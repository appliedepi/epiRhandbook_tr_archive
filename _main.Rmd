---
knit: "bookdown::render_book"
title: "The Epidemiologist R Handbook"  
description: "The Epi R Handbook is a R reference manual for applied epidemiology and public health."
author: "the handbook team"
date: "`r Sys.Date()`"
#url: 'https://github.com/nsbatra/Epi_R_handbook'
#twitter-handle: 
#cover-image: images/R_Handbook_Logo.png
site: bookdown::bookdown_site
# output: bookdown::gitbook:
#      config:
#           sharing:
#                twitter: yes
#                facebook: yes
#                whatsapp: yes
#                github: yes
documentclass: book
---





#  {-}

```{r, echo=FALSE, eval=TRUE}
options(knitr.graphics.rel_path = FALSE)
```


```{r, out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "Epi R Handbook banner beige 1500x500.png"))
# library(knitr)
# opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<meta name="description" content="The Epi R Handbook is an R reference manual for applied epidemiology and public health.">

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<!-- <span style="color: red;">**THIS IS A DRAFT.  REVIEWERS GIVE FEEDBACK AT THIS [LINK](https://forms.gle/4RNdRRLGx67xW9yq9)**.</span> -->

<!-- <span style="color: darkgreen;">**DO YOU LIKE THIS HANDBOOK? SHOULD SOMETHING BE CHANGED? PLEASE TELL US!**</span> -->

<!-- <form target="_blank" action="https://forms.gle/A5SnRVws7tPD15Js9"> -->
<!--     <input type="submit" value="FEEDBACK" /> -->
<!-- </form> -->

<!-- ======================================================= -->
<!-- ## An R reference manual for applied epidemiology and public health {.unnumbered} -->


<!-- <span style="color: brown;">**The Epi R Handbook is an R reference manual for applied epidemiology and public health.**</span> -->

<!-- ## About this handbook   -->

## R for applied epidemiology and public health {-}  

**This handbook strives to:**  

* Serve as a quick R code reference manual  
* Provide task-centered examples addressing common epidemiological problems  
* Assist epidemiologists transitioning to R  
* Be accessible in settings with low internet-connectivity via an **[offline version][Download handbook and data]**  


<!-- * Use practical epi examples - cleaning case linelists, making transmission chains and epidemic curves, automated reports and dashboards, modeling incidence and making projections, demographic pyramids and rate standardization, record matching, outbreak detection, survey analysis, survival analysis, GIS basics, contact tracing, phylogenetic trees...   -->



<!-- **How is this different than other R books?**   -->

<!-- * It is community-driven - *written for epidemiologists by epidemiologists* in their spare time and leveraging experience in local, national, academic, and emergency settings   -->

<!-- Dual-column created based on the rmarkdown cookbook here: https://bookdown.org/yihui/rmarkdown-cookbook/multi-column.html -->



<br>


:::: {style="display: flex;"}

::: {}
```{r, out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "epiRhandbook_HexSticker_500x500.png"))
```
:::


::: {.col data-latex="{0.05\textwidth}"}
\ 
<!-- an empty Div (with a white space), serving as
a column separator -->
:::

::: {}
<span style="color: black;">**Written by epidemiologists, for epidemiologists**</span>

We are applied epis from around the world, writing in our spare time to offer this resource to the community. Your encouragement and feedback is most welcome:  

* Structured **[feedback form](https://forms.gle/A5SnRVws7tPD15Js9)**  
* Email **epiRhandbook@gmail.com** or tweet **[\@epiRhandbook](https://twitter.com/epirhandbook)**  
* Submit issues to our **[Github repository](https://github.com/appliedepi/epirhandbook_eng)**  

:::

::::




<!-- ======================================================= -->
## How to use this handbook {-} 

* Browse the pages in the Table of Contents, or use the search box
* Click the "copy" icons to copy code  
* You can follow-along with [the example data][Download handbook and data]  
* See the "Resources" section of each page for further material  

**Offline version**  

See instructions in the [Download handbook and data] page.  

**Languages**  

We want to translate this into languages other than English. If you can help, please contact us.  



<!-- ======================================================= -->
## Acknowledgements {-}  

This handbook is produced by a collaboration of epidemiologists from around the world drawing upon experience with organizations including local, state, provincial, and national health agencies, the World Health Organization (WHO), Médecins Sans Frontières / Doctors without Borders (MSF), hospital systems, and academic institutions.

This handbook is **not** an approved product of any specific organization. Although we strive for accuracy, we provide no guarantee of the content in this book.  


### Contributors {-}  

**Editor:** [Neale Batra](https://www.linkedin.com/in/neale-batra/) 

**Project core team:** [Neale Batra](https://www.linkedin.com/in/neale-batra/), [Alex Spina](https://github.com/aspina7), [Amrish Baidjoe](https://twitter.com/Ammer_B), Pat Keating, [Henry Laurenson-Schafer](https://github.com/henryls1), [Finlay Campbell](https://github.com/finlaycampbell)  

**Authors**: [Neale Batra](https://www.linkedin.com/in/neale-batra/), [Alex Spina](https://github.com/aspina7), [Paula Blomquist](https://www.linkedin.com/in/paula-bianca-blomquist-53188186/), [Finlay Campbell](https://github.com/finlaycampbell), [Henry Laurenson-Schafer](https://github.com/henryls1), [Isaac Florence](www.Twitter.com/isaacatflorence), [Natalie Fischer](https://www.linkedin.com/in/nataliefischer211/), [Aminata Ndiaye](https://twitter.com/aminata_fadl), [Liza Coyer]( https://www.linkedin.com/in/liza-coyer-86022040/), [Jonathan Polonsky](https://twitter.com/jonny_polonsky), [Yurie Izawa](https://ch.linkedin.com/in/yurie-izawa-a1590319), [Chris Bailey](https://twitter.com/cbailey_58?lang=en), [Daniel Molling](https://www.linkedin.com/in/daniel-molling-4005716a/), [Isha Berry](https://twitter.com/ishaberry2), [Emma Buajitti](https://twitter.com/buajitti), [Mathilde Mousset](https://mathildemousset.wordpress.com/research/), [Sara Hollis](https://www.linkedin.com/in/saramhollis/), Wen Lin  

**Reviewers**: Pat Keating, Annick Lenglet, Margot Charette, Danielly Xavier, Esther Kukielka, Michelle Sloan, Aybüke Koyuncu, Rachel Burke, Kate Kelsey, [Berhe Etsay](https://www.linkedin.com/in/berhe-etsay-5752b1154/), John Rossow, Mackenzie Zendt, James Wright, Laura Haskins, [Flavio Finger](ffinger.github.io), Tim Taylor, [Jae Hyoung Tim Lee](https://www.linkedin.com/in/jaehyoungtlee/), [Brianna Bradley](https://www.linkedin.com/in/brianna-bradley-bb8658155), [Wayne Enanoria](https://www.linkedin.com/in/wenanoria), Manual Albela Miranda, [Molly Mantus](https://www.linkedin.com/in/molly-mantus-174550150/), Pattama Ulrich, Joseph Timothy, Adam Vaughan, Olivia Varsaneux, Lionel Monteiro, Joao Muianga  

**Illustrations**: Calder Fong  


<!-- **Editor-in-Chief:** Neale Batra  -->

<!-- **Project core team:** Neale Batra, Alex Spina, Amrish Baidjoe, Pat Keating, Henry Laurenson-Schafer, Finlay Campbell   -->

<!-- **Authors**: Neale Batra, Alex Spina, Paula Blomquist, Finlay Campbell, Henry Laurenson-Schafer, [Isaac Florence](www.Twitter.com/isaacatflorence), Natalie Fischer, Aminata Ndiaye, Liza Coyer, Jonathan Polonsky, Yurie Izawa, Chris Bailey, Daniel Molling, Isha Berry, Emma Buajitti, Mathilde Mousset, Sara Hollis, Wen Lin   -->

<!-- **Reviewers**: Pat Keating, Mathilde Mousset, Annick Lenglet, Margot Charette, Isha Berry, Paula Blomquist, Natalie Fischer, Daniely Xavier, Esther Kukielka, Michelle Sloan, Aybüke Koyuncu, Rachel Burke, Daniel Molling, Kate Kelsey, Berhe Etsay, John Rossow, Mackenzie Zendt, James Wright, Wayne Enanoria, Laura Haskins, Flavio Finger, Tim Taylor, Jae Hyoung Tim Lee, Brianna Bradley, Manual Albela Miranda, Molly Mantus, Priscilla Spencer, Pattama Ulrich, Joseph Timothy, Adam Vaughan, Olivia Varsaneux, Lionel Monteiro, Joao Muianga   -->


### Funding and support {-}  

The handbook received supportive funding via a COVID-19 emergency capacity-building grant from [TEPHINET](https://www.tephinet.org/), the global network of Field Epidemiology Training Programs (FETPs).  

Administrative support was provided by the EPIET Alumni Network ([EAN](https://epietalumni.net/)), with special thanks to Annika Wendland. EPIET is the European Programme for Intervention Epidemiology Training.  

Special thanks to Médecins Sans Frontières (MSF) Operational Centre Amsterdam (OCA) for their support during the development of this handbook.  


*This publication was supported by Cooperative Agreement number NU2GGH001873, funded by the Centers for Disease Control and Prevention through TEPHINET, a program of The Task Force for Global Health. Its contents are solely the responsibility of the authors and do not necessarily represent the official views of the Centers for Disease Control and Prevention, the Department of Health and Human Services, The Task Force for Global Health, Inc. or TEPHINET.*



### Inspiration {-}  

The multitude of tutorials and vignettes that provided knowledge for development of handbook content are credited within their respective pages.  

More generally, the following sources provided inspiration for this handbook:  
[The "R4Epis" project](https://r4epis.netlify.app/) (a collaboration between MSF and RECON)  
[R Epidemics Consortium (RECON)](https://www.repidemicsconsortium.org/)  
[R for Data Science book (R4DS)](https://r4ds.had.co.nz/)  
[bookdown: Authoring Books and Technical Documents with R Markdown](https://bookdown.org/yihui/bookdown/)  
[Netlify](https://www.netlify.com) hosts this website  


<!-- ### Image credits {-}   -->

<!-- Images in logo from US CDC Public Health Image Library) include [2013 Yemen looking for mosquito breeding sites](https://phil.cdc.gov/Details.aspx?pid=19623), [Ebola virus](https://phil.cdc.gov/Details.aspx?pid=23186), and [Survey in Rajasthan](https://phil.cdc.gov/Details.aspx?pid=19838).   -->


## Terms of Use and Contribution {-}  

### License {.unnumbered} 

<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.


Academic courses and epidemiologist training programs are welcome to use this handbook with their students. If you have questions about your intended use, email **epiRhandbook@gmail.com**.  


### Citation {.unnumbered}

Batra, Neale, et al. The Epidemiologist R Handbook. 2021. <a rel="license" href="https://zenodo.org/badge/231610102.svg"><img alt="DOI" style="border-width:0" src="https://zenodo.org/badge/231610102.svg" /></a><br />

### Contribution {.unnumbered}  

If you would like to make a content contribution, please contact with us first via Github issues or by email. We are implementing a schedule for updates and are creating a contributor guide.  

Please note that the epiRhandbook project is released with a [Contributor Code of Conduct](https://contributor-covenant.org/version/2/0/CODE_OF_CONDUCT.html). By contributing to this project, you agree to abide by its terms.


```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:index.Rmd-->

# (PART) About this book {.unnumbered}
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/cat_about_book.Rmd-->

# Önyazı ve teknik notlar { }

Bu sayfada, el kitabının hazırlanması sırasında belirlediğimiz felsefi yaklaşıma, stile ve belirli editoryal kararlara değineceğiz.



## Yaklaşım ve stil

Bu kitabın potansiyel hedef kitlesinin geniş olmasını istedik. Hem R'a yeni olan kişiler tarafından hem de "R'ın iyi uygulamalarını" ve "R'ın ipuçlarını" öğrenmek isteyen deneyimli  kullanıcıların bu kitaptan faydalanabilmesini istedik. Kitap hem kolayca erişilebilir hem de az ve öz olmalıydı. Bu nedenle yaklaşımımızı, R'de çok yeni olan birinin kodu uygulayabileceği ve kodun ne yaptığını takip edebileceği *yeterli* metin açıklamasını sağlamak olarak belirledik.

Bir kaç nokta daha:  

* Nispeten kısa örneklerin eşlik ettiği bir kod referans kitabı olarak tasarlanmıştır - R , veri bilimi üzerine kapsamlı bir ders kitabı *değildir*.
* Uygulamalı epidemiyolojide kullanmanız için *R el kitabı* olarak kapsamı sınırlandırılmıştır - uygulamalı epidemiyoloji yöntemleri veya bilimi hakkında bir kılavuz değil.
* Bu el kitabının yaşayan bir belge olması amaçlanmıştır - belirli  görevler için hazırlanan R paketleri sıklıkla güncellenir ve değişir. Bu kitapta hangilerine yer vermemiz gerektiğine dair öneri ve eleştirilerinizi memnuniyetle öğrenmek isteriz.



### R paketleri {.unnumbered}

**Çok fazla seçenek**  

R öğrenmenin en zorlu yönlerinden biri de hangi R paketinin kullanılacağını bilmektir. Bir işi çözmeye çalışırken "Hey, bunların hepsini tek bir komut satırında yapan bir R paketi var!" demeniz nadir bir durum olmayacaktır.

Bu el kitabında, her görevi tamamlamanız için size en az iki yol sunmaya çalıştık: ilki denenmiş ve doğrulanmış bir yöntem (muhtemelen **base** R veya **tidyverse** içinde) ve ikincisi o iş için özel olarak tasarlanmış bir R paketi. Belirli bir pakette sorun yaşamanız halinde birden fazla seçeneğe sahip olmanızı istiyoruz.

Paketleri belirlerken, R topluluğu tarafından test edilmiş ve onaylanmış paketlere ve yaklaşımlara öncelik verdik. Rutin bir çalışma oturumunda işinize yarayacak, stabil (çok sık değişmeyen) ve görevi basit ve temiz bir şekilde yerine getirebilecek minimal sayıda paket kullandık.

Bu el kitabı **tidyverse**'de bulunan R paket ve işlevlerine öncelik verir. Tidyverse, temel dilbilgisi ve veri yapılarını paylaşan veri bilimi için tasarlanmış bir R paketi koleksiyonudur. Tüm tidyverse paketleri, **tidyverse** paketi aracılığıyla kurulabilir veya yüklenebilir. [Tidyverse'n web sitesinde](https://www.tidyverse.org/) daha fazlasını okuyabilirsiniz.

Uygun yerlerde, kurulum sırasında R ile birlikte yüklenen **base** paket ve fonksiyonlarıyla ilişkili kod seçeneklerini de ekledik. Bunu, bu kitabın okuyucularından bazılarının ekstra paketleri indirmek için güvenilir bir internete sahip ol(a)mama ihtimaline karşılık yaptık.

**Fonksiyonları paketlerle ilişkilendirme**

R eğitim ve rehberlerinde bir fonksiyona ilişkin kodun anlatılıp, kullanılan paketin hiç değinilmemesine şahit olmuşsunuzdur. Bu durum sinir bozucudur! İşte biz bunu size yaşatmaktan kaçınmaya çalıştık.

Açıklama metinlerinde paket adları kalın harflerle (örn. **dplyr**) ve fonksiyonları `mutate()` şeklinde yazılır. Bir fonksiyonun hangi paketten geldiğini, ya en yakındaki metinde referanslayarak ya da kodu `dplyr::mutate()` şeklinde yazarak size açıklamaya çalıştık. Başta gereksiz görünebilir ancak bunu yukarıda bahsettiğimiz amaç doğrultusunda, bilerek yapıyoruz.

Paketler ve fonksiyonları hakkında daha fazla bilgi edinmek için [R basics] sayfasına bakabilirsiniz.



### Kodlama stili {.unnumbered}

El kitabında sık sık "yeni satırlar" kullanıyoruz, bu da kodumuzun "uzun" görünmesine neden olabiliyor. Bunun birkaç sebebi var:

* Kodun her küçük parçasına bitişik `#` ile açıklayıcı yorumlar yazabiliriz.
* Genellikle daha uzun (dikey) kodun okunması daha kolaydır.
* Kodların dar bir ekranda okunması daha kolaydır (ekranı yana kaydırmanıza gerek kalmaz).
* Girintiler sayesinde hangi argümanların hangi fonksiyona ait olduğunu daha kolay anlayabilirsiniz.

Sonuç olarak, *aşağıdaki gibi* yazılabilecek kod:

```{r, eval=F}
linelist %>% 
  group_by(hospital) %>%  # satırları hastane (hospital) olarak gruplandır
  slice_max(date, n = 1, with_ties = F) # eğer tarih (date) ile eşleşirse ilk satırı al
```

...şu şekilde yazılır:  

```{r, eval=F}
linelist %>% 
  group_by(hospital) %>% # satırları hastane (hospital) olarak gruplandır
  slice_max(
    date,                # maksimum tarih değerine grubu sırala
    n = 1,               # gruptaki satırlardan sadece ilkini al 
    with_ties = F)       # eğer tarih (date) ile eşleşirse ilk satırı al
```

R kodu genel olarak yeni satır veya girintilerden etkilenmez. Kodu yazarken, virgülden sonra yeni bir satır başlatırsanız, program yeni satıra otomatik girinti uygular.

Ayrıca, okunması daha kolay olduğu için kodu yazarken birçok boşluk kullandık (örneğin, 'n=1' yerine 'n = 1'). Siz de kodunuzu yazarken onu okuyabilecek insanları düşünerek yazmalısınız!



### Terminoloji {.unnumbered}  

Bu el kitabında, genellikle "değişkenler" ve "gözlemler" yerine "sütunlar" ve "satırlar"a atıfta bulunuyoruz. ["Tidy verileri"](https://tidyr.tidyverse.org/articles/tidy-data.html) ile ilgili bu makalede açıklandığı gibi, epidemiyolojik istatistiksel veri setlerinin çoğu yapısal olarak satır, sütun ve değerlerden oluşur.

*Değişkenler* aynı temel özelliği ölçen değerleri içerir (yaş grubu, çıktı veya başlangıç tarihi gibi). *Gözlemler* aynı birimde ölçülen tüm değerleri içerir (örneğin bir kişi, alan veya laboratuvar numunesi vb.). Dolayısıyla bu yönleri somut olarak tanımlamak daha zor olabilmektedir.

"Tidy" veri kümelerinde her sütun bir değişken, her satır bir gözlem ve her hücre de tek bir değeri ifade etmektedir. Ancak karşılaştığınız bazı veri kümeleri bu kalıba sığmaz - "geniş" biçimli bir veri kümesinin birkaç sütuna bölünebilen değişkenleri olabilir ([Pivoting data] sayfasındaki bir örneğe bakın). Benzer şekilde, gözlemler de birkaç satıra bölünebilir.

Bu el kitabı çoğunlukla, verileri yönetmek ve işlemek üzerine odaklanmıştır. O nedenle satır ve sütunlarda somut verilere atıfta bulunmayı, daha soyut olan "gözlem" ve "değişkenler"e tercih ettik. Bu yaklaşımımızın istisnası, daha fazla değişken ve gözlem referansıyla karşılaşacağınız veri analizi sayfalarıdır.



### Notlar {.unnumbered} 

El kitabında karşılaşabileceğiniz not türleri şunlardır:  

<span style="color: black;">**_NOT:_** Bu bir nottur.</span>  
<span style="color: darkgreen;">**_İPUCU:_** Bu bir ipucudur.</span>  
<span style="color: orange;">**_DİKKAT:_** Bu dikkatli yaklaşmanızı tavsiye eden bir nottur.</span>  
<span style="color: red;">**_TEHLİKE:_** Bu bir uyarıdır.</span>  



## Editöryal Kararlar  

Aşağıda, paket ve işlev seçimiyle ilgili önemli editoryal kararları sizinle paylaşıyoruz. Bizimle aynı fikirde değilseniz veya değerlendirilmesi için yeni bir araç önermek isterseniz, lütfen [Github sayfamıza](https://github.com/appliedepi/epirhandbook_eng) katılın ve yeni bir sohbet başlatın.


**Paket, fonksiyon ve diğer editoryal kararlar tablosu**  


Konu           |     Paket      |   Çıktı              |    Rasyoneli   
----------------- | --------------------|------------------------|-----------------------------------------------
Genel kodlama yaklaşımı|**tidyverse**, **data.table**, **base**|**tidyverse**, **data.table** üzerinde bir sayfa ve interneti olmayan okuyucular için **base** alternatifleri|**tidyverse** okunabilir, evrensel, en çok öğretilen pakettir. 
Paket yükleme|`library()`,`install.packages()`, `require()`, **pacman**|**pacman**|Çoklu paket indirme/yükleme süreçlerini kısaltır ve basitleştirir.
İçe ve dışa aktarma|**rio**, ve diğer pek çok paketler|**rio**|birçok dosya türü için kolaylık sağlar.
İstatistik özetleri için gruplandırma|**dplyr** `group_by()`, **stats** `aggregate()`|**dplyr** `group_by()`|**tidyverse** vurgusu ile tutarlıdır.
Pivotlama|**tidyr** (pivot fonksiyonları), **reshape2** (melt/cast), **tidyr** (spread/gather)|**tidyr** (pivot fonksiyonları)|**reshape2** artık kullanımda değil, **tidyr** v1.0.0 itibariyle pivot fonksiyonlarını kullanmaktadır.
Sütun adlarını temizleme|**linelist**, **janitor**|**janitor**|Paketlerin birlikte kullanımı vurgulanmaktadır.
Epiweeks |**lubridate**, **aweek**, **tsibble**, **zoo**|genelde **lubridate**, özel durumlarda diğer paketler| **lubridate** esnek, tutarlı ve diğer paketleri koruyan bir seçenektir.  
ggplot etiketleri |`labs()`, `ggtitle()`/`ylab()`/`xlab()` |`labs()` |tüm etiketler tek bir yerde, kullanımı basittir.  
Faktöre çevir |`factor()`, **forcats**|**forcats**|çeşitli fonksiyonları da aynı komutta faktöre dönüşür.
Epidemi eğrileri|**incidence**, **ggplot2**, **EpiCurve**|**incidence2** hızlıdır, **ggplot2** ise detaylı ve güvenilirdir.
Birleştirme|`paste()`, `paste0()`, `str_glue()`, `glue()`|`str_glue()`|**stringr** fonksiyonlarını içerir; yapıştır fonksiyonlarından daha basit bir sentaks (sözdizimi) vardır.


## Büyük güncellemeler  


Tarih           |Açıklama        
---------------| ------------------------------------------    
10 May 2021    |Versiyon 1.0.0'ın yayınlanması    


## Oturum bilgisi (R, RStudio, packages)  

Aşağıda, bu el Kitabının hazırlanması sırasında kullanılan R, RStudio, R paketleri ve sürümlerine ilişkin bilgiler yer almaktadır. 


```{r}
sessioninfo::session_info()
```




```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/editorial_style.Rmd-->

# El Kitabı ve verileri indirme  


<!-- Note to self: If you want to create a download link to Github, right-click the "View Raw" button on Github, copy the address, and use that in the HTML below. -->




## Çevrimdışı el kitabı indirme

İnternet erişiminiz olmasa bile bu el kitabını web tarayıcınızda görüntüleyebilirsiniz. Bunun için HTML dosyalarını indirmeniz gerekmektedir. Epi R El Kitabını çevrimdışı kullanmayı düşünüyorsanız, bilmeniz gereken gereken birkaç nokta mevcut:

* Dosyaları açtığınızda resimler ve İçindekiler'in yüklenmesi bir veya iki dakika sürebilir.
* Çevrimdışı kitabın düzeni biraz farklıdır - solda İçindekiler Tablosu olan uzun bir alan görecekseniz. Belirli terimleri aramak için Ctrl+F (Cmd-F) tuşlarını kullanabilirsiniz.
* İnternet bağlantınızı kesmeden önce uygun R paketlerini kurmanıza yardımcı olması için [Önerilen paketler] sayfasına bakın.
* Tüm örnek verileri içeren R paketinizi **epirhandbook** kurun. (kurulum işlemi aşağıda açıklanmıştır)

**El Kitabını iki farklı yoldan indirebilirsiniz:**  



### İndirme linkini kullanarak {.unnumbered}  

Linke hızlıca erişebilmek için, **bu linki sağ fare tuşunuzla tıklayın** [link](https://github.com/appliedepi/epirhandbook_eng/raw/master/offline_long/Epi_R_Handbook_offline.html) **ve "Farklı Kaydet" seçeneğini seçin**.  

Mac kullanıyorsanız, Cmd'ye basılı tutarak farenizle tıklayın. Cep telefonu kullanıyorsanız, bağlantıyı basılı tutun ve "Bağlantıyı kaydet"i seçin. Kitap cihazınıza indirilecektir. Görseller olmadan HTML kodu içeren bir ekran görürseniz, yukarıdaki talimatları uyguladığınızdan emin olun veya ikinci seçeneği deneyin.



### R paketimizi kullanın {.unnumbered}  

Sizin için **epirhandbook** adında bir R paketi tasarladık. El kitabını bilgisayarınıza indirebilmek için `download_book()` adlı bir fonksiyon oluşturduk. Bu fonksiyonu R programınızda kullanabilirsiniz.


Bu pakette ayrıca `get_data()` adlı bir fonksiyon da mevcuttur. Bu fonskiyonla tüm örnek verileri bilgisayarınıza indirebilirsiniz.

[Github sayfamızdan *appliedepi*](https://github.com/appliedepi/epirhandbook) **epirhandbook** R paketini indirmek için aşağıda verdiğimiz kodu kullanabilirsiniz. İndireceğiniz bu paket CRAN'da olmadığı için (Github'da kayıtlı) `p_install_gh()` özel fonksiyonunu kullanmanız gerekecektir.  


```{r, eval=F}
# Epi R El Kitabı paketinin en son sürümünü indirin
pacman::p_install_gh("appliedepi/epirhandbook")
```

Şimdi, mevcut R oturumunuzda kullanmak üzere paketi yükleyin: 

```{r, eval=F}
# paketi kullanmak için yükleyin
pacman::p_load(epirhandbook)
```

Ardından, el kitabını bilgisayarınıza indirmek için paketin `download_book()` (boş parantez ile) fonksiyonunu çalıştırın. RStudio kullandığınızı varsayarsak, dosyaları kaydetmeden önce konumu seçmenize izin veren bir pencere açılacaktır.  

```{r, eval=F}
# çevrimdışı el kitabını bilgisayarınıza indirin
download_book()
```





## Örnek bazlı verileri indirme 

El kitabındaki örnekleri "takip etmek" için örnek veri ve çıktıları indirebilirsiniz.  

### R paketimizi kullanma {.unnumbered}  

Tüm verileri indirmenin en kolay yolu, R paketimiz olan **epirhandbook** kurmaktır. Bu paket tüm örnek verileri bilgisayarınızda seçtiğiniz bir klasöre kaydeden `get_data()` fonksiyonunu içerir.

R paketini **epirhandbook**u kurmak için aşağıdaki kodu çalıştırın. Paketimiz CRAN'da bulunmamaktadır. Bu yüzden kurmak için `p_install_gh()` fonksiyonunu kullanın. Parantez içindeki referans, Github organizasyonumuza ("*appliedepi*") ve **epirhandbook** proje adına atıfta bulunnmaktadır.

```{r, eval=F}
# Epi R El Kitabı paketinin en son sürümünü indirin
pacman::p_install_gh("appliedepi/epirhandbook")
```


Şimdi, mevcut R oturumunuzda kullanmak üzere paketi yükleyin: 

```{r, eval=F}
# paketi kullanmak için yükleyin
pacman::p_load(epirhandbook)
```

Bu işlemlerin ardından, örnek verileri bilgisayarınıza indirmek için paketin `get_data()` fonksiyonunu kullanın. Örnek verilerin *tamamını* indirmek için `get_data("all")` komutunu çalıştırın veya yalnızca bir dosyayı almak için tırnak işaretleri içinde ilgili dosya adı ve uzantısını yazın. 

Veriler paketle birlikte indirilmiş olacaktır. Burada yapmanız gereken tek şey bilgisayarınızda indireceğiniz klasörü belirlemektir. İndirme konumunu seçmenize izin veren bir açılır pencere karşınıza çıkacaktır. Örnek veri ve çıktılar dahil yaklaşık 30 dosya olduğundan indirme konumunda yeni bir "veri" klasörü oluşturmanızı öneririz.

```{r, eval=F}
# tüm örnek verileri bilgisayarınızdaki bir klasöre indirin
get_data("all")

# bilgisayarınızdaki bir klasöre yalnızca belli bir satırın verilerini indirin
get_data(file = "linelist_cleaned.rds")

```


```{r, eval=F}
# belirli bir dosyayı bilgisayarınızdaki bir klasöre indirin
get_data("linelist_cleaned.rds")
```

İstediğiniz dosyayı bilgisayarınıza kaydetmek için `get_data()`yı kullandıktan sonra, yine de onu R'a aktarmanız gerekecektir. Ayrıntılar için [İçe ve dışa aktar] sayfasına bakabilirsiniz.

Dilerseniz bu el kitabında kullanılan tüm verileri Github sayfamızın **["data" klasöründe](https://github.com/appliedepi/epirhandbook_eng/tree/master/data)** inceleyebilirsiniz.



### Tek tek indirme {.unnumbered}  

Bu seçenek, dosyaya özel bir bağlantı veya R komutu aracılığıyla Github sayfamızdan dosyaları sırasıyla indirmeyi içermektedir. Bazı dosya türleri indirme düğmesine izin verirken, diğerleri bir R komutuyla indirilebilir.


#### Vaka satır listesi {.unnumbered}

Aşağıdaki linkler, **outbreaks** paketindeki `ebola_sim` uygulama veri kümesinde yer alan kitabın ekibi tarafından genişletilen kurgusal bir Ebola salgına aittir.

* <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_raw.xlsx' class='download-button'>"Ham" satır listesini indirmek için tıklayın (.xlsx)</span></a>. "Ham" vaka satır listesi, dağınık veriler içeren bir excel tablosudur. [Verileri temizleme ve temel işlevler] sayfasını takip etmek için bunu kullanabilirsiniz.  

* <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>"Temiz" satır listesini indirmek için tıklayın (.rds)</a>. Bu el kitabının satır listesini kullanan diğer tüm sayfaları için bu dosyayı kullanabilirsiniz. Rds dosyası, sütun sınıflarını koruyan R'a özgü bir dosya türüdür. Bu, verileri R'a aktardıktan sonra temizlik yapma ihtiyacını azaltır.

*Diğer dosyalar:*  

* <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.xlsx' class='download-button'>"Temiz" satır listesini Excel dosyası olarak indirmek için tıklayın</a>

* Temizleme sayfasının bir kısmı bir "temizleme sözlüğü" (.csv dosyası) kullanır. Aşağıdaki komutları çalıştırarak doğrudan R'a yükleyebilirsiniz:

```{r, eval=F}
pacman::p_load(rio) # rio paketini kurun/yükleyin

# dosyayı doğrudan Github'dan içe aktarın
cleaning_dict <- import("https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/cleaning_dict.csv")
```


#### Sıtma sayısı verileri {#data_malaria .unnumbered}  

Bu veriler, yaş grubu, tesis ve güne göre sıtma vakalarının kurgusal sayılarıdır. Rds dosyası, sütun sınıflarını koruyan R'a özgü bir dosya türüdür. Bu, verileri R'a aktardıktan sonra temizlik yapma ihtiyacını azaltır. 

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/malaria_facility_count_data.rds' class='download-button'>
	Sıtma sayılarını (.rds dosyası)
	<span>indirmek için tıklayın.</span>
</a>


#### Likert ölçekli veri {.unnumbered}  

Bunlar, [Demografik Piramitler ve Likert Ölçekleri] sayfasında kullanılan likert tarzı bir anketten alınan kurgusal verilerdir. Aşağıdaki komutları çalıştırarak bu verileri doğrudan R'a yükleyebilirsiniz:

```{r, eval=F}
pacman::p_load(rio) # rio paketini kurun/yükleyin

# dosyayı doğrudan Github'dan içe aktarın
likert_data <- import("https://raw.githubusercontent.com/nsbatra/Epi_R_handbook/master/data/likert_data.csv")
```


#### Esnek pano {.unnumbered}  

Aşağıda [R Markdown ile Kontrol Panelleri]'ndeki sayfayla ilişkili dosyaya bağlantılar verilmiştir:

* Salgın panosu ile ilgili R Markdown'ı indirmek için [linke](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/flexdashboard/outbreak_dashboard.Rmd) sağ fare tuşuyla tıklayın (Mac için Cmd + tıkla) ve "Farklı Kaydet" seçeneğini seçin.  
* HTML kontrol panelini indirmek için [linke](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/flexdashboard/outbreak_dashboard_test.html) sağ fare tuşuyla tıklayın (Mac için Cmd + tıkla) ve "Farklı Kaydet" seçeneğini seçin.  

#### Temaslı İzleme {.unnumbered} 

[Temaslı İzleme] sayfası, aşağıdaki örnek verileri kullanarak kişi izleme verilerinin analizini göstermektedir. [Go.Data](https://github.com/WorldHealthOrganization/godata/tree/master/analytics/r-reporting). Sayfada kullanılan veriler aşağıdaki linklere tıklanarak .rds dosyaları olarak indirilebilir:

<a href='https://github.com/WorldHealthOrganization/godata/blob/master/analytics/r-reporting/data/cases_clean.rds?raw=true' class='download-button'>
	Vaka inceleme verilerini (.rds dosyası)
	<span>indirmek için tıklayın.</span>
</a>

<a href='https://github.com/WorldHealthOrganization/godata/blob/master/analytics/r-reporting/data/contacts_clean.rds?raw=true' class='download-button'>
	Temaslı kayıt verilerini (.rds dosyası)
	<span>indirmek için tıklayın.</span>
</a>

<a href='https://github.com/WorldHealthOrganization/godata/blob/master/analytics/r-reporting/data/followups_clean.rds?raw=true' class='download-button'>
	Temaslı takip verilerini (.rds dosyası)
	<span>indirmek için tıklayın.</span>
</a>



<span style="color: black;">**_NOT:_** Diğer yazılımlarda (örn. KoBo, DHIS2 Tracker, CommCare) yapılandırılmış temaslı izleme verileri farklı görünebilir. Bu sayfa için alternatif örnek veri veya içeriğe katkıda bulunmak isterseniz lütfen [bize ulaşın](#contact_us).</span> 

<span style="color: darkgreen;">**_İPUCU:_** Go.Data kullanmak istiyorsanız ve örneklerinizin API'sine bağlanmak istiyorsanız, İçe ve Dışa Aktarma sayfasına [(API bölümü)](#import_api) ve [Go.Data Uygulama Topluluğu](https://community-godata.who.int/)'na bakabilirsiniz.</span>


#### GIS {.unnumbered}  

Şekil dosyaları, her biri farklı uzantıya sahip birçok alt bileşen dosyasına sahiptir. Bir dosya ".shp" uzantısına sahipken, bir diğeri ".dbf", ".prj" vb. uzantıya sahip olabilir.

[GIS temel bilgileri] sayfası, sıkıştırılmış şekil dosyalarını indirebileceğiniz *Humanitarian Data Exchange* web sitesine ait bağlantıları barındırmaktadır.

Örneğin sağlık tesisi puan verileri [buradan](https://data.humdata.org/dataset/hotosm_sierra_leone_health_facilities) indirilebilir. "hotosm_sierra_leone_health_facilities_points_shp.zip" dosyasını indirin. Bilgisayarınıza kaydettikten sonra, klasörü "açın". Farklı uzantılara sahip birkaç dosya göreceksiniz (örneğin ".shp", ".prj", ".shx") - bunların tümü bilgisayarınızda aynı klasöre kaydedilmelidir. Ardından, R'a aktarmak için ".shp" dosyasının dosya yolunu ve adını **sf** paketinden `st_read()` fonksiyonuna ekleyin ([GIS temel bilgileri] sayfasında açıklandığı gibi)

Tüm örnek verileri indirmek için Seçenek 1'i izlediyseniz (R paketimiz **epirhandbook** aracılığıyla), şekil dosyalarının tamamı içeride olacaktır.  


Alternatif olarak, şekil dosyalarını Github sayfamızdaki "data" klasöründen indirebilirsiniz ("gis" alt klasörüne bakın). Ancak, *her bir* alt dosyayı ayrı ayrı bilgisayarınıza indirmeniz gerekeceğini unutmayın. Github'da her bir dosyaya tek tek tıklayın ve "İndir" butonuna basarak indirin. Aşağıda örnek olarak, "sle_adm3" şekil dosyasının Github bölümünde kayıtlı birçok alt dosyadan oluştuğunu görebilirsiniz.

```{r out.height = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "download_shp.png"))
```


#### Filogenetik ağaçlar {.unnumbered}  

[Filogenetik ağaçlar] sayfayasında, 299 Shigella sonnei örneğinin tüm genom dizilimi ve buna karşılık gelen vaka verilerinden (bir metin dosyası halinde) oluşturulan filogenetik ağacı Newick dosyası göreceksiniz. Belçika örneklerinden elde edilen veriler, ECDC EUPHEM asistanı tarafından yürütülen bir proje kapsamında üretilmiştir. Salmonella ve Shigella'dan elde edilen bu veriler Belçika NRC'si tarafından sağlanmaktadır.Bu veriler yayına dönüştürülme aşamasındadır. Kullanılan uluslararası veriler kamuya açık veri tabanlarına (ncbi) kayıtlı ve yayınlanmış verilerden elde edilmiştir.

* "Shigella_tree.txt" filogenetik ağaç dosyasını indirmek için  [linke](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/phylo/Shigella_tree.txt) sağ fare tuşuyla tıklayın (Mac için Cmd + tıkla) ve "Farklı Kaydet" seçeneğini seçin.  
* Her örnekle ilgili ek bilgiler içeren "sample_data_Shigella_tree.csv" dosyasını indirmek için  [linke](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/phylo/sample_data_Shigella_tree.csv) sağ fare tuşuyla tıklayın (Mac için Cmd + tıkla) ve "Farklı Kaydet" seçeneğini seçin.  
* Yeni oluşturulan altküme ağacını görmek için  [linke](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/phylo/Shigella_subtree_2.txt) sağ fare tuşuyla tıklayın (Mac için Cmd + tıkla) ve "Farklı Kaydet" seçeneğini seçin.  


Daha sonra sayfada açıklandığı gibi **ape** paketinden `read.tree()` ile .txt dosyalarını içe aktarabilirsiniz.

```{r, eval=F}
ape::read.tree("Shigella_tree.txt")
```


#### Standardizasyon {.unnumbered}  

[Standartlaştırılmış oranlar] ile ilgili sayfaya bakın. Verileri doğrudan internetteki Github sayfamızdan aşağıdaki komutlarla R oturumunuza yükleyebilirsiniz:


```{r, eval=F}
# rio paketini kurun/yükleyin
pacman::p_load(rio) 

##############
# A Ülkesi
##############
# A ülkesi için demografi bilgilerini Github'dan içeri aktarın
A_demo <- import("https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics.csv")

# A ülkesi için ölüm bilgilerini Github'dan içeri aktarın
A_deaths <- import("https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryA.csv")

##############
# B Ülkesi
##############
# B ülkesi için demografi bilgilerini Github'dan içeri aktarın
B_demo <- import("https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics_2.csv")

# B ülkesi için ölüm bilgilerini Github'dan içeri aktarın
B_deaths <- import("https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryB.csv")


###############
# Referans
###############
# Referans demografik bilgileri Github'dan içeri aktarın
standard_pop_data <- import("https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/world_standard_population_by_sex.csv")
```



#### Zaman serileri ve salgın tespiti {#data_outbreak .unnumbered}  

[Zaman serisi ve salgın tespiti] sayfasında Almanya 2002-2011'de rapor edilen Campylobacter vakalarını **surveillance** R paketinde olduğu gibi kullanıyoruz. (*ek bilgi:* bu veri seti orijinalinden uyarlanmıştır, 2011'in son 3 aylık verileri demo amacıyla silinmiştir)

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/time_series/campylobacter_germany.xlsx' class='download-button'>
	Almanya Campylobacter verilerini (.xlsx)
	<span> indirmek için tıklayın.</span>
</a>

Kitapta ayrıca Almanya 2002-2011 iklim verilerini kullanıyoruz (santigrat derece cinsinden sıcaklık ve milimetre cinsinden yağış bilgileri mevcut). Bu veriler, **ecmwfr** paketi kullanılarak EU Copernicus uydu yeniden analiz veri setinden indirilmiştir. Bunların hepsini indirmeniz ve zaman serisi sayfasında açıklandığı gibi `stars::read_stars()` ile içe aktarmanız gerekecektir.

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/time_series/weather/germany_weather2002.nc' class='download-button'>
	Almanya Hava Durumu 2002 verilerini(.nc dosyası)
	<span> indirmek için tıklayın.</span>
</a> 

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/time_series/weather/germany_weather2003.nc' class='download-button'>
	Almanya Hava Durumu 2003 verilerini (.nc dosyası)
	<span> indirmek için tıklayın.</span>
</a> 

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/time_series/weather/germany_weather2004.nc' class='download-button'>
	Almanya Hava Durumu 2004 verilerini (.nc dosyası)
	<span> indirmek için tıklayın.</span>
</a> 

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/time_series/weather/germany_weather2005.nc' class='download-button'>
	Almanya Hava Durumu 2005 verilerini (.nc dosyası)
	<span> indirmek için tıklayın.</span>
</a> 

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/time_series/weather/germany_weather2006.nc' class='download-button'>
	Almanya Hava Durumu 2006 verilerini (.nc dosyası)
	<span> indirmek için tıklayın.</span>
</a> 

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/time_series/weather/germany_weather2007.nc' class='download-button'>
	Almanya Hava Durumu 2007 verilerini (.nc dosyası)
	<span> indirmek için tıklayın.</span>
</a> 

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/time_series/weather/germany_weather2008.nc' class='download-button'>
	Almanya Hava Durumu 2008 verilerini (.nc dosyası)
	<span> indirmek için tıklayın.</span>
</a> 

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/time_series/weather/germany_weather2009.nc' class='download-button'>
	Almanya Hava Durumu 2009 verilerini (.nc dosyası)
	<span> indirmek için tıklayın.</span>
</a> 

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/time_series/weather/germany_weather2010.nc' class='download-button'>
	Almanya Hava Durumu 2010 verilerini (.nc dosyası)
	<span> indirmek için tıklayın.</span>
</a> 

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/time_series/weather/germany_weather2011.nc' class='download-button'>
	Almanya Hava Durumu 2011 verilerini (.nc dosyası)
	<span> indirmek için tıklayın.</span>
</a>



#### Anket analizi {#data_survey .unnumbered}  

[Anket analizi](https://epirhandbook.com/survey-analysis.html) sayfası için MSF OCA anket şablonlarına dayalı kurgusal ölüm anketi verilerini kullandık. Bu kurgusal veriler ["R4Epis" projesi](https://r4epis.netlify.app/) kapsamında oluşturulmuştur.

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/surveys/survey_data.xlsx' class='download-button'>
	Kurgusal anket verilerini (.xlsx)
	<span> indirmek için tıklayın.</span>
</a>

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/surveys/survey_dict.xlsx' class='download-button'>
	Kurgusal anket veri sözlüğünü (.xlsx)
	<span> indirmek için tıklayın.</span>
</a>

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/surveys/population.xlsx' class='download-button'>
	Kurgusal anket nüfus verilerini (.xlsx)
	<span> indirmek için tıklayın.</span>
</a>




#### Shiny {#data_shiny .unnumbered}  

[Shiny Gösterge Tabloları] ile ilgili sayfa, sıtma verilerini görüntülemek için uygulamanın yapısını göstermektedir.

Shiny uygulamasını oluşturan R dosyalarını indirmek için:  

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/malaria_app/app.R' class='download-button'>Shiny uygulaması için hem kullanıcı arayüzünü hem de sunucu kodunu içeren app.R dosyasını<span> indirmek için burayı tıklayabilirsiniz.</span></a>

<a href='https://github.com/appliedepi/epirhandbook_eng/blob/master/data/malaria_app/data/facility_count_data.rds' class='download-button'>Shiny uygulaması için sıtma verilerini içeren property_count_data.rds dosyasını indirmek için burayı tıklayabilirsiniz.<span></a> `here()` fonksiyonunun doğru çalışması için onu bir "data" klasöründe saklamayı unutmayın.

<a href='https://github.com/appliedepi/epirhandbook_eng/blob/master/data/malaria_app/global.R' class='download-button'>Sayfada açıklandığı gibi, uygulama açılmadan önce çalışması gereken global.R dosyasını indirmek için burayı tıklayabilirsiniz.<span></a> Sayfada açıklandığı gibi, uygulama açılmadan önce çalıştırmayı unutmayın.

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/malaria_app/funcs/plot_epicurve.R' class='download-button'>global.R tarafından sağlanan plot_epicurve.R dosyasını indirmek için burayı tıklayabilirsiniz.<span></a> `here()` fonksiyonlarının doğru çalışması için onu bir "funcs" klasöründe saklamayı unutmayın.


```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/data_used.Rmd-->

# (BÖLÜM) Temel Bilgiler {.unnumbered}
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/cat_basics.Rmd-->

# R'ın Temelleri

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "basics_header_close.png"))
```

Hoş geldiniz!

Bu sayfa, R'ın temellerini gözden geçirmektedir. Kapsamlı bir eğitim olması amaçlanmamıştır. Ancak temel bilgileri sağlar ve hatırlamanız için faydalı olabilir. İleri ve daha kapsamlı eğitimler için ilgili [Öğrenme kaynağı](#learning) bölüme geçiş yapılabilir. 

Bu sayfanın bazı bölümleri [R4Epis projesinden](https://r4epis.netlify.app/) izin alınarak uyarlanmıştır.

STATA, SAS veya Excel'den R'a geçişle ilgili ipuçları için [R'a Geçiş] hakkındaki sayfaya bakabilirsiniz.

```{r, echo=F}
# temizlenmiş ebola satır listesini içe aktar
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
pacman::p_load(apyramid)
```

<!-- ======================================================= -->

## Neden R Kullanıyoruz?

[R proje web sitesinde](https://www.r-project.org/about.html) belirtildiği gibi, R, istatistiksel hesaplama ve grafikler için bir programlama dili ve ortamıdır. Çok yönlü, genişletilebilir ve topluluk odaklıdır.

**Maliyet**

R'ın kullanımı ücretsizdir! Açık kaynak ve ücretsiz olması yönünde topluluğun ciddi bir etik duruşu vardır.

**Yeniden üretilebilirlik**

Veri yönetiminizi ve analizinizi bir programlama dili aracılığıyla yürütmek (Excel'e veya başka bir öncelikli tıklama/manuel araçla karşılaştırıldığında), **tekrarlanabilirliği** artırır, **hata algılamayı** kolaylaştırır ve iş yükünüzü hafifletir.

**Topluluk**

R kullanıcı topluluğu kalabalık ve işbirlikçidir. Gerçek hayattaki sorunları ele almak için yeni paketler ve araçlar günlük olarak geliştirilir ve kullanıcı topluluğu tarafından incelenir. Örnek olarak, [R-Ladies](https://rladies.org/), amacı R topluluğunda cinsiyet çeşitliliğini teşvik etmek olan dünya çapında bir kuruluştur ve R kullanıcılarının en büyük kuruluşlarından biridir. Muhtemelen kullanmak üzere olduğunuz bir bölümleri vardır!

## Anahtar Kelimeler

**RStudio** - RStudio, **R**'ın daha kolay kullanımı için bir Grafik Kullanıcı Arayüzüdür (GUI). Daha fazlasını [RStudio bölümünde](#rstudio) okuyabilirsiniz.

**Objects** - R'da sakladığınız her şey - veri kümeleri, değişkenler, köy adlarının bir listesi, toplam nüfus sayısı, hatta grafikler gibi çıktılar - *bir isim atanan* nesnelerdir ve *sonraki komutlarda* başvurulabilir. Daha fazlasını [Nesneler bölümünde](#objects) okuyabilirsiniz.

**Functions** - Fonksiyon, girdileri kabul eden ve çıktıya dönüştüren bir kod işlemidir. Daha fazlasını [Fonksiyonlar bölümünde](#Fonksiyonlar) okuyabilirsiniz.

**Packages** -  R paketi, aslında paylaşılabilir fonksiyonlar paketidir. Daha fazlasını [Paketler bölümünde](#packages) okuyabilirsiniz.

**Scripts** - Komut dosyası, komutlarınızı tutan belge dosyasıdır. Daha fazlasını [Komut Dosyaları bölümünde](#scripts) okuyabilirsiniz.

## Öğrenme Kaynakları {#learning}

### RStudio İçindeki Kaynaklar {.unnumbered}

**Yardım dosyaları**

R paketleri ve belirli fonksiyonlarla ilgili belgeler için RStudio "Yardım" sekmesini arayın. Bu, Dosyaları, Grafikleri ve Paketleri de içeren bölmenin içindedir (genellikle sağ alt bölmededir). Kısayol olarak, ilgili Yardım sayfasını açmak için bir soru işaretinden sonra R konsoluna bir paketin veya fonksiyonun adını da yazabilirsiniz. Kesme işareti eklemeyin.

Örneğin: `?filter` veya `?diagrammeR`.

**Etkileşimli öğreticiler**

RStudio *içinde* etkileşimli olarak R öğrenmenin birkaç yolu vardır.

RStudio'nun kendisi, [**learnr**](https://blog.rstudio.com/2020/02/25/rstudio-1-3-integrated-tutorials/) R paketi tarafından desteklenen bir eğitim bölmesi sunar. Basitçe bu paketi kurabilir ve sağ üst RStudio bölmesindeki (Ortam ve Geçmiş sekmelerini de içeren) yeni "Tutorial" sekmesi aracılığıyla bir öğretici açabilirsiniz.

R paketi [**swirl**](https://swirlstats.com/), R Konsolunda etkileşimli kurslar sunar. Bu paketi kurun ve yükleyin, ardından R konsolunda `swirl()` (boş parantezler) komutunu çalıştırın. Konsolda istemlerin göründüğünü göreceksiniz. Konsola yazarak yanıt verin. Seçtiğiniz bir kurs boyunca size rehberlik edecektir.

### Kopya Kağıtları {.unnumbered}

[RStudio web sitesinde](https://rstudio.com/resources/cheatsheets/) birçok PDF "kullanımı kolaylaştırıcı belge/ kopya kağıtları" bulunmaktadır, örneğin:

- **forcats** paketini içeren faktörler\
- **lubridate** paketi ile tarihler ve saatler\
- **stringr** paketi içeren dizeler\
- **purrr** paketi ile tekrarlanan işlemler\
- içeri_veri_aktar\
- **dplyr** paketi ile veri dönüştürme hile sayfası\
- R Markdown (PDF, Word, Powerpoint... gibi belgeler oluşturmak için)\
- Shiny (etkileşimli web uygulamaları oluşturmak için)\
- **ggplot2** paketi ile veri görselleştirme\
- Haritacılık (GIS)\
- **broşür** paketi (etkileşimli haritalar)\
- R ile Python (**reticulate** paketi)

Bu, özellikle [Excel kullanıcıları](https://jules32.github.io/r-for-excel-users/) için çevrimiçi bir R kaynağıdır.

### Twitter {.unnumbered}

<!-- R, ipuçlarını, kısayolları ve haberleri öğrenebileceğiniz canlı bir twitter topluluğuna sahiptir - şu hesapları takip edin: -->

-   Bizi Takip Edin! [\@epiRhandbook](https://twitter.com/epirhandbook)\
-   R Function A Day [\@rfuntionaday](https://twitter.com/rfunctionaday) *muazzam* bir kaynak\
-   R for Data Science [\@rstats4ds](https://twitter.com/rstats4ds?lang=en)\
-   RStudio [\@RStudio](https://twitter.com/rstudio?lang=en)\
-   RStudio Tips [\@rstudiotips](https://twitter.com/rstudiotips)\
-   R-Bloggers [\@Rbloggers](https://twitter.com/Rbloggers)\
-   R-ladies [\@RLadiesGlobal](https://twitter.com/RLadiesGlobal)\
-   Hadley Wickham [\@hadleywickham](https://twitter.com/hadleywickham?ref_src=twsrc%5Egoogle%7Ctwcamp%5Eserp%7Ctwgr%5Eauthor)

Aynı zamanda:

**\#epitwitter** ve **\#rstats**

### Ücretsiz Çevrimiçi Kaynaklar {.unnumbered}

Tanımlayıcı bir metin, Garrett Grolemund ve Hadley Wickham'ın [Veri Bilimi için R](https://r4ds.had.co.nz/) kitabı.

[R4Epis](https://r4epis.netlify.app/)
Proje web sitesi "bir MSF acil müdahale ortamında yürütülecek yaygın salgın türlerini ve nüfusa dayalı anketleri kapsayacak şekilde standartlaştırılmış veri temizleme, analiz ve raporlama araçları geliştirmeyi" amaçlamaktadır. R temel eğitim materyallerini, salgınlar ve anketlerle ilgili RMarkdown raporları için şablonları ve bunları ayarlamanıza yardımcı olacak öğreticileri bulabilirsiniz.

### İngilizce dışındaki dillerde {.unnumbered}

[Materiales de RStudio en Español](https://www.rstudio.com/collections/espanol/)

[Introduction à R et au tidyverse (Francais)](https://juba.github.io/tidyverse/index.html)

<!-- ======================================================= -->

## Kurulum

### R ve RStudio {.unnumbered}

**R Nasıl Kurulur?**

Bu web sitesini <https://www.r-project.org/> ziyaret edin ve bilgisayarınıza uygun en son R sürümünü indirin.

**RStudio nasıl kurulur?**

Bu web sitesini <https://rstudio.com/products/rstudio/download/> ziyaret edin ve bilgisayarınıza uygun RStudio'nun en son ücretsiz masaüstü sürümünü indirin.

**İzinler**\

R ve RStudio'yu okuma ve yazma izinlerine sahip olduğunuz bir sürücüye kurmanız gerektiğini unutmayın. Aksi takdirde, R paketlerini kurma yeteneğiniz (sık rastlanan bir durum) etkilenecektir. Sorunlarla karşılaşırsanız, simgeye sağ tıklayıp "Yönetici olarak çalıştır"ı seçerek RStudio'yu açmayı deneyin. Diğer ipuçları [Ağ sürücülerinde R] sayfasında bulunabilir.

**R ve RStudio nasıl güncellenir?**

R sürümünüz, başlangıçta R Konsoluna yazdırılır. Ayrıca `sessionInfo()` komutunu da çalıştırabilirsiniz.

R'ı güncellemek için yukarıda belirtilen web sitesine gidin ve R'ı yeniden yükleyin. Alternatif olarak, **installr** paketini (Windows'ta) `installr::updateR()` çalıştırarak kullanabilirsiniz. Bu, en son R sürümünü indirmenize ve paketlerinizi yeni R sürümüne güncellemenize yardımcı olacak iletişim kutularını açacaktır. Daha fazla ayrıntıyı **installr** [belgelerde](https://www.r-project.org/nosvn/pandoc/installr.html) bulabilirsiniz.

Eski R sürümünün bilgisayarınızda hala var olacağını unutmayın. RStudio'da "Araçlar" -\> "Global Seçenekler"e tıklayarak ve bir R sürümü seçerek R'ın daha eski bir sürümünü (eski "kurulum") geçici olarak çalıştırabilirsiniz. Bu, R'ın en yeni sürümü üzerinde çalışacak şekilde güncellenmemiş bir paket kullanmak istiyorsanız yararlı olabilir.

RStudio'yu güncellemek için yukarıdaki web sitesine gidebilir ve RStudio'yu yeniden indirebilirsiniz. Başka bir seçenek de RStudio içinde "Yardım" -\> "Güncellemeleri Kontrol Et" seçeneğine tıklamaktır. Ancak bu en son güncellemeleri göstermeyebilir.

Bu El Kitabı hazırlanırken hangi R, RStudio veya paket sürümlerinin kullanıldığını görmek için [Editoryal ve teknik notlar] sayfasına bakın.

### Kurulumuna ihtiyaç duyabileceğiniz diğer yazılımlar{.unnumbered}

-   TinyTeX (*bir RMarkdown belgesini PDF'ye derlemek için*)\
-   Pandoc (*RMarkdown belgelerini derlemek için*)\
-   RTools (*R için paketler oluşturmak için*)\
-   phantomjs (*iletim zincirleri gibi hareketli ağların hareketsiz görüntülerini kaydetmek için*)

#### TinyTex {.unnumbered}

TinyTex, özel bir LaTeX dağıtımıdır ve R'dan PDF'ler üretmeye çalışırken kullanışlıdır.\
Daha fazla bilgi için <https://yihui.org/tinytex/> adresine bakın.

TinyTex'i R'dan yüklemek için:

```{r, eval=F}
install.packages('tinytex')
tinytex::install_tinytex()
# TinyTeX'i kaldırmak için, run tinytex::uninstall_tinytex()
```

#### Pandoc {.unnumbered}

Pandoc, R'dan ayrı bir yazılım olan belge dönüştürücüdür. **RStudio ile birlikte gelir ve indirilmesi gerekmez.** Rmarkdown belgelerini .pdf gibi biçimlere dönüştürme ve karmaşık fonksiyonlar ekleme sürecine yardımcı olur.

#### RTools {.unnumbered}

RTools, R için paketler oluşturmaya yönelik bir yazılım koleksiyonudur.

Bu internet sayfasından yükleyebilirsiniz: <https://cran.r-project.org/bin/windows/Rtools/>

#### phantomjs {.unnumbered}

Bu genellikle web sayfalarının "ekran görüntülerini" almak için kullanılır. Örneğin **epicontacts** paketi ile bir iletim zinciri yaptığınızda interaktif ve dinamik bir HTML dosyası üretilir. Statik bir görüntü istiyorsanız, bu işlemi otomatikleştirmek için [**webshot**](https://wch.github.io/webshot/articles/intro.html) paketini kullanmak faydalı olabilir. Bu, harici "phantomjs" programını gerektirecektir. phantomjs'yi **webshot** paketi aracılığıyla `webshot::install_phantomjs()` komutuyla kurabilirsiniz.

<!-- ======================================================= -->

## RStudio {#rstudio}

### RStudio Yönlendirmesi {.unnumbered}

**Öncelikle RStudio'yu açın.** Simgeleri çok benzer görünebileceğinden, R'ı değil *RStudio*'yu açtığınızdan emin olun.

RStudio'nun çalışması için bilgisayarda R'ın da kurulu olması gerekir (kurulum talimatları için yukarıya bakın).

**RStudio**, **R**'ın daha kolay kullanımı için bir arayüzdür (GUI). R'ı kritik işi yapan aracın motoru ve RStudio'yu, ilerlemek için motoru gerçekten kullanmanıza yardımcı olan aracın gövdesi (koltuklar, aksesuarlar vb. ile) olarak düşünebilirsiniz! Tam RStudio kullanıcı arayüzünü kolaylaştırıcısını (PDF) [buradan](https://www.rstudio.com/wp-content/uploads/2016/01/rstudio-IDE-cheatsheet.pdf) görebilirsiniz.

Varsayılan olarak RStudio dört dikdörtgen bölme görüntüler.
```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "RStudio_overview.png"))
```

[***İPUCU:*** RStudio'nuz yalnızca bir sol bölme gösteriyorsa, bunun nedeni henüz açık komut dosyanız olmamasıdır.]{style="color: darkgreen;"}

**Kaynak Bölmesi**\

Varsayılan olarak sol üstteki bu bölme, [komut dosyalarınızı](#scripts) düzenlemek, çalıştırmak ve kaydetmek için kullanılan bir alandır. Komut dosyaları, çalıştırmak istediğiniz komutları içerir. Bu bölme, görüntüleme için veri kümelerini/çerçevelerini (datasets/data frames) de görüntüleyebilir.

Stata kullanıcıları için bu bölme, Do-file ve Data Editor pencerelerinize benzer.

**R Konsol Bölmesi**

Varsayılan olarak R Studio'daki sol veya sol alt bölme olan R Konsolu, R "motorunun" evidir. Burası komutların fiilen çalıştırıldığı ve grafik olmayan çıktıların ve hata/uyarı mesajlarının göründüğü yerdir. Komutları doğrudan R Konsoluna girebilir ve çalıştırabilirsiniz. Ancak bu komutların bir komut dosyasından komut çalıştırırken olduğu gibi kaydedilmediğine dikkat ediniz.

Stata'ya aşina iseniz, R Konsolu komut penceresi "Sonuçlar" penceresi gibidir.

**Ortam Bölmesi**\

Varsayılan olarak sağ üstte bulunan bu bölme, çoğunlukla mevcut oturumda R Ortamındaki [nesnelerin](#nesneler) kısa özetlerini görmek için kullanılır. Bu nesneler, içe aktarılan, değiştirilen veya oluşturulan veri kümelerini, tanımladığınız parametreleri (örneğin, analiz için belirli bir epi haftası) veya analiz sırasında tanımladığınız vektörleri veya listeleri (örneğin, bölgelerin adları) içerebilir. Değişkenlerini görmek için bir veri kümesi adının yanındaki oka tıklayabilirsiniz.

<!--Data frame kavramını nasıl çevirmeli?Data Frameler, listenin her elemanının kendisine ait aynı uzunlukta özel bir listesi olan veriler olarak temsil edilir.
Listenin her bir öğesi bir sütun ve bu sütuna ait satırlar olarak düşünülebilir.
Matrislerden farklı olarak data frame’ler, her sütunda farklı nesne sınıfları depolayabilir. Matrisler,
her öğenin aynı sınıfa sahip olmasını gerektirmektedir (ör.hepsi sayısal veya hepsi string). ======================================================= -->

Stata'da, bu en çok Değişkenler Yöneticisi penceresine benzer.

Bu bölme ayrıca daha önceki komutları görebileceğiniz *Geçmiş*i içerir. Ayrıca, **learnr** paketini yüklediyseniz etkileşimli R eğitimlerini tamamlayabileceğiniz bir "Öğretici" sekmesine de sahiptir. Ayrıca harici bağlantılar için bir "Bağlantılar" bölmesine sahiptir ve Github ile arabirim kurmayı seçerseniz bir "Git" bölmesine sahip olabilir.

**Grafikler, Görüntüleyici, Paketler ve Yardım Bölmesi**\

Sağ alt bölmede birkaç önemli sekme bulunur. Haritalar dahil tipik çizim grafikleri, Çizim bölmesinde görüntülenecektir. Etkileşimli veya HTML çıktıları, Görüntüleyici bölmesinde görüntülenecektir. Yardım bölmesi, belgeleri ve yardım dosyalarını görüntüleyebilir. Dosyalar bölmesi, dosyaları açmak veya silmek için kullanılabilen bir tarayıcıdır. Paketler bölmesi, R paketlerini görmenize, yüklemenize, güncellemenize, silmenize ve paketin hangi sürümüne sahip olduğunuzu görmenize olanak tanır. Paketler hakkında daha fazla bilgi edinmek için aşağıdaki [paketler bölümüne](#packages) bakın.

Bu bölme, Plots Manager ve Project Manager pencerelerinin Stata eşdeğerlerini içerir.

### RStudio ayarları {.numbered}

*Tools* açılır menüsünde *Global Options*'ı seçerek RStudio ayarlarını ve görünümünü değiştirin. Orada görünüm/arka plan rengi dahil varsayılan ayarları değiştirebilirsiniz.

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "RStudio_tools_options_1.png"))

knitr::include_graphics(here::here("images", "RStudio_tools_options.png"))
```

**Tekrar başlat**

R'ınız donarsa, Oturum menüsüne gidip "R'ı Yeniden Başlat" ı tıklayarak R'ı yeniden başlatabilirsiniz. Bu, RStudio'yu kapatıp açma zahmetini ortadan kaldırır. Bunu yaptığınızda R ortamınızdaki her şey kaldırılacaktır.

### Klavye kısayolları {.unnumbered}

Bazı çok kullanışlı klavye kısayolları aşağıdadır. Bu RStudio'nun ikinci sayfasında Windows, Mac ve Linux için tüm klavye kısayollarına ulaşabilirsiniz [kullanıcı arayüzü kolaylaştırıcısı](https://www.rstudio.com/wp-content/uploads/2016/01/rstudio-IDE-cheatsheet .pdf).
<!--Link bozuk -->

+----------------------------------+------------------------+--------------------------------------------------------------------------------------------------------------------------------+
| Windows/Linux                    | Mac                    | Eylemi                                                                                                                         |
+==================================+========================+================================================================================================================================+
| Esc                              | Esc                    | Geçerli komutu kesintiye uğratın (yanlışlıkla eksik bir komut çalıştırdıysanız ve R konsolunda "+" görmekten kurtulamıyorsanız kullanışlıdır) |
+----------------------------------+------------------------+--------------------------------------------------------------------------------------------------------------------------------+
| Ctrl+s                           | Cmd+s                  | Kaydet (komut dosyası)                                                                                                                  |
+----------------------------------+------------------------+--------------------------------------------------------------------------------------------------------------------------------+
| Tab                              | Tab                    | Otomatik tamamlama                                                                                                                  |
+----------------------------------+------------------------+--------------------------------------------------------------------------------------------------------------------------------+
| Ctrl + Enter                     | Cmd + Enter            | Geçerli satırları/kod seçimini çalıştır                                                                                          |
+----------------------------------+------------------------+--------------------------------------------------------------------------------------------------------------------------------+
| Ctrl + Shift + C                 | Cmd + Shift + c        | Vurgulanan satırları yorumla/yorumu kaldır                                                                                        |
+----------------------------------+------------------------+--------------------------------------------------------------------------------------------------------------------------------+
| Alt + -                          | Option + -             | Eklemek `<-`                                                                                                                    |
+----------------------------------+------------------------+--------------------------------------------------------------------------------------------------------------------------------+
| Ctrl + Shift + m                 | Cmd + Shift + m        | Eklemek `%>%`                                                                                                                   |
+----------------------------------+------------------------+--------------------------------------------------------------------------------------------------------------------------------+
| Ctrl + l                         | Cmd + l                | R konsolunu temizle                                                                                                            |
+----------------------------------+------------------------+--------------------------------------------------------------------------------------------------------------------------------+
| Ctrl + Alt + b                   | Cmd + Option + b       | Baştan geçerli satıra çalıştır                                                                                                 |
+----------------------------------+------------------------+--------------------------------------------------------------------------------------------------------------------------------+
| Ctrl + Alt + t                   | Cmd + Option + t       | Geçerli kod bölümünü çalıştırın (R Markdown)                                                                                      |
+----------------------------------+------------------------+--------------------------------------------------------------------------------------------------------------------------------+
| Ctrl + Alt + i                   | Cmd + Shift + r        | Kod öbeği ekle (R Markdown'a)                                                                                            |
+----------------------------------+------------------------+--------------------------------------------------------------------------------------------------------------------------------+
| Ctrl + Alt + c                   | Cmd + Option + c       | Geçerli kod parçasını çalıştır (R Markdown)                                                                                            |
+----------------------------------+------------------------+--------------------------------------------------------------------------------------------------------------------------------+
| Yukarı/aşağı ok tuşları          | Aynı                   | Son çalıştırılan komutlar arasında geçiş yap                                                                                           |
+----------------------------------+------------------------+--------------------------------------------------------------------------------------------------------------------------------+
| Shift + Yukarı/aşağı ok tuşları  | Aynı                   | Birden çok kod satırı seçin                                                                                                   |
+----------------------------------+------------------------+--------------------------------------------------------------------------------------------------------------------------------+
| Ctrl + f                         | Cmd + f                | Geçerli komut dosyasında bul ve değiştir                                                                                             |
+----------------------------------+------------------------+--------------------------------------------------------------------------------------------------------------------------------+
| Ctrl + Shift + f                 | Cmd + Shift + f        | Dosyalarda bulun (birçok komut dosyasında arama yapın/değiştirin)                                                                            |
+----------------------------------+------------------------+--------------------------------------------------------------------------------------------------------------------------------+
| Alt + l                          | Cmd + Option + l       | Seçilen kodu katla                                                                                                             |
+----------------------------------+------------------------+--------------------------------------------------------------------------------------------------------------------------------+
| Shift + Alt + l                  | Cmd + Shift + Option+l | Seçili kodu aç                                                                                                           |
+----------------------------------+------------------------+--------------------------------------------------------------------------------------------------------------------------------+

[***İPUCU:*** Yazarken RStudio'nun otomatik tamamlama fonksiyonunu etkinleştirmek için Sekme tuşunuzu kullanın. Bu, yazım hatalarını önleyebilir. Şu ana kadar yazdıklarınıza bağlı olarak olası fonksiyonlar ve nesnelerin bir açılır menüsünü oluşturmak için yazarken Sekme tuşuna basın.]{style="color: darkgreen;"}

<!-- Tablo düzgün mü diye htmlden kontrolü iyi olur. ======================================================= -->

## Fonksiyonlar" {#functions}

Fonksiyonlar, R'ı kullanmanın merkezinde yer alır. Fonksiyonlar, görevleri ve işlemleri nasıl gerçekleştirdiğinizdir. Pek çok fonksiyon R ile kurulu olarak gelir, daha pek çoğu *paketlerde* indirilebilir ([paketler](#paketler) bölümünde açıklanmıştır) ve hatta kendi özel Fonksiyonlarınızı bile yazabilirsiniz!

Fonksiyonlarla ilgili bu temel bilgiler bölümü şunları açıklar:

- Fonksiyon nedir ve nasıl çalışır\
- Fonksiyonun *Değişkenleri*(arguments) nelerdir\
- Bir fonksiyonu anlamak için nasıl yardım alınır

*Sözdizimi (syntax) hakkında kısa bir not:* Bu el kitabında, fonksiyonlar açık ve kapalı parantezler içinde kod-metin içinde şöyle yazılmıştır: `filter()`. [Paketler](#packages) bölümünde açıklandığı gibi, Fonksiyonlar *paketler* içinde indirilir. Bu el kitabında, paket adları **dplyr** gibi **kalın** ile yazılmıştır. Bazen örnek kodda, fonksiyon adının, bunun gibi iki adet iki nokta üst üste (`::`) ile açıkça paketinin adıyla bağlantılı olduğunu görebilirsiniz: `dplyr::filter()`. Bu bağlantının amacı paketler bölümünde açıklanmıştır.

<!-- ======================================================= -->

### Basit Fonksiyonlar {.unnumbered}

**Bir fonksiyon, girdileri alan, bu girdilerle bazı işlemler yapan ve bir çıktı üreten makine gibidir.** Çıktının ne olduğu fonksiyona bağlıdır.

**Fonksiyonlar genellikle fonksiyonun parantezleri içine yerleştirilmiş bazı nesneler üzerinde çalışır**. Örneğin, `sqrt()` fonksiyonu bir sayının karekökünü hesaplar:

```{r basics_function_sqrt}
sqrt(49)
```

Bir fonksiyona sağlanan nesne ayrıca veri kümesindeki bir sütun olabilir (tüm nesne türleri hakkında ayrıntılı bilgi için [Nesneler](#nesneler) bölümüne bakın). R, birden çok veri kümesini depolayabildiğinden, hem veri kümesini hem de sütunu belirtmeniz gerekecektir. Bunu yapmanın bir yolu, veri kümesinin adını ve sütunun adını ("veri kümesi$sütun") bağlamak için "$" gösterimini kullanmaktır. Aşağıdaki örnekte, "summary()" fonksiyonu, "linelist" veri kümesindeki "age" sayısal sütununa uygulanır ve çıktı, sütunun sayısal ve eksik değerlerinin bir özetidir.

```{r basics_functions_summary}
# 'linelist' veri kümesindeki 'age' sütununun özet istatistiklerini yazdır
summary(linelist$age)
``` 

[***NOT:*** Perde arkasında, bir fonksiyon, kullanıcı için tek bir kolay komuta sarılmış karmaşık ek kodu temsil eder.]{style="color: black;"}

<!-- ======================================================= -->

### Birden çok bağımsız değişkene sahip fonksiyonlar {.unnumbered}

Fonksiyonlar genellikle,parantezleri içinde yer alan ve virgülle ayrılmış olan ***değişkenler*** adı verilen birkaç girdi ister.

- Fonksiyonun doğru çalışması için bazı değişkenler gereklidir, bazıları isteğe bağlıdır\
- İsteğe bağlı bağımsız değişkenlerin varsayılan ayarları vardır\
- Değişkenler karakter, sayısal, mantıksal (DOĞRU/YANLIŞ) ve diğer girdi değerlerini alabilir

Tipik bir fonksiyona örnek olarak, 'oven_bake()' adlı eğlenceli bir kurgusal fonksiyonu burada bulabilirsiniz. Bir girdi nesnesi (örneğin, bir veri kümesi veya bu örnekte "hamur") alır ve üzerinde ek bağımsız değişkenler ('dakikalar =' ve 'sıcaklık =') tarafından belirtildiği gibi işlemler gerçekleştirir. Çıktı konsola yazdırılabilir veya "<-" atama operatörü kullanılarak bir nesne olarak kaydedilebilir.

```{r basics_functions_image, echo=F, out.width = "75%", fig.align = "center"}
knitr::include_graphics(here::here("images", "Function_Bread_Example.png"))
```

**Daha gerçekçi bir örnekte**, aşağıdaki "age_pyramid()" komutu, tanımlanmış yaş gruplarına ve "cinsiyet" gibi ikili bir bölme sütununa dayalı bir yaş piramidi grafiği oluşturur. Fonksiyona, parantez içinde virgülle ayrılmış üç değişken verilir. Değişkenlere sağlanan değerler, kullanılacak veri çerçevesi olarak "satır listesi"ni, sayılacak sütun olarak "age_cat5"i ve piramidi renge göre bölmek için kullanılacak ikili sütun olarak "gender"i belirler.

```{r basics_functions_arguments, include=FALSE, results='hide', message=FALSE, warning=FALSE,}
## kategorik aralar belirterek bir yaş grubu değişkeni oluşturun
linelist$age_group <- cut(linelist$age, breaks = c(0, 5, 10, 15, 20, 30, 45, 60))
```

```{r message=FALSE, warning=FALSE,  out.width = "75%", out.height="75%"}
# Bir yaş piramidi oluştur
age_pyramid(data = linelist, age_group = "age_cat5", split_by = "gender")
```

Yukarıdaki komut, her değişken için yeni bir satırla daha uzun bir tarzda aşağıdaki gibi eşdeğer olarak yazılabilir. Bu stilin okunması daha kolay olabilir ve her bölümü açıklamak için "#" ile "yorum" yazmak daha kolay olabilir (kapsamlı yorum yapmak iyi bir uygulamadır!). Bu daha uzun komutu çalıştırmak için tüm komutu vurgulayabilir ve "Çalıştır"a tıklayabilir veya imlecinizi ilk satıra getirip ardından Ctrl ve Enter tuşlarına aynı anda basabilirsiniz.

```{r message=FALSE, warning=FALSE,  out.width = "75%", out.height="75%"}
# Bir yaş piramidi oluştur
age_pyramid(
  data = linelist,        # Satır listesini kullan
  age_group = "age_cat5", # Yaş grubu sütununu kullan
  split_by = "gender"     # Piramidin iki tarafı için cinsiyet sütununu kullan
  )
```

Bir bağımsız değişken atamasının ilk yarısının (örneğin, "veri ="), bağımsız değişkenler belirli bir sırada (fonksiyonun belgelerinde belirtilen) yazılmışsa belirtilmesi gerekmez. Aşağıdaki kod, yukarıdakiyle tam olarak aynı piramidi üretir, çünkü fonksiyon değişken sırasını kabul eder: satır listesi, "yaş_grubu" değişkeni, "bölme_göre" değişkeni.

```{r, basics_functions_pyramid2, eval = FALSE, warning=FALSE, message=FALSE, , out.width = "75%", out.height="75%", eval=F}
# Bu komut yukarıdaki ile aynı grafiği üretecektir.
age_pyramid(linelist, "age_cat5", "gender")
```

**Daha karmaşık bir "age_pyramid()" komutu, aşağıdakilere yönelik *isteğe bağlı* değişkenleri içerebilir:**

- Sayılar yerine oranları göster (varsayılan "YANLIŞ" olduğunda "orantılı = DOĞRU" olarak ayarlayın)\
- Kullanılacak iki rengi belirtin (`pal =`, "palet"in kısaltmasıdır ve iki renk adından oluşan bir vektörle sağlanır. ""c()" fonksiyonunun nasıl vektör oluşturduğunu öğrenmek için [nesneler](#objectstructure) sayfasına bakın)

[***NOT:*** İki taraflı belirtilecek değişkenler için (ör. `orantılı = DOĞRU`) değişkenlerin sıraları önemsizdir.]{style="color: black;"}

```{r message=FALSE, warning=FALSE, out.width = "75%", out.height="75%"}
age_pyramid(
  linelist,                    # Satır listesini kullan
  "age_cat5",                  # Yaş grubu sütununu kullan
  "gender",                    # Cinsiyete göre ayır
  proportional = TRUE,         # sayı yerine yüzdelik kullan
  pal = c("orange", "purple")  # renkleri turuncu ve mor
  )
```

<!-- ======================================================= -->

### Fonksiyon Yazma {.unnumbered}

R, fonksiyonlara yönelik bir dildir, bu nedenle kendi fonksiyonlarınızı yazmak için yetkilendirilmiş hissetmeniz gerekir. Fonskiyonlar oluşturmak çeşitli avantajlar sağlar:

- Modüler programlamayı kolaylaştırmak için - kodun bağımsız ve yönetilebilir parçalara ayrılması\
- Hataya açık olabilen tekrarlayan kopyala ve yapıştır işlemlerinin değiştirilmesi\
- Kod parçalarına akılda kalıcı isimler verilmesi

Bir fonksiyonun nasıl yazılacağı [Fonksiyon Yazma] sayfasında derinlemesine ele alınmıştır.

<!-- A function is given a name and defined with the assignment operator `<-` to a special **base** R function called `function()`. Within the parentheses, the arguments that the function will accept are defined. This is followed by curly brackets `{ }`, within which the actual code of the function is written.     -->

```{r, eval=F, echo=F}
my_function <- function( ARGUMENTS HERE ){ CODE HERE }
```

<!-- The arguments should be provided in the syntax `argument = default`, separated by commas.   -->

<!-- Here is an example where we create a function `staff_calc()` to serve as a staffing calculator for COVID-19 case investigation and contact tracing calls.   -->

<!-- The arguments (inputs) and their default values will be:   -->

<!-- * `daily_cases = NULL` The number of new COVID-19 cases per day   -->

<!-- * `contacts_each = 5` The number contacts enumerated for each case   -->

<!-- * `time_case = 0.5`  Number of hours to complete a case investigaton by phone   -->

<!-- * `time_contact = 0.25`  Number of hours to complete a contact follow-up by phone   -->

<!-- * `time_day = 8` The number of hours one staff works per day   -->

<!-- Below, the function is created. The code ends with the special function `return()`, which is what the function produces.    -->

<!-- ```{r message=FALSE, warning=FALSE, out.width = "75%", out.height="75%"} -->

<!-- staff_calc <- function(daily_cases = NULL, contacts_each = 5, -->

<!--                        time_case = 0.5, time_contact = 0.25, time_day = 8){ -->

<!--   # Define total daily hours for calling cases -->

<!--   case_hours <- daily_cases * time_case  -->

<!--   # Define total daily hours for calling contacts -->

<!--   contact_hours <- daily_cases * contacts_each * time_contact -->

<!--   # Calculate number of staff required -->

<!--   staff_required <- (case_hours + contact_hours)/time_day -->

<!--   return(staff_required) -->

<!-- } -->

<!-- ``` -->

<!-- Once this code is run, the function will be defined and will appear in the R Environment. We can run the function. Below all the default values are used and the `daily_cases = ` is set to 150.   -->

```{r eval=F, echo=F, message=FALSE, warning=FALSE, out.width = "75%", out.height="75%"}
staff_calc(daily_cases = 150)
```

```{r, eval=F, echo=F}
case_incidence <- tibble(
  dates = seq.Date(from = as.Date("2020-05-01"), to = as.Date("2020-05-21"), by = 1),
  projected_incidence = c(102,110,50,37,106,190,146,138,135,111,60,43,189,184,185,80,44,97,254,291,288),
  staff_needed = staff_calc(projected_incidence)
)

ggplot(case_incidence, aes(x = dates))+
  geom_line(aes(y = projected_incidence))+
  geom_line(aes(y = staff_needed))
```

<!-- There are many other nuances to understand when writing functions, as discussed in the page [Writing functions].   -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Paketler {#packages}

**Paketler fonksiyonları içerir.**

Bir R paketi, önceden tanımlanmış fonksiyonları içeren, paylaşılabilir bir kod ve belge paketidir. R topluluğundaki kullanıcılar, her zaman belirli sorunlara yönelik paketler geliştirir, muhtemelen size yardımcı olabilecek bir tanesi mevcuttur! R kullanımınızda yüzlerce paket kuracak ve kullanacaksınız.

Kurulum sırasında R, yaygın kullanılan görevleri gerçekleştiren **"temel"** paketleri ve fonksiyonları içerir. Ancak birçok R kullanıcısı, R topluluğu tarafından doğrulanan ve kendi kullanımınız için bir **paket** olarak indirebileceğiniz özel fonksiyonlar oluşturur. Bu el kitabında paket adları **kalın** ile yazılmıştır. R'ın daha zorlu yönlerinden biri, belirli bir görevi tamamlamak için seçilebilecek çok sayıda farklı fonksiyon veya paketin olmasıdır.

### Kurulum ve Yükleme {.unnumbered}

*Fonksiyonlar*, internetten bilgisayarınıza indirebileceğiniz ("kurulu") **paketler** içerisinde yer almaktadır. Bir paket indirildiğinde, "kütüphanenizde" saklanır. Ardından, paketi "yükleyerek" mevcut R oturumunuz sırasında içerdiği fonksiyonlara erişebilirsiniz.

*R'ı kişisel kitaplığınız olarak düşünün*: Bir paket indirdiğinizde, kütüphaneniz yeni bir fonksiyon kitabı kazanır, ancak o kitaptaki bir fonksiyonu her kullanmak istediğinizde, kütüphanenizden o kitabı ödünç almanız ("yüklemeniz") gerekir.

Özetle: bir R paketinde bulunan fonksiyonları kullanmak için 2 adım uygulanmalıdır:

1) Paket (bir defaya mahsus) **kurulmalı**, *ve*\
2) Paket (her R oturumu sırasında) **yüklenmeli**

#### Senin Kütüphanen {.unnumbered}

"Senin kütüphanen" aslında bilgisayarınızda kurulu olan her paket için içerisinde farklı bir dosya oluşturulan bir klasördür. Bilgisayarınızda R'ın nerede kurulu olduğunu bulun ve "win-library" adlı bir klasör arayın. Örneğin: `R\win-library\4.0` (4.0, R sürümüdür - indirdiğiniz her R sürümü için farklı bir kitaplığınız olacaktır).

`.libPaths()` (boş parantezler) girerek kitaplığınızın dosya yolunu yazdırabilirsiniz. [Ağ sürücülerinde R] ile çalışırken bu özellikle önemlidir.

#### CRAN 'dan Kurulum {.unnumbered}

Çoğu zaman, R kullanıcıları paketleri CRAN'dan indirir. CRAN (Comprehensive R Archive Network - Kapsamlı R Arşiv Ağı), topluluk üyeleri tarafından yayınlanan R paketlerinin çevrimiçi genel deposudur.

CRAN'dan bir paket indirirken virüsler ve güvenlik konusunda endişeleniyor musunuz? Konuyla ilgili [bu makaleyi](https://support.rstudio.com/hc/en-us/articles/360042593974-R-and-R-Package-Security) okuyabilirsiniz.

#### Nasıl kurulum yapar ve yüklerim?{.unnumbered}
Bu el kitabında, **pacman** paketini ("paket yöneticisi" kısaltması) kullanmanızı öneririz. Gerekirse bir paketi kuracak *ve* mevcut R oturumunda kullanmak üzere yükleyecek uygun bir `p_load()` fonksiyonu sunar.

Sözdizimi oldukça basit. Paketlerin adlarını 'p_load()' parantezleri içinde virgülle ayırarak listeleyin. Bu komut, henüz kurulmamışlarsa **rio**, **tidyverse** ve **here** paketlerini kuracak ve bunları kullanım için yükleyecektir. Bu, komut dosyalarını başkalarıyla paylaşırken `p_load()` yaklaşımını kullanışlı ve özlü hale getirir. Paket adlarının büyük/küçük harfe duyarlı olduğunu unutmayın.

```{r}
# Paketleri kurup yükleyebilirsiniz.(Gerekli görürseniz)
pacman::p_load(rio, tidyverse, here)
```

Paket adını (**pacman**) fonksiyon adından (`p_load()`) önce açıkça yazan `pacman::p_load()` sözdizimini kullandığımızı ve iki adet iki nokta üst üste `::` ile bağlandığını unutmayın. Bu sözdizimi, **pacman** paketini de yüklediği için kullanışlıdır (zaten kurulu olduğu varsayılarak).

Sıklıkla göreceğiniz alternatif **temel** R fonksiyonları vardır. Bir paketi kurmak için **temel** R fonksiyonu `install.packages()` fonksiyonudur. Kurulacak paketin adı parantez içinde *tırnak içinde* belirtilmelidir. Bir komutta birden çok paket kurmak istiyorsanız, bunlar bir `c()` karakter vektörü içinde listelenmelidir.

Not: Bu komut bir paketi *kurar*, ancak geçerli oturumda kullanmak için *yüklemez*.

```{r, eval=F}
# Temel R için bir paketin kurulumu
install.packages("tidyverse")

# Temel R için çoklu paketlerin kurulumu
install.packages(c("tidyverse", "rio", "here"))
```

Kurulum ayrıca, RStudio "Paketler" bölmesine gidip istenen paket adını arayarak "Kur" seçeneğine tıklanarak da gerçekleştirilebilir.

Bir paketi kullanmak üzere (kurulduktan sonra) **yüklemek** için **temel** R fonksiyonu 'library()'dir. Bir seferde yalnızca bir paket yükleyebilir (`p_load()` kullanmanın başka bir nedeni). Paket adını tırnak işaretleri ile veya tırnak işaretleri olmadan sağlayabilirsiniz.

```{r, eval=F}
# Temel R için paket yüklenmesi
library(tidyverse)
library(rio)
library(here)
```

Bir paketin kurulu ve/veya yüklenmiş olup olmadığını kontrol etmek için RStudio'da Paketler bölmesini görüntüleyebilirsiniz. Paket kurulu ise sürüm numarası ile orada gösterilir. Kutusu işaretliyse, geçerli oturum için yüklenir.

**Github'dan Kurulum**

Bazen, henüz CRAN'da bulunmayan bir paketi yüklemeniz gerekir. Veya belki de paket CRAN'da mevcuttur, ancak daha kararlı yayınlanan CRAN sürümünde henüz sunulmayan yeni özelliklere sahip *geliştirme sürümünü* istiyorsunuzdur. Bunlar genellikle [github.com](https://github.com/) web sitesinde ücretsiz, halka açık bir kod "deposu" içinde barındırılır. [Git ve Github ile sürüm kontrolü ve işbirliği] El kitabı sayfasından Github hakkında daha fazla bilgi edinebilirsiniz.

Github'dan R paketlerini indirmek için, gerekirse paketi kuracak ve mevcut R oturumunuzda kullanmak üzere yükleyecek olan **pacman**'dan `p_load_gh()` fonksiyonunu kullanabilirsiniz. Kurulum alternatifleri arasında **remotes** veya **devtools** paketlerinin kullanılması yer alır. [Paket belgelerinde](https://cran.r-project.org/web/packages/pacman/pacman.pdf) tüm **pacman** fonksiyonları hakkında daha fazla bilgi edinin.

Github'dan yüklemek için daha fazla bilgi sağlamanız gerekir. Şunları sağlamalısın:

1) Depo sahibinin Github kimliği
2) Paketi içeren havuzun adı\
3) *(isteğe bağlı) İndirmek istediğiniz "dalın" (özel geliştirme sürümü) adı*

Aşağıdaki örneklerde, tırnak içindeki ilk kelime depo sahibinin Github ID'sidir, eğik çizgiden sonra deponun adı (paketin adı) olur.

```{r, eval=F}
# Github deposundan epicontacts paketini kur ve yükle.
p_load_gh("reconhub/epicontacts")
```

Ana dal dışında bir "daldan" (sürüm) kurulum yapmak istiyorsanız, dal adını depo adından sonra şu ifade ile birlikte "\@" ekleyin.

```{r, eval=F}
# Github'dan epicontacts paketinin "zaman çizelgesi" dalını kurun
p_load_gh("reconhub/epicontacts@timeline")
```

Github sürümü ile bilgisayarınızdaki sürüm arasında herhangi bir fark yoksa herhangi bir işlem yapılmayacaktır. "update = TRUE" değişkeni yerine "p_load_current_gh()" komutu kullanarak yeniden yüklemeyi "zorlayabilirsiniz" (force). Bu [çevrimiçi gösterimde] http://trinker.github.io/pacman/vignettes/Introduction_to_pacman.html adresinde **pacman** hakkında daha fazla bilgi edinin)

**ZIP veya TAR'dan yükleme**

Paketi bir URL'den yükleyebilirsiniz:

```{r, eval=F}
packageurl <- "https://cran.r-project.org/src/contrib/Archive/dsr/dsr_0.2.2.tar.gz"
install.packages(packageurl, repos=NULL, type="source")
```

Veya sıkıştırılmış bir dosyada bilgisayarınıza indirin:

Seçenek 1: **remotes** paketinden `install_local()` kullanmak

```{r, eval=F}
remotes::install_local("~/Downloads/dplyr-master.zip")
```

Seçenek 2: **base** R'dan `install.packages()` komutunu kullanarak, ZIP dosyasının dosya yolunu sağlayarak ve `type = "source` ve `repos = NULL` ayarını yaparak.

```{r, eval=F}
install.packages("~/Downloads/dplyr-master.zip", repos=NULL, type="source")
```

### Kod sözdizimi {.unnumbered}

Bu el kitabındaki netlik için, fonksiyonlar önüne bazen aşağıdaki şekilde `::` sembolü kullanılarak paketlerinin adı gelir: `package_name::function_name()`

Bir oturum için bir paket yüklendiğinde, belirgin stil gerekli değildir. Sadece `function_name()` kullanılabilir. Bununla birlikte, bir fonksiyon adı yaygın olduğunda ve birden çok pakette bulunabileceğinde paket adını yazmak yararlıdır (örneğin, `plot()`). Paket adının yazılması, henüz yüklenmemişse paketi de yükleyecektir.

```{r eval=FALSE}
# Bu komut, bir veri kümesini içe aktarmak için "rio" paketini ve "import()" fonksiyonunu kullanır.
linelist <- rio::import("linelist.xlsx", which = "Sheet1")
```

### Fonksiyon yardımı {.unnumbered}

Bir fonksiyon hakkında daha fazlasını okumak için, sağ alt RStudio'nun Yardım sekmesinde onu arayabilirsiniz. Ayrıca `?fonksiyonadı` (fonksiyonun adını bir soru işaretinden sonra koyun) gibi bir komut çalıştırabilirsiniz ve Yardım bölmesinde Yardım sayfası görünecektir. Son olarak, kaynakları çevrimiçi olarak aramayı deneyin.

### Paketleri güncelleyin {.unnumbered}

Paketleri yeniden yükleyerek güncelleyebilirsiniz. Hangi paketlerin kurulacak yeni sürümleri olduğunu görmek için RStudio Paketleri bölmenizdeki yeşil "Güncelle" düğmesini de tıklayabilirsiniz. Bir fonksiyonun nasıl çalıştığına dair büyük bir revizyon varsa, eski kodunuzun güncellenmesi gerekebileceğini unutmayın!

### Paketleri sil {.unnumbered}

**pacman**'den `p_delete()` veya **base** R'dan `remove.packages()` komutlarını kullanabilirsiniz. Alternatif olarak, kitaplığınızı içeren klasörü bulup manuel olarak silebilirsiniz.

### Bağlılıklar {.unnumbered}

Paketler genellikle çalışmak için diğer paketlere bağlıdır. Bunlara bağlılıklar (dependencies)denir. Bir bağlılık yüklenemezse, buna bağlı olan paket de yüklenemeyebilir.

`p_depends()` ile bir paketin bağlılıklarını görün ve `p_depends_reverse()` ile hangi paketlerin ona bağlı olduğunu görün

### Maskelenmiş fonksiyonlar {.numbered}

İki veya daha fazla paketin aynı fonksiyon adını içermesi nadir değildir. Örneğin, **dplyr** paketinin bir "filter()" fonksiyonu vardır, ancak **stats** paketinin de fonksiyonu vardır. Varsayılan 'filter()' fonksiyonu, bu paketlerin R oturumunda ilk yüklendiği sıraya bağlıdır - sonraki, 'filter()' komutu için varsayılan olacaktır.

Sırayı R Studio'nun Ortam bölmesinde kontrol edebilirsiniz - "Global Ortam" açılır menüsünü tıklayın ve paketlerin sırasını görün. Bu açılır listedeki *alt* paketlerdeki fonksiyonlar, açılır listede daha yukarıda görünen paketlerdeki aynı ada sahip fonksiyonları maskeleyecektir. Bir paketi ilk yüklerken, maskeleme meydana gelirse R sizi konsolda uyarır, ancak bunu gözden kaçırmak kolay olabilir.

```{r out.width = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "masking_functions.png"))
```

Maskelemeyi düzeltmenin yolları şunlardır:

1) Komutta paket adını belirtin. Örneğin, `dplyr::filter()`\ kodunu kullanın
2) Paketlerin yüklenme sırasını yeniden düzenleyin (ör. `p_load()` içinde) ve **yeni bir R oturumu başlatın**

### Ayır / kaldır {.unnumbered}

Bir paketi ayırmak (kaldırmak) için, bu komutu doğru paket adı ve yalnızca bir iki nokta üst üste ile kullanın. Bunun maskelemeyi çözmeyebileceğini unutmayın.

```{r, eval=F}
detach(package:PACKAGE_NAME_HERE, unload=TRUE)
```

###  Eski sürümü yükleyin {.unnumbered}

Belirli bir paketin daha eski bir sürümünü yüklemek için bu [kılavuza](https://support.rstudio.com/hc/en-us/articles/219949047-Installing-older-versions-of-packages) bakabilirsiniz.

### Önerilen paketler {.unnumbered}

Günlük epidemiyoloji için önerdiğimiz paketlerin listesi için [Önerilen paketler] sayfasına bakabilirsiniz.

<!-- ============================================ ========= -->

## Komut Dosyaları {#scripts}

Komut dosyaları, programlamanın temel bir parçasıdır. Komutlarınızı tutan belgelerdir (örneğin, veri kümeleri oluşturma ve değiştirme fonksiyonları, baskı görselleştirmeleri vb.). Bir komut dosyasını kaydedebilir ve daha sonra yeniden çalıştırabilirsiniz. Komutlarınızı bir komut dosyasında saklamanın ve çalıştırmanın (komutları tek tek R konsolu "komut satırına" yazmaya kıyasla) birçok avantajı vardır:

- Taşınabilirlik - çalışmalarınızı komut dosyalarınızı göndererek başkalarıyla paylaşabilirsiniz\
- Tekrarlanabilirlik - böylece siz ve diğerleri tam olarak ne yaptığınızı bilir\
- Sürüm kontrolü - böylece kendiniz veya meslektaşlarınız tarafından yapılan değişiklikleri takip edebilirsiniz\
- Yorumlama/açıklama - meslektaşlarınıza ne yaptığınızı açıklamak için kullanabilirsiniz

### Yorum yapma {.unnumbered}

Bir komut dosyasında, R kodunuzun etrafına açıklama da ("yorum") yapabilirsiniz. Yorum yapmak, kendinize ve diğer okuyuculara ne yaptığınızı açıklamanıza yardımcı olur. Hashtag sembolünü (\#) yazıp ardından yorumunuzu yazarak yorum ekleyebilirsiniz. Yorum yapılan metin, R kodundan farklı bir renkte görünecektir.

\#'dan sonra yazılan hiçbir kod çalıştırılmayacaktır. Bu nedenle, kodun önüne bir \# koymak, silmek istemiyorsanız bir kod satırını geçici olarak engellemenin ("yorum yapma") da yararlı bir yoludur. Ctrl+Shift+c (Mac'te Cmd+Shift+c) tuşlarına basarak aynı anda birden fazla satırda yorum yapabilir ve vurgular oluşturabilirsiniz.

```{r, eval = F}
# Bir yorum tek başına bir satırda olabilir
# verileri içe aktar
linelist <- import("linelist_raw.xlsx") %>%   # Bir yorum aynı zamanda kodun ardından gelebilir
# filtre(yaş > 50)                # Bir kod satırını devre dışı bırakmak/kaldırmak için de kullanılabilir
  count()

```

- *Ne* yaptığınız hakkında *ve  **neden** yaptığınız* hakkında yorum yapın.\
- Kodunuzu mantıksal bölümlere ayırın\
- Yaptığınız işin adım adım açıklamasını içeren bir metinle kodunuza eşlik edin (ör. numaralandırılmış adımlar)

### Stil {.numbered}

Özellikle bir ekip üzerinde çalışıyorsanız, kodlama stilinizin bilincinde olmak önemlidir. Biz **tidyverse** [stil rehberini](https://style.tidyverse.org/) öneriyoruz. Bu stile uyum sağlamanıza yardımcı olan **styler** ve **lintr** gibi paketler de vardır.

Kodunuzu başkaları tarafından okunabilir kılmak için birkaç temel nokta:\
\* Nesneleri adlandırırken yalnızca küçük harf, sayı ve alt çizgi "_" kullanın, ör. `benim_verilerim`\
\* Sık boşluklar kullanın, ör. "n = 1" ve "age_new <- age_old + 3"

### Örnek Komut Dosyası {.unnumbered}

Aşağıda kısa bir R komut dosyası örneği verilmiştir. Unutmayın, kodunuzu yorumlarda ne kadar kısa ve öz bir şekilde açıklarsanız, iş arkadaşlarınız sizi o kadar çok sevecektir!

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "example_script.png"))
```

<!--PNG'DE TÜRKÇEYE ÇEVRİLMESİ GEREKEN YORUM ALANLARI MEVCUT ======================================================= -->

### R işaretleme (R Markdown) {.unnumbered}

Bir R işaretleme komut dosyası, betiğin kendisinin bir çıktı belgesi (PDF, Word, HTML, Powerpoint, vb.) *olduğu*  türüdür. Bunlar, genellikle dinamik ve otomatik raporlar oluşturmak için kullanılan inanılmaz derecede kullanışlı ve çok yönlü araçlardır. Bu web sitesi ve el kitabı bile R işaretleme komut dosyaları ile üretilmiştir!

Yeni başlayan R kullanıcılarının da R Markdown'ı kullanabileceğini belirtmekte fayda var - gözünüz korkmasın! Daha fazla bilgi edinmek için, [R Markdown ile Raporlar] belgelerindeki el kitabı sayfasına bakabilirsiniz.

<!-- ============================================ ========= -->

### R not defterleri {.unnumbered}

Rmarkdown ile R not defterine yazmak arasında hiçbir fark yoktur. Ancak belgenin işlenmesi biraz farklıdır. Daha fazla ayrıntı için bu [siteye](http://uc-r.github.io/r_notebook) bakabilirsiniz.

<!-- ============================================ ========= -->

### Parlak {.unnumbered}

Parlak uygulamalar/web siteleri, "app.R" olarak adlandırılması gereken tek bir komut dosyası içinde bulunur. Bu dosyanın üç bileşeni vardır:

1) Bir kullanıcı arayüzü (user inteface(ui))\
2) Bir sunucu fonksiyonu\
3) "shinyApp" fonksiyonuna bir çağrı

[Shiny ile Panolar]'daki el kitabı sayfasına veya bu çevrimiçi eğiticiye bakabilirsiniz: [Parlak öğretici](https://shiny.rstudio.com/tutorial/write-tutorial/lesson1/)

*Önceleri yukarıdaki dosya iki dosyaya bölünmüş olarak mevcuttu. (`ui.R` ve `server.R`)*

### Kod katlama {.unnumbered}

Komut dosyanızın okunmasını kolaylaştırmak için kod bölümlerini daraltabilirsiniz.

Bunu yapmak için, \# ile bir metin başlığı oluşturun, başlığınızı yazın ve ardından tire (-), kare (\#) veya eşittir (=)'den birini en az 4 kez kullanın. Bunu yaptığınızda, soldaki "oluk"ta (satır numarasına göre) küçük bir ok belirecektir. Bu oku ve aşağıdaki kodu, bir sonraki başlık bitimine ve yerinde bir çift ok simgesi görünene kadar tıklayabilirsiniz.

Kodu genişletmek için, ya cilt payındaki oku ya da çift ok simgesini tıklayın. Bu sayfanın [RStudio bölümünde](#rstudio) açıklandığı gibi klavye kısayolları da mevcuttur.

\# ile başlıklar oluşturarak, komut dosyanızın altında (aşağıya bakın) komut dosyanızda gezinmek için kullanabileceğiniz İçindekiler Tablosunu da etkinleştirirsiniz. Daha fazla \# sembolü ekleyerek alt başlıklar oluşturabilirsiniz, örneğin birincil için \#, ikincil için \#\# ve üçüncül başlıklar için \#\#\#.

Aşağıda örnek bir komut dosyasının iki versiyonu bulunmaktadır. Solda, yorumlanmış başlıkları olan orijinaldir. Sağ tarafta, her başlıktan sonra daraltılabilir hale getiren dört çizgi yazılmıştır. Bunlardan ikisi daraltılmıştır ve alttaki İçindekiler'in artık her bölümü gösterdiğini görebilirsiniz.

```{r, out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "code_folding1.png"))
knitr::include_graphics(here::here("images", "code_folding2.png"))
```

Otomatik olarak katlama için uygun olan diğer kod alanları, fonksiyon tanımları veya koşullu bloklar (if else ifadeleri) gibi "{ }" köşeli parantezli "köşeli" bölgeleri içerir. RStudio [sitesinde](https://support.rstudio.com/hc/en-us/articles/200484568-Code-Folding-and-Sections) kod katlama hakkında daha fazla bilgi edinebilirsiniz.

<!-- ============================================ ========= -->

<!-- ============================================ ========= -->

<!-- ============================================ ========= -->

## Çalışma dizini

Çalışma dizini, R tarafından işiniz için kullanılan kök klasör konumudur - burada R, varsayılan olarak dosyaları arar ve kaydeder. Varsayılan olarak, yeni dosyaları ve çıktıları bu konuma kaydedecek ve içe aktarılacak dosyaları (örneğin veri kümeleri) burada da arayacaktır.

Çalışma dizini, RStudio Konsol bölmesinin üst kısmında gri metin olarak görünür. Geçerli çalışma dizinini `getwd()` komutunu çalıştırarak da yazdırabilirsiniz (parantezleri boş bırakın).

```{r fig.align="center", out.width="100%"}
knitr::include_graphics(here::here("images", "working_directory_1.png"))
```


Yakın zamana kadar, R öğrenen birçok kişiye komut dosyalarına `setwd()` komutuyla başlamaları öğretiliyordu. Bunun yerine lütfen [R projesi][R projeleri] odaklı bir iş akışı kullanmayı düşünün ve [`setwd()` kullanmama nedenleriniz için okuyunuz](https://www.tidyverse.org/blog/2017/12/workflow-vs-script/). Kısacası, işiniz bilgisayarınıza özel hale gelir, dosyaları içe ve dışa aktarmak için kullanılan dosya yolları "kırılgan" hale gelir ve bu, işbirliğini ve kodunuzun başka herhangi bir bilgisayarda kullanılmasını ciddi şekilde engeller. Kolay alternatifler var!

Yukarıda belirtildiği gibi, çoğu durumda bu yaklaşımı önermesek de, `setwd()` komutunu alıntılarda istediğiniz klasör dosya yolu ile kullanabilirsiniz, örneğin:

```{r, eval=F}
setwd("C:/Documents/R Files/My analysis")
```

[***TEHLİKE:*** `setwd()` ile bir çalışma dizini ayarlamak dosya yolu bir bilgisayara özelse "kırılgan" *olabilir*. Bunun yerine, bir R Project kök dizinine göre dosya yollarını kullanın (**burada** paketiyle). ]{style="renk: kırmızı;"}

<!-- ============================================ ========= -->

### Manuel olarak ayarla {.unnumbered}

Çalışma dizinini manuel olarak ayarlamak için ('setwd()'nin tıklamakla eşdeğeri), Oturum açılır menüsünü tıklayın ve "Çalışma Dizinini Ayarla"ya ve ardından "Dizin Seç"e gidin. Bu, o belirli R oturumu için çalışma dizinini ayarlayacaktır. Not: Bu yaklaşımı kullanıyorsanız, RStudio'yu her açtığınızda bunu manuel olarak yapmanız gerekecektir.

<!-- ============================================ ========= -->

### Bir R projesi içinde {.unnumbered}

Bir R projesi kullanıyorsanız, çalışma dizini varsayılan olarak ".rproj" dosyasını içeren R projesi kök klasörü olacaktır. Bu, RStudio'yu R Project'i (".rproj" uzantılı dosya) tıklayarak açarsanız geçerli olacaktır.

<!-- ============================================ ========= -->

### R markdown için çalışma dizini {.unnumbered}

Bir R markdown komut dosyasında, varsayılan çalışma dizini, Rmarkdown dosyasının (`.Rmd`) içinde kaydedildiği klasördür. Bir R projesi ve **here** paketi kullanılıyorsa, bu geçerli değildir ve çalışma dizini [R projeleri] sayfasında açıklandığı gibi 'here()' olacaktır.

Tek başına bir R markdown çalışma dizinini değiştirmek istiyorsanız (bir R projesinde değil), 'setwd()' kullanırsanız, bu yalnızca o belirli kod yığını için geçerli olacaktır. Bir R işaretlemesindeki tüm kod parçalarında değişiklik yapmak için, aşağıdaki gibi "root.dir =" parametresini eklemek için kurulum öbeğini düzenlemelisiniz:

```{r, eval=F}
knitr::opts_knit$set(root.dir = 'desired/directorypath')
```

Bir R projesinde sadece R işaretlemesini kullanmak ve **here** paketini kullanmak çok daha kolaydır.

<!-- ============================================ ========= -->

### Dosya yolları sağlama {.unnumbered}

Yeni başlayanlar için (en azından bir Windows makinesinde) belki de en yaygın hayal kırıklığı kaynağı, verileri içe veya dışa aktarmak için bir dosya yoluna yazmaktır. [İçe ve dışa aktar] sayfasında dosya yollarının en iyi nasıl girileceğine dair kapsamlı bir açıklama vardır, ancak burada birkaç önemli nokta vardır:

**Bozuk yollar**

Aşağıda bir "mutlak" veya "tam adres" dosya yolu örneği verilmiştir. Bunlar başka bir bilgisayar tarafından kullanılırsa büyük olasılıkla kırılacaktır. Bir istisna, paylaşılan/ağ sürücüsü kullanmanızdır.

    C:/Kullanıcılar/Ad/Belge/Analitik Yazılım/R/Projeler/Analiz2019/data/March2019.csv

** Eğik yön**

*Bir dosya yolu yazıyorsanız, eğik çizgilerin yönüne dikkat edin.* Bileşenleri ayırmak için *eğik çizgi* (`/`) kullanın ("data/provincial.csv"). Windows kullanıcıları için, dosya yollarının varsayılan görüntülenme şekli *ters eğik çizgi* (\\) iledir - bu nedenle her eğik çizginin yönünü değiştirmeniz gerekecektir. **here** paketini [R projeleri] sayfasında açıklandığı gibi kullanırsanız, eğik çizgi bir sorun olmaz.

**Göreceli dosya yolları**

Bunun yerine genellikle "göreceli" dosya yolları sağlamanızı öneririz - yani, R Projenizin köküne *göre* olan yol. Bunu, [R projeleri] sayfasında açıklandığı gibi **here** paketini kullanarak yapabilirsiniz. Göreceli bir dosya yolu şöyle görünebilir:

```{r, eval=F}
# Bir R projesinin veri/satır listesi/temiz/alt klasörlerinden csv satır listesini içe aktarın
linelist <- import(here("data", "clean", "linelists", "marin_country.csv"))
```

Bir R projesinde göreli dosya yolları kullanıyor olsanız bile, R projenizin dışında verileri içe/dışa aktarmak için mutlak yolları kullanabilirsiniz.

<!-- ============================================ ========= -->

## Nesneler {#objects}

R'daki her şey bir nesnedir ve R, "nesne yönelimli" bir dildir. Bu bölümler şunları açıklayacaktır:

- Nesneler nasıl oluşturulur (`<-`)
- Nesne türleri (örn. veri çerçeveleri, vektörler..)\
- Nesnelerin alt bölümlerine nasıl erişilir (ör. bir veri kümesindeki değişkenler)\
- Nesne sınıfları (örn. sayısal, mantıksal, tamsayı, çift, karakter, faktör)

<!-- ============================================ ========= -->

### Her şey bir nesnedir {.unnumbered}

*Bu bölüm [R4Epis projesinden](https://r4epis.netlify.app/training/r_basics/objects/) uyarlanmıştır.*\
R'da sakladığınız her şey - veri kümeleri, değişkenler, köy isimleri listesi, toplam nüfus sayısı, hatta grafikler gibi çıktılar - **atanmış bir adla** ve **alıntılanabilen** **nesnelerdir**.

Bir nesneye bir değer atadığınızda var olur (aşağıdaki atama bölümüne bakın). Bir değer atandığında, nesne Ortamda görünür (RStudio'nun sağ üst bölmesine bakın). Daha sonra çalıştırılabilir, manipüle edilebilir, değiştirilebilir ve yeniden tanımlanabilir.

<!-- ============================================ ========= -->

### Nesneleri tanımlama (`<-`) {.unnumbered}

**\<- operatörüyle *nesnelere bir değer* atayarak nesneler oluşturun.**\
"<-" atama operatörü olarak tanımlanır. Atama komutları genellikle standart bir sıra izler:

**nesne_adı** \<- **değer** (veya bir değer üreten süreç/hesaplama)

Örneğin, mevcut epidemiyolojik raporlama haftasını daha sonraki kodda referans için bir nesne olarak kaydetmek isteyebilirsiniz. Bu örnekte, "current_week" nesnesi "2018-W10"' değeri atandığında oluşturulur (tırnak işaretleri bunu bir karakter değeri yapar). 'current_week' nesnesi daha sonra RStudio Ortam bölmesinde (sağ üst) görünecek ve sonraki komutlarda başvurulabilecektir.

Aşağıdaki kutularda R komutlarına ve çıktılarına bakabilirsiniz.

```{r basics_objects_assignment}
current_week <- "2018-W10"   # bu komut, bir değer atayarak current_week nesnesini yaratır.
current_week                 # bu komut, geçerli_hafta nesnesinin geçerli değerini konsolda yazdırır
```

[***NOT:*** R konsol çıktısındaki `[1]` sadece çıktının ilk öğesini görüntülediğinizi belirtir]{style="color: black;"}

[***DİKKAT:*** **Bir nesnenin değerinin üzerine  yeniden tanımlamak için bir atama komutu herhangi bir zamanda yazılabilir** Bu nedenle, **çalışan komutların sırası çok önemlidir**.]{style="color: orange;"}

Aşağıdaki komut, "current_week" değerini yeniden tanımlayacaktır:

```{r basics_objects_reassignment}
current_week <- "2018-W51"   # current_week nesnesine YENİ bir değer atar
current_week                 # bu yeni değeri konsolda yazdırır
```

**Eşittir işaretleri `=`**

Ayrıca R kodunda eşittir işaretleri göreceksiniz:

- İki nesne veya değer arasındaki bir çift eşittir işareti `==` mantıksal bir *soru sorar*: "buna eşit mi?".\
- Ayrıca, fonskiyonların değişkenlerinin değerlerini belirtmek için kullanılan eşittir işaretlerini de göreceksiniz (bunlar hakkında aşağıdaki bölümlerde okuyun), örneğin `max(age, na.rm = TRUE)`.\
- Nesneleri oluşturmak ve tanımlamak için `<-` yerine tek bir eşittir işareti `=` *kullanabilirsiniz*, ancak bu önerilmez. Bunun neden önerilmediğini [buradan](https://renkun.me/2014/01/28/difference-between-assignment-operators-in-r/) okuyabilirsiniz.

**Veri kümeleri (Datasets)**

Veri kümeleri de nesnelerdir (tipik olarak "veri çerçeveleri") ve içe aktarıldıklarında adlarının atanması gerekir. Aşağıdaki kodda, 'linelist' nesnesi oluşturulur ve **rio** paketi ve 'import()' fonksiyonu ile içe aktarılan bir CSV dosyasının değeri atanır.

```{r basics_objects_dataframes, eval=FALSE}
# satır listesi oluşturulur ve içe aktarılan CSV dosyasının değeri atanır
linelist <- import("my_linelist.csv")
```

[İçe aktarma ve dışa aktarma] bölümünden veri kümelerini içe ve dışa aktarma hakkında daha fazla bilgi edinebilirsiniz.

[***DİKKAT:*** Nesnelerin adlandırılmasıyla ilgili kısa bir not:]{style="color: orange;"}

- Nesne adları boşluk içermemelidir, ancak boşluk yerine alt çizgi (\_) veya nokta (.) kullanabilirsiniz.\
- Nesne adları büyük/küçük harfe duyarlıdır (yani Veri Kümesi_A, veri kümesi_A'dan farklıdır).
- Nesne adları bir harfle başlamalıdır (1, 2 veya 3 gibi bir sayı ile başlayamaz).

**Çıktılar**

Tablolar ve çizimler gibi çıktılar, çıktıların nesneler olarak nasıl kaydedilebileceğine veya kaydedilmeden nasıl yazdırılabileceğine dair bir örnek sağlar. **Temel** R fonksiyonu "table()" kullanılarak cinsiyet ve kazanç tablosu doğrudan R konsoluna yazdırılabilir (*kaydedilmeden*).

```{r}
# yalnızca R konsoluna yazdırılır
table(linelist$gender, linelist$outcome)
```

Ancak aynı tablo adlandırılmış bir nesne olarak kaydedilebilir. Daha sonra isteğe bağlı olarak yazdırılabilir.

```{r}
# kayıt
gen_out_table <- table(linelist$gender, linelist$outcome)

#  yazdırma
gen_out_table
```

**Sütunlar**

Bir veri kümesindeki sütunlar da nesnelerdir ve aşağıda Sütunlar bölümünde açıklandığı gibi tanımlanabilir, üzerine yazılabilir ve oluşturulabilirdir.

Yeni bir sütun oluşturmak için **temel** R'dan atama operatörünü kullanabilirsiniz. Aşağıda, yeni sütun "bmi" (Vücut Kitle İndeksi) oluşturulur ve her satır için yeni değer, satırın "wt_kg" ve "ht_cm" sütunlarındaki değeri üzerindeki matematiksel bir işlemin sonucudur.

```{r, eval=F}
# temel R sözdizimini kullanarak yeni "bmi" sütunu oluşturun
linelist$bmi <- linelist$wt_kg / (linelist$ht_cm/100)^2
```

Bununla birlikte, bu el kitabında, **dplyr** paketindeki `mutate()` fonksiyonunu ve tünel operatörüyle (`%>%`) *piping* fonksiyonunu kullanan sütunları tanımlamaya yönelik farklı bir yaklaşımı vurguluyoruz. Sözdiziminin okunması daha kolaydır ve [Temizleme verileri ve temel fonksiyonlar] sayfasında açıklanan başka avantajları da vardır. *tünelleme* hakkında daha fazla bilgiyi aşağıdaki Tünelleme bölümünde okuyabilirsiniz.

```{r, eval=F}
# dplyr sözdizimini kullanarak yeni "bmi" sütunu oluşturun
linelist <- linelist %>% 
  mutate(bmi = wt_kg / (ht_cm/100)^2)
```

<!PİPİNG OLAYINI HİÇ ANLAMADIM-- ======================================================= -->

### Nesne yapısı {.unnumbered}

**Nesneler tek bir veri parçası olabilir (ör. "my_number <- 24") veya yapılandırılmış verilerden oluşabilir.**

Aşağıdaki grafik [bu çevrimiçi R eğitiminden](http://venus.ifca.unican.es/Rintro/dataStruct.html) ödünç alınmıştır. Bazı yaygın veri yapılarını ve adlarını gösterir. [GIS temelleri] sayfasında tartışılan uzamsal veriler bu görüntüye dahil değildir.

```{r basics_objects_structures, echo=F, out.width = "75%", out.height="50%", fig.align = "center"}
knitr::include_graphics(here::here("images", "R_data_structures.png"))
```

Epidemiyolojide (ve özellikle saha epidemiyolojisinde), *en yaygın olarak* veri çerçeveleri ve vektörlerle karşılaşacaksınız:

+------------------+--------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------+
| Yaygın Yapılar | Açıklama                                                                     | Örnekler                                                                             |
+==================+==================================================================================================+=====================================================================================+
| Vektörler          | Hepsi aynı sınıftan (ör. sayısal, karakter) tekil nesneler dizisi için bir kapsayıcı. | **Veri çerçevelerindeki "Değişkenler" (sütunlar) vektörlerdir** (ör. "age_years" sütunu). |
+------------------+--------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------+
| Veri Çerçeveleri   | Hepsi aynı sayıda satıra sahip olan birbirine bağlı vektörler (örneğin sütunlar).           | `satır_listesi` bir veri çerçevesidir.                                                         |
+------------------+--------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------+

"Tek başına" (bir veri çerçevesinin parçası olmayan) bir vektör oluşturmak için "c()" fonksiyonunun farklı öğeleri birleştirmek için kullanıldığını unutmayın. Örneğin, bir renk vektörü oluşturuyorsanız, grafiğin renk skalası: `vector_of_colors <- c("blue", "red2", "orange", "grey")`

<!-- ============================================ ========= -->

### Nesne sınıfları {.unnumbered}

R'da depolanan tüm nesnelerin, R'a nesneyi nasıl kullanacağını söyleyen bir *sınıfı* vardır. Birçok olası sınıf vardır, ancak ortak olanlar şunları içerir:

+------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------+
| Sınıf      | Açıklama                                                                                            | Örnekler                                                      |
+============+=========================================================================================================================================================================================+=======================================================================================================+
| Karakter   | Bunlar **"tırnak içinde"** bulunan metin/kelimeler/cümlelerdir . Bu nesneler üzerinde matematik yapılamaz.  | "Karakter nesneleri tırnak içindedir"                                                            |
+------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------+
| Tam Sayı    | **Yalnızca tam** olan sayılar (virgülden sonra ondalığı yok)                                                                                                                                         | -5, 14, veya 2000                                                                                       |
+------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------+
| Sayısal(Nümerik)    | Bunlar sayılardır ve **ondalık sayılar içerebilir**. Tırnak içindeyseler, karakter sınıfı olarak kabul edilirler.                                                             | 23.1 veya 14                                                                                            |
+------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------+
| Faktör     | Bunlar, **belirtilmiş bir sıraya** veya değerler hiyerarşisine sahip vektörlerdir.                                                                                                     | Sıralı değerlere sahip bir ekonomik durum değişkeni                                                  |
+------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------+
| Tarih       |**R'a belirli verilerin Tarih olduğu söylendiğinde**, bu veriler özel yollarla manipüle edilebilir ve görüntülenebilir. Daha fazla bilgi için [Tarihlerle çalışma] sayfasına bakın.| 2018-04-12 veya 15/3/1954 veya Çrş 4 Ocak 1980                                                             |
+------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------+
| Mantıksal (Logical)    | Değerler DOĞRU veya YANLIŞ iki özel değerden biri olmalıdır (bunların tırnak içinde **değil** "DOĞRU" ve "YANLIŞ" olduğuna dikkat edin)                                                              | DOĞRU veya YANLIŞ                                                                                         |
+------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------+
| veri Çerçevesi (data frame) | Veri çerçevesi, R'ın **tipik bir veri kümesini** nasıl depoladığıdır. Hepsi aynı sayıda gözleme (satır) sahip olan birbirine bağlı veri vektörlerinden (sütunlarından) oluşur.         | 'linelist_raw' adlı örnek AJS veri kümesi, her biri 300 gözlem (satır) içeren 68 değişken içerir. |
+------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------+
| Tibble     | tibbles, veri çerçevesindeki bir varyasyondur, ana operasyonel fark, konsola daha güzel yazdırmalarıdır (ilk 10 satırı ve yalnızca ekrana uyan sütunları görüntüleyin) | Herhangi bir veri çerçevesi, liste veya matris, `as_tibble() ile bir tibble'a dönüştürülebilir.`                       |
+------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------+
| Liste       | Liste vektör gibidir, ancak diğer nesneler farklı sınıflara ait olabilir.                                                                                                     | Bir liste tek bir sayıyı, bir veri çerçevesini ve bir vektörü ve hatta içinde başka bir listeyi içerebilir!   |
+------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------+

**Bir nesnenin sınıfını, adını `class()`** fonksiyonuna vererek test edebilirsiniz. Not: Veri kümesinin adını ve sütunun adını ayırmak için "$" gösterimini kullanarak bir veri kümesi içindeki belirli bir sütuna başvurabilirsiniz.

```{r, echo=TRUE,}
class(linelist) # sınıfı bir veri çerçevesi veya tibble olmalıdır

class(linelist$age) # sınıfı sayısal olmalıdır

class(linelist$gender) # sınıfı karakter olmalı
```

Bazen bir sütun R tarafından otomatik olarak farklı bir sınıfa dönüştürülür. Buna dikkat edin! Örneğin, bir vektörünüz veya sayı sütununuz varsa, ancak bir karakter değeri eklenirse... sütunun tamamı sınıf karakterine dönüşür.

```{r}
num_vector <- c(1,2,3,4,5)       # vektörü tüm sayılar olarak tanımla
class(num_vector)                # vektör sayısal bir sınıftır
num_vector[3] <- "üç"            # üçüncü elemanı bir karaktere çevir
class(num_vector)                # vektör artık karakter sınıfıdır
```

Bunun yaygın bir örneği, bir tablo yazdırmak için bir veri çerçevesini manipüle etmektir - toplam bir satır yaparsanız ve sayılarla aynı hücredeki yüzdeleri yapıştırmaya çalışırsanız (örneğin '23 (%40)'), yukarıdaki sayısal sütunun tamamı karaktere dönüştürülecek ve artık matematiksel hesaplamalar için kullanılamayacak.**Bazen nesneleri veya sütunları başka bir sınıfa dönüştürmeniz gerekebilir.**

+------------------+---------------------------------------------------------------------------------------+
| Fonksiyon         | Eylem                                                                                |
+==================+=======================================================================================+
| `as.character()` | Karakter sınıfına çevirir                                                           |
+------------------+---------------------------------------------------------------------------------------+
| `as.numeric()`   | Sayısal sınıfına çevirir                                                             |
+------------------+---------------------------------------------------------------------------------------+
| `as.integer()`   | Tam Sayı sınıfına çevirir                                                            |
+------------------+---------------------------------------------------------------------------------------+
| `as.Date()`      | Tarih sınıfına dönüştürür - Not: Ayrıntılar için [dates](#dates) bölümüne bakıns             |
+------------------+---------------------------------------------------------------------------------------+
| `factor()`       | Faktöre dönüştürür - Not: değer düzeylerinin sırasını yeniden tanımlamak için ekstra değişkenler gerekir |
+------------------+---------------------------------------------------------------------------------------+

Benzer şekilde, belirli bir sınıfa ait bir nesnenin IS olup olmadığını kontrol etmek için **temel** R fonksiyonları vardır. Örneğin "is.numeric()", "is.character()", "is.double()", "is.factor()`, `is.integer()`

[R'daki sınıflar ve veri yapıları hakkında daha fazla çevrimiçi materyal](https://swcarpentry.github.io/r-novice-inflammation/13-supp-data-structures/).

<!-- ============================================ ========= -->

### Sütunlar/Değişkenler (`$`) {.unnumbered}

**Veri çerçevesindeki bir sütun teknik olarak bir "vektördür" (yukarıdaki tabloya bakın)** - tümü aynı sınıfta olması gereken bir dizi değer (karakter, sayısal, mantıksal vb.).

Bir vektör, bir veri çerçevesinden bağımsız olarak var olabilir. Örneğin, bir modelde açıklayıcı değişkenler olarak dahil etmek istediğiniz sütun adlarından oluşan bir vektör. "Bağımsız" bir vektör oluşturmak için aşağıdaki gibi `c()` fonksiyonunu kullanın:

```{r, warning=F, message=F}
# karakter değerlerinin bağımsız vektörünü tanımlayın
explanatory_vars <- c("gender", "fever", "chills", "cough", "aches", "vomit")

# bu adlandırılmış vektördeki değerleri yazdır
explanatory_vars
```

**Bir veri çerçevesindeki sütunlar da vektörlerdir ve çağrılabilir, referans alınabilir, ayıklanabilir veya `$` sembolü kullanılarak oluşturulabilir.** `$` sembolü, sütunun adını veri çerçevesinin adına bağlar. Bu el kitabında "değişken" yerine "sütun" kelimesini kullanmaya çalışıyoruz.

```{r basics_objects_call, eval=F}
# age_years vektörünün uzunluğunu alın
length(linelist$age) # (yaş, satır listesi veri çerçevesindeki bir sütundur)

```

Veri çerçevesinin adının ardından `$' yazarak, veri çerçevesindeki tüm sütunların bir açılır menüsünü de göreceksiniz. Ok tuşunuzu kullanarak aralarında gezinebilir, Enter tuşu ile birini seçebilir ve yazım hatalarından kaçınabilirsiniz!

```{r echo=F, out.width = "100%", fig.align = "center"}
knitr::include_graphics(here::here("images", "Calling_Names.gif"))
```
[***GELİŞMİŞ İPUCU:*** Bazı daha karmaşık nesnelerin (örneğin bir liste veya bir "epicontacts" nesnesi) birden çok dolar işaretiyle erişilebilen birden çok düzeyi olabilir. Örneğin, `epicontacts$linelist$date_onset`]{style="color: darkgreen;"}

<!-- ============================================= ========= -->

### Köşeli ayraçlarla erişim/dizin (`[ ]`) {.unnumbered}

Genellikle "[ ]" köşeli parantezleri kullanılarak yapılan, "indeksleme" olarak da adlandırılan nesnelerin parçalarını görüntülemeniz gerekebilir. Bir sütuna erişmek için bir veri çerçevesinde `$` kullanmak da bir indeksleme türüdür.

```{r}
my_vector <- c("a", "b", "c", "d", "e", "f")  # Vektörün tanımlanması
my_vector[5]                                  # 5. ögenin yazdırılması
```

Köşeli parantezler ayrıca, bir "summary()" fonksiyonunun çıktısı gibi, döndürülen çıktının belirli bölümlerini döndürmek için de çalışır:

```{r}
# Özetin tamamı
summary(linelist$age)

# Özetin yalnızca ikinci ögesi, adıyla (yalnızca tek parantez kullanarak)
summary(linelist$age)[2]

# Sadece ikinci öge, isimsiz (çift parantez kullanarak)
summary(linelist$age)[[2]]

# Bir öğeyi, adını göstermeden adıyla ayıklayın
summary(linelist$age)[["Median"]]

```

Parantezler ayrıca belirli satırları ve sütunları görüntülemek için veri çerçeveleri üzerinde de çalışır. Bunu, `dataframe[rows, column]` sözdizimini kullanarak yapabilirsiniz:

```{r basics_objects_access, eval=F}
# Tüm sütunlarla birlikte veri kümesinden belirli bir satırı (2) görüntüleyin (virgül unutmayın!)
linelist[2,]

# Tüm satırları görüntüleyin, ancak yalnızca bir sütun
linelist[, "date_onset"]

# 2. satırdaki ve 5 ile 10 arasındaki sütunlardaki değerleri görüntüleyin
linelist[2, 5:10] 

# 2. satırdaki ve 5. ila 10. ve 18. sütunlardaki değerleri görüntüleyin
linelist[2, c(5:10, 18)] 

# 2'den 20'ye kadar olan satırları ve belirli sütunları görüntüleyin
linelist[2:20, c("date_onset", "outcome", "age")]

# Ölçüte göre satırları ve sütunları görüntüleyin
# *** Veri çerçevesinin kriterlerde hala adlandırılması gerektiğine dikkat edin!
linelist[linelist$age > 25 , c("date_onset", "outcome", "age")]

# RStudio Viewer bölmesindeki çıktıları görmek için View()'i kullanın (okunması daha kolay)
# *** View() fonksiyonunda büyük "V" harfini not edin
View(linelist[2:20, "date_onset"])

# Yeni bir nesne olarak kaydet
new_table <- linelist[2:20, c("date_onset")] 
```

**dplyr** sözdizimini (satırlar için 'filter()' ve sütunlar için 'select()' fonksiyonları) kullanarak veri çerçeveleri ve tibbles üzerinde yukarıdaki satır/sütun indekslemeyi de gerçekleştirebileceğinizi unutmayın. [Temizleme verileri ve temel fonksiyonlar] sayfasında bu temel fonksiyonlar hakkında daha fazla bilgi edinin.

"Satır numarasına" göre filtrelemek için, mantıksal bir filtreleme ifadesinin parçası olarak açık parantezlerle **dplyr** `row_number()` fonksiyonunu kullanabilirsiniz. Aşağıda gösterildiği gibi, genellikle bu mantıksal ifadenin bir parçası olarak "%in%" operatörünü ve bir dizi sayıyı kullanacaksınız. *ilk* N satırı görmek için, özel **dplyr** fonksiyonu `head()` de kullanabilirsiniz.

```{r, eval=F}
# İlk 100 satırı görüntüle
linelist %>% head(100)

# Sadece 5. satırı görüntüke
linelist %>% filter(row_number() == 5)

# 2'den 20'ye kadar olan satırları ve üç özel sütunu görüntüleyin (sütun adlarında tırnak işareti gerekmediğini unutmayın)
linelist %>% filter(row_number() %in% 2:20) %>% select(date_onset, outcome, age)
```

**list** sınıfının bir nesnesini indekslerken, yalnızca tek bir nesne döndürülse bile, tek parantezler her zaman sınıf listesiyle birlikte döner. Ancak çift parantezler, tek bir öğeye erişmek ve listeden farklı bir sınıf döndürmek için kullanılabilir.\
Parantezler ayrıca aşağıda gösterildiği gibi birbiri ardına yazılabilir.

Bu [liste indekslemenin tuzlukla görsel açıklaması](https://r4ds.had.co.nz/vectors.html#lists-of-condiments) komik ve faydalıdır.

```{r}
# demo listesini tanımla
my_list <- list(
  # Listedeki ilk öge karakter vektörü
  hospitals = c("Central", "Empire", "Santa Anna"),
  
  # Listedeki ikinci öge adreslerin veri çerçevesi
  addresses   = data.frame(
    street = c("145 Medical Way", "1048 Brown Ave", "999 El Camino"),
    city   = c("Andover", "Hamilton", "El Paso")
    )
  )
```

Konsola yazdırıldığında listenin nasıl göründüğü aşağıda açıklanmıştır. Nasıl adlandırılmış iki öğe olduğunu görün:

- "hospitals", bir karakter vektörü\
- "addresses", adreslerin bir veri çerçevesi

```{r}
my_list
```

Şimdi çeşitli yöntemler kullanarak ayıklıyoruz:

```{r}
my_list[1] # bu, "list" sınıfındaki öğeyi döndürür - öğe adı hala görüntüleniyor

my_list[[1]] # bu yalnızca (adsız) karakter vektörünü döndürür

my_list[["hospitals"]] # ayrıca liste öğesinin adına göre dizin oluşturabilirsiniz

my_list[[1]][3] # "hastaneler" karakter vektörünün üçüncü öğesini döndürür

my_list[[2]][1] # Bu, adres veri çerçevesinin ilk sütununu ("sokak") döndürür

```

<!-- ======================================================= -->

### Nesneleri kaldırma {.unnumbered}

'rm()' fonksiyonu ile (tırnak işaretleri olmadan) R ortamınızdan tek tek nesneleri kaldırabilirsiniz:

```{r, eval=F}
rm(object_name)
```

Aşağıdakileri çalıştırarak tüm nesneleri kaldırabilirsiniz (çalışma alanınızı temizleyin):

```{r, eval=F}
rm(list = ls(all = TRUE))
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Tünelleme (`%>%`)

**Nesnelerle çalışmaya yönelik iki genel yaklaşım şunlardır:**

1) **Tüneller/tidyverse** - tüneller nesneyi bir fonksiyondan diğerine gönderir - vurgu nesne değil *eylem* üzerindedir\
2) **Ara nesneleri tanımlayın** - bir nesne tekrar tekrar tanımlanır - vurgu nesne üzerindedir

<!-- ============================================ ========= -->

### **Tüneller** {.unnumbered}

**Basitçe açıklandığı gibi, tünel operatörü (`%>%`) bir fonksiyondan diğerine bir ara çıktı iletir.**\
Bunu "sonrasında" demek gibi düşünebilirsiniz. Birçok fonksiyon `%>%` ile birbirine bağlanabilir.

- **Tünelleme, eylemlerin gerçekleştirildiği nesneyi değil, bir dizi eylemi vurgular**\
- Tüneller, bir nesne üzerinde bir dizi eylem gerçekleştirilmesi gerektiğinde en iyisidir\
- Tüneller, otomatik olarak **dplyr** ve **tidyverse** paketlerine dahil edilen **magrittr** paketinden gelir
- Tüneller, kodu daha temiz ve okunması daha kolay, daha sezgisel hale getirebilir

Bu yaklaşımla ilgili daha fazla bilgiyi tidyverse [stil kılavuzunda] (https://style.tidyverse.org/pipes.html) okuyabilirsiniz.

İşte "kek pişirmek" için kurgusal fonksiyonları kullanan karşılaştırma için sahte bir örnek. İlk olarak, tünel yöntemi:

```{r piping_example_pipe, eval=F}
# Tünel sözdizimi kullanarak kek pişirmenin sahte bir örneği

cake <- flour %>%       # Kek pişirmek için önce undan başlanır, sonrasında...
  add(eggs) %>%   # yumurtaları ekle
  add(oil) %>%    # yağı ekle
  add(water) %>%  # suyu ekle
  mix_together(         # birlikte karıştır
    utensil = spoon,
    minutes = 2) %>%    
  bake(degrees = 350,   # pişir
       system = "fahrenheit",
       minutes = 35) %>%  
  let_cool()            # soğumaya bırak
```

İşte tünellerin kullanımını açıklayan başka bir [bağlantı](https://cfss.uchicago.edu/notes/pipes/#:~:text=Pipes%20are%20an%20extremely%20useful,code%20and%20combine%20multiple%20operations).

Tünelleme bir **temel** fonksiyon değildir. Tünelleri kullanmak için **magrittr** paketi kurulmalı ve yüklenmelidir (bu genellikle, onu içeren **tidyverse** veya **dplyr** paketi yüklenerek yapılır). [magrittr belgelerinde tünelleme hakkında daha fazla bilgi edinebilirsiniz](https://magrittr.tidyverse.org/).

Diğer R komutlarında olduğu gibi, tünellerin yalnızca sonucu görüntülemek veya "<-" atama operatörünün dahil olup olmadığına bağlı olarak bir nesneyi kaydetmek/yeniden kaydetmek için kullanılabileceğini unutmayın. Her ikisine de bakın:

```{r, eval=F}
# Yaş kategorisine göre toplam sayım olarak tanımlayarak nesne oluşturun veya üzerine yazın (yazdırılmaz)
linelist_summary <- linelist %>% 
  count(age_cat)
```

```{r}
# Konsoldaki sayım tablosunu yazdırın, ancak kaydetmeyin
linelist %>% 
  count(age_cat)
```

**`%<>%`**\
Bu, **magrittr** paketinden bir "atama tüneli"dir ve bu, bir nesneyi ileriye taşır ve aynı zamanda nesneyi yeniden tanımlar*. Zincirdeki ilk tünel operatörü olmalıdır. Kısa yol. Aşağıdaki iki komut eşdeğerdir:

```{r, eval=F}
linelist <- linelist %>%
  filter(age > 50)

linelist %<>% filter(age > 50)
```

<!-- ======================================================= -->

### Ara nesneleri tanımlayın {.unnumbered}

Nesneleri/veri çerçevelerini değiştirmeye yönelik bu yaklaşım, aşağıdaki durumlarda daha iyi olabilir:

- Birden çok nesneyi manipüle etmeniz gerekirse\
- Anlamlı olan ve ayrı nesne adlarını hak eden ara adımlar varsa

**Riskler:**

- Her adım için yeni nesneler oluşturmak, çok sayıda nesne oluşturmak anlamına gelir. Eğer yanlış olanı kullanırsan, bunu fark etmeyebilirsin!\
- Tüm nesneleri adlandırmak kafa karıştırıcı olabilir\
- Hatalar kolayca tespit edilemeyebilir

Her bir ara nesneyi adlandırın veya orijinalin üzerine yazın veya tüm fonksiyonları bir araya getirin. Hepsi kendi riskleriyle birlikte gelir.

Aşağıda, yukarıdakiyle aynı sahte "kek" örneği verilmiştir, ancak bu stili kullanarak:

```{r piping_example_redefine, eval=F}
# bu yöntemi kullanarak kek pişirmenin sahte bir örneği (ara nesneleri tanımlama)
batter_1 <- left_join(flour, eggs)
batter_2 <- left_join(batter_1, oil)
batter_3 <- left_join(batter_2, water)

batter_4 <- mix_together(object = batter_3, utensil = spoon, minutes = 2)

cake <- bake(batter_4, degrees = 350, system = "fahrenheit", minutes = 35)

cake <- let_cool(cake)
```

Tüm fonksiyonları bir araya getirin - bunu okumak zordur:

```{r eval=F}
# birden çok fonksiyonu bir araya getirme/iç içe yerleştirme örneği - okunması zordur
cake <- let_cool(bake(mix_together(batter_3, utensil = spoon, minutes = 2), degrees = 350, system = "fahrenheit", minutes = 35))
```

<!-- ======================================================= -->

## Anahtar operatörler ve fonksiyonlar {#operators}

Bu bölüm, R'daki operatörleri detaylandırır, örneğin:

- Tanımsal operatörler\
- İlişkisel operatörler (küçüktür, eşittir çok ..)\
- Mantıksal operatörler (ve, veya...)\
- Eksik değerlerin işlenmesi\
- Matematiksel operatörler ve fonksiyonlar (+/-, \>, toplam(), medyan(), ...)\
- `%in%` operatörü

<!-- ============================================ ========= -->

### Atama operatörleri {.unnumbered}

**`<-`**

R'daki temel atama operatörü `<-` şeklindedir. Öyle ki `nesne_adı <- değer`.\
Bu atama operatörü `=` şeklinde de yazılabilir. Genel R kullanımı için `<-` kullanılmasını tavsiye ederiz.\
Okunabilirlik için bu tür operatörleri boşluklarla çevrelemenizi de öneririz.

**`<<-`**

[Yazma fonksiyonlarını] veya R'ı kaynaklı komut dosyalarıyla etkileşimli bir şekilde kullanıyorsanız, bu atama operatörünü `<<-` (**base** R'dan) kullanmanız gerekebilir. Bu operatör, daha yüksek bir 'ana' R Ortamında bir nesneyi tanımlamak için kullanılır. Bu [çevrimiçi referansa](https://stat.ethz.ch/R-manual/R-devel/library/base/html/assignOps.html) bakabilirsiniz.

**`%<>%`**

Bu, bir nesneyi ileriye yönlendiren ve *aynı zamanda nesneyi yeniden tanımlayan* **magrittr** paketinden bir "atama tünelidir". Zincirdeki ilk tünel operatörü olmalıdır. Aşağıda iki eşdeğer örnekte gösterildiği gibi kısa yoldur:

```{r, eval=F}
linelist <- linelist %>% 
  mutate(age_months = age_years * 12)
```

Yukarıdaki aşağıdakine eşdeğerdir.

```{r, eval=F}
linelist %<>% mutate(age_months = age_years * 12)
```

**`%<+%`**

Bu, **ggtree** paketi ile filogenetik ağaçlara veri eklemek için kullanılır. [Filogenetik ağaçlar] sayfasına veya bu çevrimiçi [kaynak kitap](https://yulab-smu.top/treedata-book/) sayfasına bakabilirsiniz.

<!-- ============================================= ========= -->

### İlişkisel ve mantıksal operatörler {.unnumbered}

İlişkisel operatörler değerleri karşılaştırır ve genellikle yeni değişkenleri ve veri kümelerinin alt kümelerini tanımlarken kullanılır. R'daki ortak ilişkisel operatörler şunlardır:

+--------------------------+------------+--------------+--------------------------------------------------------------------------------------------------------------------------------------------------------+
| Anlamı                  | Operatör   | Örnek         | Örnek Sonucu                                                                                                                                         |
+==========================+============+==============+========================================================================================================================================================+
| Eşittir                | `==`       | `"A" == "a"` | `FALSE` (çünkü R büyük/küçük harf duyarlıdır) *== (çift eşittir) öğesinin = (tekli eşittir) fonksiyonundan farklı olduğuna ve bu atama operatörünün `<-`* gibi davrandığına dikkat edin |
+--------------------------+------------+--------------+--------------------------------------------------------------------------------------------------------------------------------------------------------+
| Eşit değildir             | `!=`       | `2 != 0`     | `TRUE`                                                                                                                                                 |
+--------------------------+------------+--------------+--------------------------------------------------------------------------------------------------------------------------------------------------------+
| Büyüktür                 | `>`        | `4 > 2`      | `TRUE`                                                                                                                                                 |
+--------------------------+------------+--------------+--------------------------------------------------------------------------------------------------------------------------------------------------------+
| Küçüktür                 | `<`        | `4 < 2`      | `FALSE`                                                                                                                                                |
+--------------------------+------------+--------------+--------------------------------------------------------------------------------------------------------------------------------------------------------+
| Büyük eşittir            | `>=`       | `6 >= 4`     | `TRUE`                                                                                                                                                 |
+--------------------------+------------+--------------+--------------------------------------------------------------------------------------------------------------------------------------------------------+
| Küçük eşittir            | `<=`       | `6 <= 4`     | `FALSE`                                                                                                                                                |
+--------------------------+------------+--------------+--------------------------------------------------------------------------------------------------------------------------------------------------------+
| Değer eksiktir           | `is.na()`  | `is.na(7)`   | `FALSE` [Kayıp Veri] sayfasına bakabilirsiniz)                                                                                                                   |
+--------------------------+------------+--------------+--------------------------------------------------------------------------------------------------------------------------------------------------------+
| Değer tamdır             | `!is.na()` | `!is.na(7)`  | `TRUE`                                                                                                                                                 |
+--------------------------+------------+--------------+--------------------------------------------------------------------------------------------------------------------------------------------------------+

AND ve OR gibi mantıksal operatörler, genellikle ilişkisel operatörleri bağlamak ve daha karmaşık kriterler oluşturmak için kullanılır. Karmaşık ifadeler, gruplama ve uygulama sırası için parantez ( ) gerektirebilir.

+---------------------+-----------------------------------------------------------------------+
| Anlamı              | Operator                                                              |
+=====================+=======================================================================+
| VE                  | `&`                                                                   |
+---------------------+-----------------------------------------------------------------------+
| VEYA                  | `|` (dikey çizgi)                                                    |
+---------------------+-----------------------------------------------------------------------+
| Parantezler         | `( )` Kriterleri birlikte gruplandırmak ve işlem sırasını netleştirmek için kullanılır |
+---------------------+-----------------------------------------------------------------------+

Örneğin, aşağıda vaka tanımımızı oluşturmak için kullanmak istediğimiz iki değişkenli bir satır listemiz var, `hep_e_rdt`, bir test sonucu ve hanede başka vakalar olup olmadığını bize bildirecek `other_cases_in_hh`. Aşağıdaki komut, yeni "case_def" değişkenini yaratmak için "case_when()" fonksiyonunu kullanır:

```{r eval=FALSE}
linelist_cleaned <- linelist %>%
  mutate(case_def = case_when(
    is.na(rdt_result) & is.na(other_case_in_home)            ~ NA_character_,
    rdt_result == "Positive"                                 ~ "Confirmed",
    rdt_result != "Positive" & other_cases_in_home == "Yes"  ~ "Probable",
    TRUE                                                     ~ "Suspected"
  ))
```

+------------------------------------------------------------------------------------------------+--------------------------------------------+
| Üstteki örneğin kriteri                                                                   | Yeni "case_def" değişkeninde elde edilen değer |
+================================================================================================+============================================+
| "rdt_result" ve "other_cases_in_home" değişkenlerinin değeri eksik ise                          | `NA` (eksik)                             |
+------------------------------------------------------------------------------------------------+--------------------------------------------+
| "rdt_result" içindeki değer "Pozitif" ise                                                      | "Onaylanmış"                                |
+------------------------------------------------------------------------------------------------+--------------------------------------------+
| "rdt_result" içindeki değer "Pozitif" DEĞİLSE VE "other_cases_in_home" içindeki değer "Evet" ise | "Muhtemel"                                 |
+------------------------------------------------------------------------------------------------+--------------------------------------------+
| Yukarıdaki kriterlerden biri karşılanmazsa                                                    | "Şüpheli"                                |
+------------------------------------------------------------------------------------------------+--------------------------------------------+

*R'ın büyük/küçük harf duyarlı olduğuna dikkat edin, bu nedenle "Pozitif", "pozitif"ten farklıdır...*

<!-- ============================================= ========= -->

### Eksik değerler {.unnumbered}

R'da, eksik değerler "NA" ("ayrılmış" bir değer) özel değeriyle temsil edilir (büyük harfler N ve A - tırnak içinde değil). Eksik verileri başka bir şekilde kaydeden verileri içe aktarırsanız (ör. 99, "Eksik" veya .), bu değerleri "NA" olarak yeniden kodlamak isteyebilirsiniz. Bunun nasıl yapılacağı [İçe ve dışa aktar] sayfasında ele alınmaktadır.

**Bir değerin "NA" olup olmadığını test etmek için "DOĞRU" veya "YANLIŞ" döndüren özel "is.na()"** fonksiyonunu kullanın.

```{r basics_operators_missing}
rdt_result <- c("Positive", "Suspected", "Positive", NA)   # biri şüpheli, biri bilinmeyen iki pozitif vaka
is.na(rdt_result)  # rdt_result değerinin NA olup olmadığını test eder
```

[Eksik veri] sayfasındaki eksik, sonsuz, "NULL" ve imkansız değerler hakkında daha fazla bilgi edinin. [İçe ve dışa aktar] sayfasındaki verileri içe aktarırken eksik değerleri nasıl dönüştüreceğinizi öğrenin.

<!-- ============================================= ========= -->

### Matematik ve istatistik {.unnumbered}

Bu sayfadaki tüm operatörler ve fonksiyonlar, **base** R kullanılarak otomatik olarak kullanılabilir.

#### Matematiksel operatörler {.unnumbered}

Bunlar genellikle toplama, bölme, yeni sütunlar vb. oluşturmak için kullanılır. Aşağıda R'daki yaygın matematiksel operatörler verilmiştir. Operatörlerin etrafına boşluk koyup koymamanız önemli değildir.

| Amaç                | R'da Örneği  |
|---------------------|--------------|
| Toplama             | 2 + 3        |
| Çıkarma             | 2 - 3        |
| Çarpma              | 2 \* 3       |
| Bölme               | 30 / 5       |
| Üstel               | 2\^3         |
| Operasyon sırası    | ( )          |

#### Matematiksel fonksiyonlar {.unnumbered}

| Amaç               | Fonksiyon                             |
|--------------------|---------------------------------------|
| yuvarlama          | round(x, digits = n)                  |
| yuvarlama          | janitor::round_half_up(x, digits = n) |
| tavana yuvarlama   | ceiling(x)                            |
| tabana yuvarlama   | floor(x)                              |
| kesin değer        | abs(x)                                |
| karekök            | sqrt(x)                               |
| üstel              | exponent(x)                           |
| doğal logaritma    | log(x)                                |
| log 10 tabanlı     | log10(x)                              |
| log 2 tabanlı      | log2(x)                               |

Not: "round()" için "digits =", yerleştirilen ondalık sayıyı belirtir. Bir dizi anlamlı rakama yuvarlamak için `signif()` kullanın.

#### Bilimsel gösterim {.unnumbered}

Bilimsel gösterimin kullanılma olasılığı, "scipen" seçeneğinin değerine bağlıdır.

`?options` belgesinden: scipen, sayısal değerleri sabit veya üstel gösterimde yazdırmaya karar verirken uygulanacak bir cezadır. Pozitif değerler sabite ve negatif değerler bilimsel gösterime eğilimlidir: 'scipen' basamaklarından daha geniş olmadığı sürece sabit gösterim tercih edilecektir.

Düşük bir sayıya (örneğin 0) ayarlanırsa, her zaman "açık" olacaktır. R oturumunuzda bilimsel gösterimi "kapatmak" için çok yüksek bir sayıya ayarlayın, örneğin:

```{r, eval=F}
# bilimsel gösterimi kapat
options(scipen=999)
```

#### Yuvarlama {.unnumbered}

[***TEHLİKE:*** 'round()', yalnızca üst sayı çift ise 0,5'ten yuvarlayan "banker yuvarlaması"nı kullanır. Yarımları tutarlı bir şekilde en yakın tam sayıya yuvarlamak için **janitor** 'dan 'round_half_up()' kullanın. [Bu açıklamaya] bakabilirsiniz(https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html#explore-records-with-duplicated-values-for-spec-combinations-of-variables- with-get_dupes) ]{style="color: red;"}

```{r}
# işiniz için uygun yuvarlama fonksiyonunu kullanın
round(c(2.5, 3.5))

janitor::round_half_up(c(2.5, 3.5))
```

#### İstatistiksel fonksiyonlar{.unnumbered}

[***DİKKAT:*** Aşağıdaki fonksiyonlar varsayılan olarak hesaplamalarda eksik değerleri içerecektir. "na.rm = TRUE" bağımsız değişkeni belirtilmedikçe, eksik değerler "YOK" çıktısıyla sonuçlanır. Bu, kısaca `na.rm = T` şeklinde yazılabilir.]{style="color: orange;"}

| Amaç                    | Fonksiyon          |
|-------------------------|--------------------|
| Ortalama                | mean(x, na.rm=T)   |
| Ortanca                 | median(x, na.rm=T) |
| Standart Deviasyon      | sd(x, na.rm=T)     |
| dağılım\*               | quantile(x, probs) |
| toplam                  | sum(x, na.rm=T)    |
| minimum değer           | min(x, na.rm=T)    |
| maksimum değer          | max(x, na.rm=T)    |
| Numerik veri aralığı    | range(x, na.rm=T)  |
| özet\*\*                | summary(x)         |

Notlar:

- "*quantile()": "x" incelenecek sayısal vektördür ve "prob =" olasılıkları 0 ile 1.0 arasında olan sayısal bir vektördür, ör. "c(0.5, 0.8, 0.85)"
- `**summary()`: ortalama, medyan ve ortak yüzdelikler dahil olmak üzere sayısal bir vektörün özetini verir

[***TEHLİKE:*** Yukarıdaki fonksiyonlardan birine bir sayı vektörü sağlıyorsanız, sayıları `c()` içine sardığınızdan emin olun.]{style="color: red;"}

```{r}
# Bir fonksiyona ham sayılar veriliyorsa, bunları c() içine sarın
mean(1, 6, 12, 10, 5, 0)    # !!! YANLIŞ !!!  

mean(c(1, 6, 12, 10, 5, 0)) # DOĞRU
```

#### Diğer kullanışlı fonksiyonlar {.unnumbered}

+----------------------------+-------------------+-------------------------------------------------+
| Amaç                       | Fonksiyon         | Örnek                                           |
+============================+===================+=================================================+
| Bir seri oluştur           | seq(from, to, by) | `seq(1, 10, 2)`                                 |
+----------------------------+-------------------+-------------------------------------------------+
| x, n kere tekrar et        | rep(x, ntimes)    | `rep(1:3, 2)` or `rep(c("a", "b", "c"), 3)`     |
+----------------------------+-------------------+-------------------------------------------------+
| sayısal bir vektörü alt bölümlere ayır | cut(x, n)         | `cut(linelist$age, 5)`                          |
+----------------------------+-------------------+-------------------------------------------------+
| Rastgele örnek al          | sample(x, size)   | `sample(linelist$id, size = 5, replace = TRUE)` |
+----------------------------+-------------------+-------------------------------------------------+

<!-- ======================================================= -->

### `%in%` {.unnumbered}

Değerleri eşleştirmek ve bir değerin bir vektör veya veri çerçevesi içinde olup olmadığını hızlı bir şekilde değerlendirmek için çok kullanışlı bir operatör.

```{r}
my_vector <- c("a", "b", "c", "d")
```

```{r}
"a" %in% my_vector
"h" %in% my_vector
```

Bir vektörün **%in%'inde  olup olmadığını sormak için mantık ifadesinin **önüne** bir ünlem işareti (!) koyun:

```{r}
# inkar etmek, önüne ünlem işareti koymak
!"a" %in% my_vector
!"h" %in% my_vector
```

"%in%", **dplyr** fonksiyonu "case_while()" kullanılırken çok kullanışlıdır. Bir vektörü önceden tanımlayabilir ve daha sonra ona başvurabilirsiniz. Örneğin:

```{r eval=F}
affirmative <- c("1", "Yes", "YES", "yes", "y", "Y", "oui", "Oui", "Si")

linelist <- linelist %>% 
  mutate(child_hospitaled = case_when(
    hospitalized %in% affirmative & age < 18 ~ "Hospitalized Child",
    TRUE                                      ~ "Not"))
```

Not: Belki **stringr**'den `str_detect()` kullanarak kısmi bir dize algılamak istiyorsanız, `c("1", "Yes", "yes", "y" gibi bir karakter vektörünü kabul etmeyecektir. ")`. Bunun yerine, "1\|Yes\|yes\|y" gibi VEYA çubukları olan bir yoğunlaştırılmış dize *normal ifade* verilmelidir. Örneğin, `str_detect(hospitalized, "1|Yes|yes|y")`. Daha fazla bilgi için [Karakterler ve dizeler] hakkındaki sayfaya bakın.

Bu komutla bir karakter vektörünü adlandırılmış bir normal ifadeye dönüştürebilirsiniz:

```{r}
affirmative <- c("1", "Yes", "YES", "yes", "y", "Y", "oui", "Oui", "Si")
affirmative

# condense to 
affirmative_str_search <- paste0(affirmative, collapse = "|")  # Temel R ile yapılması seçeneği
affirmative_str_search <- str_c(affirmative, collapse = "|")   # stringr paketi seçeneği

affirmative_str_search
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Hatalar ve uyarılar

Bu bölüm şunları açıklar:

- Hatalar ve uyarılar arasındaki fark\
- R kodu yazmak için genel sözdizimi ipuçları\
- Kod yardımcıları

Genel hatalar, uyarılar ve sorun giderme ipuçları [Hatalar ve yardım] sayfasında bulunabilir.

<!-- ============================================ ========= -->

### Hata VS. Uyarı {.unnumbered}

Bir komut çalıştırıldığında, R Konsolu size kırmızı metinle uyarı veya hata mesajları gösterebilir.

- Bir **uyarı**, R'ın komutunuzu tamamladığı, ancak farkında olmanız gereken ek adımlar atması veya olağandışı çıktılar üretmesi gerektiği anlamına gelir.

- Bir **hata**, R'ın komutunuzu tamamlayamadığı anlamına gelir.

İpuçlarını ara:

- Hata/uyarı mesajı genellikle sorun için bir satır numarası içerir.

- Bir nesne "bilinmiyorsa" veya "bulunamadıysa", yanlış yazmış olabilirsiniz, library() ile bir paketi çağırmayı unutmuş veya değişiklik yaptıktan sonra betiğinizi yeniden çalıştırmayı unutmuş olabilirsiniz.

Her şey başarısız olursa, bazı anahtar terimlerle birlikte hata mesajını Google'a kopyalayın - büyük olasılıkla başka biri bunun üzerinde çalışmıştır!

<!-- ============================================ ========= -->

### Genel sözdizimi ipuçları {.unnumbered}

Hataları ve uyarıları önlemek için R'da komut yazarken hatırlamanız gereken birkaç şey:

- Parantezleri her zaman kapatın - ipucu: Her kod öbeği için "(" ve kapanış parantezleri ")" sayısını sayın
- Sütun ve nesne adlarında boşluklardan kaçının. Bunun yerine alt çizgi ( \_ ) veya nokta ( . ) kullanın
- Bir fonksiyonun değişkenlerini virgülle ayırmayı unutmayın ve takip edin
- R büyük/küçük harf duyarlıdır, yani "Değişken_A", "değişken_A"dan *farklıdır*

<!-- ============================================ ========= -->

### Kod yardımı {.unnumbered}

Herhangi bir komut dosyası (RMarkdown veya başka türlü), bir hata yaptığınızda ipucu verecektir. Örneğin, gereken yere virgül yazmayı veya bir parantez kapatmayı unuttuysanız, RStudio sizi uyarmak için betiğin sağ tarafında o satırda bir bayrak kaldıracaktır.
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/basics.Rmd-->


<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# R'a geçiş { }  

Aşağıda, R'a geçiş yapmanız adına bazı tavsiyeler ve kaynaklar sunuyoruz.  

R, 1990'ların sonlarında ortaya çıktı ve o zamandan beri ciddi bir ölçüde büyüdü. O kadar gelişmiş ve geniş bir kapasiteye ulaştı ki ticari alternatifleri rekabeti koruyabilmek için R'ın gelişmelerine ayak uydurmaya çalıştılar! ([R, SPSS, SAS, STATA ve Python'u karşılaştıran bu makaleyi okuyabilirsiniz](https://www.inwt-statistics.com/read-blog/comparison-of-r-python-sas-spss-and-stata. html)).

Tüm bunlarla birlikte R'ı öğrenmek 10 yıl öncesine göre artık çok daha kolay. Daha önceleri, R, yeni başlayanlar için zor olarak kabul edilirdi. RStudio gibi kullanıcı dostu arayüzler, **tidyverse** gibi sezgisel kodlar ve birçok eğitim kaynakları ile R kullanımı kolaylaştırıldı.

<span style="color: darkgreen;">**Korkmayın - gelin R dünyasını keşfedin!**</span>   

  

```{r, echo=F, out.width = "75%", out.height="75%", fig.align = "center"}
knitr::include_graphics(here::here("images", "transition_door.png"))
```




## Excel'den geçiş  

Excel'den doğrudan R'a geçiş yapmak artık çok daha ulaşılabilir bir hedeftir. Göz korkutucu görünebilir, ancak yapabilirsiniz!

Güçlü Excel becerilerine sahip birinin tek başına Excel'de çok gelişmiş analizler yapabileceği doğrudur. Hatta VBA gibi komut araçlarını kullanarak yapılabilecek faaliyetler daha da artabilecektir. Excel tüm dünyada kullanılmaktadır ve bir epidemiyolog için önemli bir araçtır. Bununla birlikte, onu R ile tamamlamak, iş akışlarınızı önemli ölçüde iyileştirip genişletebilir.

### Faydaları {.unnumbered}  

R'ın zamandan tasarruf, daha tutarlı ve doğru analiz, tekrarlanabilirlik, paylaşılabilirlik ve daha hızlı hata düzeltme açısından muazzam faydalar sunduğunu göreceksiniz. Her yeni yazılım gibi, ona aşina olmak için emek vermeniz gereken bir öğrenme "eğrisi" vardır. Birbirinden farklı kütüphaneleriyle R size yeni olasılıkların muazzam kapısını açacaktır.

Excel, "seç ve tıkla" özelliği ile basit analizler ve görselleştirmeler oluşturmak için yeni başlayanlar tarafından kolayca kullanılabilen ve iyi bilinen bir yazılımdır. R'a baktığınızda, fonksiyonlarına ve arayüzüne aşina olabilmeniz birkaç hafta sürebilir. Bununla birlikte, R, son yıllarda yeni başlayanlar için çok daha kolay hale gelmek adına önemli adımlar atmıştır.

Birçok Excel iş akışı hafıza ve tekrarlamaya dayanır. Bu nedenle hata olasılığı çoktur. Ayrıca, genellikle veri temizleme, analiz metodolojisi ve kullanılan denklemler görünümden gizlenir. Yeni bir iş arkadaşının bir Excel çalışma kitabının ne yaptığını ve olası hataların nasıl giderileceğini öğrenmesi için önemli ölçüde bir zamana ihtiyaç duyabilir. R ile tüm adımlar komut dosyasına açıkça yazılır ve kolayca görüntülenebilir, düzenlenebilir, düzeltilebilir ve diğer veri kümelerine uygulanabilir.


**Excel'den R'a geçişinize başlamak için zihniyetinizi birkaç önemli yaklaşımla düzenlemeniz gerekir:**  


### Düzenli veri {.unnumbered}  

Dağınık "insan tarafından okunabilen" veriler yerine makine tarafından okunabilen "düzenli" verileri kullanın. [R'deki "düzenli" veriler](https://r4ds.had.co.nz/tidy-data.html) konusunda açıklandığı gibi, "düzenli" veriler için üç ana şart vardır:

* Her değişkenin kendi sütunu olmalıdır
* Her gözlemin kendi satırı olmalıdır
* Her değerin kendi hücresi olmalıdır

Excel kullanıcıları bu şartları [Excel "tablolarının"](https://exceljet.net/excel-tables) verileri standartlaştırma ve daha tahmin edilebilir bir formata uyarlamada oynadığı rol gibi değerlendirebilir.

"Düzenli" verilere bir örnek, bu el kitabında kullanılan durum satır listesi olabilir. Her değişken bir sütunda yer alır, her gözlemin (bir vaka) kendine ait satırı vardır ve her değer yalnızca bir hücrededir. Aşağıda, linelistin ilk 50 satırını görüntüleyebilirsiniz:

```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

*Düzenli olmayan verilerle karşılaşmamızın ana nedeni, birçok Excel tablosunun makineler/yazılımlar tarafından değil, insanlar tarafından kolay okumaya öncelik verecek şekilde tasarlanmış olmasıdır.*  

Farkı görmenize yardımcı olmak için, aşağıda *insan*-okunabilirliğe öncelik veren **düzensiz verilere** ilişkin bazı kurgusal örnekler verilmiştir.:  

```{r, echo=F, out.width = "100%", out.height="75%", fig.align = "center"}
knitr::include_graphics(here::here("images", "Excel_nonTidy_1.png"))
```


*Sorunlar:* Yukarıdaki tabloda, R tarafından kolayca anlaşılamayacak olan *birleştirilmiş hücreler* mevcuttur. Hangi satırın "başlık" olarak kabul edilmesi gerektiği açık değildir. Renk tabanlı bir sözlük sağ taraftadır ve hücre değerleri renklerle temsil edilir - bu da R tarafından kolayca yorumlanamaz (ayrıca renk körlüğü olan insanlar tarafından da!). Ayrıca, farklı bilgi parçaları tek bir hücrede birleştirmiştir (bir alanda çalışan birden fazla ortak kuruluş gibi).


```{r, echo=F, out.width = "100%", out.height="100%", fig.align = "center"}
knitr::include_graphics(here::here("images", "Excel_nonTidy_2.png"))
```


*Sorunlar:* Yukarıdaki tabloda, veri kümesi içinde çok sayıda fazladan boş satır ve sütun vardır - bu, R'de temizlik sorunlarına neden olur. Ayrıca, belirli bir tedavi merkezi için GPS koordinatları iki satıra yayılmaktadır. Bir yan not olarak - GPS koordinatları iki farklı biçimdedir!

"Düzenli" veri kümeleri insan gözüyle rahatça okunabilir olmayabilir, fakat veri temizleme ve analiz süreçlerini çok daha kolay hale getirirler! Düzenli veriler çeşitli biçimlerde saklanabilir, örneğin "uzun" veya "geniş""(bkz.[Pivot verileri]). Ancak yukarıdaki ilkeler hala gözetilmektedir.


### Fonksiyonlar {.unnumbered}  

R terimi olan "fonksiyon" size yeni gelebilir, fakat bu kavram Excel'de *formüller* olarak mevcuttur. Excel'deki formüller ayrıca kesin sözdizimi gerektirir (örneğin, noktalı virgül ve parantez yerleştirilmesi). Tek yapmanız gereken birkaç yeni fonksiyonu ve bunların R'da nasıl birlikte çalıştıklarını öğrenmek.



### Kodlar {.unnumbered}  

Düğmelere tıklayıp hücreleri sürüklemek yerine *her* adımı ve prosedürü bir "komut dosyasına" yazacaksınız.
Excel kullanıcıları, aynı zamanda bir komut dosyası oluşturma yaklaşımı kullanan "VBA makrolarına" aşina olabilir.

*R komut dosyası adım adım talimatlardan oluşur.* Bu, herhangi bir iş arkadaşınızın komut dosyasını okumasını ve attığınız adımları kolayca görmesini sağlar. Bu aynı zamanda hataların veya hatalı hesaplamaların giderilmesine de yardımcı olur. Örnekler için komut dosyalarıyla ilgili [R temelleri] bölümüne bakabilirsiniz. 

İşte bir R kodu örneği:  

```{r, echo=F, out.width = "75%", out.height="75%", fig.align = "center"}
knitr::include_graphics(here::here("images", "example_script.png"))
```







### Excel'den R'a geçiş kaynakları {.unnumbered}

Excel'den R'ye geçiş yapmanıza yardımcı olacak rehberlere yönelik bazı bağlantılar:  

* [R vs. Excel](https://www.northeastern.edu/graduate/blog/r-vs-excel/)  
* [Excel kullanıcıları için R'de RStudio kursu](https://rstudio-conf-2020.github.io/r-for-excel/)  


### R-Excel etkileşimi {.unnumbered}  

R, Excel çalışma kitaplarını içe aktarmak, verilerle çalışmak, Excel dosyalarını dışa aktarmak/kaydetmek ve Excel sayfalarının nüanslarıyla çalışmak adına güçlü fonksiyonlara sahiptir.  

Estetik bazı Excel biçimlendirmelerinin çeviri sırasında kaybolabileceği doğrudur (örneğin, italik, yan metin, vb.). İş akışınız, orijinal Excel biçimlendirmesini korurken belgeleri R ve Excel arasında ileri geri aktarmayı gerektiriyorsa, **openxlsx** gibi paketleri deneyebilirsiniz.







## Stata'dan geçiş 
<!-- ======================================================= -->

**Stata'dan R'a gelmek**  

İlk olarak Stata'yı kullanmayı öğrenen birçok epidemiyolog için R'a geçmek göz korkutucu görünebilir. Ancak, iyi bir Stata kullanıcısıysanız, R'a geçiş kesinlikle düşündüğünüzden daha kolay süreç olacaktır. Stata ve R arasında verilerin nasıl oluşturulabileceği, değiştirilebileceği ve ayrıca analizlerin nasıl yapılacağı konusunda bazı temel farklılıklar olsa bile bu temel farklılıkları öğrendikten sonra Stata becerilerinizi burada da kullabilirsiniz.

Aşağıda, bu kılavuzu incelerken kullanışlı olabilecek, Stata ve R arasındaki bazı önemli akışları bulabilirsiniz.


**Genel notlar**

**STATA**                    | **R**  
---------------------------- | ---------------------------------------------    
Bir seferde yalnızca bir veri kümesi görüntülenip değiştirebilir. | Aynı anda birden fazla veri kümesi görüntülenip değiştirebilir, bu nedenle sık sık kod içinde veri kümesinin belirtilmesi gerekmektedir.
Çevrimiçi topluluklara [https://www.statalist.org/](https://www.statalist.org/) sitesinden ulaşabilir. | Çevrimiçi topluluklara [RStudio](https://community.rstudio.com/), [StackOverFlow](https://stackoverflow.com/questions/tagged/r), ve [R-bloggers](https://www.r-bloggers.com/) sitelerinden ulaşabilir.
Seçenek olarak seç ve tıkla işlevi mevcut. | Minimal düzeyde seç ve tıkla işlevi mevcut.
`help [command]` koduyla komutlar hakkında yardımcı bilgilere ulaşabilir. | `[function]?` kodu veya Yardım sekmesi ile komutlar hakkında yardımcı bilgilere ulaşabilir.
`*` veya `///` veya `/* METİN */` seçeneklerini kullanarak kod yoruma çevirebilir. | `#` kullanarak kod yoruma çevirebilir.
Hemen hemen tüm komutlar Stata'da yerleşiktir. Yeni/kullanıcı tarafından yazılan işlevler, **ssc install** [paket] kullanılarak **ado** dosyaları olarak kurulabilir. | R, **base** fonksiyonlarla kurulur, ancak tipik kullanım, CRAN'dan diğer paketlerin kurulmasını içerir ([R temelleri]'ndeki sayfasına bakınız.)
Analizler genellikle bir **do** dosyasına yazılır | Analizler RStudio'daki kaynak bölmesine R dili ile yazılır. R markdown dili de alternatif olarak kullanılmaktadır.


**Çalışma dizini**  

**STATA**                        | **R**  
-------------------------------- | ---------------------------------------------
Çalışma dizinleri mutlak dosya yollarını içerir (örneğin, "C:/username/documents/projects/data/"). | Çalışma dizinleri, **here** paketi kullanılarak proje ana klasörüne veya başka alanlara aktarılabilir (bkz. [İçe aktarma ve dışa aktarma]).
**pwd** ile mevcut çalışma dizini görülebilir. | Boş parantezlerle "getwd()" veya "here()" (**here** paketi kullanılıyorsa) kullanılır.
Çalışma dizinini **cd** “klasör konumu” ile ayarlanabilir. | `setwd(“klasör konumu”)` veya `set_here("klasör konumu)` (**here** paketi kullanılıyorsa) kullanabilir.


**Verinin içe aktarılması ve görüntülenmesi**  

**STATA**                    | **R**  
-------------------------------- | ---------------------------------------------
Dosya türüne göre belirli komutlar mevcuttur. | Hemen hemen tüm dosya türleri için **rio** paketinden `import()` fonksiyonu kullanabilir. Alternatif olarak belirli fonksiyonlar da mevcuttur (bkz. [İçe aktarma ve dışa aktarma]).
csv dosyalarını okuma, **import delimitied** “dosyaadı.csv” komutuyla sağlanır. | `import("filename.csv")` kullanılır.
xlsx dosyalarını okuma, **import excel** “dosyaadı.xlsx” komutuyla sağlanır. | `import("filename.xlsx")` kullanılır.
**browse** komutunu kullanarak veriler yeni bir pencerede incelenebilir. | `View(dataset)` kullanarak RStudio kaynak bölmesinde veri seti görüntülenebilir. *Aynı anda birden fazla veri seti tutulabileceğinden, R'daki fonksiyona veri seti adının belirtilmesi gerekir. Bu fonksiyondaki büyük "V" harfine dikkat edilmeli.*
Değişken adlarını ve temel bilgileri veren **summarize** kullanılarak veri kümesine ilişkin genel bir bakış elde edilebilir. | `summary(dataset)` fonksiyonu kullanılarak veri kümesine ilişkin genel bir bakış elde edilebilir.


**Basit veri manipülasyonu**  

**STATA**                    | **R**  
-------------------------------- | ---------------------------------------------
Veri kümesi sütunlarına genellikle "değişkenler" denir. | Daha sıklıkla "sütunlar" veya bazen "vektörler" veya "değişkenler" olarak anılır.
Veri kümesini özellikle belirtmenize gerek yoktur. | Aşağıdaki komutların her birinde veri kümesinin belirtilmesi gerekir. Örnekler için [Verileri temizleme ve temel fonksiyonlar] sayfasına bakınız.
**generate** *varname* = komutu kullanılarak yeni değişkenler oluşturulabilir. | `mutate(varname = )` fonksiyonu kullanılarak yeni değişkenler oluşturabilir. Bütün **dplyr** fonksiyonlarıyla ilgili ayrıntılar için [Verileri temizleme ve temel fonksiyonlar] sayfasına bakınız.
Değişkenler **rename** *eski_adı yeni_adı* komutuyla yeniden adlandırılabilir. | Sütunlar, `rename(new_name = old_name)` fonksiyonu kullanılarak yeniden adlandırılabilir.
Değişkenler **drop** *varname* kullanılarak kaldırılabilir. | Sütunlar, bir eksi işaretinin ardından parantez içinde sütun adı ile `select()` işlevi kullanılarak kaldırılabilir.
Faktör değişkenleri, **label define** gibi bir dizi komut kullanılarak etiketlenebilir. | Değerleri etiketleme, sütunu Faktör sınıfına dönüştürerek ve seviyeler belirleyerek yapılabilir.([Faktörler] ile ilgili sayfaya bakınız.) Sütun adları genellikle Stata'da olduğu gibi etiketlenmez.


**Tanımlayıcı analiz**  

**STATA**                    | **R**  
-------------------------------- | ---------------------------------------------
**tab** *varname* kullanarak bir değişkenin sayılarını tablo haline getirilebilir. | `table()` fonksiyonu için `table(dataset$colname)` koduyla veri kümesi ve sütunun adının sağlanması gerekmektedir. Alternatif olarak, [Verileri gruplama] bölümünde açıklandığı gibi **dplyr** paketindeki `count(varname)` fonksiyonu kullanabilir.
2x2'lik bir tabloda iki değişkenin çapraz tablosu **tab** *varname1 varname2* kodlarıyla oluşturulur. | `table(dataset$varname1, dataset$varname2)` veya `count(varname1, varname2)` fonksiyonları kullanabilir.


Bu liste, Stata komutlarını R'a çevirmenin temelleri hakkında bir genel bakış sunmakla birlikte ayrıntılı değildir. R'a geçiş yapan Stata kullanıcıları için ilgi çekici olabilecek başka birçok harika kaynak mevcuttur:

* https://dss.princeton.edu/training/RStata.pdf  
* https://clanfear.github.io/Stata_R_Equivalency/docs/r_stata_commands.html  
* http://r4stats.com/books/r4stata/  







## SAS'dan geçiş  
<!-- ======================================================= -->

**SAS'dan R'a gelmek**  

SAS, halk sağlığı kurumlarında ve akademik araştırma alanlarında yaygın olarak kullanılmaktadır. Yeni bir dile geçiş nadiren basit bir süreç olsa da, SAS ve R arasındaki temel farkları anlamak, ana dilinizde edindiğiniz tecrübeleri yeni dile aktarmakta yardımcı olabilir.

Aşağıda, SAS ve R arasındaki veri yönetimi ve tanımlayıcı analizdeki temel farklılıklar özetlenmektedir.   

**Genel notlar**  

**SAS**                          | **R**  
-------------------------------- | ---------------------------------------------
Çevrimiçi topluluklara [SAS Müşteri Hizmetleri](https://support.sas.com/en/support-home.html)sitesinden ulaşabilir. | RStudio, StackOverFlow ve R-blogları aracılığıyla çevrimiçi topluluklara ulaşabilir.
`help [command]` koduyla komutlar hakkında yardımcı bilgilere ulaşabilir. | `[function]?` kodu veya Yardım sekmesi ile komutlar hakkında yardımcı bilgilere ulaşabilir.
`* METİN`; `/*` veya `/* METİN */` seçeneklerini kullanarak kodu yoruma çevirebilir. | `#` kullanarak kodu yoruma çevirebilir.
Hemen hemen tüm komutlar yerleşiktir. Yeni/kullanıcı tarafından yazılan işlevler, SAS macro, SAS/IML, SAS Component Language (SCL); `Proc Fcmp` ve `Proc Proto` prosedürleri kullanılarak kurulabilir. | R, **base** fonksiyonlarla kurulur, ancak tipik kullanım, CRAN'dan diğer paketlerin kurulmasını içerir ([R temelleri]'ndeki sayfasına bakınız.).
Analiz genellikle Editör penceresinde bir SAS programı yazılarak yapılır. | Analizler RStudio'daki kaynak bölmesine R dili ile yazılır. R markdown dili de alternatif olarak kullanılmaktadır.


**Çalışma dizini**  

**SAS**                          | **R**  
-------------------------------- | ---------------------------------------------
Çalışma dizinleri mutlak dosya yollarını içerir. Bunun dışında `%let rootdir=/root path; %include “&rootdir/subfoldername/filename”` kodu kullanarak başka alanlara kaydedilebilir. | Çalışma dizinleri, **here** paketi kullanılarak proje ana klasörüne veya başka alanlara aktarılabilir (bkz. [İçe aktarma ve dışa aktarma]).
`%put %sysfunc(getoption(work));` ile mevcut çalışma dizinini görebilir. | Boş parantezlerle "getwd()" veya "here()" (**here** paketi kullanılıyorsa) kullanılır.
Çalışma dizinini `libname “folder location”` “klasör konumu” ile ayarlanabilir. | `setwd(“klasör konumu”)` veya `set_here("klasör konumu)` (**here** paketi kullanılıyorsa) kullanabilir.


**Verinin içe aktarılması ve görüntülenmesi**  

**SAS**                          | **R**  
-------------------------------- | ---------------------------------------------
`Proc Import` prosedürünü veya `Data Step Infile` ifadesini kullanılır. | Hemen hemen tüm dosya türleri için **rio** paketinden `import()` fonksiyonu kullanabilir. Alternatif olarak belirli fonksiyonlar da mevcuttur (bkz. [İçe aktarma ve dışa aktarma]).
csv dosyalarını okuma, `Proc Import datafile=”filename.csv” out=work.filename dbms=CSV kullanılarak yapılır; run;` VEYA [Data Step Infile Açıklaması](http://support.sas.com/techsup/technote/ts673.pdf) kullanılabilir. | `import("filename.csv")` kullanılır.
xlsx dosyalarını okuma, `Proc Import datafile=”filename.xlsx” out=work.filename dbms=xlsx kullanılarak yapılır; run;` VEYA [Data Step Infile Açıklaması](http://support.sas.com/techsup/technote/ts673.pdf) kullanılabilir. | `import("filename.xlsx")` kullanılır.
Gezgin penceresi açılarak veriler yeni bir pencerede incelenebilir; istenilen kitaplık ve veri kümesi seçilebilir. | `View(dataset)` kullanarak RStudio kaynak bölmesinde veri seti görüntülenebilir. *Aynı anda birden fazla veri seti tutulabileceğinden, R'daki fonksiyona veri seti adının belirtilmesi gerekir. Bu fonksiyondaki büyük "V" harfine dikkat edilmeli.*


**Basit veri manipülasyonu**  

**SAS**                          | **R**  
-------------------------------- | ---------------------------------------------
Veri kümesi sütunlarına genellikle "değişkenler" denir. | Daha sıklıkla "sütunlar" veya bazen "vektörler" veya "değişkenler" olarak anılır.
Veri kümesini özellikle belirtmenize gerek yoktur. Yeni değişkenler, yalnızca yeni değişken adı, ardından eşittir işareti ve ardından değer için bir ifade yazılarak oluşturulur. | `mutate()` fonksiyonu kullanılarak yeni değişkenler oluşturabilir. Bütün **dplyr** fonksiyonlarıyla ilgili ayrıntılar için [Verileri temizleme ve temel fonksiyonlar] sayfasına bakınız.
Değişkenler `rename *old_name=new_name*` komutuyla yeniden adlandırılabilir. | Sütunlar, `rename(new_name = old_name)` fonksiyonu kullanılarak yeniden adlandırılabilir.
Değişkenler `**keep**=varname` kullanılarak kullanılabilir. | Sütunlar, parantez içinde sütun adı ile `select()` işlevi kullanılarak seçilebilir.
Değişkenler `**drop**=varname` kullanılarak kaldırılabilir. | Sütunlar, bir eksi işaretinin ardından parantez içinde sütun adı ile `select()` işlevi kullanılarak kaldırılabilir.
Faktör değişkenleri, `Label` ifadesi kullanılarak Veri Adımında etiketlenebilir. | Değerleri etiketleme, sütunu Faktör sınıfına dönüştürerek ve seviyeler belirleyerek yapılabilir.([Faktörler] ile ilgili sayfaya bakınız.) Sütun adları genellikle etiketlenmez.
Kayıtlar, Veri Adımında `Where` veya `If` ifadesi kullanılarak seçilir. Çoklu seçim koşulları “and” komutu kullanılarak ayrılır. | Kayıtlar, VE operatörü (&) veya virgülle ayrılmış çoklu seçim koşullarıyla `filter()` fonksiyonu kullanılarak seçilir.
Veri kümeleri, Veri Adımında `Merge` ifadesi kullanılarak birleştirilir. Birleştirilecek veri kümelerinin önce `Proc Sort` prosedürü kullanılarak sıralanması gerekmektedir. | **dplyr** paketi, veri kümelerini birleştirmek için birkaç işlev sunar. Ayrıntılar için [Verileri birleştirme] sayfasına bakınız.


**Tanımlayıcı analiz**  

**SAS**                          | **R**  
-------------------------------- | ---------------------------------------------
Değişken adları ve açıklayıcı istatistikler sağlayan "Proc Summary" prosedürü kullanılarak veri kümesi hakkında üst düzey bir genel bakış elde edilebilir. | **skimr** paketinden "summary(dataset)" veya "skim(dataset)" kullanılarak veri kümesine ilişkin üst düzey bir genel bakış elde edilebilir.
`proc freq data=Dataset; Tables varname; Run;` komutu kullanılarak değişken sayıları tablo halinde özetlenebilir. |
[Tanımlayıcı tablolar] ile ilgili sayfaya bakınız. Seçenekler arasında **base** R'den 'table()' ve **janitor** paketinden 'tabyl()' bulunmaktadır. R birden fazla veri kümesi içerdiği için veri kümesi ve sütun adının belirtilmesi gerekmektedir.
2x2'lik bir tabloda iki değişkenin çapraz tablosu `proc freq data=Dataset; Tables rowvar*colvar; Run;` komutuyla oluşturulabilir. | `table()`, `tabyl()` veya [Tanımlayıcı tablolar] sayfasında açıklandığı gibi diğer seçenekler kullanabilir.


**Birkaç değerli kaynak:**  

[R for SAS and SPSS Users (2011)](https://www.amazon.com/SAS-SPSS-Users-Statistics-Computing/dp/1461406846/ref=sr_1_1?dchild=1&gclid=EAIaIQobChMIoqLOvf6u7wIVAhLnCh1c9w_DEAMYASAAEgJLIfD_BwE&hvadid=241675955927&hvdev=c&hvlocphy=9032185&hvnetw=g&hvqmt=e&hvrand=16854847287059617468&hvtargid=kwd-44746119007&hydadcr=16374_10302157&keywords=r+for+sas+users&qid=1615698213&sr=8-1)

[SAS and R, Second Edition (2014)](https://www.amazon.com/SAS-Management-Statistical-Analysis-Graphics-dp-1466584491/dp/1466584491/ref=dp_ob_title_bk)



## Veri formatları
<!-- ======================================================= -->

R **rio** paketinin, STATA .dta dosyaları, SAS .xpt ve.sas7bdat dosyaları, SPSS .por ve.sav dosyaları gibi dosyaları gibi pek çok dosyanın nasıl içe ve dışa aktarabileceğiyle ilgili ayrıntılar için [İçe ve dışa aktar] sayfasına bakınız.


```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/transition_to_R.Rmd-->

# Önerilen paketler

Aşağıda R ile yapılan epidemiyolojik çalışmalarda yaygın olarak önerilen paketlerin uzun bir listesi bulunmaktadır. Aşağıdaki kodu kopyalayabilir ve çalıştırabilirsiniz. Bu paketlerin tümü CRAN'dan mevcut R oturumunda kullanılmak üzere indirilecektir. Paket zaten kuruluysa, yalnızca oturumda kullanılması için yüklenecektir.

İstemediğiniz paketleri çıkarmak için kodu `#` sembolleri ile değiştirebilirsiniz.

Ek not:  

* Aşağıdaki kodu çalıştırmadan önce **pacman** paketini kurmalısınız. Bunu `install.packages("pacman")` ile yapabilirsiniz. Bu el kitabında, gerekirse paketi kuran *and* mevcut R oturumunda kullanmak üzere yükleyen **pacman**'dan `p_load()`a vurgu yapmaktayız. Ayrıca **base** R'dan `library()` ile önceden kurulmuş paketleri de yükleyebilirsiniz.  
* Aşağıdaki kodda, yüklenen paketlerin bağımlı olduğu diğer paketler bir girinti ve hash ile belirtilmiştir. Örnek olarak, **ggplot2**'nin **tidyverse** altında nasıl listelendiği inceleyebilirsiniz.
* Yüklenen birden çok paket aynı adda fonksiyonlara sahipse, en son yüklenen paketten gelen fonksiyonun önceliklendirildiği *masking*  ortaya çıkabilmektedir. [R temelleri] sayfasında daha fazlasını bulabilirsiniz. Bu tür çakışmaları yönetmek için **conflicted** paketini kullanabilirsiniz.
* **pacman** ve maskeleme hakkında daha fazla bilgi için paketlerle ilgili [R temelleri] bölümüne bakınız.

Bu el kitabının hazırlanması sırasında kullanılan R, RStudio ve R paketlerinin sürümlerini görmek için [Yazı ve teknik notlar] sayfasına bakınız.

## Packages from CRAN  

```{r, eval=F}

##########################################
# Önemli epidemiyoloji R paketlerinin listesi #
##########################################

# Bu komut dosyası, pacman R paketindeki p_load() işlevini kullanır, 
# paket yoksa indirilir ve zaten kuruluysa kullanım için yüklenir


# "pacman" paketinin kurulu olduğundan emin olur
if (!require("pacman")) install.packages("pacman")


# Packages available from CRAN
##############################
pacman::p_load(
     
     # R'ı öğrenmek
     ############
     learnr,   # RStudio Eğitimi bölmesinde etkileşimli rehberler
     swirl,    # R konsolunda etkileşimli rehberler
        
     # proje ve dosya yönetimi
     #############################
     here,     # R proje ana klasörüne göre dosya yönetimi
     rio,      # birçok veri türünün içe/dışa aktarımı
     openxlsx, # çok sayfalı Excel çalışma kitaplarını içe/dışa aktarma
     
     # paket kurulumu ve yönetimi
     ################################
     pacman,   # paket indirme/yükleme
     renv,     # ekiple çalışırken paket sürümlerini yönetme
     remotes,  # Github'dan indirme
     
     # Genel veri yönetimi
     #########################
     tidyverse,    # düzenli veri analizi ve sunumu için birçok paket içerir
          #dplyr,      # data yönetimi
          #tidyr,      # data yönetimi
          #ggplot2,    # data gösterimi
          #stringr,    # dizeler ve karakterlerle çalışma
          #forcats,    # faktörlerle çalışma
          #lubridate,  # tarihlerle çalışma
          #purrr       # yineleme ve listelerle çalışma
     linelist,     # satır listesini temizleme
     naniar,       # eksik verilerin değerlendirilmesi
     
     # İstatistik  
     ############
     janitor,      # tablolar ve veri temizleme
     gtsummary,    # tanımlayıcı ve istatistiksel tablolar hazırlama
     rstatix,      # istatistiksel testleri ve özetleri hızla çalıştırma
     broom,        # regresyonlardan elde edilen sonuçları düzenleme
     lmtest,       # likelihood-ratio testleri
     easystats,
          # parameters, # regresyonlardan elde edilen sonuçları alternatif düzenleme
          # see,        # forest plot'ları alternatif görseleştirme 
     
     # epidemic modelleme
     ###################
     epicontacts,  # Transmisyon networklarını analiz etme
     EpiNow2,      # Rt tahmini
     EpiEstim,     # Rt tahmini
     projections,  # İnsidans projeksiyonları
     incidence2,   # Epidemiyolojik eğrileri yapma ve insidans verilerini işleme
     i2extras,     # İnsidans2 paketi için ekstra fonksiyonlar
     epitrix,      # Faydalı epidemiyoloji fonksiyonları
     distcrete,    # Ayrık dağılımlar
     
     
     # plots - genel
     #################
     #ggplot2,         # tidyverse içinde bulunmaktadır
     cowplot,          # plotları birleştirme  
     # patchwork,      # plotları birleştirme   (alternatif)     
     RColorBrewer,     # renk skalaları
     ggnewscale,       # ek renk katmanları ekleme

     
     # plots - özel türler
     ########################
     DiagrammeR,       # DOT dilini kullanan diyagramlar
     incidence2,       # epidemic eğriler
     gghighlight,      # bir alt kümeyi vurgulama
     ggrepel,          # akıllı etiketler
     plotly,           # interaktif grafikler
     gganimate,        # animasyonlu grafikler 

     
     # gis
     ######
     sf,               # Basit Özellik formatı kullanarak uzamsal verileri yönetme
     tmap,             # Basit haritalar üretme (Hem etkileşimli hem de statik haritalar oluşturulabilir)
     OpenStreetMap,    # ggplot haritasına OSM temel haritası ekleme
     spdep,            # geografik istatistikler
     
     # rutin raporlar
     #################
     rmarkdown,        # PDF, Word, Powerpoint ve HTML dosyaları üretme
     reportfactory,    # R Markdown çıktılarının otomatik organizasyonu
     officer,          # powerpoint
     
     # kontrol paneli
     ############
     flexdashboard,    # R Markdown komut dosyasını bir gösterge panosuna dönüştürme
     shiny,            # etkileşimli web uygulamaları
     
     # sunum için tablolar
     #########################
     knitr,            # R Markdown raporu oluşturma ve html tabloları
     flextable,        # HTML tablolar
     #DT,              # HTML tablolar (alternatif)
     #gt,              # HTML tablolar (alternatif)
     #huxtable,        # HTML tablolar (alternatif) 
     
     # filogenetik
     ###############
     ggtree,           # ağaçların görselleştirilmesi ve açıklanması
     ape,              # filogenetik ve evrim analizi
     treeio            # filogenetik dosyaları görselleştirme
 
)

```

## Github paketleri 


Aşağıda, iki paketi doğrudan Github sunucularından indirmek için gerekli komutlar verilmiştir.

* **epicontacts**'ın geliştirme sürümü, zamansal bir x ekseni ile transmisyon ağaçları oluşturma özelliğini içermektedir.
* **epirhandbook** paketi bu el kitabı için tüm örnek verileri içermektedir. Bunun dışında el kitabının çevrimdışı sürümünü indirmek için kullanılabilir.


```{r, eval=F}
# Github'dan indirilecek paketler (CRAN'da mevcut değildir)
##########################################################

# Epicontacts geliştirme versiyonu (x ekseni zamanına sahip transmisyon zincirleri icin)
pacman::p_install_gh("reconhub/epicontacts@timeline")

# Tüm örnek verileri de içeren bu el kitabının paketi
pacman::p_install_gh("appliedepi/epirhandbook")



```

```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/packages_suggested.Rmd-->


# R projeleri {}  


Bir R projesi, çalışmanızın taşınabilir, bağımsız bir klasörde paketlenmesini sağlar. Proje klasörü içinde, ilgili tüm komutlar, veri dosyaları, şekiller/çıktılar ve geçmiş kayıtları alt klasörlerde saklanır. *Çalışma dizini* projenin ana klasörüdür.


## Önerilen kullanım 

R'ı kullanmanın yaygın, verimli ve sorunsuz bir yolu bu 3 unsuru birleştirmektir. Herbir proje, bir R klasörü içinde barındırılmaktadır. İlgili başlıklar aşağıdaki bölümlerde açıklanmıştır.

1) Bir **R projesi**  
     - Veriler, komut dosyaları, çıktılar vb. için ilgili klasörlerden oluşan bağımsız bir çalışma ortamı. 
2) Alternatif dosya yolakları için **here** paketi 
     - Dosya yolakları, R projesinin ana klasörüne göre yazılır - daha fazla bilgi için [İçe ve dışa aktar] bölümüne bakınız.  
3) İçe/dışa aktarma için **rio** paketi  
     - `import()` ve `export()`, herhangi bir dosya türünü uzantısına göre işler (ör. .csv, .xlsx, .png)
     
     


<!-- ======================================================= -->
## Bir R projesi yaratma {}

Bir R projesi oluşturmak için Dosya menüsünden "Yeni Proje" seçeneğini seçiniz.

* Proje için yeni bir klasör oluşturmak istiyorsanız, "Yeni dizin"i seçin ve projenizin nerede oluşturulmasını istediğinizi belirtiniz.  
* Projeyi mevcut bir klasör içinde oluşturmak istiyorsanız, "Mevcut dizin" seçeneğine tıklayıp ve klasörü belirtiniz.  
* Bir Github deposunu klonlamak istiyorsanız, üçüncü seçenek olan "Versiyon Kontrolü"nü seçip ve ardından "Git"i seçiniz. Daha fazla ayrıntı için [Versiyon kontrolü, Git ve Github ile işbirliği] hakkındaki sayfaya bakınız.  


```{r out.width = "75%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "create_project.png"))
```


R projesi, *.Rproj* dosyası içeren bir klasör şeklinde oluşturulacaktır. Bu dosya bir kısayoldur ve projenizi açmanın birincil yoludur. Dosya menüsünden "Projeyi Aç"ı seçerek de bir projeyi açabilirsiniz. Alternatif olarak, RStudio'nun en sağ üst tarafında bir R projesi simgesi ve mevcut R projelerinin açılır menüsünü göreceksiniz. 

Bir R projesinden çıkmak için ya yeni bir proje açın ya da açık olan projeyi kapatınız (Dosya - Projeyi Kapat).


### Projeler arasında geçiş yapma {.unnumbered}

Projeler arasında geçiş yapmak için, RStudio'nun sağ üst köşesindeki R projesi simgesini ve açılır menüyü tıklayınız. "Projeyi Kapat", "Projeyi Aç" seçeneklerini ve son projelerin bir listesini göreceksiniz.  

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "Rproject_dropdown.png"))
```


### Ayarlar {.unnumbered}  

Genellikle RStudio'yu her seferinde "temiz bir sayfa" ile başlatmanız önerilmektedir - yani, çalışma alanınız önceki oturumunuzdan **korunmamış** olarak. Bu, nesnelerinizin ve çıktılarınızın oturumdan oturuma devam etmeyeceği anlamına gelir (komut dosyalarınızı çalıştırarak bunları yeniden oluşturmanız gerekmektedir). Bu iyi bir durumdur, çünkü sizi daha iyi komutlar yazmaya ve uzun vadede hatalardan kaçınmaya zorlayacaktır.  

RStudio'yu her açılışta "temiz bir sayfaya" sahip olacak şekilde ayarlamak için:

* Araçlar menüsünden "Proje Seçenekleri"ni seçiniz.
* "Genel" sekmesinde, RStudio'yu başlangıçta .RData'yı çalışma alanına **geri yüklemeyecek** ve çıkışta çalışma alanını .RData'ya **kaydetmeyecek** şekilde ayarlayınız.


### Organizasyon {.unnumbered}  

Projenizde alt klasörlerin olması yaygın bir durumdur. "Veri", "komut dosyaları", "şekiller", "sunular" gibi klasörleri oluşturabilirsiniz. Bilgisayarınız için yeni bir klasör eklediğiniz gibi proje alt klasörlerini ekleyebilirsiniz. Alternatif olarak, R komutlarıyla yeni klasörlerin nasıl oluşturulacağını öğrenmek için [Dizin etkileşimleri] hakkındaki sayfaya bakınız. 


### Versiyon kontrolü {.unnumbered}  

Projelerinizde her zaman bir versiyon kontrol sistemi düşünmelisiniz. Komut dosyalarının adlarında (örneğin, "transmission_analysis_2020-10-03.R") ve bir "arşiv" klasöründe tarihlerin eklenmesi gibi basit bir yöntemi kullanabilirsiniz. Ayrıca açıklama, etiketler, yazarlar ve değişiklik günlüğü ile her komut dosyasının üst kısmında yorumlar da ekleyebilirsiniz.

Daha karmaşık bir yöntem, sürüm kontrolü için Github veya benzer bir platform kullanmayı içermektedir. [Versiyon kontrolü, Git ve Github ile işbirliği] hakkındaki sayfaya bakınız.

Bir ipucu olarak, "Dosyalarda Bul" aracını (Düzenle menüsü) kullanarak tüm projede veya klasörde arama yapabilmenizdir. Birden çok dosyada istediğiniz kelime/dizeleri arayabilir ve hatta değiştirebilirsiniz.  






## Örnekler

Aşağıda, bir R projesi içinden `here()` fonksiyonunu kullanarak bazı içe/dışa aktarma/kaydetme örnekleri verilmiştir. [İçe ve dışa aktar] sayfasında **here** paketinin kullanımı hakkında daha fazla bilgi edinebilirsiniz.


*R projenizdeki "data" klasöründen `linelist_raw.xlsx` dosyasını içe aktarın*  

```{r eval=F}
linelist <- import(here("data", "linelist_raw.xlsx"))
```

*R projenizdeki "data" klasörü içindeki "clean" klasörüne, R nesnesi 'linelist'i, "my_linelist.rds" olarak dışa aktarın.*   

```{r, eval=F}
export(linelist, here("data","clean", "my_linelist.rds"))
```

*En son yazdırılan grafiği, R projenizdeki "outputs" klasöründeki "epicurves" klasörüne "epicurve_2021-02-15.png" olarak kaydedin.*  

```{r, eval=F}
ggsave(here("outputs", "epicurves", "epicurve_2021-02-15.png"))
```




<!-- ======================================================= -->
## Kaynaklar {}

RStudio web sayfası - [R projelerini kullanma](https://support.rstudio.com/hc/en-us/articles/200526207-Using-Projects)




```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/r_projects.Rmd-->

# İçe ve dışa aktar {}

```{r, out.width=c('100%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "Import_Export_1500x500.png"))
```


Bu sayfada dosyaları bulmanın, içe aktarmanın ve dışa aktarmanın yollarını açıklıyoruz:

* Birçok dosya türünü esnek bir şekilde `import()` ve `export()` işlemi için **rio** paketinin kullanımını
* Bir R proje köküyle ilişkili dosyaları bulmak için **here** paketinin kullanılması - bir bilgisayara özgü dosya yollarından kaynaklanan komplikasyonları önlemek için
* Aşağıdakiler gibi belirli içe aktarma senaryoları:
  * Spesifik Excel sayfaları
  * Dağınık başlıklar ve satır atlama
  * Google sayfalarından
  * Web sitelerine gönderilen verilerden
  * API'ler ile
  * *En son* dosyayı içe aktarma
* Manuel veri girişi
* RDS ve RData gibi R'a özgü dosya türleri
* Dosyaları ve grafikleri dışa aktarma/kaydetme


<!-- ============================================ ========= -->
## Genel Bakış

Bir "veri kümesini" R'ı içe aktardığınızda, genellikle R ortamınızda yeni bir *veri çerçevesi* nesnesi yaratır ve onu klasör dizinlerinizde bulunan içe aktarılmış bir dosya (örn. Excel, CSV, TSV, RDS) olarak belirli bir dosya yolu/adresini tanımlamış olursunuz. 

Diğer istatistiksel programlar (SAS, STATA, SPSS) tarafından oluşturulanlar da dahil olmak üzere birçok dosya türünü içe/dışa aktarabilirsiniz. Ayrıca ilişkisel veritabanlarına da bağlanabilirsiniz.

R'ın kendi veri biçimleri bile vardır:

* Bir RDS dosyası (.rds), veri çerçevesi gibi tek bir R nesnesini depolar. Bunlar, R sütun sınıflarını korudukları için temizlenmiş verileri depolamak için kullanışlıdır. [Bu bölümde](#import_rds) daha fazlasını okuyabilirsiniz.
* Bir RData dosyası (.Rdata), birden çok nesneyi veya hatta eksiksiz bir R çalışma alanını depolamak için kullanılabilir. [Bu bölümde](#import_rdata) daha fazlasını okuyabilirsiniz.


<!-- ============================================ ========= -->
## **rio** paketi {}

Önerdiğimiz R paketi: **rio**. "Rio" adı, "R I/O" (girdi-input/çıktı-output) ifadesinin kısaltmasıdır.

`import()` ve `export()` fonksiyonları birçok farklı dosya türünü (örneğin .xlsx, .csv, .rds, .tsv) işleyebilir. Bu fonksiyonlardan herhangi birine (".csv" gibi dosya uzantısı dahil) bir dosya yolu sağladığınızda, **rio** uzantıyı okuyacak ve dosyayı içe veya dışa aktarmak için doğru aracı kullanacaktır.

**rio** kullanmanın alternatifi, her biri bir dosya türüne özgü olan diğer birçok paketin fonksiyonunu kullanmaktır. Örneğin, 'read.csv()' (**base** R), 'read.xlsx()' (**openxlsx** paketi) ve 'write_csv()' (**readr** paketi), vb. Bu alternatifleri hatırlamak zor olabilir, oysa **rio**'dan `import()` ve `export()` kullanmak kolaydır.

**rio**'nun `import()` ve `export()` fonksiyonları, dosya uzantısına bağlı olarak belirli bir dosya için uygun paketi ve fonksiyonu kullanır. **rio**'nun arka planda kullandığı paketlerin/fonksiyonların tam bir tablosu için bu sayfanın sonuna bakabilirsiiniz. Düzinelerce başka dosya türü arasından STATA, SAS ve SPSS dosyalarını içe aktarmak için de kullanılabilir.

Şekil dosyalarının içe/dışa aktarımı, [GIS temelleri] sayfasında ayrıntılı olarak açıklandığı gibi başka paketler gerektirir.





## **here** paketi {#here}

**here** paketi ve 'here()' fonksiyonu, R'a dosyalarınızı nerede bulacağını ve kaydedeceğini söylemeyi kolaylaştırır - özünde, dosya yolları oluşturur.

Bir R projesiyle birlikte kullanıldığında **here**, R projenizdeki dosyaların konumunu R projesinin *kök dizini* (en üst düzey klasör) ile ilişkili olarak tanımlamanıza olanak tanır. Bu, R projesinin birden fazla kişi/bilgisayar tarafından paylaşılabildiği veya erişilebildiği durumlarda kullanışlıdır. Dosya yolunu tüm kullanıcılar için ortak bir yerde (R proje kökü) "başlatarak", farklı bilgisayarlardaki benzersiz dosya yollarından (ör. "C:/Users/Laura/Documents...") kaynaklanan komplikasyonları önler.

Bir R projesinde "here()" şu şekilde çalışır:

* **here** paketi R projesine ilk yüklendiğinde, ".here" adlı küçük bir dosyayı R projenizin kök klasörüne "benchmark" veya "anchor" olarak yerleştirir.
* Komut dosyalarınızda, R projesinin alt klasörlerindeki bir dosyaya referans vermek için, dosya yolunu oluşturmak için 'here()' fonksiyonunu kullanırsınız *bu bağlantıya göre*
* Dosya yolunu oluşturmak için, klasör adlarını kökün ötesinde, tırnak işaretleri içinde, virgülle ayırarak ve son olarak aşağıda gösterildiği gibi dosya adı ve dosya uzantısı ile bitecek şekilde yazın.
* `here()` dosya yolları hem içe hem dışa aktarma için kullanılabilir

Örneğin, aşağıda, "import()" fonksiyonuna "here()" ile oluşturulmuş bir dosya yolu sağlanmaktadır.

```{r, eval=F}
linelist <- import(here("data", "linelists", "ebola_linelist.xlsx"))
```

`here("data", "linelists", "ebola_linelist.xlsx")` komutu aslında *kullanıcının bilgisayarına özgü olan* tam dosya yolunu sağlar*:

```
"C:/Users/Laura/Documents/my_R_project/data/linelists/ebola_linelist.xlsx"
```

İşin güzel yanı, 'here()' kullanan R komutunun, R projesine erişen herhangi bir bilgisayarda başarılı bir şekilde çalıştırılabilmesidir.


<span style="color: darkgreen;">**_TIP:_** “.here” kökünün nereye ayarlandığından emin değilseniz, boş parantezlerle 'here()' fonksiyonunu çalıştırın.</span>

**here** paketi hakkında [bu bağlantıdan](https://here.r-lib.org/) daha fazlasını okuyabilirsiniz.



<!-- ============================================ ========= -->
## Dosya yolları

Verileri içe veya dışa aktarırken bir dosya yolu sağlamanız gerekir. Bunu üç yoldan biriyle yapabilirsiniz:

1) *Önerilen:* **here** paketiyle "ilişkili" bir dosya yolu sağlayın
2) "tam" / "mutlak" dosya yolunu sağlayın
3) Manuel dosya seçimi



### "İlişkili" dosya yolları {.unnumbered}

R'da, "ilişkili" dosya yolları, bir R projesinin köküne *ilişkili* olan dosya yolundan oluşur. Farklı bilgisayarlarda çalışabilen daha basit dosya yollarına izin verirler (örneğin, R projesi paylaşılan bir sürücüdeyse veya e-postayla gönderiliyorsa). [Yukarıda](#here) açıklandığı gibi, göreli dosya yolları **here** paketi kullanılarak kolaylaştırılır.

'here()' ile oluşturulmuş ilişkili bir dosya yolu örneği aşağıdadır. Çalışmanın, bir "veri" alt klasörü içeren bir R projesinde olduğunu ve bunun içinde, .xlsx dosyasının bulunduğu bir "çizgi listeleri" alt klasöründe olduğunu varsayıyoruz.

```{r, eval=F}
linelist <- import(here("data", "linelists", "ebola_linelist.xlsx"))
```



### "Mutlak" dosya yolları {.unnumbered}

`import()` gibi fonksiyonlar için mutlak veya "tam" dosya yolları sağlanabilir, ancak bunlar kullanıcının özel bilgisayarına özgü olduğundan "kırılgandır" ve bu nedenle *önerilmez*.

Aşağıda, Laura'nın bilgisayarında bir "analiz" klasörü, bir "veri" alt klasörü ve bunun içinde, ilgilenilen .xlsx dosyasının bulunduğu bir alt klasör "satır listeleri" bulunan bir mutlak dosya yolu örneği verilmiştir. .

```{r, eval=F}
linelist <- import("C:/Users/Laura/Documents/analysis/data/linelists/ebola_linelist.xlsx")
```

Mutlak dosya yolları hakkında dikkat edilmesi gereken birkaç nokta:

* **Mutlak dosya yollarını kullanmaktan kaçının** çünkü komut dosyası farklı bir bilgisayarda çalıştırılırsa bozulurlar
* Yukarıdaki örnekte olduğu gibi *ileri* eğik çizgi (`/`) kullanın (not: bu, Windows dosya yolları için varsayılan *DEĞİLDİR*)
* Çift eğik çizgiyle başlayan dosya yolları (ör. "//...") büyük olasılıkla **R** tarafından tanınmayacak ve bir hata üretecektir. Çalışmanızı bir harfle başlayan "adlandırılmış" veya "harfli" bir sürücüye taşımayı düşünün (ör. "J:" veya "C:"). Bu sorunla ilgili daha fazla ayrıntı için [Dizin etkileşimleri] hakkındaki sayfaya bakabilirsiniz.

Mutlak dosya yollarının uygun olabileceği bir senaryo, tüm kullanıcılar için aynı tam dosya yoluna sahip bir paylaşılan sürücüden bir dosyayı içe aktarmak istediğiniz zamandır.

<span style="color: darkgreen;">**_İPUCU:_** Tüm `\` işaretlerini `/` biçimine hızlı bir şekilde dönüştürmek için ilgili kodu vurgulayın, Ctrl+f (Windows'ta) kullanın,  "In selection" seçenek kutusunu işaretleyin ve ardından bunları dönüştürmek için değiştirme fonksiyonunu kullanın.</span>



<!-- ============================================ ========= -->
### Dosyayı manuel olarak seçin {.unnumbered}

Aşağıdaki yöntemlerden birini kullanarak verileri manuel olarak içe aktarabilirsiniz:

1) Ortam RStudio Bölmesi, "Veri Kümesini İçe Aktar"a tıklayın ve veri türünü seçin
2) Dosya / Veri Kümesini İçe Aktar / (veri türünü seçin) öğesine tıklayın.
3) Manuel seçimi sabit kodlamak amacıyla, kullanıcının manuel olarak bilgisayarından dosya seçmesine izin veren bir **açılır pencere** görünümünü tetiklemek için *temel R* `file.choose()` komutunu (parantezleri boş bırakarak) kullanın. Örneğin:

```{r import_choose, eval=F}
# Bir dosyanın manuel seçimi. Bu komut çalıştırıldığında bir POP-UP penceresi görünecektir.
# Seçilen dosya yolu import() komutunu sağlayacaktır.

my_data <- import(file.choose())
```

<span style="color: darkgreen;">**_İPUCU:_** **Açılır pencere** RStudio pencerenizin ARDINDA görünebilir.</span>



## Verileri içe aktar

Bir veri kümesini içe aktarmak için `import()` kullanmak oldukça basittir. Dosyanın yolunu (dosya adı ve dosya uzantısı dahil) tırnak içinde belirtmeniz yeterlidir. Dosya yolunu oluşturmak için "here()" kullanılıyorsa, yukarıdaki talimatları izleyebilirsiniz. Aşağıda birkaç örnek verilmiştir:

"Çalışma dizininizde" veya R projesi kök klasöründe bulunan bir csv dosyasını içe aktarma:

```{r, eval=F}
linelist <- import("linelist_cleaned.csv")
```


R projesinin (`here()` kullanılarak oluşturulan dosya yolu) "veri" ve "çizgi listeleri" alt klasörlerinde bulunan bir Excel çalışma kitabının ilk sayfasını içe aktarma:

```{r, eval=F}
linelist <- import(here("data", "linelists", "linelist_cleaned.xlsx"))
```


Mutlak bir dosya yolu kullanarak bir veri çerçevesini (bir .rds dosyası) içe aktarma:

```{r, eval=F}
linelist <- import("C:/Users/Laura/Documents/tuberculosis/data/linelists/linelist_cleaned.rds")
```




### Belirli Excel sayfaları {.unnumbered}

Varsayılan olarak, `import()` dosyasına bir Excel çalışma kitabı (.xlsx) sağlarsanız, çalışma kitabının ilk sayfası içe aktarılacaktır. Belirli bir **sayfayı** içe aktarmak istiyorsanız, sayfa adını `which = ` değişkenine ekleyin. Örneğin:

```{r eval=F}
my_data <- import("my_excel_file.xlsx", which = "Sheetname")
```
"import()" ile ilişkili bir yol sağlamak için "here()" yöntemini kullanıyorsanız, "here()" fonksiyonunu kapanış parantezlerinden sonra "which =" değişkenine ekleyerek belirli bir sayfayı yine de belirtebilirsiniz.  

```{r import_sheet_here, eval=F}
# Gösteri: 'here' paketiyle ilgili yolları kullanırken belirli bir Excel sayfasını içe aktarma
linelist_raw <- import(here("data", "linelist.xlsx"), which = "Sheet1")`  
```

Bir veri çerçevesini R'dan belirli bir Excel sayfasına *dışa aktarmak* ve Excel çalışma kitabının geri kalanının değişmeden kalmasını sağlamak için, bu amaca yönelik **openxlsx** gibi alternatif bir paketle içe aktarmanız, düzenlemeniz ve dışa aktarmanız gerekir. . [Dizin etkileşimleri] sayfasındaki veya [bu github sayfasındaki](https://ycphs.github.io/openxlsx/) daha fazla bilgiye bakabilirsiniz.

Excel çalışma kitabınız .xlsb (ikili biçimli Excel çalışma kitabı) ise **rio** kullanarak içe aktaramayabilirsiniz. .xlsx olarak yeniden kaydetmeyi veya [bu amaç için] oluşturulmuş **readxlsb** gibi bir paket kullanmayı düşünebilirsiniz(https://cran.r-project.org/web/packages/readxlsb/vignettes/read- xlsb-workbook.html).






<!-- ============================================ ========= -->
### Eksik değerler {#import_missing .unnumbered}

Veri kümenizdeki hangi değer(ler)in eksik olarak kabul edilmesi gerektiğini belirlemek isteyebilirsiniz. [Eksik veri] sayfasında açıklandığı gibi, R'daki eksik veriler için değer `NA'dır, ancak belki de içe aktarmak istediğiniz veri kümesi bunun yerine 99, "Eksik" veya yalnızca boş karakter alanı "" kullanır.

'import()' için 'na = ' bağımsız değişkenini kullanın ve değer(ler)i tırnak işaretleri içinde sağlayın (sayı olsalar bile). Aşağıda gösterildiği gibi `c()` kullanarak bunları bir vektöre dahil ederek birden çok değer belirtebilirsiniz.

Burada, içe aktarılan veri kümesindeki "99" değeri eksik olarak kabul edilir ve R'da "NA"ya dönüştürülür.

```{r, eval=F}
linelist <- import(here("data", "my_linelist.xlsx"), na = "99")
```

Burada, içe aktarılan veri kümesindeki "Eksik", "" (boş hücre) veya " " (tek boşluk) değerlerinden herhangi biri R'da "NA"ya dönüştürülür.

```{r, eval=F}
linelist <- import(here("data", "my_linelist.csv"), na = c("Missing", "", " "))
```


<!-- ======================================================= -->
### Satırları atla {.unnumbered}

Bazen bir veri satırını içe aktarmaktan kaçınmak isteyebilirsiniz. Bir .xlsx veya .csv dosyasında **rio**'dan `import()` kullanıyorsanız bunu `skip =` değişkeniyle yapabilirsiniz. Atlamak istediğiniz satır sayısını belirtin.


```{r, eval=F}
linelist_raw <- import("linelist_raw.xlsx", skip = 1)  # does not import header row
```

Ne yazık ki `skip= ` yalnızca bir tamsayı değeri kabul eder, bir aralık *kabul etmez* (ör. "2:10" çalışmaz). Üstten ardışık olmayan belirli satırların içe aktarımını atlamak için, birden çok kez içe aktarmayı ve **dplyr**'den `bind_rows()` kullanmayı düşünün. Yalnızca 2. satırı atlamayla ilgili aşağıdaki örneğe bakın.


### İkinci bir başlık satırını yönetin {.unnumbered}

Bazen, aşağıda gösterildiği gibi bir "veri sözlüğü" satırıysa verileriniz bir *saniye* satırı olabilir. Bu durum sorunlu olabilir, çünkü tüm sütunların "karakter" sınıfı olarak içe aktarılmasına neden olabilir.  

```{r, echo=F}
# HIDDEN FROM READER
####################
# Create second header row of "data dictionary" and insert into row 2. Save as new dataframe.
linelist_2headers <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds")) %>%         
        mutate(across(everything(), as.character)) %>% 
        add_row(.before = 1,
                #row_num = "000",
                case_id = "case identification number assigned by MOH",
                generation = "transmission chain generation number",
                date_infection = "estimated date of infection, mm/dd/yyyy",
                date_onset = "date of symptom onset, YYYY-MM-DD",
                date_hospitalisation = "date of initial hospitalization, mm/dd/yyyy",
                date_outcome = "date of outcome status determination",
                outcome = "either 'Death' or 'Recovered' or 'Unknown'",
                gender = "either 'm' or 'f' or 'unknown'",
                hospital = "Name of hospital of first admission",
                lon = "longitude of residence, approx",
                lat = "latitude of residence, approx",
                infector = "case_id of infector",
                source = "context of known transmission event",
                age = "age number",
                age_unit = "age unit, either 'years' or 'months' or 'days'",
                fever = "presence of fever on admission, either 'yes' or 'no'",
                chills = "presence of chills on admission, either 'yes' or 'no'",
                cough = "presence of cough on admission, either 'yes' or 'no'",
                aches = "presence of aches on admission, either 'yes' or 'no'",
                vomit = "presence of vomiting on admission, either 'yes' or 'no'",
                time_admission = "time of hospital admission HH:MM")
```

Aşağıda bu tür bir veri kümesi örneği verilmiştir (ilk satır veri sözlüğüdür).

```{r message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist_2headers, 5), rownames = FALSE, filter="top", options = list(pageLength = 4, scrollX=T), class = 'white-space: nowrap' )
```

#### İkinci başlık satırını kaldırın {.unnumbered} 

İkinci başlık satırını bırakmak için büyük olasılıkla verileri iki kez içe aktarmanız gerekecektir.

1) Doğru sütun adlarını saklamak için verileri içe aktarın
2) İlk *iki* satırı (başlık ve ikinci satır) atlayarak verileri tekrar içe aktarın
3) Doğru adları azaltılmış veri çerçevesine bağlayın

Doğru sütun adlarını bağlamak için kullanılan tam bağımsız değişken, veri dosyasının türüne (.csv, .tsv, .xlsx, vb.) bağlıdır. Bunun nedeni, **rio**'nun farklı dosya türleri için farklı bir fonksiyon kullanmasıdır (yukarıdaki tabloya bakın).

**Excel dosyaları için:** (`col_names =`)

```{r, eval=F}
# ilk kez içe aktarma; sütun adlarını sakla
linelist_raw_names <- import("linelist_raw.xlsx") %>% names()  # gerçek sütun adlarını kaydet

# ikinci kez içe aktar; 2. satırı atlayın ve sütun adlarını col_names = değişkenine atayın
linelist_raw <- import("linelist_raw.xlsx",
                       skip = 2,
                       col_names = linelist_raw_names
                       ) 
```

**CSV dosyaları için:** (`col.names = `)  

```{r, eval=F}
# ilk kez içe aktarma; sütun adlarını depola
linelist_raw_names <- import("linelist_raw.csv") %>% names() # gerçek sütun adlarını kaydet

# csv dosyaları için not değişkeni 'col.names =' şeklindedir
linelist_raw <- import("linelist_raw.csv",
                       skip = 2,
                       col.names = linelist_raw_names
                       ) 
```

**Yedekleme seçeneği** - sütun adlarını ayrı bir komut olarak değiştirme

```{r, eval=F}
# temel 'colnames()' fonksiyonunu kullanarak başlıkları ata/üzerine yaz
colnames(linelist_raw) <- linelist_raw_names
```


#### Veri sözlüğü oluşturun {.unnumbered}

Bonus! Veri sözlüğü olan ikinci bir satırınız varsa, ondan kolayca uygun bir veri sözlüğü oluşturabilirsiniz. Bu ipucu bu [post](https://alison.rbind.io/post/2018-02-23-read-multiple-header-rows/)'dan uyarlanmıştır.


```{r}
dict <- linelist_2headers %>%             # başla: ilk satır olarak sözlük içeren satır listesi
  head(1) %>%                             # yalnızca sütun adlarını ve ilk sözlük satırını tut                
  pivot_longer(cols = everything(),       # tüm sütunları uzun biçime döndür
               names_to = "Column",       # yeni sütun adları atayın
               values_to = "Description")
```


```{r message=FALSE, echo=F}
DT::datatable(dict, rownames = FALSE, filter="top", options = list(pageLength = 4, scrollX=T), class = 'white-space: nowrap' )
```



#### İki başlık satırını birleştirin {.unnumbered}

Bazı durumlarda, ham veri kümenizde *iki* başlık satırı varsa (veya daha spesifik olarak, 2. veri satırı ikincil bir başlıktır), bunları "birleştirmek" veya ikinci başlık satırındaki değerleri ilk başlığa eklemek isteyebilirsiniz.

Aşağıdaki komut, veri çerçevesinin sütun adlarını, hemen altındaki (ilk satırdaki) değerle ilk (doğru) başlıkların birleşimi (birlikte yapıştırarak) olarak tanımlayacaktır.

```{r, eval=F}
names(my_data) <- paste(names(my_data), my_data[1, ], sep = "_")
```



<!-- ============================================ ========= -->
### Google sayfaları {.unnumbered}

**googlesheet4** paketiyle ve e-tabloya erişiminizi doğrulayarak çevrimiçi bir Google e-tablosundan veri aktarabilirsiniz.


```{r, eval=F}
pacman::p_load("googlesheets4")
```

Aşağıda, bir demo Google sayfası içe aktarılır ve kaydedilir. Bu komut, Google hesabınızın kimlik doğrulamasının onaylanmasını isteyebilir. Tidyverse API paketlerine Google Drive'da e-tablolarınızı düzenleme, oluşturma ve silme izinleri vermek için internet tarayıcınızdaki istemleri ve açılır pencereleri izleyin.


Aşağıdaki sayfa "bağlantıya sahip olan herkes tarafından görüntülenebilir" ve onu içe aktarmayı deneyebilirsiniz.

```{r, eval=F}
Gsheets_demo <- read_sheet("https://docs.google.com/spreadsheets/d/1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY/edit#gid=0")
```

Sayfa, yalnızca URL'nin daha kısa bir parçası olan sayfa kimliği kullanılarak da içe aktarılabilir:

```{r, eval=F}
Gsheets_demo <- read_sheet("1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY")
```


Başka bir paket olan **googledrive**, Google sayfalarını yazmak, düzenlemek ve silmek için kullanışlı fonksiyonlar sunar. Örneğin, bu pakette bulunan `gs4_create()` ve `sheet_write()` fonksiyonları kullanılabilir.

İşte diğer bazı yararlı çevrimiçi eğitimler:
[temel Google sayfaları içe aktarma öğreticisi](https://arbor-analytics.com/post/getting-your-data-into-r-from-google-sheets/)
[daha ayrıntılı eğitim](https://googlesheets4.tidyverse.org/articles/googlesheets4.html)
[googlesheets4 ve tidyverse arasındaki etkileşim](https://googlesheets4.tidyverse.org/articles/articles/drive-and-sheets.html)




## Birden çok dosya - içe aktarma, dışa aktarma, bölme, birleştirme

Birden çok dosyanın veya birden çok Excel çalışma kitabı dosyasının nasıl içe aktarılacağına ve birleştirileceğine ilişkin örnekler için [Yineleme, döngüler ve listeler] hakkındaki sayfaya bakın. Bu sayfada ayrıca bir veri çerçevesinin parçalara nasıl bölüneceği ve her birinin ayrı ayrı veya bir Excel çalışma kitabında adlandırılmış sayfalar olarak nasıl dışa aktarılacağına ilişkin örnekler de vardır.




<!-- ============================================= ========= -->
## Github'dan içe aktar {#import_github}

Verileri doğrudan Github'dan R'a aktarmak çok kolay olabilir veya dosya türüne bağlı olarak birkaç adım gerektirebilir. Aşağıda bazı yaklaşımlar yer almaktadır:

### CSV dosyaları {.unnumbered}

Bir .csv dosyasını bir R komutuyla doğrudan Github'dan R'a aktarmak kolay olabilir.

1) Github deposuna gidin, ilgilendiğiniz dosyayı bulun ve üzerine tıklayın.
3) "Raw" düğmesine tıklayın (daha sonra aşağıda gösterildiği gibi "ham" csv verilerini göreceksiniz)
4) URL'yi kopyalayın (web adresi)
5) URL'yi `import()` R komutu içinde tırnak içine alın

```{r, out.width=c('100%', '100%'), fig.align = "left", echo=F}
knitr::include_graphics(here::here("images", "download_csv_raw.png"))
```

### XLSX dosyaları {.unnumbered}

Bazı dosyalar için "Ham" verileri görüntüleyemeyebilirsiniz (ör. .xlsx, .rds, .nwk, .shp)

1) Github deposuna gidin, ilgilendiğiniz dosyayı bulun ve üzerine tıklayın.
2) Aşağıda gösterildiği gibi "İndir" düğmesini tıklayın
3) Dosyayı bilgisayarınıza kaydedin ve R'a alın 


```{r , out.width=c('100%', '100%'), fig.align = "left", echo=F}
knitr::include_graphics(here::here("images", "download_xlsx.png"))
```

### Şekil dosyaları (Shapefiles) {.unnumbered}

Şekil dosyaları, her biri farklı bir dosya uzantısına sahip birçok alt bileşen dosyasına sahiptir. Bir dosya ".shp" uzantısına sahip olacaktır, ancak diğerleri ".dbf", ".prj" vb. uzantılara sahip olabilir. Github'dan bir şekil dosyası indirmek için, alt bileşen dosyalarının her birini ayrı ayrı indirmeniz ve kaydetmeniz gerekir. bunları bilgisayarınızdaki *aynı* klasöre yerleştirin. Github'da her dosyaya tek tek tıklayın ve "İndir" butonuna tıklayarak indirin.

Bilgisayarınıza kaydettikten sonra, **sf** paketinden `st_read()` kullanarak şekil dosyasını [GIS temel bilgileri] sayfasında gösterildiği gibi içe aktarabilirsiniz. Diğer ilgili dosyalar bilgisayarınızda aynı klasörde olduğu sürece yalnızca ".shp" dosyasının dosya yolunu ve adını sağlamanız gerekir. 

Aşağıda, "sle_adm3" şekil dosyasının her biri Github'dan indirilmesi gereken birçok dosyadan nasıl oluştuğunu görebilirsiniz. 

```{r , out.width=c('100%', '100%'), fig.align = "left", echo=F}
knitr::include_graphics(here::here("images", "download_shp.png"))
```





<!-- ======================================================= -->
## Manuel veri girişi {}

### Satırlara göre giriş {.unnumbered}

tidyverse'deki **tibble** paketindeki 'tribble' fonksiyonunu kullanın ([çevrimiçi tibble referansı](https://tibble.tidyverse.org/reference/tribble.html)).
  
Sütun başlıklarının nasıl *tilde* (`~`) ile başladığına dikkat edin. Ayrıca her sütunun yalnızca bir veri sınıfı (karakter, sayısal vb.) içermesi gerektiğini unutmayın. Veri girişini daha sezgisel ve okunabilir hale getirmek için sekmeleri, boşlukları ve yeni satırları kullanabilirsiniz. Değerler arasında boşluklar önemli değildir, ancak her satır yeni bir kod satırı ile temsil edilir. Örneğin:

```{r import_manual_row}
# veri kümesini satıra göre manuel olarak oluşturun
manual_entry_rows <- tibble::tribble(
  ~colA, ~colB,
  "a",   1,
  "b",   2,
  "c",   3
  )
```

Ve şimdi yeni veri setini görüntülüyoruz:

```{r, echo=F}
# yeni veri setini görüntüleme
DT::datatable(manual_entry_rows)
```


### Sütunlara göre giriş {.unnumbered}

Bir veri çerçevesi vektörlerden (dikey sütunlardan) oluştuğu için, R'da manuel veri çerçevesi oluşturmaya yönelik **temel** yaklaşım, her sütunu tanımlamanızı ve ardından bunları birbirine bağlamanızı bekler. Bu, genellikle verilerimizi satırlar halinde düşündüğümüzden (yukarıdaki gibi) epidemiyolojide mantıksız olabilir.

```{r import_manual_col}
# her vektörü (dikey sütun) ayrı ayrı tanımlayın, her biri kendi adıyla
PatientID <- c(235, 452, 778, 111)
Treatment <- c("Yes", "No", "Yes", "Yes")
Death     <- c(1, 0, 1, 0)
```

<span style="color: orange;">**_UYARI:_** Tüm vektörler aynı uzunlukta olmalıdır (aynı sayıda değer).</span>

Vektörler daha sonra "data.frame()" fonksiyonu kullanılarak birbirine bağlanabilir:

```{r}
# vektör adlarına başvurarak sütunları bir veri çerçevesinde birleştirin
manual_entry_cols <- data.frame(PatientID, Treatment, Death)
```

Ve şimdi yeni veri setini görüntülüyoruz.

```{r, echo=F}
# yeni veri setini görüntülemek.
DT::datatable(manual_entry_cols)
```




### Panodan yapıştırma {.unnumbered}

Verileri başka bir yerden kopyalar ve panonuzda bulundurursanız, aşağıdaki iki yoldan birini deneyebilirsiniz:

**clipr** paketinden, veri çerçevesi olarak içe aktarmak için 'read_clip_tbl()' veya bir karakter vektörü olarak içe aktarmak için sadece 'read_clip()' kullanabilirsiniz. Her iki durumda da parantezleri boş bırakın.

```{r, eval=F}
linelist <- clipr::read_clip_tbl()  # mevcut panoyu veri çerçevesi olarak içe aktarır
linelist <- clipr::read_clip()      # karakter vektörü olarak içe aktar
```
Ayrıca **clipr** ile sisteminizin panosuna kolayca aktarabilirsiniz. Aşağıdaki dışa aktarma bölümüne bakın.


Alternatif olarak, veri çerçevesi olarak içe aktarmak için **base** R'dan `file = "clipboard")` `read.table()` fonksiyonunu kullanabilirsiniz: 

```{r, eval=F}
df_from_clipboard <- read.table(
  file = "clipboard",  # bunu "pano" olarak belirtin
  sep = "t",           # ayırıcı sekme veya virgül vb. olabilir.
  header=TRUE)         # bir başlık satırı varsa
```






## En son dosyayı içe aktar

Genellikle veri kümeleriniz için günlük güncellemeler alabilirsiniz. Bu durumda, en son dosyayı içe aktaran bir kod yazmak isteyeceksiniz. Aşağıda buna yaklaşmanın iki yolunu sunuyoruz:

* Dosya adındaki tarihe göre dosya seçimi
* Dosya meta verilerine göre dosya seçimi (son değişiklik)


### Dosya adındaki tarihler {.unnumbered} 

Bu yaklaşım üç öncüle bağlıdır:

1) Dosya adlarındaki tarihlere güveniyorsunuz
2) Tarihler sayısaldır ve *genellikle* aynı biçimde görünür (ör. yıl sonra ay sonra gün)
3) Dosya adında başka numara yok

Her adımı açıklayacağız ve sonunda size bunların birleştirilmiş halini göstereceğiz.

İlk olarak, ilgilenilen klasördeki her dosya için yalnızca dosya adlarını çıkarmak için **base** R'dan `dir()` kullanın. 'dir()' hakkında daha fazla ayrıntı için [Dizin etkileşimleri] sayfasına bakın. Bu örnekte, ilgilenilen klasör, R projesi içindeki "data" içindeki "example" klasörü içindeki "linelists" klasörüdür.

```{r}
linelist_filenames <- dir(here("data", "example", "linelists")) # klasörden dosya isimlerini al
linelist_filenames                                              # yazdır
```

Bu ad vektörüne sahip olduğunuzda, bu normal ifadeyi kullanarak **stringr**'den `str_extract()` uygulayarak tarihleri çıkarabilirsiniz. Dosya adındaki herhangi bir sayıyı çıkarır (ortadaki tire veya eğik çizgi gibi diğer karakterler dahil). [Dizeler ve karakterler] sayfasında **stringr** hakkında daha fazla bilgi edinebilirsiniz.

```{r}
linelist_dates_raw <- stringr::str_extract(linelist_filenames, "[0-9].*[0-9]") # sayıları ve aradaki karakterleri ayıklayın
linelist_dates_raw  # yazdır
```

Tarihlerin genellikle aynı tarih formatında yazıldığını (örneğin Yıl sonra Ay sonra Gün) ve yılların 4 basamaklı olduğunu varsayarsak, **lubridate**'nin esnek dönüştürme fonksiyonlarını (`ymd()`, `dmy() kullanabilirsiniz. )` veya `mdy()`) tarihlere dönüştürmek için. Bu fonksiyonlar için tireler, boşluklar veya eğik çizgiler önemli değildir, yalnızca sayıların sırası önemlidir. [Tarihlerle çalışma] sayfasında daha fazlasını okuyun.  

```{r}
linelist_dates_clean <- lubridate::ymd(linelist_dates_raw)
linelist_dates_clean
```

**base** R fonksiyonu `which.max()` daha sonra maksimum tarih değerinin dizin konumunu (ör. 1., 2., 3., ...) döndürmek için kullanılabilir. En son dosya, 6. dosya olarak doğru bir şekilde tanımlandı - "case_linelist_2020-10-08.xlsx".  

```{r}
index_latest_file <- which.max(linelist_dates_clean)
index_latest_file
```

Tüm bu komutları yoğunlaştırırsak, kodun tamamı aşağıdaki gibi görünebilir. Son satırdaki `.` öğesinin, tünel dizisindeki o noktada tünellenen nesne için bir yer tutucu olduğuna dikkat edin. Bu noktada değer basitçe 6 sayısıdır. Bu, 'dir()' tarafından üretilen dosya adları vektörünün 6. öğesini çıkarmak için çift parantez içine yerleştirilir.

```{r}
# paketleri yükle
pacman::p_load(
  tidyverse,         # veri yönetimi
  stringr,           # dizeler/karakterlerle çalışmak
  lubridate,         # tarihlerle çalışmak
  rio,               # içe aktar / dışa aktar
  here,              # ilişkili dosya yolları
  fs)                # dizin etkileşimleri

# en son dosyanın dosya adını çıkar
latest_file <- dir(here("data", "example", "linelists")) %>%  # "linelists" alt klasöründeki dosya adları         
  str_extract("[0-9].*[0-9]") %>%                  # tarihleri çıkar (sayılar)
  ymd() %>%                                        # sayıları tarihlere dönüştür (yıl-ay-gün biçimini varsayarak)
  which.max() %>%                                  # maksimum tarihin dizinini al (en son dosya)
  dir(here("data", "example", "linelists"))[[.]]              # en son satır listesinin dosya adını döndür

latest_file  # en son dosyanın adını yazdır
```

Artık bu adı, ilişkili dosya yolunu "here()" ile bitirmek için kullanabilirsiniz:

```{r, eval=F}
here("data", "example", "linelists", latest_file) 
```

Ve şimdi en son dosyayı içe aktarabilirsiniz:

```{r, eval=F}
# import
import(here("data", "example", "linelists", latest_file)) # içe aktar 
```

 



###  Dosya bilgisini kullanın {.unnumbered}

Dosyalarınızın adlarında tarih yoksa (veya bu tarihlere güvenmiyorsanız), dosya meta verilerinden son değişiklik tarihini çıkarmayı deneyebilirsiniz. Her dosya için son değişiklik zamanını ve dosya yolunu içeren meta veri bilgilerini incelemek için **fs** paketindeki fonksiyonları kullanın.

Aşağıda, **fs**'nin `dir_info()` dosyasının ilgilendiği klasörü sunuyoruz. Bu durumda, ilgilenilen klasör "data" klasöründeki R projesinde, "example" alt klasöründe ve alt klasörü "linelists"tedir. Sonuç, dosya başına bir satır ve "modification_time", "path" vb. için sütunlar içeren bir veri çerçevesidir. Bunun görsel bir örneğini [Dizin etkileşimleri] sayfasında görebilirsiniz.

Dosyaların bu veri çerçevesini 'modification_time' sütununa göre sıralayabiliriz ve ardından **base** R'ın 'head()' ile yalnızca en üstteki/en son satırı (dosyayı) tutabiliriz. Daha sonra bu en son dosyanın dosya yolunu sadece 'path' sütunundaki **dplyr** fonksiyonu 'pull()' ile ayıklayabiliriz. Sonunda bu dosya yolunu `import()`a geçirebiliriz. İçe aktarılan dosya "latest_file" olarak kaydedilir.

```{r, eval=F}
latest_file <- dir_info(here("data", "example", "linelists")) %>%  # dizindeki tüm dosyalarda dosya bilgilerini topla
  arrange(desc(modification_time)) %>%      # değişiklik zamanına göre sırala
  head(1) %>%                               # sadece en üstteki (en son) dosyayı tut
  pull(path) %>%                            # yalnızca dosya yolunu çıkar
  import()                                  # dosyayı içe aktar

```



<!-- ======================================================= -->
## API'ler {#import_api}

Bir web sitesinden doğrudan veri istemek için bir "Otomatik Programlama Arayüzü" (API) kullanılabilir. API'ler, bir yazılım uygulamasının diğeriyle etkileşime girmesine izin veren bir dizi kuraldır. İstemci (siz) bir "istek" gönderir ve içerik içeren bir "yanıt" alır. **httr** ve **jsonlite** R paketleri bu süreci kolaylaştırabilir.

API'nin etkin olduğu her web sitesi, aşina olmak için kendi belgelerine ve özelliklerine sahip olacaktır. Bazı siteler herkese açıktır ve herkes tarafından erişilebilir. Kullanıcı kimliklerine ve kimlik bilgilerine sahip platformlar gibi diğerleri, verilerine erişmek için kimlik doğrulama gerektirir.

API aracılığıyla verileri içe aktarmak için internet bağlantınızın olması gerektiğini söylemeye gerek yok. Verileri içe aktarmak için API'lerin kullanımına ilişkin örnekler vereceğiz ve sizi daha fazla kaynağa bağlayacağız.

*Not: Verilerin API içermeyen bir web sitesinde *yayınlanabileceğini* ve bunun alınmasının daha kolay olabileceğini unutmayın. Örneğin, yayınlanan bir CSV dosyasına, [Github'dan içe aktarma](#import_github) bölümünde açıklandığı gibi site URL'sini "import()"a sağlayarak kolayca erişilebilir.*


### HTTP isteği {.unnumbered}

API değişimi en yaygın olarak bir HTTP isteği aracılığıyla yapılır. HTTP, Köprü Metni Aktarım Protokolüdür ve bir istemci ile bir sunucu arasındaki bir istek/yanıtın temel biçimidir. Tam girdi ve çıktı, API türüne bağlı olarak değişebilir, ancak süreç aynıdır - genellikle bir sorgu içeren, kullanıcıdan gelen bir "Talep" (genellikle HTTP İsteği), ardından durum bilgilerini içeren bir "Yanıt". 

İşte bir *HTTP isteğinin* birkaç bileşeni:

* API uç noktasının URL'si
* "Yöntem" (veya "Fiil")
* Başlıklar
* Vücut

HTTP isteği "yöntemi", gerçekleştirmek istediğiniz eylemdir. En yaygın iki HTTP yöntemi 'GET' ve 'POST'tur, ancak diğerleri 'PUT', 'DELETE', 'PATCH' vb. içerebilir. Verileri R'a aktarırken büyük olasılıkla 'GET' kullanacaksınız.

İsteğinizden sonra bilgisayarınız, URL, HTTP durumu (İstediğiniz Durum 200'dür!), dosya türü, boyutu ve istenen içerik dahil olmak üzere gönderdiğinize benzer bir biçimde bir "yanıt" alacaktır. Daha sonra bu yanıtı ayrıştırmanız ve R ortamınızda uygulanabilir bir veri çerçevesine dönüştürmeniz gerekecektir.


### Paketler {.unnumbered}

**httr** paketi, R'da HTTP isteklerini işlemek için iyi çalışır. Web API'leri hakkında çok az ön bilgi gerektirir ve yazılım geliştirme terminolojisine daha az aşina olan kişiler tarafından kullanılabilir. Ayrıca, HTTP yanıtı .json ise yanıtı ayrıştırmak için **jsonlite** kullanabilirsiniz.

```{r, eval=F}
# paketleri yüklemek
pacman::p_load(httr, jsonlite, tidyverse)
```


### Herkese açık veriler {.unnumbered}

Aşağıda, [Trafford Data Lab](https://www.trafforddatalab.io/open_data_companion/#A_quick_introduction_to_APIs) bir eğiticiden ödünç alınan bir HTTP isteği örneği verilmiştir. Bu sitede öğrenilecek başka kaynaklar ve API alıştırmaları var.

Senaryo: İngiltere'nin Trafford şehrinde bulunan fast food satış noktalarının bir listesini içe aktarmak istiyoruz. Verilere, Birleşik Krallık için gıda hijyeni derecelendirme verileri sağlayan Gıda Standartları Ajansı API'sinden erişilebilir.

İşte talebimiz için parametreler:

* HTTP fiili: GET
* API uç noktası URL'si: http://api.ratings.food.gov.uk/Establishments
* Seçilen parametreler: ad, adres, boylam, enlem, businessTypeId, ratingKey, localAuthorityId
* Başlıklar: “x-api-version”, 2
* Veri biçimleri: JSON, XML
* Belgeler: http://api.ratings.food.gov.uk/help

R kodu aşağıdaki gibi olacaktır:

```{r, eval=F, warning=F, message=F}
# talebi hazırlamak
path <- "http://api.ratings.food.gov.uk/Establishments"
request <- GET(url = path,
             query = list(
               localAuthorityId = 188,
               BusinessTypeId = 7844,
               pageNumber = 1,
               pageSize = 5000),
             add_headers("x-api-version" = "2"))

# herhangi bir sunucu hatası olup olmadığını kontrol edin ("200" iyidir!)
request$status_code

# isteği gönderin, yanıtı ayrıştırın ve bir veri çerçevesine dönüştürün
response <- content(request, as = "text", encoding = "UTF-8") %>%
  fromJSON(flatten = TRUE) %>%
  pluck("establishments") %>%
  as_tibble()
```

Artık her fast food tesisi için bir satır içeren "yanıt" veri çerçevesini temizleyebilir ve kullanabilirsiniz.


### Kimlik doğrulama gerekli {.unnumbered}

Bazı API'ler kimlik doğrulaması gerektirir - kim olduğunuzu kanıtlamanız halinde kısıtlı verilere erişebilirsiniz. Bu verileri içe aktarmak için önce bir kullanıcı adı, parola veya kod sağlamak üzere bir POST yöntemi kullanmanız gerekebilir. Bu, istenen verileri almak için sonraki GET yöntemi istekleri için kullanılabilecek bir erişim belirteci döndürür.

Aşağıda, bir salgın araştırma aracı olan *Go.Data*'dan veri sorgulama örneği verilmiştir. *Go.Data*, veri toplama için kullanılan web ön uç ve akıllı telefon uygulamaları arasındaki tüm etkileşimler için bir API kullanır. *Go.Data* tüm dünyada kullanılmaktadır. Salgın verileri hassas olduğundan ve yalnızca *salgınınız* için verilere erişebilmeniz gerektiğinden, kimlik doğrulama gereklidir.

Aşağıda, salgınınızdan kişi takibine ilişkin verileri içe aktarmak için *Go.Data* API'sine bağlanmak için **httr** ve **jsonlite** kullanan bazı örnek R kodları verilmiştir.


```{r, eval=F}
# yetkilendirme için kimlik bilgilerini ayarla
url <- "https://godatasampleURL.int/"           # geçerli Go.Data url örneği
username <- "username"                          # geçerli Go.Data kullanıcı adı 
password <- "password"                          # geçerli Go.Data parolası 
outbreak_id <- "xxxxxx-xxxx-xxxx-xxxx-xxxxxxx"  # geçerli Go.Data salgın kimliği

# erişim izni almak
url_request <- paste0(url,"api/oauth/token?access_token=123") # temel url isteğini tanımla

# istek hazırlamak
response <- POST(
  url = url_request,  
  body = list(
    username = username,    # yetkilendirmek için yukarıdan kaydedilmiş kullanıcı adını/şifreyi kullanın                           
    password = password),                                       
    encode = "json")

# isteği yürüt ve yanıtı ayrıştır
content <-
  content(response, as = "text") %>%
  fromJSON(flatten = TRUE) %>%          # düzleştirilmiş iç içe JSON
  glimpse()

# Yanıttan erişim belirtecini kaydet
access_token <- content$access_token    # aşağıdaki API çağrılarına izin vermek için erişim belirtecini kaydedin

# Salgın temaslılarını içe aktar
# Erişim belirtecini kullanın
response_contacts <- GET(
  paste0(url,"api/outbreaks/",outbreak_id,"/contacts"),          # GET talebi
  add_headers(
    Authorization = paste("Bearer", access_token, sep = " ")))

json_contacts <- content(response_contacts, as = "text")         # Metni JSON'a dönüştür

contacts <- as_tibble(fromJSON(json_contacts, flatten = TRUE))   # JSON'u tibble için düzleştirin 
```

<span style="color: orange;">**_UYARI:_** Kimlik doğrulama gerektiren bir API'den büyük miktarda veri içe aktarıyorsanız, zaman aşımına uğrayabilir. Bunu önlemek için, her API GET isteğinden önce access_token'i tekrar alın ve sorguda filtreleri veya sınırları kullanmayı deneyin. </span>

<span style="color: darkgreen;">**_İPUCU:_** **jsonlite** paketindeki `fromJSON()` fonksiyonu, ilk çalıştırıldığında yuvayı tamamen açmaz, bu nedenle muhtemelen yine de sonuçta ortaya çıkan tibble'ınızda liste öğeleri vardır. .json dosyanızın ne kadar iç içe olduğuna bağlı olarak belirli değişkenler için daha fazla yuva açmanız gerekecektir. Bununla ilgili daha fazla bilgi görüntülemek için, [`flatten()` fonksiyonu](https://rdrr.io/cran/jsonlite/man/flatten.html) gibi **jsonlite** paketinin belgelerine bakabilirsiniz. </span>


Daha fazla ayrıntı için [LoopBack Explorer](https://loopback.io/doc/en/lb4/index.html), [Kişi İzleme] sayfası veya [Go.Data Github deposundaki](https://worldhealthorganization.github.io/godata/api-docs) API ipuçları hakkındaki belgeleri görüntüleyin. 

*httr* paketi hakkında daha fazla bilgiyi [buradan](https://httr.r-lib.org/articles/quickstart.html) okuyabilirsiniz.

Bu bölümde ayrıca [bu ders](https://www.dataquest.io/blog/r-api-tutorial/) ve [bu ders](https://medium.com/@traffordDataLab/querying-apis-in-r-39029b73d5f1) metinlerinden de yararlanıldı.




<!-- ============================================= ========= -->
## Dışa aktarma{}

### **rio** paketiyle {.unnumbered}
**rio** ile, 'export()' fonksiyonunu 'import()' fonksiyonuna çok benzer bir şekilde kullanabilirsiniz. Önce kaydetmek istediğiniz R nesnesinin adını verin (örn. Örneğin:

Bu, "linelist" veri çerçevesini bir Excel çalışma kitabı olarak çalışma dizini/R proje kök klasörüne kaydeder:

```{r, eval=F}
export(linelist, "my_linelist.xlsx") # çalışma dizinine kaydedecek
```

Uzantıyı değiştirerek aynı veri çerçevesini bir csv dosyası olarak kaydedebilirsiniz. Örneğin, onu "here()" ile oluşturulmuş bir dosya yoluna da kaydederiz:

```{r, eval=F}
export(linelist, here("data","clean", "my_linelist.csv")
```


### Panoya {.unnumbered}

Bir veri çerçevesini bilgisayarınızın "panosuna" aktarmak için (daha sonra Excel, Google E-Tablolar, vb. gibi başka bir yazılıma yapıştırmak için) **clipr** paketinden `write_clip()` kullanabilirsiniz.

```{r, eval=F}
# satır listesi veri çerçevesini sisteminizin panosuna aktarın
clipr::write_clip(linelist)
```




## RDS dosyaları {#import_rds}

.csv, .xlsx vb. ile birlikte R veri çerçevelerini .rds dosyaları olarak dışa aktarabilir/kaydedebilirsiniz. Bu, R'a özgü bir dosya biçimidir ve dışa aktarılan verilerle tekrar R'da çalışacağınızı biliyorsanız çok kullanışlıdır.

Sütun sınıfları depolanır, bu nedenle içe aktarıldığında tekrar temizlemeniz gerekmez (bir Excel veya hatta bir CSV dosyası ile bu bir baş ağrısı olabilir!). Ayrıca, veri kümeniz büyükse dışa ve içe aktarma için kullanışlı olan daha küçük bir dosya üzerinden işlemi yapar.

Örneğin, bir Epidemiyoloji ekibinde çalışıyorsanız ve haritalama için bir CBS ekibine dosya göndermeniz gerekiyorsa ve onlar da R kullanıyorsa, onlara .rds dosyasını göndermeniz yeterlidir! Daha sonra tüm sütun sınıfları korunur ve yapacak daha az işleri olur.

```{r, eval=F}
export(linelist, here("data","clean", "my_linelist.rds")
```



<!-- ======================================================= -->
## Rdata dosyaları ve listeleri {#import_rdata}

'.Rdata' dosyaları birden çok R nesnesini depolayabilir - örneğin birden çok veri çerçevesi, model sonuçları, listeler, vb. Bu, belirli bir proje için çok sayıda verinizi birleştirmek veya paylaşmak için çok yararlı olabilir.

Aşağıdaki örnekte, dışa aktarılan "my_objects.Rdata" dosyasında birden çok R nesnesi depolanır: 

```{r, eval=F}
rio::export(my_list, my_dataframe, my_vector, "my_objects.Rdata")
```

Not: Bir listeyi *içe aktarmaya* çalışıyorsanız, tam orijinal yapı ve içerikle içe aktarmak için **rio**'dan `import_list()` kullanın.

```{r, eval=F}
rio::import_list("my_list.Rdata")
```







<!-- ======================================================= -->
## Grafikleri kaydetme {}

"ggplot()" tarafından oluşturulanlar gibi grafiklerin nasıl kaydedileceğine ilişkin talimatlar [ggplot temelleri] sayfasında ayrıntılı olarak tartışılmaktadır.

Özetle, grafiğinizi yazdırdıktan sonra `ggsave("my_plot_filepath_and_name.png")` komutunu çalıştırın. `plot =` değişkenine kaydedilmiş bir çizim nesnesi sağlayabilir veya en son görüntülenen grafiği kaydetmek için yalnızca hedef dosya yolunu (dosya uzantısıyla) belirtebilirsiniz. Ayrıca 'width = ', 'height = ', 'units = ' ve 'dpi = ' değerlerini de kontrol edebilirsiniz.

İletim ağacı gibi bir ağ grafiğinin nasıl kaydedileceği [İletim zincirleri] sayfasında açıklanmıştır.


<!-- ============================================= ========= -->
## Kaynaklar {}

[R Verilerini İçe/Dışa Aktarma Kılavuzu](https://cran.r-project.org/doc/manuals/r-release/R-data.html)
[Veri içe aktarma hakkında R 4 Veri Bilimi bölümü](https://r4ds.had.co.nz/data-import.html#data-import)
[ggsave() belgeleri](https://ggplot2.tidyverse.org/reference/ggsave.html)


Aşağıda **rio** çevrimiçi [vinyet](https://cran.r-project.org/web/packages/rio/vignettes/rio.html)'den alınmış bir tablo bulunmaktadır. Gösterilen her veri türü için: beklenen dosya uzantısı, **rio** paketinin verileri içe veya dışa aktarmak için kullandığı ve bu fonksiyonun **rio**'nun varsayılan yüklü sürümüne dahil edilip edilmediğini gösterir.


Biçim | Tipik Uzantı | İçe Aktarma Paketi | Dışa Aktarma Paketi | Varsayılan Olarak Yüklenir Mi?
---------------------------|-------------------|-------------------|--------------------|---------------------
Comma-separated data | .csv | data.table `fread()` | data.table |	Evet
Pipe-separated data |	.psv | data.table `fread()` | data.table | Evet
Tab-separated data| .tsv | data.table `fread()` | data.table | Evet
SAS | .sas7bdat | haven | haven | Evet
SPSS | .sav | haven | haven | Evet
Stata | .dta | haven | haven | Evet
SAS | XPORT | .xpt | haven | haven | Evet
SPSS Portable | .por | haven | | Evet
Excel | .xls | readxl | | Evet
Excel | .xlsx | readxl | openxlsx | Evet
R syntax | .R	| base | base | Evet
Saved R objects | .RData, .rda | base | base | Evet
Serialized R objects | .rds | base | base | Evet
Epiinfo | .rec | foreign | | Evet
Minitab | .mtp | foreign | | Evet
Systat | .syd |	foreign | | Evet
“XBASE” | database files | .dbf | foreign | foreign | Evet
Weka Attribute-Relation File Format | .arff | foreign | foreign | Evet
Data Interchange Format | .dif | utils | | Evet
Fortran data | no recognized extension | utils | | Evet
Fixed-width format data | .fwf | utils | utils | Evet
gzip comma-separated data | .csv.gz | utils | utils | Evet
CSVY (CSV + YAML metadata header) | .csvy | csvy | csvy | Hayır
EViews | .wf1 |hexView | | Hayır
Feather R/Python interchange format | .feather | feather | feather | Hayır
Fast Storage | .fst | fst |	fst | Hayır
JSON | .json | jsonlite | jsonlite | Hayır
Matlab | .mat | rmatio | rmatio | Hayır
OpenDocument Spreadsheet | .ods | readODS | readODS | Hayır
HTML Tables | .html | xml2 | xml2 | Hayır
Shallow XML documents | .xml | xml2 | xml2 | Hayır
YAML | .yml | yaml | yaml	| Hayır
Clipboard	default is tsv | |  clipr | clipr | Hayır



```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/importing.Rmd-->

# (PART) Data Management {.unnumbered}
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/cat_data_management.Rmd-->

---
output:
  word_document: default
  html_document: default
---
# Veri temizliği ve temel fonksiyonlar  {}


```{r, out.height = "10%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "cleaning.png"))
```


Bu sayfa, bir veritabanını "temizleme" sürecinde kullanılan genel adımları gösterir ve ayrıca birçok temel R veri yönetimi fonksiyonunun kullanımını açıklamaktadır. 

Bu sayfada veri temizliğinin gösterimi için ilk olarak ham satır listesi formunda bir veritabanı içe aktarılacaktır (import). Daha sonra adım adım veri temizliği basamakları uygulanacaktır. 

R kod dilinde bu süreç “tünel” zinciri olarak adlandırılır. Tünel (pipe) operatörü %>% bir veritabanını bir operasyondan diğerine aktarır. 



### Temel fonksiyonlar  {.unnumbered}  

Bu el kitabı R paketlerinden tidyverse ailesi fonksiyonlarının kullanımını vurgulamaktadır.  [**tidyverse**](https://www.tidyverse.org/) Bu sayfada gösterilen temel R fonksiyonları aşağıda listelenmiştir.

Bu fonksiyonların çoğu dplyr R paketine aittir. Bu R paketi veri manipülasyonu problemlerini çözmek için gerekli “eylem” fonksiyonlarını içerir.  ( dplyr ismi veri çerçevesi katlayıcı – data frame [plier](https://www.thefreedictionary.com/plier#:~:text=also%20ply%C2%B7er%20(pl%C4%AB%E2%80%B2,holding%2C%20bending%2C%20or%20cutting.)")  kelimelerine referans olarak verilmiştir). [**dplyr**](https://dplyr.tidyverse.org/) dplyr ,  tidyverse R paketi ailesinin bir parçasıdır. Bu aile ggplot2, tidyr, stringr, tibble, purrr, magrittr ve forcats  gibi birçok önemli paketi kapsar.  


Fonksiyon      | Kullanımı                             | Paket
---------------|---------------------------------------|------------------------------
` %>% `|“tünel” veriyi bir fonksiyondan diğerine geçirir.|**magrittr** 
`mutate()`|Sütunların oluşturulması, dönüştürülmesi, yeniden tanımlanması |**dplyr**  
`select()`|Sütunların veritabanında tutulması, silinmesi, yeniden adlandırılması |**dplyr**
`rename()`|Sütunların yeniden adlandırılması|**dplyr** 
`clean_names()`|Sütun isimlerinin sintaksının standardize edilmesi|**janitor**
`as.character()`, `as.numeric()`, `as.Date()`, etc.|Bir sütunun sınıfının değişimi |**base** R
`across()`|Birden çok sütunun aynı anda transforme edilmesi |**dplyr** 
**tidyselect** fonksiyonu |Mantık ile sütunların seçimi |**tidyselect**   
`filter()`|Belli sütunların tutulması |**dplyr** 
`distinct()`|Duplike sütunların uzaklaştırılması|**dplyr** 
`rowwise()`|Her satır için operasyon|**dplyr**  
`add_row()`|Elle satır ekleme|**tibble** 
`arrange()`|Satırların düzenlenmesi |**dplyr**
`recode()`|Sütundaki değerlerin yeniden kodlanması |**dplyr** 
`case_when()`|Sütundaki değerlerin daha kompleks mantık kriterleri ile yeniden kodlanması|**dplyr** 
`replace_na()`, `na_if()`, `coalesce()`|Yeniden kodlama için özel fonksiyonlar |**tidyr**  
`age_categories()` ve `cut()`|Sayısal değerler içeren bir sütundan kategorik gruplar oluşturma|**epikit** ve **base** R
`match_df()`|Veri sözlüğü kullanarak değerlerin yeniden kodlanması ve temizliği|**matchmaker**
`which()`|Mantık kriterlerinin uygulanması, endekslerin elde edilmesi |**base** R

Bu komutların Stata ya da SAS komutları ile karşılaştırılmasını görmek için R’a geçiş sayfasını inceleyin. 
Alternatif bir veri yönetim çerçevesi olarak data.table R paketi := gibi operatörler ve sıkça köşeli parantezler [ ] kullanır. Bu yaklaşım ve sintaksı kısaca Veri Tablosu sayfasında anlatılmıştır. 
 

### İsimlendirme {.unnumbered}  

Bu el kitabında, değişken ve gözlem yerine sütun ve satır terimleri kullanılacaktır. Tidy Data sayfasında anlatıldığı gibi epidemiyolojik istatistik veritabanları; satır, sütun  ve değerlerden oluşur.  ["tidy data"](https://tidyr.tidyverse.org/articles/tidy-data.html)

Değişkenler, aynı temel özelliği ölçen değerleri içerir (yaş grubu, sonuç veya başlangıç tarihi gibi). Gözlemler, aynı birimde ölçülen tüm değerleri içerir (örneğin, bir kişi, bir bölge veya laboratuvar numunesi). Dolayısıyla bu özellikleri somut olarak tanımlamak zor olabilir.

"Tidy" (düzenli) veritabanlarında her sütun bir değişken, her satır bir gözlem ve her hücre tek bir değerdir. Ancak karşılaştığınız bazı veritabanları bu kalıba uymaz - "geniş" formdaki veritabanlarının birkaç sütuna bölünebilen değişkenleri olabilir (Pivoting data sayfasındaki örneğe bakın). Benzer şekilde, gözlemler birkaç satıra bölünebilir.

Bu el kitabının büyük bölümü, verileri yönetmek ve dönüştürmekle ilgilidir, bu nedenle somut veri yapıları olan satır ve sütunlara atıfta bulunmak, daha soyut özellikteki gözlemler ve değişkenlerden daha önemlidir. Veri analizi sayfalarında istisna olarak değişkenlere ve gözlemlere daha fazla değinilecektir.  



<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Tünel hattını temizlemek  

**Bu sayfada tipik veri temizleme basamakları ve bu basamakların tünel hattına eklenmesi gözden geçirilecektir.** 

Epidemiyolojik analiz ve veri işlemede, temizleme adımları genellikle birbiri ile bağlantılı olarak sırayla gerçekleştirilir. R'da, bu genellikle ham veri kümesinin bir temizleme adımından diğerine geçirildiği veya "tünellandığı" bir temizleme "tünel hattı" olarak kendini gösterir. 

Bu tür zincirler, dplyr “eylem” fonksiyonları ve magrittr tünel operatörü %>%'yi kullanır. Bu kanal, "ham" verilerle ("linelist_raw.xlsx") başlar ve kullanılabilen, kaydedilebilen, dışa aktarılabilen vb. "temiz" bir R veri çerçevesi (linelist) ile biter.

Bir temizleme tünel hattında adımların sırası önemlidir. Temizleme adımları şunları içerebilir:
• Verilerin içe aktarılması
• Sütun adlarının temizlenmesi veya değiştirilmesi 
• Tekilleştirme (de-duplikasyon) 
• Sütun oluşturma ve dönüştürme (örn. değerleri yeniden kodlama veya standartlaştırma)
• Filtrelenen veya eklenen satırlar




<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Paketlerin yüklenmesi  

Bu kod kümesi, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gereken durumlarda paket kuran ve kullanım için yükleyen pacman'ın p_load() fonksiyonu vurgulanmaktadır. Alternatif olarak, base (temel) R'den library() komutu ile kurulu paketler yüklenebilir. R paketleri hakkında daha fazla bilgi için R’ın temelleri sayfasına bakın.

```{r, message = F}
pacman::p_load(
  rio,        # verileri içe aktarma
  here,       # göreli dosya yolları
  janitor,    # veri temizleme ve tablolar
  lubridate,  # tarihlerle çalışma
  epikit,     # age_categories() fonksiyonu
  tidyverse   # veri yönetimi ve görselleştirme
)

```




<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Verileri içe aktar  

### İçe aktarma {.unnumbered}  

Burada, rio paketinden import() fonksiyonunu kullanarak “ham” vaka satır listesi formundaki  Excel dosyasını içe aktarıyoruz. rio paketi birçok dosya türünü esnek bir şekilde işler (örn. .xlsx, .csv, .tsv, .rds. Satırları atlama, eksik değerleri ayarlama, Google sayfalarını içe aktarma gibi diğer durumlar hakkında daha fazla bilgi ve ipucu için İçe Aktarma ve Dışa Aktarma sayfasına bakın.  

Eşlik etmek isterseniz, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_raw.xlsx' class='download-button'>ham satır listesini indirmek için tıklayınız</a> (.xlsx dosyası olarak).  

Veri tabanınız büyükse ve içe aktarılması uzun sürüyorsa, içe aktarma komutunun tünel zincirinden ayrı olması ve ham verinin ayrı bir dosya olarak kaydedilmesi yararlı olabilir. Bu aynı zamanda orijinal ve temizlenmiş sürümler arasında kolay karşılaştırma sağlar.

Aşağıda, ham Excel dosyasını içe aktarıyoruz ve onu linelist_raw veri çerçevesi olarak kaydediyoruz. Dosyanın çalışma dizininizde veya R proje kök dizininde bulunduğunu ve bu nedenle dosya yolunda hiçbir alt klasör belirtilmediğini varsayıyoruz.

```{r, echo=F, message=F}

linelist_raw <- rio::import(here::here("data", "case_linelists", "linelist_raw.xlsx"))
```

```{r, eval=F}
linelist_raw <- import("linelist_raw.xlsx")
```

Aşağıda veri çerçevesinin ilk 50 satırını görüntüleyebilirsiniz. Not: temel R fonksiyonu head (n), R konsolundaki ilk n satırı görüntülemenize olanak tanır.


```{r message=FALSE, echo=F}
# satır listesi verilerini 
DT::datatable(head(linelist_raw,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```
### Gözden geçirme {.unnumbered}  

Tüm veri çerçevesine genel bir bakış elde etmek için skimr paketindeki skim() fonksiyonunu kullanabilirsiniz (daha fazla bilgi için Tanımlayıcı tablolar sayfasına bakın). Sütunlar karakter, sayısal gibi sınıflara göre özetlenir. Not: “POSIXct” bir tür ham tarih sınıfıdır (bkz. [Tarihlerle çalışma])  


```{r, eval=F}
skimr::skim(linelist_raw)
```

```{r, echo=F}
skimr::skim_without_charts(linelist_raw)
```




 





<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Sütun isimleri {} 
R'de sütun adları, bir sütunun "başlık" veya "üst" değeridir. Koddaki sütunlara atıfta bulunmak için kullanılırlar ve şekillerde varsayılan bir etiket görevi görürler.

SAS ve STATA gibi diğer istatistiksel yazılımlar, daha kısa sütun adlarının daha uzun basılı sürümleri olarak birlikte oldukları “etiketler” kullanır. R, verilere sütun etiketleri ekleme olanağı sunarken, uygulamada çoğu zaman bu vurgulanmamaktadır. Şekiller için sütun adlarını "yazıcı dostu" yapmak için, çıktı oluşturan çizim komutları içinde sütun adı gösterimleri uygun şekilde ayarlanabilir (Örneğin, bir grafiğin eksen veya gösterge (legend)  başlıkları veya basılı bir tablodaki sütun başlıkları – [ggplot için ipuçları ölçekler bölümü](#ggplot_tips_scales) ve [sunum sayfaları için tablolar] sayfalarına bakabilirsiniz). Veride sütun etiketleri atamak istiyorsanız,[buradan] (https://cran.r-project.org/web/packages/expss/vignettes/labels-support.html) ve [buradan](https://cran.r-project.org/web/packages/labelled/vignettes/intro_labelled.html) çevrimiçi olarak daha fazlasını okuyabilirsiniz.

R sütun adları çok sık kullanıldığından, "temiz" sintaksa sahip olmalıdır. Aşağıdakileri öneriyoruz:

•	Kısa isimler 
•	Boşluk kullanmayın (bunun yerine alt çizgi _  kullanın  ) 
•	Beklenmedik karakter kullanmayın (&, #, <, >, …)
•	Benzer stilde adlandırmalar  (örneğin tüm tarih sütunları tarih_başlangıç, tarih_rapor, tarih_ölüm… gibi aynı tarzda adlandırılmalı) 

linelist_raw sütun adları, aşağıda temel R names() fonksiyonunu kullanılarak yazdırılır. Başlangıçta şunu görebiliriz:
•	Bazı isimler boşluk içerir (e.g. infection date)
•	Tarihler için farklı adlandırma kalıpları kullanılmıştır (date onset vs. infection date)
•	.xlsx dosyasındaki son iki sütunda birleştirilmiş bir başlık bulunmalıdır. Bunu biliyoruz, çünkü birleştirilmiş iki sütunun adı (“merged_header”) R tarafından ilk sütuna atanmıştır ve ikinci sütuna “…28” yer tutucu adı atanmıştır (boş olan 28. sütun).

```{r}
names(linelist_raw)
```

<span style="color: black;">**_NOT:_** Boşluk içeren bir sütun adı için, adı ters tik işaretleriyle çevreleyin, örneğin: linelist$` \x60infection date\x60`. `.` Klavyenizdeki geri tik işaretinin (`) tek tırnak işaretinden (') farklı olduğunu unutmayın..</span>


### Etiketler {.unnumbered}  

SAS gibi bazı diğer istatistiksel yazılımların değişken *etiketleri* vardır.

### Otomatik Temizleme {.unnumbered}  

janitor paketindeki clean_names() fonksiyonu, sütun adlarını standartlaştırır ve aşağıdakileri yaparak bunları benzersiz kılar:
• Tüm adları yalnızca alt çizgi, sayı ve harflerden oluşacak şekilde dönüştürür
• Vurgulu karakterler ASCII'ye dönüştürülür (örneğin, ö "o" olur, İspanyolca "enye" "n" olur)
• Yeni sütun adları için büyük harf kullanımı tercihi case = argümanı kullanılarak belirtilebilir (“snake” varsayılandır, alternatifler arasında “sentence” (cümle) , “title” (başlık) , “small_camel”… bulunur)
• İşte bir çevrimiçi [gösterim](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html#cleaning)  

Aşağıda, temizleme tünel hattı, ham satır listesinde `clean_names()` kullanılarak başlar.

```{r clean_names}
# ham veri kümesini clean_names() fonksiyonu aracılığıyla aktarın, sonucu "linelist" olarak atayın
linelist <- linelist_raw %>% 
  janitor::clean_names()

# yeni sütun adlarını görün
names(linelist)
```

<span style="color: black;">**_NOT:_** Son sütun adı “…28” “x28” olarak değiştirilmiştir.</span>


### Manuel isim temizliği  {.unnumbered}  
Sütunları manuel olarak yeniden adlandırmak, yukarıdaki standardizasyon adımından sonra bile genellikle gereklidir. Aşağıda, bir tünel zincirinin parçası olarak dplyr paketindeki rename() fonksiyonu kullanılarak yeniden adlandırma gerçekleştirilir. rename() YENİ = ESKİ stilini kullanır - yeni sütun adı eski sütun adından önce verilir.

Aşağıda, temizleme hattına bir yeniden adlandırma komutu eklenmiştir. Kodu daha kolay okumak için hizalama amacıyla boşluklar eklenmiştir. 

```{r}
# TEMİZLİK 'TÜNEL' ZİNCİRİ (ham verilerle başlar ve temizleme adımları boyunca iletir)
##################################################################################
linelist <- linelist_raw %>%
    
    # sütun adı sintaksını standartlaştırın
    janitor::clean_names() %>% 
    
    # sütunları manuel olarak yeniden adlandır
           # YENİ isim             # ESKİ isim
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome)
```


Artık sütun adlarının değiştirildiğini görebilirsiniz:

```{r message=FALSE, echo=F}
names(linelist)
```


#### Sütun konumuna göre yeniden adlandırma {.unnumbered} 

Sütun adı yerine sütun konumuna göre de yeniden adlandırabilirsiniz, örneğin:

```{r, eval=F}
rename(newNameForFirstColumn  = 1,
       newNameForSecondColumn = 2)
```



#### `select()` ve `summarise()`  ile yeniden adlandırma  {.unnumbered}  

Kısa yol olarak, dplyr select() ve summarise() fonksiyonları ile sütunları yeniden adlandırabilirsiniz. select() yalnızca belirli sütunları tutmak için kullanılır (ve bu sayfanın ilerleyen kısımlarında ele alınacaktır). summarise(),[Verilerin gruplanması] ve [Tanımlayıcı tablolar] sayfalarında ele alınmıştır. Bu fonksiyonlar da yeni_adı = eski_adı biçimini kullanır. İşte bir örnek: 

```{r, eval=F}
linelist_raw %>% 
  select(# YENİ isim             # ESKİ isim
         date_infection       = `infection date`,    # yeniden adlandır ve SADECE BU KOLONLARI TUT.
         date_hospitalisation = `hosp date`)
```





### Diğer sorunlar {.unnumbered}  


#### Boş excel sütun isimleri {.unnumbered} 

R, sütun adları (başlıklar) olmayan veri kümesi sütunlarına izin vermez. Bu nedenle, veriler içeren ancak sütun başlıkları olmayan bir Excel veri kümesini içe aktarırsanız, başlıklar “…1” veya “…2” gibi adlarla doldurulacaktır. Sayı, sütun numarasını temsil eder (örneğin, veri kümesindeki 4. sütunun başlığı yoksa, R buna “…4” adını verir).

Bu adları, konum numaralarına (yukarıdaki örneğe bakın) veya atanmış adlarına (linelist_raw$...1) başvurarak manuel olarak temizleyebilirsiniz.




#### Birleştirilmiş Excel sütun adları ve hücreleri {.unnumbered}  

Bir Excel dosyasındaki birleştirilmiş hücreler, veri alırken sık karşılaşılan bir durumdur. R'a Geçiş bölümünde açıklandığı gibi, birleştirilmiş hücreler verinin insan tarafından okunması için iyi olabilir, ancak "düzenli-tidy veri" değildir ve verilerin makine tarafından okunması için birçok soruna neden olur. R, birleştirilmiş hücreleri barındıramaz.

Veri girişi yapan kişilere, insan tarafından okunabilen verilerin makine tarafından okunabilen verilerle aynı olmadığını hatırlatın. Kullanıcıları düzenli veri [**tidy data**](https://r4ds.had.co.nz/tidy-data.html) ilkeleri konusunda eğitmeye çalışın. Mümkünse, verilerin birleştirilmiş hücreler olmadan düzenli bir biçimde aktarımı için prosedürleri değiştirmeye çalışın.

• Her değişkenin kendi sütunu olmalıdır.
• Her gözlemin kendi satırı olmalıdır.
• Her değerin kendi hücresi olmalıdır.

rio'nun import() fonksiyonunu kullanırken, birleştirilmiş hücredeki değer ilk hücreye atanacak ve sonraki hücreler boş kalacaktır.

Birleştirilmiş hücrelerle başa çıkmak için bir çözüm, verileri openxlsx paketinden readWorkbook() fonksiyonuyla içe aktarmaktır. `fillMergedCells = TRUE` değişkeni ayarlanmalıdır. Bu, birleştirilmiş hücredeki değeri, birleştirme aralığındaki tüm hücrelere verir.


```{r, eval=F}
linelist_raw <- openxlsx::readWorkbook("linelist_raw.xlsx", fillMergedCells = TRUE)
```

<span style="color: red;">**_TEHLİKE:_** Sütun adları `readWorkbook()` ile birleştirilirse, el ile düzeltmeniz gereken yinelenen sütun adları elde edersiniz - R, tekrarlayan sütun adlarıyla iyi çalışmaz! Manuel sütun adı temizleme bölümünde açıklandığı gibi, sütunların konumlarına atıfta bulunarak (örneğin sütun 5) sütunları yeniden adlandırabilirsiniz.</span>






<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Sütunların seçimi ve yeniden düzenlenmesi  {} 

Tutmak istediğiniz sütunları seçmek ve veri çerçevesindeki sıralarını belirtmek için dplyr'dan select()'i kullanın.

<span style="color: orange;">**_UYARI:_** Aşağıdaki örneklerde, satır listesi veri çerçevesi select() ile değiştirilip görüntülenmektedir, ancak kaydedilmemektedir. Bu örnek gösterim amaçlıdır. Değiştirilen sütun adları, veri çerçevesinin names () fonksiyonuna bağlanmasıyla yazdırılır.</span>

**Temizleme tünel hattının bu noktasında satır listesindeki TÜM sütun adları şunlardır:**

```{r}
names(linelist)
```

### Sütunları koru {.unnumbered}  

**Yalnızca kalmasını istediğiniz sütunları seçin**  

Sütun adlarını tırnak işareti olmadan select() komutuna koyun. Sütunlar veri çerçevesinde istediğiniz sırayla görünürler. Var olmayan bir sütun eklerseniz, R'nin hata vereceğini unutmayın (bu durumda herhangi bir hata istemiyorsanız, aşağıdaki `any_of()` kullanımına bakın).

```{r}
# linelist veri tabanı, select() komutu aracılığıyla iletilir ve name() yalnızca sütun adlarını yazdırır
linelist %>% 
  select(case_id, date_onset, date_hospitalisation, fever) %>% 
  names()  # sütun isimlerini göster
```


### “tidyselect” yardımcı fonksiyonları {#clean_tidyselect .unnumbered}  

Bu yardımcı fonksiyonlar, tutulacak, atılacak veya dönüştürülecek sütunları belirlemeyi kolaylaştırmak için oluşturulmuştur. Bu fonksiyonlar, tidyverse'de bulunan ve dplyr fonksiyonlarında sütunların nasıl seçildiğinin gösteren tidyselect paketindendir.

Örneğin, sütunları yeniden sıralamak istiyorsanız, everything() “henüz belirtilmeyen tüm sütunları” göstermek için kullanışlı bir fonksiyondur. Aşağıdaki komutlar, date_onset ve date_hospitalisation sütunlarını veritabanının başına (soluna) taşır, ancak diğer tüm sütunları tutar. everything()'in boş parantezlerle yazıldığını unutmayın:


```{r}
# date_onset ve date_hospitalisation'ı başlangıca taşıyın
linelist %>% 
  select(date_onset, date_hospitalisation, everything()) %>% 
  names()
```

Burada dplyr fonksiyonları içinde çalışan select(), across() ve summarise() gibi diğer "tidyselect" yardımcı fonksiyonları yer almaktadır: 

* `everything()`  - belirtilmemiş tüm diğer sütunlar  
* `last_col()`    - son sütun 
* `where()`       - tüm sütunlara bir fonksiyon uygular ve DOĞRU (TRUE) olanları seçer  
* `contains()`    - karakter dizisi (string) içeren sütunlar
  * örnek: `select(contains("time"))`  
* `starts_with()` - belirli bir ön-ekle eşleşme
  * örnek: `select(starts_with("date_"))`  
* `ends_with()`   - - belirli bir son-ekle eşleşme
  * örnek: `select(ends_with("_post"))`  
* `matches()`     - normal bir ifadenin (regex) uygulanması için
  * örnek: `select(matches("[pt]al"))`  
* `num_range()`   - sayısal aralık x01, x02, x03 gibi 
* `any_of()`      - IF sütunuyla eşleşir ancak bulunamazsa hata vermez  
  * örnek: `select(any_of(date_onset, date_death, cardiac_arrest))`  

Ek olarak, birkaç sütunun listelenmesi için c() gibi normal operatörler kullanılır, : ardışık sütunlar için, ! zıtlar için, & AND (VE) için , | OR (YA DA) için kullanılır. 


Sütunlar için mantıksal kriterler belirtmek için where() kullanın. where() içinde bir fonksiyon kullanıyorsanız, fonksiyonun boş parantezlerini dahil etmeyin. Aşağıdaki komut, sayısal özellikteki sütunları seçer.

```{r}
# Sayısal sınıfı olan sütunları seçin
linelist %>% 
  select(where(is.numeric)) %>% 
  names()
```

Yalnızca sütun adının belirtilen bir karakter dizesini (string) içeren sütunları seçmek için include() kullanın. end_with() ve start_with() daha fazla detay sağlar.  

```{r}
# belirli karakterleri içeren sütunları seçin
linelist %>% 
  select(contains("date")) %>% 
  names()
```

Match() fonksiyonu, include() fonksiyonuna benzer şekilde çalışır, ancak bu fonksiyon ile parantez içinde OR (VEYA) çubuklarıyla (|) ayrılmış birden çok dize (string) gibi bir normal ifadeler sağlanabilir. (Karakterler ve dizeler sayfasına bakın):  

```{r}
# birden fazla karakter eşleşmesi arandı
linelist %>% 
  select(matches("onset|hosp|fev")) %>%   # VEYA sembolüne dikkat edin "|"
  names()
```

<span style="color: orange;">**_UYARI:_** Verdiğiniz sütun adlarından biri verilerde yoksa, R hata verebilir ve kodunuzu durdurabilir. Özellikle negatif seçimlerde (kaldır), var olan (ya da olmayan) sütunları seçmek için any_of() kullanmak faydalıdır.</span>

Bu sütunlardan yalnızca biri var, ancak herhangi bir hata üretilmiyor ve kod, temizleme zincirinizi durdurmadan devam ediyor.  

```{r}
linelist %>% 
  select(any_of(c("date_onset", "village_origin", "village_detection", "village_residence", "village_travel"))) %>% 
  names()
```



### Sütunları kaldır {.unnumbered} 

Sütun adının önüne bir eksi “-” sembolü (örn. select(-outcome)) veya sütun adları vektörü (aşağıdaki gibi) belirterek hangi sütunların kaldırılacağını belirtin. Diğer tüm sütunlar korunacaktır. 

```{r}
linelist %>% 
  select(-c(date_onset, fever:vomit)) %>% # date_onset ve tüm sütunları ateşten kusmaya kadar kaldırın
  names()
```

Bir sütunu R **tabanı** sözdizimini kullanarak, onu 'NULL' olarak tanımlayarak da kaldırabilirsiniz. Örneğin:

```{r, eval=F}
linelist$date_onset <- NULL   # R tabanı sözdizimine sahip sütunu siler
```



### Bağımsız (Standalone) {.unnumbered}

select() tüneldan bağımsız bağımsız bir komut olarak da kullanılabilir. Bu durumda, ilk argüman, üzerinde çalışılacak orijinal veri çerçevesidir.

```{r}
# id ve yaşla ilgili sütunlarla yeni bir satır listesi oluşturun
linelist_age <- select(linelist, case_id, contains("age"))

# Sütun adlarını göster
names(linelist_age)
```



#### Tünel zincirine ekleme  {.unnumbered}  

linelist_raw'da ihtiyacımız olmayan birkaç sütun var: row_num, merged_header ve x28. Bunları temizleme tünel zincirinde bir select() komutuyla kaldırıyoruz:

```{r}
# TEMİZLİK 'BORU' ZİNCİRİ (ham verilerle başlar ve temizleme adımları boyunca iletir)
##################################################################################

# tünel zincirini temizlemeye başla
###########################
linelist <- linelist_raw %>%
    
    # sütun adı sintaksını standartlaştır
    janitor::clean_names() %>% 
    
    # sütunları manuel olarak yeniden adlandır
           # YENİ isim           # ESKİ isim
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # YUKARIDAKİ TEMİZLİK ADIMLARI ZATEN TARTIŞILMIŞTIR
    #####################################################

    # satırı sil
    select(-c(row_num, merged_header, x28))
```




<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Tekilleştirme 


Verilerin tekilleştirilmesinin nasıl yapılacağına ilişkin kapsamlı seçenekler için  el kitabı Tekilleştirme sayfasına bakın. Burada yalnızca çok basit bir satır tekilleştirme örneği sunulmuştur.

dplyr paketi, distinct() fonksiyonunu içerir. Bu fonksiyon, her satırı inceler ve veri çerçevesini yalnızca benzersiz satırlara indirger. Yani %100 tekrarlayan satırları kaldırır.

Yinelenen satırları değerlendirirken, bir dizi sütun dikkate alınır (varsayılan ayar olarak tüm sütunlar dikkate alınır). Tekilleştirme sayfasında gösterildiği gibi, sütun aralığı, yalnızca belirli sütunlara göre satır benzersizliği değerlendirilecek şekilde ayarlanabilir. 

Bu basit örnekte, tünel zincirine sadece distinct () boş komutunu ekliyoruz. Bu, diğer satırların %100 kopyası olan hiçbir satır olmamasını sağlar (burada tüm sütunlarda değerlendirilir).

Linelist'te nrow(linelist) satırları ile başlıyoruz. 

```{r}
linelist <- linelist %>% 
  distinct()
```

Tekilleştirmeden sonra nrow(linelist) satırları kalır. Kaldırılan herhangi bir satır, diğer satırların %100 kopyasıdır. 

Aşağıda, temizleme tünel zincirine distinct() komutu eklenir:


```{r}
# TEMİZLİK 'BORU' ZİNCİRİ (ham verilerle başlar ve temizleme adımları boyunca iletir)
##################################################################################

# tünel zincirini temizlemeye başla
###########################
linelist <- linelist_raw %>%
    
    # sütun adı sintaksını standartlaştır
    janitor::clean_names() %>% 
    
    # sütunları manuel olarak yeniden adlandır
           # YENİ isim           # ESKİ isim
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # sütunu sil
    select(-c(row_num, merged_header, x28)) %>% 
  
    # YUKARIDAKİ TEMİZLİK ADIMLARI ZATEN TARTIŞILMIŞTIR
    #####################################################
    
    # tekilleştirme
    distinct()
```





<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Sütun oluşturma ve dönüştürme  { }


**Yeni bir sütun eklemek veya mevcut bir sütunu değiştirmek için dplyr mutate() fonksiyonunu kullanmanızı öneririz.**  

Aşağıda, mutate() ile yeni bir sütun oluşturmaya bir örnek verilmiştir. Sintaksı: mutate(new_column_name = value or transformation)

Bu Stata'da, generate komutuna benzer, ancak R'ın mutate() fonksiyonu de mevcut bir sütunu değiştirmek için kullanılabilir.



### Yeni sütunlar {.unnumbered}

Yeni bir sütun oluşturmak için en temel mutate() komutu aşağıdaki gibdir görünebilir. Her satırdaki değerin 10 olduğu yeni bir new_col sütunu oluşturur.

```{r, eval=F}
linelist <- linelist %>% 
  mutate(new_col = 10)
```

Hesaplamalar için diğer sütunlardaki değerlere de başvurabilirsiniz. Aşağıda, her vaka için Vücut Kitle İndeksi'ni (VKİ) hesaplamak için yeni bir BMI sütunu oluşturulmuştur - VKİ = kg/m^2 formülü kullanılarak, ht_cm sütunu ve wt_kg sütunu kullanılarak hesaplanmıştır.

```{r}
linelist <- linelist %>% 
  mutate(bmi = wt_kg / (ht_cm/100)^2)
```

Birden çok yeni sütun oluşturuyorsanız, her birini bir virgül ve yeni bir satırla ayırın. Aşağıda, stringr paketinden str_glue() kullanılarak birleştirilen diğer sütunlardan gelen değerlerden oluşanlar da dahil olmak üzere yeni sütun örnekleri verilmiştir (Karakterler ve dizeler sayfasına bakın.)

```{r}
new_col_demo <- linelist %>%                       
  mutate(
    new_var_dup    = case_id,             # yeni sütun = mevcut başka bir sütunu çoğalt/kopyala
    new_var_static = 7,                   # yeni sütun = tüm değerler aynı
    new_var_static = new_var_static + 5,  # bir sütunun üzerine yazabilirsiniz ve bu, diğer değişkenleri kullanan bir hesaplama olabilir
    new_var_paste  = stringr::str_glue("{hospital} on ({date_hospitalisation})") # yeni sütun = diğer sütunlardaki değerleri birbirine yapıştırma
    ) %>% 
  select(case_id, hospital, date_hospitalisation, contains("new"))        # tanıtım amacıyla yalnızca yeni sütunları göster
```


Yeni sütunları inceleyin. Gösterim amacıyla, yalnızca yeni sütunlar ve bunları oluşturmak için kullanılan sütunlar sunulmuştur. 


```{r message=FALSE, echo=F}
# satır listesi tablosunu göster
DT::datatable(head(new_col_demo,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

<span style="color: darkgreen;">**_İPUCU:_** : mutate() üzerindeki varyasyonlar için transmute() fonksiyonu kullanılır. Bu fonksiyon, mutate() gibi yeni bir sütun ekler, ancak parantez içinde bahsetmediğiniz diğer tüm sütunları da bırakır/kaldırır.</span>


```{r, eval=F}
# yukarıda oluşturulan yeni demo sütunlarını kaldırır
# linelist <- linelist %>% 
#   select(-contains("new_var"))
```



### Sütun sınıfının dönüşümü  {.unnumbered}
  
Tarihler, sayılar veya mantıksal değerler (DOĞRU/YANLIŞ) içeren sütunlar, yalnızca doğru şekilde sınıflandırıldıklarında beklendiği gibi davranacaktır. Sınıf tipi "2" ile sayısal 2 arasında fark vardır!

İçe aktarma komutları sırasında sütun sınıfını ayarlamanın yolları vardır, ancak bu genellikle zahmetlidir. 
Nesnelerin ve sütunların sınıfını dönüştürme hakkında daha fazla bilgi edinmek için nesne sınıflarıyla ilgili R Temelleri bölümüne bakın.

İlk olarak, önemli sütunların doğru sınıf olup olmadıklarını görmek için bazı kontroller yapalım. Bunu başlangıçta skim() komutunu çalıştırdığımızda da görmüştük. 

Şu anda, yaş sütununun sınıfı karakterdir. Nicel analizler yapmak için bu sayıların sayısal olarak tanınmasına ihtiyacımız var!


```{r}
class(linelist$age)
```

date_onset sütununun sınıfı da karakterdir! Analiz yapabilmek için bu tarihlerin tarih olarak kabul edilmesi gerekir! 
```{r}
class(linelist$date_onset)
```

Bunu çözmek için, dönüştürülmüş bir sütunu yeniden tanımlamak için mutate() fonksiyonunu kullanın. Sütunu kendisi olarak tanımlıyoruz, ancak farklı bir sınıfa dönüştürüyoruz. age sütununun sayısal sınıfta olmasını sağlayan veya dönüştüren temel bir örnek:

```{r, eval=F}
linelist <- linelist %>% 
  mutate(age = as.numeric(age))
```

Benzer şekilde, as.character() ve as.logical() kullanabilirsiniz. Faktör sınıfına dönüştürmek için, temel R'den factor() veya forcats'tan as_factor() kullanabilirsiniz. Faktörler sayfasında bu konuyla ilgili daha fazla bilgi edinebilirsiniz. 

Tarih  sınıfına geçerken dikkatli olmalısınız. Tarihlerle çalışma sayfasında çeşitli yöntemler açıklanmıştır. Tipik olarak, dönüştürmenin doğru çalışması için ham tarih değerlerinin tümü aynı biçimde olmalıdır (ör. "AA/GG/YYYY" veya "GG AA YYYY"). Tarih sınıfına dönüştürdükten sonra, her bir değerin doğru şekilde dönüştürüldüğünü doğrulamak için verilerinizi kontrol edin.




### Gruplandırılmış veri  {.unnumbered}  

Veri çerçeveniz zaten gruplanmışsa (verileri gruplama ile ilgili sayfaya bakın), mutate() veri çerçevesinin gruplanmamasındaki gruba göre farklı davranabilir. Ortalama(), medyan(), max(), vb. gibi herhangi bir özetleme fonksiyonu, tüm satırlara göre değil, gruba göre hesaplayacaktır.     

```{r, eval=F}
# TÜM satırların ortalamasına göre normalleştirilmiş yaş
linelist %>% 
  mutate(age_norm = age / mean(age, na.rm=T))

# hastane grubunun ortalamasına göre normalize edilmiş yaş
linelist %>% 
  group_by(hospital) %>% 
  mutate(age_norm = age / mean(age, na.rm=T))
```

Tidyverse mutate belgelerinden gruplanmış veri çerçevelerinde mutate () kullanma hakkında daha fazla bilgi edinebilirsiniz. [tidyverse mutate dökümanları](https://dplyr.tidyverse.org/reference/mutate.html).  



### Birden çok sütunu dönüştürün {#clean_across .unnumbered}


Genellikle kısa bir kod ile aynı dönüşümü birden çok sütuna aynı anda uygulamak amaçlanır. dplyr paketindeki (ayrıca tidyverse paketinde de bulunur) across() fonksiyonu kullanılarak aynı anda birden çok sütuna bir dönüşüm uygulanabilir. across() herhangi bir dplyr fonksiyonuyla kullanılabilir, ancak genellikle select(), mutate(), filter() veya summarise() içinde kullanılır. [Tanımlayıcı tablolar] sayfasındaki summarise() fonksiyonuna nasıl uygulandığını inceleyin.  

.cols =  argümanına sütunlar ve .fns =  argümanına uygulanacak fonksiyonlar atanır. .fns fonksiyonuna sağlanacak herhangi bir argüman, yine across() içinde olmak üzere virgülden sonra dahil edilebilir.

#### `across()` sütun seçimi {.unnumbered}  

.cols =  argümanı ile sütunlarını seçin. Bunları tek tek adlandırabilir veya "tidyselect" yardımcı fonksiyonlarını kullanabilirsiniz. Fonksiyonu .fns = ile belirtin. Aşağıda gösterilen fonksiyon modunu kullanarak, fonksiyonun parantez ( ) olmadan yazıldığını unutmayın.

Burada as.character() dönüşümü, across() içinde tanımlanmış belirli sütunlara uygulanır.
 

```{r, eval=F}
linelist <- linelist %>% 
  mutate(across(.cols = c(temp, ht_cm, wt_kg), .fns = as.character))
```

Sütunları belirlemede size yardımcı olmak için "tidyselect" yardımcı fonksiyonları mevcuttur. Yukarıda Sütunları seçme ve yeniden sıralama bölümünde ayrıntılı olarak açıklanmıştır ve şu komutları içerir:
everything(), last_col(), where(), starts_with(), ends_with(), contains(), matches(), num_range() ve any_of().
 
Tüm sütunların karakter sınıfına nasıl değiştirileceğine dair bir örnek:
 

```{r, eval=F}
#tüm sütunları karakter sınıfına değiştirmek için
linelist <- linelist %>% 
  mutate(across(.cols = everything(), .fns = as.character))
```

Adın "tarih" dizesini içerdiği tüm sütunları karaktere dönüştürün (virgül ve parantezlerin yerleşimine dikkat edin 

```{r, eval=F}
#tüm sütunları karakter sınıfına değiştirmek için
linelist <- linelist %>% 
  mutate(across(.cols = contains("date"), .fns = as.character))
```

Aşağıda, POSIXct sınıfı (zaman damgalarını gösteren ham bir tarihzaman sınıfı) olan sütunları değiştirmenin bir örneği. Başka bir deyişle, burada fonksiyon is.POSIXct() DOĞRU olarak değerlendirilir. Daha sonra, bu sütunları normal bir Date sınıfına dönüştürmek için bu sütunlara as.Date() fonksiyonu uygulanır.  

```{r, eval=F}
linelist <- linelist %>% 
  mutate(across(.cols = where(is.POSIXct), .fns = as.Date))
```

•	Across() içinde, is.POSIXct'in DOĞRU veya YANLIŞ olarak değerlendirdiği where() fonksiyonunu da kullandığımızı unutmayın.
• is.POSIXct() komutunun lubridate paketinden olduğunu unutmayın. is.character(), is.numeric() ve is.logical() gibi diğer benzer "is" fonksiyonları **R tabanı**’ndadır.


#### `across()` fonksiyonları {.unnumbered}

across() fonksiyonlarına ilişkin ayrıntılar için ?across ile ilgili belgeleri okuyabilirsiniz. Birkaç özet nokta: Bir sütunda gerçekleştirilecek fonksiyonları belirtmenin birkaç yolu vardır ve hatta kendi fonksiyonlarınızı tanımlayabilirsiniz:
•	Yalnızca fonksiyon adını sağlayabilirsiniz (örneğin, mean veya as.character)
•	Fonksiyonu purr stilinde yazabilirsinizi (örneğin ~ mean(.x, na.rm = TRUE)) ([bu sayfaya bakabilirsiniz][Iteration, loops, and lists])  
* •	Bir liste ile çoklu fonksiyonlar belirlenebilir  (örneğin list(mean = mean, n_miss = ~ sum(is.na(.x))). 
•	Birden çok fonkisyon yazarsanız, giriş sütunu başına farklı adlarla col_fn biçiminde birden çok dönüştürülmüş sütun oluşturulur. Yeni sütunların .names = argümanıyla nasıl adlandırılacağını, {.col} ve {.fn}'nin giriş sütunu ve fonksiyonu için kısayol olduğu tutkal sintaksının  [Karakterler ve dizeler] sayfasına bakınız) kullanarak ayarlayabilirsiniz.

  
  
Burada across()kullanımı için online kaynaklar yer almakta: [yaratıcı Hadley Wickham'ın düşünceleri](https://www.tidyverse.org/blog/2020/04/dplyr-1-0-0-colwise/)




### `coalesce()` {.unnumbered}  

Bu dplyr fonksiyonu, her konumda eksik olmayan ilk değeri bulur. Eksik değerleri, belirttiğiniz sırayla ilk kullanılabilir değerle "doldurur".

İşte bir veri çerçevesi bağlamı dışında bir örnek: Diyelim ki, biri hastanın tespit edildiği köyü ve diğeri hastanın ikamet ettiği köyü içeren iki vektörünüz var. Her dizin için eksik olmayan ilk değeri seçmek için birleştirmeyi kullanabilirsiniz:


```{r}
village_detection <- c("a", "b", NA,  NA)
village_residence <- c("a", "c", "a", "d")

village <- coalesce(village_detection, village_residence)
village    # yazdır
```

Bu fonksiyon, veri çerçevesi sütunlarıyla da aynı şekilde çalışır: her satır için fonksiyon, belirtilen sütunlarda (sırayla) ilk eksik olmayan değerle yeni sütun değerini atar. 

```{r, eval=F}
linelist <- linelist %>% 
  mutate(village = coalesce(village_detection, village_residence))
```

Bu, "satır bazında" bir işlem örneğidir. Daha karmaşık satır bazında hesaplamalar için aşağıdaki satır bazında hesaplamalar bölümüne bakın.  



### Kümülatif Matematik {.unnumbered}

Bir sütunun, bir veri çerçevesinin satırlarında o noktaya kadar değerlendirildiği kümülatif toplamı/ortalama/min/maks vb. yansıtmasını istiyorsanız, aşağıdaki fonksiyonları kullanın:

cumsum() aşağıda gösterildiği gibi kümülatif toplamı verir:


```{r}
sum(c(2,4,15,10))     # sadece bir sayı verir
cumsum(c(2,4,15,10))  # her basamaktaki kümülatif toplamı verir
```

Bu, veri çerçevesinde yeni bir sütun oluştururken de  kullanılabilir. Örneğin, bir salgında günlük kümülatif vaka sayısını hesaplamak için şöyle bir kod düşünün:

```{r, warning=F, message=F}
cumulative_case_counts <- linelist %>%  # linelist ile başlayan vakalar
  count(date_onset) %>%                 # 'n' sütunu olarak günlük satır sayısı   
  mutate(cumulative_cases = cumsum(n))  # her satırdaki kümülatif toplamın yeni sütunu
```

Aşağıda ilk 10 satır görülmektedir: 

```{r}
head(cumulative_case_counts, 10)
```

Epikurve ile kümülatif insidansın nasıl çizileceğini öğrenmek için [Epidemik eğriler] sayfasına bakın.

Bunlara da bakın:
`cumsum()`, `cummean()`, `cummin()`, `cummax()`, `cumany()`, `cumall()`






### R **Tabanı** kullanımı {.unnumbered}  

Temel R’I (R Tabanı) kullanarak yeni bir sütun tanımlamak (veya bir sütunu yeniden tanımlamak) için, $ ile bağlantılı veri çerçevesinin adını yeni sütuna (veya değiştirilecek sütuna) yazın. Yeni değer(ler)i tanımlamak için <- atama operatörünü kullanın. Temel R'I kullanırken, her seferinde sütun adından önce veri çerçevesi adını belirtmeniz gerektiğini unutmayın (örn. dataframe$column). Aşağıda, temel R kullanarak bmi sütunu oluşturmaya bir örnek verilmiştir:  

```{r, eval=F}
linelist$bmi = linelist$wt_kg / (linelist$ht_cm / 100) ^ 2)
```




### Tünel zincirine ekleme yapma {.unnumbered}  

**Aşağıda, tünel zincirine yeni bir sütun eklenir ve bazı sınıflar dönüştürülür.**  

```{r }
# TEMİZLİK 'BORU' ZİNCİRİ (ham verilerle başlar ve temizleme adımları boyunca iletir)
##################################################################################

# tünel zincirini temizlemeye başlayın
###########################
linelist <- linelist_raw %>%
    
    # sütun adı sintaksını standartlaştır
    janitor::clean_names() %>% 
    
    # sütunları manuel olarak yeniden adlandır
           # YENİ isim             # ESKİ isim
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # sütunu sil
    select(-c(row_num, merged_header, x28)) %>% 
  
    # tekilleştir
    distinct() %>% 
  
    # YUKARIDAKİ TEMİZLİK ADIMLARI ZATEN TARTIŞILMIŞTIR
    ###################################################
    # yeni bir sütun ekle
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>% 
  
    # sütun sınıfını değiştir
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) 
```





## Değerlerin yeniden kodlanması  

Değerleri yeniden kodlamanız (değiştirmeniz) gereken birkaç senaryo:

• Belirli bir değeri düzenlemek için (örneğin, yanlış bir yıl veya biçime sahip bir tarih)
• Aynı şekilde yazılmayan değerleri uzlaştırmak için
• Yeni bir kategorik değerler sütunu oluşturmak için
• yeni bir sayısal kategori sütunu oluşturmak için (ör. Yaş kategorileri)



### Spesifik değerler  {.unnumbered}  

Değerleri manuel olarak değiştirmek için mutate() fonksiyonu içindeki recode() fonksiyonunu kullanabilirsiniz.
Verilerde uygun olmayan bir tarih olduğunu düşünün (örneğin “2014-14-15”): tarihi ham kaynak verilerde manuel olarak düzeltebilir veya değişikliği mutate() ve recode( aracılığıyla temizleme hattına yazabilirsiniz. ). 

İkincisi daha şeffaftır ve analizinizi anlamak veya tekrarlamak isteyen herkes için tekrarlanabilir.
 

```{r, eval=F}
 
# hatalı değerleri düzelt                   # eski değer       # yeni değer
linelist <- linelist %>% 
  mutate(date_onset = recode(date_onset, "2014-14-15" = "2014-04-15"))
```

Yukarıdaki mutate() satırı şu şekilde okunabilir: date_onset sütununu, yeniden kodlanan date_onset sütununa eşit olacak şekilde değiştirin, böylece ESKİ DEĞER YENİ DEĞER olarak değiştirilir". recode() için bu kalıbın (ESKİ = YENİ) diğer R kalıplarının çoğunun (yeni = eski) tersi olduğuna dikkat edin. R geliştirme topluluğu bunu gözden geçirmek için çalışmaktadır.  

**İşte bir sütun içinde birden çok değeri yeniden kodlayan başka bir örnek.** 

Linelist'te “hospital” sütunundaki değerler temizlenmelidir. Birkaç farklı yazım ve birçok eksik değer var.

```{r}
table(linelist$hospital, useNA = "always")  # eksik olanlar dahil tüm benzersiz değerlerin tablosunu yazdır
```

Aşağıdaki recode() komutu, "hastane" sütununu belirtilen yeniden kodlama değişiklikleriyle geçerli "hastane" sütunu olarak yeniden tanımlar. Her birinden sonra virgül koymayı unutmayın!

```{r}
linelist <- linelist %>% 
  mutate(hospital = recode(hospital,
                     # kaynak için: ESKİ = YENİ
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      ))
```


Şimdi hospital sütunundaki yazımların düzeltildiğini ve birleştiğini görüyoruz: 

```{r}
table(linelist$hospital, useNA = "always")
```

<span style="color: darkgreen;">**_İPUCU:_** Eşittir işaretinden önceki ve sonraki boşluk sayısı önemli değildir. Satırlar için = işaretini hizalayarak kodunuzun okunmasını kolaylaştırın. Ayrıca, gelecekteki okuyucular için hangi tarafın ESKİ ve hangi tarafın YENİ olduğunu netleştirmek için bir yorum satırı (#) eklemeyi düşünün. </span>  

<span style="color: darkgreen;">**_İPUCU:_** Bazen bir veri kümesinde boş bir karakter değeri bulunur (R tarafından eksik (NA) olarak tanınmaz). Bu değere, aralarında boşluk ("") olmadan iki tırnak işareti ile başvurabilirsiniz.</span>  




### Mantık kullanımı {.unnumbered}

Aşağıda, mantık ve koşulların kullanımıyla bir sütundaki değerlerin nasıl yeniden kodlanacağını gösteriyoruz:

• Basit mantık için replace(), ifelse() ve if_else() kullanımı
• Daha karmaşık mantık için case_while() kullanımı




### Basit mantık {.unnumbered}  


#### `replace()` {.unnumbered}  

Basit mantık kriterleriyle yeniden kodlamak için mutate() içinde replace() öğesini kullanabilirsiniz. replace(), temel R'daki bir fonksiyondur. Değiştirilecek satırları belirtmek için bir mantık koşulu kullanın. Genel sintaks şöyledir:

`mutate(col_to_change = replace(col_to_change, criteria for rows, new value))`.  

replace() fonksiyonunun en yaygın kullanımı; benzersiz bir satır tanımlayıcısı kullanarak bir satırdaki yalnızca bir değeri değiştirmektir. Aşağıda, case_id sütununun "2195" olduğu satırda cinsiyet "Kadın" olarak değiştirilmiştir.

```{r, eval=F}
# Örnek: belirli bir gözlemin cinsiyetini "Female" olarak değiştirin
linelist <- linelist %>% 
  mutate(gender = replace(gender, case_id == "2195", "Female"))
```

Temel R sintaksı ve dizinleme parantezlerini [ ] kullanan eşdeğer komut aşağıdadır. “Veri çerçevesi satır listesinin gender sütun değerini (satır listesinin case_id sütununda '2195' değerine sahip olduğu satır için) 'Kadın' olarak değiştirin" olarak okunur. 

```{r, eval=F}
linelist$gender[linelist$case_id == "2195"] <- "Female"
```




#### `ifelse()` ve `if_else()` {.unnumbered}  

ABasit mantık için başka bir araç ifelse() ve if_else()'dir. Bununla birlikte, çoğu durumda yeniden kodlama için case_when() kullanmak daha kolaydır (aşağıda ayrıntılı olarak açıklanmıştır). Bu “if else” komutları, if ve else programlama ifadelerinin basitleştirilmiş versiyonlarıdır. Genel sözdizimi şöyledir:
`ifelse(condition, value to return if condition evaluates to TRUE, value to return if condition evaluates to FALSE)` 

Aşağıda, source_known sütunu tanımlanmıştır. Sütun kaynağındaki satırın değeri eksik değilse, belirli bir satırdaki değeri "bilinen" olarak ayarlanır. Kaynaktaki değer eksikse, kaynak_bilinen içindeki değer “bilinmeyen” olarak ayarlanır.  

```{r, eval=F}
linelist <- linelist %>% 
  mutate(source_known = ifelse(!is.na(source), "known", "unknown"))
```

if_else(), tarihleri işleyen dplyr'in özel bir sürümüdür. "doğru" değer bir tarihse, "yanlış" değerin de bir tarihi nitelemesi gerektiğini, dolayısıyla yalnızca NA yerine NA_real_ özel değerinin kullanması gerektiğini unutmayın. 

```{r, eval=F}
# Hasta ölmediyse NA olan bir ölüm tarihi sütunu oluşturun.
linelist <- linelist %>% 
  mutate(date_death = if_else(outcome == "Death", date_outcome, NA_real_))
```

Birçok ifelse komutunu bir araya getirmekten kaçının… bunun yerine case_When() kullanın! case_When() çok daha kolay okunur ve daha az hata yaparsınız.

```{r, fig.align = "center", out.width = "100%", echo=F}
knitr::include_graphics(here::here("images", "ifelse bad.png"))
```


Bir veri çerçevesi bağlamı dışında, kodunuzda kullanılan bir nesnenin değerini değiştirmesini istiyorsanız, temel R'dan switch() kullanmayı düşünün. 




### Karmaşık mantık {#clean_case_when .unnumbered}  

Birçok yeni gruba yeniden kodlama yapıyorsanız veya değerleri yeniden kodlamak için karmaşık mantıksal ifadeler kullanmanız gerekiyorsa dplyr'in case_while() fonksiyonunu kullanın. Bu fonkisyon, veri çerçevesindeki her satırı değerlendirir, satırların belirtilen kriterleri karşılayıp karşılamadığını değerlendirir ve doğru yeni değeri atar.

case_When() komutları, "tilde" ~ ile ayrılmış Sağ Taraf (RHS) ve Sol Taraf (LHS) içeren ifadelerden oluşur. Mantık kriterleri her bir ifadenin sol tarafında ve ilgili değerler sağ tarafındadır. İfadeler virgülle ayrılır.

Örneğin, burada age_years sütunu oluşturmak için age ve age_unit sütunlarını kullanıyoruz:



```{r}
linelist <- linelist %>% 
  mutate(age_years = case_when(
            age_unit == "years"  ~ age,       # yaş yıl olarak verildiyse
            age_unit == "months" ~ age/12,    # yaş ay olarak verildiyse
            is.na(age_unit)      ~ age))      # yaş birimi eksikse, yıl varsayın
                                              # Başka herhangi bir senaryo NA olarak atanır

```


Verilerdeki her satır değerlendirilirken, kriterler case_while() ifadelerinin yazıldığı sırayla - yukarıdan aşağıya - uygulanır/değerlendirilir. Belirli bir satır için en üstteki ölçüt DOĞRU olarak değerlendirilirse, RHS değeri atanır ve kalan ölçütler o satır için test edilmez. Bu nedenle, en spesifik kriterleri önce ve en genel olanı en son yazmak en iyisidir.

Bu satırlar boyunca, son ifadenizde, önceki kriterlerden herhangi birini karşılamayan satırları yakalayacak şekilde, sol tarafa DOĞRU'yu yerleştirin. Bu ifadenin sağ tarafına “kontrol et!” gibi bir değer atanabilir. veya eksik olarak değerlendirilir.



<span style="color: red;">**_TEHLİKE:_** **Sağ taraftaki değerlerin tümü aynı sınıfta olmalıdır** - sayısal, karakter, tarih, mantıksal vb. Eksik (NA) ya senaryoyu ele almadan bırakın ya da NA_character_, NA_real_ (sayısal veya POSIX) ve as.Date(NA) gibi NA'nın özel varyasyonlarını kullanmanız gerekebilir. [Tarihlerle çalışma] bölümünden daha fazlasını okuyabilirsiniz.</span>  


### Eksik değerler {.unnumbered} 

Aşağıda, veri temizleme bağlamında eksik değerlerle çalışmak için özel fonksiyonlar bulunmaktadır.

Eksik değerleri belirleme ve işleme konusunda daha ayrıntılı bilgi için Eksik veriler sayfasına bakın. Örneğin, eksik olup olmadığını mantıksal olarak test eden is.na() fonksiyonu.
 


**`replace_na()`**  

Eksik değerleri (NA), "Eksik" gibi belirli bir değerle değiştirmek için, mutate() içindeki dplyr replace_na() fonksiyonunu kullanın. Bunun yukarıdaki recode ile aynı şekilde kullanıldığını unutmayın - değişkenin adı replace_na() içinde tekrarlanmalıdır.


```{r}
linelist <- linelist %>% 
  mutate(hospital = replace_na(hospital, "Missing"))
```


**fct_explicit_na()**  

Bu, forcats paketinden bir fonksiyondur. forcats paketi, faktör sınıfının sütunlarını işler. Faktörler, R'nin c("Birinci", "İkinci", "Üçüncü") gibi sıralı değerleri işleme veya değerlerin (örn. hastaneler) tablolarda ve çizimlerde görünme sırasını belirleme yöntemidir. Faktörler sayfasını inceleyin.

Verileriniz Faktör sınıfı ise ve replace_na() kullanarak NA'yı "Eksik"e dönüştürmeye çalışırsanız, şu hatayı alırsınız: geçersiz faktör düzeyi, NA oluşturuldu. Faktörün olası bir düzeyi olarak “Eksik” değerini bir değer olarak eklemeye çalıştığınızda reddedilirsiniz. 

Bunu çözmenin en kolay yolu, bir sütunu sınıf faktörüne ve NA değerlerini “(Missing)” karakterine dönüştüren forcats fonksiyonunu fct_explicit_na() kullanmaktır.
  

```{r, eval=F}
linelist %>% 
  mutate(hospital = fct_explicit_na(hospital))
```

Daha yavaş bir alternatif, fct_expand() kullanarak faktör düzeyini eklemek ve ardından eksik değerleri dönüştürmek olabilir.

**`na_if()`**  

Belirli bir değeri NA'ya dönüştürmek için dplyr'in na_if() fonksiyonunu kullanın. Aşağıdaki komut, replace_na() fonksiyonunun tersi işlemini gerçekleştirir. Aşağıdaki örnekte, hastane sütunundaki herhangi bir "Eksik" değeri NA'ya dönüştürülür.

```{r}
linelist <- linelist %>% 
  mutate(hospital = na_if(hospital, "Missing"))
```

Not: na_if() **mantık kriterleri için kullanılamaz** (örneğin, "tüm değerler > 99") - bunun için replace() veya case_while() kullanın: 

```{r, eval=F}
# 40'ın üzerindeki sıcaklıkları NA'ya dönüştürün
linelist <- linelist %>% 
  mutate(temp = replace(temp, temp > 40, NA))

#  1 Ocak 2000'den önceki başlangıç tarihlerini eksik tarihlere dönüştürün
linelist <- linelist %>% 
  mutate(date_onset = replace(date_onset, date_onset > as.Date("2000-01-01"), NA))
```




### Sözlüğün temizlenmesi  {.unnumbered}

Bir veri çerçevesini bir temizleme sözlüğü ile temizlemek için R paketi satır **matchmaker** ve match_df() fonksiyonunu kullanın.  

1. 3 sütunlu bir temizleme sözlüğü oluşturun:
• Bir "-den" sütunu (yanlış değer)
• Bir "-e" sütunu (doğru değer)
• Değişikliklerin uygulanacağı sütunu belirten bir sütun (veya tüm sütunlara uygulanacak ".global")

Not: .global sözlük girişleri, sütuna özel sözlük girişleri tarafından geçersiz kılınacaktır.


```{r, fig.align = "center", out.width = "100%", echo=F}
knitr::include_graphics(here::here("images", "cleaning_dict.png"))
```


2. Sözlük dosyasını R'a aktarın. Bu örnek, [El kitabı ve veri indirme] sayfasındaki talimatlar aracılığıyla indirilebilir.

```{r, echo=F}
cleaning_dict <- rio::import(here("data", "case_linelists", "cleaning_dict.csv"))
```

```{r, eval=F}
cleaning_dict <- import("cleaning_dict.csv")
```

3. Ham satır listesini, dictionary = temizleme sözlüğü veri çerçevesini belirterek match_df() öğesine iletin. `from = ` argümanı "eski" değerleri içeren sözlük sütununun adı olmalıdır, `by = ` argümanı karşılık gelen "yeni" değerleri içeren sözlük sütunu olmalıdır ve üçüncü sütun değişikliğin yapılacağı sütunu listeler. Bir değişikliği tüm sütunlara uygulamak için `by = ` sütununda `.global` kullanın. Dördüncü bir sözlük sütunu olan `order` yeni değerlerin faktör sırasını belirtmek için kullanılabilir.  Bu fonksiyonun çalışmasının uzun zaman alabileceğini unutmayın.  

Daha fazla ayrıntıyı `?match_df` komutunu çalıştırarak [paket dokümantasyonu](https://cran.r-project.org/web/packages/matchmaker/vignettes/intro.html) adresinden okuyabilirsiniz.  


```{r}
linelist <- linelist %>%               # veri setinizi sağlayın veya borulayın
     matchmaker::match_df(
          dictionary = cleaning_dict,  # sözlüğünüzün adı
          from = "from",               # değiştirilecek değerlerin bulunduğu sütun (varsayılan değer col 1'dir)
          to = "to",                   # nihai değerleri içeren sütun (varsayılan değer 2. sütundur)
          by = "col"                   # sütun adları ile sütun (varsayılan col 3'tür)
  )
```

Şimdi değerlerin nasıl değiştiğini görmek için sağa kaydırın - özellikle cinsiyet (küçük harften büyük harfe) ve tüm semptom sütunları evet/hayır'dan 1/0'a dönüştürülmüşür. 


```{r message=FALSE, echo=F}
# satır listesi verisini tablo olarak görüntüle
DT::datatable(head(linelist,50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


Temizleme sözlüğündeki sütun adlarınızın, temizleme komut dosyanızın bu noktasındaki adlara karşılık gelmesi gerektiğini unutmayın.  



#### Tünel zincirine ekleme {.unnumbered}  

**Aşağıda, tünel zincirine bazı yeni sütunlar ve sütun dönüşümleri eklenmiştir.**  

```{r}
# TEMİZLİK 'BORU' ZİNCİRİ (ham verilerle başlar ve temizleme adımları boyunca iletir
##################################################################################

# tünel zincirini temizlemeye başla
###########################
linelist <- linelist_raw %>%
    
    # sütun adı sintaksını standartlaştır
    janitor::clean_names() %>% 
    
    # sütunları manuel olarak yeniden adlandır
           # YENİ isim             # ESKİ isim
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # sütunu sil
    select(-c(row_num, merged_header, x28)) %>% 
  
    # tekilleştir
    distinct() %>% 
  
    # sütun ekle
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     

    # sütun sınıfını değiştir
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) %>% 
    
    # sütun ekleme: hastaneye yatışta gecikme
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 
    
   # YUKARIDAKİ TEMİZLİK ADIMLARI ZATEN TARTIŞILMIŞTIR
   ###################################################

    # hastane sütununun temiz değerleri
    mutate(hospital = recode(hospital,
                      # ESKİ = YENİ
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

    # age_years sütunu oluştur (age ve age_unit sütunlarından)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age))
```






<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Sayısal kategoriler  {#num_cats}


Burada sayısal sütunlardan kategoriler oluşturmaya yönelik bazı özel yaklaşımları açıklıyoruz. Yaygın örnekler arasında yaş kategorileri, laboratuvar değerleri grupları vb. bulunur. Burada şunları tartışacağız:

• epikit paketinden age_categories()
• temel R’dan cut()
• case_When()
• quantile() ve ntile() ile nicel sonlanmalar



### Dağılımın gözden geçirilmesi  {.unnumbered}

Bu örnek için age_years sütununu kullanarak bir age_cat sütunu oluşturacağız.

```{r}
#linelist değişken yaşının sınıfını kontrol edin
class(linelist$age_years)
```

İlk olarak, uygun kesme noktaları yapmak için verilerinizin dağılımını inceleyin. [ggplot temelleri] ile ilgili sayfaya bakabilirsiniz.

```{r, out.height='50%'}
# dağılımın incelenmesi
hist(linelist$age_years)
```

```{r}
summary(linelist$age_years, na.rm=T)
```

<span style="color: orange;">**_UYARI:_** Bazen sayısal değişkenler "karakter" sınıfı olarak içe aktarılır. Bu durum, bazı değerlerde sayısal olmayan karakterler varsa, örneğin yaş için “2 ay” girişi veya (yerel ayarlarınıza bağlı olarak) ondalık basamakta virgül kullanılmışsa (örn. 5” dört buçuk yıl anlamına gelir) karşınıza çıkar.</span>


<!-- ======================================================= -->
### `age_categories()` {.unnumbered}

Epikit paketiyle, sayısal sütunları kolayca kategorilere ayırmak ve etiketlemek için age_categories() fonksiyonunu kullanabilirsiniz (not: bu fonksiyon, yaş dışı sayısal değişkenlere de uygulanabilir). Bir bonus olarak, fonkisyonun oluşturduğu çıktı sütunu otomatik olarak sıralı bir faktör özelliğinde gelir. 

Gerekli girdiler:
• Sayısal bir vektör (sütun)
• Kesiciler = argüman - yeni gruplar için sayısal bir kesim noktası vektörü sağlar

İlk olarak, en basit örnek:


```{r}
# basit örnek
################
pacman::p_load(epikit)                    # paket yükleme

linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(             # yeni sütun ekleme
      age_years,                          # grupların oluşturulacağı ssayısal sütun 
      breakers = c(0, 5, 10, 15, 20,      # kesim noktaları 

                   30, 40, 50, 60, 70)))

# tabloyu göster
table(linelist$age_cat, useNA = "always")
```

Belirttiğiniz kesme değerleri varsayılan olarak alt sınırlardır - yani "üst" gruba dahil edilirler / gruplar alt/sol tarafta "açıktır". Aşağıda gösterildiği gibi, üstte/sağda açık olan gruplara ulaşmak için her bir ara değerine 1 ekleyebilirsiniz. 
 
```{r}
# Aynı kategoriler için üst uçları dahil et
############################################
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      breakers = c(0, 6, 11, 16, 21, 31, 41, 51, 61, 71)))

# tabloyu göster
table(linelist$age_cat, useNA = "always")
```


Ayırıcı = ile etiketlerin nasıl görüntüleneceğini ayarlayabilirsiniz. Varsayılan "-"

Ceiling = değişkeni ile en üstteki sayıların nasıl kullanılacağını ayarlayabilirsiniz. Daha yukarı seviyede eşik değeri ayarlamak için ceiling = DOĞRU. Bu kullanımda sağlanan en yüksek kesim değeri bir “tavan”dır ve “XX+” kategorisi oluşturulmaz. En yüksek kırılma değerinin üzerindeki (veya tanımlanmışsa upper =) değerler NA olarak kategorize edilir. Aşağıda ceiling = DOĞRU olan bir örnek verilmiştir, bu örnekte XX+ kategorisi yoktur ve 70'in üzerindeki değerler (en yüksek kesmi değeri) NA olarak atanır.
 

```{r}
# Tavan DOĞRU olarak ayarlandığında
##########################
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      breakers = c(0, 5, 10, 15, 20, 30, 40, 50, 60, 70),
      ceiling = TRUE)) # 70 tavandır, her şey NA olur

# tabloyu göster
table(linelist$age_cat, useNA = "always")
```

Alternatif olarak, ayırıcılar = yerine, tüm lower =, upper = ve by = değerlerini verebilirsiniz:

• lower = Dikkate alınmasını istediğiniz en düşük sayı - varsayılan 0'dır
• upper = dikkate alınmasını istediğiniz en yüksek sayı
• by = Gruplar arasındaki yıl sayısı

```{r}
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      lower = 0,
      upper = 100,
      by = 10))

# tabloyu göster
table(linelist$age_cat, useNA = "always")
```


Daha fazla ayrıntı için Yardım sayfasına bakın (R konsolunda ?age_categories).

<!-- ======================================================= -->
### `cut()` {.unnumbered}

cut(), age_categories()'e alternatif bir temel R fonksiyonudur, Bu işlemin basitleştirilmesi için age_categories()'in geliştirilmiştir. age_categories()'den bazı dikkate değer farklılıkları şunlardır:

• Başka bir paket kurmanız/yüklemeniz gerekmez

• Sağda/solda grupların açık/kapalı olup olmadığını belirleyebilirsiniz.

• Doğru etiketleri kendiniz sağlamalısınız

• En alt gruba 0'ın dahil edilmesini istiyorsanız, bunu belirtmelisiniz.

cut() içindeki temel sintaksta, önce kesilecek sayısal sütun (age_years) ve ardından kesme noktalarının sayısal vektörü olan break argümanı yazılmalıdır. cut() kullanılarak elde edilen sütun sıralı bir faktördür.

Varsayılan olarak, sınıflandırma sağ/üst taraf "açık" ve kapsayıcı (ve sol/alt taraf "kapalı" veya özel) olacak şekilde gerçekleşir. Bu, age_categories() fonksiyonunun tersi davranıştır. Varsayılan etiketler, "(A, B]" notasyonunu kullanır, bu, A'nın dahil edilmediği, ancak B'nin dahil olduğu anlamına gelir. right = DOĞRU argümanını sağlayarak bu davranışı tersine çevirin.

Bu nedenle, varsayılan olarak “0” değerleri en düşük gruptan çıkarılır ve NA olarak sınıflandırılır! “0” değerleri 0 yaş olarak kodlanmış bebekler olabilir, bu yüzden dikkatli olun! Bunu değiştirmek için, include.lowest = DOĞRU argümanını ekleyin, böylece herhangi bir "0" değeri en düşük gruba dahil edilecektir. En düşük kategori için otomatik olarak oluşturulan etiket “[A],B]” olacaktır. include.lowest = DOĞRU argümanını ve right = DOĞRU’yu eklerseniz, aşırı değerleri dahil etmenin artık en düşük değil, en yüksek kesme noktası değeri ve kategorisi için geçerli olacağını unutmayın.

Etiketler = bağımsız değişkenini kullanarak bir özelleştirilmiş etiket vektörü sağlayabilirsiniz. Bunlar elle yazıldığından, doğru olduklarından emin olmak için çok dikkatli olun! Aşağıda açıklandığı gibi çapraz tablolama kullanarak çalışmanızı kontrol edin.

Yeni age_cat değişkenini yapmak için age_years'a uygulanan bir cut() örneği aşağıdadır:


```{r}
# Sayısal yaş değişkenini keserek yeni değişken oluşturun
# alt kesim hariç tutulmuştur, ancak her kategoride üst kesim dahil edilmiştir

linelist <- linelist %>% 
  mutate(
    age_cat = cut(
      age_years,
      breaks = c(0, 5, 10, 15, 20,
                 30, 50, 70, 100),
      include.lowest = TRUE         # 0'ı en düşük gruba dahil et
      ))

# grup başına gözlem sayısını tablo haline getirin
table(linelist$age_cat, useNA = "always")
```


**İşini kontrol et!!!** Sayısal ve kategori sütunlarını çapraz tablolayarak her yaş değerinin doğru kategoriye atandığını doğrulayın. Sınır değerlerinin atanmasını inceleyin (örneğin komşu kategoriler 10-15 ve 16-20 ise 15). 

```{r}
# Sayısal ve kategori sütunlarının çapraz tablosu.  
table("Numeric Values" = linelist$age_years,   # netlik için tabloda belirtilen isimler.
      "Categories"     = linelist$age_cat,
      useNA = "always")                        # NA değerlerini incelemeyi unutmayın
```





**NA değerlerinin yeniden etiketlenmesi **

NA değerlerine “Eksik” gibi bir etiket atamak isteyebilirsiniz. Yeni sütun faktör sınıfından (kısıtlı değerler) olduğundan replace_na() ile değiştiremezsiniz. Bunun yerine, [Faktörler] sayfasında açıklandığı gibi forcat'lerden fct_explicit_na() kullanın.

```{r}
linelist <- linelist %>% 
  
  # cut()age_cat oluşturur, otomatik olarak faktör sınıfı özelliğindedir.     
  mutate(age_cat = cut(
    age_years,
    breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),          
    right = FALSE,
    include.lowest = TRUE,        
    labels = c("0-4", "5-9", "10-14", "15-19", "20-29", "30-49", "50-69", "70-100")),
         
    # eksik değerleri açık hale getirmek
    age_cat = fct_explicit_na(
      age_cat,
      na_level = "Missing age")  # you can specify the label
  )    

# sayıları görüntülemek için tablo
table(linelist$age_cat, useNA = "always")
```

**Hızlı şekilde kesim noktaları ve etiket oluşturma **  

Kesim noktası oluşturma ve vektörleri etiketlemenin hızlı bir yolu için aşağıdaki yöntemi kullanın. seq() ve rep() ile ilgili referanslar için [R temelleri] sayfasına bakınız.

```{r, eval=F}
# 0'dan 90'a 5'erli kesim noktaları yapın
age_seq = seq(from = 0, to = 90, by = 5)
age_seq

# Varsayılan cut() ayarlarına göre yukarıdaki kategoriler için etiketler yapın
age_labels = paste0(age_seq + 1, "-", age_seq + 5)
age_labels

# her iki vektörün de aynı uzunlukta olduğunu kontrol edin
length(age_seq) == length(age_labels)
```


R konsoluna ?cut yazarak cut() hakkında daha fazla bilgi edinin.




### Yüzdelik kesim noktaları {.unnumbered}  

Genel olarak, "yüzdelik dilimler”, değerlerin bir kısmının altına düştüğü bir değeri ifade eder. Örneğin, satır listesindeki yaşların 95. yüzdelik dilimi, yaşın %95'inin altına düştüğü yaş olacaktır.

Bununla birlikte, konuşmada, “çeyreklikler” ve “ondalıklar”, eşit olarak 4 veya 10 gruba bölünmüş veri gruplarını da ifade edebilir (grup sayısından bir fazla kesim noktası olacağını unutmayın).

Yüzdelik kırılma noktaları elde etmek için, temel R stats paketinden quantile() öğesini kullanabilirsiniz. Sayısal bir vektör (örneğin, bir veri kümesindeki bir sütun) ve 0 ile 1.0 arasında değişen sayısal değerleri içeren vektör yazılmalıdır. Kesmi noktaları sayısal bir vektör olarak oluşturulur. Konsola ?quantile komutunu girerek istatistiksel metodolojilerin ayrıntılarını keşfedin.

• Girdiğiniz sayısal vektörde eksik değerler varsa, en iyisi na.rm = DOĞRU olarak ayarlamaktır.

• Adsız bir sayısal vektör elde etmek için names = YANLIŞ


```{r}
quantile(linelist$age_years,               # üzerinde çalışılacak sayısal vektörü belirtin
  probs = c(0, .25, .50, .75, .90, .95),   # istediğiniz yüzdelik dilimleri belirtin
  na.rm = TRUE)                            # eksik değerleri yoksay 
```

quantile() sonuçlarını age_categories() veya cut() içinde kesim noktaları olarak kullanabilirsiniz. Aşağıda cut() kullanarak yeni bir sütun oluşturuyoruz, burada kesim noktaları age_years üzerinde quantiles() kullanılarak tanımlanıyor. Aşağıda, yüzdeleri görebilmeniz için janitor’dan tabyl() fonksiyonu kullanarak sonuçları gösteriyoruz [Tanımlayıcı tablolar] sayfasına bakabilirsiniz. Her gruptaki, yüzdeliklerin tam olarak %10 olmadıklarına dikkat edin.

```{r}
linelist %>%                                # linelist ile başla 
  mutate(deciles = cut(age_years,           # age_years sütununda cut() olarak yeni sütun ondalık oluştur
    breaks = quantile(                      # quantile() kullanarak kesim noktalarını tanımlayın
      age_years,                               # age_years çalıştır
      probs = seq(0, 1, by = 0.1),             # 0,0 ile 1,0 arasında 0,1’erlik aralıklar
      na.rm = TRUE),                           # eksik değerleri yoksay
    include.lowest = TRUE)) %>%             # cut() için 0 yaşını içerir
  janitor::tabyl(deciles)                   # görüntülemek için tabloya tünelle

```

### Eşit boyutlu gruplar {.unnumbered}  

Sayısal gruplar oluşturmak için başka bir araç, verilerinizi eşit boyutlu gruplara ayırmaya çalışan ntile() dplyr fonksiyonudur - ancak quantile()'den farklı olarak aynı değerin birden fazla grupta görünebileceğini unutmayın. Sayısal vektörü ve ardından grup sayısını girin. Oluşturulan yeni sütundaki değerler, cut() kullanılırken olduğu gibi değer aralığının kendisi değil, yalnızca "sayılar" grubudur (örneğin 1 ila 10).

```{r}
# ntile() ile gruplar oluştur
ntile_data <- linelist %>% 
  mutate(even_groups = ntile(age_years, 10))

# gruba göre sayım ve orantı tablosu yapın
ntile_table <- ntile_data %>% 
  janitor::tabyl(even_groups)
  
# aralıkları göstermek için min/maks değerleri ekleyin
ntile_ranges <- ntile_data %>% 
  group_by(even_groups) %>% 
  summarise(
    min = min(age_years, na.rm=T),
    max = max(age_years, na.rm=T)
  )

# birleştir ve yazdır - değerlerin birden fazla grupta bulunduğunu unutmayın
left_join(ntile_table, ntile_ranges, by = "even_groups")
```


<!-- ======================================================= -->
### `case_when()` { .unnumbered}

Sayısal bir sütundan kategoriler oluşturmak için case_while() dplyr fonksiyonunu kullanmak mümkündür, ancak epikit veya cut()'tan age_categories() kullanmak daha kolaydır çünkü bunlar otomatik olarak sıralı bir faktör oluşturacaktır.

case_while() kullanıyorsanız, lütfen bu sayfanın değerleri yeniden kodla bölümünde daha önce açıklandığı gibi doğru kullanıldığını kontrol edin. Ayrıca tüm sağ taraftaki değerlerin aynı sınıfta olması gerektiğini unutmayın. Bu nedenle, sağ tarafta NA istiyorsanız, “Eksik” yazmalı veya NA_character_ özel NA değerini kullanmalısınız.




### Tünel zincirine ekleme {.unnumbered}  

Aşağıda, temizleme tünel zincirine iki kategorik yaş sütunu oluşturma kodu eklenmiştir:

```{r}
# TEMİZLİK 'TÜNEL' ZİNCİRİ (ham verilerle başlar ve temizleme adımları boyunca iletir)
##################################################################################

# tünel zincirini temizlemeye başla
###########################
linelist <- linelist_raw %>%
    
    # sütun adı sintaksını standartlaştır
    janitor::clean_names() %>% 
    
    # sütunları manuel olarak yeniden adlandır
           # YENİ isim             # ESKİ isim
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # sütunu sil
    select(-c(row_num, merged_header, x28)) %>% 
  
    # tekilleştir
    distinct() %>% 

    # sütun ekle
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     

    # sütun sınıfını değiştir
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) %>% 
    
    # sütun ekle: hastaneye yatışta gecikme
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 
    
    # hastane sütununun temiz değerleri
    mutate(hospital = recode(hospital,
                      # ESKİ = YENİ
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

    # age_years sütunu oluştur (age ve age_unit'ten)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age)) %>% 
  
    # YUKARIDAKİ TEMİZLİK ADIMLARI ZATEN TARTIŞILMIŞTIR
    ###################################################   
    mutate(
          # yaş kategorileri: özel
          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),
        
          # yaş kategorileri: 0-85 arası, 5’erli
          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5)))
```








<!-- ======================================================= -->
## Satır ekleme   

### Teker teker {.unnumbered}  

Satırları tek tek manuel olarak eklemek sıkıcıdır ancak dplyr'den add_row() ile yapılabilir. Her sütunun yalnızca bir sınıfın (karakter, sayısal, mantık vb.) değerlerini içermesi gerektiğini unutmayın. Bu yüzden bir satır eklemek, bunu korumak için dikkat gerektirir.


```{r, eval=F}
linelist <- linelist %>% 
  add_row(row_num = 666,
          case_id = "abc",
          generation = 4,
          `infection date` = as.Date("2020-10-10"),
          .before = 2)
```

.before ve .after kullanın. Eklemek istediğiniz satırın yerleşimini belirtmek için .before = 3, yeni satırı mevcut 3. satırın önüne koyacaktır. Varsayılan davranış, satırı sonuna eklemektir. Belirtilmeyen sütunlar boş bırakılacaktır (NA).

Yeni satır numarası garip görünebilir (“…23”) ancak önceden var olan satırlardaki satır numaraları değişmiştir. Bu nedenle, komutu iki kez kullanıyorsanız, yerleştirmeyi dikkatlice inceleyin/test edin.

Sağladığınız bir sınıf kapalıysa, aşağıdaki gibi bir hata görürsünüz:


```
Error: Can't combine ..1$infection date <date> and ..2$infection date <character>.
```

((tarih değerine sahip bir satır eklerken, tarihi `as.Date()` fonksiyonuyla `as.Date("2021-12-31")` gibi eklemeyi unutmayın)).


### Satırların bağlanması {.unnumbered}  

Bir veri çerçevesinin satırlarını başka bir veri çerçevesinin altına bağlayarak veri kümelerini birleştirmek için dplyr'den bind_rows() öğesini kullanabilirsiniz. Bu yöntem, [Verileri birleştirme] sayfasında daha ayrıntılı olarak açıklanmaktadır. 




<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Satırların filtrelenmesi   {  }


Sütunları temizledikten ve değerleri yeniden kodladıktan sonra tipik bir temizleme adımı, dplyr filter() komutunu kullanarak belirli satırlar için veri çerçevesini filtrelemektir.

filter() içinde, veri kümesindeki bir satırın tutulması için DOĞRU olması gereken mantık koşulunu belirtin. Aşağıda, basit ve karmaşık mantıksal koşullara dayalı olarak satırların nasıl filtreleneceğini gösteriyoruz.



<!-- ======================================================= -->
### Basit Filtre {.unnumbered} 

Bu basit örnek, mantıksal bir koşulu karşılayacak satırları filtreleyerek veri çerçevesi satır listesini yeniden tanımlar. Yalnızca parantez içindeki mantıksal ifadenin DOĞRU olarak değerlendirildiği satırlar veri çerçevesinde tutulur.

Bu örnekte, cinsiyet sütunundaki değerin “f”ye (büyük/küçük harf duyarlı) eşit olup olmadığını soran cinsiyet == "f" mantıksal ifadesi filtreleme için kullanılmıştır.

Filtre uygulanmadan önce linelistteki satır sayısı nrow(linelist) ile gösterilir.


```{r, eval=F}
linelist <- linelist %>% 
  filter(gender == "f")   # yalnızca cinsiyetin "f"ye eşit olduğu satırları tut
```

Filtre uygulandıktan sonra, linelistteki satır sayısı linelist %>% filter(gender == "f") %>% nrow().

### Eksik değerlerin filtrelenmesi {.unnumbered}  

Eksik değerlere sahip satırları filtrelemek oldukça yaygındır. filter(!is.na(column) & !is.na(column)) yerine bu amaç için özel olarak oluşturulmuş tidyr fonksiyonunu kullanın: drop_na(). Boş parantezlerle çalıştırılırsa, eksik değerleri olan satırları kaldırır. Alternatif olarak, eksik olup olmadığı değerlendirilecek belirli sütunların adlarını sağlayabilir veya [yukarıda](#clean_tidyselect) açıklanan "tidyselect" yardımcı fonksiyonlarını kullanabilirsiniz.  

```{r, eval=F}
linelist %>% 
  drop_na(case_id, age_years)  # case_id veya age_years için eksik değerleri olan satırları bırak
```

Verilerinizdeki eksiklikleri analiz etmeye ve yönetmeye yönelik birçok teknik için [Eksik veriler] sayfasına bakın. 
 


### Satır numarasına göre filtreleme {.unnumbered}  

Bir veri çerçevesinde veya tibble'da, her satır genellikle (R Viewer'da görüldüğünde) ilk sütunun solunda görünen bir "satır numarasına" sahip olacaktır. Bu satır numarası veri çerçevesinde gerçek bir sütun değildir, ancak filter() ifadesinde kullanılabilir.

"Satır numarasına" göre filtrelemek için, mantıksal filtreleme ifadesinin bir parçası olarak açık parantezlerle dplyr row_number() fonksiyonunu kullanabilirsiniz. Aşağıda gösterildiği gibi, genellikle %in% operatörünü ve bir dizi sayıyı bu mantıksal ifadenin parçası olarak kullanacaksınız. İlk N satırı görmek için özel dplyr fonksiyonu head()'i de kullanabilirsiniz.
   

```{r, eval=F}
# İlk 100 satırı gösterin
linelist %>% head(100)     # veya son n satırı görmek için tail() kullanın

# sadece 5 satırı göster
linelist %>% filter(row_number() == 5)

# satır 2'den 20'ye üç spesifik sütunu göster
linelist %>% filter(row_number() %in% 2:20) %>% select(date_onset, outcome, age)
```

Ayrıca veri çerçevenize tibble fonksiyonu rownames_to_column() (parantez içine hiçbir şey koymayın) kullanarak  satır numaralarını gerçek bir sütuna dönüştürebilirsiniz.


<!-- ======================================================= -->
### Karmaşık filtre {.unnumbered} 

Parantezler ( ), OR |, negate !, %in% ve AND & operatörleri kullanılarak daha karmaşık mantıksal ifadeler oluşturulabilir. Bir örnek aşağıdadır:

Not:  Mantıksal bir kriteri reddetmek için ! operatörünü kullanabilirsiniz. Örneğin, !is.na(column), sütun değeri eksik değilse doğru olarak değerlendirilir. Aynı şekilde !column %in% c("a", "b", "c"), sütun değeri vektörde değilse doğru olarak değerlendirilir.
  


#### Verinin incelenmesi  {.unnumbered}  

Aşağıda, başlangıç tarihlerinin bir histogramını oluşturmak için basit bir tek satırlık komut verilmiştir. Bu ham veri kümesine 2012-2013 arasında ikinci bir daha küçük salgının da dahil edildiğini görün. Analizlerimiz için, bu önceki salgın girişlerini kaldırmak istiyoruz.

```{r, out.width = "50%"}
hist(linelist$date_onset, breaks = 50)
```


#### Eksik sayısal ve tarih verilerinin filtrelenmesi  {.unnumbered}  

Haziran 2013'ten sonraki satırlara date_onset’e göre filtre uygulayabilir miyiz? **Dikkat! Kod filtresini uygulamak(date_onset > as.Date("2013-06-01"))) sonraki salgında başlangıç tarihi eksik olan tüm satırları kaldırır!**

<span style="color: red;">**_UYARI:_** Bir tarih veya sayıdan büyük (>) veya küçük (<) olarak filtrelemek, eksik değerlere sahip satırları kaldırabilir (NA)! Bunun nedeni, NA'nın sonsuz büyük ve küçük olarak kabul edilmesidir.</span>

*(Tarihlerle çalışma ve lubridate paketi hakkında daha fazla bilgi için Tarihlerle çalışma sayfasına bakın)*

#### Filtre Dizaynı {.unnumbered}  

Yalnızca istediğimiz doğru satırları hariç tuttuğumuzdan emin olmak için bir çapraz tabloyu inceleyin:


```{r}
table(Hospital  = linelist$hospital,                     # hastane ismi
      YearOnset = lubridate::year(linelist$date_onset),  # date_onset yılı
      useNA     = "always")                              # eksik verileri göster
```

İlk salgını (2012 ve 2013'te) veri kümesinden çıkarmak için başka hangi kriterleri filtreleyebiliriz? Şunu görüyoruz:

•	2012 ve 2013 yıllarında ilk salgın A Hastanesi ve B Hastanesi'nde meydana geldi ve ayrıca Liman Hastanesi'nde 10 vaka görüldü.

•	A ve B hastanelerinde ikinci salgında vaka görülmedi ama Liman Hastanesinde görüldü. 


Dışlamak istediklerimiz: 

•	nrow(linelist %>% filter(hospital %in% c("Hospital A", "Hospital B") | date_onset < as.Date("2013-06-01"))) • A, B hastanesi veya Liman'da 2012 ve 2013'te başlayan sıralar:

•	nrow(linelist %>% filter(date_onset < as.Date("2013-06-01"))) 2012 ve 2013'te başlayan satırlar

•	Exclude nrow(linelist %>% filter(hospital %in% c('Hospital A', 'Hospital B') & is.na(date_onset))) A ve B Hastanelerinden başlangıç tarihleri eksik satırlar

•	Ancak nrow(linelist %>% filter(!hospital %in% c('Hospital A', 'Hospital B') & is.na(date_onset))) eksik tarihli diğer satırlar dışlanmayacak 



nrow(linelist)` satır listesiyle başlıyoruz. Filtre ifademiz:
 

```{r}
linelist <- linelist %>% 
  # başlangıcın 1 Haziran 2013'ten sonra olduğu VEYA başlangıcın olmadığı ve Hastane A veya B'den DIŞINDA bir hastane olduğu satırları saklayın
  filter(date_onset > as.Date("2013-06-01") | (is.na(date_onset) & !hospital %in% c("Hospital A", "Hospital B")))

nrow(linelist)
```

Çapraz tabloyu yeniden yaptığımızda A ve B Hastanelerinin tamamen kaldırıldığını; 2012 ve 2013 yıllarındaki 10 Liman Hastanesi vakasının kaldırıldığını ve diğer tüm değerlerin aynı - istediğimiz gibi - olduğunu görüyoruz.
 
```{r}
table(Hospital  = linelist$hospital,                     # hastane adı
      YearOnset = lubridate::year(linelist$date_onset),  # date_onset yılı
      useNA     = "always")                              # eksik değerleri göster

```

Bir filtre komutuna (virgülle ayrılmış) birden çok ifade dahil edilebilir veya kolaylık için her zaman ayrı bir filter() komutuna yönlendirebilirsiniz.

*Not: Bazı okuyucular, hiçbir eksik değer olmadığında, yalnızca date_hospitalisation'a göre filtrelemenin daha kolay olacağını fark edebilir. Bu doğrudur. Ancak date_onset, karmaşık bir filtreyi göstermek amacıyla kullanılmıştır.* 





### Bağımsız (Standalone) {.unnumbered}  

Filtreleme, bağımsız bir komut olarak da uygulanabilir (tünel zincirinin bir parçası değil). Diğer dplyr komutları gibi, bu durumda ilk argüman veri kümesinin kendisi olmalıdır.

```{r, eval=F}
# dataframe <- filter(dataframe, condition(s) for rows to keep)

linelist <- filter(linelist, !is.na(case_id))
```

Korumak istediğiniz [satırları, sütunları] yansıtan köşeli parantezler kullanarak alt küme için temel R ‘ı da kullanabilirsiniz.

```{r, eval=F}
# dataframe <- dataframe[row conditions, column conditions] (blank means keep all)

linelist <- linelist[!is.na(case_id), ]
```





### Kayıtların hızla gözden geçirilmesi {.unnumbered} 

Çoğu zaman, yalnızca birkaç sütun için birkaç kaydı hızlı bir şekilde gözden geçirmek istersiniz. Temel R fonksiyonu View(), RStudio'da görüntülemek için bir veri çerçevesi yazdıracaktır.

RStudio'daki satır listesini görüntüleyin:


```{r, eval=F}
View(linelist)
```

Belirli hücreleri (belirli satırlar ve belirli sütunlar) görüntülemeye ilişkin iki örnek:


**dplyr fonksiyonları  filter() ve select():**

View() içinde, veri çerçevesinde belirli satırları tutmak için veri kümesini filter() öğesine ve ardından belirli sütunları tutmak için select() öğesine yönlendirin. Örneğin, 3 spesifik vakanın başlangıç ve hastaneye yatış tarihlerini gözden geçirmek için
   

```{r, eval=F}
View(linelist %>%
       filter(case_id %in% c("11f8ea", "76b97a", "47a5f5")) %>%
       select(date_onset, date_hospitalisation))
```


Aynı sonucu, görmek istediğiniz alt küme için köşeli parantez [ ] kullanarak, temel R sintaksı ile elde edebilirsiniz. 

```{r, eval=F}
View(linelist[linelist$case_id %in% c("11f8ea", "76b97a", "47a5f5"), c("date_onset", "date_hospitalisation")])
```





#### Tünel zincirine ekleme  {.unnumbered}  


```{r}
# TEMİZLİK 'TÜNEL' ZİNCİRİ (ham verilerle başlar ve temizleme adımları boyunca iletir)
##################################################################################

# tünel zincirini temizlemeye başla
###########################
linelist <- linelist_raw %>%
    
    # sütun adı sintaksını standartlaştır
    janitor::clean_names() %>% 
    
    # sütunları manuel olarak yeniden adlandır
           # ESKİ isim             # YENİ isim
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # sütunu sil
    select(-c(row_num, merged_header, x28)) %>% 
  
    # tekilleştir
    distinct() %>% 

    # sütun ekle
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     

    # sütun sınıfını değiştir
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) %>% 
    
    # sütun ekleme: yatışta gecikme
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 
    
    # hastane sütununun temiz değerleri
    mutate(hospital = recode(hospital,
                      # ESKİ = İSİM
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

    # age_years sütunu oluştur (age ve age_unit'ten)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age)) %>% 
  
    mutate(
          # yaş kategorileri: özel
          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),
        
          # yaş kategorileri: 0-85 arası, 5’erli 
          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5))) %>% 
    
    # YUKARIDAKİ TEMİZLİK ADIMLARI ZATEN TARTIŞILMIŞTIR
    ###################################################
    filter(
          # sadece case_id'nin eksik olmadığı satırları tut
          !is.na(case_id),  
          
          # ayrıca yalnızca ikinci salgını tutmak için filtreleyin
          date_onset > as.Date("2013-06-01") | (is.na(date_onset) & !hospital %in% c("Hospital A", "Hospital B")))
```







<!-- AYNI SATIR KODLARI 8 KERE FALAN TEKRARLANMIŞ. ANLAM VEREMEDİM, SADELEŞTİRİLEBİLİR SONRAKİ VERSİYONLARDA-çağrı======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
## Satır tabanlı hesaplamalar  

Bir satır içinde bir hesaplama yapmak istiyorsanız, dplyr'den rowwise() fonksiyonuni kullanabilirsiniz. [Satır bazında hesaplamalar için bu çevrimiçi gösterime](https://cran.r-project.org/web/packages/dplyr/vignettes/rowwise.html) bakabilirsiniz.

Örneğin, bu kod rowwise() komutunu uygular ve ardından satır listesindeki her satır için "evet" değerine sahip belirtilen semptom sütunlarının sayısını toplayan yeni bir sütun oluşturur. Sütunlar, bir c() vektörü içinde adlarıyla sum() içinde belirtilir. rowwise() aslında özel bir group_by() türüdür, bu nedenle işiniz bittiğinde ungroup() komutunu kullanmak en iyisidir [verileri gruplandırma sayfasınd].


```{r,}
linelist %>%
  rowwise() %>%
  mutate(num_symptoms = sum(c(fever, chills, cough, aches, vomit) == "yes")) %>% 
  ungroup() %>% 
  select(fever, chills, cough, aches, vomit, num_symptoms) # gösterim için
```

  
Değerlendirilecek sütunu belirlerken, bu sayfanın select() bölümünde açıklanan “tidyselect” yardımcı fonksiyonlarını kullanmak isteyebilirsiniz. Sadece bir ayarlama yapmanız gerekir (çünkü bunları select() veya summarise() gibi bir dplyr fonksiyonunda kullanmıyorsunuz).

Sütun belirtim ölçütlerini dplyr fonksiyonu c_across() içine koyun. Bunun nedeni, c_across'un ([belgeler](https://dplyr.tidyverse.org/reference/c_across.html)) özellikle rowwise() ile çalışmak üzere tasarlanmış olmasıdır. Örneğin, aşağıdaki kod: 

• rowwise() uygular, böylece her satırda aşağıdaki işlem (sum()) uygulanır (tüm sütunları toplamaz)
• Yeni sütun num_NA_dates oluşturur, her satır için is.na() öğesinin DOĞRU olarak değerlendirildiği sütun sayısı tanımlanır.
• sonraki adımlar için rowwise()'ın etkilerini kaldırmak için grubu çözmek gerekir ungroup()


```{r,}
linelist %>%
  rowwise() %>%
  mutate(num_NA_dates = sum(is.na(c_across(contains("date"))))) %>% 
  ungroup() %>% 
  select(num_NA_dates, contains("date")) # gösterim için
```

Her satır için en son veya en son tarihi almak için max() gibi başka fonksiyonlar da uygulayabilirsiniz:

```{r}
linelist %>%
  rowwise() %>%
  mutate(latest_date = max(c_across(contains("date")), na.rm=T)) %>% 
  ungroup() %>% 
  select(latest_date, contains("date"))  # gösterim için
```


## Düzenle ve sıraya diz 

Satırları sütun değerlerine göre sıralamak veya sıralamak için dplyr fonksiyonu arrange()'i kullanın.

Sütunları gereken sırayla basit bir şekilde listeleyin. Sıralamanın önce verilere uygulanan herhangi bir gruplandırma tarafından yapılmasını istiyorsanız .by_group = argümanını  DOĞRU belirtin (bkz. Verileri gruplama sayfası).

Varsayılan olarak, sütun "artan" düzende sıralanır (sayısal ve ayrıca karakter sütunları için geçerlidir). Bir değişkeni desc() fonksiyonu ile sararak "azalan" düzende sıralayabilirsiniz.

Verileri arrange () ile sıralamak, sunum için tablolar hazırlarken, grup başına "üst" satırları almak için slice() kullanırken veya görünüm sırasına göre faktör düzeyi sırasını ayarlarken özellikle yararlıdır.

Örneğin, satır listesi satırlarımızı hastaneye göre, ardından azalan düzende date_onset'e göre sıralamak için şunu kullanırız:


```{r, eval=F}
linelist %>% 
   arrange(hospital, desc(date_onset))
```


```{r, echo=F}
# HIDDEN
#
# kolaylık sağlamak için kalan bir eski salgın satırını eksik hale dönüştürün
linelist <- linelist %>% 
  mutate(
    date_hospitalisation = case_when(
      date_hospitalisation < as.Date("2013-01-01") ~ as.Date(NA),
      TRUE                                         ~ date_hospitalisation),
    date_outcome = case_when(
      date_outcome < as.Date("2013-01-01") ~ as.Date(NA),
      TRUE                                 ~ date_outcome)
    )

#min(linelist$date_hospitalisation, na.rm=T)
#min(linelist$date_outcome, na.rm=T)
```



```{r echo=F}
# dışa aktarmak için yeniden düzenleyin
linelist <- linelist %>% 
  select(case_id:gender, age, age_unit, age_years, age_cat, age_cat5, everything())
```

```{r echo=F}
# TEMİZLENMİŞ LINELIST DOSYASINI "VERİ" KLASÖRÜNE AKTARIN
rio::export(linelist, here::here("data", "case_linelists", "linelist_cleaned.xlsx"))
rio::export(linelist, here::here("data", "case_linelists", "linelist_cleaned.rds"))
```
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/cleaning.Rmd-->


# Tarihlerle çalışma {}


```{r, out.width=c('50%'), fig.align='center', echo=F, message=F}
knitr::include_graphics(here::here("images", "Dates_500x500.png"))
```


R'da tarihlerle çalışmak, diğer nesne sınıflarıyla kıyasla daha fazla dikkat etmeyi gerektirmektedir. Aşağıda, bu süreci daha az acı verici hale getirmek için bazı araçlar ve örnekler sunacağız Neyse ki, tarihler pratikle ve **lubridate** gibi bir dizi yardımcı paketle kolayca yönetilebilir.

Ham veriler içe aktarıldığında R genellikle tarihleri karakter nesneleri olarak yorumlamaktadır - bu, zaman serilerini hazırlamak ve zaman aralıklarını hesaplamak gibi genel tarih işlemleri için kullanılamayacakları anlamına gelmektedir. İşleri daha da zorlaştırmak adına, bir tarihin biçimlendirilmesinin birden çok yolu vardır ve bunun için R'ın bir tarihin hangi bölümünün neyi temsil ettiğini (ay, gün, saat, vb.) bilmesine yardımcı olmalısınız. 

R'daki tarihler özgün nesne sınıflarıdır - 'Date' sınıfı. Bu sınıf ayrıca gün *ve* saat nesnelerini saklayan bir sınıftır. Tarih, saat nesneleri resmi olarak 'POSIXt', 'POSIXct' ve/veya 'POSIXlt' sınıfları olarak adlandırılır (aralarındaki fark önemli değildir). Bu nesnelere gayri resmi olarak *datetime* sınıfları denir.

* Bir sütun tarih içerdiğinde R'nin bunu tanımasını sağlamak önemlidir.  
* Tarihler bir nesne sınıfıdır ve üzerinde çalışmak zor olabilir.
* Burada tarih sütunlarını Date sınıfına dönüştürmenin birkaç yolunu sunuyoruz. 


<!-- ======================================================= -->
## Hazırlık

### Paketleri yüklemek {.unnumbered}  

Aşağıdaki kod parçası, bu sayfa için gerekli olan paketlerin yüklenmesini göstermektedir. Bu el kitabında, gerekirse paketi kuran *ve* kullanım için yükleyen **pacman**'dan `p_load()` fonksiyonuna vurgulamaktayız. **base** R'dan `library()` ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakınız. 

```{r dates_packages, warning=F, message=F}
# Paketin kurulu olup olmadığını kontrol eder, gerekirse kurar ve mevcut oturum için paketi yükler

pacman::p_load(
  lubridate,  # tarihlerin işlenmesi ve dönüştürülmesi için genel paket 
  linelist,   # dağınık tarihleri "tahmin etme" işlevi sağlar
  aweek,      # tarihleri haftalara ve haftaları tarihe dönüştürmek için alternatif bir seçenek
  zoo,        # ek tarih/saat işlevleri
  tidyverse,  # veri yönetimi ve görselleştirme 
  rio)        # veri içe/dışa aktarma
```

### Verileri içe aktarma {.unnumbered}  

Simüle edilmiş bir Ebola salgını ile ilişkili vakaların veri setini içe aktarıyoruz. Adım adım izlenecek verileri indirmek istiyorsanız, [El kitabını ve verileri indir] sayfasındaki talimatlara bakınız. İlgili dosyaların çalışma dizininde olduğunu varsayıyoruz, bu nedenle bu dosya yolunda hiçbir alt klasör belirtilmemiştir.

```{r,  echo=F}
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

```

```{r, eval=F}
linelist <- import("linelist_cleaned.xlsx")

```



<!-- ======================================================= -->
## Güncel tarih

**base** R ile aşağıdaki işlemleri tamamlayarak bilgisayarınızın güncel "sistem" tarihini veya sistem tarih saatini görebilirsiniz. 

```{r}
# sistem tarihini al - bu bir DATE sınıfıdır
Sys.Date()

# sistem saatini al - bu bir DATETIME sınıfıdır
Sys.time()
```


**lubridate** paketi ile bu fonksiyonlar, sırasıyla 'today()' ve 'now()' ile de elde edilebilir. `date()`, haftanın günü ve ay adlarıyla birlikte geçerli tarih ve saati vermektedir.  
  
  

<!-- ======================================================= -->
## Tarihe Dönüştürme 

Bir veri kümesini R'a aktardıktan sonra, tarih sütunu değerleri "1989/12/30", "05/06/2014" veya "13 Ocak 2020" gibi görünebilir. Bu durumlarda, R muhtemelen bu değerleri hala karakter değerleri olarak ele alıyordur. R'a bu değerlerin tarih olduğu *söylenmelidir* - tarih formatının ne olduğu (hangi kısım Gün, hangisi Ay, hangisi Yıl vb.). 

Gerekli formatlar tanımlandığında, R bu değerleri Date sınıfına dönüştürür. Arka planda R, tarihleri sayı olarak saklayacaktır ("başlangıç" tarihi 1 Ocak 1970'den itibaren gün sayısı). Tarih numarasını büyük bir ihtimalle arayüzde ve hesaplamalarda kullanmayacaksınız, ancak bu, R'ın tarihleri sürekli değişkenler olarak ele almasına ve tarihler arasındaki mesafeyi hesaplama gibi özel işlemlerde kullanmasına izin verir.  

Varsayılan olarak, R'daki Date sınıfının değerleri YYYY-AA-GG olarak görüntülenmektedir. Bu bölümün ilerleyen kısımlarında, tarih değerlerinin görüntüsünün nasıl değiştirilebileceğini paylaşacağız

Aşağıda, bir sütunu karakter değerlerinden Date sınıfına dönüştürmek için iki yaklaşım sunmaktayız. 


<span style="color: darkgreen;">**_İPUCU:_** Bir sütunun geçerli sınıfını **base** R fonksiyonu olan `class()` ile kontrol edebilirsiniz, örneğin `class(linelist$date_onset)`.</span>  

  

### **base** R {.unnumbered}  

`as.Date()`, bir nesneyi veya sütunu Date sınıfına dönüştürmek için standart, **temel** R fonksiyonudur. ("D" harfinin büyük harf kullanımına dikkat ediniz).  

`as.Date()` kullanımı aşağıdaki koşulları içermektedir:  

* Ham karakter tarihinin **mevcut** formatını veya tarihleri sayı olarak veriyorsanız *başlangıç tarihini* belirtirmelisiniz (Excel tarihleriyle ilgili bölüme bakınız)  
* Eğer bir karakter sütununda kullanılıyorsa, tüm tarih değerleri aynı formata sahip olmalıdır (eğer durum böyle değilse, **linelist** paketinden `guess_dates()` deneyebilirsiniz)

**İlk olarak**, sütununuzun sınıfını **base** R'den `class()` fonksiyonu ile kontrol edin. Verilerinizin sınıfı hakkında emin değilseniz veya kafanız karıştıysa (örneğin, "POSIXct" vs. görüyorsanız) ilk adım olarak formatı sıfırlamak kolay bir strateji olabilir. Bunun için sütunu `as.character()` fonksiyonu ile Karakter sınıfına ve ardından onu Date sınıfına dönüştürebilirsiniz. 

**İkinci olarak**, 'as.Date()' fonksiyonu içinde, R'a karakter tarih bileşenlerinin *geçerli* biçimini - hangi karakterlerin ay, gün ve yılı ifade ettiğini ve bunların nasıl ayrıldığını belirtmek için 'format =' bağımsız değişkenini kullanabilirsiniz. Değerleriniz zaten R'ın standart tarih biçimlerinden ("YYYY-AA-GG" veya "YYYY/AA/GG") biriyse, "format =" bağımsız değişkeni gerekli değildir.

`format =` için, aşağıdaki özel "strptime" kısaltmalarını kullanarak *geçerli* tarih biçimini temsil eden bir karakter dizisi (tırnak içinde) sağlamalısınız. Örneğin, karakter tarihleriniz şu anda "24/04/1968" gibi "GG/AA/YYYY" biçimindeyse, o zaman karakteri dönüştürmek için `format = "%d/%m/%Y"` kullanabilirsiniz. İlgili değerler tarihlere dönüştürülecektir. **Formatı tırnak içine almanız gerekmektedir. Eğik çizgi veya kısa çizgileri de eklemeyi unutmayın!**

```{r eval=F}
# Date sınıfına çevir
linelist <- linelist %>% 
  mutate(date_onset = as.Date(date_of_onset, format = "%d/%m/%Y"))
```

strptime kısaltmalarının çoğu aşağıda listelenmiştir. `?strptime` komutunu çalıştırarak tam listeyi görebilirsiniz.

%d = Aydaki gün (5, 17, 28, vb.)  
%j = Yıl-gün numarası (Julian günü 001-366)  
%a = Kısaltılmış gün (Pt, sa, Çar, vb.)  
%A = Tam gün (Pazartesi, Salı, vb.)
%w = Gün sırası (0-6, Pazar 0'dır)  
%u = Gün sırası (1-7, Pazartesi 1'dir)  
%W = Hafta sırası (00-53, Pazartesi haftanın ilk günüdür)  
%U = Hafta sırası (01-53, Pazar haftanın ilk günüdür)  
%m = Ay sırası (örn. 01, 02, 03, 04)  
%b = Kısaltılmış ay (Oca, Şub, vb.)  
%B = Tam ay (Ocak, Şubat, vb.)  
%y = 2-basamak yıl  (örn. 89)  
%Y = 4-basamak yıl  (örn. 1989)  
%h = saat (24-saat)  
%m = dakika  
%s = saniye
%z = GMT farkı
%Z = Saat dilimi (karakter)  

<span style="color: darkgreen;">**_İPUCU:_** 'as.Date()' fonksiyonun 'format =' argümanı, R'a tarihlerin olmasını istediğiniz biçimi *söylemez*, bunun yerine tarih bölümlerini siz komutu çalıştırmadan *önce* oldukları gibi nasıl tanımlayacağınızı söyler.</span>  

<span style="color: darkgreen;">**_İPUCU:_** "format =" bağımsız değişkeninde tarihlerinizde bulunan *tarih-ayracı* (ör. /, - veya boşluk) kullandığınızdan emin olun.</span>  

Değerler Date sınıfında olduğunda, R varsayılan olarak bunları YYYY-AA-GG olan standart biçimde görüntüler.



### **lubridate** {.unnumbered}  

**lubridate** paketi kullanılarak karakter nesnelerinin tarihlere dönüştürülmesi daha kolay hale getirilebilir. Bu, tarih ve saatlerle çalışmayı **base** R'dan daha basit ve tutarlı hale getirmek için tasarlanmış bir **tidyverse** paketidir. **lubridate** genellikle tarihler ve saatler için altın standart paket olarak kabul edilmektedir. Tarih hesaplamalarında bu paketle çalışmanızı tavsiye etmekteyiz.

**lubridate** paketi, karakter nesnelerini 'as.Date()' biçiminde belirtmekten daha kolaydır. Paket tarihleri dönüştürmek için tasarlanmış birkaç farklı yardımcı fonksiyon sağlamaktadır. Bu fonksiyonlar çoğunlukla, kaba tarih biçimine özgüdür. Ancak tarihler için çeşitli ayırıcılara ve eş anlamlı tabirlerin kullanılmasına izin verir (ör. 01 - Oca - Ocak) - bunlar, tarih biçimlerinin kısaltmalarından sonra tanımlanır.


```{r, }
# lubridate paketini indirip/yükler 
pacman::p_load(lubridate)
```

'ymd()' fonksiyonu, **yıl, sonra ay, sonra gün** olarak sağlanan tarih değerlerini esnek bir şekilde dönüştürür.

```{r}
# tarihi yıl-ay-gün biçiminde okur
ymd("2020-10-11")
ymd("20201011")
```

`mdy()` fonksiyonu, **ay, sonra gün, sonra yıl** olarak sağlanan tarih değerlerini esnek bir şekilde dönüştürür.  

```{r}
# tarihi ay-gün-yıl biçiminde okur
mdy("10/11/2020")
mdy("Oct 11 20")
```

`dmy()` fonksiyonu, **gün, sonra ay, sonra yıl** olarak sağlanan tarih değerlerini esnek bir şekilde dönüştürür.

```{r}
# tarihi gün-ay-yıl biçiminde okur
dmy("11 10 2020")
dmy("11 October 2020")
```

<!-- The `as.character()` and `as.Date()` commands can optionally be combined as:   -->

<!-- ```{r eval=F} -->
<!-- linelist_cleaned$date_of_onset <- as.Date(as.character(linelist_cleaned$date_of_onset), format = "%d/%m/%Y") -->
<!-- ``` -->

Tünelleme kullanılıyorsa, bir karakter sütununun **lubridate** ile tarihlere dönüştürülmesi şöyle görünebilir:

```{r, eval=F}
linelist <- linelist %>%
  mutate(date_onset = lubridate::dmy(date_onset))
```

İşlemler tamamlandığında, sütunun sınıfını doğrulamak için `class()` komutunu çalıştırabilirsiniz.

```{r, eval=F}
# Sütunun sınıfını kontrol edin
class(linelist$date_onset)  
```


Değerler Date sınıfında olduğunda, R varsayılan olarak bunları YYYY-AA-GG olan standart biçimde görüntüler. 

Yukarıdaki fonksiyonların 4 basamaklı yıllarda en verimli şekilde çalıştığını unutmayın. **lubridate** yüzyılı tahmin etmeye çalıştığı için 2 basamaklı yıllar beklenmedik sonuçlar üretebilmektedir.

2 basamaklı bir yılı 4 basamaklı bir yıla dönüştürmek için (tümü aynı yüzyılda) sınıf karakterine dönüştürebilir ve ardından **stringr** paketinden (bkz. [Karakterler ve dizeler]) `str_glue()` fonksiyonu kullanarak mevcut rakamları bir ön ek ile birleştirebilirsiniz. Ardından tarihe dönüştürebilirsiniz.

```{r}
two_digit_years <- c("15", "15", "16", "17")
str_glue("20{two_digit_years}")
```



### Sütunları birleştirme {.unnumbered}  

Birden çok sütunu tek bir tarih sütununda birleştirmek için `make_date()` ve `make_datetime()` **lubridate** fonksiyonlarını kullanabilirsiniz. Örneğin, "linelist" veri formatında `onset_day`, `onset_month` ve `onset_year` sütunlarınız mevcutsa: 

```{r, eval=F}
linelist <- linelist %>% 
  mutate(onset_date = make_date(year = onset_year, month = onset_month, day = onset_day))
```




<!-- ======================================================= -->
## Excel tarihleri

Arka planda, çoğu yazılım, tarihleri sayı olarak kaydeder. R 1 Ocak 1970 tarihini başlangıç tarihi olarak ele almaktadır. Bu nedenle, `as.numeric(as.Date("1970-01-01))` komutunu çalıştırırsanız `0` sonucunu elde edersiniz.

Microsoft Excel, işletim sisteminize bağlı olarak 30 Aralık 1899 (Windows) veya 1 Ocak 1904 (Mac) tarihleri başlangıç tarihi olarak depolamaktadır. Detaylar için [Microsoft rehberini](https://docs.microsoft.com/en-us/office/troubleshoot/excel/1900-and-1904-date-system) inceleyebilirsiniz.  

Excel tarihleri genellikle R'a karakter yerine sayısal değerler olarak aktarılmaktadır. Excel'den içe aktardığınız veri kümesi, tarihleri sayı veya "41369" gibi karakterler olarak gösteriyorsa bunları istenilen formata dönüştürmek için `as.Date()` (veya **lubridate**'nin `as_date()` işlevini) kullanabilirsiniz. Ancak **yukarıdaki gibi bir "formatı" tanımlamak** yerine, `origin = ` argümanıyla Excel başlangıç tarihini R'a bildirebilirsiniz.  

Excel tarihi bir Karakter türü olarak R'a aktarılmışsa bu fonksiyon işe yaramaz, bu nedenle sayının Numeric sınıfında olduğundan emin olun!

<span style="color: black;">**_NOT:_** Başlangıç tarihini R'ın varsayılan tarih biçiminde ("YYYY-AA-GG") formatlamalısınız.</span>

```{r, eval = FALSE}
# Exceldeki sayı formatındaki tarihleri dönüştürürken Excel 'başlangıç tarihi' sağlamaya ilişkin bir örnek
data_cleaned <- data %>% 
  mutate(date_onset = as.numeric(date_onset)) %>%   # sınıfın numeric olduğundan emin olun
  mutate(date_onset = as.Date(date_onset, origin = "1899-12-30")) # Excel orijinini kullanarak tarih formatına dönüştürme
```



<!-- ======================================================= -->
## Karışık tarihler  

**parsedate** paketindeki `parse_dates()` fonksiyonu, birçok farklı biçimde tarihleri içeren "dağınık" bir tarih sütununu okumaya ve tarihleri standart bir biçime dönüştürmeye çalışır. [`parse_date()` hakkında daha fazla bilgiyi için bakınız](https://readr.tidyverse.org/reference/parse_datetime.html).  

Örneğin, `parse_dates()`, "03 Oca 2018", "07/03/1982" ve "08/20/85" karakter tarihlerinin bir vektörünü görür ve bunları Date sınıfına dönüştürür: '2018-01-03 ', '1982-03-07' ve '1985-08-20'.  

```{r, }
parsedate::parse_date(c("03 Janry 18",
                        "07/03/1982",
                        "8-20-1985"))
```


```{r eval = FALSE}
# dater_onset sütununda parse_date() kullanan bir örnek
linelist <- linelist %>%      
  mutate(date_onset = parse_date(date_onset))
```




<!-- ======================================================= -->
## Date-time sınıfı ile çalışma 

Daha önce belirtildiği gibi, R ek olarak `datetime` sınıfını desteklemektedir - tarih **ve** saat bilgilerini içeren bir sütun. "Date" sınıfında olduğu gibi, bu verilerin genellikle `karakter` nesnelerinden `datetime` nesnelerine dönüştürülmesi gerekmektedir.

### Tarihleri saatlerle dönüştürme {.unnumbered}  

Standart bir "datetime" nesnesi önce tarihle, ardından bir saat bileşeniyle biçimlendirilir - örneğin _01 Ocak 2020, 16:30_. Tarihlerde olduğu gibi, bun durumun biçimlendirilmesinin ve kesinlik düzeyinin (saat, dakika, saniye) tanımlanmasının bir çok yolu mevcuttur.  

Neyse ki, bu dizeleri 'datetime' nesnelerine dönüştürmeye yardımcı olmak için **lubridate** paketinin yardımcı fonksiyonları mevcuttur. Bu fonksiyonların, sonuna "_h" (saati tanımlar), "_hm" (saat ve dakikayı tanımlar) veya "_hms" (saat, dakika ve saniyeyi tanımlar) uzantıları eklenebilir (örn. dmy_hms()`). Aşağıda bu uzantıların kullanımı için örnekler verilmiştir.

Yalnızca saat bilgisi olan datetime verilerini datetime nesnesine dönüştürme:

```{r}
ymd_h("2020-01-01 16hrs")
ymd_h("2020-01-01 4PM")
```

Saat ve dakika bilgisi olan datetime verilerini datetime nesnesine dönüştürme:

```{r}
dmy_hm("01 January 2020 16:20")
```

Saat, dakika ve saniye bilgisi olan datetime verilerini datetime nesnesine dönüştürme:

```{r}
mdy_hms("01 January 2020, 16:20:40")
```

Saat dilimini formata ekleyebilirsiniz ancak bu bilgi yok sayılmaktadır. Daha detaylı bilgi için ilerleyen bölümlerdeki saat dilimleri bölümüne bakınız. 

```{r}
mdy_hms("01 January 2020, 16:20:40 PST")

```

Bir veri çerçevesiyle çalışırken, **stringr** paketinden `str_glue()` fonksiyonu ve uygun bir **lubridate** fonksiyonu kullanılarak saat ve tarih sütunları birleştirilebilir. **stringr** ile ilgili ayrıntılar için [Karakterler ve dizeler] hakkındaki sayfaya bakınız.

Bu örnekte, "linelist" veri çerçevesi "saat:dakika" biçiminde bir sütuna sahiptir. Bunu bir datetime formatına dönüştürmek için aşağıdaki adımları izleyebiliriz:

1) Eksik verileri medyan sütunlarından elde edilen verilerle tamamlanmış, "temiz" bir hasta kabul sütunu oluşturun. Bunu yapıyoruz çünkü **lubridate** eksik değerler üzerinde çalışmayacaktır. Bunu "date_hospitalisation" sütunuyla birleştirin ve ardından istenilen formata dönüştürmek için "ymd_hm()" işlevini kullanın. 

```{r, eval = FALSE}
# paketler
pacman::p_load(tidyverse, lubridate, stringr)

# time_admission, saat:dakika cinsinden bir sütundur
linelist <- linelist %>%
  
  # uygun saat bulunamadığında, medyan kabul süresini atama
  mutate(
    time_admission_clean = ifelse(
      is.na(time_admission),         # zaman eksikse
      median(time_admission),        # medyan ata
      time_admission                 # eksik değilse olduğu gibi tut
  ) %>%
  
    # bir karakter sütunu oluşturmak üzere tarih ve saat sütunlarını birleştirmek için str_glue() fonksiyonunu kullanın
    # ve sonra onu tarih saatine dönüştürmek için ymd_hm() fonksiyonunu kullanın
  mutate(
    date_time_of_admission = str_glue("{date_hospitalisation} {time_admission_clean}") %>% 
      ymd_hm()
  )

```

### Sadece saatleri çevirme {.unnumbered}  

Verileriniz yalnızca bir karakter süresi (saat ve dakika) içeriyorsa, **base** R'dan `strptime()` kullanarak bunları zaman formatına dönüştürebilir ve değiştirebilirsiniz. Örneğin, bu iki süre arasındaki farkı elde etmek için:


```{r}
# ham karakter süreleri
time1 <- "13:45" 
time2 <- "15:20"

# Datetime sınıfına dönüştürülen zamanlar
time1_clean <- strptime(time1, format = "%H:%M")
time2_clean <- strptime(time2, format = "%H:%M")

# Fark, varsayılan olarak "difftime" sınıfındadır, burada sayısal saatlere dönüştürülür
as.numeric(time2_clean - time1_clean)   # saat farkı

```

Bununla birlikte, herhangi bir tarih değerine ulaşılamazsa, tarihin bugün olduğunu varsayıldığını unutmayın. Bir tarih harf dizisini ve bir zamanı harf dizisiyle birleştirmek için, hemen yukarıdaki bölümde **stringr**'nin nasıl kullanılacağına bakınız. `strptime()` hakkında daha fazla bilgiyi [buradan](https://rdrr.io/r/base/strptime.html) okuyabilirsiniz.

Tek basamaklı sayıları çift basamaklı sayılara dönüştürmek için (ör. 2 basamak elde etmek için baştaki sıfırlarla birlikte saat veya dakika formatına), [Karakterler ve dizeler sayfasının "Taban uzunluğu" bölümüne](#str_pad) bakınız.

### Saati ayıklama {.unnumbered}  

Bir zamanın alt öğelerini **lubridate**'paketinden 'hour()', 'minute()' veya 'second()' fonksiyonu ile seçebilirsiniz.

Saatin ayıklanması ve ardından günün bölümlerine göre sınıflandırılmasına bir örnek verilmesi gerekirse: "SS:DD" biçimindeki Karakter sınıfı olan `time_admission` sütununu göz önüne alalım.  İlk olarak, karakterleri datetime sınıfına dönüştürmek için yukarıda açıklandığı gibi `strptime()` fonksiyonu kullanılır. Daha sonra saat, 0-24 arasında bir sayı döndürerek `hour()` fonksiyonu ile çıkarılır. Son olarak, satırları giriş saatlerine göre Sabah/Öğleden sonra/Akşam/Gece olarak sınıflandırmak için `case_while()` mantığı kullanılarak bir 'time_period' sütunu oluşturulur.

```{r}
linelist <- linelist %>%
  mutate(hour_admit = hour(strptime(time_admission, format = "%H:%M"))) %>%
  mutate(time_period = case_when(
    hour_admit > 06 & hour_admit < 12 ~ "Morning",
    hour_admit >= 12 & hour_admit < 17 ~ "Afternoon",
    hour_admit >= 17 & hour_admit < 21 ~ "Evening",
    hour_admit >=21 | hour_admit <= 6 ~ "Night"))
```

`case_while()` hakkında daha fazla bilgi edinmek için [Temizleme verileri ve temel işlevler] hakkındaki sayfaya bakınız.

<!-- ======================================================= -->
## Tarihlerle çalışma   

`lubridate` aynı zamanda **date/datetime özelliklerini çıkarma**, **tarih aritmetiği gerçekleştirme** veya **tarih aralıklarını hesaplama** gibi çeşitli başka işlevler için de kullanılabilir.

Burada örnekler için kullanılacak bir tarih tanımlayacağız: 

```{r, }
# Date sınıfının nesnesini oluşturma
example_date <- ymd("2020-03-01")
```

### Tarih bileşenlerini ayıklama {.unnumbered}  

Ay, gün, hafta içi gibi ortak yönleri çıkarabilirsiniz: 

```{r}
month(example_date)  # ay numarası
day(example_date)    # ayın günü (sayı)
wday(example_date)   # haftanın gün sayısı (1-7)
```

Ayrıca bir `datetime` nesnesinden veya sütunundan saat bileşenlerini de çıkarabilirsiniz. Bu durum, özellikle başvuru saatlerinin dağılımını görmek istiyorsanız yararlı olabilir.

```{r, eval=F}
example_datetime <- ymd_hm("2020-03-01 14:45")

hour(example_datetime)     # saati ayıklama
minute(example_datetime)   # dakikayı ayıklama
second(example_datetime)   # saniyeyi ayıklama
```

Hafta bilgilerini ayıklamak için birkaç seçenek vardır. Aşağıdaki Epidemiyolojik haftalar bölümüne bakın.

Bir tarihi belirli bir şekilde *görüntülemek* istiyorsanız (örneğin, "Ocak 2020" veya "20 Mart Perşembe" veya "20. Hafta, 1977") bunu Tarihi görüntüleme bölümünde açıklandığı gibi daha esnek bir şekilde yapabilirsiniz.


### Tarih matematiği {.unnumbered}  

**lubridate**'deki ilgili fonksiyonları kullanarak belirli sayıda gün veya hafta ekleyebilirsiniz.

```{r}
# bu tarihe 3 gün ekleyin
example_date + days(3)
  
# 7 hafta ekleyin ve bu tarihten iki gün çıkarın
example_date + weeks(7) - days(2)
```

### Tarih aralıkları {.unnumbered}  

Tarihler arasındaki fark şu şekilde hesaplanabilir:

1. Her iki tarihin de Date sınıfına ait olduğundan emin olun 
2. İki tarih arasındaki "zaman farkını (difftime)" elde etmek için çıkarma işlemini kullanın  
3. Gerekirse, sonraki matematiksel hesaplamaları yapmak için sonucu sayısal sınıfa dönüştürün

Aşağıdaki kodda iki tarih arasındaki aralığın hesaplanması ve görüntülenmesi verilmiştir. Date sınıfındaki değerlerde çıkarma (eksi) işareti ile aralıkları bulabilirsiniz. Ancak, döndürülen değerin sınıfının aşağıda gösterildiği gibi "difftime" olduğunu ve sayısala dönüştürülmesi gerektiğini unutmayın. 

```{r}
# bu tarih ile 20 Şubat 2020 arasındaki aralığı bulun
output <- example_date - ymd("2020-02-20")
output    # yazdır
class(output)
```

Bir "difftime" üzerinde sonraki işlemleri yapmak için, onu `as.numeric()` ile sayısal değere dönüştürmelisiniz.

Bunların hepsi verilerle çalışmak için bir araya getirilebilir - örneğin:

```{r, eval = F}
pacman::p_load(lubridate, tidyverse)   # paketleri yükleme

linelist <- linelist %>%
  
  # dmy biçimini belirterek başlangıç tarihini, karakterden tarih nesnelerine dönüştürün
  mutate(date_onset = dmy(date_onset),
         date_hospitalisation = dmy(date_hospitalisation)) %>%
  
  # Mart ayında başlamayan tüm vakaları filtreleyin
  filter(month(date_onset) == 3) %>%
    
  # başlangıç ve hastaneye yatış arasındaki gün farkını bulun
  mutate(days_onset_to_hosp = date_hospitalisation - date_of_onset)
```

Bir veri çerçevesi bağlamında, yukarıdaki tarihlerden biri eksikse, o satır için işlem başarısız olur. Sonuç, sayısal bir değer yerine bir "NA" olarak verilecektir. Bu sütunu hesaplamalar için kullanırken, `na.rm = ` bağımsız değişkenini `TRUE (DOĞRU)` olarak ayarladığınızdan emin olun. Örneğin:

```{r, eval = FALSE}
# verilerin mevcut olduğu tüm vakalar için; hastaneye yatışa kadar geçen medyan gün sayısını hesaplama
median(linelist_delay$days_onset_to_hosp, na.rm = T)
```


<!-- ======================================================= -->
## Tarihi gösterme

Tarihler doğru sınıfta formatlandığında; farklı şekilde görüntülenmelerini isteyebilir (örneğin "2018-01-05" yerine "05 Ocak Pazartesi"), satırları tarih öğelerine göre gruplandırabilir (örneğin ay-yıla göre gruplandırma) gösterilme sırasını istediğiniz gibi düzenleyebilirsiniz.

### `format()` {.unnumbered}  

Tarih gösterimini **base** R fonksiyonu olan `format()` ile ayarlayabilirsiniz. Bu fonksiyon, "%" strptime kısaltmalarında *istenen* çıktı biçimini belirten bir karakter dizesini (tırnak içinde) argüman olarak kabul etmektedir.- (`as.Date()` içinde kullanılanla benzer sözdizimi). Aşağıda yaygın olarak kullanılan kısaltmaların çoğu verilmiştir.

Not: `format()` fonksiyonunu kullanmak değerleri Karakter sınıfına dönüştürür, bu nedenle bu genellikle bir analizin sonuna doğru veya yalnızca görüntüleme amacıyla kullanılır! `?strptime` komutunu çalıştırarak tam listeyi görebilirsiniz.

%d = Aydaki gün (5, 17, 28, vb.)  
%j = Yıl-gün numarası (Julian günü 001-366)  
%a = Kısaltılmış gün (Pt, sa, Çar, vb.)  
%A = Tam gün (Pazartesi, Salı, vb.)
%w = Gün sırası (0-6, Pazar 0'dır)  
%u = Gün sırası (1-7, Pazartesi 1'dir)  
%W = Hafta sırası (00-53, Pazartesi haftanın ilk günüdür)  
%U = Hafta sırası (01-53, Pazar haftanın ilk günüdür)  
%m = Ay sırası (örn. 01, 02, 03, 04)  
%b = Kısaltılmış ay (Oca, Şub, vb.)  
%B = Tam ay (Ocak, Şubat, vb.)  
%y = 2-basamak yıl  (örn. 89)  
%Y = 4-basamak yıl  (örn. 1989)  
%h = saat (24-saat)  
%m = dakika  
%s = saniye
%z = GMT farkı
%Z = Saat dilimi (karakter)

Bugünün tarihini biçimlendirmeye bir örnek olarak:

```{r}
# bugünün tarihi, biçimlendirme ile
format(Sys.Date(), format = "%d %B %Y")

# tam tarih ve saati almanın kolay yolu (varsayılan biçimlendirme)
date()

# str_glue() fonksiyonunu kullanarak biçimlendirilmiş birleşik tarih, saat ve saat dilimi
str_glue("{format(Sys.Date(), format = '%A, %B %d %Y, %z  %Z, ')}{format(Sys.time(), format = '%H:%M:%S')}")

# Haftaları görüntüleme formatını kullanma
format(Sys.Date(), "%Y Week %W")
```

`str_glue()` fonksiyonunu kullanıyorsanız, sözdizimi formatındaki çift tırnak içinde (") yalnızca tek tırnak kullanmanız gerektiğini unutmayın (yukarıdaki örnekte verildiği gibi).


### Ay-Yıl {.unnumbered}  

Bir Date sütununu Ay-yıl biçimine dönüştürmek için, **zoo** paketindeki `as.yearmon()` işlevini kullanmanızı öneririz. Bu, tarihi "yearmon" sınıfına dönüştürür ve uygun sıralamayı korur. Buna karşılık, `format(column, "%Y %B")` fonksiyonunun kullanılması, değerleri Karakter sınıfına dönüştürecek ve değerleri alfabetik olarak (yanlış) sıralayacaktır.

Aşağıda, "as.yearmon()" fonksiyonu kullanılarak "date_onset" sütunundan yeni bir "yearmonth" sütunu oluşturulmuştur. Elde edilen değerlerin varsayılan (doğru) sıralaması tabloda gösterilmiştir.

```{r}
# yeni sütun oluştur
test_zoo <- linelist %>% 
     mutate(yearmonth = zoo::as.yearmon(date_onset))

# tabloyu yazdır
table(test_zoo$yearmon)
```

Buna karşılık, aşağıdaki örnekte, `format()` fonksiyonu ile istenen görüntüleme biçimini verirken, ancak doğru sıralamayı nasıl sağlayamadığını görebilirsiniz.

```{r}
# yeni sütun oluştur
test_format <- linelist %>% 
     mutate(yearmonth = format(date_onset, "%b %Y"))

# tabloyu yazdır
table(test_format$yearmon)
```

Not: Bir `ggplot()` içinde çalışıyor ve sadece tarihlerin nasıl *görüntülendiğini* düzenlemek istiyorsanız, `scale_x_date()` fonksiyonu içindeki `date_labels =` argümanına bir strptime formatı sağlamak yeterli olabilir. Bunun için `"%b %Y"` veya `"%Y %b"` formatını kullanabilirsiniz. Detaylı bilgi için [ggplot ipuçları] sayfasına bakınız.  

**zoo** ayrıca `as.yearqtr()` fonksiyonuna da sahiptir ve `ggplot()` kullanırken `scale_x_yearmon()` fonksiyonunu da bu amaçla kullanabilirsiniz.


<!-- ======================================================= -->
## Epidemiyolojik haftalar {#dates_epi_wks}

### **lubridate** {.unnumbered}  

Verileri tarihlerine göre gruplandırmaya ilişkin daha kapsamlı örnekler için [Gruplama verileri] hakkındaki sayfaya bakınız. Aşağıda, verileri haftalara göre gruplandırmayı kısaca açıklamaktayız.

Genellikle, **lubridate** paketindeki `floor_date()` fonksiyonunu,  `unit = "week"` bağımsız değişkeniyle kullanmanızı önermekteyiz. Bu, `week_start = ` bağımsız değişkeniyle tanımlandığı gibi tarihi haftanın "başlangıcına" yuvarlar. Varsayılan hafta başlangıcı 1'dir (Pazartesiler için), ancak haftanın herhangi bir gününü başlangıç olarak belirtebilirsiniz (ör. Pazar günleri için 7). "floor_date()" çok yönlü bir fonksiyondur; `unit = ` öğesini "saniye (second)", "dakika (minute)", "saat (hour)", "gün (day)", "ay (month)" veya "yıl (year)" olarak ayarlayarak diğer zaman birimlerine yuvarlamak için kullanılabilir.

Döndürülen değer, Date sınıfında haftanın başlangıç tarihidir. Date sınıfı, ggplot() tarafından kolayca tanınacağı ve doğru şekilde sıralanacağı için verileri çizerken de gayet kolaylık sağlamaktadır.

Tarihleri bir grafikte yalnızca haftasına göre *görüntülemek* ile ilgileniyorsanız, bu sayfadaki Tarihi görüntüleme bölümüne bakınız. Örneğin, bir epicurve çizerken, istenen strptime "%" terminolojisini sağlayarak tarih görüntüsünü biçimlendirebilirsiniz. Örneğin, yıl ve hafta numarasını döndürmek için "%Y-%W" veya "%Y-%U" kullanabilirsiniz (sırasıyla Pazartesi veya Pazar haftanın ilk günü olarak kabul edilmektedir).

### Haftalık sayımlar {.unnumbered}  

Verileri `count()`, `group_by()` ve `summarise()` ile gruplandırmanın kapsamlı açıklamaları için [Verileri Gruplama] ile ilgili sayfaya bakınız. Aşğıda Kısa bir örnek verilmiştir.

1) `unit = "week"` argümanıyla `floor_date()` ve `mutate()` fonksiyonlarıyla yeni bir "hafta" sütunu oluşturun
2) `count()` ile haftalık satır (vaka) sayısını alın; tarihi eksik olan vakaları filtreleyin
3) Verilerde *tüm* haftaların görünmesini sağlamak için **tidyr**'paketinden `complete()` ile fonksiyonunu kullanın (satır/durum bilgisi içermeyenleri de eklemek adına). Varsayılan olarak, herhangi bir "yeni" satır için sayım değerleri NA'dır, ancak bunları adlandırılmış bir liste bekleyen `fill = ` argümanıyla 0 yapabilirsiniz (aşağıdaki örnekte verilen `n` değeri yeni sütununun adıdır)

```{r}
# Haftalık vaka sayılarının yeni bir veri setinde gösterin
weekly_counts <- linelist %>% 
  drop_na(date_onset) %>%             # başlangıç tarihi eksik vakaları kaldırın
  mutate(weekly_cases = floor_date(   # "weekly_cases" adında yeni bir sütun oluştur
    date_onset,
    unit = "week")) %>%            
  count(weekly_cases) %>%           # verileri haftaya göre gruplandır ve grup başına satırları say ('n' sütununu oluşturur)
  tidyr::complete(                  # vaka bildirilmemiş olan haftalar da dahil olmak üzere tüm haftaların mevcut olduğundan emin ol
    weekly_cases = seq.Date(          # "weekly_cases" sütununu eksiksiz bir dizi olarak yeniden tanımla
      from = min(weekly_cases),       # minimum tarihten itibaren
      to = max(weekly_cases),         # maksimum tarihe kadar
      by = "week"),                   # hafta olarak
    fill = list(n = 0))             # n sütunundaki NA'ları 0 ile değiştir
```

Ortaya çıkan veri çerçevesinin ilk satırları şunlardır:

```{r message=FALSE, echo=F}
DT::datatable(head(weekly_counts, 20), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


### Epiweek alternatifleri {.unnumbered}  

**lubridate**'nin ayrıca her biri farklı başlangıç tarih ve nüanslarına sahip olan `week()`, `epiweek()` ve `isoweek()` fonksiyonlarına sahip olduğunu unutmayın. Genel olarak, `floor_date()` ihtiyacınız olan her şeyi kapsamaktadır. Konsola `?week` girerek veya [buradaki belgeleri](https://www.rdocumentation.org/packages/lubridate/versions/1.7.4/topics/week) okuyarak daha fazla bilgiye ulaşabilirsiniz.

Epidemiyolojik haftaları ayarlamak için **aweek** paketini kullanmayı düşünebilirsiniz. Bununla ilgili daha fazla bilgiyi [RECON web sitesinde](https://www.repidemicsconsortium.org/aweek/) okuyabilirsiniz. Haftanın başlangıç gününü `week_start = "Monday"` ile ayarlayabileceğiniz 'date2week()' ve 'week2date()' fonksiyonları mevcuttur. "Hafta" tarzı çıktılar istiyorsanız (örneğin "2020-W12") bu paket en kolay yoldur. **aweek**'in bir başka avantajı da, tarih sütununa `date2week()` uygulandığında, döndürülen sütunun (hafta biçimi) otomatik olarak sınıf Faktörü olması ve zaman aralığındaki tüm haftalar için seviyeleri de içermesidir (bu, yukarıda anlatılan `complete()` komutunda ek adımını yok sayar). **aweek**, tarihleri ay, yıl vb. gibi diğer zaman birimlerine yuvarlama işlevine sahip değildir.

Bir "hafta" biçimini ("2020 W12") göstermek için başka bir zaman serisi alternatifi de, [Zaman serisi ve salgın tespiti] sayfasında anlatılan **tsibble** paketindeki `yearweek()`tir. . 


<!-- ======================================================= -->
## Tarihleri/saat dilimlerini dönüştürme

Veriler farklı saat dilimlerinde olduğunda, bu verileri birleşik bir saat dilimine standart hale getirmek genellikle önemlidir. Çoğu durumda verilerin saat dilimi bileşeninin manuel olarak kodlanması gerektiğinden, bu daha fazla zorluğa neden olmaktadır.

R'da her *datetime* nesnesinin bir saat dilimi bileşeni vardır. Varsayılan olarak, tüm datetime nesneleri kullanılan bilgisayarın yerel saat dilimini kullanmaktadır - bu genellikle, yaz saati uygulaması nedeniyle zaman dilimleri konumlarda sık sık değişeceğinden, adlandırılmış bir saat dilimi yerine *konuma* özgüdür. Bir tarih sütununun temsil ettiği olay belirli bir zamana atfedilemeyeceğinden ve bu nedenle saat cinsinden ölçülen zaman kaymaları makul bir şekilde açıklanamaz. Tarihin zaman bileşeni olmadan saat dilimlerini doğru bir şekilde yönetmek mümkün değildir.

Saat dilimleriyle başa çıkabilmek için, lubridate'de bir datetime nesnesinin saat dilimini farklı bir saat dilimine değiştirmek için kullanılabilecek bir dizi yardımcı fonksiyon mevcuttur. Saat dilimleri, datetime nesnesine geçerli bir tz veritabanı saat dilimi atanarak hesaplanır. Bunların bir listesini aşağıdaki linkte bulabilirsiniz - verileri kullandığınız konum bu listede değilse, saat dilimine yakın büyük şehirleri kullanabilirsiniz, bu, aynı amaca hizmet edecektir.

https://en.wikipedia.org/wiki/List_of_tz_database_time_zones


```{r}
# geçerli saati bir sütuna ata
time_now <- Sys.time()
time_now

# saat zamanını DEĞİŞTİRİRKEN sütuna yeni bir saat dilimi atamak için with_tz() kullan
time_london_real <- with_tz(time_now, "Europe/London")

# sütuna yeni bir saat dilimi atamak için force_tz() kullanın, saat zamanını SABİTLEYİN
time_london_local <- force_tz(time_now, "Europe/London")


# Bu kodu çalıştırmak için kullanılan bilgisayar Londra saat diliminde olmadığını unutmayın,
# zaman farkı olacaktır
# (bilgisayar saat diliminden londra'ya kadar olan saat farkı)
time_london_real - time_london_local

```

Bu büyük ölçüde soyut görünebilir ve kullanıcı farklı zaman dilimlerinde çalışmıyorsa genellikle gerekli değildir.


<!-- ======================================================= -->
## Gecikme ve önden gelme hesaplamaları 

`lead()` ve `lag()`, bir vektördeki önceki (geciken) veya sonraki (önden gelen) değerleri bulmaya yardımcı olan **dplyr** paketindeki fonksiyonlarıdır - tipik olarak bir sayısal veya tarih vektörüdür. Bu fonksiyonlar, zaman birimleri arasındaki değişim/fark hesaplamaları yaparken işe yarar.


```{r, echo=F}
counts <- import(here("data", "example", "district_weekly_count_data.xlsx")) %>% 
  filter(District == "Nibari") %>% 
  mutate(Date = as.Date(Date),
         week_start = lubridate::floor_date(Date, "week")) %>%
  group_by(week_start) %>% 
  summarize(cases_wk = sum(Cases, na.rm=T)) %>% 
  complete(week_start = seq.Date(min(week_start), max(week_start), by = "week"), fill = list(cases_wk = 0))
```

Mevcut bir hafta ile önceki hafta arasındaki vaka farkını hesaplamak istediğinizi varsayalım. Veriler başlangıçta aşağıda gösterildiği gibi haftalık sayılarla elde edilir. 

```{r message=FALSE, echo=F}
DT::datatable(counts, rownames = FALSE,  options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

**`lag()` veya `lead()` komutlarını kullanırken veri çerçevesindeki satırların sırası çok önemlidir! - tarihlerinizin / numaralarınızın artan mı yoksa azalan mı olduğuna dikkat etmelisiniz.**  

İlk olarak, önceki (geciken) haftanın değerini içeren yeni bir sütun oluşturun.

* Geri/ileri birim sayısını `n =` ile kontrol edin (negatif olmayan bir tam sayı olmalıdır)  
* Var olmayan satırlara yerleştirilen değeri tanımlamak için `default =` argümanını kullanın (örneğin, gecikmeli değerin olmadığı ilk satır). Varsayılan olarak bu `NA`dır.  
* Satırlarınız referans sütununuza göre sıralanmıyorsa `order_by = TRUE` argümanını kullanın


```{r}
counts <- counts %>% 
  mutate(cases_prev_wk = lag(cases_wk, n = 1))
```

```{r message=FALSE, echo=F}
DT::datatable(counts, rownames = FALSE,  options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Ardından, iki vaka sütunu arasındaki farkı hesaplayan yeni bir sütun oluşturun:

```{r}
counts <- counts %>% 
  mutate(cases_prev_wk = lag(cases_wk, n = 1),
         case_diff = cases_wk - cases_prev_wk)
```

```{r message=FALSE, echo=F}
DT::datatable(counts, rownames = FALSE,  options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


`lead()` ve `lag()` hakkında daha fazla bilgiyi [buradaki](https://dplyr.tidyverse.org/reference/lead-lag.html) belgelerde veya `?lag`` kodunu konsola girerek elde edebilirsiniz. 


<!-- ======================================================= -->
## Kaynaklar 

**lubridate** [tidyverse sayfası](https://lubridate.tidyverse.org/)  
**lubridate** RStudio [kopya kağıdı](https://rawgit.com/rstudio/cheatsheets/master/lubridate.pdf)  
Veri Bilimi için R - [tarih ve saatler sayfası](https://r4ds.had.co.nz/dates-and-times.html)  
[Çevrimiçi rehber](https://www.statmethods.net/input/dates.html)
[Tarih formatları](https://www.r-bloggers.com/2013/08/date-formats-in-r/)
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/dates.Rmd-->


# Karakterler ve dizeler { }  

```{r, out.width=c('100%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "Characters_Strings_1500x500.png"))
```


Bu sayfa, karakter değerlerini ("dizeler") değerlendirmek ve işlemek için **stringr** paketinin kullanımını göstermektedir.

1. Birleştir, düzenle, ayır, düzenle - `str_c()`, `str_glue()`, `str_order()`, `str_split()`  
2. Temizle ve standardize et
    * Uzunluğunu ayarla - `str_pad()`, `str_trunc()`, `str_wrap()`  
    * Büyük küçük harfi değiştir - `str_to_upper()`, `str_to_title()`, `str_to_lower()`, `str_to_sentence()`  
3. Sırasına göre çıkar ve değerlendir - `str_length()`, `str_sub()`, `word()`  
4. Paternlre  
    * Tespit et ve bul - `str_detect()`, `str_subset()`, `str_match()`, `str_extract()`  
    * Modifiye et ve değiştir - `str_sub()`, `str_replace_all()`  
7. Düzenli ifadeler ("regex")


Gösterimi kolaylaştırmak için çoğu örnekte kısa tanımlı bir karakter vektörü esas alınmıştır, bu örnekler bir veri çerçevesi içindeki sütuna kolayca uyarlanabilir. 

Bu [stringr skeci](
https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html) bu sayfa için ilham vermiştir. 


<!-- ======================================================= -->
## Hazırlık { }

### Paketleri yükleme {.unnumbered}  

**stringr** ve diğer **tidyverse** paketlerini kurun veya yükleyin.

```{r}
# paketleri indir/yükle
pacman::p_load(
  stringr,    # dizeleri işlemek için birçok fonksiyon
  tidyverse,  # ek veri işleme fonksiyonları
  tools)      # başlıkları dönüştürmek için alternatif

```


### Verileri yükleme {.unnumbered}  


Bu sayfada, simüle edilmiş bir Ebola salgını vakalarının temizlenmiş "satır listesine" ara sıra atıfta bulunulacaktır. Daha fazla bilgi için, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>"temiz satır listesi" dosyasını indirmek için tıklayın.</a> (.rds dosyası olarak). **rio** paketinden `import()` işleviyle veriler içe aktarırılır (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe ve dışa aktarma] sayfasına bakın).

```{r, echo=F}
# satır listesini R'a yükle
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# Satır listesini indir
linelist <- import("linelist_cleaned.rds")
```

The first 50 rows of the linelist are displayed below.

```{r, message=FALSE, echo=F}
# satır listesini tablo olarak göster
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


<!-- ======================================================= -->
## Birleştir, böl ve düzenle { }


Bu bölüm aşağıdaki başlıkları içermektedir:  

* `str_c()`, `str_glue()`, ve `unite()` komutlarıyla dizeleri birleştirmek  
* `str_order()` komutuyla dizeleri sıralamak
* `str_split()` ve `separate()` komutuyla dizeleri ayırmak  


<!-- ======================================================= -->
### Dizeleri Birleştirme {.unnumbered}

Birden çok dizeyi tek bir dizede birleştirmek için, **stringr**'dan `str_c` fonksiyonu kullanılır. Birleştirilecek farklı karakterler mevcutsa, bunları virgülle ayırarak benzersiz argümanlar olarak eklemeniz yeterlidir.    

```{r}
str_c("String1", "String2", "String3")
```

`sep =` argümanı, eklediğiniz bağımsız değişkenlerin her birinin arasına bir karakter değeri ekler (ör. virgül, boşluk veya yeni satır `"\n"` ekleme)

```{r}
str_c("String1", "String2", "String3", sep = ", ")
```

`collapse =` argümanı, `str_c()` argümanıyla birden çok *vektör* kullanılıldığı durumlarda işe yarar. Çıktının öğelerini ayırmak için kullanılır.

Aşağıdaki örnek, iki vektörün tek bir vektörde (adlar ve soyadlar) birleşimini göstermektedir. Bir başka benzer örnek, yargı yetkileri ve dava sayıları olabilir. Bu örnekte: 

* `sep = ` değeri ad ve soyad arasını belirler  
* `collapse = ` değeri her bir kişiyi bir diğerinden ayırır  


```{r}
first_names <- c("abdul", "fahruk", "janice") 
last_names  <- c("hussein", "akinleye", "okeke")

# ilgili giriş dizeleri arasını sep belirler, her bir öğenin arasını ise collapse belirler
str_c(first_names, last_names, sep = " ", collapse = ";  ")
```

Not: İstenilen görüntüleme şekline göre, birleşik dize yazdırırken, yeni satırların düzgün yazdırılması için tüm ifadeyi `cat()` fonksiyonu içine sarmanız gerekebilir:  

```{r}
# Yeni satırların doğru yazdırılması için ifadenin cat() içine sarılması gerekir
cat(str_c(first_names, last_names, sep = " ", collapse = ";\n"))
```


<!-- ======================================================= -->
### Dinamik dizeler {.unnumbered}

Bir dizeye dinamik R kodu eklemek için `str_glue()` fonksiyonunu kullanın. Bu, aşağıda gösterildiği gibi dinamik grafik başlıkları oluşturmak için çok kullanışlı bir fonksiyondur 

* Tüm içerik çift tırnak işaretleri arasında girilir `str_glue("")`  
* Herhangi bir dinamik kod veya önceden tanımlanmış değerlere yapılan referanslar, çift tırnak işareti içerisinde `{}` küme parantezleri içine yerleştirilir. Aynı `str_glue()` komutunda birçok küme parantezleri olabilir.  
* `"` tırnak işaretini görüntülemek için, çevreleyen çift tırnak içinde *tek* tırnak kullanılabilir (ör. tarih formatı sağlarken - aşağıdaki örneğe bakın)  
* İpucu: Satır atlamak için `\n`i kullanabilirsiniz
* İpucu: Tarih gösterimini ayarlamak için `format()` ve geçerli tarihi görüntülemek için `Sys.Date()` fonksiyonlarını kullanabilirsiniz 

Dinamik bir grafik başlığının basit bir örneği:

```{r}
str_glue("Data include {nrow(linelist)} cases and are current to {format(Sys.Date(), '%d %b %Y')}.")
```

Alternatif bir format, parantez içinde yer tutucuları kullanmak ve kodu, aşağıdaki gibi `str_glue()` fonksiyonunun sonunda ayrı argümanlarda tanımlamaktır. Bu, metin uzunsa kodun okunabilirliğini artırabilir.

```{r}
str_glue("Linelist as of {current_date}.\nLast case hospitalized on {last_hospital}.\n{n_missing_onset} cases are missing date of onset and not shown",
         current_date = format(Sys.Date(), '%d %b %Y'),
         last_hospital = format(as.Date(max(linelist$date_hospitalisation, na.rm=T)), '%d %b %Y'),
         n_missing_onset = nrow(linelist %>% filter(is.na(date_onset)))
         )

```


**Bir veri çerçevesinden dizi alımı**  

Bazen, bir veri çerçevesinden veri çekmek ve peşpeşe eklemek istenebilir. Aşağıda örnek bir veri çerçevesi bulunmaktadır. Bu veri çerçevesi, yetki alanları; yeni ve toplam dava sayıları hakkında özet bir açıklama yapmak için kullanılabilir. 

```{r}
# vaka veri çerçevesini hazırla
case_table <- data.frame(
  zone        = c("Zone 1", "Zone 2", "Zone 3", "Zone 4", "Zone 5"),
  new_cases   = c(3, 0, 7, 0, 15),
  total_cases = c(40, 4, 25, 10, 103)
  )
```

```{r, echo=F}
DT::datatable(case_table, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Veri çerçevesi satırlarından veri almak için özel olarak yapılmış `str_glue_data()` kullanılır:

```{r}
case_table %>% 
  str_glue_data("{zone}: {new_cases} ({total_cases} total cases)")
```


**Dizeleri satırlarda birleştirme**  

Bir veri çerçevesi sütunundaki değerleri "birleştirmeye" çalışıyorsanız; örneğin, birden çok satırdaki değerleri bir ayırıcıyla birbirine yapıştırarak tek bir satırda birleştirme, [Tekilleştirme] sayfasının ["toplama" değerleri](#str_rollup) bölümüne bakabilirsiniz.

**Veri çerçevesini bir satıra çevirme**  

`str_c()` fonksiyonu (veri çerçevesini ve sütun adlarını da belirterek), `sep =` ve `collapse =` argümanlarını kullanarak verilerin tek satırda görünmesini sağlayabilirsiniz.

```{r}
str_c(case_table$zone, case_table$new_cases, sep = " = ", collapse = ";  ")
```

Verileri ayrı bir `str_c()` komutu ile sarmalayarak ifadenin başına "New Cases:" ön metnini ekleyebilirsiniz ("New Cases:" orijinal `str_c()` içindeyse, birden çok kez görünecektir).

```{r}
str_c("New Cases: ", str_c(case_table$zone, case_table$new_cases, sep = " = ", collapse = ";  "))
```


### Sütunları birleştirme  {#str_unite .unnumbered}

Bir veri çerçevesinde, birden çok sütundaki karakter değerlerini bir araya getirmek, **tidyr**'den `unite()` fonksiyonu ile gerçekleştirilebilir. Bu, `separate()`in tam tersidir.

Yeni birleşik sütunun adı girilir. Ardından, birleştirmek istenen sütunların adları girilir.

* Varsayılan olarak, birleşik sütunda kullanılan ayırıcı `_` alt çizgidir, ancak bu, `sep =` argümanı ile değiştirilebilir.
* `remove = ` veri çerçevesinden giriş sütunlarını kaldırır (varsayılan olarak TRUE) 
* `na.rm = ` birleştirirken eksik değerleri kaldırır (varsayılan olarak FALSE) 

Aşağıda, göstermek için bir mini veri çerçevesi tanımlanmaktadır:

```{r, message = F, warning=F}
df <- data.frame(
  case_ID = c(1:6),
  symptoms  = c("jaundice, fever, chills",     # hasta 1
                "chills, aches, pains",        # hasta 2 
                "fever",                       # hasta 3
                "vomiting, diarrhoea",         # hasta 4
                "bleeding from gums, fever",   # hasta 5
                "rapid pulse, headache"),      # hasta 6
  outcome = c("Recover", "Death", "Death", "Recover", "Recover", "Recover"))
```


```{r}
df_split <- separate(df, symptoms, into = c("sym_1", "sym_2", "sym_3"), extra = "merge")
```

Örnek bir veri çerçevesi:

```{r, echo=F}
DT::datatable(df_split, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Aşağıda, üç semptom sütununu birleştirilmiştir: 

```{r}
df_split %>% 
  unite(
    col = "all_symptoms",         # yeni birleşik sütunun adı
    c("sym_1", "sym_2", "sym_3"), # birleştirilecek için sütunlar
    sep = ", ",                   # birleşik sütunda kullanılacak ayırıcı
    remove = TRUE,                # TRUE ise, veri çerçevesinden girdi sütunlarını kaldırır
    na.rm = TRUE                  # DOĞRU ise, birleştirmeden önce eksik değerler kaldırılır
  )
```

<!-- ======================================================= -->
### Ayırma {.unnumbered}  

Bir dizgiyi belli bir paterne göre bölmek için `str_split()` kullanılabilir. Bu komut dize(ler)i uygun paternde böler ve yeni değerlerden oluşan karakter vektörleri `list` olarak döndürür.

Aşağıdaki basit örnek, verilen dizeyi değerlendirir ve onu üçe böler. Varsayılan olarak, her dizin her bir bölümü (bir karakter vektörü) `list` sınıfının bir nesnesine dönüştürülür. Eğer argüman `simplify = TRUE` ise, sonuç bir karakter matrisi olacaktır.

Bu örnekte, dize fonksiyon ile, listeye dönüştürülür - üç değer içeren bir karakter vektörü. 

```{r}
str_split(string = "jaundice, fever, chills",
          pattern = ",")
```

Çıktı kaydedilirse, parantez sözdizimi ile n'inci değerine erişebilirsiniz. Belirli bir değere erişmek için `the_returned_object[[1]][2]` argümanı kullanılır. Bu fonksiyonla listedeki ("fever") ikinci değere erişir. Değerlere erişim hakkında daha fazla ayrıntı için [R temelleri] sayfasına bakabilirsiniz. 

```{r}
pt1_symptoms <- str_split("jaundice, fever, chills", ",")

pt1_symptoms[[1]][2]  # listeden 2. değeri çıkarır
```

`str_split()` fonksiyonuyla listede birden fazla karakter dizisi mevcutsa, döndürülen listede de birden fazla eleman olacaktır.

```{r}
symptoms <- c("jaundice, fever, chills",     # hasta 1
              "chills, aches, pains",        # hasta 2 
              "fever",                       # hasta 3
              "vomiting, diarrhoea",         # hasta 4
              "bleeding from gums, fever",   # hasta 5
              "rapid pulse, headache")       # hasta 6

str_split(symptoms, ",")                     # her hastanın semptomlarını ayırır
```

Veri çerçevesi sütununa dönüştürebileceğiniz bir "karakter matrisi" çıktısını almak için, `simplify = TRUE` bağımsız değişkenini aşağıda gösterildiği gibi ayarlamalısınız:

```{r}
str_split(symptoms, ",", simplify = TRUE)
```

Ayrıca `n = ` argümanıyla oluşturulacak bölmelerin sayısını da ayarlayabilirsiniz. Aşağıdaki örnekte bölme sayısı 2 ile sınırlandırılmıştır. Diğer virgül ve dizeler ikinci değer içinde kalır.

```{r}
str_split(symptoms, ",", simplify = TRUE, n = 2)
```

*Not - aynı çıktıları, "simplify" argümanını kullanmadığınız, bunun yerine sütun sayısını (`n`) belirtmeniz gereken `str_split_fixed()` fonksiyonu ile de elde edilebilirsiniz.* 

```{r, eval=F}
str_split_fixed(symptoms, ",", n = 2)
```

### Sütunları ayırma {.unnumbered}  

Veri çerçevesine ait bir sütunu bölmeye çalışıyorsanız, **dplyr** paketinden `separate()` fonksiyonu en iyi seçenektir. Bu fonksiyon var olan bir karakter sütununu diğer sütunlara bölmek için kullanılır.

Diyelim ki bir `case_ID` sütunu, birçok semptom içeren bir karakter sütunu ve bir sonuç sütunu içeren basit bir "df" ([Sütunları birleştirme bölümünde](#str_unite) içinde tanımlanmış ve birleştirilmiş) veri çerçevemiz var. Bu örnekte amacımız, `semptomlar` sütununu her biri bir semptom içeren birçok sütuna ayırmaktır.

```{r, echo=F}
DT::datatable(df, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Verileri `separate()` fonksiyonuna aktarıldığını varsayarsak, önce ayrılacak sütunu fonksiyona tanımlamalısınız. Ardından, aşağıda gösterildiği gibi *yeni* sütun adlarını içeren bir `c( )` vektörünü olarak `into = ` argümanına aktarabilirsiniz.

* `sep = ` ayırıcı, bir karakter veya bir sayı olabilir (bölünecek karakter konumu olarak yorumlanır)
* `remove = ` Varsayılan olarak FALSE, giriş sütununu kaldırır  
* `convert = ` Varsayılan olarak FALSE, "NA" dizelerinin "NA" (eksik veri) formatına dönüştürür 
* `extra = ` bu, ayırılan yeni sütunlarda daha fazla değer varsa bunların ne olacağını kontrol eder.  
     * `extra = "warn"` sizi uyarır, ancak aşırı değerlerin kaybolacağı anlamına gelir (**the default**)  
     * `extra = "drop"` aşırı değerlerin uyarı yapılmadan kaybolacağı anlamına gelir 
     * **`extra = "merge"` yalnızca "into" argümanında tanımlanan sütun sayısına bölünür - *bu ayar tüm verilerinizi korur***  

Aşağıda `extra = "merge"` içeren bir örnek verilmiştir - burada hiçbir veri kaybolmaz. İki yeni sütun tanımlanır, ancak ikinci yeni sütunda üçüncü semptomlar kalmaya devam eder: 

```{r}
# ikinci ve üçüncü semptomlar ikinci sütunda birleştirildi
df %>% 
  separate(symptoms, into = c("sym_1", "sym_2"), sep=",", extra = "merge")
```

Aşağıda varsayılan `extra = "drop"` kullanıldığında sistem bir uyarı verir ancak üçüncü semptomlar kaybolur:

```{r}
# üçüncü semptomlar kaybolur
df %>% 
  separate(symptoms, into = c("sym_1", "sym_2"), sep=",")
```

<span style="color: orange;">**_DİKKAT:_** Yeni sütunlar için yeterli `into` değeri sağlamazsanız verileriniz kaybolabilir.</span>  

<!-- ======================================================= -->
### Alfabetik olarak düzenle {.unnumbered} 

Birkaç dize alfabetik sıraya göre sıralanabilir. `str_order()` dizelerin alfabetik olarak sırasını verirken, `str_sort()` dizeleri alfabetik olarak sıralar.  

```{r}
# dizeler
health_zones <- c("Alba", "Takota", "Delta")

# alfabetik sırasını döndürür
str_order(health_zones)

# dizeleri alfabetik olarak sıralar
str_sort(health_zones)
```

Farklı bir alfabe kullanmak için `locale =` argümanını ekleyebilirsiniz. R konsoluna `stringi::stri_locale_list()` girerek yerel ayarların tam listesine bakabınız.

<!-- ======================================================= -->
### R tabanı fonksiyonları {.unnumbered}

Tüm parçaları karaktere dönüştürdükten sonra vektörleri birleştiren R tabanındaki `paste()` ve `paste0()` fonksiyonları yaygın bir şekilde kullanılmaktadır. Bunlar `str_c()` fonksiyonuna benzer şekilde hareket ederler, ancak sözdizimi daha karmaşıktır - parantez içinde her bölüm bir virgülle ayrılır. Parçalar ya karakter metnidir (tırnak içinde) ya da önceden tanımlanmış kod nesneleridir (tırnak işaretleri olmadan). Örnek olarak:

```{r}
n_beds <- 10
n_masks <- 20

paste0("Regional hospital needs ", n_beds, " beds and ", n_masks, " masks.")
```

`sep = ` ve `collapse = ` argümanları özelleştirilebilir. `paste0()` basitçe `paste()` fonksiyonunun `sep = " "` (bir boşluk) argümanlı halidir.  

## Temizleme ve standartlaştırma  

<!-- ======================================================= -->
### Karakterleri değiştirme {.unnumbered}

Çoğu zaman, bir dize değerinin büyük/küçük harf kullanımı değiştirilmelidir, örneğin şehir adları. Aşağıda **stringr** paketinden `str_to_upper()`, `str_to_lower()` ve `str_to_title()` fonksiyonlarına ait örnekler verilmiştir:

```{r}
str_to_upper("California")

str_to_lower("California")
```

Yukarıdaki örnekler R tabanındaki `toupper()`, `tolower()` fonksiyonlarıyla da yapılabilir.

**İlk karakter**  

Her kelimenin ilk harfini büyütmek için `str_to_title()` fonksiyonu kullanılır:  

```{r}
str_to_title("go to the US state of california ")
```

Daha hassas bir büyük harf kullanımı elde etmek için **tools** paketinden `toTitleCase()` fonksiyonunu kullanabilirsiniz ("to", "the" ve "of" gibi sözcükler büyük harfle yazılmaz). 

```{r}
tools::toTitleCase("This is the US state of california")
```

Ayrıca cümlenin yalnızca ilk harfini büyük harf yapan `str_to_sentence()` kullanabilirsiniz.

```{r}
str_to_sentence("the patient must be transported")
```


### Karakter uzunluğu {#str_pad .unnumbered}

Bir dizeye minimum uzunlukta karakter eklemek için `str_pad()` fonksiyonunu kullanabilirsiniz. Varsayılan olarak boşluklar eklenir, ancak `pad = ` argümanını kullanarak diğer karakterlerle de doldurabilirsiniz.

```{r}
# Farklı uzunluktaki ICD kodları
ICD_codes <- c("R10.13",
               "R10.819",
               "R17")

# Sağ tarafta 7 karaktere kadar doldurulmuş ICD kodları
str_pad(ICD_codes, 7, "right")

# Boşluk yerine nokta içeren karakter alanı
str_pad(ICD_codes, 7, "right", pad = ".")
```

Örneğin, sayıların başını sıfırlarla doldurmak için (saat veya dakika gibi), sayıyı `pad = "0"` ile minimum 2 uzunluğa kadar doldurabilirsiniz.

```{r}
# İki basamağın başına sıfır ekle (ör. dakika/saat zamanları için)
str_pad("4", 2, pad = "0") 
```

```{r, echo=T, eval=F}
# "saat" adlı sayısal bir sütun kullanan örnek
hours <- str_pad(hours, 2, pad = "0")
```


### Kesme {.unnumbered} 

`str_trunc()` her dize için bir maksimum bir uzunluk belirler. Bir dize bu uzunluğu aşarsa, kısaltılır (kısaltılır) ve dizenin öncesinde daha uzun olduğunu belirtmek için bir üç nokta (...) eklenir. Üç noktanın *uzunluk* olarak sayıldığına dikkat etmelisiniz. Üç nokta karakterleri `ellipsis = ` argümanı ile değiştirilebilir. İsteğe bağlı `side = ` argümanı, üç noktanın kesilen dize ("sol", "sağ" veya "merkez") içinde nerede görüneceğini belirtir.

```{r}
original <- "Symptom onset on 4/3/2020 with vomiting"
str_trunc(original, 10, "center")
```


### Standart uzunluk {.unnumbered}

Standart uzunluğu belirlemek için `str_trunc()` fonksiyonunu kullanabilirsiniz. Standart uzunluğa göre kısa olan dizeleri genişletmek için `str_pad()` fonksiyonu kullanılır. Aşağıdaki örnekte, maksimum uzunluk olarak 6 ayarlanmıştır. Burada daha uzun değerler kesilir ve kısa olan değerler genişler. 

```{r}
# Farklı uzunluktaki ICD kodları
ICD_codes   <- c("R10.13",
                 "R10.819",
                 "R17")

# en fazla 6 karakterle sınırla
ICD_codes_2 <- str_trunc(ICD_codes, 6)
ICD_codes_2

# en az 6 karakter uzunluğunda tut
ICD_codes_3 <- str_pad(ICD_codes_2, 6, "right")
ICD_codes_3
```


### Baştaki/sondaki boşlukları kaldırma {.unnumbered}  

Bir dize girişinin kenarlarındaki boşlukları, yeni satırları (`\n`) veya sekmeleri (`\t`) kaldırmak için `str_trim()` kullanın. Hangi tarafın kırpılacağını belirtmek için komuta `"sağ"` `"sol"` veya `"her ikisi"` ekleyin (ör. `str_trim(x, "sağ")`).

```{r}
# Sağda fazla boşluk bulunan kimlik numaraları
IDs <- c("provA_1852  ", # iki fazla boşluk
         "provA_2345",   # fazla boşluk yok
         "provA_9460 ")  # bir fazla boşluk

# Kimlik numaraların yalnızca sağ taraftaki fazla boşlukları kaldırılır
str_trim(IDs)
```


### Tekrarlanan boşlukları kaldırma {.unnumbered}  

Bir dizenin *içindeki* yinelenen boşlukları kaldırmak için `str_squish()` fonksiyonunu kullanabilirsiniz. Örneğin, çift boşlukları tek boşluklara dönüştürmek için. Ayrıca `str_trim()` fonksiyonu gibi dizenin dışındaki boşlukları, yeni satırları veya sekmeleri de kaldırır.

```{r}
# orijinal, dize içinde fazla boşluk içeriyor
str_squish("  Pt requires   IV saline\n") 
```

Daha fazla ayrıntı görmek için R konsolunuza `?str_trim`, `?str_pad` komutunu giriniz. 


### Paragrafa sığdırma {.unnumbered}  

Uzun bir yapılandırılmamış metni sabit satır uzunluğuna sahip yapılandırılmış bir paragrafa sığdırmak için `str_wrap()` fonksiyonunu kullanabilirsiniz. Her satır için ideal karakter uzunluğunu tanımladığınızda, fonksiyon, aşağıdaki örnekte görüldüğü gibi paragraf içine yeni satırlar (`\n`) eklemek için bir algoritma uygular.

```{r}
pt_course <- "Symptom onset 1/4/2020 vomiting chills fever. Pt saw traditional healer in home village on 2/4/2020. On 5/4/2020 pt symptoms worsened and was admitted to Lumta clinic. Sample was taken and pt was transported to regional hospital on 6/4/2020. Pt died at regional hospital on 7/4/2020."

str_wrap(pt_course, 40)
```

R tabanındaki `cat()` fonksiyonu ile yapılandırılmış bu yeni paragrafın çıktısı alınabilir.  

```{r}
cat(str_wrap(pt_course, 40))
```


<!-- ======================================================= -->
## Pozisyona göre düzenleme { }


### Karakter pozisyonuna göre çıkarma {.unnumbered}  

Bir dizenin yalnızca bir kısmını döndürmek için `str_sub()` kullanın. Fonksiyon üç ana argüman alır:

1) karakter vektör(leri)  
2) başlangıç pozisyonu
3) bitiş pozisyonu

Pozisyon değeri hakkında bir kaç:  

* Bir pozisyon değeri pozitifse, pozisyon dizenin sol ucundan başlayarak sayılır.  
* Bir pozisyon değeri negatifse, pozisyon dizenin sağ ucundan başlayarak sayılır. 
* Pozisyon numaraları dahildir.  
* Dizinin ötesine uzanan konumlar kesilir (kaldırılır).

Aşağıda "pneumonia" dizesine uygulanan bazı örnekler verilmiştir.:  

```{r}
# soldan üçüncü başlar ve biter (soldan üçüncü harf)
str_sub("pneumonia", 3, 3)

# 0 mevcut değil
str_sub("pneumonia", 0, 0)

# soldan 6., sağdan 1. arasındaki
str_sub("pneumonia", 6, -1)

# Sağdan 5., sağdan 2. arasındaki
str_sub("pneumonia", -5, -2)

# 4. soldan dizenin dışındaki bir pozisyona
str_sub("pneumonia", 4, 15)
```


### Kelime pozisyonuna göre çıkarma {.unnumbered} 

n'inci 'kelime'yi çıkarmak için, yine **stringr** paketinden `word()` fonksiyonunu kullanabilirsiniz. Fonksiyonu kullanabilmek için dizeyi, ardından ayıklanacak ilk sözcük konumunu ve ayıklanacak son sözcük konumunu tanımlamanız gerekmektedir.

Varsayılan olarak, `sep = ` ile aksi belirtilmedikçe 'kelimeler' arasındaki ayırıcının bir boşluk olduğu varsayılır (örneğin, kelimeler alt çizgilerle ayrıldığında `sep = "_"`.


```{r}
# dizeleri değerlendirme
chief_complaints <- c("I just got out of the hospital 2 days ago, but still can barely breathe.",
                      "My stomach hurts",
                      "Severe ear pain")

# her dizenin 1. ila 3. kelimelerin arasını ayır
word(chief_complaints, start = 1, end = 3, sep = " ")
```


### Karakteri pozisyonuna göre değiştirme {.unnumbered} 

Atama operatörüyle (`<-`) eşleştirilen `str_sub()` fonksiyonu, bir dizenin bir bölümünü değiştirmek için kullanılabilir:

```{r}
word <- "pneumonia"

# üçüncü ve dördüncü karakterleri X'e dönüştür
str_sub(word, 3, 4) <- "XX"

# print
word
```

Birden çok dizeye uygulanan bir örnek (örneğin bir sütun). "HIV" uzunluğundaki genişlemeye dikkat edin.

```{r}
words <- c("pneumonia", "tubercolosis", "HIV")

# üçüncü ve dördüncü karakterleri X'e dönüştür
str_sub(words, 3, 4) <- "XX"

words
```


### Uzunluğu değerlendirme {.unnumbered}


```{r}
str_length("abc")
```

Alternatif olarak, R tabanından `nchar()` fonksiyonu kullanabilirsiniz.


<!-- ======================================================= -->
## Paternler { }

Birçok **stringr** fonksiyonu, belirli bir *paterne* göre algılamak, bulmak, ayıklamak, eşleştirmek, değiştirmek ve bölmek için kullanılabilir.


<!-- ======================================================= -->
### Patern bulma {.unnumbered}

Bir dize içindeki bir kalıbın varlığını/yokluğunu algılamak için aşağıdaki gibi `str_detect()` fonksiyonunu kullanabilirsiniz. Önce aranacak dizeyi veya vektörü (`string = `) ve sonra aranacak modeli (`pattern = `) belirlemeniz gerekmektedir. Varsayılan olarak aramanın *büyük/küçük harf duyarlı olduğunu* unutmayın!

```{r}
str_detect(string = "primary school teacher", pattern = "teach")
```

Desenin mevcut olup olmadığını bilmek istiyorsanız, `negate = ` argümanı eklenebilir ve `TRUE` olarak ayarlanabilir.
 
```{r}
str_detect(string = "primary school teacher", pattern = "teach", negate = TRUE)
```

Büyük/küçük harf kullanımını yok saymak için, kalıbı `regex()` içine sarın ve `regex()` komutu *içinde*, `ignore_case = TRUE` (veya `T`) argümanını ekleyin. 

```{r}
str_detect(string = "Teacher", pattern = regex("teach", ignore_case = T))
```

Bir karakter vektörüne veya bir veri çerçevesi sütununa `str_detect()` uygulandığında, değerlerin her biri için DOĞRU veya YANLIŞ sonucunu döndürür.

```{r}
# bir meslek vektörü/sütunu 
occupations <- c("field laborer",
                 "university professor",
                 "primary school teacher & tutor",
                 "tutor",
                 "nurse at regional hospital",
                 "lineworker at Amberdeen Fish Factory",
                 "physican",
                 "cardiologist",
                 "office worker",
                 "food service")

# Her dizede "teach" kalıbının varlığını tespit et - çıktı DOĞRU/YANLIŞ vektörüdür
str_detect(occupations, "teach")
```

"DOĞRU"ları saymanız gerekiyorsa, çıktıyı `sum()` fonksiyonu içine almanız yeterlidir. Bu, "DOĞRU" çıktıların sayısını verir.

```{r}
sum(str_detect(occupations, "teach"))
```

Birden çok terimi aramak için, bunları aşağıda gösterildiği gibi 'pattern = ' bağımsız değişkenine VEYA çubukları (`|`) ile ayırarak ekleyin:

```{r}
sum(str_detect(string = occupations, pattern = "teach|professor|tutor"))
```

Uzun bir arama terimleri listesi oluşturmanız gerekiyorsa, bunları `str_c()` ve `sep = |` kullanarak birleştirebilir ardından bunun bir karakter nesnesi olarak tanımlayabilir ve daha sonrasında vektör formatında arayabilirsiniz. Aşağıdaki örnek, birinci basamak sağlık çalışanları için olası meslek arama terimlerini içermektedir.

```{r}
# search terms
occupation_med_frontline <- str_c("medical", "medicine", "hcw", "healthcare", "home care", "home health",
                                "surgeon", "doctor", "doc", "physician", "surgery", "peds", "pediatrician",
                               "intensivist", "cardiologist", "coroner", "nurse", "nursing", "rn", "lpn",
                               "cna", "pa", "physician assistant", "mental health",
                               "emergency department technician", "resp therapist", "respiratory",
                                "phlebotomist", "pharmacy", "pharmacist", "hospital", "snf", "rehabilitation",
                               "rehab", "activity", "elderly", "subacute", "sub acute",
                                "clinic", "post acute", "therapist", "extended care",
                                "dental", "dential", "dentist", sep = "|")

occupation_med_frontline
```

Aşağıdaki komut, birinci basamak sağlık çalışanları (`occupation_med_frontline`) için arama terimlerinden herhangi birini içeren mesleklerin sayısını döndürür:  

```{r}
sum(str_detect(string = occupations, pattern = occupation_med_frontline))
```


**R tabanı dizin arama işlevleri**  

R tabanı fonksiyonu olan `grepl()`, `str_detect()` fonksiyonuna benzer bir şekilde çalışır. Çünkü o da bir modelle eşleşmeleri arar ve mantıksal bir vektör döndürür. Temel sözdizimi `grepl(pattern, strings_to_search, ignore.case = FALSE, ...)` şeklindedir. Avantajlardan biri, `ignore.case` argümanını yazmanın daha kolay olmasıdır (`regex()` fonksiyonunu dahil etmeye gerek yoktur).

Benzer şekilde, R tabanı fonksiyonları olan `sub()` ve `gsub()`, `str_replace()`a benzer şekilde hareket eder. Temel sözdizimleri şöyledir: `gsub(pattern, replace, strings_to_search, ignore.case = FALSE)`. `sub()` kalıbın ilk örneğini değiştirirken, `gsub()` kalıbın tüm örneklerini değiştirir.


#### Virgülleri noktalara dönüştürme {.unnumbered}  

Burada, bir sayı vektöründe virgülleri noktalara dönüştürmek için `gsub()` kullanımına örnek verilmiştir. Bu durum özellikle verileriniz Amerika Birleşik Devletleri veya İngiltere dışındaki ülkelerden geliyorsa faydalı olabilir. 

İlk olarak "lengths" üzerinde etkili olan komutun içindeki `gsub()` fonksiyonu, herhangi bir noktayı boşluksuz "" değerine dönüştürmektedir (silmektedir). Noktayı doğru tanımlamak için başına iki eğik çizgi "eklenmesi" gerekir çünkü normal "." ifadesi "herhangi bir karakter" anlamına gelir. Ardından, sonuç (yalnızca virgülle), virgüllerin noktalarla değiştirildiği dış `gsub()` komutuna iletilir.

```{r, eval=F}
lengths <- c("2.454,56", "1,2", "6.096,5")

as.numeric(gsub(pattern = ",",                # virgülleri bul     
                replacement = ".",            # nokta ile değiştir
                x = gsub("\\.", "", lengths)  # binlik değerlerdeki noktaları kaldır
                )
           )                                  # çıktıyı sayısal bir değer olarak tanımla
```


### Tamamını değiştirme {.unnumbered}  

"Bul ve değiştir" aracı olarak `str_replace_all()` kullanabilirsiniz. İlk Önce, `string =` olarak değerlendirilecek dizeleri, sonra değiştirilecek kalıbı `pattern =` olarak ve ardından değiştirme değerini `replacement =` olarak tanımlamanız gerekmektedir. Aşağıdaki örnek, tüm "dead" örneklerini "deceased" ile değiştirmektedir. Bu komuttaki argümanların büyük/küçük harfe duyarlı olduğunu unutmayın.

```{r}
outcome <- c("Karl: dead",
            "Samantha: dead",
            "Marco: not dead")

str_replace_all(string = outcome, pattern = "dead", replacement = "deceased")
```

Notlar:  

* Paternleri `NA` olarak değiştirmek için `str_replace_na()` fonksiyonunu kullanın.  
* `str_replace()` fonksiyonu her bir dizedeki sadece ilk paterni değiştirir, diğerlerini değiştirmez.


<!-- ======================================================= -->
### Mantığa göre arama {.unnumbered}


**`case_when()` fonksiyonuyla**  

`str_detect()` genellikle `case_while()` içinde kullanılır (**dplyr** paketinden). `occupations`ın satır listesindeki bir sütun olduğunu varsayalım. Aşağıda `mutate()`, `case_while()` fonksiyonları aracılığıyla koşullu mantığı kullanarak `is_educator` adında yeni bir sütun oluşturmaktayız. `case_while()` hakkında daha fazla bilgi edinmek için veri temizleme sayfasına bakabilirsiniz.

```{r, eval=F}
df <- df %>% 
  mutate(is_educator = case_when(
    # meslek içinde terim arama, büyük/küçük harfe duyarlı değil
    str_detect(occupations,
               regex("teach|prof|tutor|university",
                     ignore_case = TRUE))              ~ "Educator",
    # diğerleri
    TRUE                                               ~ "Not an educator"))
```

Bir hatırlatma olarak, koşullu mantığa dışlama kriterlerini(`negate = F`) eklemeniz işinizi kolaylaştırabilir:

```{r, eval=F}
df <- df %>% 
  # is_educator yeni sütunundaki değer koşullu mantığa dayalıdır
  mutate(is_educator = case_when(
    
    # Meslek sütununun "Educator" olarak atanabilmesi için 2 kriteri karşılaması gerekir:
    # bir arama terimine sahip olmalı VE herhangi bir dışlama terimi olmamalı
    
    # Bir arama terimi içermeli
    str_detect(occupations,
               regex("teach|prof|tutor|university", ignore_case = T)) &              
    
    # VE bir dışlama terimi İÇERMEMELİDİR
    str_detect(occupations,
               regex("admin", ignore_case = T),
               negate = TRUE                        ~ "Educator"
    
    # Yukarıdaki kriterlere uymayan tüm satırlar
    TRUE                                            ~ "Not an educator"))
```


<!-- ======================================================= -->
### Patern konumunu bulma {.unnumbered}  

Bir paternin *ilk* konumunu bulmak için `str_locate()` kullanabilirsiniz. Fonksiyon çıktı olarak bir başlangıç ve bitiş konumu verir.

```{r}
str_locate("I wish", "sh")
```

Diğer `str` fonksiyonları gibi, her dizede paterni karşılayan *bütün* örneklerin konumlarını döndürecek bir "_all" versiyonu (`str_locate_all()`) mevcuttur. Bu fonksiyon bir liste çıktısı verir.

```{r}
phrases <- c("I wish", "I hope", "he hopes", "He hopes")

str_locate(phrases, "h" )     # paternin *ilk* örneğinin konumu
str_locate_all(phrases, "h" ) # paternin *her* örneğinin konumu
```


<!-- ======================================================= -->
### Eşleşeni çıkarma {.unnumbered}  

`str_extract_all()` eşleşen kalıpların kendisini döndürür; bu fonksiyon, "VEYA" koşulları aracılığıyla birkaç kalıp önerdiğinizde en kullanışlı seçenektir. Örnek olarak, "teach", "prof" *veya* "tutor" paternleri için meslekler vektörünü (önceki sekmeye bakın) inceleyebilirsiniz.

`str_extract_all()`, değerlendirilen her dize için *tüm eşleşmeleri* içeren bir "liste" döndürür. Aşağıda, meslek vektörü içinde 3 paternin nasıl eşleştiğini görebilirsiniz.

```{r}
str_extract_all(occupations, "teach|prof|tutor")
```

`str_extract()`, değerlendirilen her dizede *yalnızca ilk eşleşmeyi* ortaya çıkararak, değerlendirilen her dize için bir elemanlı bir karakter vektörü üretir. Eşleşmenin olmadığı yerde `NA` sonucunu döndürür. `NA`lar, döndürülen vektör `na.exclude()` fonksiyonu ile sarılarak kaldırılabilir. Çıkan sonuçta ikincisinin nasıl gösterilmediğine dikkat ediniz.

```{r}
str_extract(occupations, "teach|prof|tutor")
```

<!-- ======================================================= -->
### Alt küme ve sayı {.unnumbered}  

Bu başlıktaki fonksiyonlar arasında `str_subset()` ve `str_count()` bulunmaktadır. 

`str_subset()` fonksiyonu paterni içeren gerçek değerleri döndürür:

```{r}
str_subset(occupations, "teach|prof|tutor")
```

`str_count()` bir sayı vektörü döndürür: Değerlendirilen her değerde bir arama teriminin göründüğü **miktar**.

```{r}
str_count(occupations, regex("teach|prof|tutor", ignore_case = TRUE))
```


<!-- ======================================================= -->
### Regex grupları {.unnumbered}

HAZIRLANIYOR


<!-- ======================================================= -->
## Özel karakterler  

**Ters eğik çizgi `\`**

Ters eğik çizgi `\` sonrasındaki karakteri "yok saymak" için kullanılır. Bu şekilde, diğer tırnak işaretleri (`\"`) *içinde* olan bir alıntı işaretini görüntülemek için bir ters eğik çizgi kullanılabilir - ortadaki alıntı işareti, çevreleyen alıntı işaretlerini "iptal etmez".

Not - bu nedenle, bir ters eğik çizgi *görüntülemek* istiyorsanız için iki ters eğik çizgi `\\` yazmalısınız.

**Özel Karakterler**  

Özel Karakter | Anlamı  
----------------- | --------------------------------------------------------------    
`"\\"` | ters eğik çizgi  
`"\n"` | yeni satır  
`"\""` | çift tırnak *içinde* çift tırnak 
`'\''` | tek tırnak *içinde* tek tırnak 
`"\`"` | şapka işareti 
`"\r"` | satır başı
`"\t"` | sekme
`"\v"` | dikey sekme 
`"\b"` | geri alma


Bu özel karakterlerin tam listesini görüntülemek için R Konsolunda `?"'"` komutunu çalıştırabilirsiniz (RStudio Yardım bölmesinde görünecektir). 


<!-- ======================================================= -->
## Düzenli ifadeler (regex) 


<!-- ======================================================= -->
## Regex ve özel karakterler { } 

Düzenli ifadeler veya "regex", dizelerdeki kalıpları açıklamak için kısa bir dildir. Eğer aşina değilseniz, düzenli ifadeler yabancı bir dil gibi görünebilir. Burada bu dili biraz gizeminden arındırmaya çalışacağız.

*[Bölümün çocuğu bu rehberden alınmıştır](https://towardsdatascience.com/a-gentle-introduction-to-regular-expressions-with-r-df5e897ca432) and [this cheatsheet](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf)*. Bu el kitabının internet erişimi olmayan kişiler tarafından da görüntülenebileceğini ön görülerek burada önemli olanları paylaşıyoruz.

"Yapılandırılmamış" metinden belirli kalıplarını çıkarmak için genellikle düzenli bir ifade uygulanır - örneğin tıbbi notlar, hasta şikayetleri, geçmişi veya bir veri çerçevesindeki diğer serbest metin sütunları.

Temel bir düzenli ifade oluşturmak için kullanılabilecek dört araç vardır:  

1) Karakter setleri  
2) Meta karakterler  
3) Niceleyiciler  
4) Grouplar


**Karakter setleri**  

Karakter setleri, bir karakter eşleşmesi için köşeli parantez içinde listeleme seçeneklerini ifade etmenin bir yoludur. Bu nedenle, köşeli parantez içindeki karakterlerden herhangi biri dizede bulunursa eşleşme tetiklenir. Örneğin, sesli harfleri aramak için şu karakter seti kullanılabilir: "[aeiou]". Diğer bazı yaygın karakter setleri şunlardır:

Karakter Seti | Anlamı 
----------------- | --------------------------------------------------------------    
`"[A-Z]"` | herhangi bir tek büyük harf  
`"[a-z]"` | herhangi bir tek küçük harf  
`"[0-9]"` | herhangi bir rakam 
`[:alnum:]` | herhangi bir alfanümerik karakter  
`[:digit:]` | herhangi bir sayısal rakam 
`[:alpha:]` | herhangi bir harf (büyük veya küçük harf)
`[:upper:]` | herhangi bir büyük harf 
`[:lower:]` | herhangi bir küçük harf 

Karakter setleri, `"[A-Za-z]"` (herhangi bir büyük veya küçük harf) veya başka bir örnek `"[t-z0-5]"` gibi tek bir parantez içinde (boşluksuz!) birleştirilebilir ( t'den z'ye kadar küçük harf VEYA 0'dan 5'e kadar sayılar).


**Meta karakterler**  

Meta karakterler, karakter setlerinin kısaltmasıdır. Önemli olanlardan bazıları aşağıda listelenmiştir:

Meta karakter | Anlamı  
----------------- | --------------------------------------------------------------    
`"\\s"` | tek bir boşluk  
`"\\w"` | herhangi bir tek alfanümerik karakter (A-Z, a-z, or 0-9)  
`"\\d"` | herhangi bir tek sayısal rakam (0-9)  


**Niceleyiciler**  

Genellikle tek bir karakterde eşleşme aramak istemezsiniz. Niceleyiciler, eşleşmeye izin vermek için harflerin/sayıların uzunluğunu belirlemenize olanak tanır.

Niceleyiciler, nicelleştirdikleri karakterin *sonrasında* olan `{ }` küme parantezleri içinde yazılan sayılardır, örneğin,  

* `"A{2}"` **iki** büyük A harfinin örneklerini döndürür.  
* `"A{2,4}"` **iki ile dört** arasında büyük A harfi *(boşluk koymayın!)* örneklerini döndürür.
* `"A{2,}"` **iki veya daha fazla** büyük A harfinin örneklerini döndürür.
* `"A+"` **bir veya daha fazla** büyük A harfinin örneklerini döndürür (farklı bir karakterle karşılaşılıncaya kadar uzatılan grup).  
* **Sıfır veya daha fazla** eşleşme döndürmek için bir `*` yıldız işareti ile başlayın (paternin mevcut olduğundan emin değilseniz kullanışlıdır) 


Nicelik belirteci olarak '+' artı sembolü kullanıldığında, farklı bir karakterle karşılaşılıncaya kadar eşleşme gerçekleşir. Örneğin, bu ifade tüm *kelimeleri* (alfa karakterleri: `"[A-Za-z]+"`) döndürür.


```{r}
# niceleyiciler için test dizisi
test <- "A-AA-AAA-AAAA"
```

{2} niceleyicisi kullanıldığında, yalnızca ardışık A çiftleri döndürülür. "AAAA" içinde iki çift tanımlanmıştır. 

```{r}
str_extract_all(test, "A{2}")
```

{2,4} niceleyicisi kullanıldığında, uzunluğu iki ila dört olan ardışık A grupları döndürülebilir.

```{r}
str_extract_all(test, "A{2,4}")
```

"+" niceleyicisiyle, **bir veya daha fazla** gruplar döndürülebilir:

```{r}
str_extract_all(test, "A+")
```

**Relatif pozisyon**  

Relatif pozisyon, bir kalıptan önce gelen veya onu izleyen bir kalıba göre konumu ifade eder. Örneğin, cümleleri çıkarmak için "sonunda bir nokta bulunan iki sayı" (`""`).  (?<=\\.)\\s(?=[A-Z]) 

```{r}
str_extract_all(test, "")
```

Pozisyon Tanımı | Anlamı 
----------------- | --------------------------------------------------------------    
`"(?<=b)a"` | **öncesinde** bir "b" bulunan "a"  
`"(?<!b)a"` | **Öncesinde ** bir "b" olmayan "a"
`"a(?=b)"` | **ardından** bir "b" gelen "a" 
`"a(?!b)"` | **ardından** bir "b" gelmeyen "a"


**Gruplar**  

Düzenli ifadelerinizde grupları yakalamak, çıkarma işlemi sonrasında daha organize bir çıktı elde etmenin bir yoludur.  


**Regex örnekleri**  

Aşağıda örnekler için serbest bir metin bulunmaktadır. Bir düzenli ifade arama terimi kullanarak ondan faydalı bilgiler çıkarmaya çalışacağız.

```{r}
pt_note <- "Patient arrived at Broward Hospital emergency ward at 18:00 on 6/12/2005. Patient presented with radiating abdominal pain from LR quadrant. Patient skin was pale, cool, and clammy. Patient temperature was 99.8 degrees farinheit. Patient pulse rate was 100 bpm and thready. Respiratory rate was 29 per minute."
```

Bu ifade tüm kelimelerle (boşluk gibi karakter olmayan bir karaktere ulaşana kadar herhangi bir karakter) eşleşir:

```{r}
str_extract_all(pt_note, "[A-Za-z]+")
```

`"[0-9]{1,2}"` ifadesi, 1 veya 2 basamak uzunluğunda ardışık sayılarla eşleşir. Ayrıca `"\\d{1,2}"` veya `"[:digit:]{1,2}"` şeklinde de yazılabilir. 

```{r}
str_extract_all(pt_note, "[0-9]{1,2}")
```

<!-- This expression will extract all sentences (assuming first letter is capitalized, and the sentence ends with a period). The pattern reads in English as: "A capital letter followed by some lowercase letters, a space, some letters, a space,     -->

<!-- ```{r} -->
<!-- str_extract_all(pt_note, "[A-Z][a-z]+\\s\\w+\\s\\d{1,2}\\s\\w+\\s*\\w*") -->
<!-- ``` -->


[Bu kopya kağıdının 2. sayfasında, normal ifadelerin ve ipuçlarının faydalı bir listesini görüntüleyebilirsiniz.](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf)  

[Ayrıca bu rehbere bakabilirsiniz](https://towardsdatascience.com/a-gentle-introduction-to-regular-expressions-with-r-df5e897ca432).  


<!-- ======================================================= -->
## Kaynaklar { }

[**stringr** işlevleri için bir referans sayfası burada bulunabilir](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf)


[**stringr** ile ilgili bir gösterim burada bulunabilir](https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html)
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/characters_strings.Rmd-->

# Faktörler {}


```{r, out.width=c('100%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "Factors_1500x500.png"))
```

R'da *faktörler*, sabit, kabul edilebilir değerler kümesiyle sıralı kategorilere izin veren bir veri sınıfıdır.

Tipik olarak, değerleri ("*levels*"), grafik ve tablolarda alfabetik olmayan bir şekilde görüntülenebilmeleri için özel bir sıralamaya tabi tutmak isterseniz bir sütunu karakter veya sayısal sınıftan bir faktöre dönüştürmeniz gerekir. Faktörlerin diğer bir yaygın kullanımı, verilerin geçici olarak yok olması nedeniyle oluşabilecek dalgalanmamaları engellemek için grafik açıklamalarını standart hale getirmektir.

Bu sayfa, **forcats** ("**for** ve **kat**egorik değişkenler" için kısa bir ad) paketi ve bazı R tabanındaki fonkisyonların kullanımını göstermektedir. Epidemiyolojik haftalarla ilgili özel faktör vakaları için **lubridat** ve **aweek** kullanımına da değiniyoruz.

**forcats** fonksiyonlarının tam listesi çevrimiçi olarak [burada](https://forcats.tidyverse.org/reference/index.html) bulunabilir. Aşağıda en yaygın olanlardan bazılarını gösteriyoruz.


<!-- ======================================================= -->
## Hazırlık  

### Paketlerin yüklenmesi {.unnumbered}  

Aşağıdaki kod parçası, analizler için gereken paketlerin yüklenmesini göstermektedir. Bu el kitabında, gerekirse paketi kuran *ve* kullanım için yükleyen **pacman**'dan `p_load()` vurgulamaktayız. R tabanından `library()` ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] sayfasına bakın.

```{r}
pacman::p_load(
  rio,           # içe/dışa aktar
  here,          # dosya yolu
  lubridate,     # tarihlerle çalışma
  forcats,       # faktörler
  aweek,         # otomatik faktör seviyeleri ile epiweeks oluştur
  janitor,       # tablolar
  tidyverse      # data yönetim ve görselleştirmesi
  )
```



### Veriyi içe aktarma {.unnumbered}  

Simüle edilmiş bir Ebola salgınına ait vakaların veri setini içe aktarıyoruz. Takip etmek isterseniz, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>"temiz satır listesi" dosyasını indirmek için tıklayın.</a> (.rds dosyası olarak). Verilerinizi **rio** paketinden `import()` işleviyle içe aktarın (.xlsx, .rds, .csv gibi birçok dosya türünü kabul eder - ayrıntılar için [İçe ve dışa aktarma] sayfasına bakın).

```{r, echo=F}
# satır listesini R'a aktar
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```


```{r, eval=F}
# veri setini indir
linelist <- import("linelist_cleaned.rds")
```


### Yeni kategorik değişken {#fct_newcat .unnumbered}  

Bu sayfada gösterim için ortak bir senaryo kullanacağız - yeni bir kategorik değişkenin oluşturulması.

Sayısal bir sütunu sınıf faktörüne dönüştürürseniz, bunun üzerinde sayısal istatistikleri hesaplayamayacağınızı unutmayın.

#### Sütun oluşturma {.unnumbered}  

Biz, mevcut `days_onset_hosp` sütununu (semptom başlangıcından hastaneye kabule kadar geçen gün) kullanarak her satırı birkaç kategoriden birine sınıflandırıp yeni bir `delay_cat` sütunu oluşturuyoruz. Bunu, her satıra sırayla mantıksal ölçütleri (sağ taraf) uygulayan ve yeni `delay_cat` sütununa karşılık gelen sol taraf değerini döndüren, **dplyr** paktenin fonksiyonu `case_when()` ile yapıyoruz. [Temizleme verileri ve temel işlevler] bölümünde `case_when()` hakkında daha fazla bilgi edinebilirsiniz.


```{r}
linelist <- linelist %>% 
  mutate(delay_cat = case_when(
    # criteria                                   # eğer doğruysa yeni değer
    days_onset_hosp < 2                        ~ "<2 days",
    days_onset_hosp >= 2 & days_onset_hosp < 5 ~ "2-5 days",
    days_onset_hosp >= 5                       ~ ">5 days",
    is.na(days_onset_hosp)                     ~ NA_character_,
    TRUE                                       ~ "Check me"))  
```


#### Varsayılan değer sırası {.unnumbered}  

`case_when()` ile oluşturulduğu gibi, yeni `delay_cat` sütunu, karakter sınıfının kategorik bir sütunudur - *henüz bir faktör değildir*. Bu nedenle, bir sıklık tablosunda, benzersiz değerlerin varsayılan bir alfa-numerik düzende sıralandığını görüyoruz - bu, sezgisel olarak pek mantıklı olmayan bir sıradır:

```{r}
table(linelist$delay_cat, useNA = "always")
```

Benzer şekilde, bir çubuk grafiği yaparsak, değerler de x ekseninde bu sırayla görünür (R'deki en yaygın görselleştirme paketi olan **ggplot2** hakkında daha fazla bilgi için [ggplot temelleri] sayfasına bakın).

```{r, warning=F, message=F}
ggplot(data = linelist)+
  geom_bar(mapping = aes(x = delay_cat))
```



## Faktöre dönüştürme  

Bir karakteri veya sayısal sütunu *faktör* sınıfına dönüştürmek için, **forcats** paketindeki herhangi bir fonksiyonu kullanabilirsiniz (birçoğu [aşağıda](#fct_adjust) ayrıntılı olarak verilmiştir). Bu fonksiyonlarla veriler sınıf faktörüne dönüşecek ve daha sonra seviyelerin belirli şekilde sıralanmasını gerçekleşecek veya buna izin verilecek - örneğin `fct_relevel()` kullanmak seviye sırasını manuel olarak belirlemenizi sağlar. `as_factor()` fonksiyonu, başka bir özellik eklemeden sınıfı basitçe dönüştürür.

R tabanı fonksiyonu olan `factor()`, bir sütunu faktöre dönüştürür ve karakter vektöründeki `levels =` argümanına göre seviyelerin sırasını manuel olarak düzenlemenizi sağlar.

Aşağıda, `delay_cat` sütununu sınıf karakterinden sınıf faktörüne dönüştürmek için `mutate()` ve `fct_relevel()` kullanıyoruz. `delay_cat` sütunu, yukarıdaki [Hazırlık](#fct_newcat) bölümünde oluşturulmuştur.

```{r}
linelist <- linelist %>%
  mutate(delay_cat = fct_relevel(delay_cat))
```

*The unique "values" in this column are now considered "levels" of the factor.*  The levels have an *order*, which can be printed with the **base** R function `levels()`, or alternatively viewed in a count table via `table()` from **base** R or `tabyl()` from **janitor**. By default, the order of the levels will be alpha-numeric, as before. Note that `NA` is not a factor level.  

```{r}
levels(linelist$delay_cat)
```

`fct_relevel()` fonksiyonu, seviye sırasını manuel olarak belirlemenize izin veren ek bir özelliğe sahiptir. Düzey değerlerini, aşağıda gösterildiği gibi virgülle ayırarak sırayla, tırnak içinde yazmanız yeterlidir. Yazımın değerlerle tam olarak eşleşmesi gerektiğini unutmayın. Verilerde mevcut olmayan düzeyler oluşturmak istiyorsanız, bunun yerine [`fct_expand()` kullanın](#fct_add)).

```{r}
linelist <- linelist %>%
  mutate(delay_cat = fct_relevel(delay_cat, "<2 days", "2-5 days", ">5 days"))
```

Artık seviyelerin bir önceki komutta belirtildiği gibi mantıklı bir sırayla sıralandığını görebiliriz.

```{r}
levels(linelist$delay_cat)
```

Şimdi tablodaki sırası da daha sezgisel bir anlam ifade ediyor. 

```{r, warning=F, message=F}
ggplot(data = linelist)+
  geom_bar(mapping = aes(x = delay_cat))
```


## Seviye ekleme ve çıkarma  

### Ekleme {#fct_add .unnumbered}

Bir faktöre seviye eklemeniz gerekiyorsa, bunu `fct_expand()` ile yapabilirsiniz. Sütun adını ve ardından yeni seviyeleri (virgülle ayırarak) yazmanız yeterlidir. Değerleri tablolaştırarak yeni seviyeleri ve sıfır sayılarını görebiliriz. R tabanından `table()`ı veya **janitor**'dan `tabyl()` kullanabilirsiniz:

```{r}
linelist %>% 
  mutate(delay_cat = fct_expand(delay_cat, "Not admitted to hospital", "Transfer to other jurisdiction")) %>% 
  tabyl(delay_cat)   # print table
```

Not: Eksik değerleri (`NA`) seviyelere kolayca eklemek için özel bir **forcats** fonksiyonu mevcuttur. Aşağıdaki [Eksik değerler](#fct_missing) ile ilgili bölüme bakın.

### Çıkarma {.unnumbered}  

`fct_drop()`ı kullanırsanız, sıfır sayımlı "kullanılmayan" seviyeler, seviyeler grubundan çıkarılacaktır. Yukarıda eklediğimiz seviyeler ("Hastaneye kabul edilmedi") bir seviye olarak mevcuttur, ancak hiçbir satır aslında bu değere sahip değildir. Böylece, faktör sütunumuza `fct_drop()` uygulanarak çıkarılır:

```{r}
linelist %>% 
  mutate(delay_cat = fct_drop(delay_cat)) %>% 
  tabyl(delay_cat)
```




## Seviye sırasını düzenleme {#fct_adjust} 

**forcats** paketi, faktör düzeylerinin sırasını kolayca ayarlamak için kullanışlı fonksiyonlar da sunar (bir sütun sınıf faktörü olarak tanımlandıktan sonra):

Bu fonksiyonlar, iki bağlamda faktör sütununa uygulanabilir: 

1) Her zamanki gibi veri çerçevesindeki sütuna uygulanır, böylece değişen veriler daha sonra da kullanılabilir 
2) *Bir grafik içine* uygulanabilir, böylece değişiklik sadece grafik içinde kalır 



### Elle düzenleme {.unnumbered} 

Bu fonksiyon, faktör seviyelerini manuel olarak sıralamak için kullanılır. Faktör olmayan bir sütunda kullanılırsa, sütun önce sınıf faktörüne dönüştürülür.

Parantez içinde önce faktör sütun adını girin, ardından aşağıdakilerden birini sağlayın:  

* Tüm seviyeleri istenen sırada (karakter vektörü `c()` olarak) veya 
* Bir seviye ve `after =` argümanı kullanılarak düzeltilmiş sıralama  

Burada, (zaten Faktör sınıfı olan) `delay_cat` sütununu yeniden tanımlamaya ve istenen tüm düzey sırasını belirtmeye bir örnek verilmiştir.

```{r}
# seviye sırasını yeniden düzenle
linelist <- linelist %>% 
  mutate(delay_cat = fct_relevel(delay_cat, c("<2 days", "2-5 days", ">5 days")))
```

Sadece bir seviyeyi taşımak istiyorsanız, bunu tek başına `fct_relevel()` olarak belirtebilir ve `after =` argümanına hangi sırada olması gerektiğini belirtmek için sayı verebilirsiniz. Örneğin, aşağıdaki komut "<2 gün" ifadesini ikinci konuma kaydırır:

```{r, eval=F}
# seviye sırasını yeniden düzenle
linelist %>% 
  mutate(delay_cat = fct_relevel(delay_cat, "<2 days", after = 1)) %>% 
  tabyl(delay_cat)
```




### Grafik içinde {.unnumbered}  

**forcats** komutları, veri çerçevesinde veya yalnızca bir grafik içinde seviye sırasını ayarlamak için kullanılabilir. Sütun adını *grafik içinde* `ggplot()`un "sarma" komutunu kullanarak, tersine çevirebilir veya yeniden seviyelendirebilirsiniz. Değişim yalnızca bu grafik için geçerli olacaktır. 

Aşağıda, `ggplot()` ile iki grafik oluşturulmuştur ([ggplot temelleri] sayfasına bakın). İlkinde, `delay_cat` sütunu, "satır listesi" verisinde olduğu gibi varsayılan düzey sırası ile grafiğin x eksenine eşlenir. İkinci örnekte `fct_relevel()` içine sarılmış ve grafikteki sırası değiştirilmiştir.

```{r, echo =F}
linelist <- linelist %>% 
  mutate(delay_cat = fct_relevel(delay_cat, c("2-5 days", "<2 days", ">5 days")))

```



```{r, warning=F, message=F, out.width = c('50%', '50%'), fig.show='hold'}
# Alfa-numerik varsayılan sıra - ggplot'ta düzenleme yapılmadı
ggplot(data = linelist)+
    geom_bar(mapping = aes(x = delay_cat))

# ggplot içinde faktör seviyesi düzenlendi
ggplot(data = linelist)+
  geom_bar(mapping = aes(x = fct_relevel(delay_cat, c("<2 days", "2-5 days", ">5 days"))))
```

Varsayılan x ekseni başlığının oldukça karmaşık olduğuna dikkat edin - bu başlığı **ggplot2** `labs()` argümanı ile değiştirebilirsiniz.  




### Tersine döndürme {.unnumbered}  

Seviye sırasını tersine çevirmek işlemi oldukça yaygındır. Faktörü `fct_rev()` ile sarmanız yeterlidir.

Gerçek faktör seviyelerini değil de *yalnızca* bir grafiğin açıklamasını tersine çevirmek istiyorsanız, bunu `guides()` ile yapabileceğinizi unutmayın (bkz. [ggplot ipuçları]). 




### Sıklığa göre {.unnumbered}  

Değerleri verilerde görünme sıklığına göre sıralamak için `fct_infreq()` kullanın. Eksik değerler (`NA`), açık bir düzeye dönüştürülmediği sürece otomatik olarak sona eklenir (bkz. [bu bölüm](#fct_missing)). `fct_rev()` ile bir daha sarmalayarak sırayı tersine çevirebilirsiniz. 

Bu fonksiyon, aşağıda gösterildiği gibi bir `ggplot()` içinde kullanılabilir.

```{r, out.width = c('50%', '50%', '50%'), fig.show='hold', warning=F, message=F}
# sıklığa göre sırala
ggplot(data = linelist, aes(x = fct_infreq(delay_cat)))+
  geom_bar()+
  labs(x = "Delay onset to admission (days)",
       title = "Ordered by frequency")

# sıralamayı tersine çevir
ggplot(data = linelist, aes(x = fct_rev(fct_infreq(delay_cat))))+
  geom_bar()+
  labs(x = "Delay onset to admission (days)",
       title = "Reverse of order by frequency")
```


### Karşılaşmaya göre {.unnumbered}  

Seviye sırasını, ilk satırdan başlayarak verilerdeki karşılaşma sırasına uyacak şekilde ayarlamak için `fct_inorder()` fonksiyonunu kullanın. Bu komut, veri çerçevesindeki verileri `arrange()` fonksiyonu ile düzenledikten sonra faktör sırasını tekrardan ayarlamak için faydalı olacaktır. 


### Başka bir sütunun özet istatistiğine göre {.unnumbered}  

Bir sütunun seviyelerini *başka bir sütunun özet istatistiğine* göre sıralamak için `fct_reorder()`yı kullanabilirsiniz. Görsel olarak, bu, çubukların/noktaların grafik boyunca istikrarlı bir şekilde yükseldiği veya alçaldığı hoş grafiklerle sonuçlanabilir.

Aşağıdaki örneklerde, x ekseni `delay_cat` ve y ekseni `ct_blood` (döngü eşiği) sayısal sütunudur. Kutu grafikleri, `delay_cat` grubuna göre CT değeri dağılımını gösterir. Kutu grafiklerini grup medyan CT değerine göre artan sırada sıralamak istiyoruz.

Aşağıdaki ilk örnekte, varsayılan sıra olarak alfa-numerik sırası kullanılır. Kutu çizim yüksekliklerinin karışık olduğunu ve belirli bir sırada olmadığını görebilirsiniz. İkinci örnekte ise, `delay_cat` sütunu (x eksenine eşlenmiştir) `fct_reorder()` içine sarılmıştır, `ct_blood` sütunu ikinci ve `medyan` üçüncü argüman olarak verilmiştir. (`maks`, `ortalama`, `min` vb. de kullanabilirsiniz). Böylece, `delay_cat` seviyelerinin sırası artan medyan CT değerlerini yansıtacaktır. Bu, ikinci grafikte gösterilmektedir - kutu çizimleri yükselecek şekilde yeniden düzenlenmiştir. Açık bir düzeye dönüştürülmediği sürece, "NA"nın (eksik) sonunda nasıl görüldüğüne dikkat edin.

```{r, fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}
# kutu grafiği orjinal faktör seviyelerine göre sıralanmıştır
ggplot(data = linelist)+
  geom_boxplot(
    aes(x = delay_cat,
        y = ct_blood, 
        fill = delay_cat))+
  labs(x = "Delay onset to admission (days)",
       title = "Ordered by original alpha-numeric levels")+
  theme_classic()+
  theme(legend.position = "none")


# kutu grafiği medyan CT düzeylerine göre sıralanmıştır
ggplot(data = linelist)+
  geom_boxplot(
    aes(x = fct_reorder(delay_cat, ct_blood, "median"),
        y = ct_blood,
        fill = delay_cat))+
  labs(x = "Delay onset to admission (days)",
       title = "Ordered by median CT value in group")+
  theme_classic()+
  theme(legend.position = "none")
```

Yukarıdaki örnekte, `ggplot()` komutundan önce gerekli hiçbir adım olmadığına dikkat edin - gruplama ve hesaplamaların tümü dahili olarak ggplot komutunda yapılır.

### "Son" değere göre {.unnumbered}  

Gruplandırılmış çizgi grafiklerinde `fct_reorder2()`, düzeylerin (ve dolayısıyla *başlığın*) grafik "sonu" çizgilerin dikey sıralamasıyla hizalandırırr. Teknik olarak konuşursak, "en büyük x değerleriyle ilişkili y değerlerine göre sıralanır."

Örneğin, zaman içinde hastaneye göre vaka sayılarını gösteren satırlarınız varsa, `aes()` içindeki `color =` argümanına `fct_reorder2()` komutunu uygulayabilirsiniz. Öyle ki açıklamada görünen hastanelerin dikey sırası grafik sonundaki satır sırasıyla hizalanır. [Çevrimiçi belgelerde](https://forcats.tidyverse.org/reference/fct_reorder.html) daha fazlasını okuyuabilirsiniz.

```{r, warning=F, message=F}
epidemic_data <- linelist %>%         # satır listesiyle başla   
    filter(date_onset < as.Date("2014-09-21")) %>%    # görsel netlik için son tarih
    count(                                            # haftalık ve hastaneye göre vaka sayılarını al
      epiweek = lubridate::floor_date(date_onset, "week"),  
      hospital                                            
    ) 
  
ggplot(data = epidemic_data)+                       # grafiği başlat
  geom_line(                                        # çizgileri hazırla
    aes(
      x = epiweek,                                  # x-axis epiweek
      y = n,                                        # boyu haftalık vaka sayısıdır
      color = fct_reorder2(hospital, epiweek, n)))+ # veriyi, grafik sonu yüksekliği ve hastaneye göre gruplandırılıp renklendir
  labs(title = "Factor levels (and legend display) by line height at end of plot",
       color = "Hospital")                          # başlığı değiştir
```




## Eksik değerler {#fct_missing}  

Faktör sütununuzda `NA` değerleri varsa, bunları `fct_explicit_na()` ile kolayca "Eksik" gibi adlandırılmış bir düzeye dönüştürebilirsiniz. `NA` değerleri, sıralamanın sonunda varsayılan olarak "(Eksik)" değerine dönüştürülür. Seviye adını `na_level =` argümanıyla ayarlayabilirsiniz.

Aşağıda, bu işlem `delay_cat` sütununda 'NA'ları "Missing delay"e dönüştürür. Bu, `tabyl()` ile bir tabloya yazdırılır.

```{r}
linelist %>% 
  mutate(delay_cat = fct_explicit_na(delay_cat, na_level = "Missing delay")) %>% 
  tabyl(delay_cat)
```





## Seviyeleri birleştirme  


### Elle düzenleme {.unnumbered}  

Seviye göstergelerini `fct_recode()` ile manuel olarak ayarlayabilirsiniz. Bu, **dplyr** fonksiyonu `recode()` gibidir (bkz. [Temizleme verileri ve temel işlevler]), farklı olarak yeni faktör seviyelerinin oluşturulmasına izin verir. Bir faktörde basit `recode()`komutunu kullanırsanız, önceden izin verilen seviyeler ayarlanmadıkça yeni kodlanmış değerler reddedilecektir.

Bu araç, yeniden kodlanmış değeri birden çok seviyeye atayarak seviyeleri "birleştirmek" için de kullanılabilir. Sadece bilgileri kaybetmemeye dikkat edin! Bu birleştirme adımlarını yeni bir sütunda yapmayı düşünün (mevcut sütunun üzerine yazmayın).

`fct_recode()`, `recode()`dan farklı bir sözdizimine sahiptir. `recode()`, `ESKİ = YENİ`yi kullanırken, `fct_recode()`, `YENİ = ESKİ`yi kullanır.   

Geçerli `delay_cat` seviyeleri şunlardır:

```{r, echo=F}
linelist <- linelist %>% 
  mutate(delay_cat = fct_relevel(delay_cat, "<2 days", after = 0))
```


```{r}
levels(linelist$delay_cat)
```

Yeni düzeyler, `fct_recode(column, "new" = "old", "new" = "old", "new" = "old")` sözdizimi kullanılarak oluşturulur ve yazdırılır: 

```{r}
linelist %>% 
  mutate(delay_cat = fct_recode(
    delay_cat,
    "Less than 2 days" = "<2 days",
    "2 to 5 days"      = "2-5 days",
    "More than 5 days" = ">5 days")) %>% 
  tabyl(delay_cat)
```

Burada seviyeler `fct_recode()` ile manuel olarak birleştirilirler. "5 günden az" yeni bir düzeyin oluşturulmasında herhangi bir hata olmadığını unutmayın.

```{r, warning=F, message=F}
linelist %>% 
  mutate(delay_cat = fct_recode(
    delay_cat,
    "Less than 5 days" = "<2 days",
    "Less than 5 days" = "2-5 days",
    "More than 5 days" = ">5 days")) %>% 
  tabyl(delay_cat)
```


### "Diğerine" indirgeme {.unnumbered}  

Faktör seviyelerini bir "Diğer" seviyeye manuel olarak atamak için `fct_other()` komutunu kullanabilirsiniz. Aşağıda, "Port Hospital" ve "Central Hospital" dışındaki "hospital" sütunundaki tüm seviyeler "Other Hospital" olarak birleştirilmiştir. `keep =` veya `drop =` için bir vektör sağlayabilirsiniz. "Diğer" düzeyinin görünümünü `other_level = ` ile değiştirebilirsiniz. 

```{r}
linelist %>%    
  mutate(hospital = fct_other(                      # adjust levels
    hospital,
    keep = c("Port Hospital", "Central Hospital"),  # keep these separate
    other_level = "Other Hospital")) %>%            # All others as "Other Hospital"
  tabyl(hospital)                                   # print table

```


### Frekansa göre indirgeme {.unnumbered}

`fct_lump()` kullanarak az görülen faktör düzeylerini otomatik olarak birleştirebilirsiniz. 

Birçok düşük frekans düzeyini bir "Diğer" grubuna "toplamak" için aşağıdakilerden birini yapın:

* Tutmak istediğiniz grup sayısını `n =` olarak ayarlayın. En çok görülen n seviyeleri tutulacak ve diğerlerinin tamamı "Diğer" olarak birleştirilecektir.
* "prop =" değerini, üzerinde tutmak istediğiniz seviyeler için eşik frekans oranı olarak ayarlayın. Diğer tüm değerler "Diğer" olarak birleşecektir.  

"Diğer" düzeyinin görünümünü `other_level = ` ile değiştirebilirsiniz. Aşağıda, en sık rastlanan iki hastane dışındaki tüm hastaneler "Other Hospital" olarak birleştirilmiştir.

```{r, warning=F, message=F}
linelist %>%    
  mutate(hospital = fct_lump(                      # seviyeleri düzenle
    hospital,
    n = 2,                                          # ilk 2 seviyeyi tut
    other_level = "Other Hospital")) %>%            # geri kalanını "Other Hospital" olarak tanımla
  tabyl(hospital)                                   # tabloyu yazdır

```


## Tüm seviyeleri gösterme

Faktörleri kullanmanın bir diğer faydası da, bir veri kümesinde gerçekte hangi değerlerin mevcut olduğuna bakılmaksızın, grafik açıklamalarının ve tabloların görünümünü standart hale getirmesidir.

Çok sayıda analiz hazırlıyorsanız (örneğin, birden fazla analiz için), gösterge ve tabloların, değişen seviyelerde veri kompozisyonu ile bile aynı görünmesini isteyebilirsiniz.

### Grafiklerde {.unnumbered}  

Bir `ggplot()` grafiğinde, ilgili `scale_xxxx()` fonksiyonuna "drop = FALSE" argümanını eklemeniz yeterlidir. Verilerde bulunup bulunmadıklarına bakılmaksızın tüm faktör seviyeleri görüntülenecektir. Faktör sütun seviyeleriniz `fill =` kullanılarak görüntüleniyorsa, o zaman `scale_fill_discrete()` içine aşağıda gösterildiği gibi `drop = FALSE` değerini eklersiniz. Seviyeleriniz `x =` (x eksenine göre) `color =` veya `size =` ile görüntüleniyorsa, bunu `scale_color_discrete()` veya `scale_size_discrete()` argümanlarıyla sağlayabilirsiniz. 

Aşağıdaki örnek, hastaneye göre yaş kategorisine ait çubuk grafiğidir. `scale_fill_discrete(drop = FALSE)` eklenmesi, verilerde mevcut olmasa bile tüm yaş gruplarının açıklamada görünmesini sağlar.

```{r}
ggplot(data = linelist)+
  geom_bar(mapping = aes(x = hospital, fill = age_cat)) +
  scale_fill_discrete(drop = FALSE)+                        # boş olsa bile tüm verileri açıklamada göster
  labs(
    title = "All age groups will appear in legend, even if not present in data")
```

### Tablolarda {.unnumbered}  

Hem R tabanında `table()` hem de **janitor**'dan `tabyl()` tüm faktör seviyelerini (kullanılmayan seviyeler bile) gösterecektir. 

Bir tablo oluşturmak için **dplyr**'den `count()` veya `summarise()` kullanırsanız, kullanılmamış olanlar da dahil tüm faktör düzeylerini dahil etmek için '.drop = FALSE' bağımsız değişkenini ekleyin. 

[Açıklayıcı tablolar] sayfasında, [scale_discrete belgelerinde](https://ggplot2.tidyverse.org/reference/scale_discrete.html) veya [count() belgelerinde](https://dplyr. tidyverse.org/reference/count.html). [Bulaşıcı takibi] sayfasında başka bir örnek görebilirsiniz.


## Epiweeks  

Lütfen [Gruplama verileri] sayfasında epidemiyolojik haftaların nasıl oluşturulacağına ilişkin kapsamlı tartışmaya bakın.

Epidemiyolojik haftaların nasıl oluşturulacağı ve biçimlendirileceğiyle ilgili ipuçları için lütfen [Tarihlerle çalışma] sayfasına da bakın.


### Grafiklerde epiweeks {.unnumbered}  

Amacınız bir grafikte görüntülenecek epiweeks oluşturmaksa, bunu [Gruplama verileri] sayfasında açıklandığı gibi **lubridate**'nin `floor_date()` ile yapabilirsiniz. Döndürülen değerler YYYY-AA-GG biçiminde Date sınıfında olacaktır. Bu sütunu bir grafik içinde kullanırsanız, tarihler doğal olarak sıralanır; seviyeler veya sınıf Faktörüne dönüştürme konusunda endişelenmenize gerek yoktur. Aşağıdaki başlangıç tarihlerine ait `ggplot()` histogramına bakın.

Bu yaklaşımda, `scale_x_date()` ile bir eksen üzerindeki tarihlerin *görüntülenmesini* ayarlayabilirsiniz. Daha fazla bilgi için [Salgın eğrileri] ile ilgili sayfaya bakın. `scale_x_date()` öğesinin 'date_labels = ' bağımsız değişkenine bir "strptime" görüntüleme biçimi belirleyebilirsiniz. Bu biçimler "%" yer tutucularını kullanır. Yer tutucular [Tarihlerle çalışma] sayfasında ele alınmıştır. 4 basamaklı bir yılı temsil etmek için "%Y" ve hafta numarasını temsil etmek için "%W" veya "%U" kullanın (sırasıyla Pazartesi veya Pazar haftaları).

```{r, warning=F, message=F}
linelist %>% 
  mutate(epiweek_date = floor_date(date_onset, "week")) %>%  # hafta sütununu oluştur
  ggplot()+                                                  # ggplotu başlat
  geom_histogram(mapping = aes(x = epiweek_date))+           # başlangıç tarihinin histogramı
  scale_x_date(date_labels = "%Y-W%W")                       # tarihlerin gösterimini YYYY-WWw olacak şekilde ayarla
```


### Verilerde epiweeks {.unnumbered}  

Verileri faktöre çevirmedeki amacınız grafik yapmak *değilse*, bunu iki yoldan yapabilirsiniz:  

1) *Görüntüleme üzerindeki hassas kontrol* için, **lubridate** epiweek sütununu (YYYY-AA-GG) istenen formatına (YYYY-WWw) ve ardından bunu sınıf Faktörüne dönüştürün .

İlk olarak, tarih gösterimini YYYY-AA-GG'den YYYY-Www gösterimine dönüştürmek için R tabanından `format()` komutunu kullanın (bkz. [Tarihlerle çalışma] sayfası). Bu süreçte veriler sınıftan karaktere dönüşmüş olacaktır. Ardından, `factor()` ile karakterden tekrar sınıf Factor'a dönüştürün. 


```{r}
linelist <- linelist %>% 
  mutate(epiweek_date = floor_date(date_onset, "week"),       # epiweeks oluştur (YYYY-AA-GG)
         epiweek_formatted = format(epiweek_date, "%Y-W%W"),  # (YYYY-HHh) formatına dönüştür
         epiweek_formatted = factor(epiweek_formatted))       # faktöre dönüştür

# seviyeleri göster
levels(linelist$epiweek_formatted)
```

<span style="color: red;">**_TEHLİKE:_** Haftaları yılların önüne koyarsanız ("Www-YYYY") ("%W-%Y"), varsayılan alfa-numerik sıralaması yanlış olacaktır (ör. 01-2015, 35-2014'ten önce olacaktır). Uzun ve sancılı bir süreçle, sırayı manuel olarak ayarlamanız gerekebilir.</span>  

2) *Hızlı varsayılan görüntüleme* için **aweek** paketini ve `date2week()` fonksiyonunu kullanın. `week_start =` ile haftanın ilk gününü ayarlayabilirsiniz. `factor = TRUE` olarak ayarlarsanız, çıktı sütunu sıralı bir faktör olacaktır. Ek olarak, faktör, o hafta hiç vaka olmasa bile, aralıktaki *tüm* haftalar için seviyeleri içermektedir.  

```{r, eval=F}
df <- linelist %>% 
  mutate(epiweek = date2week(date_onset, week_start = "Monday", factor = TRUE))

levels(df$epiweek)
```

**aweek** hakkında daha fazla bilgi için [Tarihlerle çalışma] sayfasına bakın. Ayrıca `week2date()` ters fonksiyonu da bu paket içinde mevcuttur.



<!-- ======================================================= -->
## Kaynaklar {} 

[faktörler ile ilgili Veri Bilimi sayfası için R](https://r4ds.had.co.nz/factors.html)  
[aweek paketi skeci](https://cran.r-project.org/web/packages/aweek/vignettes/introduction.html)
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/factors.Rmd-->


<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Verilerin pivotlanması {}

```{r, warning=F, message=F, out.height = c('50%'), fig.align="center", fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "pivoting", "Pivoting_500x500.png"))

#knitr::include_graphics(here::here("images", "pivoting", "pivot_longer_new.png"))
#knitr::include_graphics(here::here("images", "pivoting", "pivot_bar.png"))
#knitr::include_graphics(here::here("images", "pivoting", "pivot_wider_new.png"))
```



Verileri yönetirken, *pivotlama* aşağıdaki iki süreçten birini tarif eder:

1. Daha kapsamlı bir tablonun verilerini özetleyen istatistik tabloları olan *pivot tabloların* oluşturulması 
2. Bir tablonun **uzun** formattan **geniş** formata dönüştürülmesi veya tam tersi. 

**Bu sayfada, ikinci tanıma odaklanacağız.** İlk tanım, veri analizinde çok önemli bir adımdır ancak [Verileri gruplandırma] ve [Tanımlayıcı tablolar] sayfalarında ele alınmıştır.

Bu sayfada veri biçimleri tartışılmaktadır. Her değişkenin kendi sütununa, her gözlemin kendi satırına ve her değerin kendi hücresine sahip olduğu “düzenli-tidy veri” felsefesi akılda tutulmalıdır. Bu konu hakkında daha fazla bilgiyi [Veri Bilimi için R çevrimiçi](https://r4ds.had.co.nz/tidy-data.html) bölümünde bulabilirsiniz.




## Hazırlık  

### Paketlerin yüklenmesi {.unnumbered}  

Bu kod bloğu, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gereken durumlarda paketi kuran *ve* kullanım için yükleyen **pacman**'ın `p_load()` fonksiyonunun kullanımı vurgulanmıştır. Ayrıca, R tabanından `library()` ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] sayfasına bakın.

```{r}
pacman::p_load(
  rio,          # Dosyanın içe aktarımı
  here,         # Dosyanın konumu
  tidyverse)    # veri yönetimi + ggplot2 grafik paketi
```



### Verinin içeri aktarımı {.unnumbered}


### Sıtma hastalığı için sayım verisi {-}  

Bu sayfada, kuruluş ve yaş grubuna göre günlük sıtma vakalarını içeren kurgusal bir veri setini inceleyeceğiz. Adımları takip etmek isterseniz, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/malaria_facility_count_data.rds' class='download-button'>veri setini indirmek için buraya tıklayın (.rds dosyası formatında)</a>. Verileri **rio** paketinden `import()` fonksiyonuyla içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için İçe Aktarma ve Dışa Aktarma sayfasına bakın).

```{r, echo=F}
count_data <- rio::import(here::here("data", "malaria_facility_count_data.rds")) %>% 
  as_tibble()
```

```{r, eval=F}
# Verinin içeri aktarımı
count_data <- import("malaria_facility_count_data.rds")
```

İlk 50 satır aşağıda gösterilmiştir.

```{r, message=FALSE, echo=F}
# satır listesini tablo olarak göster
DT::datatable(head(count_data, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


### Satır listesi verisi {-}  

Bu sayfanın sonraki bölümünde, simüle edilmiş bir Ebola salgını vakalarını içeren veri setini de kullanacağız. Devam etmek istiyorsanız, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>“temiz” satır listesini (.rds dosyası olarak) indirmek için tıklayın.</a> Verilerinizi **rio** paketinden `import()` işleviyle içe aktarın (.xlsx, .rds, .csv gibi birçok dosya türünü kabul eder - ayrıntılar için İçe Aktarma ve Dışa Aktarma sayfasına bakın).

```{r, echo=F}
# satır listesini R'a aktar
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```


```{r, eval=F}
# Verinin içeri aktarımı
linelist <- import("linelist_cleaned.xlsx")
```







<!-- ======================================================= -->
## Genişten uzuna {}

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "pivoting", "pivot_longer_new.png"))
```


<!-- ======================================================= -->
### “Geniş” format {.unnumbered}

Veriler genellikle "geniş" bir biçimde girilir ve saklanır - burada bir gözlemin (kişinin) özellikleri veya yanıtları tek bir satırda depolanır. Bu sunum için faydalı olsa da, bazı analiz türleri için ideal değildir.  

Örnek olarak yukarıdaki Hazırlık bölümünde içe aktarılan `count_data` veri setini ele alalım. Her satırın bir “tesis-gününü” temsil ettiğini görebilirsiniz. Gerçek vaka sayıları (en sağdaki sütunlar), belirli bir tesis günündeki farklı yaş grubuna ait bilgilerin ayrı sütunlar halinde ancak tek bir satırda saklanacağı şekilde “geniş” bir formatta bulunur.

```{r, echo=F}
DT::datatable(count_data, rownames = FALSE, options = list(pageLength = 5, scrollX=T) )
```

Bu veri tabanındaki ScriptEach gözlemi, belirli bir tarihteki 65 tesisten birindeki sıtma sayımlarını gösterir; bu sayı, `count_data$data_date %>% min()` ile `count_data$data_date %>% max()` arasında değişir. Bu tesisler bir `Province (il)` (North) ve dört `District (ilçe)`de (Spring, Bolo, Dingo ve Barnard) bulunmaktadır. Veri seti, genel sıtma sayılarının yanı sıra üç yaş grubunun her birinde - <4 yaş, 5-14 yaş ve 15 yaş ve üzeri - yaşa özel sayıları da içermektedir.

Bunun gibi "geniş" veriler "düzenli veri" standartlarına uymaz, çünkü sütun başlıkları aslında "değişkenleri" temsil etmez - bunlar hipotetik bir "yaş grubu" *değişkenini* temsil eder.

Bu format, bilgileri bir tabloda sunmak veya vaka raporu formlarına veri girmek (örn. Excel'de) için faydalı olabilir. Ancak, analiz aşamasında, bu veriler tipik olarak "düzenli veri" standartlarıyla daha uyumlu "daha uzun" bir formata dönüştürülmelidir. Özellikle R paketi **ggplot2**, veriler "uzun" formatta olduğunda en iyi sonuçları verir.  


*Toplam* sıtma sayılarının zamana göre görselleştirilmesinde, mevcut formattaki verilerle herhangi bir zorluk yaşanmaz:

```{r, warning=F, message=F}
ggplot(count_data) +
  geom_col(aes(x = data_date, y = malaria_tot), width = 1)
```

Ancak, her yaş grubunun bu toplam sayıya göreli katkılarını göstermek istersek ne olur? Bu durumda, ilgilenilen değişkenin (yaş grubu), veri kümesinde `{ggplot2}`'nin "haritalama estetiği" `aes()` argümanına aktarılabilecek tek bir sütunda bulunması gerekir.


<!-- ======================================================= -->
### `pivot_longer()` {.unnumbered}

**tidyr** fonksiyonu `pivot_longer()`, verileri "daha uzun" formata getirir. **tidyr**, R paketlerinin **tidyverse** kümesinin bir parçasıdır.

Bu fonksiyon, dönüştürülecek bir dizi sütunu kabul eder (`cols =` argümanı ile belirtilir). Bu nedenle, bir veri tabanının yalnızca bir kısmıyla çalışabilir. Bu fonksiyonla yalnızca vaka sayısı sütunlarını döndürmek istediğimizden, kullandığımız veritabanı için yararlıdı  

Bu süreçte, biri kategorileri (eski sütun adları) ve diğeri de karşılık gelen değerleri (ör. vaka sayıları) içeren iki "yeni" sütun elde edeceksiniz. Bu yeni sütunlar için varsayılan adları kabul edebilir veya kendi adlarınızı sırasıyla `names_to =` ve `values_to =`  argümanlarıyla belirtebilirsiniz. 

`Pivot_longer()`'ı çalışırken görelim… 


### Standard pivoting {.unnumbered}  

"Geniş" verileri "uzun" bir biçime dönüştürmek için **tidyr**'in `pivot_longer()` fonksiyonunu kullanmak istiyoruz. Spesifik olarak, sıtma sayılarına ilişkin verileri içeren dört sayısal sütunu iki yeni sütuna dönüştürmek istiyoruz. İki yeni sütundan biri *yaş gruplarını* ve diğeri yaş gruplarına karşılık gelen *değerleri* içerecektir.

```{r, eval=F}
df_long <- count_data %>% 
  pivot_longer(
    cols = c(`malaria_rdt_0-4`, `malaria_rdt_5-14`, `malaria_rdt_15`, `malaria_tot`)
  )

df_long
```

Yeni oluşturulan veri çerçevesinin (`df_long`) daha fazla satırı olduğuna dikkat edin (12.152'ye karşı 3.038); böylece veri çerçevesi daha *uzun* bir şekle sahip olur. Aslında, eski versiyonuna göre tam olarak dört kat daha uzundur, çünkü orijinal veri kümesindeki her satır şimdi `df_long`'da dört satırı temsil etmektedir (her bir sıtma sayımı gözlemi yaş grubu için bir tane (<4y, 5-14y, 15y+ ve toplam)).

Daha önce dört sütunda (`malaria_` ön ekiyle başlayanlar) depolanan veriler şimdi iki sütunda depolandığından, daha uzun olmanın yanı sıra, yeni veri kümesi daha az sütuna (8'e karşı 10) sahiptir.

Bu dört sütunun adlarının tümü `malaria_` önekiyle başladığından, aynı sonucu elde etmek için kullanışlı "tidyselect" `start_with()` işlevini kullanabilirdik (bu yardımcı işlevlerin daha fazlası için [Verileri temizleme ve temel işlevler] sayfasına bakın).


```{r}
# tidyselect yardımcı işleviyle sütun sağlayın
count_data %>% 
  pivot_longer(
    cols = starts_with("malaria_")
  )
```

ya da pozisyona göre:

```{r, eval=F}
# pozisyona göre sütun sağlamak
count_data %>% 
  pivot_longer(
    cols = 6:9
  )
```

veya adlandırılmış aralığa göre:

```{r, eval=F}
# ardışık sütun aralıkları sağlama
count_data %>% 
  pivot_longer(
    cols = `malaria_rdt_0-4`:malaria_tot
  )
```

Bu iki yeni sütuna varsayılan `ad` ve `değerler` verilir, ancak istediğimiz adları verebilmek için bu varsayılan adları geçersiz kılabiliriz; `names_to` ve `values_to` argümanlarını kullanarak yeni sütunlarda hangi bilgilerin depolandığını hatırlayabiliriz. `Age_group` adlarını ve sayılarını kullanalım:

```{r}
df_long <- 
  count_data %>% 
  pivot_longer(
    cols = starts_with("malaria_"),
    names_to = "age_group",
    values_to = "counts"
  )

df_long
```

Şimdi bu yeni veri kümesini `{ggplot2}`'ye aktarabiliriz ve yeni sütunlardaki `count` y eksenine ve yeni `age_group` sütununu `fill =` argümanına (sütun iç kısmının rengi) atayabiliriz. Bu komut, çubuk grafikte yaş grubuna göre sıtma sayılarını gösterir:

```{r, warning=F, message=F}
ggplot(data = df_long) +
  geom_col(
    mapping = aes(x = data_date, y = counts, fill = age_group),
    width = 1
  )
```

Bu yeni grafiği inceleyin ve daha önce oluşturduğumuz grafikle karşılaştırın – *Sizce yanlış giden ne?*

Sürveyans verilerini incelerken yaygın bir sorunla karşılaştık: Grafikteki her çubuğun boyu olması gerekenin iki katıdır, çünkü grafiğe `malaria_tot` sütunundaki toplam sayıları da dahil ettik.

Bu sorunu birkaç şekilde halledebiliriz. `ggplot()`'a aktarmadan önce bu toplamları veri kümesinden filtreleyebiliriz:

```{r, warning=F, message=F}
df_long %>% 
  filter(age_group != "malaria_tot") %>% 
  ggplot() +
  geom_col(
    aes(x = data_date, y = counts, fill = age_group),
    width = 1
  )
```

Alternatif olarak, `pivot_longer()`'ı çalıştırdığımızda bu değişkeni hariç tutabilirdik, böylece sorun oluşturan bu değişkeni ayrı bir değişken olarak veri kümesinde tutabilirdik. Değerlerin yeni satırları doldurmak için nasıl "genişlediğini" inceleyin.

```{r, warning=F, message=F}
count_data %>% 
  pivot_longer(
    cols = `malaria_rdt_0-4`:malaria_rdt_15,   # does not include the totals column
    names_to = "age_group",
    values_to = "counts"
  )
```


### Birden çok sınıfa ait verinin pivotlanması {.unnumbered}

Yukarıdaki örnek, daha uzun şekilde pivotlamak istediğiniz tüm sütunların aynı sınıfta olduğu durumlarda (karakter, sayısal, mantıksal…) iyi çalışır.

Bununla birlikte, bir saha epidemiyoloğu olarak, bu konuda uzman olmayanlar tarafından hazırlanan ve standart dışı verilerle çalışacağınız birçok durum olacaktır - Hadley Wickham'ın **Düzenli Veri** ilkeleri üzerine [ufuk açıcı makalesinde](https://vita.had.co.nz/papers/tidy-data.pdf) Tolstoy'a atıfta bulunarak belirttiği gibi "Düzenli veri kümelerinin hepsi birbirine benzer, ancak her dağınık veri kümesi kendi tarzında dağınıktır, aynı aileler gibi."

Karşılaşacağınız özellikle yaygın bir sorun, farklı veri sınıfları içeren sütunları döndürme ihtiyacı olacaktır. Bu pivot işlemi, farklı veri türlerinin tek bir sütunda depolanmasına neden olur ve bu durum istenmeyen bir sonuçtur. Bunun yarattığı karışıklığı ortadan kaldırmak için çeşitli yaklaşımlar vardır. Ancak bu duruma düşmemek için `pivot_longer()` kullanımında uygulanabilecek önemli bir adım vardır.

A, B ve C öğelerinin her biri için farklı zamanlarda bir dizi gözlemin olduğu bir durumu ele alın. Bu öğeler örneğin farklı bireyler (örneğin 21 gün boyunca her gün bir Ebola vakasının temaslıları) veya hala çalışır durumda olduklarından emin olmak için yılda bir kez izlenen sağlık ocakları olabilir. Temaslı kişilerini izlemini ele alalım. Verilerin aşağıdaki gibi kaydedildiğini düşünelim:


```{r, message=FALSE, echo=F}

df <- 
  tibble::tribble(
     ~id,   ~obs1_date, ~obs1_status,   ~obs2_date, ~obs2_status,   ~obs3_date, ~obs3_status,
     "A", "2021-04-23",    "Healthy", "2021-04-24",    "Healthy", "2021-04-25",     "Unwell",
     "B", "2021-04-23",    "Healthy", "2021-04-24",    "Healthy", "2021-04-25",    "Healthy",
     "C", "2021-04-23",    "Missing", "2021-04-24",    "Healthy", "2021-04-25",    "Healthy"
     ) 

DT::datatable(df, rownames = FALSE)

```

Verinin durumu başlangıçta karmaşıktır. Her satır, bir öğe hakkında veri içerir, ancak zaman serilerinde zamandaki ilerleme ile sütunlarda sağa doğru ilerleme izlenmektedir. Ayrıca, sütun sınıfları sırayla tarih ve karakter değerleri almaktadır.  

Bu araştırmacının karşılaştığı kötü bir örnek, 4 yıl boyunca *her gün* 8 yeni gözlem sütununun eklendiği kolera sürveyans verilerini içeriyordu. Bu verilerin depolandığı Excel dosyasını açmak, dizüstü bilgisayarda 10 dakikan fazla zaman almıştır.

Bu verilerle çalışmak için, veri çerçevesini uzun biçime dönüştürmemiz, ancak her öğeye ait tüm gözlemler için `date` ve `character` (durum) sütunu arasındaki ayrımı korumamız gerekir. Bunu yapmazsak, tek bir sütunda değişken türleri karışık şekilde bulunur (Veri yönetimi ve düzenli veriler söz konusu olduğunda gerçekten istenmeyen bir durumdur):

```{r}
df %>% 
  pivot_longer(
    cols = -id,
    names_to = c("observation")
  )

```

Yukarıda, pivot komutu, *tarihleri* ve *karakterleri* tek bir değer sütununda birleştirdi. Bu durumda R, tüm sütunu sınıf karakterine dönüştür ve tarih özellikleri kaybolur.  

Bu durumu önlemek için orijinal sütun adlarının sintaks yapısından yararlanabiliriz. Gözlem numarası, alt çizgi ve ardından “durum” veya “tarih” bilgisi içeren ortak bir adlandırma şeklini kullanmak faydalıdır. Pivot sonrası bu iki veri türünü ayrı sütunlarda tutmak için bu sintakstan yararlanabiliriz.

Bunu şu şekilde yapıyoruz:

* İkinci öğe (`".value"`) olmak üzere, `names_to =` argümanına bir karakter vektörü yazmalısınız. Bu özel terim, pivot sütunlarının adlarındaki bir karaktere göre nasıl bölüneceğini belirtir. 
* Ayrıca, `name_sep =` argümanına “splitting-ayırma” karakterini de yazmalısınız. Bu durumda, ayırma karakteri alt çizgidir ( "_”)

Bu nedenle, yeni sütunların adlandırılması ve bölünmesi, mevcut değişken adlarındaki alt çizgiye göre gerçekleşir. 

```{r}

df_long <- 
  df %>% 
  pivot_longer(
    cols = -id,
    names_to = c("observation", ".value"),
    names_sep = "_"
  )

df_long

```

__Son dokunuşlar__:

Tarih sütununun şu anda *character* sınıfında olduğuna dikkat edin. [Tarihlerle çalışma] sayfasında açıklanan `mutate()` ve `as_date()` fonksiyonlarını kullanarak sınıfı kolayca uygun tarih sınıfına dönüştürebiliriz.

Ayrıca, "obs" ön ekini silerek `observation` sütununu `sayısal` bir biçime dönüştürmek isteyebiliriz. Bunu **stringr** paketinden `str_remove_all()` ile yapabiliriz ([Karakterler ve dizeler] sayfasına bakın).

```{r}

df_long <- 
  df_long %>% 
  mutate(
    date = date %>% lubridate::as_date(),
    observation = 
      observation %>% 
      str_remove_all("obs") %>% 
      as.numeric()
  )

df_long

```

Ve şimdi bu formattaki verilerle çalışmaya başlayabiliriz, örn. açıklayıcı bir ısı döşemesi çizerek: 

```{r}
ggplot(data = df_long, mapping = aes(x = date, y = id, fill = status)) +
  geom_tile(colour = "black") +
  scale_fill_manual(
    values = 
      c("Healthy" = "lightgreen", 
        "Unwell" = "red", 
        "Missing" = "orange")
  )

```





<!-- ======================================================= -->
## Uzundan genişe {}

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "pivoting", "pivot_wider_new.png"))
```

Bazı durumlarda, bir veri tabanını daha geniş bir formata dönüştürmek isteyebiliriz. Bunun için `pivot_wider()` fonksiyonunu kullanabiliriz.

Analiz sonuçlarını okuyucu için daha anlaşılır bir formata dönüştürmek istediğimiz zamandır (örneğin, [Sunum için bir tablo][Tables for presentation]), bu fonksiyonu. Genellikle bu işlem, bir gözlem için değerlerin birden çok satıra yayıldığı bir veri kümesinin, bu değerlerin tek bir satırda depolandığı bir formata dönüştürülmesini içerir.

### Veri {.unnumbered}

Sayfanın bu bölümü için, vaka başına bir satır içeren satır listesini kullanacağız ([Hazırlık](#pivot_prep) bölümüne bakın).

İlk 50 satır: 

```{r, message=FALSE, echo=F}
# satır listesini tablo olarak göster
DT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Farklı yaş gruplarındaki bireylerin sayısını cinsiyete göre bilmek istediğimizi varsayalım:

```{r}
df_wide <- 
  linelist %>% 
  count(age_cat, gender)

df_wide
```

Bu bize, **ggplot2**'de görselleştirme için harika, ancak tabloda sunum için ideal olmayan uzun bir veri tabanı sağlar:

```{r}
ggplot(df_wide) +
  geom_col(aes(x = age_cat, y = n, fill = gender))
```

### Daha geniş olarak pivotlama {.unnumbered}  

Bu nedenle, verileri raporlara tablo olarak dahil etmek amaçlı olarak daha uygun biçime dönüştürmek için `pivot_wider()`'ı kullanabiliriz.

name_from argümanı, yeni sütun adlarının oluşturulacağı *names* sütunu belirtirken; `values_from` argümanı, hücreleri doldurmak için gereken değerlerin alınacağı sütunu belirtir. `id_cols =` argümanı isteğe bağlıdır, ancak döndürülmemesi gereken satırları içeren sütun adları vektörünü içerir ..  

```{r}
table_wide <- 
  df_wide %>% 
  pivot_wider(
    id_cols = age_cat,
    names_from = gender,
    values_from = n
  )

table_wide
```

Bu tablo daha okuyucu dostudur ve bu nedenle raporlarımıza dahil edilmesi daha uygundur. **Flextable** ve **knitr** dahil olmak üzere çeşitli paketlerle güzel bir tablolar oluşturulabilir. Bu süreç [Sunum için tablolar] sayfasında daha detaylı olarak anlatılmıştır.  

```{r}
table_wide %>% 
  janitor::adorn_totals(c("row", "col")) %>% # adds row and column totals
  knitr::kable() %>% 
  kableExtra::row_spec(row = 10, bold = TRUE) %>% 
  kableExtra::column_spec(column = 5, bold = TRUE) 
```

---


<!-- ======================================================= -->
## Doldurma 

Bazı durumlarda pivot işlemi sonrası ve daha yaygın olarak bir birleştirme sonrası, bazı hücrelerde doldurmak istediğimiz boşluklar kalır.  

<!-- ======================================================= -->
### Veri {.unnumbered}

Örneğin, ölçüm numarası, tesisin adı ve o andaki vaka sayısı için gözlemleri olan iki veri tabanını inceleyelim. Ancak, ikinci veri kümesinde ek olarak `Year` değişkeni vardır.

```{r}
df1 <- 
  tibble::tribble(
       ~Measurement, ~Facility, ~Cases,
                  1,  "Hosp 1",     66,
                  2,  "Hosp 1",     26,
                  3,  "Hosp 1",      8,
                  1,  "Hosp 2",     71,
                  2,  "Hosp 2",     62,
                  3,  "Hosp 2",     70,
                  1,  "Hosp 3",     47,
                  2,  "Hosp 3",     70,
                  3,  "Hosp 3",     38,
       )

df1 

df2 <- 
  tibble::tribble(
    ~Year, ~Measurement, ~Facility, ~Cases,
     2000,            1,  "Hosp 4",     82,
     2001,            2,  "Hosp 4",     87,
     2002,            3,  "Hosp 4",     46
  )

df2
```

İki veri kümesini birleştirmek için bir `bind_rows()` işlemi gerçekleştirdiğimizde, `Year` değişkeni, ön bilgi bulunmayan satırlar için (yani ilk veri kümesinde) `NA` ile doldurulur:


```{r}
df_combined <- 
  bind_rows(df1, df2) %>% 
  arrange(Measurement, Facility)

df_combined

```

<!-- ======================================================= -->
### `fill()` {.unnumbered}

Bu durumda, özellikle zaman içindeki eğilimleri keşfetmek istiyorsak, yıl dahil etmek için yararlı bir değişkendir. Bu nedenle, doldurulacak sütunu ve *doldurma* yönünü (bu durumda **yukarı**) belirterek boş hücreleri doldurmak için `fill()` komutunu kullanırız:

```{r}
df_combined %>% 
  fill(Year, .direction = "up")
```

Alternatif olarak, verileri aşağı yönde dolduracak şekilde yeniden düzenleyebiliriz:

```{r}
df_combined <- 
  df_combined %>% 
  arrange(Measurement, desc(Facility))

df_combined

df_combined <- 
  df_combined %>% 
  fill(Year, .direction = "down")

df_combined
```

Artık görselleştirmek için kullanışlı bir veri setimiz var:

```{r}
ggplot(df_combined) +
  aes(Year, Cases, fill = Facility) +
  geom_col()
```

Ancak bu form tablo halinde sunmak için daha az kullanışlıdır, bu yüzden uzun, düzensiz veri çerçevesini daha geniş, düzenli bir veri çerçevesine dönüştürme alıştırması yapalım:

```{r}
df_combined %>% 
  pivot_wider(
    id_cols = c(Measurement, Facility),
    names_from = "Year",
    values_from = "Cases"
  ) %>% 
  arrange(Facility) %>% 
  janitor::adorn_totals(c("row", "col")) %>% 
  knitr::kable() %>% 
  kableExtra::row_spec(row = 5, bold = TRUE) %>% 
  kableExtra::column_spec(column = 5, bold = TRUE) 
```

Not:  Bu durumda, ek değişken olan “ölçüm” tablonun oluşturulmasına engel olacağından, yalnızca `Facility`, `Year` ve `Cases` değişkenleri dahil edilmelidir:

```{r}
df_combined %>% 
  pivot_wider(
    names_from = "Year",
    values_from = "Cases"
  ) %>% 
  knitr::kable()
```

## Kaynaklar  

Yararlı bir [eğitim](https://datacarpentry.org/r-socialsci/03-dplyr-tidyr/index.html)

```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/pivoting.Rmd-->


# Verileri Gruplama { }  


```{r, out.width=c('100%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "Grouping_1500x500.png"))
```

Bu sayfa, tanımlayıcı analiz için verilerin nasıl gruplandırılacağını ve toplanacağını kapsar. Ortak ve kullanımı kolay fonksiyonlar için **tidyverse** paket ailesini kullanır.


Verileri gruplamak, veri yönetimi ve analizinin temel bir bileşenidir. Gruplandırılmış veriler istatistiksel olarak grup tarafından özetlenir ve grup tarafından çizilebilir. **dplyr** paketindeki fonksiyonlar (**tidyverse**'in bir parçası) gruplandırmayı ve sonraki işlemleri oldukça kolaylaştırır.

Bu sayfa aşağıdaki konuları ele alacaktır:

* `group_by()` fonksiyonuyla verileri gruplayın
* Grubun verilerini kaldırma
* `summarise()` istatistiklerle gruplandırılmış veriler
* `count()` ve `tally()` arasındaki fark
* gruplandırılmış verilere uygulanan `arrange()`
* gruplandırılmış verilere uygulanan `filter()`
* gruplandırılmış verilere uygulanan `mutate()`
* gruplandırılmış verilere uygulanan `select()`
* Alternatif olarak  R **tabanı** `aggregate()` komutu

## Hazırlık {  }
     
### Paketleri yükleyin {.unnumbered}
     
Bu kod parçası, analizler için gereken paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran *ve* kullanım için yükleyen **pacman**'dan `p_load()` vurgusunu yapıyoruz.  R **tabanı**ndan `library()` ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakabilirsiniz.


```{r}
pacman::p_load(
  rio,       # verileri içe aktarma
  here,      # dosyaları konumlama
  tidyverse, # veriyi temizleme, işleme ve grafikleştirme (dplyr dahil)
  janitor)   # toplam satır ve süruna ekleme yapma
```




### Verileri içe aktar {.unnumbered}

Simüle edilmiş bir Ebola salgınından vakaların veri setini içe aktarıyoruz. Takip etmek isterseniz, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>"clean" dosyasını indirmek için tıklayın</a> (.rds dosyası olarak). Veri kümesi, **rio** paketinden `import()` fonksiyonu kullanılarak içe aktarılır. Verileri içe aktarmanın çeşitli yolları için [İçe ve dışa aktar] hakkındaki sayfaya bakın.

```{r, echo=F}
linelist <- rio::import(here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
linelist <- import("linelist_cleaned.rds")
```


"linelist"in ilk 50 satırı:

```{r message=FALSE, echo=F}
DT::datatable(head(linelist,50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


## Gruplandırma { }
     
**dplyr**'den `group_by()` fonsiyonu, satırları kendisine belirtilen sütundaki benzersiz değerlere göre gruplandırır. Birden çok sütun belirtilirse, satırlar sütunlar boyunca benzersiz değer kombinasyonlarına göre gruplanır. Her benzersiz değer (veya değer kombinasyonu) bir grup oluşturur. Veri kümesinde veya hesaplamalarda sonraki değişiklikler daha sonra her grup bağlamında gerçekleştirilebilir.

Örneğin, aşağıdaki komut "linelist"i alır ve satırları "outcome" sütunundaki benzersiz değerlere göre gruplayarak çıktıyı yeni bir "ll_by_outcome" veri çerçevesi olarak kaydeder. Gruplandırma sütunu/sütunları, 'group_by()' fonksiyonunun parantezlerin içine yerleştirilir.

```{r}
ll_by_outcome <- linelist %>% 
  group_by(outcome)
```

**Veri kümesinde algılanabilir bir değişiklik olmadığını unutmayın**
`group_by()` çalıştırıldıktan sonra, `mutate()`, `summarise()` veya `arrange()` gibi başka bir **dplyr** fiili "gruplandırılmış" veri çerçevesine *kadar* uygulanır.

Bununla birlikte, veri çerçevesini yazdırarak gruplamaları "görebilirsiniz". Gruplandırılmış bir veri çerçevesi yazdırdığınızda, bunun yazdırıldığında hangi gruplamaların uygulandığını ve kaç tane olduğunu gösteren bir  [`tibble` sınıf nesnesine](https://tibble.tidyverse.org/) dönüştürüldüğünü göreceksiniz - başlık satırının hemen üstüne yazılır.

```{r}
# hangi grupların aktif olduğunu görmek için yazdır
ll_by_outcome
```


### Benzersiz gruplar {.unnumbered}

**Oluşturulan gruplar, gruplandırma sütunlarında her benzersiz değer kombinasyonunu yansıtır.**

Grupları *ve her gruptaki* satır sayısını görmek için gruplanmış verileri 'tally()' öğesine iletin. Sadece benzersiz, sayısız grupları görmek için `group_keys()` öğesine geçebilirsiniz.

Aşağıda, "sonuç" gruplandırma sütununda **üç** benzersiz değer olduğunu görün: "Ölüm", "İyileşme" ve "NA". ` nrow(linelist %>% filter(outcome == "Death"))` ölümler, ` nrow(linelist %>% filter(outcome == "Recover"))` ve ` nrow(linelist %)` olduğunu görün >% filter(is.na(outcome)))` hiçbir sonuç kaydedilmedi.

```{r}
linelist %>% 
  group_by(outcome) %>% 
  tally()
```

Birden fazla sütuna göre gruplandırabilirsiniz. Aşağıda, veri çerçevesi "sonuç" ve "cinsiyet"e göre gruplandırılır ve ardından hesaplanır. "Sonuç" ve "cinsiyet"in her benzersiz kombinasyonunun kendi grubu olarak nasıl kaydedildiğine dikkat edin - her iki sütun için de eksik değerler dahil edilmektedir.

```{r}
linelist %>% 
  group_by(outcome, gender) %>% 
  tally()
```

### Yeni sütunlar {.unnumbered}

Ayrıca, "group_by()" ifadesinin *içinde* yeni bir gruplandırma sütunu da oluşturabilirsiniz. Bu, 'group_by()'dan önce 'mutate()' çağrısına eşdeğerdir. Hızlı bir tablolama için bu stil kullanışlı olabilir, ancak kodunuzda daha fazla netlik için bu sütunu kendi `mutate()` adımında oluşturmayı ve ardından `group_by()` ile bağlantı kurmayı düşünün.

```{r}
# group_by() komut satırı listesi %>% *içinde* oluşturulan bir ikili sütuna dayalı grup verileri
linelist %>% 
     group_by(
          age_class = ifelse(age >= 18, "adult", "child")) %>% 
     tally(sort = T)
```

### Gruplandırma sütunlarını ekle/bırak {.unnumbered}

Varsayılan olarak, zaten gruplanmış veriler üzerinde `group_by()` çalıştırırsanız, eski gruplar kaldırılacak ve yenileri uygulanacaktır. Mevcut gruplara yeni gruplar eklemek istiyorsanız, `.add = TRUE` değişkenini ekleyin.

````{r, eval=F}
# Çıktıya göre gruplama
by_outcome <- linelist %>% 
  group_by(outcome)

# İlave olarak cinsiyet olarak gruplama eklemesi
by_outcome_gender <- by_outcome %>% 
  group_by(gender, .add = TRUE)
```


** Tüm grupları tut**

Bir sınıf faktörü sütununda gruplandırırsanız, şu anda verilerde mevcut olmayan faktör seviyeleri olabilir. Bu sütunda gruplandırırsanız, varsayılan olarak mevcut olmayan seviyeler bırakılır ve grup olarak dahil edilmez. Bunu, tüm seviyelerin gruplar halinde görüneceği şekilde değiştirmek için (verilerde mevcut olmasa bile), `group_by()` komutunuzda `.drop = FALSE` değerini ayarlayın.


## Grubu kaldır

Gruplandırılmış veriler, 'ungroup()' aracılığıyla özellikle işlenene kadar gruplanmış olarak kalacaktır. Grubu çözmeyi unutursanız, yanlış hesaplamalara yol açabilir! Aşağıda tüm gruplamaların kaldırılmasına ilişkin bir örnek verilmiştir:

```{r, eval=F}
linelist %>% 
  group_by(outcome, gender) %>% 
  tally() %>% 
  ungroup()
```

Ayrıca, sütun adını "ungroup()" içine yerleştirerek yalnızca belirli sütunlar için gruplamayı kaldırabilirsiniz.

```{r, eval=F}
linelist %>% 
  group_by(outcome, gender) %>% 
  tally() %>% 
  ungroup(gender) # cinsiyete göre gruplamayı kaldır, sonuca göre gruplamayı bırak
```


<span style="color: black;">**_NOT:_** `count()` fiili saydıktan sonra verilerin grubunu otomatik olarak çözer.</span>



## Özetleme {#group_summarise}

Özet tablolarının "summarise()" ile nasıl oluşturulacağına ilişkin ayrıntılı bir açıklama için [Tanımlayıcı tablolar] sayfasının **dplyr** bölümüne bakın. Burada, gruplandırılmış verilere uygulandığında davranışının nasıl değiştiğini kısaca ele alıyoruz.

**dplyr** fonksiyonu`summarise()` (veya `summarize()`) bir veri çerçevesi alır ve onu tanımladığınız özet istatistikleri içeren sütunlarla birlikte *yeni* bir özet veri çerçevesine dönüştürür. Gruplandırılmamış bir veri çerçevesinde, tüm satırlardan özet istatistikler hesaplanacaktır. Gruplandırılmış verilere 'summarise()' uygulamak, *her grup için* bu özet istatistikleri üretir.

`summarise()` sözdizimi, **yeni** özet sütun(lar)ının adlarını, bir eşittir işaretini ve ardından aşağıda gösterildiği gibi verilere uygulanacak istatistiksel bir fonksiyon sağlayacak şekildedir. Örneğin, "min()", "max()", "median()" veya "sd()". İstatistiksel fonksiyon içinde, üzerinde çalışılacak sütunu ve ilgili herhangi bir değişkeni listeleyebilir (ör. "na.rm = TRUE"). Mantıksal bir ölçütü karşılayan satırların sayısını saymak için `sum()` kullanabilirsiniz (çift eşittir `==` ile).

Aşağıda, *gruplandırılmış veriler olmadan* uygulanan bir `summarise()` örneği verilmiştir. Döndürülen istatistikler, tüm veri kümesinden üretilir.    

```{r}
# gruplandırılmamış satır listesindeki özet istatistikler
linelist %>% 
  summarise(
    n_cases  = n(),
    mean_age = mean(age_years, na.rm=T),
    max_age  = max(age_years, na.rm=T),
    min_age  = min(age_years, na.rm=T),
    n_males  = sum(gender == "m", na.rm=T))
```

Buna karşılık, aşağıda gruplanmış verilere uygulanan aynı "summarise()" ifadesi yer almaktadır. İstatistikler, her bir "sonuç" grubu için hesaplanır. Gruplandırma sütunlarının yeni veri çerçevesine nasıl taşınacağına dikkat edin.    

```{r}
# gruplandırılmış satır listesindeki özet istatistikler
linelist %>% 
  group_by(outcome) %>% 
  summarise(
    n_cases  = n(),
    mean_age = mean(age_years, na.rm=T),
    max_age  = max(age_years, na.rm=T),
    min_age  = min(age_years, na.rm=T),
    n_males    = sum(gender == "m", na.rm=T))
```

<span style="color: darkgreen;">**_İPUCU:_** TÖzetleme işlevi hem Birleşik Krallık hem de ABD yazımıyla çalışır - `summarise()` ve `summarize()` aynı fonksiyonu çağırır.</span>




## Sayımlar ve seriler

`count()` ve `tally()` benzer işlevsellik sağlar ancak farklıdır. "tally()" ve "count()" arasındaki fark hakkında daha fazla bilgiyi [buradan](https://dplyr.tidyverse.org/reference/tally.html) okuyabilirsiniz.

### `tally()` {.unnumbered}

"tally()", "summarise(n = n())" ifadesinin kısaltmasıdır ve verileri *gruplandırmaz*. Bu nedenle, gruplandırılmış çetelelere ulaşmak için bir 'group_by()' komutunu izlemesi gerekir. Önce en büyük grupları görmek için `sort = TRUE` ekleyebilirsiniz.  

```{r}
linelist %>% 
  tally()
```


```{r}
linelist %>% 
  group_by(outcome) %>% 
  tally(sort = TRUE)
```


### `count()` {.unnumbered}

Buna karşılık, "count()" şunları yapar:

1) belirtilen sütun(lar)a `group_by()` uygular
2) "summarise()" uygular ve grup başına satır sayısıyla "n" sütununu döndürür
3) `ungroup()` uygular

```{r}
linelist %>% 
  count(outcome)
```

Tıpkı 'group_by()' ile olduğu gibi, 'count()' komutu için de yeni bir sütun oluşturabilirsiniz:

```{r}
linelist %>% 
  count(age_class = ifelse(age >= 18, "adult", "child"), sort = T)
```


`count()`, "yuvarlama"nın kullanışlılığı ile birden çok kez çağrılabilir. Örneğin, her bir cinsiyet için mevcut hastanelerin sayısını özetlemek için aşağıdakileri çalıştırın. Son sütunun adının, netlik için varsayılan "n" yerine değiştirildiğini unutmayın (`name = ` ile).

```{r}
linelist %>% 
  # benzersiz sonuç-cinsiyet gruplarına göre sayımlar üretmek
  count(gender, hospital) %>% 
  #cinsiyete göre satırları toplayın (3) ve cinsiyete göre hastane sayısını sayın (6)
  count(gender, name = "hospitals per gender" ) 
```


### Sayıları ekle {.unnumbered}

'count()' ve 'summarise()'in aksine, diğer tüm veri çerçevesi sütunlarını korurken grup başına satır sayısıyla yeni bir 'n' sütunu eklemek için 'add_count()' kullanabilirsiniz.

Bu, yeni `n` sütunundaki bir grubun sayım numarasının grubun her satırına yazdırılacağı anlamına gelir. Gösteri amacıyla, bu sütunu ekliyoruz ve daha sonra daha kolay görüntüleme için sütunları yeniden düzenliyoruz. Başka bir örnek için aşağıdaki [grup boyutuna göre filtrele](#group_filter_grp_size) bölümüne bakabilirsiniz.


```{r}
linelist %>% 
  as_tibble() %>%                   # daha güzel baskı için tibble'a dönüştürün
  add_count(hospital) %>%           # hastaneye göre sayılarla n sütunu ekle
  select(hospital, n, everything()) # demo amaçlı yeniden düzenlemek
```



### Toplamları ekle {.unnumbered}

"tally()" veya "count()" kullandıktan sonra toplam *sum* satırlarını veya sütunlarını kolayca eklemek için [Tanımlayıcı tablolar](#tbl_janitor) sayfasının **janitor** bölümüne bakın. Bu paket, toplamları eklemek ve yüzdeleri göstermek için dönüştürmek için 'adorn_totals()' ve 'adorn_percentages()' gibi fonksiyonlar sunar. Aşağıda kısa bir örnek verilmiştir:  

```{r}
linelist %>%                                  # vaka satır listesi 
  tabyl(age_cat, gender) %>%                  # iki sütunun çapraz tablo sayımları
  adorn_totals(where = "row") %>%             # toplam satır ekle
  adorn_percentages(denominator = "col") %>%  # sütun paydası ile oranlara dönüştürme
  adorn_pct_formatting() %>%                  # oranları yüzdelere çevir
  adorn_ns(position = "front") %>%            # "count (percent)" olarak göster
  adorn_title(                                # başlıkları ayarla
    row_name = "Age Category",
    col_name = "Gender")
```


*Toplamlar* dışında özet istatistikleri içeren daha karmaşık 'sums' satırları eklemek için [Tanımlayıcı Tablolar sayfasının bu bölümüne](#tbl_dplyr_totals) bakabilirsiniz.


## Tarihe göre gruplama

Verileri tarihe göre gruplarken, ilgilenilen tarih birimi için bir sütuna sahip olmalısınız (veya oluşturmalısınız) (örneğin "gün", "epiweek", "ay", vb.) **lubridate**'den 'floor_date()' kullanarak bu sütunu oluşturabilirsiniz. [Tarihlerle çalışma] sayfasının [Epidemiyolojik haftalar bölümünde](#dates_epi_wks) açıklandığı gibi. Bu sütuna sahip olduğunuzda, satırları bu benzersiz tarih değerlerine göre gruplandırmak ve toplam sayıları elde etmek için **dplyr**'den `count()` kullanabilirsiniz.

Tarih durumları için ortak bir ek adım, dizide verilerde mevcut olmayan tüm tarihleri ​​"doldurmaktır". **tidyr**'den 'complete()' kullanın, böylece aralık içindeki *tüm olası tarih birimleri* dahil olmak üzere toplu tarih serisi tamamlanır. Bu adım olmadan, hiçbir vakanın bildirilmediği bir hafta verilerinizde görünmeyebilir!

'complete()' içinde, tarih sütununuzu minimumdan maksimuma 'seq.Date()' tarihlerinin bir *dizisi* olarak *yeniden tanımlarsınız*. Böylece tarihler genişletilir. Varsayılan olarak, herhangi bir yeni "genişletilmiş" satırdaki büyük/küçük harf sayısı değerleri "NA" olacaktır. Adlandırılmış bir liste bekleyen 'complete()' öğesinin 'fill = ' değişkenini kullanarak bunları 0'a ayarlayabilirsiniz (sayımlar sütununuz 'n' olarak adlandırılmışsa, 'fill = list(n = 0)' sağlayın. Ayrıntılar için ?complete' komutuna ve örnek için [Tarihlerle çalışma](#dates_epi_wks) sayfasına bakabilirsiniz.



###  Günlere göre satır listesi vakaları {.unnumbered}

Burada, "complete()" kullanılmadan ​günlere göre gruplandırma örneği verilmiştir. İlk satırların hiçbir durum olmadan tarihleri atladığını unutmayın.

```{r}
daily_counts <- linelist %>% 
  drop_na(date_onset) %>%        # date_onset eksik olanları kaldırın
  count(date_onset)              # benzersiz tarih başına satır sayısını say
```

```{r message=FALSE, echo=F}
DT::datatable(daily_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Aşağıda, aralıktaki her günün temsil edilmesini sağlamak için `complete()` komutunu ekliyoruz.

```{r, eval=F}
daily_counts <- linelist %>% 
  drop_na(date_onset) %>%                 # date_onset eksik vakayı kaldır
  count(date_onset) %>%                   # benzersiz tarih başına satır sayısını say
  complete(                               # hiçbir vaka olmasa bile tüm günlerin görünmesini sağlayın
    date_onset = seq.Date(                # tarih sütununu günlük tarih dizisi olarak yeniden tanımlayın
      from = min(date_onset, na.rm=T), 
      to = max(date_onset, na.rm=T),
      by = "day"),
    fill = list(n = 0))                   # yeni doldurulmuş satırları n sütununda 0 gösterecek şekilde ayarla (varsayılan olarak NA değil) 
```

```{r message=FALSE, echo=F}
DT::datatable(daily_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

###  Haftalara bölünmüş satır listesi vakaları {.unnumbered}


Aynı prensip haftalarca uygulanabilir. İlk önce, `unit = "hafta"` ile `floor_date()` kullanarak vakanın haftası olan yeni bir sütun oluşturun. Ardından, haftalık vaka sayılarına ulaşmak için yukarıdaki gibi `count()` kullanın. Hiçbir vaka içermeseler bile tüm haftaların temsil edildiğinden emin olmak için "complete()" ile bitirin.

```{r}
# Haftalık vaka sayımlarının veri setini yapın
weekly_counts <- linelist %>% 
  drop_na(date_onset) %>%                 # date_onset eksik vakaları kaldırın
  mutate(week = lubridate::floor_date(date_onset, unit = "week")) %>%  # başlangıç haftasının yeni sütunu
  count(week) %>%                         # verileri haftaya göre gruplandır ve grup başına satırları say
  complete(                               # hiçbir vaka olmasa bile tüm günlerin görünmesini sağlayın
    week = seq.Date(                      # tarih sütununu günlük tarih dizisi olarak yeniden tanımlayın
      from = min(week, na.rm=T), 
      to = max(week, na.rm=T),
      by = "week"),
    fill = list(n = 0))                   # yeni doldurulmuş satırları n sütununda 0 gösterecek şekilde ayarla (varsayılan olarak NA değil)
```

Ortaya çıkan veri çerçevesinin ilk 50 satırı:

```{r message=FALSE, echo=F}
DT::datatable(weekly_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

###  Aylara ayrılmış satır listesi vakaları {.unnumbered}

Vakaları aylara toplamak için, yine **lubridate** paketinden 'floor_date()' kullanın, ancak 'unit= "months"' bağımsız değişkeni ile. Bu, her tarihi ayın 1'ine yuvarlar. Çıktı, Date sınıfı olacaktır. `complete()` adımında `by = "aylar"` ifadesini de kullandığımızı unutmayın.


```{r}
# Aylık vaka sayımlarının veri setini yapın
monthly_counts <- linelist %>% 
  drop_na(date_onset) %>% 
  mutate(month = lubridate::floor_date(date_onset, unit = "months")) %>%  # yeni sütun, başlangıcın 1. ayı
  count(month) %>%                          # vakaları aya göre saymak
  complete(
    month = seq.Date(
      min(month, na.rm=T),     # hiçbir vakanın bildirilmediği tüm ayları dahil et
      max(month, na.rm=T),
      by="month"),
    fill = list(n = 0))
```

```{r message=FALSE, echo=F}
DT::datatable(monthly_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


### Haftalara göre günlük sayım {.unnumbered}

Günlük sayıları haftalık sayımlarda toplamak için yukarıdaki gibi `floor_date()` kullanın. Ancak, "count()" yerine "group_by()" ve "summarize()" kullanın, çünkü yalnızca haftalık satır sayısını saymak yerine günlük vaka sayılarını "sum()" yapmanız gerekir.


#### Aylara göre günlük sayımlar {.unnumbered}

Günlük sayıları ay sayılarına toplamak için, yukarıdaki gibi "unit = "month"" ile "floor_date()" kullanın. Ancak, 'count()' yerine 'group_by()' ve 'summarize()' kullanın çünkü sadece aylık satır sayısını saymak yerine günlük vaka sayılarını 'sum()' yapmanız gerekir.


## Gruplandırılmış verileri düzenleme

Bir veri çerçevesindeki satırları sıralamak için **dplyr** fiilinin "arrange()" kullanılması, ".by_group =TRUE" bağımsız değişkenini ayarlamadığınız sürece, veriler gruplandığında aynı şekilde davranır. Bu durumda, satırlar önce gruplandırma sütunlarına ve ardından 'arrange()' için belirttiğiniz diğer sütunlara göre sıralanır.


## Gruplandırılmış verilere filtre uygula

### `filtre()` {.unnumbered}

Veri çerçevesini değerlendiren işlevlerle birlikte uygulandığında ('max()', 'min()', 'mean()' gibi), bu fonksiyonlar artık gruplara uygulanacaktır. Örneğin, hastaların medyan yaşın üzerinde olduğu satırları filtrelemek ve tutmak istiyorsanız, bu artık her grup için geçerli olacaktır - satırları *grubun* medyan yaşının üzerinde tutmak için filtreleyin.



### Grup başına satırları dilimleyin {.unnumbered}

Verilerdeki [satırları konumlarına göre filtreleyen](https://dplyr.tidyverse.org/reference/slice.html) **dplyr** `slice()` fonksiyonu da grup başına uygulanabilir. İstenilen "dilimi" elde etmek için her grup içindeki verileri sıralamayı unutmayın.

Örneğin, her hastaneden yalnızca en son 5 başvuruyu almak için:

1) Satır listesini "hastane" sütununa göre gruplandırın
2) Kayıtları en geçten en erken 'hastaneye yatış tarihi'ne *her hastane grubu içinde* düzenleyin
3) Her hastaneden ilk 5 sırayı almak için dilimleyin

```{r,}
linelist %>%
  group_by(hospital) %>%
  arrange(hospital, date_hospitalisation) %>%
  slice_head(n = 5) %>% 
  arrange(hospital) %>%                            
  select(case_id, hospital, date_hospitalisation)  # görüntülemek için
```

`slice_head()` - üstten n satır seçer
`slice_tail()` - sondan n satır seçer
`slice_sample()` - n satırı rastgele seçer
`slice_min()` - `order_by =` sütununda en yüksek değerlere sahip n satırı seçer, bağları korumak için `with_ties = TRUE` kullanın
'slice_max()' - 'order_by = ' sütununda en düşük değerlere sahip n satırı seçer, bağları korumak için 'with_ties = TRUE'yu kullanın

`slice()` hakkında daha fazla örnek ve ayrıntı için [Tekilleştirme] sayfasına bakabilirsiniz.


### Grup boyutuna göre filtreleyin {#group_filter_grp_size .unnumbered}

'add_count()' fonksiyonu, o satırın grubundaki satır sayısını veren orijinal verilere bir 'n' sütunu ekler.

Aşağıda gösterildiği gibi, "hastane" sütununa "add_count()" uygulanır, bu nedenle yeni "n" sütunundaki değerler, o satırın hastane grubundaki satır sayısını yansıtır. 'n' sütunundaki değerlerin nasıl tekrarlandığına dikkat edin. Aşağıdaki örnekte, 'n' sütun adı 'add_count()' içindeki 'name = ' kullanılarak değiştirilebilir. Gösteri amacıyla sütunları `select()` ile yeniden düzenliyoruz.

```{r}
linelist %>% 
  as_tibble() %>% 
  add_count(hospital) %>%          # "bu sıra ile aynı hastaneye kabul edilen sıra sayısı" ekle
  select(hospital, n, everything())
```

Ardından "küçük" bir hastanede, örneğin 500'den az hastayı kabul eden bir hastanede yatan vaka sıralarını filtrelemek kolaylaşıyor:


```{r, eval=F}
linelist %>% 
  add_count(hospital) %>% 
  filter(n < 500)
```





## Gruplandırılmış verileri dönüştürün

Tüm sütunları ve satırları (özetleme değil) korumak ve *grup istatistiklerini* içeren yeni bir sütun eklemek için, 'özet()' yerine 'group_by()'dan sonra 'mutate()' kullanın.

Bu, orijinal veri kümesinde diğer tüm sütunların mevcut olduğu grup istatistiklerini istiyorsanız yararlıdır - ör. bir satırı kendi grubuyla karşılaştıran hesaplamalar için.

Örneğin, aşağıdaki kod, bir satırın kabul gecikmesi ile hastaneleri için medyan gecikme arasındaki farkı hesaplar. Adımlar:

1) Verileri hastaneye göre gruplandırın
2) *o satırın* hastanede ortalama gecikmesini içeren yeni bir sütun oluşturmak için "days_onset_hosp" (hastaneye yatış gecikmesi) sütununu kullanın
3) İki sütun arasındaki farkı hesaplayın

Gösteri amacıyla yalnızca belirli sütunları "select()" olarak seçiyoruz.

```{r}
linelist %>% 
  # hastaneye göre grup verileri (henüz satır listesinde değişiklik yok)
  group_by(hospital) %>% 
  
  # Yeni sütunlar
  mutate(
    # hastaneye kabule kadar geçen ortalama gün sayısı (1 ondalık sayıya yuvarlanır)
    group_delay_admit = round(mean(days_onset_hosp, na.rm=T), 1),
    
    # sıra gecikmesi ile hastanelerindeki ortalama gecikme arasındaki fark (1 ondalık basamağa yuvarlanır)
    diff_to_group     = round(days_onset_hosp - group_delay_admit, 1)) %>%
  
  # yalnızca belirli satırları seçin - gösterim/görüntüleme amaçlı
  select(case_id, hospital, days_onset_hosp, group_delay_admit, diff_to_group)
```



## Gruplandırılmış verileri seçin

'select()' fiili gruplandırılmış veriler üzerinde çalışır, ancak gruplandırma sütunları her zaman dahil edilir ('select()' içinde belirtilmemiş olsa bile). Bu gruplama sütunlarını istemiyorsanız, önce `ungroup()` kullanın.


<!-- ======================================================= -->
## Kaynaklar {  }

Daha fazla bilgi için bazı yararlı kaynaklar şunlardır: 

Gruplandırılmış veriler üzerinde herhangi bir özet fonksiyonu gerçekleştirebilirsiniz; [RStudio veri dönüştürme bilgi sayfasına](https://github.com/rstudio/cheatsheets/blob/master/data-transformation.pdf) bakabilirsiniz.

[**dplyr**](https://datacarpentry.org/R-genomics/04-dplyr.html) adresindeki Veri Marangozluğu sayfası
[group_by()](https://dplyr.tidyverse.org/reference/group_by.html) ve [grouping](https://dplyr.tidyverse.org/articles/grouping.html) üzerindeki **tidyverse** referans sayfaları.

Bu sayfa [Veri manipülasyonu](https://itsalocke.com/files/DataManipulationinR.pdf)

[dplyr'deki koşullarla özetleyin](https://stackoverflow.com/questions/23528862/summarize-with-conditions-in-dplyr)



```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/grouping.Rmd-->


# Veri Birleştirme { }  

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "left-join.gif"))
```

*Yukarıda: sol birleştirmenin animasyonlu bir örneği ([görüntünün kaynağı](https://github.com/gadenbuie/tidyexplain/tree/master/images))*


Bu sayfa, "birleştirme(join)", "eşleştirme(match)", "ilişkilendirme(link)" "bağlantı kurma(bind)" ve veri çerçevelerini başka şekilde harmanlamanın yollarını açıklamaktadır.

Epidemiyolojik analizinizin veya iş akışınızın birden çok veri kaynağını ve birden çok veri kümesinin bağlantısını içermemesi nadir görülen bir durumdur. Belki de laboratuvar verilerini hastanın klinik sonuçlarına veya Google mobilite verilerini bulaşıcı hastalık eğilimlerine, hatta analizin bir aşamasındaki bir veri kümesini kendisinin dönüştürülmüş bir versiyonuna bağlamanız gerekebilir.

Bu sayfada aşağıdakilere yönelik kodu gösteriyoruz:

* Satırların tanımlayıcı sütunlarındaki ortak değerlere göre eşleştirileceği şekilde iki veri çerçevesinin *birleştirilmesi*
* Değerler arasındaki *olasılıklı* (likely) eşleşmelere dayalı iki veri çerçevesini birleştirme
* Başka bir veri çerçevesinden satırları veya sütunları doğrudan *bağlayarak* veya ("ekleyerek") bir veri çerçevesini genişletme


<!-- ============================================ ========= -->
## Hazırlık { }

### Paketleri yükleme {.unnumbered}

Bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran *ve* kullanım için yükleyen **pacman**'dan 'p_load()' vurgusunu yapıyoruz. **base** R'dan `library()` ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakın.

```{r}
pacman::p_load(
  rio,            # içe aktar ve dışa aktar
  here,           # dosyaların yerini belirle
  tidyverse,      # veri yönetimi ve görselleştirme
  RecordLinkage,  # olasılıksal eşleşme
  fastLink        # olasılıksal eşleşme
)
```



### Verileri içe aktarma {.unnumbered}

Başlamak için, simüle edilmiş bir Ebola salgınından temizlenmiş vaka listesini içe aktarıyoruz. Takip etmek isterseniz <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>click to download the "clean" linelist</a> (.rds dosyası olarak). **rio** paketinden `import()` fonksiyonuyla verileri içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe aktarma ve dışa aktarma] sayfasına bakın).  

```{r, echo=F}
# satır listesini R'a içe aktarma
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# vaka satır listesini içe aktarma 
linelist <- import("linelist_cleaned.rds")
```

Satır listesinin ilk 50 satırı aşağıda gösterilmiştir.

```{r, message=FALSE, echo=F}
# satır listesi verilerini tablo olarak göster
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```




<!-- ======================================================= -->
### Örnek veri kümeleri {.unnumbered}

Aşağıdaki birleştirme bölümünde, aşağıdaki veri kümelerini kullanacağız:

1) Yalnızca "case_id", "date_onset" ve "hospital" sütunlarını ve yalnızca ilk 10 satırı içeren "vaka satır listesinin" "minyatür" versiyonu
2) Her hastane hakkında daha fazla ayrıntı içeren "hosp_info" adlı ayrı bir veri çerçevesi

Olasılıksal eşleştirme bölümünde iki farklı küçük veri seti kullanacağız. Bu veri kümelerini oluşturacak kod o bölümde verilmiştir.




#### "Minyatür" vaka satır listesi {#joins_llmini .unnumbered}

Aşağıda, yalnızca 10 satır ve yalnızca "case_id", "date_onset" ve "hospital" sütunlarını içeren minyatür vaka satır listesi bulunmaktadır. 

```{r}
linelist_mini <- linelist %>%                 # orijinal satır listesiyle başla
  select(case_id, date_onset, hospital) %>%   # sütunları seç
  head(10)                                    # sadece ilk 10 satırı al
```

```{r message=FALSE, echo=F}
DT::datatable(linelist_mini, rownames = FALSE, options = list(pageLength = nrow(10)))
```




#### Hastane bilgi veri çerçevesi {#joins_hosp_info .unnumbered}

Aşağıda, yedi hastane hakkında ek bilgi içeren ayrı bir veri çerçevesi oluşturma kodu verilmiştir (çalışma alanı nüfusu ve mevcut bakım düzeyi). "Askeri Hastane" adının iki farklı hastaneye ait olduğunu unutmayın - biri 10000 kişiye hizmet veren birinci basamak ve diğeri 50280 kişiye hizmet veren ikinci basamak.

```{r}
#Hastane bilgi veri çerçevesini yapın
hosp_info = data.frame(
  hosp_name     = c("central hospital", "military", "military", "port", "St. Mark's", "ignace", "sisters"),
  catchment_pop = c(1950280, 40500, 10000, 50280, 12000, 5000, 4200),
  level         = c("Tertiary", "Secondary", "Primary", "Secondary", "Secondary", "Primary", "Primary")
)
```

İşte bu veri çerçevesi: 

```{r message=FALSE, echo=F}
# hastane verilerini bir tablo olarak göster
DT::datatable(hosp_info, rownames = FALSE, options = list(pageLength = nrow(hosp_info)))
```





<!-- ======================================================= -->
### Ön temizleme {.unnumbered}

Geleneksel birleştirmeler (olasılıksız) büyük/küçük harfe duyarlıdır ve iki veri çerçevesindeki değerler arasında tam karakter eşleşmeleri gerektirir. Bir birleştirmeyi başlatmadan önce yapmanız gerekebilecek bazı temizleme adımlarını göstermek için, şimdi 'linelist_mini' ve 'hosp_info' veri kümelerini temizleyip hizalayacağız.

**Farklılıkları tanımlayın**

'linelist_mini' veri çerçevesindeki 'hospital' sütununun değerleriyle eşleşmesi için 'hosp_info' veri çerçevesindeki 'hosp_name' sütununun değerlerine ihtiyacımız var.

**base** R fonksiyonu 'unique()' ile yazdırılan 'linelist_mini' veri çerçevesindeki değerler şunlardır:

```{r}
unique(linelist_mini$hospital)
```

ve burada "hosp_info" veri çerçevesindeki değerler: 

```{r}
unique(hosp_info$hosp_name)
```

Her iki veri çerçevesinde de bazı hastaneler varken, yazımda birçok farklılık olduğunu görebilirsiniz.


**Değerleri hizala**

`hosp_info` veri çerçevesindeki değerleri temizleyerek başlıyoruz. [Temizleme verileri ve temel fonksiyonlar] sayfasında açıklandığı gibi, **dplyr**'in `case_while()` fonksiyonunu kullanarak değerleri mantıksal kriterlerle yeniden kodlayabiliriz. Her iki veri çerçevesinde de bulunan dört hastane için değerleri, 'linelist_mini' içindeki değerlerle uyumlu olacak şekilde değiştiriyoruz. Diğer hastanelerde değerleri olduğu gibi bırakıyoruz (`TRUE ~ hosp_name`).

<span style="color: orange;">**_UYARI:_** Genellikle temizlik yapılırken yeni bir sütun oluşturulmalıdır (ör. `hosp_name_clean`),
ancak gösterim kolaylığı için eski sütunun modifikasyonunu gösteriyoruz</span>

```{r}
hosp_info <- hosp_info %>% 
  mutate(
    hosp_name = case_when(
      # criteria                         # yeni değer
      hosp_name == "military"          ~ "Military Hospital",
      hosp_name == "port"              ~ "Port Hospital",
      hosp_name == "St. Mark's"        ~ "St. Mark's Maternity Hospital (SMMH)",
      hosp_name == "central hospital"  ~ "Central Hospital",
      TRUE                             ~ hosp_name
      )
    )
```

Her iki veri çerçevesinde de görünen hastane adları hizalanmıştır. "Hosp_info"da "linelist_mini"de bulunmayan iki hastane vardır - bunları daha sonra, birleştirmede ele alacağız.

```{r}
unique(hosp_info$hosp_name)
```

Birleştirmeden önce, bir sütunu tamamen küçük harfe veya tamamı büyük harfe dönüştürmek genellikle en kolayıdır. Bir sütundaki tüm değerleri BÜYÜK veya küçük harfe dönüştürmeniz gerekiyorsa, 'mutate()' kullanın ve sütunu**stringr**' fonksiyonlarından biriyle sarın. [Karakterler ve dizeler] sayfasında gösterildiği gibi  

`str_to_upper()`  
`str_to_upper()`  
`str_to_title()`  




<!-- ======================================================= -->
## **dplyr** birleştirmeleri { }

**dplyr** paketi birkaç farklı birleştirme fonksiyonu sunar. **dplyr**, **tidyverse** paketine dahildir. Bu birleştirme fonksiyonları, basit kullanım durumları ile aşağıda açıklanmıştır.

Bilgilendirici gifler için [https://github.com/gadenbuie](https://github.com/gadenbuie/tidyexplain/tree/master/images)'e çok teşekkürler!




<!-- ============================================ ========= -->
### Genel sözdizimi {.unnumbered}

Birleştirme komutları, iki veri çerçevesini yeni bir nesnede birleştirmek için bağımsız komutlar olarak çalıştırılabilir veya bir veri çerçevesini temizlenirken veya başka bir şekilde değiştirilirken bir veri çerçevesini diğerine birleştirmek için bir tünel zincirinde ("%>%") kullanılabilir. .

Aşağıdaki örnekte, "left_join()" fonksiyonu, yeni bir "joined_data" veri çerçevesi oluşturmak için bağımsız bir komut olarak kullanılır. Girişler, veri çerçeveleri 1 ve 2'dir (`df1` ve `df2`). Listelenen ilk veri çerçevesi temel veri çerçevesidir ve listelenen ikincisi *buna* birleştirilir.

Üçüncü argüman "by =", iki veri çerçevesindeki satırları hizalamak için kullanılacak her veri çerçevesindeki sütunları belirttiğiniz yerdir. Bu sütunların adları farklıysa, bunları aşağıda gösterildiği gibi bir "c()" vektörü içinde sağlayın; burada satırlar "df1"deki "ID" sütunu ile "df2"deki "tanımlayıcı" sütunu arasındaki ortak değerler temelinde eşleştirilir.

```{r, eval=F}
# "ID" sütunu (ilk veri çerçevesi) ve "tanımlayıcı" sütunu (ikinci veri çerçevesi) arasındaki ortak değerlere göre birleştirme
joined_data <- left_join(df1, df2, by = c("ID" = "identifier"))
```

Her iki veri çerçevesindeki "by" sütunları tam olarak aynı ada sahipse, bu tek adı tırnak içinde verebilirsiniz.  

```{r, eval=F}
# Her iki veri çerçevesindeki "ID" sütunundaki ortak değerlere dayalı birleştirme
joined_data <- left_join(df1, df2, by = "ID")
```

Birden çok alandaki ortak değerlere dayalı veri çerçevelerini birleştiriyorsanız, bu alanları "c()" vektörü içinde listeleyin. Bu örnek, her veri kümesindeki üç sütundaki değerler tam olarak aynı hizadaysa satırları birleştirir.

```{r, eval=F}
# aynı isim-soyisim ve yaşa sahip olanları birleştirme
joined_data <- left_join(df1, df2, by = c("name" = "firstname", "surname" = "lastname", "Age" = "age"))
```


Birleştirme komutları bir tünel zinciri içinde de çalıştırılabilir. Bu, aktarılan veri çerçevesini değiştirecektir.

Aşağıdaki örnekte 'df1' tünellerden geçirilmekte, 'df2' ile birleştirilmekte ve böylece 'df' değiştirilip yeniden tanımlanmaktadır.

```{r eval=F}
df1 <- df1 %>%
  filter(date_onset < as.Date("2020-03-05")) %>% # öok yönlü temizlik
  left_join(df2, by = c("ID" = "identifier"))    # df2 yi df1 e birleştirmek
```


<span style="color: orange;">**_UYARI:_** Birleştirmeler büyük/küçük harfe özeldir! Bu nedenle, birleştirmeden önce tüm değerleri küçük harfe veya büyük harfe dönüştürmek yararlıdır. Karakterler/dizeler ile ilgili sayfaya bakınız.</span>





<!-- ======================================================= -->
### Sol ve sağ birleşimler {.unnumbered}

**Bir veri çerçevesine bilgi eklemek için yaygın olarak sol veya sağ birleşim kullanılır** - yeni bilgiler yalnızca temel veri çerçevesinde zaten var olan satırlara eklenir. Bunlar, bir veri kümesinden diğerine bilgi eklemek için kullanıldıkları için epidemiyolojik çalışmalarda yaygın olarak kullanılan birleştirmelerdir.

Bu birleştirmeleri kullanırken, komuttaki veri çerçevelerinin yazılı sırası önemlidir*.

* Bir *sol birleştirmede*, yazılan *ilk* veri çerçevesi temel satırdır
* Bir *sağ birleştirmede*, yazılan *ikinci* veri çerçevesi temel satırdır

**Temel veri çerçevesinin tüm satırları tutulur.** Diğer (ikincil) veri çerçevesindeki bilgiler, temel veri çerçevesine *yalnızca tanımlayıcı sütun(lar)ı aracılığıyla bir eşleşme varsa* birleştirilir. Ek olarak:

* İkincil veri çerçevesindeki eşleşmeyen satırlar atlanır.
* İkincil veri çerçevesindeki bir satırla eşleşen çok sayıda temel satır varsa (çoktan bire), ikincil bilgiler *eşleşen her bir temel satıra* eklenir.
* Bir temel satır, ikincil veri çerçevesindeki birden çok satırla eşleşirse (bire çok), tüm kombinasyonlar verilir, yani *döndürülen veri çerçevenize yeni satırlar eklenebilir!*

Sol ve sağ birleştirmelerin animasyonlu örnekleri ([image source](https://github.com/gadenbuie/tidyexplain/tree/master/images))

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "left-join.gif"))
knitr::include_graphics(here::here("images", "right-join.gif"))
```

**Örnek**

Aşağıda, "hosp_info"nun (ikincil veri çerçevesi, [buradan görüntüleyebilirsiniz](#joins_hosp_info)) "linelist_mini"ye (temel veri çerçevesi, [buradan görüntüleyebilirsiniz](#joins_llmini)) bir "left_join()" çıktısı verilmiştir. Orijinal "linelist_mini", "nrow(linelist_mini)" satırlarına sahiptir. Değiştirilen "linelist_mini" görüntülenir. Aşağıdakilere dikkat ediniz:

* "linelist_mini"nin sol tarafına iki yeni sütun, "catchment_pop" ve "level" eklendi
* 'linelist_mini' temel veri çerçevesinin tüm orijinal satırları tutulur
* "Askeri Hastane" için herhangi bir orijinal "linelist_mini" satırı, ikincil veri çerçevesindeki *iki* satırla eşleştiği için çoğaltılır, bu nedenle her iki kombinasyon da döndürülür
* İkincil veri kümesinin (`hosp_name`) birleştirme tanımlayıcı sütunu, birincil veri kümesindeki ("hastane") tanımlayıcı sütunuyla gereksiz olduğundan kayboldu
* Temel satır herhangi bir ikincil satırla eşleşmediğinde (örneğin, "hastane" "Diğer" veya "Eksik" olduğunda), "NA" (boşluk) ikincil veri çerçevesindeki sütunları doldurur
* İkincil veri çerçevesindeki temel veri çerçevesiyle eşleşmeyen satırlar ("kızkardeşler" ve "ignace" hastaneleri) çıkarıldı.


```{r, eval=F}
linelist_mini %>% 
  left_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r message=FALSE, echo=F}
linelist_mini %>% 
  left_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 11))
```





#### "Sağ birleştirme mi yoksa sol birleştirme mi kullanmalıyım?" {.unnumbered}

Yukarıdaki soruyu yanıtlamak için kendinize "hangi veri çerçevesinin tüm satırlarını tutması gerektiğini" sorun. - bunu temel satır olarak kullanın. *sol birleştirme* komutta yazılan ilk veri çerçevesindeki tüm satırları tutarken, *sağ birleştirme* tüm satırları ikinci veri çerçevesinde tutar.

Aşağıdaki iki komut aynı çıktıyı elde eder - 10 satır "hosp_info" bir "linelist_mini" temel satırına katılmıştır, ancak farklı birleşimler kullanırlar. Sonuç olarak, sütun sırası, "hosp_info"nun sağdan mı (sol birleştirmede) yoksa soldan mı (sağ birleştirmede) geldiğine bağlı olarak farklılık gösterecektir. Sıraların sırası da buna göre değişebilir. Ancak bu sonuçların her ikisi de daha sonra, sütunları yeniden sıralamak için "select()" veya satırları sıralamak için "arrange()" kullanılarak ele alınabilir.

```{r, eval=F}
# Aşağıdaki iki komut aynı verileri elde eder, ancak farklı sıralı satırlar ve sütunlarla
left_join(linelist_mini, hosp_info, by = c("hospital" = "hosp_name"))
right_join(hosp_info, linelist_mini, by = c("hosp_name" = "hospital"))
```
Sol birleşim yoluyla 'hosp_info'nun 'linelist_mini' içindeki sonucu (sağdan gelen yeni sütunlar)

```{r message=FALSE, echo=F}
left_join(linelist_mini, hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 11))
```
İşte sağ birleştirme yoluyla 'hosp_info'nun 'linelist_mini' içindeki sonucu (soldan gelen yeni sütunlar)

```{r message=FALSE, echo=F}
right_join(hosp_info, linelist_mini, by = c("hosp_name" = "hospital")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 11))
```

Ayrıca kullanım durumunuzun bir tünel zinciri (`%>%`) içinde olup olmadığını da göz önünde bulundurun. Borulardaki veri kümesi temel satır ise, buna veri eklemek için büyük olasılıkla bir sol birleştirme kullanacaksınız.


<!-- ======================================================= -->
### Tam birleşme {.unnumbered}

**Tam birleşim, birleşimlerin en *kapsayıcısıdır** - her iki veri çerçevesinden tüm satırları döndürür.

Birinde mevcut olan ve diğerinde olmayan satırlar varsa (eşleşmenin bulunmadığı durumlarda), veri çerçevesi bunları içerecek ve daha uzun olacaktır. "NA" eksik değerleri, oluşturulan boşlukları doldurmak için kullanılır. Birleştirirken, büyük/küçük harf duyarlılığı ve tam karakter eşleşmeleriyle ilgili sorunları gidermek için sütun ve satır sayısını dikkatle izleyin.

"Temel satır" veri çerçevesi, komutta ilk yazılan çerçevedir. Bunun ayarlanması, birleştirme tarafından hangi kayıtların döndürüleceğini etkilemez, ancak sonuçta elde edilen sütun sırasını, satır sırasını ve hangi tanımlayıcı sütunların tutulacağını etkileyebilir.

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "full-join.gif"))
```

Tam birleştirmenin animasyonlu örneği ([görüntü kaynağı](https://github.com/gadenbuie/tidyexplain/tree/master/images))

**Örnek**

`linelist_mini`nin(başlangıçta`nrow(linelist_mini)`, [buradan görüntüleyebilirsiniz](#joins_llmini) *içine* `hosp_info`'nun `full_join()`'i (başlangıçta  nrow(hosp_info)`, [buradan görüntüleyebilirsiniz](#joins_hosp_info)) çıktısı aşağıda yer almaktadır. Aşağıdakilere dikkat ediniz:  

* Tüm temel satırlar tutulur (`linelist_mini`)
* İkincil satırda temel satırla eşleşmeyen satırlar tutulur ("ignace" ve "sisters"), karşılık gelen "case_id" ve "onset" sütunlarındaki değerler eksik değerlerle doldurulur
* Benzer şekilde, temel veri çerçevesindeki ikincil ile eşleşmeyen satırlar ("Diğer" ve "Eksik") tutulur, ikincil sütunlar "catchment_pop" ve "level" eksik değerlerle doldurulur
* Bire çoğa veya çoğa bire eşleşmelerde (ör. "Askeri Hastane" satırları), tüm olası kombinasyonlar döndürülür (son veri çerçevesini uzatarak)
* Yalnızca temel satırdan tanımlayıcı sütun tutulur ("hastane")


```{r, eval=F}
linelist_mini %>% 
  full_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r message=FALSE, echo=F}
linelist_mini %>% 
  full_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 15))
```





<!-- ======================================================= -->
### İç birleştirme {.unnumbered}

**İç birleştirme, birleştirmelerin en *kısıtlayıcısıdır** - yalnızca her iki veri çerçevesinde eşleşen satırları döndürür.
Bu, temel veri çerçevesindeki satır sayısının gerçekten *azalabileceği* anlamına gelir. Hangi veri çerçevesinin "temel satır" (işlevde ilk olarak yazılır) olduğunun ayarlanması, hangi satırların döndürüleceğini etkilemez, ancak sütun sırasını, satır sırasını ve hangi tanımlayıcı sütunların tutulacağını etkiler.


```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "inner-join.gif"))
```

İç birleştirmenin animasyonlu örneği ([görüntü kaynağı](https://github.com/gadenbuie/tidyexplain/tree/master/images))


**Örnek**

Aşağıda, "hosp_info" (ikincil) ile "linelist_mini"nin (temel satır) bir "inner_join()" çıktısı bulunmaktadır. Aşağıdakilere dikkat ediniz:

* İkincil verilerle eşleşmeyen temel satırlar kaldırılır ("hastane"nin "Eksik" veya "Diğer" olduğu satırlar)
* Benzer şekilde, temel satırla eşleşmeyen ikincil veri çerçevesindeki satırlar kaldırılır ("hosp_name"nin "kız kardeşler" veya "ignace" olduğu satırlar)
* Yalnızca temel satırdan tanımlayıcı sütun tutulur ("hastane")

```{r, eval=F}
linelist_mini %>% 
  inner_join(hosp_info, by = c("hospital" = "hosp_name"))
```


```{r message=FALSE, echo=F}
linelist_mini %>% 
  inner_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 12))
```






<!-- ======================================================= -->
### Yarım birleştirme {.unnumbered}

Yarım birleştirme, başka bir veri kümesini *satır veya sütun eklemek için değil, filtreleme* gerçekleştirmek için kullanan bir "filtreleme birleştirme"dir.

Bir **yarım birleştirme, ikincil veri çerçevesinde bir eşleşmeye sahip olan temel veri çerçevesindeki tüm gözlemleri tutar** (ancak yeni sütunlar eklemez veya birden çok eşleşme için herhangi bir satırı çoğaltmaz). Bu "filtreleme" birleşimleri hakkında daha fazla bilgiyi buradan okuyabilirsiniz [buradan](https://towardsdatascience.com/level-up-with-semi-joins-in-r-a068426096e0).  

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "semi-join.gif"))
```

Yarım birleştirmenin animasyonlu örneği ([görüntü kaynağı](https://github.com/gadenbuie/tidyexplain/tree/master/images))

Örnek olarak, aşağıdaki kod, hastane adına göre "linelist_mini" içinde eşleşmeleri olan "hosp_info" veri çerçevesinden satırları döndürür.

```{r}
hosp_info %>% 
  semi_join(linelist_mini, by = c("hosp_name" = "hospital"))
```



<!-- ======================================================= -->
###  Karşıt birleştirme {.unnumbered}

**Karşıt birleştirme 'anti_join()', temel veri çerçevesindeki ikincil veri çerçevesinde eşleşmeyen* satırları döndüren başka bir "filtreleme birleştirme"dir.**

Birleştirmeleri filtreleme hakkında daha fazla bilgiyi buradan okuyabilirsiniz [buradan](https://towardsdatascience.com/level-up-with-semi-joins-in-r-a068426096e0).

Bir karşıt birleştirme için yaygın senaryolar arasında başka bir veri çerçevesinde mevcut olmayan kayıtların belirlenmesi, bir birleştirmedeki yazım hatalarının giderilmesi (eşleşmesi *gereken* kayıtların gözden geçirilmesi) ve başka bir birleştirmeden sonra hariç tutulan kayıtların incelenmesi yer alır.

**'right_join()' ve 'left_join()' ile olduğu gibi, *temel* veri çerçevesi (ilk olarak listelenmiştir) önemlidir**. Döndürülen satırlar yalnızca temel veri çerçevesindendir. Alttaki gifte, ikincil veri çerçevesindeki o satırın (mor satır 4), taban çizgisiyle eşleşmemesine rağmen döndürülmediğine dikkat edin.

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "anti-join.gif"))
```

Karşıt birleştirmenin animasyonlu örneği ([görüntü kaynağı](https://github.com/gadenbuie/tidyexplain/tree/master/images))


#### Basit `anti_join()` örneği {.unnumbered}

Basit bir örnek için, 'linelist_mini' içinde herhangi bir vaka bulunmayan 'hosp_info' hastanelerini bulalım. Temel veri çerçevesi olarak önce 'hosp_info'yu listeleriz. 'linelist_mini' içinde bulunmayan hastaneler iade edilir.

```{r, eval=F}
hosp_info %>% 
  anti_join(linelist_mini, by = c("hosp_name" = "hospital"))
```

```{r message=FALSE, echo=F}
hosp_info %>% 
  anti_join(linelist_mini, by = c("hosp_name" = "hospital")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 12))
```


#### Karmaşık `anti_join()` örneği {.unnumbered}

Başka bir örnek için, "linelist_mini" ve "hosp_info" arasında bir "inner_join()" çalıştırdığımızı varsayalım. Bazıları "hosp_info" içinde bulunmadığından, bu, orijinal "linelist_mini" kayıtlarının yalnızca bir alt kümesini döndürür. 

```{r, eval=F}
linelist_mini %>% 
  inner_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r message=FALSE, echo=F}
linelist_mini %>% 
  inner_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 8))
```

İç birleştirme sırasında hariç tutulan 'linelist_mini' kayıtlarını gözden geçirmek için aynı ayarlarla (temel satır olarak 'linelist_mini')  bir ayrıştırma (anti-join) çalıştırabiliriz.  

```{r, eval = F}
linelist_mini %>% 
  anti_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r message=FALSE, echo=F}
linelist_mini %>% 
  anti_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 8))
```

İç birleşimde hariç tutulan 'hosp_info' kayıtlarını görmek için, temel veri çerçevesi olarak 'hosp_info' ile bir ayrıştırma çalıştırabiliriz.



<!-- ============================================ ========= -->
## Olasılıksal eşleştirme { }

Katılmak için veri kümeleri arasında ortak benzersiz bir tanımlayıcınız yoksa, olasılıklı bir eşleştirme algoritması kullanmayı düşünün. Bu, benzerliğe dayalı olarak kayıtlar arasındaki eşleşmeleri bulur (örneğin, Jaro–Winkler dizi mesafesi veya sayısal mesafe). Aşağıda **fastLink** paketini kullanan basit bir örnek verilmiştir.

**Paketleri yükle**

```{r}
pacman::p_load(
  tidyverse,      # veri işleme ve görselleştirme
  fastLink        # kayıt eşleştirme
  )
```

Olasılıksal eşleşmeyi göstermek için kullanacağımız iki küçük örnek veri kümesi ("durumlar" ve "test_sonuçları"):

Veri kümelerini oluşturmak için kullanılan kod:

```{r}
# veri kümeleri yapmak

cases <- tribble(
  ~gender, ~first,      ~middle,     ~last,        ~yr,   ~mon, ~day, ~district,
  "M",     "Amir",      NA,          "Khan",       1989,  11,   22,   "River",
  "M",     "Anthony",   "B.",        "Smith",      1970, 09, 19,      "River", 
  "F",     "Marialisa", "Contreras", "Rodrigues",  1972, 04, 15,      "River",
  "F",     "Elizabeth", "Casteel",   "Chase",      1954, 03, 03,      "City",
  "M",     "Jose",      "Sanchez",   "Lopez",      1996, 01, 06,      "City",
  "F",     "Cassidy",   "Jones",      "Davis",     1980, 07, 20,      "City",
  "M",     "Michael",   "Murphy",     "O'Calaghan",1969, 04, 12,      "Rural", 
  "M",     "Oliver",    "Laurent",    "De Bordow" , 1971, 02, 04,     "River",
  "F",      "Blessing",  NA,          "Adebayo",   1955,  02, 14,     "Rural"
)

results <- tribble(
  ~gender,  ~first,     ~middle,     ~last,          ~yr, ~mon, ~day, ~district, ~result,
  "M",      "Amir",     NA,          "Khan",         1989, 11,   22,  "River", "positive",
  "M",      "Tony",   "B",         "Smith",          1970, 09,   19,  "River", "positive",
  "F",      "Maria",    "Contreras", "Rodriguez",    1972, 04,   15,  "Cty",   "negative",
  "F",      "Betty",    "Castel",   "Chase",        1954,  03,   30,  "City",  "positive",
  "F",      "Andrea",   NA,          "Kumaraswamy",  2001, 01,   05,  "Rural", "positive",      
  "F",      "Caroline", NA,          "Wang",         1988, 12,   11,  "Rural", "negative",
  "F",      "Trang",    NA,          "Nguyen",       1981, 06,   10,  "Rural", "positive",
  "M",      "Olivier" , "Laurent",   "De Bordeaux",  NA,   NA,   NA,  "River", "positive",
  "M",      "Mike",     "Murphy",    "O'Callaghan",  1969, 04,   12,  "Rural", "negative",
  "F",      "Cassidy",  "Jones",     "Davis",        1980, 07,   02,  "City",  "positive",
  "M",      "Mohammad", NA,          "Ali",          1942, 01,   17,  "City",  "negative",
  NA,       "Jose",     "Sanchez",   "Lopez",        1995, 01,   06,  "City",  "negative",
  "M",      "Abubakar", NA,          "Abullahi",     1960, 01,   01,  "River", "positive",
  "F",      "Maria",    "Salinas",   "Contreras",    1955, 03,   03,  "River", "positive"
  )

```


**"vakalar" veri kümesinde, test sonuçlarını bekleyen hastaların 9 kaydı** vardır.  

```{r message=FALSE, echo=F}
# hastane verisini tabloda göster
DT::datatable(cases, rownames = FALSE, options = list(pageLength = nrow(cases), scrollX=T), class = 'white-space: nowrap')
```



**`test_results` veri kümesi** 14 kayıt içerir ve kayıtların olasılıksal eşleşmesine dayalı olarak `vakalar`daki kayıtlara eklemek istediğimiz `sonuç` sütununu içerir. 

```{r message=FALSE, echo=F}
#  hastane verisini tabloda göster
DT::datatable(results, rownames = FALSE, options = list(pageLength = nrow(results), scrollX=T), class = 'white-space: nowrap')
```

### Olasılıksal eşleşme {.unnumbered}

**fastLink** paketindeki `fastLink()` fonksiyonu, bir eşleştirme algoritması uygulamak için kullanılabilir. İşte temel bilgiler. Konsolunuza `?fastLink` girerek daha fazla ayrıntı okuyabilirsiniz.

* `dfA = ` ve `dfB = ` değişkenleriyle karşılaştırmak için iki veri çerçevesini tanımlayın.
* `varnames =` içinde eşleştirme için kullanılacak tüm sütun adlarını verin. Hepsi hem "dfA" hem de "dfB" içinde bulunmalıdır.
* `stringdist.match =` içinde, "distance" dizesinde değerlendirilmek üzere `varnames` içindekilerden sütunlar verin.
* 'numeric.match = ' içinde, 'varnames' içindekilerden sayısal mesafeye göre değerlendirilecek sütunlar verin.
* Eksik değerler dikkate alınmaz
* Varsayılan olarak, herhangi bir veri çerçevesindeki her satır, diğer veri çerçevesindeki en fazla bir satırla eşleştirilir. Değerlendirilen tüm eşleşmeleri görmek istiyorsanız, "dedupe.matches = FALSE" olarak ayarlayın. Tekilleştirme, Winkler'in doğrusal atama çözümü kullanılarak yapılır.

*İpucu: **lubridate** paketinden 'day()', 'ay()' ve 'year()' kullanarak bir tarih sütununu üç ayrı sayısal sütuna ayırın*

Eşleşmeler için varsayılan eşik 0,94'tür (`threshold.match = `), ancak bunu daha yüksek veya daha düşük olarak ayarlayabilirsiniz. Eşiği tanımlarsanız, daha yüksek eşiklerin daha fazla yanlış-negatif (aslında eşleşmesi gereken eşleşmeyen satırlar) verebileceğini ve aynı şekilde daha düşük bir eşiğin daha fazla yanlış-pozitif eşleşmeler sağlayabileceğini düşünün.

Aşağıda, veriler, ad ve bölge sütunları boyunca harf dizisi mesafesine ve yıl, ay ve doğum günü için sayısal mesafeye göre eşleştirilir. %95 olasılıkla bir eşleşme eşiği belirlenir.


```{r, message=F, warning=F}
fl_output <- fastLink::fastLink(
  dfA = cases,
  dfB = results,
  varnames = c("gender", "first", "middle", "last", "yr", "mon", "day", "district"),
  stringdist.match = c("first", "middle", "last", "district"),
  numeric.match = c("yr", "mon", "day"),
  threshold.match = 0.95)
```

**Eşleşmelerin incelenmesi**

`fastLink()`den dönen nesneyi `fl_output` olarak tanımladık. 'list' sınıfında yer alır ve aslında içinde eşleşmenin sonuçlarını detaylandıran birkaç veri çerçevesi içerir. Bu veri çerçevelerinden biri, "durumlar" ve "sonuçlar" arasındaki en olası eşleşmeleri içeren "eşleşmeler"dir. Bu "eşleşmelere" veri çerçevesine `fl_output$matches` ile erişebilirsiniz. Aşağıda, daha sonra erişim kolaylığı için 'my_matches' olarak kaydedilmiştir.

"my_matches" yazdırıldığında, iki sütun vektörü görürsünüz: "cases" ("inds.a") ve "results" ("inds.b") içindeki satır numaraları/indeks ("satır adları" olarak da adlandırılır) çiftleri en iyi eşleşmeleri temsil eder. Bir veri çerçevesinden bir satır numarası eksikse, belirtilen eşleşme eşiğinde diğer veri çerçevesinde hiçbir eşleşme bulunamaz. 

```{r}
# eşleşmeleri yazdır
my_matches <- fl_output$matches
my_matches
```

  Dikkat edilmesi gerekenler:

* İsim yazımında ve doğum tarihlerinde küçük farklılıklar olmasına rağmen eşleşmeler gerçekleşti:
  * "Tony B. Smith", "Anthony B Smith" ile eşleşti
  * "Maria Rodriguez", "Marialisa Rodrigues" ile eşleşti
  * "Betty Chase", "Elizabeth Chase" ile eşleşti
  * "Olivier Laurent De Bordeaux", "Oliver Laurent De Bordow" ile eşleştirildi (eksik doğum tarihi dikkate alınmadı)
* "Cases" bir satır ("Blessing Adebayo" için, 9. satır) "results"da iyi bir eşleşmeye sahip değildi, bu nedenle "eşleşmelerim"de yer verilmedi.




**Olasılıklı eşleşmelere göre birleştirme**

Bu eşleşmeleri "results" "cases" birleştirmek için strateji şudur:

1) "my_matches"ı "cases" ile birleştirmek için "left_join()"i kullanın ("cases"deki satır adlarını "my_matches" içindeki "inds.a" ile eşleştirme)
2) Ardından, "results"ı "cases" ile birleştirmek için başka bir "left_join()" kullanın ("vakalar"daki yeni edinilen "inds.b"yi "results"daki satır adlarıyla eşleştirin)

Birleştirmelerden önce üç veri çerçevesini temizlemeliyiz:

* Hem "dfA" hem de "dfB" satır numaraları ("satır adı") uygun bir sütuna dönüştürülmelidir.
* `my_matches` içindeki her iki sütun da sınıf karakterine dönüştürülür, böylece karakter satır adlarına birleştirilebilirler.

```{r}
# Eşleştirmeden önce verileri temizleyin
#############################

# vaka satır adlarını bir sütuna dönüştür 
cases_clean <- cases %>% rownames_to_column()

# test_results satır adlarını bir sütuna dönüştür
results_clean <- results %>% rownames_to_column()  

# eşleşen veri kümesindeki tüm sütunları karaktere dönüştürün, böylece satır adlarına birleştirilebilirler
matches_clean <- my_matches %>%
  mutate(across(everything(), as.character))



# Eşleşmeleri dfA ile birleştirin, ardından dfB ekleyin
##################################
# "inds.b" sütunu dfA'ya eklendi
complete <- left_join(cases_clean, matches_clean, by = c("rowname" = "inds.a"))

#dfB'den sütun(lar) eklendi
complete <- left_join(complete, results_clean, by = c("inds.b" = "rowname"))
```

Yukarıdaki kod kullanılarak gerçekleştirildiği gibi, elde edilen "tamamlandı" veri çerçevesi hem "durumlardan" hem de "sonuçlardan" *tüm* sütunları içerecektir. Sütun adları aksi takdirde yineleneceğinden, birçoğuna ".x" ve ".y" son ekleri eklenecektir.

```{r message=FALSE, echo=F}
DT::datatable(complete, rownames = FALSE, options = list(pageLength = nrow(complete), scrollX=T), class = 'white-space: nowrap')
```

Alternatif olarak, "results"dan yeni sütun(lar)la "cases" yalnızca "orijinal" 9 kaydı elde etmek için, birleştirmeden önce "results"da "select()"i kullanın, böylece yalnızca satır adlarını ve "cases" (örneğin "result" sütunu) eklemek istediğiniz sütunları içerir.  

```{r}
cases_clean <- cases %>% rownames_to_column()

results_clean <- results %>%
  rownames_to_column() %>% 
  select(rowname, result)    # sadece belirli sütunları seç

matches_clean <- my_matches %>%
  mutate(across(everything(), as.character))

# birleştirme
complete <- left_join(cases_clean, matches_clean, by = c("rowname" = "inds.a"))
complete <- left_join(complete, results_clean, by = c("inds.b" = "rowname"))
```


```{r message=FALSE, echo=F}
DT::datatable(complete, rownames = FALSE, options = list(pageLength = nrow(complete), scrollX=T), class = 'white-space: nowrap')
```


Her iki veri kümesini de yalnızca eşleşen satırlara alt kümelemek isterseniz aşağıdaki kodları kullanabilirsiniz:

```{r}
cases_matched <- cases[my_matches$inds.a,]  # Sonuçlarda bir satırla eşleşen vakalarda satırlar
results_matched <- results[my_matches$inds.b,]  # Vakalardaki bir satırla eşleşen sonuçlardaki satırlar
```

Veya yalnızca **eşleşmeyen** satırları görmek için:

```{r}
cases_not_matched <- cases[!rownames(cases) %in% my_matches$inds.a,]  # Sonuçlarda bir satırla eşleşmeyen vakalardaki satırlar
results_not_matched <- results[!rownames(results) %in% my_matches$inds.b,]  # Bir satırla eşleşmeyen sonuçlardaki satırlars
```


### Olasılıksal veri tekilleştirme {.unnumbered}

Olasılıksal eşleştirme, bir veri kümesini tekilleştirmek için de kullanılabilir. Diğer veri tekilleştirme yöntemleri için veri tekilleştirme sayfasına bakabilirsiniz.

Burada "cases" veri kümesiyle başladık, ancak önceki satırların kopyası olabilecek 2 ek satırı olduğundan şimdi buna "cases_dup" adını veriyoruz:
"Anthony" ile "Tony" ve "Maria Rodriguez" ile "Marialisa Rodrigues" i inceleyiniz.

```{r, echo=F}
## Yinelenenleri ekle
#cases_dup <- rbind(cases, cases[sample(1:nrow(cases), 3, replace = FALSE),])

cases_dup <- tribble(
  ~gender, ~first,      ~middle,     ~last,        ~yr,   ~mon, ~day, ~district,
  "M",     "Amir",      NA,          "Khan",       1989,  11,   22,   "River",
  "M",     "Anthony",   "B.",        "Smith",      1970, 09, 19,      "River", 
  "F",     "Marialisa", "Contreras", "Rodrigues",  1972, 04, 15,      "River",
  "F",     "Elizabeth", "Casteel",   "Chase",      1954, 03, 03,      "City",
  "M",     "Jose",      "Sanchez",   "Lopez",      1996, 01, 06,      "City",
  "F",     "Cassidy",   "Jones",      "Davis",     1980, 07, 20,      "City",
  "M",     "Michael",   "Murphy",     "O'Calaghan",1969, 04, 12,      "Rural", 
  "M",     "Oliver",    "Laurent",    "De Bordow" , 1971, 02, 04,     "River",
  "F",      "Blessing",  NA,          "Adebayo",   1955,  02, 14,     "Rural",
  "M",     "Tony",   "B.",        "Smith",         1970, 09, 19,      "River", 
  "F",     "Maria",  "Contreras", "Rodriguez",     1972, 04, 15,      "River",
)

```

```{r message=FALSE, echo=F}
DT::datatable(cases_dup, rownames = FALSE, options = list(pageLength = nrow(cases_dup)))
```


Daha önce olduğu gibi "fastLink()"i çalıştırın, ancak "cases_dup" veri çerçevesini kendisiyle karşılaştırın. Sağlanan iki veri çerçevesi aynı olduğunda, fonksiyon, çoğaltmayı kaldırmak istediğinizi varsayar. Daha önce yaptığımız gibi `stringdist.match =` veya `numeric.match =` belirtmediğimizi unutmayın.

```{r, message = F, warning = F}
## Aynı veri kümesinde fastLink'i çalıştırın
dedupe_output <- fastLink(
  dfA = cases_dup,
  dfB = cases_dup,
  varnames = c("gender", "first", "middle", "last", "yr", "mon", "day", "district")
)
```

Şimdi, `getMatches()` ile olası kopyaları inceleyebilirsiniz. Veri çerçevesini hem 'dfA = ' hem de 'dfB = ' olarak sağlayın ve 'fastLink()' fonksiyonunun çıktısını 'fl.out = ' olarak sağlayın. "fl.out", "fastLink.dedupe" sınıfında veya başka bir deyişle "fastLink()"in sonucu olmalıdır. 

```{r}
## getMatches() çalıştır
cases_dedupe <- getMatches(
  dfA = cases_dup,
  dfB = cases_dup,
  fl.out = dedupe_output)
```

Yinelenen kimlikleri gösteren en sağdaki sütuna bakın - son iki satır, 2. ve 3. satırların olası kopyaları olarak tanımlanır.

```{r message=FALSE, echo=F}
DT::datatable(cases_dedupe, rownames = FALSE, options = list(pageLength = nrow(cases_dedupe)))
```

Büyük olasılıkla yinelenen satırların satır numaralarını döndürmek için, "dedupe.ids" sütunundaki benzersiz değer başına satır sayısını sayabilir ve ardından yalnızca birden fazla satıra sahip olanları tutmak için filtre uygulayabilirsiniz. Bu durumda 2. ve 3. satırları bırakır. 

```{r}
cases_dedupe %>% 
  count(dedupe.ids) %>% 
  filter(n > 1)
```

Muhtemel kopyaların tüm satırlarını incelemek için satır numarasını bu komuta girin:

```{r}
# 2. satırı ve tüm olası kopyalarını görüntüler
cases_dedupe[cases_dedupe$dedupe.ids == 2,]   
```



## Bağlama ve hizalama

İki veri çerçevesini birleştirmenin başka bir yöntemi, onları birbirine "bağlamaktır". Bunu satır veya sütunları "eklemek" olarak da düşünebilirsiniz.

Bu bölümde ayrıca bir veri çerçevesinin satır sırasının başka bir veri çerçevesindeki sıraya nasıl "hizalanacağı" tartışılacaktır. Bu konu aşağıda Sütunları bağlama bölümünde tartışılmaktadır.



### Satırları bağlama {.unnumbered}

Bir veri çerçevesinin satırlarını başka bir veri çerçevesinin altına bağlamak için, **dplyr**'den `bind_rows()` kullanın. Çok kapsayıcıdır, bu nedenle her iki veri çerçevesinde bulunan herhangi bir sütun çıktıya dahil edilecektir. Birkaç not:

* **base** R sürümü 'row.bind()'den farklı olarak, **dplyr**'nin 'bind_rows()' fonksiyonu, sütunların sırasının her iki veri çerçevesinde de aynı olmasını gerektirmez. Sütun adları aynı şekilde yazıldığı sürece, bunları doğru şekilde hizalayacaktır.
* İsteğe bağlı olarak `.id = ` argümanını belirtebilirsiniz. Bir karakter sütun adı sağlayın. Bu, her satırın orijinal olarak hangi veri çerçevesinden geldiğini belirlemeye yarayan yeni bir sütun üretecektir.
* Benzer şekilde yapılandırılmış veri çerçevelerinin bir 'listesinde' onları tek bir veri çerçevesinde birleştirmek için 'bind_rows()' kullanabilirsiniz. **purrr** ile birden çok satır listesinin içe aktarılmasını içeren [Yineleme, döngüler ve listeler] sayfasındaki bir örneğe bakın.

Satır bağlamanın yaygın bir örneği, "toplam" bir satırı **dplyr**'nin `summarise()` fonksiyonuyla yapılmış açıklayıcı bir tabloya bağlamaktır. Aşağıda, toplam satır ile hastaneye göre vaka sayıları ve medyan CT değerleri tablosu oluşturulmuştur.

"Summarise()" fonksiyonu, hastaneye göre bir özet veri çerçevesi döndürmek için hastaneye göre gruplandırılmış verilerde kullanılır. Ancak `summarise()` fonksiyonu otomatik olarak bir "toplamlar" satırı oluşturmaz, bu nedenle verileri *tekrar* özetleyerek, ancak hastane tarafından gruplandırılmamış verilerle oluştururuz. Bu, yalnızca bir satırdan oluşan ikinci bir veri çerçevesi üretir. Daha sonra nihai tabloya ulaşmak için bu veri çerçevelerini birbirine bağlayabiliriz.

[Açıklayıcı tablolar] ve [Sunum için tablolar] sayfalarında bunun gibi diğer çalışılmış örnekleri inceleyibilirsiniz.


```{r}
# Çekirdek tablo oluştur
###################
hosp_summary <- linelist %>% 
  group_by(hospital) %>%                        # Verileri hastaneye göre gruplandır
  summarise(                                    # İlgilenilen göstergelerin yeni özet sütunları oluşturun
    cases = n(),                                  # Hastane-çıktı grubu başına satır sayısı     
    ct_value_med = median(ct_blood, na.rm=T))     # grup başına medyan CT değeri
```

İşte "hosp_summary" veri çerçevesi:

```{r message=FALSE, echo=F}
DT::datatable(hosp_summary, rownames = FALSE, options = list(pageLength = nrow(10)))
```

"Toplam" istatistiklerle (*hastaneye göre gruplandırılmamış*) bir veri çerçevesi oluşturun. Bu sadece bir satır döndürür.

```{r}
# Toplamları oluştur
###############
totals <- linelist %>% 
  summarise(
    cases = n(),                               # Tüm veri kümesi için satır sayısı    
    ct_value_med = median(ct_blood, na.rm=T))  # Tüm veri seti için medyan CT
```

Ve aşağıda bu "totals" veri çerçevesi var. Sadece iki sütunun nasıl olduğuna dikkat edin. Bu sütunlar da "hosp_summary" içindedir, ancak "hosp_summary"de "totals" ("hastane") içinde olmayan bir sütun vardır.  

```{r message=FALSE, echo=F}
DT::datatable(totals, rownames = FALSE, options = list(pageLength = nrow(10)))
```

Artık satırları `bind_rows()` ile birbirine bağlayabiliriz.

```{r}
# Veri çerçevelerini birbirine bağla
combined <- bind_rows(hosp_summary, totals)
```

Artık sonucu görebiliriz. Son satırda, "hosp_summary"de olmayan "hospital" sütunu için boş bir "NA" değerinin nasıl doldurulduğunu görün. [Sunum için tablolar] sayfasında açıklandığı gibi, `replace_na()` kullanarak bu hücreyi "Total" ile "doldurabilirsiniz".  

```{r message=FALSE, echo=F}
DT::datatable(combined, rownames = FALSE, options = list(pageLength = nrow(10)))
```


### Sütunları bağla {.unnumbered}

İki veri çerçevesini yanlara birleştirmek için kullanabileceğiniz benzer bir **dplyr** fonksiyonu `bind_cols()` vardır. Satırların birbiriyle *konuma göre* eşleştirildiğini unutmayınız (yukarıdaki *birleştirme* gibi değil). Örneğin her veri çerçevesindeki 12. satır hizalanacaktır.

Örneğin, birkaç özet tabloyu birbirine bağlarız. Bunu yapmak için, aynı zamanda, bir veri çerçevesindeki satırların sırasının, 'match()' ile başka bir veri çerçevesindeki sıra ile eşleşecek şekilde nasıl yeniden düzenleneceğini de gösteriyoruz.

Burada 'vaka_bilgisi'ni, hastaneye göre, vaka sayısı ve ölüm sayısı ile birlikte sıralı vakaların özet veri çerçevesi olarak tanımlıyoruz.

```{r}
# Vaka bilgisi
case_info <- linelist %>% 
  group_by(hospital) %>% 
  summarise(
    cases = n(),
    deaths = sum(outcome == "Death", na.rm=T)
  )
```

```{r message=FALSE, echo=F}
DT::datatable(case_info, rownames = FALSE, options = list(pageLength = nrow(10)))
```

Ve diyelim ki burada yine hastane tarafından araştırılan ve "takip edilen" maruz kalan temasların yüzdesi hakkında bilgi içeren farklı bir "contact_fu" veri çerçevesi var. 

```{r}
contact_fu <- data.frame(
  hospital = c("St. Mark's Maternity Hospital (SMMH)", "Military Hospital", "Missing", "Central Hospital", "Port Hospital", "Other"),
  investigated = c("80%", "82%", NA, "78%", "64%", "55%"),
  per_fu = c("60%", "25%", NA, "20%", "75%", "80%")
)
```

```{r message=FALSE, echo=F}
DT::datatable(contact_fu, rownames = FALSE, options = list(pageLength = nrow(10)))
```

Hastanelerin aynı olduğunu, ancak her veri çerçevesinde farklı sıralarda olduğunu unutmayın. En kolay çözüm, 'hastane' sütununda bir 'left_join()' kullanmak olacaktır, ancak fazladan bir adımla 'bind_cols()' da kullanabilirsiniz.

#### Sırasını hizalamak için `match()` kullanımı {.unnumbered}

Satır sıraları farklı olduğundan, basit bir "bind_cols()" komutu, verilerin yanlış eşleşmesine neden olur. Bunu düzeltmek için, bir veri çerçevesinin satırlarını diğeriyle aynı sırada hizalamak için **base** R'dan 'match()' kullanabiliriz. Bu yaklaşım için her iki veri çerçevesinde de yinelenen değer olmadığını varsayıyoruz.

'match()' kullandığımızda, sözdizimi 'match(HEDEF SIRA VEKTÖR, DEĞİŞTİRİLECEK VERİ ÇERÇEVESİ SÜTUNU)' şeklindedir, burada ilk değişken istenen sıradır (ya bağımsız bir vektör, ya da bu durumda bir veri çerçevesi) ve ikinci değişken, yeniden sıralanacak veri çerçevesindeki veri çerçevesi sütunudur. "match()" çıktısı, doğru konum sıralamasını temsil eden bir sayı vektörüdür. Daha fazlasını `?match` ile okuyabilirsiniz.

```{r}
match(case_info$hospital, contact_fu$hospital)
```

Veri çerçevesini yeniden sıralamak için bu sayısal vektörü kullanabilirsiniz - onu '[ ]' alt küme parantezleri içine *virgülden önce* yerleştirin. [R temelleri] sayfasında **temel** R köşeli ayraç alt kümesi sözdizimi hakkında daha fazla bilgi edinin. Aşağıdaki komut, satırların yukarıdaki sayısal vektörde sıralandığı eskisi olarak tanımlanan yeni bir veri çerçevesi oluşturur.

```{r}
contact_fu_aligned <- contact_fu[match(case_info$hospital, contact_fu$hospital),]
```


```{r message=FALSE, echo=F}
DT::datatable(contact_fu_aligned, rownames = FALSE, options = list(pageLength = nrow(10)))
```

Artık veri çerçevesi sütunlarını doğru satır sırası ile birbirine bağlayabiliriz. Bazı sütunların çoğaltıldığını ve 'rename()' ile temizlenmesi gerekeceğini unutmayın. `bind_rows()` hakkında daha fazla bilgi edinmek için tıklayınız. [buradan](https://dplyr.tidyverse.org/reference/bind.html).  

```{r}
bind_cols(case_info, contact_fu)
```

"bind_cols"e bir **base** R alternatifi, aynı işlemi gerçekleştiren "cbind()"dir.




<!-- ============================================ ========= -->
## Kaynaklar { }

[Birleşimlerdeki tidyverse sayfası](https://dplyr.tidyverse.org/reference/join.html)

[İlişkisel verilerle ilgili Veri Bilimi için R sayfası](https://r4ds.had.co.nz/relational-data.html)

[dplyr'deki tidyverse sayfası](https://dplyr.tidyverse.org/reference/bind.html) ciltleme hakkında

Paketin Github sayfasındaki betimlemesi [fastLink](https://github.com/kosukeimai/fastLink)

Metodolojisini açıklayan yayın[fastLink](https://imai.fas.harvard.edu/research/files/linkage.pdf) 

[RecordLinkage paketini] açıklayan yayın
(https://journal.r-project.org/archive/2010/RJ-2010-017/RJ-2010-017.pdf)


```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/joining_matching.Rmd-->


# Tekilleştirme {}  

```{r, out.width=c("50%"), echo=F}
knitr::include_graphics(here::here("images", "deduplication.png"))
```

Bu sayfa aşağıdaki veri tekilleştirme tekniklerini kapsamaktadır:

1. Yinelenen satırları belirleme ve kaldırma
2. Her satır grubundan yalnızca belirli satırları (ör. min veya maks) tutmak için satırları "dilimleme" 
3. "Toplama" veya birden çok satırdaki değerleri tek satırda birleştirme  


<!-- ======================================================= -->
## Hazırlık { }


### Paketleri yükleme {.unnumbered}

Bu kod parçası, analizler için gereken paketlerin yüklenmesini göstermektedir. Bu el kitabında, paketi kuran *ve* eğer gerekirse kullanım için yükleyen pacman'ın `p_load()` işlevlerini vurgulamaktayız. Ayrıca, **base** R'den `library()` fonksiyonu ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R'ın Temelleri] sayfasına bakabilirsiniz.

```{r}
pacman::p_load(
  tidyverse,   # tekilleştirme, gruplama ve dilimleme işlevleri
  janitor,     # kopyaları gözden geçirme işlevi
  stringr)      # dizi aramaları için "toplama" değerleri de kullanılabilir
```

### Verileri içeri aktarma {.unnumbered}

Aşağıda, R kodu ile oluşturulmuş örnek bir veri seti kullanacağız.

Veriler, temaslı kişiler ve vakalar dahil olmak üzere COVID-19 telefon görüşmelerinin kayıtlarıdır. Sütunlar, kayıt kimliği - `recordID` (bilgisayar tarafından oluşturulan), kişi kimliği - `personID`, ad - `name`, karşılaşma tarihi - `date`, karşılaşma zamanı - `time`, karşılaşmanın amacını - `purpose` (vaka veya temaslı olarak görüşme için) ve semptomları `symptoms_ever` (kayıt zamanında kişinin *hiç* semptom bildirip bildirmediğini) içerir.

`obs` veri kümesini oluşturmak için gereken kod:

```{r}
obs <- data.frame(
  recordID  = c(1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18),
  personID  = c(1,1,2,2,3,2,4,5,6,7,2,1,3,3,4,5,5,7,8),
  name      = c("adam", "adam", "amrish", "amrish", "mariah", "amrish", "nikhil", "brian", "smita", "raquel", "amrish",
                "adam", "mariah", "mariah", "nikhil", "brian", "brian", "raquel", "natalie"),
  date      = c("1/1/2020", "1/1/2020", "2/1/2020", "2/1/2020", "5/1/2020", "5/1/2020", "5/1/2020", "5/1/2020", "5/1/2020","5/1/2020", "2/1/2020",
                "5/1/2020", "6/1/2020", "6/1/2020", "6/1/2020", "6/1/2020", "7/1/2020", "7/1/2020", "7/1/2020"),
  time      = c("09:00", "09:00", "14:20", "14:20", "12:00", "16:10", "13:01", "15:20", "14:20", "12:30", "10:24",
                "09:40", "07:25", "08:32", "15:36", "15:31", "07:59", "11:13", "17:12"),
  encounter = c(1,1,1,1,1,3,1,1,1,1,2,
                2,2,3,2,2,3,2,1),
  purpose   = c("contact", "contact", "contact", "contact", "case", "case", "contact", "contact", "contact", "contact", "contact",
                "case", "contact", "contact", "contact", "contact", "case", "contact", "case"),
  symptoms_ever = c(NA, NA, "No", "No", "No", "Yes", "Yes", "No", "Yes", NA, "Yes",
                    "No", "No", "No", "Yes", "Yes", "No","No", "No")) %>% 
  mutate(date = as.Date(date, format = "%d/%m/%Y"))
```


#### Veri Çerçevesi {#dedup_data .unnumbered}  

Her bir kişi için karşılaşmaları gözden geçirmek için üst kısımdaki filtre kutularını kullanabilirsiniz. 

```{r message=FALSE, echo=F}
DT::datatable(obs, rownames = FALSE, filter = "top", options = list(pageLength = nrow(obs), scrollX=T), class = 'white-space: nowrap' )
```


Verileri gözden geçirirken dikkat etmeniz gereken birkaç nokta:

* İlk iki kayıt, yineleyen kayıt kimliği - `recordID` de dahil olmak üzere %100 birbirinin tam kopyalarıdır (bir bilgisayar arızası olmalı!)
* İkinci iki satır, kayıt kimliği - `recordID dışındaki` tüm sütunlarda birbirinin kopyalarıdır.
* Birkaç kişi, çeşitli tarih ve saatlerde ve temaslılar ve/veya vakalar olarak birden fazla telefon görüşmesi yaptı.
* Her vizitte, kişiye **daha öncesinde** semptomları olup olmadığı soruldu ve bu bilgilerin bir kısmı eksik. 


Ve işte **janitor** paketinden `tabyl()` fonksiyonu kullanılarak insanların ve karşılaşmalarının amaçlarının kısa bir özeti:

```{r}
obs %>% 
  tabyl(name, purpose)
```
<!-- ======================================================= -->
## Tekilleştirme { }


Bu bölüm, bir veri çerçevesindeki yinelenen satırların nasıl gözden geçirileceğini ve kaldırılacağını açıklamakta ve bir vektörde yinelenen öğelerin nasıl ele alınacağını göstermektedir.  


<!-- ======================================================= -->
### Yinelenen satırları inceleme {.unnumbered}  


Yinelenen satırları hızlı bir şekilde gözden geçirmek için **janitor** paketinden `get_dupes()` öğesini kullanabilirsiniz. *Varsayılan olarak*, yinelemeler değerlendirilirken tüm sütunlar dikkate alınır - fonksiyon tarafından döndürülen satırlar, **bütün** sütunlardaki değerler dikkate alındığında %100 yinelemedir.

`obs` veri çerçevesinde, ilk iki satır *%100 kopyadır* - her sütunda aynı değere sahiptirler (*benzersiz olması gereken* kayıt kimliği - `recordID` sütunu dahil - bir bilgisayar arızası olmalı). Döndürülen veri çerçevesi, sağ tarafta otomatik olarak yeni bir `dupe_count` sütunu içerir ve bu yinelenen değerler kombinasyonuna sahip satır sayısını gösterir.

```{r, eval=F}
# Tüm sütunlarda %100 kopyalar
obs %>% 
  janitor::get_dupes()
```

```{r message=FALSE, echo=F}
obs %>% 
  janitor::get_dupes() %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = nrow(obs), scrollX=T), class = 'white-space: nowrap' )
```

Orijinal veriyi incelemek için [linke](#dedup_data) tıklayınız.

Ancak kayıt kimliğini- `recordID` yok saymayı seçersek 3. ve 4. satırlar da birbirinin kopyasıdır. Yani, `recordID` *dışındaki* tüm sütunlarda aynı değerlere sahiptirler. Bir `-` eksi sembolü kullanarak fonksiyonda yok sayılacak belirli sütunları belirtebilirsiniz.  

```{r, eval=F}
# Sütun kayıt kimliği/recordID dikkate alınmadığında yinelenir
obs %>% 
  janitor::get_dupes(-recordID)         # if multiple columns, wrap them in c()
```

```{r message=FALSE, echo=F}
obs %>% 
  janitor::get_dupes(-recordID) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = nrow(obs), scrollX=T), class = 'white-space: nowrap' )
```

Ayrıca dikkate alınacak sütunları pozitif olarak belirleyebilirsiniz. Aşağıda, yalnızca ad- `name` ve amaç - `name` sütunlarında aynı değerlere sahip satırlar döndürülür. "amrish"in, üç "temas" karşılaşmasını yansıtmak için nasıl  `dupe_count`'un 3'e eşit olduğuna dikkat edin. 

**Daha fazla satır görmek için sola kaydırın.**  

```{r, eval=F}
# YALNIZCA ad ve amaç sütunlarına dayalı olarak kopyalar
obs %>% 
  janitor::get_dupes(name, purpose)
```

```{r message=FALSE, echo=F}
obs %>% 
  janitor::get_dupes(name, purpose) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 7, scrollX=T), class = 'white-space: nowrap' )
```

Orijinal veriyi incelemek için [linke](#dedup_data) tıklayınız.

Daha fazla ayrıntı için `?get_dupes` fonksiyonunu kullanabilir veya bu [çevrimiçi referansa](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html#explore-records-with-duplicated-values-for-specific-combinations-of-variables-with-get_dupes) bakabilirsiniz.





<!-- ======================================================= -->
### Yalnızca benzersiz satırları tutma  {.unnumbered}


Bir veri çerçevesinin yalnızca benzersiz satırlarını tutmak için **dplyr** paketinden `distinct()` fonksiyonunu kullanabilirsiniz ([Veri ve temel işlevleri temizleme] sayfasında gösterildiği gibi). Yinelenen satırlar, bu tür satırlardan yalnızca ilki tutulacak şekilde kaldırılır. Varsayılan olarak, "ilk" en yüksek satır sayısı - `rownumber` anlamına gelir (yukarıdan aşağıya sırasında). Yalnızca benzersiz satırlar kalır.

Aşağıdaki örnekte, kayıt kimliği - `recordID` sütununun dikkate alınmaması için `distinct()` fonksiyonunu çalıştırıyoruz - bu nedenle *iki yinelenen satır* kaldırılmaktadır. İlk satır ("adam" için) %100 kopyalandı ve kaldırıldı. Ayrıca 3. satır ("amrish" için) `recordID` (değerlendirilmemiştir) *dışındaki* her sütunda bir kopyaydı ve bu nedenle de kaldırıldı. `obs` veri kümesinin n'i `nrow(obs)-2`dir, `nrow(obs)` satırı değil.

*Tüm veri çerçevesini görmek için sola kaydırın.*  


```{r, eval=F}
# veri zincirine eklendi (ör. veri temizleme)
obs %>% 
  distinct(across(-recordID), # veri çerçevesini yalnızca benzersiz satırlara indirger (herhangi bir kopyadan ilkini tutar)
           .keep_all = TRUE) 

# eğer veri zincirinin dışındaysa, verileri ilk argüman olarak dahil et 
# distinct(obs)
```

```{r message=FALSE, echo=F}
obs %>% 
  distinct(across(-recordID), # veri çerçevesini yalnızca benzersiz satırlara indirger (herhangi bir kopyadan ilkini tutar)
           .keep_all = TRUE) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 6, scrollX=T), class = 'white-space: nowrap' )
```

<span style="color: orange;">**_UYARI:_** Gruplandırılmış verilerde `distinct()` kullanılıyorsa, fonksiyon her gruba uygulanacaktır.</span>


**Belirli sütunlara dayalı olarak tekilleştirme**  

Ayrıca tekilleştirme için temel olacak sütunları da belirtebilirsiniz. Bu şekilde, tekilleştirme yalnızca belirtilen sütunlar içinde yinelenen satırlar için geçerlidir. `.keep_all = TRUE`, olarak ayarlamadığınız sürece, belirtilmeyen tüm sütunlar kaldırılacaktır.

Aşağıdaki örnekte, tekilleştirme yalnızca ad - `name` ve amaç - `purpose` sütunları için aynı değerlere sahip satırlar için geçerlidir. Böylece, "brian"ın 3 yerine sadece 2 satırı vardır - *ilk* "temas" karşılaşması ve tek "vaka" karşılaşması. Brian'ın her bir amaç için *en son* karşılaşmasını koruyacak şekilde ayarlamak için, Gruplar içinde Dilimleme sekmesine bakın.

*Tüm veri çerçevesini görmek için sola kaydırın.*

```{r, eval=F}
# veri zincirine eklendi (ör. veri temizleme)
obs %>% 
  distinct(name, purpose, .keep_all = TRUE) %>%  # satırları ada ve amaca göre benzersiz tut ve tüm sütunları koru
  arrange(name)                                  # daha kolay görüntüleme için düzenle
```

```{r message=FALSE, echo=F}
obs %>% 
  distinct(name, purpose, .keep_all = TRUE) %>%  # satırları ada ve amaca göre benzersiz tut ve tüm sütunları koru
  arrange(name) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 6, scrollX=T), class = 'white-space: nowrap' )
```

Orijinal veriyi incelemek için [linke](#dedup_data) tıklayınız. 

<!-- ======================================================= -->
### Bir vektörde yinelenen öğeler {.unnumbered}  


**base** R'dan `duplicated()` fonksiyonu, bir vektörü (sütun) değerlendirecek ve aynı uzunlukta (DOĞRU/YANLIŞ) bir mantıksal vektöre döndürecektir. Bir değer ilk göründüğünde, YANLIŞ’a (yinelenen değil) döndürür ve bu değerin sonraki görüntülerinde DOĞRU’ya döndürür. `NA`'nın diğer herhangi bir değerle nasıl aynı şekilde ele alındığına dikkat edin. 

```{r}
x <- c(1, 1, 2, NA, NA, 4, 5, 4, 4, 1, 2)
duplicated(x)
```

Yalnızca yinelenen öğeleri döndürmek için, orijinal vektörün alt kümesini oluşturmak için köşeli parantezleri kullanabilirsiniz:

```{r}
x[duplicated(x)]
```

Yalnızca benzersiz öğeleri döndürmek için, **base** R'dan `unique()` kullanın. `NA`'ları sonuçtan çıkarmak için na.omit() öğesini `unique()` içine yerleştirin.

```{r}
unique(x)           # alternatif olarak, x[!duplicated(x)]kullanın
unique(na.omit(x))  # NA’ları kaldırın
```


<!-- ======================================================= -->
### **base** R'ı kullanma {.unnumbered}

**Yinelenen satırları döndürmek için**  

**base** R'da, `duplicated(df)` komutuyla `df` veri çerçevesinde hangi satırların %100 kopya olduğunu da görebilirsiniz (satırların mantıksal vektörünü döndürür).

Bu nedenle, `df[duplicated(df),]` ile *yineleyen* satırları görmek için veri çerçevesindeki `[ ]` temel alt kümesini de kullanabilirsiniz (virgülü unutmayın, bu tüm sütunları görmek istediğiniz anlamına gelir!).

**Benzersiz satırları döndürmek için**  

Yukarıdaki notlara bakın. *Benzersiz* satırları görmek için `duplicated()` işlevinin önünde mantıksal olumsuzlayıcıyı/logical negator `!v eklersiniz: 
`df[!duplicated(df),]`  


**Yalnızca belirli sütunların kopyası olan satırları döndürmek için**  

*`duplicated()` parantez içindeki* `df`’yi alt kümeye alın, böylece bu işlev df'nin yalnızca belirli sütunlarında çalışacaktır.

Sütunları belirtmek için, virgülden sonra sütun numaralarını veya adlarını girin (tüm bunların `duplicated()` fonksiyonu *içinde* olduğunu unutmayın).

`duplicated()` fonksiyonundan sonra da virgülü `dışarıda` tuttuğunuzdan emin olun!

Örneğin, kopyalar için yalnızca 2 ila 5 arasındaki sütunları değerlendirmek için:  `df[!duplicated(df[, 2:5]),]`  
Kopyalar için yalnızca `name` ve `purpose` sütununu değerlendirmek için: `df[!duplicated(df[, c("name", "purpose)]),]`  





<!-- ======================================================= -->
## Dilimleme { }


Satır numarasına/konumuna göre satırlara filtre uygulamak için bir veri çerçevesini "dilimlemek". Bu, özellikle işlevsel grup başına (örneğin, "kişi" başına) birden çok satırınız varsa ve bunlardan yalnızca birini veya birkaçını tutmak istiyorsanız yararlı olur.

Temel `slice()` işlevi sayıları kabul eder ve bu konumlardaki satırları döndürür. Sağlanan sayılar pozitifse, yalnızca döndürülür. Negatifse, bu satırlar *döndürülmez*. Sayıların tümü pozitif veya tümü negatif olmalıdır.     

```{r}
obs %>% slice(4)  # 4. satırı döndür
```

```{r}
obs %>% slice(c(2,4))  # 2. ve 4. satırları döndür
#obs %>% slice(c(2:4))  # 2'den 4'e kadar olan satırları döndür
```


Orijinal veriyi incelemek için [linke](#dedup_data) tıklayınız.

Birkaç varyasyon mevcuttur: Bunlara bir sütun ve döndürülecek birkaç satır verilmelidir ( n ='ye).  

* `slice_min()` ve `slice_max()` yalnızca belirtilen sütunun minimum veya maksimum değer(ler)ine sahip satır(lar)ı tutar. Bu aynı zamanda sıralı faktörlerin "min" ve "maks" değerlerini döndürmek için de işe yarar.
* `slice_head()` ve `slice_tail()` -  sadece *ilk* veya *son* satır(lar)ı tutar.
* `slice_sample()` - satırların yalnızca rastgele bir örneğini tutar.  


```{r}
obs %>% slice_max(encounter, n = 1)  # en büyük karşılaşma numarasına sahip satırları döndür
```

Saklanacak satırların sayısını veya oranını belirtmek için  `n = ` veya `prop = ` argümanlarını kullanın. İşlev bir boru zincirinde kullanılmıyorsa, önce veri bağımsız değişkenini sağlayın (ör. `slice(data, n = 2)`). Daha fazla bilgi için `?slice` bölümüne bakın.

Diğer argümanlar: 

`.order_by = ` `slice_min()` ve `slice_max()` içinde kullanılır ve bu, dilimlemeden önce sıralanması gereken bir sütundur.
`with_ties = ` Varsayılan olarak DOĞRU, yani bağlar korunur.
`.preserve = ` Varsayılan olarak YANLIŞ. DOĞRU ise, dilimlemeden sonra gruplama yapısı yeniden hesaplanır.  
`weight_by = ` Ağırlıklandırmaya göre isteğe bağlı, sayısal sütun (daha büyük sayının örneklenmesi daha olasıdır).
Ayrıca `replace = ` Örneklemenin değiştirilerek/değiştirilmeden yapılıp yapılmadığı için. 

<span style="color: darkgreen;">**_İPUCU:_** `slice_max()` ve `slice_min()` kullanırken, n ='yi belirttiğinizden/yazdığınızdan emin olun (ör. `n = 2`, sadece `2` değil). Aksi takdirde bir hata alabilirsiniz. `Error:` … `is not empty.`</span>

<span style="color: black;">**_NOT:_** slice işlevlerinin yerini alan [`top_n()`](https://dplyr.tidyverse.org/reference/top_n.html) fonksiyonuyla karşılaşabilirsiniz.</span>

 


<!-- ======================================================= -->
### Gruplarla dilimleme  {.unnumbered}

`slice_*()` fonksiyonları, gruplanmış bir veri çerçevesine uygulandığında çok yararlı olabilir, çünkü dilim işlemi her grup üzerinde ayrı ayrı gerçekleştirilir. Her gruptan bir dilim almak üzere verileri gruplamak için `group_by()` **fonksiyonunu** `slice()` ile birlikte kullanın.

Bu, kişi başına birden fazla satırınız varsa ancak bunlardan yalnızca birini tutmak istiyorsanız, tekilleştirme için yararlıdır. Önce `group_by()` fonksiyonunu kişi başına aynı olan anahtar sütunlarla kullanırsınız ve ardından gruplanmış satırlar arasında farklılık gösterecek bir sütun üzerinde bir `slice` fonksiyonunu kullanırsınız.

Aşağıdaki örnekte, *kişi başına* yalnızca *en son* karşılaşmayı tutmak için satırları ada - `name`  göre grupladık ve ardından tarih - `date` sütununda `n = 1` ile `slice_max()`'ı kullandık. Haberin olsun! Tarihlere `slice_max()` gibi bir işlevi uygulamak için tarih sütunu Date sınıfı olmalıdır.

Varsayılan olarak, "bağlar" (ör. bu senaryoda aynı tarih) korunur ve yine de bazı insanlar için (ör. adam) birden çok satır alırız. Bunu önlemek için `with_ties = FALSE` olarak ayarladık. 

<span style="color: orange;">**_UYARI:_** Eğer `arrange()` fonksiyonu kullanılıyorsa, verilerin her bir grup içinde düzenlenmesi için `.by_group = TRUE` olarak belirtin.</span>

<span style="color: red;">**_TEHLİKE:_** Eğer `with_ties = FALSE` ise, bir bağın ilk satırı tutulur. Bu aldatıcı olabilir. Mariah'nın son randevusunda (6 Ocak) iki karşılaşması var ve ilki (en erken) tutuluyor. Muhtemelen, o gün daha sonraki karşılaşmasını sürdürmek istiyoruz. Bir sonraki örnekte bu bağların nasıl "kırılacağını" görebilirsiniz.</span>  




```{r, eval=F}
obs %>% 
  group_by(name) %>%       # satırları 'ad'a göre gruplandır
  slice_max(date,          # maksimum tarih değerine sahip grup başına satır tut 
            n = 1,         # sadece tek en yüksek satırı tut
            with_ties = F) # (tarihin) bir bağı varsa, ilk sırayı alın
```

```{r message=FALSE, echo=F}
obs %>% 
  group_by(name) %>%       # satırları 'ad'a göre gruplandır
  slice_max(date,          # maksimum tarih değerine sahip grup başına satır tut
            n = 1,         # sadece tek en yüksek satırı tut
            with_ties = F) %>%  # (tarihin) bir bağı varsa, ilk sırayı alın
  DT::datatable(rownames = FALSE, options = list(pageLength = 8, scrollX=T), class = 'white-space: nowrap' )
```

Yukarıda, örneğin sadece Amrish'in 5 Ocak'taki satırının tutulduğunu ve sadece Brian'ın 7 Ocak'taki satırının tutulduğunu görebiliriz. Orijinal veriyi incelemek için [linke](#dedup_data) tıklayınız. 


**"Bağları" kırmak**  

"Bağları kırmak" için birden çok dilim ifadesi çalıştırılabilir. Bu durumda, bir kişinin en son *tarihinde* birden fazla karşılaşması varsa, en son *zamanlı* olan karşılaşma tutulur (karakter zamanlarını sıralanabilir bir zaman sınıfına dönüştürmek için `lubridate::hm()` kullanılır).
Şimdi, 6 Ocak'ta “Mariah” için tutulan bir satırın, 07:25'teki 2. karşılaşma değil, 08:32'deki 3. karşılaşma olduğuna dikkat edin.

```{r, eval=F}
# "Bağları kırmak" için çoklu dilim ifadesi örneği
obs %>%
  group_by(name) %>%
  
  # İLK - en son tarihe göre dilimleyin
  slice_max(date, n = 1, with_ties = TRUE) %>% 
  
  # İKİNCİ - bir bağ varsa, en son zamana sahip satırı seçin; bağlar yasak
  slice_max(lubridate::hm(time), n = 1, with_ties = FALSE)
```

```{r message=FALSE, echo=F}
# "Bağları kırmak" için çoklu dilim ifadesi örneği
obs %>%
  group_by(name) %>%
  
  # İLK - en son tarihe göre dilimleyin
  slice_max(date, n = 1, with_ties = TRUE) %>% 
  
  # İKİNCİ - bir bağ varsa, en son zamana sahip satırı seçin; bağlar yasak
  slice_max(lubridate::hm(time), n = 1, with_ties = FALSE) %>% 
  
  DT::datatable(rownames = FALSE, options = list(pageLength = 8, scrollX=T), class = 'white-space: nowrap' )
```

*ScriptIn yukarıdaki örnekte karşılaşma - `encounter` sayısına göre dilimleme yapmak da mümkün olabilirdi ama biz örnek amaçlı olarak tarih - `date` ve saat - `time` üzerinde dilimi gösterdik.*

<span style="color: darkgreen;">**_İPUCU:_** Bir "karakter" sütununda `slice_max()` veya  `slice_min()` kullanmak için, onu sıralı bir faktör sınıfına dönüştürün!</span>

Orijinal veriyi incelemek için [linke](#dedup_data) tıklayınız.


<!-- ======================================================= -->
### Hepsini sakla ama işaretle  {.unnumbered}

Tüm kayıtları tutmak, ancak yalnızca bazılarını analiz için işaretlemek istiyorsanız, benzersiz bir recordID/encounter number:  

1) Orijinal veri çerçevesini analiz için yalnızca satırlara küçültün/dilimleyin. Bu azaltılmış veri çerçevesini kaydedin/saklayın.
2) Orijinal veri çerçevesinde, satırları, kayıtlı benzersiz tanımlayıcısının (bu örnekte recordID) indirgenmiş veri çerçevesinde bulunup bulunmadığına bağlı olarak `case_when()` ile uygun şekilde işaretleyin.


```{r}
# 1. Analiz için saklanacak satırların veri çerçevesini tanımlayın
obs_keep <- obs %>%
  group_by(name) %>%
  slice_max(encounter, n = 1, with_ties = FALSE) # her kişi başına yalnızca en son karşılaşmayı tutun


# 2. Orijinal veri çerçevesini işaretleyin
obs_marked <- obs %>%

  # yeni dup_record sütunu oluşturun
  mutate(dup_record = case_when(
    
    # kayıt obs_keep veri çerçevesindeyse
    recordID %in% obs_keep$recordID ~ "For analysis", 
    
    # analiz amacıyla "Yoksay" olarak işaretlenen diğer her şey
    TRUE                            ~ "Ignore"))

# yazdır
obs_marked
```


```{r, echo=F}
DT::datatable(obs_marked, rownames = FALSE, options = list(pageLength = 8, scrollX=T), class = 'white-space: nowrap' )
```

Orijinal veriyi incelemek için [linke](#dedup_data) tıklayınız.

<!-- ======================================================= -->
### Satır tamlığını hesapla {.unnumbered} 

Satırın tamlığı (eksik olmaması) için bir metrik içeren bir sütun oluşturun. Bu, tekilleştirme/dilimleme sırasında hangi satırların diğerlerine göre önceliklendirileceğine karar verirken yardımcı olabilir.   

Bu örnekte, tamlığını ölçmek istediğiniz "anahtar" sütunlar, bir sütun adları vektörüne kaydedilir. 

Daha sonra `mutate()` ile yeni `key_completeness` sütunu oluşturulur. Her satırdaki yeni değer, hesaplanmış bir kesir olarak tanımlanır: o satırda anahtar sütunlar arasında eksik olmayan değerlerin sayısı, anahtar sütunların sayısına bölünür.

Bu işlem, base R'daki `rowSums()` fonksiyonunu içermektedir. Ayrıca, tünellemede, veri çerçevesindeki bir noktaya atıfta bulunan `.` kullanılır (bu durumda, köşeli parantez `[]` ile alt kümelenmektedir).

*Daha fazla satır görmek için sağa kaydırın**  

```{r, eval=F}
# bir "değişken tamlığı" sütunu oluşturun
# bu, eksik olmayan değerlere sahip "key_cols" olarak belirlenmiş sütunların *oranıdır*

key_cols = c("personID", "name", "symptoms_ever")

obs %>% 
  mutate(key_completeness = rowSums(!is.na(.[,key_cols]))/length(key_cols)) 
```

```{r message=FALSE, echo=F}
key_cols = c("personID", "name", "symptoms_ever")

obs %>% 
  mutate(key_completeness = rowSums(!is.na(.[,key_cols]))/length(key_cols)) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Orijinal veriyi incelemek için [linke](#dedup_data) tıklayınız. 




<!-- ======================================================= -->
## Toplama değerleri {#str_rollup}


Bu bölüm şunları açıklar:  

1) Bazı varyasyonlarla birden çok satırdaki değerleri tek bir satıra "toplama"
2) "Toplanmış" değerlere sahip olduğunuzda, her hücredeki değerlerin üzerine nasıl yazılır/öncelik verilir 

Bu sekme, Hazırlık sekmesindeki örnek veri kümesini kullanır.  



<!-- ======================================================= -->
### Değerleri bir satıra topla {.unnumbered}  

Aşağıdaki kod örneği, satırları kişiye göre gruplandırmak için `group_by()` ve `summarise()` öğelerini kullanır ve ardından gruplanmış satırlardaki tüm benzersiz değerleri birbirine yapıştırır. Böylece kişi başına bir özet satırı elde edersiniz.  

* Tüm yeni sütunlara bir son ek eklenir (bu örnekte "_roll"). 
* Hücre başına yalnızca benzersiz değerleri göstermek istiyorsanız, `na.omit()` öğesini `unique()` ile sarın. 
* `na.omit()` `NA` değerlerini kaldırır, ancak bu istenmiyorsa `paste0(.x)`… kaldırılabilir.



```{r, eval=F}
# "Toplama" değerlerini grup başına bir satırda toplar ("personID" başına) 
cases_rolled <- obs %>% 
  
  # Ada göre grup oluşturur
  group_by(personID) %>% 
  
  # Her gruptaki satırları sıralar (ör. tarihe göre)
  arrange(date, .by_group = TRUE) %>% 
  
  # Her sütun için, gruplandırılmış satırlardaki tüm değerleri ";" ile ayırarak birbirine yapıştır
  summarise(
    across(everything(),                           # Tüm sütunlara uygula
           ~paste0(na.omit(.x), collapse = "; "))) # NA olmayan benzersiz değerleri birleştiren işlev tanımlanır
```

Fonksiyonun çıktısı, girişlerin tarihe göre düzenlendiği ve birbirine yapıştırıldığı, grup başına bir satırdır ("ID"). *Daha fazla satır görmek için sola kaydırın.*    

```{r message=FALSE, echo=F}
# "Toplama" değerlerini grup başına bir satırda toplar ("personID" başına) 
obs %>% 
  
  # Ada göre grup oluşturur
  group_by(personID) %>% 
  
  # Her gruptaki satırları sıralar (ör. tarihe göre)
  arrange(date, .by_group = TRUE) %>% 
  
  # Her sütun için, gruplandırılmış satırlardaki tüm değerleri ";" ile ayırarak birbirine yapıştır
  summarise(
    across(everything(),                                # Tüm sütunlara uygular
           ~paste0(na.omit(.x), collapse = "; "))) %>%  # NA olmayan benzersiz değerleri birleştiren işlev tanımlanır

  DT::datatable(rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

Orijinal veriyi incelemek için [linke](#dedup_data) tıklayınız. 


**Bu varyasyon yalnızca benzersiz değerleri gösterir:**  

```{r}
# Varyasyon - yalnızca benzersiz değerleri göster
cases_rolled <- obs %>% 
  group_by(personID) %>% 
  arrange(date, .by_group = TRUE) %>% 
  summarise(
    across(everything(),                                   # Tüm sütunlara uygular
           ~paste0(unique(na.omit(.x)), collapse = "; "))) # NA olmayan benzersiz değerleri birleştiren işlev tanımlanır
```

```{r message=FALSE, echo=F}
# Varyasyon - yalnızca benzersiz değerleri göster
obs %>% 
  group_by(personID) %>% 
  arrange(date, .by_group = TRUE) %>% 
  summarise(
    across(everything(),                                   # Tüm sütunlara uygular
           ~paste0(unique(na.omit(.x)), collapse = "; "))) %>%  # NA olmayan benzersiz değerleri birleştiren işlev tanımlanır

  DT::datatable(rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


**Bu varyasyon, her sütuna bir son ek ekler.**  
Bu durumda, yuvarlandığını belirtmek için "_roll":  

```{r, eval=F}
# Varyasyon - sütun adlarına eklenen sonek 
cases_rolled <- obs %>% 
  group_by(personID) %>% 
  arrange(date, .by_group = TRUE) %>% 
  summarise(
    across(everything(),                
           list(roll = ~paste0(na.omit(.x), collapse = "; ")))) # _roll sütun adlarına eklenir
```

```{r message=FALSE, echo=F}
# Satır listesi verilerini tablo olarak göster
# Varyasyon - sütun adlarına eklenen sonek
obs %>% 
  group_by(personID) %>% 
  arrange(date, .by_group = TRUE) %>% 
  summarise(
    across(everything(),                
           list(roll = ~paste0(na.omit(.x), collapse = "; ")))) %>%  # _roll sütun adlarına eklenir
  DT::datatable(rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


<!-- ======================================================= -->
### Değerlerin/hiyerarşinin üzerine yaz {.unnumbered} 


Daha sonra tüm yuvarlanan değerleri değerlendirmek ve yalnızca belirli bir değeri (örneğin, "en iyi" veya "maksimum" değer) tutmak istiyorsanız, dize kalıplarını sırayla aramak ve hücre içeriğinin üzerine yazmak için **stringr** paketinden `str_detect()` kullanan `case_when()` öğesini uygulamak için istenen sütunlarda `mutate()` öğesini kullanabilirsiniz.

```{r}
# TEMİZ VAKALAR
#############
cases_clean <- cases_rolled %>% 
    
    # Temiz Evet-Hayır-Bilinmeyen değişkenler: metni dizede bulunan "en yüksek" değerle değiştir
    mutate(across(c(contains("symptoms_ever")),                     # belirtilen sütunlarda çalışır (E/H/B)
             list(mod = ~case_when(                                 # yeni sütunlara "_mod" son ekini ekler; case_when() öğesini uygular
               
               str_detect(.x, "Yes")       ~ "Yes",                 # "Evet" algılanırsa, hücre değeri evet'e dönüşür
               str_detect(.x, "No")        ~ "No",                  # daha sonra, "Hayır" algılanırsa, hücre değeri hayır'a dönüşür
               str_detect(.x, "Unknown")   ~ "Unknown",             # daha sonra, "Bilinmeyen" algılanırsa, hücre değeri bilinmeyen'e dönüşür
               TRUE                        ~ as.character(.x)))),   # sonra, başka bir şey varsa olduğu gibi tutulursa
      .keep = "unused")                                             # eski sütunlar kaldırıldı, yalnızca _mod sütunları kaldı
```


Şimdi, `symptoms_ever`  sütununda görebilirsiniz, eğer kişi HEP semptomlara “Evet” dediyse, o zaman sadece “Evet” görüntülenir.

```{r message=FALSE, echo=F}
# Satır listesi verilerini tablo olarak göster
DT::datatable(cases_clean, rownames = FALSE, options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap')
```


Orijinal veriyi incelemek için [linke](#dedup_data) tıklayınız.


## Probabilistic de-duplication  

Bazen, ad, yaş, cinsiyet, doğum tarihi vb. gibi çeşitli sütunlarda benzerliğe (ör. dize "mesafe") dayalı olarak "olası" yinelemeleri belirlemek isteyebilirsiniz. Olası yinelemeleri belirlemek için olasılıklı bir eşleştirme algoritması uygulayabilirsiniz. 

Bu yöntemle ilgili bir açıklama için [Verileri birleştirme] sayfasına bakın. Olasılıksal Eşleştirme bölümü, bir veri çerçevesini *kendisiyle* karşılaştırmak için bu algoritmaları uygulamanın bir örneğini içerir, böylece olasılıksal tekilleştirme gerçekleştirir.



<!-- ======================================================= -->
## Kaynaklar { }

Bu sayfadaki bilgilerin çoğu şu kaynaklardan ve çevrimiçi vinyetlerden uyarlanmıştır:

[datanovia](https://www.datanovia.com/en/lessons/identify-and-remove-duplicate-data-in-r/)

[dplyr tidyverse reference](https://dplyr.tidyverse.org/reference/slice.html)  

[cran janitor vignette](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html#explore-records-with-duplicated-values-for-specific-combinations-of-variables-with-get_dupes)  

```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/deduplication.Rmd-->


# Yineleme, döngüler ve listeler { }  

Epidemiyologlar sıklıkla ülkeler, ilçeler veya yaş grupları gibi alt gruplar üzerinde tekrar eden analizlerle karşı karşıya kalırlar. Bunlar *yinelemeyi* içeren birçok durumdan sadece birkaçıdır. Aşağıdaki yaklaşımları kullanarak yinelemeli işlemlerinizi kodlamak, bu tür tekrarlayan görevleri daha hızlı gerçekleştirmenize, hata olasılığını azaltmanıza ve kod uzunluğunu azaltmanıza yardımcı olacaktır.

Bu sayfa, yinelemeli işlemlere iki yaklaşım sunacaktır - *for döngülerini* ve *purrr* paketini kullanmak.

1) *for döngüleri*, bir dizi giriş boyunca kodu yineler, ancak R'da diğer programlama dillerinden daha az yaygındır. Yine de, onları burada bir öğrenme aracı ve referans olarak tanıtıyoruz.
2) **purrr** paketi, yinelemeli işlemlere **tidyverse** yaklaşımdır - bir işlevi birçok girdi arasında "eşleyerek" çalışır (değerler, sütunlar, veri kümeleri vb.)

Yol boyunca, aşağıdaki gibi örnekler göstereceğiz:

* Birden çok dosyayı içe ve dışa aktarma  
* Birden fazla yetki alanı için eğriler oluşturma  
* Bir veri çerçevesindeki birkaç sütun için T testleri çalıştırma

**purrr**[section](#iter_purrr) bölümünde, listeleri - `lists` oluşturma ve işlemeye ilişkin birkaç örnek de sunacağız.



## Hazırlık {  }
     
     
### Paketleri yükleme {.unnumbered}  

Bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekli olursa paketi kuran *ve* kullanım için yükleyen **pacman**'ın  `p_load()` fonksiyonunu vurguluyoruz. Ayrıca, R tabanından `library()` ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] sayfasına bakın.  

```{r}
pacman::p_load(
     rio,         # içe/dışa aktarma
     here,        # dosya bulucu
     purrr,       # yineleme
     tidyverse    # veri yönetimi ve görselleştirme
)
```


### Verileri içe aktarma {.unnumbered}  

Simüle edilmiş bir Ebola salgınından vakaların veri setini içe aktarıyoruz. Devam etmek isterseniz, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>“temiz” satır listesini indirmek için tıklayın</a> (.rds dosyası olarak). Verileri **rio** paketinden `import()` fonksiyonuyla içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe ve Dışa Aktarma] sayfasına bakın). 

```{r, echo=F}
# satır listesini içe aktar
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# satır listesini içe aktar
linelist <- import("linelist_cleaned.rds")
```

Çizgi listesinin ilk 50 satırı aşağıda görüntülenir.


```{r, message=FALSE, echo=F}
# satır listesini tablo olarak göster
DT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```



<!-- ======================================================= -->

## *for döngüleri* {  }

### R'daki for döngüleri* {#iter_loops .unnumbered}  

*for döngüleri* R'de vurgulanmaz, ancak diğer programlama dillerinde yaygındır. Yeni başlayan olarak, "keşfetmek"te , "hata ayıklamak"ta daha kolay oldukları için öğrenmek ve pratik yapmak için yardımcı olabilirler ve aksi takdirde, özellikle kendi işlevlerinizi yazarken henüz rahat değilseniz, her yinelemenin tam olarak ne olduğunu anlamalısınız.

**purrr** ile eşlenmiş işlevlerle yinelemek için *for döngüleri* sayesinde hızla ilerleyebilirsiniz ([aşağıdaki bölüme bakın](#iter_purrr)).


### Temel bileşenler {.unnumbered}   

Bir *for döngüsünün* üç temel parçası vardır: 
     
1) Yinelenecek öğelerin **sırası**  
2) Sıradaki her öğe başına yapılacak **işlemler** 
3) Sonuçlar için **kapsayıcı** (isteğe bağlı)  

Temel sözdizimi şudur: `for (sıradaki öğe) {öğeyi kullanarak işlemler yapın}`. Parantezlere ve küme parantezlerine dikkat edin. Sonuçlar konsola yazdırılabilir veya bir kapsayıcı R nesnesinde saklanabilir.

Basit bir *for döngüsü* örneği aşağıdadır.   

```{r}
for (num in c(1,2,3,4,5)) {  # SIRA tanımlanır (1'den 5'e kadar sayılar) ve "{" ile döngü açılır
  print(num + 2)             # İŞLEMLER (her sıra numarasına iki tane ekleyin ve yazdırın)
}                            # Döngü "}" ile kapatılır                          
                             # Bu örnekte "kapsayıcı" yok
```



### Sıralama {.unnumbered}  

Bu, *for döngüsünün* "for" kısmıdır - işlemler dizideki her öğe için "for" çalışır. Sıra, bir dizi değer (ör. yetki alanlarının adları, hastalıklar, sütun adları, liste öğeleri, vb.) olabilir veya bir dizi ardışık sayı (ör. 1,2,3,4,5) olabilir. Her yaklaşımın aşağıda açıklanan kendi araçları vardır. 

Bir dizi ifadesinin temel yapısı `vektördeki öğedir`.  

* “Öğe” yerine herhangi bir karakter veya kelime yazabilirsiniz (örn. “i”, “num”, “hosp”, “bölge” vb.). Bu "öğenin" değeri, vektördeki her değerden geçerek döngünün her yinelemesinde değişir. 
* *Vektör*, karakter değerleri, sütun adları veya belki bir dizi sayı olabilir - bunlar her yinelemede değişecek olan değerlerdir. Bunları “item” terimini kullanarak *for döngüsü* işlemleri içinde kullanabilirsiniz.  

**Örnek: karakter değerleri dizisi**  

Bu örnekte, hastane adlarının önceden tanımlanmış bir karakter vektöründeki her bir değer için bir döngü gerçekleştirilir.

```{r}
# hastane isimlerinin vektörünü yap
hospital_names <- unique(linelist$hospital)
hospital_names # yazdır
```

Hastane_adı - `hospital_names` vektöründen değerleri temsil etmek için `hosp` terimini seçtik. Döngünün ilk yinelemesi için, hosp değeri hastane_adı - `hospital_names[[1]]` olacaktır. İkinci döngü için hastane_adı - `hospital_names[[2]]` olacaktır. Ve bunun gibi… 

```{r, eval=F}
# karakter sıralı bir 'for döngüsü'

for (hosp in hospital_names){       # sıra
  
       # İŞLEMLER BURAYA YAZILIR
  }
```

**Örnek: sütun adları dizisi**  
     
Bu, mevcut bir R nesnesinin adlarının çıkarıldığı ve vektör haline geldiği, yukarıdaki karakter dizisinin bir varyasyonudur. Örneğin, bir veri çerçevesinin sütun adları. Uygun bir şekilde, *for döngüsünün* işlem kodunda, sütun adları orijinal veri çerçevelerini *indekslemek* (alt kümeler) için kullanılabilir.

Aşağıda sıra, `satır listesi` veri çerçevesinin adları - `names()` (sütun adları) şeklindedir. "Öğe" adımız, döngüler ilerledikçe her sütun adını temsil edecek olan `col`'dur.

Örnek olarak, dizideki her değer için çalıştırılan *for döngüsünün* içine işlem kodunu ekledik. Bu kodda, sıra değerleri (sütun adları), her seferinde bir `satır listesini` *indekslemek* (alt küme) için kullanılır. R temelleri sayfasında öğretildiği gibi, alt küme için çift köşeli ayraçlar `[[ ]]` kullanılır. Elde edilen sütun `is.na()` öğesine, ardından sütunda eksik olan değerlerin sayısını üretmek için `sum()` öğesine iletilir. Sonuç konsola yazdırılır - her sütun için bir sayı.

Sütun adlarıyla indeksleme hakkında bir not - sütunun kendisine atıfta bulunurken *sadece “col” yazmayın!* col sadece karakter sütun adını temsil eder! Tüm sütuna başvurmak için, sütun adını `linelist[[col]]` aracılığıyla `satır listesinde` bir *dizin* olarak kullanmalısınız.

```{r}
for (col in names(linelist)){        # satır listesindeki her sütun için döngü çalışır; "col" ile temsil edilen sütun adı
  
  # Örnek işlem kodu - sütundaki eksik değerlerin sayısını yazdır
  print(sum(is.na(linelist[[col]])))  # sıra listesi, "col" öğesinin geçerli değeriyle indekslenir
     
}
```



**Sayıların dizisi**

Bu yaklaşımda, dizi ardışık sayılar dizisidir. Bu nedenle, "öğe"nin değeri bir karakter değeri değil (ör. "Merkez Hastane" veya "tarih_başlangıç") bir sayıdır. Bu, veri çerçevesini *satır numarası*na göre indekslemek için *for döngüsü* içindeki "öğe" numarasını kullanabileceğiniz için veri çerçeveleri arasında döngü yapmak için kullanışlıdır.

Örneğin, veri çerçevenizdeki her satırda döngü yapmak ve belirli bilgileri çıkarmak istediğinizi varsayalım. "Öğeleriniz" sayısal satır numaraları olacaktır. Çoğu zaman, bu durumda “öğeler” `i` olarak yazılır.

*For döngüsü* işlemi, "veri çerçevemdeki 1'den toplam satır sayısına kadar bir sayı dizisindeki her öğe için X yap" şeklinde açıklanabilir. Döngünün ilk yinelemesi için “item” `i` değeri 1 olur. İkinci yineleme için `i` 2 olur, vb.

Sıra kodda şöyle görünür: `for (i in 1:nrow(linelist)) {OPERATIONS CODE}` burada `i` "öğeyi" temsil eder ve `1:nrow(linelist)` 1'den `satır listesindeki` satır sayısına kadar ardışık sayılar dizisi üretir.


```{r, eval=F}
for (i in 1:nrow(linelist)) {  # bir veri çerçevesinde kullan
  # İŞLEMLER BURAYA YAZILIR
}  
```

Dizinin sayı olmasını istiyorsanız, ancak bir vektörden başlıyorsanız (bir veri çerçevesi değil), vektördeki her bir öğeki bir sayı dizisini döndürmek için `seq_along()` kısayolunu kullanın. Örneğin, `for (i in seq_along(hospital_names) {OPERATIONS CODE}`.

Aşağıdaki kod aslında kendi döngülerinde `i`'nin değeri olacak olan sayıları döndürür.    

```{r}
seq_along(hospital_names)  # adlandırılmış bir vektör üzerinde kullan
```

Dizide sayıları kullanmanın bir avantajı, döngü çıktılarını depolayan bir *kapsayıcıyı* indekslemek için `i` numarasını kullanmanın da kolay olmasıdır. Aşağıdaki İşlemler bölümünde bunun bir örneği var.

### Operasyonlar  {.unnumbered}  

Bu, *for döngüsünün* küme parantezleri `{ }`  içindeki koddur. Bu kodun *sıradaki* her "öğe" için çalışmasını istiyorsunuz. Bu nedenle, kodunuzun “öğe” ile değişen her parçasının gerçekten değişeceği şekilde doğru kodlanmış olmasına dikkat edin! Örneğin, indeksleme için `[[ ]]` kullanmayı unutmayın.

Aşağıdaki örnekte, `satır listesindeki` her bir satırı yineliyoruz. Her satırın cinsiyet - `gender` ve yaş - `age` değerleri birbirine yapıştırılır ve `cases_demographics` kapsayıcı karakter vektöründe saklanır. Döngü çıktısını “kapsayıcı” vektöründe doğru konuma kaydetmek için indekslemeyi `[[i]]` nasıl kullandığımıza dikkat edin.

```{r}
# sonuçları depolamak için kapsayıcı oluştur - bir karakter vektörü
cases_demographics <- vector(mode = "character", length = nrow(linelist))

# for döngüsü
for (i in 1:nrow(linelist)){
  
  # OPERASYONLAR
  # indeksleme için parantez kullanarak satır i için satır listesinden değerleri ayıkla
  row_gender  <- linelist$gender[[i]]
  row_age     <- linelist$age_years[[i]]    # indekslemeyi unutmayın!
     
  # cinsiyet-yaşı birleştirin ve indekslenmiş konumda kapsayıcı vektöründe sakla
  cases_demographics[[i]] <- str_c(row_gender, row_age, sep = ",") 

}  # döngü sonu


# kapsayıcının ilk 10 satırını göster
head(cases_demographics, 10)
```


### Kapsayıcı {.unnumbered}

Bazen *for döngüsünün* sonuçları konsola veya RStudio Plots bölmesine yazdırılır. Diğer zamanlarda, çıktıları daha sonra kullanmak üzere bir “kapsayıcı”da saklamak isteyeceksiniz. Böyle bir kapsayıcı, bir vektör, bir veri çerçevesi ve hatta bir liste olabilir.

*For döngüsüne* başlamadan *önce* bile sonuçlar için kapsayıcı oluşturmak en verimli yöntemdir. Pratikte bu, boş bir vektör, veri çerçevesi veya liste oluşturmak anlamına gelir. Bunlar, vektörler veya listeler için `vector()` işlevleriyle veya bir veri çerçevesi için `matrix()` ve `data.frame()` işlevleriyle oluşturulabilir.

**Boş vektör**  

`vector()`'u kullanın ve ekleyeceğiniz nesnelerin beklenen sınıfına göre `mode =` belirtin - "çift" (sayıları tutmak için), "karakter" veya "mantıksal". Ayrıca `length =` önceden ayarlamalısınız. Bu, *for döngüsü* dizinizin uzunluğu olmalıdır.

Her hastane için medyan kabul gecikmesini saklamak istediğinizi varsayalım. “Çift” kullanır ve uzunluğu beklenen çıktıların sayısı (veri setindeki benzersiz hastanelerin sayısı) olarak ayarlarsınız.

```{r}
delays <- vector(
  mode = "double",                            # numaraları kaydetmeyi bekliyoruz
  length = length(unique(linelist$hospital))) # veri setindeki benzersiz hastanelerin sayısı
```

**Boş veri çerçevesi**  
     
Bunun gibi satır ve sütun sayısını belirterek boş bir veri çerçevesi oluşturabilirsiniz:
     
```{r, eval=F}
delays <- data.frame(matrix(ncol = 2, nrow = 3))
```


**Boş liste**  
     
Bir *for döngüsü* tarafından oluşturulan bazı grafikleri bir listede saklamak isteyebilirsiniz. Liste vektör gibidir, ancak içinde farklı sınıflardan olabilen diğer R nesnelerini içerir. Listedeki öğeler tek bir sayı, bir veri çerçevesi, bir vektör ve hatta başka bir liste olabilir.  

Aslında yukarıdakiyle aynı `vector()` komutunu kullanarak, ancak  `mode = "list"` ile boş bir liste başlatıyorsunuz. Uzunluğu istediğiniz gibi belirtin.

```{r, eval=F}
plots <- vector(mode = "list", length = 16)
```




### Yazdırma {.unnumbered}  

Bir *for döngüsü* içinden yazdırmak için büyük olasılıkla `print()` işleviyle açıkça sarmanız gerekeceğini unutmayın.

Aşağıdaki bu örnekte dizi, hastane tarafından satır listesinin alt kümesi için kullanılan açık bir karakter vektörüdür. Sonuçlar bir kapsayıcıda saklanmaz, bunun yerine `print()` işleviyle konsola yazdırılır.    

```{r}
for (hosp in hospital_names){ 
     hospital_cases <- linelist %>% filter(hospital == hosp)
     print(nrow(hospital_cases))
}
```


### For döngüsünü test etme {.unnumbered}

Döngünüzü test etmek için, `i <- 10` veya `hosp <- "Central Hospital"` gibi "öğe"nin geçici bir atamasını yapmak için bir komut çalıştırabilirsiniz. Bunu *döngünün dışında* yapın ve ardından beklenen sonuçların üretilip üretilmediğini görmek için yalnızca işlem kodunuzu (kıvrımlı parantez içindeki kod) çalıştırın.



### Döngü grafikleri {.unnumbered}

Üç bileşeni (kapsayıcı, sıralama ve operasyonlar) bir araya getirmek için her hastane için bir epi eğrisi çizmeye çalışalım ([Salgın eğrileri] sayfasına bakın).

Aşağıdaki gibi **incidence2** paketini kullanarak *tüm* vakaların cinsiyete göre güzel bir epik eğrisini yapabiliriz: 

```{r, warning=F, message=F}
# 'insidans' nesnesi oluşturun
outbreak <- incidence2::incidence(   
     x = linelist,                   # dataframe - tam satır listesi
     date_index = date_onset,        # tarih sütunu
     interval = "week",              # haftalık toplu sayımlar
     groups = gender,                # cinsiyete göre grup değerleri
     na_as_group = TRUE)             # eksik cinsiyet ayrı bir gruptur

# plot epi eğrisi
plot(outbreak,                       # olay nesnesinin adı
     fill = "gender",                # cinsiyete göre renk çubukları
     color = "black",                # çubukların anahat rengi
     title = "Outbreak of ALL cases" # başlık
     )
```

Her hastanenin vakası için ayrı bir grafik oluşturmak için bu epi eğri kodunu bir *for döngüsüne* koyabiliriz.

İlk olarak, benzersiz hastane adlarının adlandırılmış bir vektörünü, `hospital_names` olarak kaydederiz. *for döngüsü* şu adların her biri için bir kez çalışacaktır: `for (hosp in hospital_names)`. *for döngüsünün* her yinelemesinde, vektörden gelen mevcut hastane adı, döngü içinde kullanım için `hosp` olarak temsil edilecektir.

Döngü işlemleri içinde, normal olarak R kodunu yazabilirsiniz, ancak değerinin değişeceğini bilerek “öğe”yi (bu durumda `hosp`) kullanın. Bu döngü içinde: 
     
* Satır listesine bir `filter()` uygulanır, öyle ki hastane - `hospital` sütunu,  `hosp`'un mevcut değerine eşit olmalıdır.
* İnsidans nesnesi, filtrelenmiş satır listesinde oluşturulur.
* Mevcut hastane için grafik, `hosp` kullanan otomatik ayarlı bir başlıkla oluşturulur.
* Mevcut hastane için grafik geçici olarak kaydedilir ve ardından yazdırılır.
* Döngü, daha sonra, `hospital_names` içindeki bir sonraki hastane ile tekrar etmek için ilerler 

```{r, out.width='50%', message = F}
# hastane isimlerinin vektörünü yapın
hospital_names <- unique(linelist$hospital)

# hospital_names deki her ad ("hosp") için epi eğrisini oluşturun ve yazdırın
for (hosp in hospital_names) {
     
     # mevcut hastaneye özgü olay nesnesi oluşturun
     outbreak_hosp <- incidence2::incidence(
          x = linelist %>% filter(hospital == hosp),   # satır listesi mevcut hastaneye göre filtrelenir
          date_index = date_onset,
          interval = "week", 
          groups = gender,
          na_as_group = TRUE
     )
     
     # Grafik oluşturun ve kaydedin. Başlık otomatik olarak mevcut hastaneye göre ayarlanır
     plot_hosp <- plot(
       outbreak_hosp,
       fill = "gender",
       color = "black",
       title = stringr::str_glue("Epidemic of cases admitted to {hosp}")
     )
     
     # mevcut hastane için grafik yazdırın
     print(plot_hosp)
     
} # hospital_names içindeki her hastane için çalıştırıldığında for döngüsünü sonlandırın 
```



### Bir döngünün ilerlemesini izleme {.unnumbered} 

Birçok yinelemeli bir döngü, dakikalarca hatta saatlerce çalışabilir. Bu nedenle, ilerlemeyi R konsoluna yazdırmak yararlı olabilir. Aşağıdaki `if` ifadesi, her 100. sayıyı yazdırmak için döngü fonksiyonlarının *içine* yerleştirilebilir. Döngünüzdeki "öğe" `i` olacak şekilde ayarlayın.

```{r, eval=F}
# her 100 yinelemede ilerlemeyi yazdırmak için kodlu döngü
for (i in seq_len(nrow(linelist))){

  # yazdırma ilerlemesi
  if(i %% 100==0){    # %% operatörü kalandır
    print(i)

}
```





<!-- ======================================================= -->
## **purrr** ve listeler {#iter_purrr}

Yinelemeli işlemlere başka bir yaklaşım da **purrr** paketidir - yineleme için **tidyverse** yaklaşımdır.

Aynı görevi birkaç kez yapmakla karşı karşıya kalırsanız, muhtemelen birçok girdide kullanabileceğiniz genelleştirilmiş bir çözüm oluşturmaya değer. Örneğin, birden fazla yetki alanları için grafikler oluşturmak veya birçok dosyayı içe aktarmak ve birleştirmek.

Ayrıca **purrr**'ın birkaç avantajı daha vardır - `%>%` tünelleriyle kullanabilirsiniz, *for döngülerine* kıyasla normalden daha iyi hataları ele alır ve sözdizimi oldukça temiz ve basittir! Bir *for döngüsü* kullanıyorsanız, muhtemelen **purrr** ile daha net ve özlü bir şekilde yapabilirsiniz!

**purrr**'ın *fonksiyonel programlama* aracı olduğunu unutmayın. Yani, yinelemeli olarak uygulanacak işlemler *fonksiyonlara* sarılır. Kendi işlevlerinizi nasıl yazacağınızı öğrenmek için [Yazma işlevleri] sayfasına bakın.

**purrr** ayrıca neredeyse tamamen *listeler* ve *vektörler* üzerine kuruludur - bu yüzden bunu o listenin/vektörün her bir öğesine bir işlev uygulamak olarak düşünün!
     
### Paketleri yükleme {.unnumbered}  

**purrr** **tidyverse**'in bir parçasıdır, bu nedenle ayrı bir paket kurmaya/yüklemeye gerek yoktur.

```{r}
pacman::p_load(
     rio,            # içe/dışa aktar
     here,           # ilgili dosya yolları
     tidyverse,      # mgt ve viz verisi
     writexl,        # Excel dosyasını birden çok sayfayla yaz
     readxl          # Excel'i birden çok sayfayla içe aktar
)
```


### `map()` {.unnumbered}  

**purrr**’un temel bir işlevi, sağladığınız bir listenin/vektörün her giriş öğesine bir işlevi "eşleyen" (uygulayan) `map()` işlevidir. 

Temel sözdizimi `map(.x = SEQUENCE, .f = FUNCTION, OTHER ARGUMENTS)`. Biraz daha ayrıntılı olarak:  
     
* `.x =`, `.f` işlevinin yinelemeli olarak uygulanacağı *girdilerdir* - ör. yetki alanları adları vektörü, veri çerçevesindeki sütunlar veya veri çerçeveleri listesi. 
* `.f =`, `.x` girişinin her bir öğesine uygulanacak *fonksiyondur* - zaten var olan `print()` gibi bir işlev veya tanımladığınız özel bir işlev olabilir. İşlev genellikle yaklaşık işaretinden sonra yazılır `~` (ayrıntılar aşağıdadır).

Sözdizimi hakkında birkaç not daha:  
     
* Fonksiyonun daha fazla argümana ihtiyacı yoksa, parantez ve yaklaşık işareti olmadan yazılabilir (ör. `.f = mean`). Her yineleme için aynı değerde olacak bağımsız değişkenler sağlamak için, bunları `map()` içinde ancak `.f =` bağımsız değişkeninin dışında sağlayın, örneğin `na.rm = T` içine `map(.x = my_list, .f = mean, na.rm=T)`.
* Bu yinelemenin `.x` değeri için yer tutucu olarak `.f =` fonksiyonu *içinde* `.x` (veya basitçe `.`) kullanabilirsiniz.
* Fonksiyon üzerinde daha fazla kontrole sahip olmak için yaklaşık sözdizimini (`~`) kullanın - fonksiyonu parantez içinde normal olarak yazın, örneğin: `map(.x = my_list, .f = ~mean(., na.rm = T))`. Bu söz dizimini özellikle bir bağımsız değişkenin değeri her yinelemeyi değiştirecekse veya `.x` değerinin kendisiyse kullanın (aşağıdaki örneklere bakın)

**`map()` kullanımının çıktısı bir listedir** - liste, vektör gibi bir nesne sınıfıdır, ancak öğeleri farklı sınıflardan olabilir. Bu nedenle, `map()` tarafından üretilen bir liste birçok veri çerçevesi veya birçok vektör, birçok tek değer ve hatta birçok liste içerebilir! Aşağıda açıklanan ve diğer çıktı türlerini üreten alternatif `map()` sürümleri vardır (örneğin, bir veri çerçevesi oluşturmak için `.map_dfr()`, karakter vektörleri üretmek için `map_chr()` ve sayısal vektörler üretmek için `map_dbl()`).

#### Örnek - Excel sayfalarını içe aktarın ve birleştirin {#iter_combined .unnumbered}  

**Yaygın bir epidemiyolog göreviyle gösterelim:** - *aka verileri içeren bir Excel çalışma kitabını içe aktarmak istiyorsunuz, ancak veriler çalışma kitabındaki farklı adlandırılmış sayfalara bölünüyor. Sayfaları tek bir veri çerçevesinde nasıl verimli bir şekilde içe aktarır ve birleştirirsiniz?*  

Diyelim ki aşağıdaki Excel çalışma kitabı bize gönderildi. Her sayfa belirli bir hastaneden vakaları içerir. 

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "hospital_linelists_excel_sheets.png"))
```

İşte `map()` kullanan bir yaklaşım:  
     
1) `map()` `import()` işlevi, böylece her Excel sayfası için çalışır 
2) `bind_rows()` kullanarak içe aktarılan veri çerçevelerini bir araya getirin
3) Yol boyunca, her satır için orijinal sayfa adını koruyarak bu bilgiyi son veri çerçevesinde yeni bir sütunda saklayın 

İlk olarak, sayfa adlarını çıkarmamız ve kaydetmemiz gerekiyor. Excel çalışma kitabının dosya yolunu, sayfa adlarını ayıklayan **readxl** paketinden `excel_sheets()` işlevine sağlıyoruz. Bunları `sheet_names` adlı bir karakter vektöründe saklarız.

```{r, echo=F}
sheet_names <- readxl::excel_sheets(here::here("data", "example", "hospital_linelists.xlsx"))

```

```{r, eval=F}
sheet_names <- readxl::excel_sheets("hospital_linelists.xlsx")
```

İşte isimler:  

```{r}
sheet_names
```

Artık bu ad vektörüne sahip olduğumuza göre, `map()` bunları import()işlevine birer birer sağlayabilir. Bu örnekte `sheet_names`, `.x`  ve `import()` `.f` işlevidir.

İçe aktarma ve dışa aktarma sayfasından, Excel çalışma kitaplarında kullanıldığında `import()` öğesinin içe aktarılacak sayfayı belirten `which =` bağımsız değişkeni kabul edebileceğini hatırlayın.`.f` fonksiyonu `import()` içinde, sheet_names vektörü aracılığıyla değeri her yinelemede değişecek olan `which = .x`'i sağlarız - önce “Merkez Hastane”, ardından “Askeri Hastane” vb.

Not - `map()` kullandığımız için, her Excel sayfasındaki veriler bir liste içinde ayrı bir veri çerçevesi olarak kaydedilecektir. Bu liste öğelerinin (veri çerçevelerinin) her birinin bir *ada* sahip olmasını istiyoruz, bu nedenle `sheet_names` `map()`'e aktarmadan önce onu `set_names()` aracılığıyla **purrr**'dan geçiririz, bu da her liste öğesinin uygun adı almasını sağlar.

Çıktı listesini `combined` olarak kaydediyoruz.

```{r, echo=F}
combined <- sheet_names %>% 
  purrr::set_names() %>% 
  map(.f = ~import(here::here("data", "example", "hospital_linelists.xlsx"), which = .x))
```

```{r, eval=F}
combined <- sheet_names %>% 
  purrr::set_names() %>% 
  map(.f = ~import("hospital_linelists.xlsx", which = .x))
```

Çıktıyı incelediğimizde, her bir Excel sayfasındaki verilerin bir adla listeye kaydedildiğini görüyoruz. Bu iyi, ama tam olarak bitirmedik.  


```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "sheets_as_list.png"))
```

Son olarak, benzer şekilde yapılandırılmış veri çerçevelerinin listesini kabul eden ve bunları tek bir veri çerçevesinde birleştiren `bind_rows()` (**dplyr**'den) işlevini kullanıyoruz. Liste öğesi adlarından yeni bir sütun oluşturmak için, `.id =` bağımsız değişkenini kullanırız ve ona yeni sütun için istenen *adı* veririz.

Tüm komut dizisi aşağıdadır:  

```{r, echo=F}
sheet_names <- readxl::excel_sheets(here::here("data", "example", "hospital_linelists.xlsx"))

combined <- sheet_names %>% 
  purrr::set_names() %>% 
  map(.f = ~import(here::here("data", "example", "hospital_linelists.xlsx"), which = .x)) %>% 
  bind_rows(.id = "origin_sheet")
```


```{r, eval=F}
sheet_names <- readxl::excel_sheets("hospital_linelists.xlsx")  # extract sheet names
 
combined <- sheet_names %>%                                     # begin with sheet names
  purrr::set_names() %>%                                        # set their names
  map(.f = ~import("hospital_linelists.xlsx", which = .x)) %>%  # iterate, import, save in list
  bind_rows(.id = "origin_sheet") # combine list of data frames, preserving origin in new column  
```

Ve şimdi, orijin sayfasını içeren bir sütuna sahip bir veri çerçevemiz var!

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "sheets_as_df.png"))
```

Bilmeniz gereken `map()` varyasyonları vardır. Örneğin, `map_dfr()` bir liste değil, bir veri çerçevesi döndürür. Böylece yukarıdaki görev için kullanabilirdik ve satırları bağlamak zorunda kalmazdık. Ama o zaman her vakanın hangi sayfadan (hastaneden) geldiğini yakalayamazdık.

Diğer varyasyonlar arasında `map_chr()`, `map_dbl()` bulunur. Bunlar iki nedenden dolayı çok faydalı işlevlerdir. İlk önce. yinelemeli bir işlevin çıktısını otomatik olarak bir vektöre (listeye değil) dönüştürürler. İkincisi, verilerin geri geldiği sınıfı açıkça kontrol edebilirler - verilerinizin `map_chr()` ile bir karakter vektörü veya `map_dbl()` ile sayısal vektör olarak geri gelmesini sağlarsınız. Bölümde daha sonra bunlara dönelim!

`map_at()` ve `map_if()` işlevleri yineleme için de çok kullanışlıdır - bir listenin hangi öğelerini yinelemeniz gerektiğini belirlemenize izin verirler! Bunlar basitçe bir dizin/ad vektörü (`map_at()` durumunda) veya mantıksal bir test (`map_if()` durumunda) uygulayarak çalışır.
 
Hastane verilerinin ilk sayfasını okumak istemediğimiz bir örnek kullanalım. `map()` yerine `map_at()` kullanırız ve `.at =` bağımsız değişkeni `c(-1)` olarak belirtiriz, bu da `.x`'in ilk öğesini *kullanılmaması* anlamına gelir. Alternatif olarak, hangi öğelerin kullanılacağını belirtmek için, `.at =` için, bir pozitif sayı veya ad vektörü sağlayabilirsiniz. 

```{r, echo=F}
sheet_names <- readxl::excel_sheets(here::here("data", "example", "hospital_linelists.xlsx"))

combined <- sheet_names %>% 
     purrr::set_names() %>% 
     # ilk sayfayı hariç tut
     map_at(.f = ~import(here::here("data", "example", "hospital_linelists.xlsx"), which = .x),
            .at = c(-1))
```


```{r, eval=F}
sheet_names <- readxl::excel_sheets("hospital_linelists.xlsx")

combined <- sheet_names %>% 
     purrr::set_names() %>% 
     # ilk sayfayı hariç tut
     map_at(.f = ~import( "hospital_linelists.xlsx", which = .x),
            .at = c(-1))
```

İlk sayfa adının yine de çıktı listesinin bir öğesi olarak görüneceğini unutmayın - ancak bu yalnızca tek bir karakter adıdır (veri çerçevesi değil). Satırları bağlamadan önce bu öğeyi kaldırmanız gerekir. Liste öğelerinin nasıl kaldırılacağını ve değiştirileceğini daha sonraki bir bölümde ele alacağız.  


### Veri kümesini bölme ve dışa aktarma {.unnumbered}  

Aşağıda, bir veri kümesinin parçalara nasıl bölüneceğine ve ardından her bir parçayı ayrı bir Excel sayfası veya ayrı bir CSV dosyası olarak dışa aktarmak için `map()` yinelemesinin nasıl kullanılacağına ilişkin bir örnek veriyoruz.  

#### Bölünmüş veri seti {.unnumbered}  

Veri çerçevesi olarak tam vaka `satır listesine` sahip olduğumuzu ve şimdi her hastane için ayrı bir satır listesi oluşturmak ve her birini ayrı bir CSV dosyası olarak dışa aktarmak istediğimizi varsayalım. Aşağıda, izleyen adımları yapıyoruz:

`hospital` sütunundaki benzersiz değerlere göre `satır listesi` veri çerçevesini bölmek için `group_split()` (**dplyr**'den) kullanın. Çıktı, her hastane alt kümesi başına bir veri çerçevesi içeren bir listedir.

```{r}
linelist_split <- linelist %>% 
     group_split(hospital)
```

`View(linelist_split)` çalıştırabilir ve bu listenin her birinin bir hastaneden vakaları temsil eden 6 veri çerçevesi (“tibbles”) içerdiğini görebiliriz.

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "purrr_linelist_split.png"))
```

Ancak, listedeki veri çerçevelerinin varsayılan olarak adları olmadığını unutmayın! Her birinin bir adı olmasını ve ardından CSV dosyasını kaydederken bu adı kullanmasını istiyoruz.  

Adları çıkarmaya yönelik bir yaklaşım, listedeki her veri çerçevesinden hospital sütununu çıkarmak için  `pull()` (**dplyr**'den) kullanmaktır. Ardından, güvende olmak için değerleri karaktere dönüştürürüz ve ardından o belirli veri çerçevesinin adını almak için `unique()` işlevini kullanırız. Bu adımların tümü, her veri çerçevesine `map()` aracılığıyla uygulanır.

```{r}
names(linelist_split) <- linelist_split %>%   # Assign to names of listed data frames 
     # Extract the names by doing the following to each data frame: 
     map(.f = ~pull(.x, hospital)) %>%        # Pull out hospital column
     map(.f = ~as.character(.x)) %>%          # Convert to character, just in case
     map(.f = ~unique(.x))                    # Take the unique hospital name
```

Artık liste öğelerinin her birinin bir adı olduğunu görebiliriz. Bu isimlere `names(linelist_split)` üzerinden erişilebilir.

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "purrr_linelist_split_named.png"))
```

```{r}
names(linelist_split)
```


##### Birden fazla `group_split()` sütunu {.unnumbered}  

Hastane VE cinsiyetin kesişimine göre alt küme satır listesi üretmek gibi, satır listesini *birden fazla gruplama sütununa* bölmek istiyorsanız, liste öğelerini adlandırmak için farklı bir yaklaşıma ihtiyacınız olacaktır. Bu, **dplyr**'den `group_keys()` kullanarak benzersiz "grup anahtarları"nın toplanmasını içerir - bunlar bir veri çerçevesine döndürülür. Ardından, aşağıda gösterildiği gibi `unite()` ile grup anahtarlarını değerler halinde birleştirebilir ve bu grup adlarını `linelist_split`'e atayabilirsiniz.

```{r}
# benzersiz hastane-cinsiyet kombinasyonlarına göre bölünmüş satır listesi
linelist_split <- linelist %>% 
     group_split(hospital, gender)

# group_keys() öğesini bir veri çerçevesi olarak çıkar
groupings <- linelist %>% 
     group_by(hospital, gender) %>%       
     group_keys()

groupings      # benzersiz gruplamaları göster 
```

Şimdi, tire ile ayrılmış gruplamaları bir araya getiriyoruz ve bunları `linelist_split`'te liste elemanlarının adları olarak atadık. NA'yı "Eksik" ile değiştirdiğimiz için bu, bazı ekstra satırlar alır, sütun değerlerini birleştirmek için **dplyr**'den `unite()` kullanın (tire ile ayrılmış), ve sonra linelist_split adları olarak kullanılabilmesi için adsız bir vektöre dönüştürün.

```{r, eval=F}
# Tek bir ad değerinde birleştir
names(linelist_split) <- groupings %>% 
     mutate(across(everything(), replace_na, "Missing")) %>%  # tüm sütunlarda NA'yı "Eksik" ile değiştir
     unite("combined", sep = "-") %>%                         # Tüm sütun değerlerini tek bir sütunda birleştir
     setNames(NULL) %>% 
     as_vector() %>% 
     as.list()
```



#### Excel sayfaları olarak dışa aktar {.unnumbered}  

Hastane satır listelerini, *sayfa başına bir satır listesi ile bir Excel çalışma kitabı olacak şekilde* dışa aktarmak için, `writexl` paketinden `write_xlsx()` işlevine yalnızca `linelist_split` adlı listeyi sağlayabiliriz. Bu, birden çok sayfa içeren bir Excel çalışma kitabını kaydetme özelliğine sahiptir. Liste öğesi adları, sayfa adları olarak otomatik olarak uygulanır.

```{r, eval=F}
linelist_split %>% 
     writexl::write_xlsx(path = here("data", "hospital_linelists.xlsx"))
```

Artık Excel dosyasını açıp her hastanenin kendi sayfası olduğunu görebilirsiniz.

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "purrr_export_sheets.png"))
```

#### Export as CSV files {.unnumbered}  

Bu biraz daha karmaşık bir komuttur, ancak hastaneye özel her bir satır listesini hastaneye özel bir dosya adıyla ayrı bir CSV dosyası olarak da dışa aktarabilirsiniz.

Yine `map()` kullanıyoruz: liste öğesi adlarının (yukarıda gösterilen) vektörünü alıyoruz ve bunlar arasında yineleme yapmak için `map()` kullanıyoruz, bu adı taşıyan `linelist_split` listesindeki veri çerçevesine `export()` (**rio** paketinden, [İçe ve dışa aktarma] sayfasına bakın) uyguluyoruz. Adı benzersiz bir dosya adı oluşturmak için de kullanırız. İşte nasıl çalıştığı:

* `map()`'e `.x` olarak iletilen karakter adlarının vektörüyle başlıyoruz.
* `.f` fonksiyonu, bir veri çerçevesi ve yazmak için bir dosya yolu gerektiren `export()` işlevidir. 
* `.x` girişi (hastane adı), `linelist_split` listesinin o belirli öğesini çıkarmak/indekslemek için `.f` *içinde* kullanılır. Bu, `export()` işlevine aynı anda yalnızca bir veri çerçevesinin sağlanmasıyla sonuçlanır.
* Örneğin, `map()` “Askeri Hastane” için yinelendiğinde, `linelist_split[[.x]]` aslında `linelist_split[["Military Hospital"]]` olur, bu nedenle `linelist_split` öğesinin ikinci öğesini döndürür - ki bu, Askeri Hastanedeki tüm vakalardır.
* `export()` için sağlanan dosya yolu, `str_glue()` kullanımı yoluyla dinamiktir (bkz. Karakterler ve dizeler sayfası):
  * `here()` dosya yolunun temelini almak ve “data” klasörünü belirtmek için kullanılır (`str_glue()` çift tırnak işaretini kesmemek için tek tırnak işaretlerini not edin)
* Ardından bir eğik çizgi `/` ve ardından tekrar dosyanın tanımlanabilmesi için mevcut hastane adını yazdıran` .x`
* Son olarak, `export()` öğesinin bir CSV dosyası oluşturmak için kullandığı “.csv” uzantısı

```{r, eval=F, message = F, warning=F}
names(linelist_split) %>%
     map(.f = ~export(linelist_split[[.x]], file = str_glue("{here('data')}/{.x}.csv")))
```

Artık her dosyanın R Project “Epi_R_handbook” un “data” klasörüne kaydedildiğini görebilirsiniz!
     
```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "purrr_export_csv.png"))
```



### Özel işlevler {.unnumbered}  

`map()` sağlamak için kendi işlevinizi oluşturmak isteyebilirsiniz.

Her hastanenin vakası için salgın eğrileri oluşturmak istediğimizi varsayalım. Bunu **purrr** kullanarak yapmak için, `.f` işlevimiz her zamanki gibi `ggplot()` ve + ile uzantılar olabilir. `map()` çıktısı her zaman bir liste olduğundan, grafikler bir listede saklanır. Grafikler oldukları için, **ggpubr** paketinden `ggarrange()` fonksiyonuyla çıkarılabilir ve grafiklendirilebilir. ([dokümantasyon](https://rpkgs.datanovia.com/ggpubr/reference/ggarrange.html))


```{r, message = F, warning=F}

# listeden öğeleri grafiklendirebilmek için paketi yükle
pacman::p_load("ggpubr")

# 6 hastane "adlar"ının vektörü boyunca haritala (daha önce oluşturulmuş)
# belirtilen ggplot işlevini kullanın
# çıktı, 6 ggplot içeren bir listedir
hospital_names <- unique(linelist$hospital)

my_plots <- map(
  .x = hospital_names,
  .f = ~ggplot(data = linelist %>% filter(hospital == .x)) +
                geom_histogram(aes(x = date_onset)) +
                labs(title = .x)
)

# ggplot'ları yazdırın (bir listede saklanırlar)
ggarrange(plotlist = my_plots, ncol = 2, nrow = 3)
```

Bu `map()` kodu çok dağınık görünüyorsa, ilgili `ggplot()` komutunuzu özel bir kullanıcı tanımlı fonksiyon olarak kaydederek aynı sonucu elde edebilirsiniz, örneğin ona `make_epicurve()` adını verebiliriz. Bu işlev daha sonra `map()` içinde kullanılır. `.x` yinelemeli olarak hastane adıyla değiştirilecek ve `make_epicurve()` fonksiyonunda `hosp_name` olarak kullanılacaktır. Detaylar için [Yazma fonksiyonları] sayfasına bakın.

```{r, eval=F}
# Fonksiyon oluştur
make_epicurve <- function(hosp_name){
  
  ggplot(data = linelist %>% filter(hospital == hosp_name)) +
    geom_histogram(aes(x = date_onset)) +
    theme_classic()+
    labs(title = hosp_name)
  
}
```

```{r, eval=F}
# haritalama
my_plots <- map(hospital_names, ~make_epicurve(hosp_name = .x))

# ggplot'ları yazdırın (bir listede saklanırlar)
ggarrange(plotlist = my_plots, ncol = 2, nrow = 3)
```




### Sütunlar arasında bir fonksiyonu eşleme  {.unnumbered}  

Diğer bir yaygın kullanım durumu, bir işlevi birçok sütun arasında eşlemektir. Aşağıda, `t.test()` fonksiyonunu, sayısal değerleri cinsiyete göre karşılaştırarak, veri çerçevesi `satır listesindeki` sayısal sütunlar arasında eşliyoruz / `map()`.

[Basit istatistiksel testler] sayfasından `t.test()`’in `t.test(numeric column ~ binary column)` gibi bir formül biçiminde girdiler alabileceğini hatırlayın. Bu örnekte aşağıdakileri yapıyoruz:

* İlgilenilen sayısal sütunlar `satır listesinden` seçilir - bunlar `map()` için `.x` girdileri olur
* `t.test()` metodu, her sayısal sütuna uygulanan `.f` fonksiyonu olarak sağlanır
* `t.test()` parantezleri içinde:
  * ilk `~` , `map()`'in `.x` üzerinde yineleneceği `.f`'den önce gelir
  * `.x`,  `t.test()` işlevine sağlanan geçerli sütunu temsil eder
  * ikinci `~` yukarıda açıklanan t testi denkleminin bir parçasıdır
  * `t.test()` işlevi, denklemin sağ tarafında bir ikili sütun bekler. `linelist$gender` vektörünü bağımsız ve statik olarak sağlıyoruz (`select()`'e dahil edilmediğine dikkat edin). 

`map()` bir liste döndürür, bu nedenle çıktı t-test sonuçlarının bir listesidir - analiz edilen her sayısal sütun için bir liste öğesi. 

```{r}
# Sonuçlar bir liste olarak kaydedilir
t.test_results <- linelist %>% 
  select(age, wt_kg, ht_cm, ct_blood, temp) %>%  # eşlemek için yalnızca bazı sayısal sütunları saklayın
  map(.f = ~t.test(.x ~ linelist$gender))        # t.test fonksiyonu, SAYISAL ~ KATEGORİSEL denklemi ile
```

RStudio'da açıldığında (Görüntülendiğinde) `t.test_results` listesi şöyle görünür. Bu sayfadaki örnekler için önemli olan kısımları vurguladık.

* En üstte tüm listenin `t.test_results` olarak adlandırıldığını ve beş öğeye sahip olduğunu görebilirsiniz. Bu beş öğe, `linelist`‘den cinsiyet - `gender` ile bir t-testinde kullanılan her değişkenden sonra `age`, `wt_km`, `ht_cm`, `ct_blood`, `temp` olarak adlandırılır.
* Bu beş öğenin her biri, içinde `p.value` ve `conf.int` gibi öğeler bulunan listelerdir. `p.value` gibi bu öğelerden bazıları tek sayılardır, oysa tahmin - `estimate` gibi bazıları iki veya daha fazla öğeden oluşur (`f grubunda ortalama` ve `m grubunda ortalama`).

```{r, out.height="150%", echo=F}
knitr::include_graphics(here::here("images", "purrr_ttest.png"))
```

Not: Bir veri çerçevesindeki yalnızca belirli sütunlara bir işlev uygulamak istiyorsanız, [Verileri temizleme ve temel işlevler] sayfasında açıklandığı gibi `mutate()` ve `across()`'u da kullanabileceğinizi unutmayın. Aşağıda, yalnızca "yaş" sütunlarına `as.character()` uygulamasının bir örneği verilmiştir. Parantez ve virgüllerin yerleşimine dikkat edin.

```{r, eval=F}
# "yaş" içeren sütun adına sahip sütunları karakter sınıfına dönüştürün
linelist <- linelist %>% 
  mutate(across(.cols = contains("age"), .fns = as.character))  
```


### Listeden çıkarma {.unnumbered}  

`map()` List sınıfının bir çıktısını ürettiği için, eşlik eden **purrr** fonksiyonlarını kullanarak listelerden nasıl veri çıkarılacağını tartışmak için biraz zaman harcayacağız. Bunu göstermek için önceki bölümdeki `t.test_results` listesini kullanacağız. Bu 5 listeden oluşan bir listedir - 5 listenin her biri, `linelist` veri çerçevesinden bir sütun ile ikili sütun cinsiyeti - `gender` arasındaki bir t-testinin sonuçlarını içerir. Liste yapısının görseli için yukarıdaki bölümdeki resme bakın.

#### Elementlerin isimleri {.unnumbered}  

Öğelerin adlarını çıkarmak için, yalnızca **R tabanından** `names()` fonksiyonunu kullanın. Bu durumda, t-testleri gerçekleştirilen 5 değişkenin adları olan her bir alt listenin adını döndürmek için `t.test_results` üzerinde `names()` kullanırız.

```{r}
names(t.test_results)
```

#### Ada veya konuma göre öğeler {.unnumbered}  

Liste öğelerini ada veya konuma göre çıkarmak için, R temelleri sayfasında açıklandığı gibi köşeli ayraçları `[[ ]]` kullanabilirsiniz. Aşağıda, `t.tests_results` listesini indekslemek için çift parantez kullanıyoruz ve t-testinin yaşa - `age` göre sonuçları olan ilk öğeyi gösteriyoruz.  

```{r}
t.test_results[[1]] # pozisyona göre ilk eleman
t.test_results[[1]]["p.value"] # ilk öğeden "p.value" adlı öğeyi döndür 
```

Bununla birlikte, aşağıda aynı sonuçları elde etmek için basit ve esnek **purrr** fonksiyonları `map()` ve `pluck()` kullanımını göstereceğiz.

#### `pluck()` {.unnumbered}  

`pluck()`, elemanları ada veya konuma göre çeker. Örneğin - yaş için t testi sonuçlarını çıkarmak için `pluck()` işlevini şu şekilde kullanabilirsiniz:

```{r}
t.test_results %>% 
  pluck("age")        # alternatif olarak, pluck(1) kullanın
```

Diğer seviyeleri virgülle belirterek daha derin seviyeleri indeksleyin. Aşağıdaki, `t.test_results` listesindeki liste yaşından `age` “p.value” adlı öğeyi çıkarır. Karakter adları yerine sayıları da kullanabilirsiniz.

```{r}
t.test_results %>% 
  pluck("age", "p.value")
```

`pluck()` işlevini *her bir* birinci düzey öğede çalıştırmak için `map()` kullanarak tüm birinci düzey öğelerden bu tür iç öğeleri ayıklayabilirsiniz. Örneğin, aşağıdaki kod, `t.test_results` içindeki tüm listelerden "p.value" öğelerini çıkarır. t testi sonuçlarının listesi, yinelenen `.x`'dir, `pluck()` yinelenen `.f` fonksiyonudur ve fonksiyona "p-değeri" sağlar.

```{r}
t.test_results %>%
  map(pluck, "p.value")   # her p değerini döndür
```

Başka bir alternatif olarak, `map()`, eleman adını tırnak içinde yazabileceğiniz bir kestirme yol sunar ve onu çıkarır.  `map()` kullanırsanız çıktı bir liste olur, `map_chr()` kullanırsanız bu adlandırılmış bir karakter vektörü olur ve `map_dbl()` kullanırsanız bu adlandırılmış bir sayısal vektör olur.

```{r}
t.test_results %>% 
  map_dbl("p.value")   # p-değerlerini adlandırılmış bir sayısal vektör olarak döndür
```

**purrr** [belgelerinde](https://purrr.tidyverse.org/reference/pluck.html) `pluck()` hakkında daha fazla bilgi edinebilirsiniz. Bir öğe yoksa NULL yerine bir hata döndüren `chuck()` kardeş işlevine sahiptir.  



### Listeyi veri çerçevesine dönüştür {.unnumbered}  

Bu karmaşık bir konudur - daha eksiksiz öğreticiler için Kaynaklar bölümüne bakın. Yine de, t-testi sonuçlarının listesini bir veri çerçevesine dönüştürmeyi göstereceğiz. Değişken, p değeri ve iki gruptan (erkek ve kadın) ortalamalar için sütunlar içeren bir veri çerçevesi oluşturacağız.

Kullanılacak bazı yeni yaklaşımlar ve işlevler şunlardır:  

* `tibble()` fonksiyonu, bir tibble (veri çerçevesi gibi) oluşturmak için kullanılacaktır
  * Tüm `t.test_results`'un ilk tibble sütunu olarak depolanmasını önlemek için `tibble()` fonksiyonunu küme parantezleri `{ }` ile çevreliyoruz
* `tibble()` içinde her sütun, `mutate()` sözdizimine benzer şekilde açıkça oluşturulur:
  * `.`, `t.test_results`'u temsil eder
  * t-test değişken adlarıyla (her liste öğesinin adı) bir sütun oluşturmak için yukarıda açıklandığı gibi `names()`i kullanırız
  * p değerleriyle bir sütun oluşturmak için, `p.value` öğelerini çekmek ve bunları sayısal bir vektöre dönüştürmek için yukarıda açıklandığı gibi `map_dbl()` kullanırız

```{r}
t.test_results %>% {
  tibble(
    variables = names(.),
    p         = map_dbl(., "p.value"))
  }
```

Ama şimdi her grup için (erkekler ve kadınlar) ortalamaları içeren sütunlar ekleyelim.

Öğe tahminini/estimate çıkarmamız gerekir, ancak bu aslında içinde *iki* öğe içerir (`f grubunda ortalama` ve `m grubunda ortalama`). Bu nedenle, `map_chr()` veya `map_dbl()` ile bir vektöre basitleştirilemez. Bunun yerine, `tibble()` içinde kullanılan `map()` fonksiyonunu kullanıyoruz, bu *tibble içinde bir sınıf listesi sütunu yaratacaktır*! Evet, bu mümkün!

```{r}
t.test_results %>% 
  {tibble(
    variables = names(.),
    p = map_dbl(., "p.value"),
    means = map(., "estimate"))}
```

Bu liste sütununa sahip olduğunuzda, bu "iç içe liste" sütunlarını "dikdörtgenleştirmenize" veya "iç içeden çıkarmanıza" yardımcı olan birkaç **tidyr** fonksiyonu (**tidyverse**'nin bir parçası) vardır. Onlar hakkında daha fazla bilgiyi buradan veya `vignette("rectangle")` çalıştırarak okuyun. Kısaca: 

* `unnest_wider()` - bir liste sütununun her elemanına kendi sütununu verir
* `unnest_longer()` - bir liste sütununun her elemanına kendi satırını verir
* `hoist()` - `unnest_wider()` gibi davranır, ancak hangi öğelerin yuvalanacağını siz belirlersiniz

Aşağıda, tibble'ın ortalama - `means` sütununu (iç içe bir liste olan) belirterek tibble'ı `unnest_wider()` öğesine iletiyoruz. Sonuç, `ortalamaların` her biri daha önce her bir `means` hücresinde bulunan iki öğeyi yansıtan iki yeni sütunla değiştirilmesidir.  

```{r}
t.test_results %>% 
  {tibble(
    variables = names(.),
    p = map_dbl(., "p.value"),
    means = map(., "estimate")
    )} %>% 
  unnest_wider(means)
```



### Listeleri atma, saklama ve sıkıştırma {.unnumbered}  

**purrr** ile çalışmak genellikle listeler içerdiğinden, listeleri değiştirmek için bazı **purrr** fonksiyonlarını kısaca inceleyeceğiz. **purrr** fonksiyonlarıyla ilgili daha eksiksiz eğitimler için Kaynaklar bölümüne bakın.

* `list_modify()` birçok kullanıma sahiptir, bunlardan biri bir liste öğesini kaldırmak olabilir
* `keep()`,  `.p =` için belirtilen öğeleri veya `.p =` için sağlanan bir işlevin DOĞRU olarak değerlendirildiği yerde tutar
* `discard()`, `.p` için belirtilen öğeleri veya `.p =` için sağlanan bir işlevin DOĞRU olarak değerlendirildiği yerde  kaldırır 
* `compact()` tüm boş öğeleri kaldırır

[Birden çok dosyayı içe aktarmak ve birleştirmek](#iter_combined) için `map()` kullanımıyla ilgili yukarıdaki bölümde oluşturulan birleşik listeyi kullanan bazı örnekler (6 vaka sıra listesi veri çerçevesi içerir):

Öğeler, `list_modify()` ile adlarına göre ve adı `NULL`'a eşitlenerek kaldırılabilir.

```{r, eval=F}
combined %>% 
  list_modify("Central Hospital" = NULL)   # liste öğesini isme göre kaldır
```

Ayrıca, `.p =` (DOĞRU veya YANLIŞ olarak değerlendirilen bir denklem) için bir "yüklem" denklemi sağlayarak, ölçütlere göre öğeleri kaldırabilirsiniz. Fonksiyonun önüne bir tilde `~` yerleştirin ve liste öğesini temsil etmek için `.x` kullanın. `keep()` kullanılarak DOĞRU olarak değerlendirilen liste öğeleri tutulacaktır. Tersine, eğer `discard()` kullanılıyorsa, DOĞRU olarak değerlendirilen liste elemanları kaldırılacaktır.

```{r, eval=F}
# yalnızca 500'den fazla satır içeren liste öğelerini tut
combined %>% 
  keep(.p = ~nrow(.x) > 500)  
```

Aşağıdaki örnekte, sınıfları veri çerçeveleri değilse liste öğeleri atılır.

```{r, eval=F}
# Veri çerçevesi olmayan liste öğelerini at
combined %>% 
  discard(.p = ~class(.x) != "data.frame")
```

Yüklem işleviniz ayrıca her liste öğesindeki öğelere/sütunlara başvurabilir. Örneğin, aşağıda, `ct_blood` sütununun ortalamasının 25'in üzerinde olduğu liste öğeleri atılır.

```{r, eval=F}
# yalnızca ct_blood sütun ortalamasının 25'in üzerinde olduğu liste öğelerini tut
combined %>% 
  discard(.p = ~mean(.x$ct_blood) > 25)  
```

Bu komut, tüm boş liste öğelerini kaldırır:

```{r, eval=F}
# Tüm boş liste öğelerini kaldırın
combined %>% 
  compact()
```



### `pmap()` {.unnumbered}

BU BÖLÜM YAPIM AŞAMASINDADIR.



## Fonksiyonları uygulama  

“Uygula” fonksiyon ailesi, yinelemeli işlemler için **purrr**'a R tabanı alternatifidir. Onlar hakkında daha fazlasını [buradan](https://www.datacamp.com/community/tutorials/r-tutorial-apply-family) okuyabilirsiniz.





<!-- ======================================================= -->
## Kaynaklar { }

[Data Carpentry ile  for döngüleri](https://datacarpentry.org/semester-biology/materials/for-loops-R/)  

[Yinelemede Veri Bilimi için R sayfası](https://r4ds.had.co.nz/iteration.html#iteration)  

[Excel dosyaları yazma/okuma üzerine skeç](https://martinctc.github.io/blog/vignette-write-and-read-multiple-excel-files-with-purrr/)  

[jennybc tarafından bir purrr dersi](https://jennybc.github.io/purrr-tutorial/index.html) by jennybc 

[Rebecca Barter'dan bir başka purrr dersi](http://www.rebeccabarter.com/blog/2019-08-19_purrr/) by Rebecca Barter  

[map, pmap ve imap hakkında bir purrr eğitimi](http://zevross.com/blog/2019/06/11/the-power-of-three-purrr-poseful-iteration-in-r-with-map-pmap-and-imap/) on map, pmap, and imap  

[purrr hile sayfası](https://raw.githubusercontent.com/rstudio/cheatsheets/master/pngs/thumbnails/purrr-cheatsheet-thumbs.png)

[purrr ipuçları ve püf noktaları](https://www.emilhvitfeldt.com/post/2018-01-08-purrr-tips-and-tricks/)

[sakla ve at](https://hookedondata.org/going-off-the-map/#keep-and-discard)

```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/iteration.Rmd-->

# (PART) Analysis {.unnumbered}

```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/cat_analysis.Rmd-->

# Tanımlayıcı tablolar  { }

```{r out.width = c('75%'), fig.align='center', fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "descriptive_tables.png"))
```

Bu sayfa, verileri özetlemek ve tanımlayıcı istatistiklerle tablolar oluşturmak için **janitor, dplyr, gtsummary, rstatix ve temel R'ın** kullanımını göstermektedir. 

Bu sayfa, temel tabloların nasıl oluşturulacağını, sunum için tablolar sayfası ise tabloların nasıl güzel bir şekilde biçimlendirileceğini ve yazdırılacağını kapsar.

Bu paketlerin her birinin kod dilinin basitliği, çıktıların erişilebilirliği, basılı çıktıların kalitesi alanlarında avantajları ve dezavantajları vardır. Senaryonuz için hangi yaklaşımın işe yaradığına karar vermek için bu sayfayı kullanın.

Tablolama ve çapraz tablo özet tabloları için  birkaç seçeneğiniz vardır. Göz önünde bulundurulması gereken faktörlerden bazıları, kod basitliği, özelleştirilebilirlik, istenen çıktı (veri çerçevesi olarak veya "güzel" yani .png/.jpeg/.html görüntüsü olarak R konsoluna yazdırılabilir) ve çıktı sonrası işleme kolaylığıdır. Durumunuz için aracı seçerken aşağıdaki noktaları göz önünde bulundurun.

• Tabloları ve çapraz tabloları oluşturmak ve “süslemek” için janitor’dan **tabyl()** kullanın

• Birden çok sütun ve/veya grup için sayısal özet istatistiklerin veri çerçevelerini kolayca oluşturmak için rstatix'ten **get_summary_stats()** kullanın

• Daha karmaşık istatistikler, düzenli veri çerçevesi çıktıları veya ggplot() için veri hazırlamak için dplyr'den **summarise()** ve **count()** kullanın

• Ayrıntılı ve yayına hazır tablolar oluşturmak için gtsummary'den tbl_summary() kullanın
• Yukarıdaki paketlere erişiminiz yoksa, temel R'dan table() kullanın 



<!-- ======================================================= -->
## Hazırlık {  }


### Paketleri yükleme {.unnumbered}

Bu kod bloğu, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman'ın p_load() fonksiyonu vurgulanmaktadır. Ayrıca, temel R'dan library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R’ın temelleri sayfasına bakabilirsiniz.


```{r, warning=F, message=F}
pacman::p_load(
  rio,          # Dosya içeri aktarımı
  here,         # Dosyaların tespit edilmesi 
  skimr,        # Verinin gözden geçirilmesi 
  tidyverse,    # Veri yönetimi + ggplot2 grafikleri  
  gtsummary,    # Özet istatistikler ve testler
  rstatix,      # Özet istatistikler ve istatistik testler
  janitor,      # Toplamların ve yüzdelerin eklenmesi 
  scales,       # Yüzdelerin oranlara kolayca çevrilmesi 
  flextable     # Tabloların “güzel” resimlere dönüştürülmesi 
  )

```

### Verinin içeri aktarımı  {.unnumbered}

Simüle edilmiş bir Ebola salgını veri setini içe aktarıyoruz. Devam etmek istiyorsanız, “temiz” satır listesini (.rds dosyası olarak) indirmek için tıklayın <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>click to download the "clean" linelist</a> . Verilerinizi rio paketinden import() fonksiyonuyla içe aktarın (.xlsx, .rds, .csv gibi birçok dosya türünü kabul eder - ayrıntılar için İçe Aktarma ve Dışa Aktarma sayfasına bakın).

```{r, echo=F}
# satır listesini içe aktar
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# satır listesini içe aktar
linelist <- import("linelist_cleaned.rds")
```

The first 50 rows of the linelist are displayed below.

```{r, message=FALSE, echo=F}
# satır listesini tablo olarak göster
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```





<!-- ======================================================= -->
## Verileri gözden geçirme {  }

### **skimr** paketi {.unnumbered}

skimr paketini kullanarak, veri tabaınızdaki değişkenlerin her biri için ayrıntılı ve estetik bir genel bakış elde edebilirsiniz. github sayfasında [github](https://github.com/ropensci/skimr). **skimr** hakkında daha fazla bilgi edinin.

Aşağıda, 'skim()'fonksiyonu tüm satır listesi veri çerçevesine uygulanır. Veri çerçevesine genel bir bakış ve her sütunun (sınıfa göre) bir özeti çıkarılır.


```{r eval=F}
## veritabanındaki her değişken için bilgiyi edin 
skim(linelist)
```

```{r  echo=F}
# sparkline (mini grafik) histogramları doğru gösterilmiyor, bu yüzden onlardan kaçının.
skim_without_charts(linelist)
```


Tüm bir veri tabanı hakkında bilgi almak için temel R'dan summary() fonksiyonunu da kullanabilirsiniz, ancak bu çıktıyı okumak skimr çıktısından daha zor olabilir. Bu nedenle, sayfa sayısından tasarruf etmek için çıktı aşağıda gösterilmemiştir.

```{r, eval=F}
## veritabanındaki her sütun için bilgiyi edin  
summary(linelist)
```


### Özet İstatistikleri {.unnumbered} 

Sayısal bir sütunda özet istatistikleri göstermek için temel R işlevlerini kullanabilirsiniz. Bir sayısal sütun için yararlı özet istatistiklerin çoğunu aşağıdaki gibi summary() kullanarak elde edebilirsiniz. Veri çerçevesi adının da aşağıda gösterildiği gibi belirtilmesi gerektiğini unutmayın.  

```{r}
summary(linelist$age_years)
```

Dizin parantezleri [ ] ile veri çerçevesinin belirli bir bölümüne erişebilir ve kaydedebilirsiniz: 

```{r}
summary(linelist$age_years)[[2]]            # yalnızca ikinci ögeyi göster
# eşdeğeri, eleman adı için yukarıdakine alternatif olarak 
# summary(linelist$age_years)[["1st Qu."]]  
```

max(), min(), median(), ortalama(), quantile(), sd() ve range() gibi temel R işlevleriyle istatistikleri tek tek elde edebilirsiniz. Tam bir liste için R’ın temelleri sayfasına bakabilirsiniz.

<span style="color: orange;">**_UYARI:_** Verileriniz eksik değerler içeriyorsa, R bunu belirtmenizi ister. Bu nedenle, na.rm = TRUE argümanı aracılığıyla R'nin eksik değerleri yok saymasını belirtmediğiniz sürece komut NA değerini verir.`na.rm = TRUE`.</span>


Özet istatistikleri bir veri çerçevesi biçiminde döndürmek için rstatix'teki get_summary_stats() fonkisyonunu kullanabilirsiniz. Bu fonksiyon, sonraki işlemleri gerçekleştirmek veya istatistiklerle çizim yapmak için yardımcı olabilir. rstatix paketi ve işlevleri hakkında daha fazla ayrıntı için Temel istatistiksel testler sayfasına bakın.

```{r}
linelist %>% 
  get_summary_stats(
    age, wt_kg, ht_cm, ct_blood, temp,  # hesaplanacak sütunlar
    type = "common")                    # döndürülecek özet istatistikler

```





## **janitor** paketi {#tbl_janitor}  

janitor paketleri, yüzdeleri, oranları, sayıları vb. görüntülemek için yardımcı işlevlerin uygulandığı tablolar ve çapraz tablolar oluşturmak için tabyl() fonksiyonunu sunar.

Aşağıda, sıra listesi veri çerçevesini janitor fonksiyonlarına aktarıyoruz ve sonucu yazdırıyoruz. İstenirse, sonuç tablolarını <- atama operatörü ile de kaydedebilirsiniz.

### Basit tabyl {.unnumbered}  

'tabyl()' öğesinin belirli bir sütunda varsayılan kullanımı, değerler, sayılar ve sütun bazında "yüzdeler" (oranlar) oluşturur. Oranlar çok basamaklı olabilir. Aşağıda açıklandığı gibi 'adorn_rounding()' ile ondalık basamak sayısını ayarlayabilirsiniz.  

```{r}
linelist %>% tabyl(age_cat)
```
Yukarıda gördüğünüz gibi, eksik değerler varsa, <NA> etiketli bir satırda görüntülenirler. Bunların gösterimini show_na = FALSE ile kapatabilirsiniz. Eksik değer yoksa bu satır görünmez. Eksik değerler varsa, tüm oranlar hem ham olarak (paydadaki NA sayıları dahil) hem de “geçerli” (paydadaki NA sayıları hariç) formda verilir.

Sütun sınıfı faktörse ve verilerinizde yalnızca belirli düzeyler varsa, tüm düzeyler tabloda görünmeye devam eder. show_missing_levels = FALSE belirterek bu özelliği kapatabilirsiniz. Faktörler sayfasında daha fazla bilgiye ulaşabilirsiniz. 


### Çapraz tablolar {.unnumbered}  

Çapraz tablolar, tabyl() içinde bir veya daha fazla ek sütun eklenerek elde edilir. Çıktıda yalnızca sayıların elde edildiğini unutmayın - oranlar ve yüzdeler, aşağıda gösterilen ek adımlarla eklenebilir.

```{r}
linelist %>% tabyl(age_cat, gender)
```

### tabyl'in "süslenmesi" {#tbl_adorn .unnumbered}  

Toplamları eklemek veya oranlara, yüzdelere dönüştürme işlemi veya ekranı başka bir şekilde ayarlamak için **janitor** “adorn” fonkisyonlarını kullanın. Tabloyu bu fonksiyonlardan birkaçından geçirebilirsiniz.

Fonksiyon          | Çıktı                          
-------------------|--------------------------------
`adorn_totals()`   | Toplamların eklenmesi (where = “row”, “col”, veya “both”). name = “Total” için.  
`adorn_percentages()` | Sayımların orana dönüştürülmesi denominator = “row”, “col”, veya “all”  
`adorn_pct_formatting()` | Oranların yüzdelere çevrimi. digits = belirtilmelidir. “%” sembolü bu argüman ile uzaklaştırılır.  `affix_sign = FALSE`.  
`adorn_rounding()` | Oranların digits =  sayıda basamağa yuvarlanması. Yüzdelerin yuvarlanması için   `adorn_pct_formatting()`.  
`adorn_ns()` | Oranlar veya yüzdeler tablosuna sayıları ekleyin. Sayıları parantez içinde göstermek için position = "rear" veya yüzdeleri parantez içinde koymak için "front" belirtin. 
`adorn_title()` | DEğişkenler aracılığıyla dize (string)eklenmesi row_name = and/or col_name =   

Yukarıdaki işlevleri uyguladığınız sıra önemlidir. Aşağıda bazı örnekler verilmiştir.

Varsayılan oranlar yerine yüzdeleri olan basit, tek yönlü bir tablo örneği: 

```{r}
linelist %>%               # vaka satır listesi 
  tabyl(age_cat) %>%       # sayıları-oranları yaşa göre tablo haline getirin
  adorn_pct_formatting()   # oranları yüzdelere çevir

```

Toplam satır ve satır yüzdelerini içeren bir çapraz tablo.
```{r}
linelist %>%                                  
  tabyl(age_cat, gender) %>%                  # yaş ve cinsiyete göre sayılar
  adorn_totals(where = "row") %>%             # toplam satırı ekle
  adorn_percentages(denominator = "row") %>%  # sayıları oranlara dönüştür
  adorn_pct_formatting(digits = 1)            # oranları yüzdelere çevir

```

Hem sayıların hem de yüzdelerin görüntülenmesi için ayarlanmış bir çapraz tablo.

```{r}
linelist %>%                                  # vaka listesi
  tabyl(age_cat, gender) %>%                  # çapraz tablo sayıları
  adorn_totals(where = "row") %>%             # toplam satırı ekle
  adorn_percentages(denominator = "col") %>%  # oranlara dönüştürmek
  adorn_pct_formatting() %>%                  # yüzdeye dönüştür
  adorn_ns(position = "front") %>%            # "sayı (yüzde)" olarak görüntüleme
  adorn_title(                                # başlıkların ayarlanması 
    row_name = "Age Category",
    col_name = "Gender")

```



### tabyl çıktısının alınması {.unnumbered}

Varsayılan olarak tabyl, R konsolunuza ham formda yazdıracaktır.

Alternatif olarak, RStudio Viewer'da .png, .jpeg, .html, vb. olarak dışa aktarılabilen bir resim olarak yazdırmak için tabyl'i flextable veya benzeri bir pakete geçirebilirsiniz. Bu işlem, Sunum için tablolar sayfasında tartışılmaktadır. Bu şekilde yazdırıyorsanız ve adorn_titles() kullanıyorsanız, place = argümanını "combined" belirtmeniz gerektiğini unutmayın. 


```{r}
linelist %>%
  tabyl(age_cat, gender) %>% 
  adorn_totals(where = "col") %>% 
  adorn_percentages(denominator = "col") %>% 
  adorn_pct_formatting() %>% 
  adorn_ns(position = "front") %>% 
  adorn_title(
    row_name = "Age Category",
    col_name = "Gender",
    placement = "combined") %>% # resim olarak yazdırmak için bu gereklidir
  flextable::flextable() %>%    # güzel görüntüye dönüştür
  flextable::autofit()          # satır başına bir satıra biçimlendir


```


### Diğer tablolarda kullanımı  {.unnumbered}  

janitor adorn_*() işlevlerini, dplyr'den summarise() ve count() veya temel R'dan table() tarafından oluşturulanlar diğer tabloları da kullanabilirsiniz. Tabloyu istenen janitor fonksiyonuna yönlendirmeniz yeterlidir. Örneğin:  

```{r}
linelist %>% 
  count(hospital) %>%   # dplyr fonksiyonu
  adorn_totals()        # janitor fonksiyonu
```


### tabyl kaydedilmesi  {.unnumbered}  

Tabloyu flextable gibi bir paketle "güzel" bir resme dönüştürürseniz, o paketteki fonksiyonlarla kaydedebilirsiniz  (flextable'da save_as_html(), save_as_word(), save_as_ppt() ve save_as_image() gibi fonksiyonlar bulunmaktadır. Sunum için tablolar sayfasında kapsamlı bir şekilde tartışılmıştır. Aşağıdaki tablo, elle düzenlenebilen bir Word belgesi olarak kaydedilmiştir: 

```{r, eval=F}
linelist %>%
  tabyl(age_cat, gender) %>% 
  adorn_totals(where = "col") %>% 
  adorn_percentages(denominator = "col") %>% 
  adorn_pct_formatting() %>% 
  adorn_ns(position = "front") %>% 
  adorn_title(
    row_name = "Age Category",
    col_name = "Gender",
    placement = "combined") %>% 
 flextable::flextable() %>%                     # resme dönüştür
  flextable::autofit() %>%                       # satır başına yalnızca bir satır
  flextable::save_as_docx(path = "tabyl.docx")   # dosya yoluna Word belgesi kaydet

```

```{r out.width = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "tabyl_word.png"))
```

### İstatistikler {#janitor_age_out_stats .unnumbered}  

Aşağıda gösterildiği gibi, stats paketinden chisq.test() veya fisher.test() gibi fonksiyonlarla tablolar üzerinde istatistiksel testler uygulayabilirsiniz. Bu işlem, eksik değerlere izin verilmez, bu nedenle show_na = FALSE ile tablodan hariç tutulurlar. 

```{r, warning=F, message=F}
age_by_outcome <- linelist %>% 
  tabyl(age_cat, outcome, show_na = FALSE) 

chisq.test(age_by_outcome)
```

Daha fazla kod ve istatistiklerle ilgili ipuçları için [Temel istatistik testleri] sayfasına bakın. 

### Diğer ipuçları {.unnumbered}  

•	Yukarıdaki hesaplamalardan herhangi birinden eksik değerleri hariç tutmak için na.rm = TRUE değişkenini kullanın.

•	tabyl() tarafından oluşturulmamış tablolara herhangi bir adorn_*() yardımcı fonksiyonu uyguluyorsanız, bunları adorn_percentage(,,,c(cases,deaths)) sintaksıyla belirli sütunlara uygulayabilirsiniz. (Sütunlar 4. değişken olarak belirtilmedir.). Sintaksı basit değil, bu nedenle bu işlem yerine summarise() kullanmayı düşünün.

•	Daha fazla ayrıntıyı janitor sayfasından ve tabyl gösteriminden okuyabilirsiniz.
[janitor sayfası](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html) ve [tabyl göstergesi](https://cran.r-project.org/web/packages/janitor/vignettes/tabyls.html).  



## **dplyr** paketi   

dplyr, tidyverse paketlerinin bir parçasıdır ve çok yaygın bir veri yönetimi aracıdır. 

dplyr’ın summarise() ve count() fonksiyonları tablolar oluşturmak, istatistikleri hesaplamak, gruba göre özetlemek veya tabloları ggplot()'a geçirmek için kullanışlı bir yaklaşımdır. 

summarise(), yeni bir özet veri çerçevesi oluşturur. Veriler gruplandırılmamışsa, tüm veri çerçevesinin belirtilen özet istatistiklerini içeren tek satırlık bir veri çerçevesi oluşturur. Veriler gruplandırılmışsa, yeni veri çerçevesinde grup başına bir satır oluşturacaktır (bkz. Verilerin gruplandırması sayfası).

summarise() fonksiyonunun parantezleri içinde, her yeni özet sütununun adını ve ardından bir eşittir işareti ve uygulanacak istatistiksel işlevi argüman olarak belirtmelisiniz.

: 


<span style="color: darkgreen;">**_İPUCU:_** Özetleme işlevi hem İngiliz hem de Amerikan İngilizcesi ile yazılabilir. (summarise() and summarize()).</span>

### Gözlem sayılarını elde etme  {.unnumbered}  

summarise() içinde uygulanacak en basit fonksiyon n()'dir. Satır sayısını elde etmek için parantezleri boş bırakın.  

```{r}
linelist %>%                 # satır listesiyle başla
  summarise(n_rows = n())    # n_rows sütunu ile özet veri çerçevesi elde edilir

```

Verileri önceden gruplandırıldığında bu daha ilginç sonuçlar elde edilir.

```{r}
linelist %>% 
  group_by(age_cat) %>%     # verileri age_cat sütunundaki değerlere göre gruplandır
  summarise(n_rows = n())   # *grup başına* satır sayısı elde edilir

```

Yukarıdaki komut, count() işlevi kullanılarak kısaltılabilir. count() şunları yapar:
  
1. Verileri belirlenen sütunlara göre gruplandırır
2. Verileri n() ile özetler (n sütunu oluşturur)
3. Verileri gruplarını çözer 


```{r}
linelist %>% 
  count(age_cat)
```

Sayılar sütununun adını varsayılan n'den name =  değişkeniyle değiştirebilirsiniz. 

İki veya daha fazla gruplandırma sütunundaki sayılar "uzun" biçimde tablo halinde döndürülür. n sütununda gözlem sayıları bulunmaktadır.  "Uzun" ve "geniş" veri biçimleri hakkında bilgi edinmek için verileri pivotlama sayfasına bakın. 

```{r}
linelist %>% 
  count(age_cat, outcome)
```


### Tüm seviyelerin gösterimi {.unnumbered}  

Bir sınıf faktörü sütunu oluştururken, summarise() veya count() komutuna .drop = FALSE argümanını ekleyerek (yalnızca verilerde değerleri olan seviyeleri değil) tüm seviyelerin gösterebilirsiniz. 

Bu teknik, tablolarınızı/grafiklerinizi standart hale getirmek için kullanışlıdır. Özellikle, birden fazla alt grup için grafik oluştururken ya da rutin raporlar için tekrarlayan grafiklerr oluştururken faydalıdır. Bu koşulların her birinde, verilerdeki değerler değişse de sabit kalan seviyeler tanımlayabilirsiniz.

Daha fazla bilgi için [Faktörler] sayfasına bakın.



### Oranlar {#tbl_dplyr_prop .unnumbered}  

Oranlar, yeni bir sütun oluşturmak için tablonun mutate() fonksiyonuna yönlendirmesi ile elde edilebilir. Yeni sütun, sayım sütununun (varsayılan olarak n) sayım sütununun toplamının elde edildiği sum()’a bölünmesiyle oluşturulur (bu işlem bir oran verir).

Bu durumda, mutate() komutundaki sum() öğesinin, oranın paydası olarak kullanılmak üzere tüm n sütununun toplamını vereceğini unutmayın. Verileri gruplandırılması sayfasında açıklandığı gibi, gruplandırılmış verilerde sum() fonksiyonu kullanılıyorsa (örneğin, mutate() fonksiyonu group_by() komutunu takip ediyorsa), gruba göre toplamlar elde edilir. Yukarıda belirtildiği gibi, count() fonksiyonu grupları çözerek görevini tamamlar. Böylece, bu senaryoda tam sütun oranlarını elde ederiz.

Yüzdeleri kolayca görüntülemek için, scales paketinden percent() fonksiyonunu kullanabilirsiniz (bu fonksiyonda verinin sınıf karakterine dönüştürüldüğünü unutmayın).


```{r}
age_summary <- linelist %>% 
  count(age_cat) %>%                     # cinsiyete göre grupla ve say ("n" sütunu oluşur)
  mutate(                                # sütunun yüzdesini oluştur – paydaya dikkat edin 
    percent = scales::percent(n / sum(n))) 

# çıktı al 
age_summary
```

Aşağıda gruplar içindeki oranları hesaplamak için bir yöntem gösterilmiştir. Seçici olarak uygulanan farklı veri gruplama düzeylerine dayanan bir yöntemdir. İlk olarak, veriler group_by() aracılığıyla sonuca göre gruplandırılır. Ardından, count() uygulanır. Bu fonksiyon, verileri age_cat'e göre gruplandırır ve her sonuç-age_cat kombinasyonu için gözlem sayılarını verir. Daha önemlisi, count() aynı zamanda age_cat gruplandırmasını da çözer, bu nedenle geriye kalan tek veri gruplaması sonuca göre orijinal gruplandırmadır. Bu nedenle, oranları hesaplamada son adımı (payda sum(n)) hala sonuca göre gruplandırılmıştır. 

```{r}
age_by_outcome <- linelist %>%                  # satır listesiyle başla
  group_by(outcome) %>%                         # sonuca göre gruplandır
  count(age_cat) %>%                            # age_cat ile gruplandır ve say ve ardından age_cat gruplamasını kaldır 
  mutate(percent = scales::percent(n / sum(n))) # yüzdeyi hesapla - paydanın sonuç grubuna göre olduğuna dikkat edin

```

```{r, echo=F}
DT::datatable(age_by_outcome, rownames = FALSE, options = list(pageLength = 12, scrollX=T), class = 'white-space: nowrap' )
```




### Grafikleştirme {.unnumbered}  

Yukarıdaki gibi "uzun" bir tablo ggplot() ile rahatça görüntülenebilir. Veriler ggplot() tarafından doğal olarak kabul edilen “uzun” formattadır. ggplot temelleri ve ggplot ipuçları sayfalarındaki diğer örneklere bakın.

```{r, warning=F, message=F}
linelist %>%                      # satır listesiyle başlama
  count(age_cat, outcome) %>%     # sayıları iki sütuna göre gruplandırın ve tablolaştırın
  ggplot()+                       # yeni veri çerçevesini ggplot'a geçir
    geom_col(                     # sütun grafiği oluştur
      mapping = aes(   
        x = outcome,              # sonucu x eksenine eşle
        fill = age_cat,           # age_cat'i dolguya eşle
        y = n))                   # sayım sütununu `n` yüksekliğe eşle
```


### Özet istatistiği {.unnumbered}  

dplyr ve summarise()'in önemli bir avantajı, median(), mean(), max(), min(), sd() (standart sapma) ve yüzdelikler gibi daha ileri istatistik özetleri oluşturma yeteneğidir. Belirli mantık kriterlerini karşılayan satır sayılarını elde etmek için sum() fonksiyonuna da kullanabilirsiniz. Yukarıdaki gibi, bu çıktılar tüm veri çerçevesi için veya belli grup gruplar için oluşturulabilir.

Sintaks aynıdır - summarise() parantezleri içinde yeni özet sütunlarının adları, ardından bir eşittir işareti ve uygulanacak istatistiksel fonksiyonlar yazılmalıdır. İstatistiksel fonksiyon içinde, üzerinde çalışılacak sütunları ve ilgili argümanlar yazılmalıdır (örneğin, çoğu matematiksel fonksiyon için na.rm = DOĞRU).

Mantıksal bir ölçütü karşılayan satır sayısını elde etmek için sum()'u da kullanabilirsiniz. İçindeki ifade TRUE olarak değerlendirilirse sayıma girer. Örneğin:


* `sum(age_years < 18, na.rm=T)`  
* `sum(gender == "male", na.rm=T)`  
* `sum(response %in% c("Likely", "Very Likely"))`  

Aşağıda, satır listesi verilerinde, semptom başlangıcından hastaneye kabule kadar geçen gün gecikmesi değişkeni (sütun days_onset_hosp) özetlenmiştir.  

```{r}
summary_table <- linelist %>%                                        # linelist ile başlayın, yeni nesne olarak kaydedin
  group_by(hospital) %>%                                             # tüm hesaplamaları hastaneye göre gruplandır
  summarise(                                                         # yalnızca aşağıdaki özet sütunları elde edilecek
    cases       = n(),                                                # grup başına satır sayısı
    delay_max   = max(days_onset_hosp, na.rm = T),                    # maksimum gecikme
    delay_mean  = round(mean(days_onset_hosp, na.rm=T), digits = 1),  # ortalama gecikme, yuvarlanmış
    delay_sd    = round(sd(days_onset_hosp, na.rm = T), digits = 1),  # gecikmelerin standart sapması, yuvarlanmış
    delay_3     = sum(days_onset_hosp >= 3, na.rm = T),               # 3 veya daha fazla gün gecikmeli satır sayısı
    pct_delay_3 = scales::percent(delay_3 / cases)                    # önceden tanımlanmış gecikme sütununu yüzdeye dönüştür
  )

summary_table  # yazdır
```


Bazı ipuçları

• Belirli ölçütleri karşılayan (==) satırları "saymak" için bir mantıksal ifadeyle sum() kullanın
• sum() gibi matematiksel fonksiyonlarda na.rm = TRUE kullanımına dikkat edin, aksi takdirde eksik değerler varsa NA elde edilir. 
• Yüzdelere kolayca dönüştürmek için scales paketindeki percent() işlevini kullanın
• Sırasıyla 1 veya 2 ondalık basamak sağlamak için accuracy =  argümanını 0,1 veya 0,01 olarak ayarlayın
• Ondalık sayıları belirtmek için temel R’dan round() fonksiyonunu kullanın
• Bu istatistikleri tüm veri kümesinde hesaplamak için, group_by() olmadan summarise() kullanın.
• Daha sonraki hesaplamalar için (örneğin payda oluşturmak için) veri çerçevenizden select() ile seçebileceğiniz sütunlar oluşturabilirsiniz. 



### Koşullu istatistikler {.unnumbered}  

Koşullu istatistikleri elde etmek isteyebilirsiniz - ör. belirli ölçütleri karşılayan maksimum satır sayısı elde edilebilir. Bu işlem, sütun parantez [ ] ile alt kümelere ayrılarak gerçekleştirilebilir. Aşağıdaki örnek, ateşi olan veya olmayan hastalar için maksimum vücut sıcaklığını verir. Ancak unutmayın - group_by()ve pivot_wider() komutlarıyla (aşağıda gösterildiği gibi) başka bir sütun eklemek daha uygun olabilir. (#tbls_pivot_wider)).  


```{r}
linelist %>% 
  group_by(hospital) %>% 
  summarise(
    max_temp_fvr = max(temp[fever == "yes"], na.rm = T),
    max_temp_no = max(temp[fever == "no"], na.rm = T)
  )
```



### Hepsini birleştirmek {.unnumbered}  

stringr'den str_glue() fonksiyonu, birkaç sütundaki değerleri yeni bir sütunda birleştirmek için kullanışlıdır. Genellikle bu fonksiyon summarise() komutundan sonra kullanılır.

Karakterler ve dizeler sayfasında, unite() ve paste0() dahil olmak üzere sütunları birleştirmek için çeşitli seçenekler tartışılmaktadır. Bu kullanım örneğinde, unite()'den daha esnek olduğu ve paste0()'dan daha basit sözdizimine sahip olduğu için str_glue() vurgulanmıştır.

Aşağıdaki örnekte, summary_table veri çerçevesinde, delay_mean ve delay_sd sütunları birleştirilecek, yeni sütuna parantez biçimlendirmesi eklenecek ve ilgili eski sütunlar kaldırılacaktır.

Ardından, tabloyu daha anlaşılır hale getirmek için, janitor’dan adorn_totals() ile toplam bir satır eklenir (bu fonksiyon sayısal olmayan sütunları yok sayar). Son olarak, hem yeniden sıralamak hem de sütunları yeniden adlandırmak için dplyr'den select() kullanıyoruz.

Artık flextable'a geçebilir ve tablonun çıktısını Word, .png, .jpeg, .html, Powerpoint, RMarkdown, vb.'ye alabilirsiniz! (Sunum için tablolar sayfasına bakınız).


```{r}
summary_table %>% 
  mutate(delay = str_glue("{delay_mean} ({delay_sd})")) %>%  # diğer değerleri birleştir ve biçimlendir
  select(-c(delay_mean, delay_sd)) %>%                       # iki eski sütunu sil  
  adorn_totals(where = "row") %>%                            # toplam satırı ekle
  select(                                                    # sütunları sırala ve yeniden adlandır
    "Hospital Name"   = hospital,
    "Cases"           = cases,
    "Max delay"       = delay_max,
    "Mean (sd)"       = delay,
    "Delay 3+ days"   = delay_3,
    "% delay 3+ days" = pct_delay_3
    )
```

#### Yüzdelikler {.unnumbered}  

Burada dplyr'deki yüzdelikler ve çeyrekliklere özel olarak değinilecektir. Yüzdelikleri döndürmek için, 'quantile()' fonksiyonunu varsayılanlarla kullanın veya istediğiniz değeri/değerleri 'probs =' değişkeni ile belirtin.

```{r}
# yaşın varsayılan yüzdelik değerlerini alın (%0, %25, %50, %75, %100)
linelist %>% 
  summarise(age_percentiles = quantile(age_years, na.rm = TRUE))

# manuel olarak belirtilen yaş yüzdelik değerlerini alın (%5, %50, %75, %98)
linelist %>% 
  summarise(
    age_percentiles = quantile(
      age_years,
      probs = c(.05, 0.5, 0.75, 0.98), 
      na.rm=TRUE)
    )
```

Yüzdelikleri gruplara göre elde etmek istiyorsanız, group_by() öğesine basitçe başka bir sütun eklerseniz, uzun ve kullanışsız çıktılarla karşılaşabilirsiniz. Bu nedenle, bunun yerine istenen her yüzdelik düzeyi için bir sütun oluşturma yöntemini kullanın. 

```{r}
#   manuel olarak belirtilen yaş yüzdelik değerlerini alın (%5, %50, %75, %98)
linelist %>% 
  group_by(hospital) %>% 
  summarise(
    p05 = quantile(age_years, probs = 0.05, na.rm=T),
    p50 = quantile(age_years, probs = 0.5, na.rm=T),
    p75 = quantile(age_years, probs = 0.75, na.rm=T),
    p98 = quantile(age_years, probs = 0.98, na.rm=T)
    )
```

dplyr summarise() fonksiyonu kesinlikle daha iyi kontrol sağlarken, ihtiyacınız olan tüm özet istatistiklerin rstatix paketinden get_summary_stat() ile elde edebilirsiniz. Gruplandırılmış veriler üzerinde çalışıyorsanız, %0, %25, %50, %75 ve %100 değerlerini elde edebilirsiniz. Gruplandırılmamış verilere uygularsanız, yüzdelikleri probs = c(.05, .5, .75, .98) değişkeni ile belirtebilirsiniz. 


```{r}
linelist %>% 
  group_by(hospital) %>% 
  rstatix::get_summary_stats(age, type = "quantile")
```

```{r}
linelist %>% 
  rstatix::get_summary_stats(age, type = "quantile")
```



### Birleştirilmiş verileri özetleyin {.unnumbered}  

*Birleştirilmiş verilerle başlarsanız*, n() fonksiyonunu kullandığınızda, toplanan sayıların toplamını değil, satır sayısını elde edersiniz. Toplamları almak için verilerin sayımlar sütununda sum() öğesini kullanın.
Örneğin, linelist_agg adında sayım veri çerçevesiyle başladığınızı varsayalım- vaka sayıları sonuca ve cinsiyete göre "uzun" biçimde gösterilir. 
Aşağıda, sonuca ve cinsiyete göre satır listesi vaka sayılarının örnek veri çerçevesini oluşturuyoruz (Anlaşılması için eksik değerler kaldırıldı).


```{r}
linelist_agg <- linelist %>% 
  drop_na(gender, outcome) %>% 
  count(outcome, gender)

linelist_agg
```

Sayıları (n sütunundaki) gruba göre toplamak için summarise()'i kullanabilirsiniz, ancak yeni sütunu sum(n, na.rm=T) değerine eşitlemeniz gerekmektedir. Toplam işlemine koşullu öğe eklemek için, sayımlar sütunundaki alt küme ayracını [ ] kullanabilirsiniz.

```{r}
linelist_agg %>% 
  group_by(outcome) %>% 
  summarise(
    total_cases  = sum(n, na.rm=T),
    male_cases   = sum(n[gender == "m"], na.rm=T),
    female_cases = sum(n[gender == "f"], na.rm=T))
```




### `across()` birden çok sütun arasından   {.unnumbered}  

summarise() fonksiyonunu across() kullanarak birden çok sütuna uygulayabilirsiniz. Bu şekilde birçok sütun için aynı istatistikleri hesaplayabilirsiniz . summarise() fonksiyonu içine across() fonksiyonunu yerleştirin ve aşağıdakileri belirtin:

* `.cols = ` sütun adlarının bir vektörü olarak .cols = c() veya "tidyselect" yardımcı işlevleri (aşağıda açıklanmıştır)
* `.fns = `gerçekleştirilecek fonksiyon (parantez yok) - bir liste içinde birden çok fonksiyon belirtebilirsiniz. 

Aşağıda, mean() birkaç sayısal sütuna uygulanmıştır. Bir sütun vektörü .cols =  argümanı olarak belirtilir ve .fns = olarak tek bir fonksiyon- bu durumda (parantez olmadan) ortalama belirtilir. İşlev için ek argümanlar (ör. na.rm=TRUE), .fns = argümanından sonra virgülle ayrılmış olarak yazılır.

Across() kullanılırken parantez ve virgüllerin sırasını doğru yapmak zor olabilir. Across() içinde, sütunları, fonksiyonları ve fonkisyonlar için gereken fazladan argümanları dahil etmeniz gerektiğini unutmayın.


```{r}
linelist %>% 
  group_by(outcome) %>% 
  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm),  # sütunlar
                   .fns = mean,                               # fonksiyon
                   na.rm=T))                                  # ekstra değişkenler
```

Aynı anda birden fazla fonksiyon çalıştırılabilir. Aşağıda, bir liste list() içinde .fns = için mean ve sd fonkisyonları sağlanır. Yeni sütunları istediğimiz gibbi adlandırabiliriz (örneğin, "ortalama" ve "sd"). 

```{r}
linelist %>% 
  group_by(outcome) %>% 
  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm), # sütunlar
                   .fns = list("mean" = mean, "sd" = sd),    # çoklu fonksiyon 
                   na.rm=T))                                 # ekstra değişkenler
```

Sütunları seçmek için .cols = argümanı için sağlayabileceğiniz "tidyselect" yardımcı işlevleri şunlardır:

•	everything() - belirtilmeyen diğer tüm sütunlar
•	last_col() – son sütun
•	where() - tüm sütunlara bir fonksiyonu uygular ve DOĞRU olanları seçer
•	starts_with() - belirli bir ön-ekle eşleşir. Örnek: starts_with("date") 
•	ends_with() - belirli bir son-ekle eşleşir. Örnek:ends_with("_end")
•	contains() - bir karakter dizisi içeren sütunlar. Örnek:contains("time") 
•	matches() - regüler bir ifade (regex) uygulamak için. Örnek:contains("[pt]al")
•	num_range() - 
•	any_of() – sütun adlandırılmışsa eşleşir. Ad mevcut değilse kullanışlıdır. Örnek:
•	any_of(date_onset, date_death, cardiac_arrest) 

Örneğin, her sayısal sütunun ortalamasını elde etmek için where() fonksiyonunu kullanın ve içinde is.numeric’i parentez olmadan kullanın. Bütün bunlar across() komutu içinde kalır.


```{r}
linelist %>% 
  group_by(outcome) %>% 
  summarise(across(
    .cols = where(is.numeric),  # veri çerçevesindeki tüm sayısal sütunlar
    .fns = mean,
    na.rm=T))
```


### Pivot genişletme {#tbls_pivot_wider .unnumbered}

Tablonuzu "geniş" biçimde oluşturmayı tercih ederseniz, tidyr pivot_wider() fonksiyonunu kullanarak dönüştürebilirsiniz. Sütunları rename() ile yeniden adlandırmanız gerekebilir. Daha fazla bilgi için Verilerin pivotlanması sayfasına bakın.

Aşağıdaki örnek, oranlar bölümündeki "uzun" tablodur ve age_by_outcome ile başlamaktadır. 
  

```{r}
age_by_outcome <- linelist %>%                  # satır listesiyle başla
  group_by(outcome) %>%                         # sonuca göre gruplandır
  count(age_cat) %>%                            # age_cat ile gruplandırın ve sayın ve ardından age_cat gruplamasını kaldırın
  mutate(percent = scales::percent(n / sum(n))) # yüzdeyi hesapla - paydanın sonuç grubuna göre olduğuna dikkat edin

```

```{r, echo=F}
DT::datatable(age_by_outcome, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Daha geniş bir tablo halinde özetlemek için ScriptTo ile, mevcut age_cat sütunundaki değerlerden name_from = age_cat ayarını yaparak yeni sütunlar yaratırız. Yeni tablo değerleri mevcut n sütunundan, value_from = n ile elde edilecektir. Pivotlama komutumuzda (çıktı) belirtilmeyen sütunlar, en sol tarafta değişmeden kalacaktır.

```{r}
age_by_outcome %>% 
  select(-percent) %>%   # basit gösterim için sadece sayımlar 
  pivot_wider(names_from = age_cat, values_from = n)  
```


### Toplam satırlar {#tbl_dplyr_totals .unnumbered}  

summarise () işlevi, gruplanmış veriler üzerinde çalıştığında, otomatik olarak "toplam" istatistikler üretmez. Aşağıda, toplam satır eklemeye yönelik iki yaklaşım sunulmaktadır:

#### **janitor**'ün `adorn_totals()` fonskiyonu {.unnumbered}  

Tablonuz yalnızca toplamda elde edilebilecek sayılardan veya orantılardan/yüzdelerden oluşuyorsa, yukarıdaki bölümde açıklandığı gibi janitor adorn_totals() fonksiyonunu kullanarak toplamları ekleyebilirsiniz. Bu fonkisyonun yalnızca sayısal sütunları toplayabileceğine dikkat edin - diğer toplam özet istatistiklerini hesaplamak istiyorsanız dplyr ile sonraki yaklaşıma bakın.

Aşağıda, satır listesi cinsiyete göre gruplandırılmıştır ve sonucu bilinen, ölen ve iyileşen vakaların sayısını açıklayan bir tabloda özetlenmiştir. Tabloyu adorn_totals()'a yönlendirmek, tablonun altına her sütunun toplamını yansıtan bir toplam satır ekler. Diğer adorn_*() işlevleri, kodda belirtildiği gibi ekranı ayarlar.


```{r}
linelist %>% 
  group_by(gender) %>%
  summarise(
    known_outcome = sum(!is.na(outcome)),           # Sonucun eksik olmadığı gruptaki satır sayısı
    n_death  = sum(outcome == "Death", na.rm=T),    # Sonucun ölüm olduğu gruptaki satır sayısı
    n_recover = sum(outcome == "Recover", na.rm=T), # Sonucun hayatta kalma olduğu gruptaki satır sayısı
  ) %>% 
  adorn_totals() %>%                                # Toplam satırı (her sayısal sütunun toplamı)
  adorn_percentages("col") %>%                      # Sütun oranlarını al
  adorn_pct_formatting() %>%                        # Oranları yüzdelere dönüştür
  adorn_ns(position = "front")                      # % ve sayıları göster (sayılar önde)

```

#### Toplam veride summarise() sonrasında bind_rows() fonksiyonu {.unnumbered}  

Tablonuz median(), mean() vb. özet istatistiklerden oluşuyorsa, yukarıda gösterilen adorn_totals() yaklaşımı yeterli olmayacaktır. Bunun yerine, tüm veri kümesi için özet istatistikleri elde etmek için ayrı bir summarise() komutu kullanarak hesaplamanız ve ardından sonuçları orijinal gruplandırılmış özet tablosuna eklemeniz gerekir. Birleştirmeyi yapmak için, Verilerin birleştirilmesi sayfasında açıklanan dplyr’dan bind_rows() fonksiyonunu kullanabilirsiniz. Aşağıda bir örnek verilmiştir:

group_by() ve summarise() ile hastane bazında sonuçların özetini şu şekilde çıkarabilirsiniz:


```{r, warning=F, message=F}
by_hospital <- linelist %>% 
  filter(!is.na(outcome) & hospital != "Missing") %>%  # Eksik sonuç veya hastane verisi olan vakaları sil
  group_by(hospital, outcome) %>%                      # Veriyi grupla 
  summarise(                                           # İlgilenilen göstergelerin yeni özet sütunları oluşturun
    N = n(),                                            # Hastane-sonuç grubu başına satır sayısı
    ct_value = median(ct_blood, na.rm=T))               # by_hospital grubu başına medyan CT değeri

by_hospital # tabloyu yazdır  

```

Toplamları almak için summarise() komutunu çalıştırın, ancak verileri yalnızca sonuca göre (hastaneye göre değil) şu şekilde gruplandırın: 

```{r}
totals <- linelist %>% 
      filter(!is.na(outcome) & hospital != "Missing") %>%
      group_by(outcome) %>%                            # Hastaneye göre değil, yalnızca sonuca göre gruplandırılmış  
      summarise(
        N = n(),                                       # Bu istatistikler artık sadece sonuca göre     
        ct_value = median(ct_blood, na.rm=T))

totals # tabloyu yazdır
```

Bu iki veri çerçevesini birbirine bağlayabiliriz. by_hospital'in 4 sütunu, toplamların ise 3 sütunu olduğunu unutmayın. bind_rows() kullanılarak, sütunlar ada göre birleştirilir ve fazladan boşluklar NA ifadesi ile doldurulur (örneğin, iki yeni toplam satırı için sütun hastane değerleri). Satırları bağladıktan sonra, bu boş alanları replace_na() kullanarak "toplam"a dönüştürürüz (bkz. Veri temizliği ve çekirdek fonksiyonlar sayfaları).

```{r}
table_long <- bind_rows(by_hospital, totals) %>% 
  mutate(hospital = replace_na(hospital, "Total"))
```

Altta "Toplam" satırları olan yeni tablo yer almaktadır.

```{r, message=FALSE, echo=F}
DT::datatable(table_long, rownames = FALSE, options = list(pageLength = 12, scrollX=T), class = 'white-space: nowrap' )
```

Bu tablo, istediğiniz gibi “uzun” biçimdedir. İsteğe bağlı olarak, tabloyu daha okunabilir hale getirmek için bu tabloyu daha geniş forma pivotlayabilirsiniz. Yukarıdaki daha geniş pivotlama ile ilgili bölüme ve Verilerin pivotlanması sayfasına bakın. Ayrıca daha fazla sütun ekleyebilir ve düzenleyebilirsiniz. İlgili kod aşağıdadır.

```{r}
table_long %>% 
  
  # Daha geniş pivotlama ve formatlama 

    mutate(hospital = replace_na(hospital, "Total")) %>% 
  pivot_wider(                                         # Uzundan genişe pivotlama
    values_from = c(ct_value, N),                       # yeni değerler ct ve count sütunlarından alınmıştır
    names_from = outcome) %>%                           # sonuçlardan yeni sütun adları 
  mutate(                                              # Yeni sütunlar ekle
    N_Known = N_Death + N_Recover,                               # sonucu bilinen sayı
    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # ölen vakaların yüzdesi (1 ondalık basamağa kadar)
    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # iyileşenlerin yüzdesi (1 ondalık basamağa kadar)
  select(                                              # Sütunları yeniden sırala
    hospital, N_Known,                                   # Giriş sütunları
    N_Recover, Pct_Recover, ct_value_Recover,            # İyileşenlerin sütunları
    N_Death, Pct_Death, ct_value_Death)  %>%             # Ölen vakaların sütunları
  arrange(N_Known)                                  # Satırları en düşükten en yükseğe doğru düzenleyin (Toplam satır en altta)


```

Daha sonra bu tablo daha “güzel” bir şekilde yazdırabilir. Aşağıda flextable ile elde edilen çıktı yer almaktadır. Bu "güzel" tablonun nasıl elde edileceği hakkında daha ayrıntılı bilgiyi Sunum için Tablolar sayfasından okuyabilirsiniz.  

```{r echo=FALSE, fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}

linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds")) 

border_style = officer::fp_border(color="black", width=1)

pacman::p_load(
  rio,            # içe/dışa aktar
  here,           # dosya yolakları
  flextable,      # tabloların güzel resimlerini yapmak 
  officer,        # tablolar için yardımcı işlevler
  tidyverse)      # veri yönetimi, özet ve görselleştirme

table <- linelist %>% 
  # filtre
  ########
  filter(!is.na(outcome) & hospital != "Missing") %>%  # Eksik sonuç veya hastane olan vakaları kaldırın
  
  # Hastane sonuç grubu başına özet değerleri alın
  ###############################################
  group_by(hospital, outcome) %>%                      # verileri gruplama
  summarise(                                           # İlgilenilen göstergelerin yeni özet sütunları oluşturun
    N = n(),                                            # Hastane-sonuç grubu başına satır sayısı     
    ct_value = median(ct_blood, na.rm=T)) %>%           # grup başına medyan CT değeri
  
  # toplamları ekle
  ############
  bind_rows(                                           # Önceki tabloyu bu mini toplamlar tablosuyla birleştirin
    linelist %>% 
      filter(!is.na(outcome) & hospital != "Missing") %>%
      group_by(outcome) %>%                            # Hastaneye göre değil, yalnızca sonuca göre gruplandırılmış  
      summarise(
        N = n(),                                       # Tüm veri kümesi için satır sayısı    
        ct_value = median(ct_blood, na.rm=T))) %>%     # Tüm veri seti için medyan CT
  
  # Daha geniş döndür ve biçimlendir
  ########################
  mutate(hospital = replace_na(hospital, "Total")) %>% 
  pivot_wider(                                         # Uzundan genişe dön
    values_from = c(ct_value, N),                       # yeni değerler ct ve count sütunlarından alınmıştır
    names_from = outcome) %>%                           # yeni sütun adları sonuçlardan
  mutate(                                              # yeni sütunları ekle
    N_Known = N_Death + N_Recover,                               # sonucu bilinen sayı
    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # ölen vakaların yüzdesi (1 ondalık basamağa kadar)
    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # iyileşen yüzde (1 ondalık basamağa kadar)
  select(                                              # Sütunları yeniden sırala
    hospital, N_Known,                                   # Giriş sütunları
    N_Recover, Pct_Recover, ct_value_Recover,            # kurtarılan sütunlar
    N_Death, Pct_Death, ct_value_Death)  %>%             # Ölüm sütunları
  arrange(N_Known) %>%                                 # Satırları en düşükten en yükseğe doğru düzenleyin (Toplam satır en altta)

  # formatlama
  ############
  flextable() %>% 
  add_header_row(
    top = TRUE,                # Yeni başlık, mevcut başlık satırının üstüne gider
    values = c("Hospital",     # Aşağıdaki her sütun için başlık değerleri
               "Total cases with known outcome", 
               "Recovered",    # Bu, bunun ve sonraki iki sütunun en üst düzey başlığı olacaktır.
               "",
               "",
               "Died",         # Bu, bunun ve sonraki iki sütunun en üst düzey başlığı olacaktır.
               "",             # "Öldü" ile birleştirileceği için boş bırakın
               "")) %>% 
    set_header_labels(         # Orijinal başlık satırındaki sütunları yeniden adlandırın
      hospital = "", 
      N_Known = "",                  
      N_Recover = "Total",
      Pct_Recover = "% of cases",
      ct_value_Recover = "Median CT values",
      N_Death = "Total",
      Pct_Death = "% of cases",
      ct_value_Death = "Median CT values")  %>% 
  merge_at(i = 1, j = 3:5, part = "header") %>% # Yeni başlık satırında 3 ile 5 arasındaki sütunları yatay olarak birleştir
  merge_at(i = 1, j = 6:8, part = "header") %>%  
  border_remove() %>%  
  theme_booktabs() %>% 
  vline(part = "all", j = 2, border = border_style) %>%   # sütun 2 de
  vline(part = "all", j = 5, border = border_style) %>%   # sütun 5 de
  merge_at(i = 1:2, j = 1, part = "header") %>% 
  merge_at(i = 1:2, j = 2, part = "header") %>% 
  width(j=1, width = 2.7) %>% 
  width(j=2, width = 1.5) %>% 
  width(j=c(4,5,7,8), width = 1) %>% 
  flextable::align(., align = "center", j = c(2:8), part = "all") %>% 
  bg(., part = "body", bg = "gray95")  %>% 
  colformat_num(., j = c(4,7), digits = 1) %>% 
  bold(i = 1, bold = TRUE, part = "header") %>% 
  bold(i = 6, bold = TRUE, part = "body")


table
```



## **gtsummary** paketi {#tbl_gt}   

Özet istatistiklerinizi yayına hazır bir grafikte yazdırmak istiyorsanız, gtsummary paketini ve onun tbl_summary() fonksiyonunu kullanabilirsiniz. Kod ilk başta karmaşık görünebilir, ancak çıktıları güzel görünür ve RStudio Viewer panelinize HTML görüntüsü olarak yazdırılır. [gösterimi burada](http://www.danieldsjoberg.com/gtsummary/articles/tbl_summary.html).  

Ayrıca istatistiksel testlerin sonuçlarını gtsummary tablolarına ekleyebilirsiniz. Bu işlem, Basit istatistik testleri sayfasının gtsummary bölümünde açıklanmıştır.[Basit istatistiksel testler](#stats_gt) sayfası.

tbl_summary()'yi tanıtmak için öncelikle büyük ve güzel tablolar oluşturan en temel işlevlerini göstereceğiz. Daha sonra düzenlemelerin ve özel tablolar yapımını detaylı olarak inceleyeceğiz.   


### Özet tablosu {.unnumbered}

tbl_summary()'nin varsayılan fonksiyonuyla belirtilen sütunları alır ve tek komutta bir özet tablo oluşturur. İşlev, sütun sınıfına uygun istatistikleri yazdırır: sayısal sütunlar için medyan ve çeyrekler arası aralık (IQR) ve kategorik sütunlar için gözlem sayısı (%) istatistiklerini verir. Eksik değerler “Bilinmeyen” ifadesnie dönüştürülür. İstatistikleri açıklamak için en alta dipnotlar eklenirken, toplam N üstte gösterilir.

```{r, warning=F, message=F}
linelist %>% 
  select(age_years, gender, outcome, fever, temp, hospital) %>%  # sadece ilgilenilen sütunları tut
  tbl_summary()                                                  # varsayılan
```


### Ayarlar {.unnumbered}  

Şimdi fonksiyonun nasıl çalıştığını ve ayarlamaların nasıl yapıldığını anlatacağız. Temel değişkenler aşağıda detaylandırılmıştır: 

**`by = `**  
2 yönlü bir tablo oluşturarak tablonuzu bir sütuna göre (örn. sonuca göre) tabakalandırabilirsiniz.

**`statistic = `**  
Hangi istatistiklerin gösterileceğini ve nasıl görüntüleneceğini belirtmek için denklem kullanın. Denklemin bir tilde ~ işareti ile ayrılmış iki tarafı vardır. Sağ tarafta istenen istatistiksel hesap, sol tarafta ise bu hesabın uygulanacağı sütunlar yer almaktadır.

• Denklemin sağ tarafındaki stringr'den str_glue() sintaksına (bkz. “n” (sayılar için), “N” (payda için), “mean”, “median”, “sd”, “max”, “min”, yüzdelikleri ( “p##” olarak; örneğin p25, toplamın yüzdeliği p) dahil edebilirsiniz. Ayrıntılar için ?tbl_summary komutunu uygulayın.

• Denklemin sol tarafı için sütunları ada göre (örn. yaş veya c(yaş, cinsiyet)) veya all_continuous(), all_categorical(), include(), start_with(), vb. gibi yardımcıları kullanarak belirtebilirsiniz.

Basit bir statistics = denklemi örneği, yalnızca age_years sütununun ortalamasını yazdırmak için aşağıdaki gibi görünebilir: 


```{r}
linelist %>% 
  select(age_years) %>%         # yalnızca ilgilenilen sütunları tut
  tbl_summary(                  # özet tablo oluştur
    statistic = age_years ~ "{mean}") # yaş ortalamasını yazdır

```

Biraz daha karmaşık gibi görünebilen denklem "({min}, {maks})", maksimum ve minimum değerleri parantez içine alır ve virgülle ayırır:

```{r}
linelist %>% 
  select(age_years) %>%                       # yalnızca ilgilenilen sütunları tut 
  tbl_summary(                                # özet tablo oluştur
    statistic = age_years ~ "({min}, {max})") # yaşın en küçük ve en büyük değerlerini yazdır
```

Ayrı sütunlar veya sütun türleri için sintaksı de farklılaştırabilirsiniz. Aşağıdaki daha karmaşık örnekte, statistic = argümanına sağlanan değer, tablonun tüm sürekli sayısal sütunlar için parantez içinde standart sapma ile ortalamayı, tüm kategorik sütunlar için ise n, payda ve yüzdeyi yazdırması gerektiğini belirten bir listedir. 

**digits =**
Rakamları ve yuvarlamayı ayarlayın. İsteğe bağlı olarak, bu yalnızca sürekli sütunlar için belirtilebilir (aşağıdaki gibi).

**label=**
Sütun adının nasıl görüntüleneceğini ayarlayın. Bir tilde ~ ile ayrılmış sütun adını ve istenen etiketi sağlayın. Varsayılan, sütun adıdır.

**Missing_text=**
Eksik değerlerin nasıl görüntüleneceğini ayarlayın. Varsayılan ifade "Bilinmeyen"dir.

**type =**
Bu argüman, istatistiklerin hangi  düzeyinin gösterileceğini ayarlamak için kullanılır. Sintaksı, statistic = değişkeni ile benzerdir, çünkü solda sütunlar ve sağda değer içeren bir denklem oluşturursunuz. İki yaygın senaryo şunları içerir:

• type = all_categorical() ~ "categorical" İkili sütunları (örn. ateş evet/hayır) yalnızca “evet” satırı yerine tüm seviyeleri göstermeye zorlar

• type = all_continuous() ~ "continuous2" Daha sonraki bir bölümde gösterildiği gibi, değişken başına çok satırlı istatistiklere izin verir

Aşağıdaki örnekte, bu bağımsız değişkenlerin her biri orijinal özet tablosunu değiştirmek için kullanılır: 


```{r}
linelist %>% 
  select(age_years, gender, outcome, fever, temp, hospital) %>% # yalnızca ilgilenilen sütunları tut
  tbl_summary(     
    by = outcome,                                               # tüm tabloyu sonuca göre katmanlandır
    statistic = list(all_continuous() ~ "{mean} ({sd})",        # sürekli sütunlar için istatistikler ve biçim
                     all_categorical() ~ "{n} / {N} ({p}%)"),   # kategorik sütunlar için istatistikler ve biçim
    digits = all_continuous() ~ 1,                              # sürekli sütunlar için yuvarlama
    type   = all_categorical() ~ "categorical",                 # tüm kategorik seviyeleri görüntülemeye zorla
    label  = list(                                              # sütun adları için etiketleri göster
      outcome   ~ "Outcome",                           
      age_years ~ "Age (years)",
      gender    ~ "Gender",
      temp      ~ "Temperature",
      hospital  ~ "Hospital"),
    missing_text = "Missing"                                    # eksik değerler nasıl gösterilmelidir
  )

```



### Sürekli değişkenler için çok satırlı istatistikler {.unnumbered}  

Sürekli değişkenler için birden çok istatistik satırı yazdırmak istiyorsanız, bunu type = değişkenini  "continuous2" olarak ayarlayarak belirtebilirsiniz. Hangi istatistikleri göstermek istediğinizi seçerek, daha önce gösterilen tüm öğeleri tek bir tabloda birleştirebilirsiniz. Bunun için type argümanına “continuous2” girerek tabloyu geri almak istediğinizi fonksiyona belirtmeniz gerekir. Eksik değerlerin sayısı “Bilinmeyen” olarak gösterilir.

```{r}
linelist %>% 
  select(age_years, temp) %>%                      # yalnızca ilgilenilen sütunları tut
  tbl_summary(                                     # özet tablo oluştur
    type = all_continuous() ~ "continuous2",       # birden fazla istatistik yazdırmak istediğinizi belirtin
    statistic = all_continuous() ~ c(
      "{mean} ({sd})",                             # 1. satır: ortalama ve SD
      "{median} ({p25}, {p75})",                   # 2. satır: medyan ve IQR
      "{min}, {max}")                              # satır 3: min ve maks
    )

```
Bu tabloları p değerleri eklenerek, renk ve başlıkları ayarlayarak vb. gibi birçok başka şekilde değiştirilebilir. Bu işlemler çoğu belgelerde açıklanmıştır (Konsol'a ?tbl_summary komutunu girin) ve diğer işlemler ise istatistiksel testler bölümünde açıklanmıştır.[istatistiksel testler](https://epirhandbook.com/simple-statistical-tests.html).  







## R **tabanı**    

Sütunları tablolamak ve çapraz tablo oluşturmak için table() fonkisyonunu kullanabilirsiniz. Yukarıdaki seçeneklerden farklı olarak, aşağıda gösterildiği gibi bir sütun adına her başvurduğunuzda veri çerçevesini belirtmelisiniz.

<span style="color: orange;">**_Uyarı:_** NA (eksik) değerler, useNA = "always" (aynı zamanda "hayır" veya "eğer" olarak da ayarlanabilir) değişkenini eklemediğiniz sürece tablo haline getirilmeyecektir.</span>

<span style="color: darkgreen;">**_İPUCU:_** Baz fonksiyonlarda tekrarlanan veri çerçevesi belirtme ihtiyacını ortadan kaldırmak için magrittr'den %$% operatörünü kullanabilirsiniz. Örneğin aşağıdaki satır listesi  tablosunu inceleyin (çıktı, useNA = "always")</span>

```{r}
table(linelist$outcome, useNA = "always")
```

Birden çok sütun, virgülle ayrılmış şekilde ardışık olarak listelenerek çapraz tablo haline getirilebilir. İsteğe bağlı olarak, her sütuna Outcome = linelist$outcome değişkeni gösterildiği gibi bir ad atayabilirsiniz.

```{r}
age_by_outcome <- table(linelist$age_cat, linelist$outcome, useNA = "always") # tabloyu nesne olarak kaydet
age_by_outcome   # tabloyu yazdır
```

### Oranlar {.unnumbered}  

Oranları elde etmek için yukarıdaki tabloyu prop.table() aktarın geçirin. Oranların (1) satırlardan mı, (2) sütunlardan mı yoksa tüm tablodan mı (3) olmasını istediğinizi belirtmek için margins = argümanını kullanın. Kolay anlaşılmasını sağlamak için, 2 basamak belirterek tabloyu temel R’daki round() fonksiyonuna yönlendiririz.   

```{r}
# yukarıda tanımlanan tablo oranlarını, satırlara göre, yuvarlanmış olarak alın
prop.table(age_by_outcome, 1) %>% round(2)
```

### Toplamlar {.unnumbered}  

Satır ve sütun toplamlarını eklemek için tabloyu addmargins() fonksiyonuna iletin. Bu fonksiyon hem sayılar hem de oranlar için geçerlidir.
"
```{r}
addmargins(age_by_outcome)
```

### Veri çerçevesine dönüştürmek  {.unnumbered}  

Bir tablo() nesnesini doğrudan bir veri çerçevesine dönüştürmek kolay değildir. Bir yaklaşım aşağıda gösterilmiştir:

1. tabloyu useNA = "always" değişkenini kullanmadan oluşturun. Bunun yerine forcats'tan fct_explicit_na() fonksiyonu ile NA değerlerini “(Missing)”e dönüştürün.
2. Toplamları (isteğe bağlı) addmargins() fonkisyonuna yönlendirerek ekleyin
3. Temel R fonksiyonuna tünelleme için  as.data.frame.matrix() fonksiyonunu kullanın 
4. İlk sütunun adını belirterek tabloyu rownames_to_column() tibble fonksiyonuna aktarın
5. Tabloyu istediğiniz gibi yazdırın, görüntüleyin veya dışa aktarın. Bu örnekte, Sunum için tablolar sayfasında açıklandığı gibi flextable paketinden flextable() fonksiyonu kullanılmıştır. Bu şekilde tablo RStudio görüntüleyici bölmesine HTML görüntüsü olarak yazdırılacaktır.
  

```{r, warning=F, message=F}
table(fct_explicit_na(linelist$age_cat), fct_explicit_na(linelist$outcome)) %>% 
  addmargins() %>% 
  as.data.frame.matrix() %>% 
  tibble::rownames_to_column(var = "Age Category") %>% 
  flextable::flextable()
```




<!-- ======================================================= -->

## Kaynaklar {  }

Bu sayfadaki bilgilerin çoğu şu kaynaklardan ve çevrimiçi görüntülerden uyarlanmıştır:

[gtsummary](http://www.danieldsjoberg.com/gtsummary/articles/tbl_summary.html)  

[dplyr](https://dplyr.tidyverse.org/articles/grouping.html)

```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/tables_descriptive.Rmd-->

# Basit istatistiksel testler { }


Bu sayfa, **base** R, **rstatix** ve **gtsummary** kullanılarak basit istatistiksel testlerin nasıl gerçekleştirileceğini gösterir.

* t testi
* Shapiro-Wilk testi
* Wilcoxon sıra toplamı testi
* Kruskal-Wallis testi
* Ki-kare testi
* Sayısal değişkenler arasındaki korelasyonlar

...başka birçok test yapılabilir, ancak biz sadece bu yaygın testleri göstermekteyiz ve daha fazla belgeye bağlantı vermekteyiz.

Yukarıdaki paketlerin her biri belirli avantajlar ve dezavantajlar getirir:

* İstatistiksel çıktıları R Konsoluna yazdırmak için **base** R fonksiyonlarını kullanın
* Sonuçları bir veri çerçevesinde döndürmek için veya testlerin gruplara göre yapılmasını istiyorsanız **rstatix** fonksiyonlarını kullanın
* Yayına hazır tabloları hızlı bir şekilde yazdırmak istiyorsanız **gtsummary** kullanın



<!-- ============================================= ========= -->
## Hazırlık {  }


### Paketleri yükleyin {.unnumbered}

Bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran *ve* kullanım için yükleyen **pacman**'dan `p_load()` vurgusunu yapıyoruz. **base** R'dan `library()` ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakın.

```{r}
pacman::p_load(
  rio,          # Dosyayı içe aktarma
  here,         # Dosyayı konumlama
  skimr,        # Veriye göz atma
  tidyverse,    # veri yönetimi + ggplot2 grafikleri, 
  gtsummary,    # özet istatistikler ve testler
  rstatix,      # istatistikler
  corrr,        # Sayısal değişkenler için Korelasyon analizi 
  janitor,      # Tablolara toplamı ve yüzdeleri ekleme
  flextable     # Tabloları HTML formatına dönüştürme
  )
```

### Verileri içe aktar {.unnumbered}

Simüle edilmiş bir Ebola salgınından vakaların veri setini içe aktarıyoruz. Takip etmek isterseniz, <a 
href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>"temiz" vaka listesini indirmek için tıklayınız</a>(.rds dosyası olarak). Verilerinizi **rio** paketinden `import()` fonksiyonuyla içe aktarın (.xlsx, .rds, .csv gibi birçok dosya türünü kabul eder - ayrıntılar için [İçe aktarma ve dışa aktarma] sayfasına bakın).


```{r, echo=F}
# Vaka listesini R'a aktarma
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# Vaka listesini içe aktarma
linelist <- import("linelist_cleaned.rds")
```

Vaka listesinin ilk 50 satırı aşağıda görüntülenmektedir.

```{r, message=FALSE, echo=F}
# Vaka listesini tablo olarak gösterme
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```





**base (temel)** R {}

İstatistiksel testler yapmak için **base** R fonksiyonlarını kullanabilirsiniz. Komutlar nispeten basittir ve sonuçlar basit görüntüleme için R Konsoluna yazdırılacaktır. Bununla birlikte, çıktılar genellikle listelerdir ve bu nedenle sonuçları sonraki işlemlerde kullanmak istiyorsanız manipüle edilmesi daha zordur.

### T testleri {.unnumbered}

"Student's t-Test" olarak da adlandırılan bir [t-testi](https://en.wikipedia.org/wiki/Student%27s_t-test), genellikle iki grup arasındaki bazı sayısal değişkenlerin ortalamaları arasında önemli bir fark olup olmadığını belirlemek için kullanılır. Burada, sütunların aynı veri çerçevesinde olup olmadığına bağlı olarak bu testi yapmak için sözdizimini göstereceğiz.

**Sözdizimi 1:** Bu, sayısal ve kategorik sütunlarınız aynı veri çerçevesinde olduğundaki sözdizimidir. Denklemin sol tarafında sayısal sütunu ve sağ tarafında kategorik sütunu sağlayın. Veri kümesini `data = ` olarak belirtin. İsteğe bağlı olarak, `paired = TRUE`, ve `conf.level = ` (0.95 default), ve`alternative = `("iki taraflı", "daha az" veya "daha büyük") olarak ayarlayın. Daha fazla ayrıntı için `?t.test` girin. 

```{r}
## T-testi ile grupların yaş ortalamalarını karşılaştırma
t.test(age_years ~ gender, data = linelist)
```

**Sözdizimi 2:** Bu alternatif sözdizimini kullanarak iki ayrı sayısal vektörü karşılaştırabilirsiniz. Örneğin, iki sütun farklı veri kümelerindeyse.

```{r, eval=F}
t.test(df1$age_years, df2$age_years)
```

Örneklerin ortalamasının belirli bir değerden önemli ölçüde farklı olup olmadığını belirlemek için bir t testi de kullanabilirsiniz. Burada, `mu = ` olarak bilinen/varsayımsal popülasyon ortalaması ile tek örnekli bir t-testi yapıyoruz:  

```{r, eval=F}
t.test(linelist$age_years, mu = 45)
```

### Shapiro-Wilk testi {.unnumbered}

[Shapiro-Wilk testi](https://en.wikipedia.org/wiki/Shapiro%E2%80%93Wilk_test) bir örneğin normal dağılıma sahip bir popülasyondan gelip gelmediğini belirlemek için kullanılabilir (diğer birçok testin varsayımı ve analizinde olduğu gibi, örneğin t-testi). Ancak, bu yalnızca 3 ila 5000 gözlem arasındaki bir örnek üzerinde kullanılabilir. Daha büyük numuneler için bir [quantile-quantile (Q-Q) grafiği](https://ggplot2.tidyverse.org/reference/geom_qq.html) yardımcı olabilir.


```{r, eval=F}
shapiro.test(linelist$age_years)
```

### Wilcoxon sıralama toplamı testi {.unnumbered}

[Mann–Whitney U testi](https://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U_test) olarak da adlandırılan Wilcoxon sıralama toplamı testi, genellikle iki sayısal örneğin popülasyonları normal dağılmadığında veya eşit olmayan varyansa sahip olduğunda kullanılır.

```{r wilcox_base}

## Wilcox testi ile grupların yaş dağılımını karşılaştırma
wilcox.test(age_years ~ outcome, data = linelist)

```


### Kruskal-Wallis testi {.unnumbered}


[Kruskal-Wallis testi](https://en.wikipedia.org/wiki/Kruskal%E2%80%93Wallis_one-way_analysis_of_variance), ikiden fazla örneklemin dağılımdaki farklılıklarını test etmek için kullanılabilecek Wilcoxon testinin bir uzantısıdır.  Yalnızca iki örnek kullanıldığında, Wilcoxon testiyle aynı sonuçları verir.

```{r }

## Kruskal-Wallis testi ile grupların yaş dağılımını karşılaştırma
kruskal.test(age_years ~ outcome, linelist)

```

### Ki-kare testi {.unnumbered}

[Pearson Ki-kare testi](https://en.wikipedia.org/wiki/Chi-squared_test) kategorik gruplar arasındaki önemli farklılıkları test etmek için kullanılır. 

```{r}

## Ki-kare testi ile her grubun oranlarını karşılaşırma
chisq.test(linelist$gender, linelist$outcome)

```



## **rstatix** paketi {}

**rstatix** paketi, istatistiksel testlerin çalıştırılmasını ve sonuçlarını "tünel dostu" bir çerçevede alma olanağı sunar. Sonuçlar üzerinde işlemleri gerçekleştirebilmeniz için sonuçlar, otomatik olarak bir veri çerçevesindedir. İstatistiklerin her grup için çalıştırılması ve fonksiyonlara geçirilen verileri gruplamak kolaydır.


### Özet istatistikler {.unnumbered}

`get_summary_stats()` fonksiyonu, özet istatistikleri döndürmenin hızlı bir yoludur. Veri kümenizi bu fonksiyona aktarmanız ve analiz edilecek sütunları sağlamanız yeterlidir. Hiçbir sütun belirtilmemişse, istatistikler tüm sütunlar için hesaplanır.

Varsayılan olarak, tam bir özet istatistik aralığı döndürülür: n, maks, min, medyan, %25 ile, %75 ile, IQR, medyan mutlak sapma (mad), ortalama, standart sapma, standart hata ve güven aralığı.


```{r}
linelist %>%
  rstatix::get_summary_stats(age, temp)
```

`type =` için şu değerlerden birini sağlayarak döndürülecek özet istatistiklerin bir alt kümesini belirtebilirsiniz: "full", "common", "robust", "five_number", "mean_sd", "mean_se", "mean_ci" , "median_iqr", "median_mad", "quantile", "mean", "median", "min", "max".

Her gruplama değişkeni için bir satır döndürülecek şekilde gruplandırılmış verilerle de kullanılabilir:

```{r}
linelist %>%
  group_by(hospital) %>%
  rstatix::get_summary_stats(age, temp, type = "common")
```

İstatistiksel testler yapmak için **rstatix**'i de kullanabilirsiniz:

### T-testi {.unnumbered}

Sayısal ve kategorik sütunları belirtmek için bir formül sözdizimi kullanın:

```{r}
linelist %>% 
  t_test(age_years ~ gender)
```

Veya `~ 1` kullanın ve tek örnekli bir T-testi için `mu =` belirtin. Bu grup tarafından da yapılabilir.

```{r}
linelist %>% 
  t_test(age_years ~ 1, mu = 30)
```

Uygulanabilirse, istatistiksel testler aşağıda gösterildiği gibi grup bazında yapılabilir:

```{r}
linelist %>% 
  group_by(gender) %>% 
  t_test(age_years ~ 1, mu = 18)
```

### Shapiro-Wilk testi {.unnumbered}

Yukarıda belirtildiği gibi, örneklem büyüklüğü 3 ile 5000 arasında olmalıdır.

```{r}
linelist %>% 
  head(500) %>%            # Vaka listesinin ilk 500 satırı, sadece örnek için
  shapiro_test(age_years)
```

### Wilcoxon sıralama toplamı testi {.unnumbered}

```{r}
linelist %>% 
  wilcox_test(age_years ~ gender)
```


### Kruskal-Wallis testi {.unnumbered}  

Mann-Whitney U testi olarak da bilinir.  

```{r}
linelist %>% 
  kruskal_test(age_years ~ outcome)
```


### Ki-kare testi {.unnumbered}

Ki-kare test fonksiyonu bir tablo kabul eder, bu nedenle önce bir çapraz tablo oluştururuz. Çapraz tablo oluşturmanın birçok yolu vardır (bkz. [Tanımlayıcı tablolar]) ancak burada **janitor** 'den 'tabyl()' kullanıyoruz ve 'chisq_test()'e geçmeden önce en soldaki değer etiketleri sütununu kaldırıyoruz.

```{r}
linelist %>% 
  tabyl(gender, outcome) %>% 
  select(-1) %>% 
  chisq_test()

```

**rstatix** fonksiyonları ile daha birçok fonksiyon ve istatistiksel test çalıştırılabilir. **rstatix** belgelerine [buradan çevrimiçi](https://github.com/kassambara/rstatix) veya ?rstatix girerek inceleyebilirsiniz. 




## `gtsummary` paketi {#stats_gt}

Bu paketle oluşturulmuş güzel bir tabloya istatistiksel bir testin sonuçlarını eklemek istiyorsanız **gtsummary** kullanın ([Açıklayıcı tablolar](#tbl_gt) sayfasının **gtsummary** bölümünde açıklandığı gibi) ).

'tbl_summary' ile karşılaştırmanın istatistiksel testlerinin yapılması,
Bir tabloya `add_p` fonskiyonu ve hangi testin kullanılacağını belirtir. kullanarak çoklu test için p değerlerinin düzeltilmesi mümkündür.
'add_q' işlevi. Ayrıntılar için `?tbl_summary` çalıştırın.

### Ki-kare testi {.unnumbered}

Kategorik bir değişkenin oranlarını iki grupta karşılaştırın. Kategorik bir değişkene uygulandığında 'add_p()' için varsayılan istatistiksel test, süreklilik düzeltmeli ki-kare bağımsızlık testi yapmaktır, ancak herhangi bir beklenen değer sayısı 5'in altındaysa, o zaman Fisher'ın kesin testi kullanılır.

```{r chi_gt}
linelist %>% 
  select(gender, outcome) %>%    # ilgilenilen değişkenleri tutma
  tbl_summary(by = outcome) %>%  # özet tablo oluştur ve gruplama değişkenini belirle
  add_p()                        # hangi testin gerçekleştirileceğini belirtin
```


### T testleri {.unnumbered}

İki grupta sürekli bir değişken için ortalamalardaki farkı karşılaştırın.
Örneğin, ortalama yaşı hasta sonucuna göre karşılaştırın.

```{r ttest_gt}

linelist %>% 
  select(age_years, outcome) %>%             # ilgilenilen değişkenleri tutma
  tbl_summary(                               # özet tablo üretme
    statistic = age_years ~ "{mean} ({sd})", # hangi istatistiklerin gösterileceğini belirtin
    by = outcome) %>%                        # gruplama değişkenini belirtin
  add_p(age_years ~ "t.test")                # hangi testlerin gerçekleştirileceğini belirtin


```

### Wilcoxon sıralama toplamı testi{.unnumbered}

Sürekli bir değişkenin dağılımını iki grupta karşılaştırın. Varsayılan ayar, iki grubu karşılaştırırken Wilcoxon sıra toplamı testi ve medyanı (IQR) kullanmaktır. Ancak normal dağılmayan veriler veya çoklu grupların karşılaştırılması için Kruskal-wallis testi daha uygundur.

```{r wilcox_gt}

linelist %>% 
  select(age_years, outcome) %>%                       # ilgilenilen değişkenleri tutma
  tbl_summary(                                         # özet tablo üretme
    statistic = age_years ~ "{median} ({p25}, {p75})", # hangi istatistiğin gösterileceğini belirtin (bu varsayılandır, bu nedenle kaldırılabilir)
    by = outcome) %>%                                  # gruplama değişkenini belirtin
  add_p(age_years ~ "wilcox.test")                     # hangi testin gerçekleştirileceğini belirtin (bu varsayılandır, bu nedenle parantezler boş bırakılabilir)


```
### Kruskal-wallis testi {.numbered}

Verilerin normal dağılıp dağılmadığına bakılmaksızın, sürekli bir değişkenin iki veya daha fazla gruptaki dağılımını karşılaştırın.

```{r kruskal_gt}

linelist %>% 
  select(age_years, outcome) %>%                       # ilgilenilen değişkenleri tutma
  tbl_summary(                                         # özet tablo üretme
    statistic = age_years ~ "{median} ({p25}, {p75})", # hangi istatistiğin gösterileceğini belirtin (bu varsayılandır, bu nedenle kaldırılabilir)
    by = outcome) %>%                                  # gruplama değişkenini belirtin
  add_p(age_years ~ "kruskal.test")                    # hangi testin gerçekleştirileceğini belirtin


```




<!-- ## `dplyr` package {} -->

<!-- Performing statistical tests in `dplyr` alone is very dense, again because it  -->
<!-- does not fit within the tidy-data framework. It requires using `purrr` to create -->
<!-- a list of dataframes for each of the subgroups you want to compare. See the page on [Iteration, loops, and lists] to learn about **purrr**.   -->

<!-- An easier alternative may be the `rstatix` package.  -->

<!-- ### T-tests {.unnumbered}  -->

<!-- ```{r ttest_dplyr} -->

<!-- linelist %>%  -->
<!--   ## only keep variables of interest -->
<!--   select(age, outcome) %>%  -->
<!--   ## drop those missing outcome  -->
<!--   filter(!is.na(outcome)) %>%  -->
<!--   ## specify the grouping variable -->
<!--   group_by(outcome) %>%  -->
<!--   ## create a subset of data for each group (as a list) -->
<!--   nest() %>%  -->
<!--   ## spread in to wide format -->
<!--   pivot_wider(names_from = outcome, values_from = data) %>%  -->
<!--   mutate( -->
<!--     ## calculate the mean age for the death group -->
<!--     Death_mean = map(Death, ~mean(.x$age, na.rm = TRUE)), -->
<!--     ## calculate the sd among dead  -->
<!--     Death_sd = map(Death, ~sd(.x$age, na.rm = TRUE)), -->
<!--     ## calculate the mean age for the recover group -->
<!--     Recover_mean = map(Recover, ~mean(.x$age, na.rm = TRUE)),  -->
<!--     ## calculate the sd among recovered  -->
<!--     Recover_sd = map(Recover, ~sd(.x$age, na.rm = TRUE)), -->
<!--     ## using both grouped data sets compare mean age with a t-test -->
<!--     ## keep only the p.value -->
<!--     t_test = map2(Death, Recover, ~t.test(.x$age, .y$age)$p.value) -->
<!--   ) %>%  -->
<!--   ## drop datasets  -->
<!--   select(-Death, -Recover) %>%  -->
<!--   ## return a dataset with the medians and p.value (drop missing) -->
<!--   unnest(cols = everything()) -->

<!-- ``` -->


<!-- ### Wilcoxon rank sum test {.unnumbered} -->

<!-- ```{r wilcox_dplyr} -->

<!-- linelist %>%  -->
<!--   ## only keep variables of interest -->
<!--   select(age, outcome) %>%  -->
<!--   ## drop those missing outcome  -->
<!--   filter(!is.na(outcome)) %>%  -->
<!--   ## specify the grouping variable -->
<!--   group_by(outcome) %>%  -->
<!--   ## create a subset of data for each group (as a list) -->
<!--   nest() %>%  -->
<!--   ## spread in to wide format -->
<!--   pivot_wider(names_from = outcome, values_from = data) %>%  -->
<!--   mutate( -->
<!--     ## calculate the median age for the death group -->
<!--     Death_median = map(Death, ~median(.x$age, na.rm = TRUE)), -->
<!--     ## calculate the sd among dead  -->
<!--     Death_iqr = map(Death, ~str_c( -->
<!--       quantile(.x$age, probs = c(0.25, 0.75), na.rm = TRUE),  -->
<!--       collapse = ", " -->
<!--       )), -->
<!--     ## calculate the median age for the recover group -->
<!--     Recover_median = map(Recover, ~median(.x$age, na.rm = TRUE)),  -->
<!--     ## calculate the sd among recovered  -->
<!--     Recover_iqr = map(Recover, ~str_c( -->
<!--       quantile(.x$age, probs = c(0.25, 0.75), na.rm = TRUE),  -->
<!--       collapse = ", " -->
<!--       )), -->
<!--     ## using both grouped data sets compare age distribution with a wilcox test -->
<!--     ## keep only the p.value -->
<!--     wilcox = map2(Death, Recover, ~wilcox.test(.x$age, .y$age)$p.value) -->
<!--   ) %>%  -->
<!--   ## drop datasets  -->
<!--   select(-Death, -Recover) %>%  -->
<!--   ## return a dataset with the medians and p.value (drop missing) -->
<!--   unnest(cols = everything()) -->

<!-- ``` -->

<!-- ### Kruskal-wallis test {.unnumbered} -->


<!-- ```{r kruskal_dplyr} -->

<!-- linelist %>%  -->
<!--   ## only keep variables of interest -->
<!--   select(age, outcome) %>%  -->
<!--   ## drop those missing outcome  -->
<!--   filter(!is.na(outcome)) %>%  -->
<!--   ## specify the grouping variable -->
<!--   group_by(outcome) %>%  -->
<!--   ## create a subset of data for each group (as a list) -->
<!--   nest() %>%  -->
<!--   ## spread in to wide format -->
<!--   pivot_wider(names_from = outcome, values_from = data) %>%  -->
<!--   mutate( -->
<!--     ## calculate the median age for the death group -->
<!--     Death_median = map(Death, ~median(.x$age, na.rm = TRUE)), -->
<!--     ## calculate the sd among dead  -->
<!--     Death_iqr = map(Death, ~str_c( -->
<!--       quantile(.x$age, probs = c(0.25, 0.75), na.rm = TRUE),  -->
<!--       collapse = ", " -->
<!--       )), -->
<!--     ## calculate the median age for the recover group -->
<!--     Recover_median = map(Recover, ~median(.x$age, na.rm = TRUE)),  -->
<!--     ## calculate the sd among recovered  -->
<!--     Recover_iqr = map(Recover, ~str_c( -->
<!--       quantile(.x$age, probs = c(0.25, 0.75), na.rm = TRUE),  -->
<!--       collapse = ", " -->
<!--       )), -->
<!--     ## using the original data set compare age distribution with a kruskal test -->
<!--     ## keep only the p.value -->
<!--     kruskal = kruskal.test(linelist$age, linelist$outcome)$p.value -->
<!--   ) %>%  -->
<!--   ## drop datasets  -->
<!--   select(-Death, -Recover) %>%  -->
<!--   ## return a dataset with the medians and p.value (drop missing) -->
<!--   unnest(cols = everything()) -->

<!-- ``` -->

<!-- ### Chi-squared test {.unnumbered}  -->


<!-- ```{r} -->
<!-- linelist %>%  -->
<!--   ## do everything by gender  -->
<!--   group_by(outcome) %>%  -->
<!--   ## count the variable of interest -->
<!--   count(gender) %>%  -->
<!--   ## calculate proportion  -->
<!--   ## note that the denominator here is the sum of each gender -->
<!--   mutate(percentage = n / sum(n) * 100) %>%  -->
<!--   pivot_wider(names_from = outcome, values_from = c(n, percentage)) %>%  -->
<!--   filter(!is.na(gender)) %>%  -->
<!--   mutate(pval = chisq.test(linelist$gender, linelist$outcome)$p.value) -->
<!-- ``` -->


<!-- ======================================================= -->

## Korelasyonlar

Sayısal değişkenler arasındaki korelasyon **tidyverse** kullanılarak araştırılabilir.
**corrr** paketi, Pearson Kendall kullanarak korelasyonları hesaplamanıza izin verir.
tau veya Spearman rho, Paket bir tablo oluşturur ve ayrıca
değerleri otomatik olarak çizer.

```{r, warning=F, message=F}

correlation_tab <- linelist %>% 
  select(generation, age, ct_blood, days_onset_hosp, wt_kg, ht_cm) %>%   # ilgilenilen sayısal değişkenleri tutma
  correlate()      # korelasyon tablosu oluşturma (varsayılan pearson kullanılarak)

correlation_tab    # yazdır

## Duplike girdileri kaldırma (üstteki tablo yansıtılır) 
correlation_tab <- correlation_tab %>% 
  shave()

## Korelasyon tablosunu gösterme 
correlation_tab

## korelasyon grafikleri 
rplot(correlation_tab)
```


<!-- ======================================================= -->

## Kaynaklar {  }

Bu sayfadaki bilgilerin çoğu şu kaynaklardan ve çevrimiçi gösterimlerden uyarlanmıştır:  

[gtsummary](http://www.danieldsjoberg.com/gtsummary/articles/tbl_summary.html)
[dplyr](https://dplyr.tidyverse.org/articles/grouping.html)
[corrr](https://corrr.tidymodels.org/articles/using-corrr.html)
[sthda correlation](http://www.sthda.com/english/wiki/correlation-test-between-two-variables-in-r)
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/stat_tests.Rmd-->

# Tek değişkenli ve çok değişkenli regresyon { }

<!-- ============================================= ========= -->

Bu sayfa, "glm()" ve **gtsummary** paketi gibi **base** R regresyon fonksiyonlarının kullanımını gösterir.
Değişkenler arasındaki ilişkilere bakarak bunu yapar (örneğin, odds oranları, risk oranları ve tehlike oranları). Ayrıca regresyon çıktılarını temizlemek için **broom** paketindeki 'tidy()' gibi fonksiyonları kullanır.

1. Tek değişkenli: ikiye iki tablo
2. Tabakalı: mantel-haenszel tahminleri
3. Çok değişkenli: değişken seçimi, model seçimi, final tablosu
4. Forest Grafikleri

Cox orantılı tehlike regresyonu için [Hayatta kalma analizi] sayfasına bakınız.

<span style="color: black;">**_NOT:_** *Çok değişkenli* terimini, birden fazla açıklayıcı değişken içeren bir regresyona atıfta bulunmak için kullanırız. Bu anlamda *çok değişkenli* bir model, çeşitli sonuçları olan bir regresyon olacaktır - ayrıntılar için [editoryal](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3518362/) e bakabilirsiniz </span>

<!-- ============================================= ========= -->

## Hazırlık {  }


### Paketleri yükleyin {.unnumbered}

Bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran *ve* kullanım için yükleyen **pacman**'dan `p_load()` vurgusunu yapıyoruz. **base** R'dan `library()` ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakın.

```{r}
pacman::p_load(
  rio,          # Dosyayı içe aktarma
  here,         # Dosyayı konumlama
  tidyverse,    # veri yönetimi + ggplo2 grafikleri 
  stringr,      # metin dizelerini düzenle 
  purrr,        # düzenli bir şekilde nesneler üzerinde döngü sağlama
  gtsummary,    # özet istatistikler ve testler
  broom,        # regresyonlardan elde edilen sonuçları toparlama
  lmtest,       # olasılık oranı testleri
  parameters,   # regresyonlardan elde edilen sonuçları toparlamaya alternatif
  see          # Forest grafiklerini görselleştirmeye alternatif
  )
```

### Verileri içe aktar {.unnumbered}

Simüle edilmiş bir Ebola salgınından vakaların veri setini içe aktarıyoruz. Takip etmek isterseniz, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>"clean" linelist indirmek için tıklayın</a> (.rds dosyası olarak). Verilerinizi **rio** paketinden `import()` fonksiyonuyla içe aktarın (.xlsx, .rds, .csv gibi birçok dosya türünü kabul eder - ayrıntılar için [İçe aktarma ve dışa aktarma] sayfasına bakınız). 


```{r, echo=F}
# Vaka listesini R içine aktarma
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# Vaka listesini içe aktarma
linelist <- import("linelist_cleaned.rds")
```

Vaka listesinin ilk 50 satırı aşağıda görüntülenir.

```{r, message=FALSE, echo=F}
# Vaka listesini tablo olarak gösterme
DT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T) )
```

### Temiz veri {.unnumbered}

#### Açıklayıcı değişkenleri saklayın {.unnumbered}

Açıklayıcı sütunların adlarını bir karakter vektörü olarak saklıyoruz. Buna daha sonra atıfta bulunulacaktır.  

```{r}
## ilgilenilen değişkenleri tanımlama 
explanatory_vars <- c("gender", "fever", "chills", "cough", "aches", "vomit")
```


#### 1'lere ve 0'lara dönüştür {.unnumbered}

Aşağıda, lojistik regresyon modellerinin beklentileriyle işbirliği yapmak için "evet"/"hayır", "e"/"k" ve "ölü"/"canlı" olan açıklayıcı sütunları **1/0**'a çeviriyoruz. Bunu verimli bir şekilde yapmak için, aynı anda birden çok sütunu dönüştürmek için **dplyr**'den 'across()' kullanıldı. Her sütuna uyguladığımız fonksiyon, belirtilen değerleri 1'lere ve 0'lara dönüştürmek için mantık uygulayan 'case_while()' (ayrıca **dplyr**) fonksiyonudur. [Temizleme verileri ve temel işlevler sayfasındaki](#clean_across) 'across()' ve 'case_while()' ile ilgili bölümlere bakınız

Not: "." aşağıdaki, 'cross()' tarafından işlenmekte olan sütunu temsil eder.

```{r}
## ikili değişkenleri 0/1'e dönüştür
linelist <- linelist %>%  
  mutate(across(                                      
    .cols = all_of(c(explanatory_vars, "outcome")),  ## listelenen her sütun ve "sonuç" için
    .fns = ~case_when(                              
      . %in% c("m", "yes", "Death")   ~ 1,           ## erkek, evet ve ölü'yü 1 olarak yeniden kodla
      . %in% c("f", "no",  "Recover") ~ 0,           ## kadın, hayır ve iyileşme'yi sıfır olarak kodla
      TRUE                            ~ NA_real_)    ## geri kalanını kayıp veri olarak kaydet
    )
  )

       
      
```

#### Eksik değerlere sahip satırları bırakın {.unnumbered}

Eksik değerleri olan satırları bırakmak için, **tidyr** `drop_na()` fonksiyonunu kullanabilirsiniz. Ancak, bunu yalnızca ilgilenilen sütunlarda değerleri eksik olan satırlar için yapmak istiyoruz.

Yapmamız gereken ilk şey, "explanatory_vars" vektörümüzün "age" sütununu içerdiğinden emin olmaktır ("age", yalnızca ikili değişkenler için olan önceki "case_while()" işleminde bir hata üretebilirdi). Ardından, "outcome" sütununda veya "explanatory_vars" sütunlarından herhangi birinde eksik değerleri olan satırları kaldırmak için "linelist"i "drop_na()"ya yönlendiririz.

Kodu çalıştırmadan önce, 'linelist'teki satır sayısı 'nrow(linelist)' şeklindedir.

```{r}
## açıklayıcı değişkenlere age_category ekleyin 
explanatory_vars <- c(explanatory_vars, "age_cat")

## ilgilenilen değişkenler için eksik bilgi içeren satırları bırak 
linelist <- linelist %>% 
  drop_na(any_of(c("outcome", explanatory_vars)))

```

'linelist'te' kalan satır sayısı 'nrow(linelist)' şeklindedir.


<!-- ============================================ ========= -->

## Tek değişkenli { }

Tıpkı [Açıklayıcı tablolar](https://epirhandbook.com/descriptive-tables.html) sayfasında olduğu gibi, kullandığınız senaryo hangi R paketini kullanacağınızı belirleyecektir. Tek değişkenli analiz yapmak için iki seçenek sunuyoruz:

* Sonuçları konsola hızlı bir şekilde yazdırmak için **base** R'da bulunan fonksiyonları kullanın. Çıktıları düzenlemek için **broom** paketini kullanın.
* Yayına hazır çıktıları modellemek ve almak için **gtsummary** paketini kullanın



<!-- ============================================ ========= -->

### **base** R {.unnumbered}

#### Doğrusal (Lineer) regresyon {.unnumbered}

**base** R fonskiyonu 'lm()', sayısal yanıt ile doğrusal bir ilişkiye sahip olduğu varsayılan açıklayıcı değişkenler arasındaki ilişkiyi değerlendirerek doğrusal regresyon gerçekleştirir.

Denklemi, yanıt ve açıklayıcı sütun adları yaklaşık bir "~" ile ayrılmış şekilde bir formül olarak sağlayın. Ayrıca, veri kümesini `data = ` olarak belirtin. Model sonuçlarını daha sonra kullanmak üzere bir R nesnesi olarak tanımlayın.

```{r lin_reg}
lm_results <- lm(ht_cm ~ age, data = linelist)
```

Daha sonra katsayıları (Tahminler), P-değerini, artıkları ve diğer ölçüleri görmek için model sonuçlarında "summary()" komutunu çalıştırabilirsiniz.  

```{r lin_reg_res}
summary(lm_results)
```

Alternatif olarak, **broom** paketindeki `tidy()` fonksiyonunu kullanabilirsiniz. Sonuçlar bir tabloya dönüştürülür. Sonuçlarda her yıl yaş arttıkça boy da 3.5 cm artıyor ve bu istatistiksel olarak anlamlıdır.

```{r lin_reg_res_tidy}
tidy(lm_results)
```

Daha sonra bu regresyonu bir **ggplot**'a eklemek için de kullanabilirsiniz, bunu yapmak için önce **broom**dan 'augment()' fonksiyonunu kullanarak gözlemlenen veri ve uygun çizgi için noktaları tek bir veri çerçevesine çekeriz.

```{r lin_reg_res_plot}

## regresyon noktalarını ve gözlemlenen verileri tek bir veri kümesine çekin
points <- augment(lm_results)

## x ekseni olarak yaşı kullanarak verileri grafikleştirin
ggplot(points, aes(x = age)) + 
  ## boy için noktalar koyun 
  geom_point(aes(y = ht_cm)) + 
  ## regresyon çizginizi çizin 
  geom_line(aes(y = .fitted), colour = "red")

```

Ayrıca, "geom_smooth()" fonksiyonunu kullanarak **ggplot**'a doğrudan basit bir doğrusal regresyon eklemek de mümkündür.

```{r geom_smooth}

## verinizi bir grafiğe ekleyin 
 ggplot(linelist, aes(x = age, y = ht_cm)) + 
  ## noktaları gösterin
  geom_point() + 
  ## lineer regresyon ekleyin 
  geom_smooth(method = "lm", se = FALSE)
```

Daha ayrıntılı öğreticiler için bu bölümün sonundaki Kaynak bölümüne bakabilirsiniz.


#### Lojistik regresyon {.unnumbered}

**stats** paketindeki (**base** R'ın bir parçası) 'glm()' fonksiyonu, Genelleştirilmiş Doğrusal Modellere (GLM) uymak için kullanılır.

`glm()`, tek değişkenli ve çok değişkenli lojistik regresyon için kullanılabilir (örneğin, Odds Ratio'ları elde etmek için). İşte temel parçalar:

```{r, eval=F}
# glm() için değişkenler
glm(formula, family, data, weights, subset, ...)
```

* `formül = ` Model `glm()` için bir denklem olarak sağlanır, tilde `~` nin sağında çıktısı, solunda açıklayıcı değişkenler bulunur.
* `family = ` Bu, çalıştırılacak modelin türünü belirler. Lojistik regresyon için `family= "binom"` kullanın, poisson için `family = "poisson"` kullanın. Diğer örnekler aşağıdaki tablodadır.
* `data = ` Veri çerçevenizi belirtin


Gerekirse, bağlantı işlevini `family = familytype(link = "linkfunction"))` sözdizimi aracılığıyla da belirtebilirsiniz. Diğer aileler ve 'ağırlıklar = ' ve 'alt küme = ' ('?glm') gibi isteğe bağlı bağımsız değişkenler hakkındaki belgelerde daha fazlasını okuyabilirsiniz.


Family                 |  Varsayılan bağlantı fonksiyonu
-----------------------|-------------------------------------------  
`"binomial"` | `(link = "logit")`  
`"gaussian"` | `(link = "identity")`  
`"Gamma"` | `(link = "inverse")`  
`"inverse.gaussian"` | `(link = "1/mu^2")`  
`"poisson"` | `(link = "log")`  
`"quasi"` | `(link = "identity", variance = "constant")`  
`"quasibinomial"` | `(link = "logit")`  
`"quasipoisson"` | `(link = "log")`  


`glm()` çalıştırıldığında, sonuçların adlandırılmış bir R nesnesi olarak kaydedilmesi en yaygın yöntemdir. Ardından, aşağıda gösterildiği gibi `summary()` kullanarak sonuçları konsolunuza yazdırabilir veya sonuçlar üzerinde diğer işlemleri gerçekleştirebilirsiniz ( örneğin; üstünü almak gibi).

Negatif bir binom regresyonu çalıştırmanız gerekiyorsa **MASS** paketini kullanabilirsiniz; "glm.nb()", "glm()" ile aynı sözdizimini kullanır.
Farklı regresyonların gözden geçirilmesi için [UCLA istatistik sayfasına](https://stats.idre.ucla.edu/other/dae/) bakabilirsiniz.

#### Tek değişkenli `glm()` {.unnumbered}

Bu örnekte, farklı yaş kategorileri ile ölümün sonucu arasındaki ilişkiyi değerlendiriyoruz (Hazırlık bölümünde 1 olarak kodlanmıştır). Aşağıda, "age_cat" tarafından "sonucun" tek değişkenli bir modeli verilmiştir. Model çıktısını `model` olarak kaydedip ardından `summary()` ile konsola yazdırıyoruz. Sağlanan tahminlerin *log oranları* olduğunu ve temel seviyenin "age_cat" ("0-4") birinci faktör seviyesi olduğunu unutmayınız.

```{r}
model <- glm(outcome ~ age_cat, family = "binomial", data = linelist)
summary(model)
```

Belirli bir değişkenin temel seviyesini değiştirmek için, sütunun Faktör sınıfı olduğundan emin olun ve istenen seviyeyi `fct_relevel()` ile ilk konuma taşıyın ([Faktörler] sayfasındaki sayfaya bakabilirsiniz). Örneğin, aşağıda 'age_cat' sütununu alıyoruz ve değiştirilmiş veri çerçevesini 'glm()' içine aktarmadan önce temel olarak "20-29" ayarlıyoruz.

```{r}
linelist %>% 
  mutate(age_cat = fct_relevel(age_cat, "20-29", after = 0)) %>% 
  glm(formula = outcome ~ age_cat, family = "binomial") %>% 
  summary()
```

#### Sonuçları yazdırmak {.unnumbered}

Çoğu kullanım için, yukarıdaki çıktılarda birkaç değişiklik yapılmalıdır. **broom** paketindeki 'tidy()' fonksiyonu, model sonuçlarını sunulabilir kılmak için uygundur.

Burada model çıktılarının bir sayım tablosuyla nasıl birleştirileceğini gösteriyoruz.

1) Modeli "tidy()" öğesine geçirerek ve "üssel = TRUE" ve "conf.int = TRUE" ayarını yaparak *üslü* günlük odds oranı tahminlerini ve güven aralıklarını(GA) alın.

```{r odds_base_single}

model <- glm(outcome ~ age_cat, family = "binomial", data = linelist) %>% 
  tidy(exponentiate = TRUE, conf.int = TRUE) %>%        # GA'larını üret ve üstelleştir
  mutate(across(where(is.numeric), round, digits = 2))  # tüm sayısal sütunları yuvarla
```

Çıktı alınan tibble 'model' aşağıdadır:

```{r, message=FALSE, echo=F}
# vaka listesi verisini tabloda göster
DT::datatable(model, rownames = FALSE, options = list(pageLength = nrow(model), scrollX=T), class = 'white-space: nowrap' )
```

2) Bu model sonuçlarını bir sayım tablosuyla birleştirin. Aşağıda, [Açıklayıcı tablolar] sayfasında anlatıldığı gibi, **janitor**'dan 'tabyl()' fonksiyonuyla bir sayımlar çapraz tablosunu oluşturuyoruz. 

```{r}
counts_table <- linelist %>% 
  janitor::tabyl(age_cat, outcome)
```


<!-- * Group rows by outcome, and get counts by age category   -->
<!-- * Pivot wider so the column are `age_cat`, `0`, and `1`   -->
<!-- * Remove row for `NA` `age_cat`, if applicable, to align with the model results   -->

<!-- ```{r} -->
<!-- counts_table <- linelist %>%  -->
<!--   filter(!is.na(outcome) & !is.na(age_cat)) %>%    # ensure outcome and age_cat are present  -->
<!--   group_by(outcome) %>%                            # get counts of variable of interest grouped by outcome -->
<!--   count(age_cat) %>%   ## gets number or rows by unique outcome-age category combinations   -->
<!--   pivot_wider(names_from = outcome, values_from = n)    ## spread data to wide format (as in cross-tabulation) -->

<!-- ``` -->


Bu "counts_table" veri çerçevesi şöyle görünür: 

```{r, message=FALSE, echo=F}
# vaka listesi verisini tabloda göster
DT::datatable(counts_table, rownames = FALSE, options = list(pageLength = nrow(counts_table), scrollX=T), class = 'white-space: nowrap' )
```

Şimdi 'counts_table' ve 'model' sonuçlarını 'bind_cols()' (**dplyr**) ile yatay olarak birbirine bağlayabiliriz. `bind_cols()` ile iki veri çerçevesindeki satırların mükemmel şekilde hizalanması gerektiğini unutmayın. Bu kodda, bir tünel zinciri içinde bağlı olduğumuz için, tünelli nesneyi "counts_table" olarak temsil etmek için "." kullanırız ve onu "model"e bağlarız. İşlemi bitirmek için, istenen sütunları ve sıralarını seçmek için 'select()' kullanırız ve son olarak 2 ondalık basamak belirtmek için tüm sayısal sütunlara **base** R 'round()' fonksiyonunu uygularız. 

```{r, message=F, warning=F}
combined <- counts_table %>%           # sayım tablosuyla başla
  bind_cols(., model) %>%              # regresyonun çıktıları ile birleştir 
  select(term, 2:3, estimate,          # sütunları seç ve yeniden düzenle
         conf.low, conf.high, p.value) %>% 
  mutate(across(where(is.numeric), round, digits = 2)) ## 2 basamak şeklinde yuvarla
```

Birleştirilmiş veri çerçevesinin nasıl göründüğü, **flextable** fonksiyonuyla güzel bir görüntü olarak yazdırılmıştır. [Tablolar sunum], bu tür tabloların **flextable** ile nasıl özelleştirileceğini veya **knitr** veya **GT** gibi çok sayıda başka paketin nasıl kullanılacağını açıklar.

```{r}
combined <- combined %>% 
  flextable::qflextable()
```


#### Birden çok tek değişkenli modeli döngüye alma {.unnumbered}

Aşağıda daha basit bir yaklaşım için `glm()` ve `tidy()` kullanan bir yöntem sunuyoruz, **gtsummary** bölümüne bakın.

Tek değişkenli olasılık oranları (yani birbirini kontrol etmeyen) üretmek için modelleri çeşitli maruziyet değişkenleri üzerinde çalıştırmak için aşağıdaki yaklaşımı kullanabilirsiniz. Tek değişkenli formüller oluşturmak için **stringr**'den str_c()' kullanır (bkz. )` ve son olarak **tidyr**'den `bind_rows()` ile birlikte tüm model çıktılarını daraltır. Bu yaklaşım, yineleme için **purrr** paketinden `map()` kullanır - bu araç hakkında daha fazla bilgi için [Yineleme, döngüler ve listeler] sayfasına bakın.

1) Açıklayıcı değişkenlerin sütun adlarından oluşan bir vektör oluşturun. Bunu zaten bu sayfanın Hazırlık bölümünden 'açıklayıcı_değişkenler' olarak aldık.

2) Solda "sonuç" ve sağda "açıklayıcı_değişkenler"den bir sütun adı ile birden çok dize formülü oluşturmak için "str_c()" kullanın. "." noktası, "açıklayıcı_değişkenler"deki sütun adının yerini alır.

```{r}
explanatory_vars %>% str_c("outcome ~ ", .)
```

3) Bu dizi formüllerini 'map()' öğesine iletin ve her girişe uygulanacak fonksiyon olarak '~glm()' öğesini ayarlayın. "glm()" içinde, regresyon formülünü "as.formula(.x)" olarak ayarlayın, burada ".x", yukarıdaki adımda tanımlanan dizi formülüyle değiştirilecektir. `map()`, her biri için gerilemeler çalıştırarak, dizi formüllerinin her biri üzerinde döngü yapacaktır.

4) Bu ilk 'map()' çıktıları, regresyon çıktılarına 'tidy()' uygulayan ikinci bir 'map()' komutuna iletilir.

5) Son olarak, ikinci 'map()' çıktısı (düzenlenmiş veri çerçevelerinin bir listesi) 'bind_rows()' ile yoğunlaştırılır, bu da tüm tek değişkenli sonuçları içeren bir veri çerçevesiyle sonuçlanır.


```{r odds_base_multiple}

models <- explanatory_vars %>%       # ilgilenilen değişkenlerle başla
  str_c("outcome ~ ", .) %>%         # her değişkeni formüle birleştir ("outcome ~ variable of interest")
  
  # her tek değişkenli formülü yineleyin
  map(                               
    .f = ~glm(                       # formülleri birer birer glm() öğesine iletin
      formula = as.formula(.x),      # glm() içinde, dizİ formülü .x'tir
      family = "binomial",           # glm (logistic) tipini belirle
      data = linelist)) %>%          # veri kümesi
  
  # glm regresyon çıktılarının her birini düzenleyin
  map(
    .f = ~tidy(
      .x, 
      exponentiate = TRUE,           # üstelleştirme 
      conf.int = TRUE)) %>%          # güven aralığına dönme
  
  # regresyon çıktılarının listesini bir veri çerçevesine daralt
  bind_rows() %>% 
  
  # tüm sayısal sütunları yuvarla
  mutate(across(where(is.numeric), round, digits = 2))
```

Bu sefer, son nesne 'modelleri' daha uzundur çünkü artık birkaç tek değişkenli regresyonun birleşik sonuçlarını temsil etmektedir. Tüm "model" satırlarını görmek için tıklayın.  

```{r, message=FALSE, echo=F}
# vaka listesi verilerini tabloda göster
DT::datatable(models, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Daha önce olduğu gibi, her açıklayıcı değişken için 'vaka listesi'nden bir sayım tablosu oluşturabilir, onu 'modellere' bağlayabilir ve güzel bir tablo yapabiliriz. Değişkenlerle başlıyoruz ve onları `map()` ile yineliyoruz. **dplyr** fonksiyonlarıyla bir sayım tablosu oluşturmayı içeren kullanıcı tanımlı bir fonksiyonu yineliyoruz. Daha sonra sonuçlar birleştirilir ve 'modeller' model sonuçlarıyla birleştirilir.

```{r, warning=F, message=F}

## Her açıklayıcı değişken için
univ_tab_base <- explanatory_vars %>% 
  map(.f = 
    ~{linelist %>%                ## vaka listesiyle başla
        group_by(outcome) %>%     ## veri setini çıktıya göre gruplandırma
        count(.data[[.x]]) %>%    ## ilgilenilen değişken için sayılar üret
        pivot_wider(              ## geniş formata yayılma (çapraz tablodaki gibi)
          names_from = outcome,
          values_from = n) %>% 
        drop_na(.data[[.x]]) %>%         ## eksik olan satırları bırak
        rename("variable" = .x) %>%      ## ilgili sütununun değişkenini "değişken" olarak değiştir
        mutate(variable = as.character(variable))} ## karaktere dönüştürün, aksi takdirde ikili olmayan (kategorik) değişkenler faktör olarak ortaya çıkar ve birleştirilemez
      ) %>% 
  
  ## sayım çıktılarının listesini bir veri çerçevesine daralt
  bind_rows() %>% 
  
  ## regresyon çıktıları ile birleştirme 
  bind_cols(., models) %>% 
  
  ## yalnızca ilgilenilen sütunları tutma 
  select(term, 2:3, estimate, conf.low, conf.high, p.value) %>% 
  
  ## ondalık basamakları yuvarla
  mutate(across(where(is.numeric), round, digits = 2))

```

Aşağıda veri çerçevesinin neye benzediği görülmektedir. Bu tablonun güzel HTML çıktısına nasıl dönüştürüleceği hakkında fikirler için [Tablolar] hakkındaki sayfaya bakın (ör. **flextable** ile).

```{r, message=FALSE, echo=F}
# vaka listesini tablo olarak göster
DT::datatable(univ_tab_base, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```





<!-- ======================================================= -->

### **gtsummary** paketi {#reg_gt_uni .unnumbered}

Aşağıda **gtsummary** paketinden `tbl_uvregression()` kullanımını sunuyoruz. Tıpkı [Tanımlayıcı tablolar](https://epirhandbook.com/descriptive-tables.html) sayfasındaki gibi, **gtsummary** fonksiyonları istatistikleri çalıştırmada *ve* profesyonel görünümlü çıktılar üretmede iyi bir iş çıkarır. Bu fonksiyon, tek değişkenli regresyon sonuçlarının bir tablosunu üretir.

'Vaka listesi'nden (açıklayıcı değişkenler ve sonuç değişkeni) yalnızca gerekli sütunları seçiyoruz ve bunları 'tbl_uvregression()' içine aktarıyoruz. Veri Hazırlama bölümünde 'açıklayıcı_değişkenler' olarak tanımladığımız sütunların her biri üzerinde (cinsiyet, ateş, titreme, öksürük, ağrı, kusmuk ve yaş_kedi) tek değişkenli regresyon uygulayacağız.

Fonksiyonun kendi içinde, `method =` as `glm` (tırnak işaretleri olmadan), `y =` sonuç sütununu (`outcome`) sağlarız, `family= binomial` yoluyla, lojistik regresyonu çalıştırmak istediğimizi `method.args = ` ile belirtiriz. Ve ona sonuçları üslü hale getirmesini söylüyoruz.

Çıktı HTML'dir ve sayıları içermektedir.

```{r odds_gt, message=F, warning=F}

univ_tab <- linelist %>% 
  dplyr::select(explanatory_vars, outcome) %>% ## ilgilenilen değişkenleri seç

  tbl_uvregression(                         ## tek değişkenli tablo üret
    method = glm,                           ## çalıştırmak istediğiniz regresyonu tanımlayın (genelleştirilmiş doğrusal model)
    y = outcome,                            ## sonuç değişkenini tanımlayın
    method.args = list(family = binomial),  ## ne tür bir glm çalıştırmak istediğini tanımla (lojistik)
    exponentiate = TRUE                     ## odds oranlarını üretmek için üstelleştir (logaritmik oranlar yerine)
  )

## tek değişkenli sonuç tablosunu göster 
univ_tab
```


Bu tablo çıktısında, metin etiketlerini ayarlamak, satırları p değerlerine göre kalınlaştırmak vb. gibi birçok değişiklik yapabilirsiniz. Öğreticilere [buradan](http://www.danieldsjoberg.com/gtsummary/articles/tbl_regression .html) ve başka çevrimiçi yerlerden bakabilirsiniz.



<!-- ============================================ ========= -->

## Tabakalı { }

Tabakalı analiz şu anda **gtsummary** üzerinde çalışıyor,
bu sayfa zamanı gelince güncellenecektir.




## Çok Değişkenli

Çok değişkenli analiz için yine iki yaklaşım sunuyoruz:

* `glm()` ve `tidy()`
* **gtsummary** paketi

İş akışı her biri için benzerdir ve yalnızca son tabloyu bir araya getirmenin son adımı farklıdır.


### Çok değişkenli yürütme {.unnumbered}


Burada `glm()` kullanıyoruz ama denklemin sağ tarafına artı sembolleriyle (`+`) ayırarak daha fazla değişken ekliyoruz.


Modeli tüm açıklayıcı değişkenlerimizle çalıştırmak için şunu çalıştırırız:  

```{r}
mv_reg <- glm(outcome ~ gender + fever + chills + cough + aches + vomit + age_cat, family = "binomial", data = linelist)

summary(mv_reg)
```

İki değişken ve aralarında bir etkileşim eklemek istiyorsanız, bunları "+" yerine yıldız işareti "*" ile ayırabilirsiniz. Yalnızca etkileşimi belirtiyorsanız, bunları iki nokta üst üste `:` ile ayırın. Örneğin:

```{r, eval=F}
glm(outcome ~ gender + age_cat * fever, family = "binomial", data = linelist)
```


*İsteğe bağlı olarak*, bu kodu, önceden tanımlanmış sütun adları vektöründen yararlanmak ve `str_c()` kullanarak yukarıdaki komutu yeniden oluşturmak için kullanabilirsiniz. Bu, açıklayıcı değişken adlarınız değişiyorsa veya hepsini yeniden yazmak istemiyorsanız yararlı olabilir.

```{r mv_regression}

##  ilgilenilen tüm değişkenlerle bir regresyon çalıştırın 
mv_reg <- explanatory_vars %>%  ## açıklayıcı sütun adlarının vektörüyle başlayın
  str_c(collapse = "+") %>%     ## bir artı ile ayrılmış ilgilenilen değişkenlerin tüm adlarını birleştirin
  str_c("outcome ~ ", .) %>%    ## formül stilinde sonuç ile ilgilenilen değişkenlerin adlarını birleştirin
  glm(family = "binomial",      ## glm tipini lojistik olarak tanımlayın
      data = linelist)          ## veri setinizi tanımlayın
```

#### Modeli oluşturma {.unnumbered}

Belirli açıklayıcı değişkenleri içeren çeşitli modelleri kaydederek modelinizi adım adım oluşturabilirsiniz. Bu modelleri, aşağıdaki gibi **lmtest** paketinden `lrtest()` kullanarak olasılık-oran testleri ile karşılaştırabilirsiniz:

<span style="color: black;">**_NOT:_** **base** `anova(model1, model2, test = "Chisq)` kullanılması aynı sonuçları verir </span>

```{r}
model1 <- glm(outcome ~ age_cat, family = "binomial", data = linelist)
model2 <- glm(outcome ~ age_cat + gender, family = "binomial", data = linelist)

lmtest::lrtest(model1, model2)
```

Diğer bir seçenek ise model nesnesini alıp **stats** paketinden `step()` fonksiyonunu uygulamaktır. Modeli oluştururken hangi değişken seçim yönünü kullanmak istediğinizi belirtin. 

```{r}
## AIC'ye (Akaike information criterion) dayalı ileri seçimi kullanarak bir model seçin
## yönü ayarlayarak "geri" veya "her ikisini" de yapabilirsiniz.
final_mv_reg <- mv_reg %>%
  step(direction = "forward", trace = FALSE)
```


Netlik için R oturumunuzda bilimsel gösterimi de kapatabilirsiniz:

```{r}
options(scipen=999)
```

Tek değişkenli analiz bölümünde açıklandığı gibi, log oranlarını ve GA'nı üslendirmek için model çıktısını 'tidy()' öğesine iletin. Son olarak, tüm sayısal sütunları iki ondalık basamağa yuvarlarız. Tüm satırları görmek için kaydırın.  

```{r mv_regression_base}

mv_tab_base <- final_mv_reg %>% 
  broom::tidy(exponentiate = TRUE, conf.int = TRUE) %>%  ## düzenli veri çerçevesinin tahminlerini elde edin 
  mutate(across(where(is.numeric), round, digits = 2))          ## yuvarlama 
```

Ortaya çıkan veri çerçevesi şöyle görünür:

```{r, message=FALSE, echo=F}
DT::datatable(mv_tab_base, rownames = FALSE, options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )
```





<!-- ======================================================= -->

### Tek değişkenli ve çok değişkenli birleştirme {.unnumbered}

#### **gtsummary** ile birleştirme {.unnumbered}

**gtsummary** paketi, `tbl_regression()` fonksiyonunu sağlar.
Bu paket regresyondan çıktıları alan (bu durumda `glm()`) ve güzel bir sonuç üreten özet tablodur.

```{r mv_regression_gt}
## son regresyonun sonuç tablosunu göster
mv_tab <- tbl_regression(final_mv_reg, exponentiate = TRUE)
```

Tabloyu görelim:

```{r}
mv_tab
```

**gtsummary** tarafından üretilen birkaç farklı çıktı tablosunu `tbl_merge()` fonksiyonuyla da birleştirebilirsiniz. Şimdi çok değişkenli sonuçları, oluşturduğumuz **gtsummary** *tek değişkenli* sonuçlarla birleştiriyoruz [yukarıda](#reg_gt_uni):

```{r}
## tek değişkenli sonuçlarla birleştir
tbl_merge(
  tbls = list(univ_tab, mv_tab),                          # birleştir
  tab_spanner = c("**Univariate**", "**Multivariable**")) # başlık adlarını ayarla
```



#### **dplyr**  ile birleştirme {.unnumbered}

`glm()`/`tidy()` tek değişkenli ve çok değişkenli çıktıları birleştirmenin alternatif bir yolu, **dplyr** birleştirme fonksiyonlarıdır.

* Daha önceki tek değişkenli sonuçları (sayıları içeren 'univ_tab_base') derlenmiş çok değişkenli sonuçlar 'mv_tab_base' ile birleştirebilirsiniz
* Yalnızca istediğimiz sütunları tutmak, sıralarını belirlemek ve yeniden adlandırmak için `select()` kullanabilirsiniz
* Double sınıfı olan tüm sütunlarda iki ondalık basamakla `round()` kullanabilirsiniz 

```{r, warning=F, message=F}
## tek ve çok değişkenli tabloları birleştir
left_join(univ_tab_base, mv_tab_base, by = "term") %>% 
  ## sütunları seç ve yeniden isimlendir
  select( # yeni isim =  eski isim
    "characteristic" = term, 
    "recovered"      = "0", 
    "dead"           = "1", 
    "univ_or"        = estimate.x, 
    "univ_ci_low"    = conf.low.x, 
    "univ_ci_high"   = conf.high.x,
    "univ_pval"      = p.value.x, 
    "mv_or"          = estimate.y, 
    "mvv_ci_low"     = conf.low.y, 
    "mv_ci_high"     = conf.high.y,
    "mv_pval"        = p.value.y 
  ) %>% 
  mutate(across(where(is.double), round, 2))   

```




<!-- ======================================================= -->

## Forest Grafiği{  }

Bu bölüm, regresyonunuzun çıktılarıyla bir grafiğin nasıl üretileceğini gösterir.
İki seçenek vardır, **ggplot2** kullanarak kendiniz bir grafik oluşturabilir veya **easystats** (birçok paket içeren bir paket) adlı bir meta paket kullanabilirsiniz.

**ggplot2** çizim paketine aşina değilseniz [ggplot temelleri] sayfasına bakın.


<!-- ============================================ ========= -->

### **ggplot2** paketi {.unnumbered}

Çok değişkenli regresyon sonuçlarının öğelerini çizerek `ggplot()` ile bir Forest grafiği oluşturabilirsiniz. Bu "geomları" kullanarak grafiklerin katmanlarını ekleyin:

* `geom_point()` ile tahminler
* `geom_errorbar()` ile güven aralıkları
* OR(Odds Ratio)= 1'de `geom_vline()` ile dikey bir çizgi

Çizmeden önce, y eksenindeki değişkenlerin/seviyelerin sırasını ayarlamak için **forcats** paketinden `fct_relevel()` kullanmak isteyebilirsiniz. "ggplot()", bu yaş kategorisi değerleri için iyi çalışmayan ("30", "5"ten önce görünür) alfa-sayısal sırada görüntüleyebilir. Daha fazla ayrıntı için [Faktörler] sayfasına bakın.

```{r ggplot_forest}

## kesme değerini çok değişkenli sonuçlarınızdan kaldırın
mv_tab_base %>% 
  
  #y ekseni boyunca görünecek seviyelerin sırasını ayarlayın
  mutate(term = fct_relevel(
    term,
    "vomit", "gender", "fever", "cough", "chills", "aches",
    "age_cat5-9", "age_cat10-14", "age_cat15-19", "age_cat20-29",
    "age_cat30-49", "age_cat50-69", "age_cat70+")) %>%
  
  # grafikten "kesme değeri" satırını kaldır
  filter(term != "(Intercept)") %>% 
  
  ## değişkeni y eksenine göre grafikleştir, x eksenini tahmin et(OR)
  ggplot(aes(x = estimate, y = term)) +
  
  ## tahminini nokta olarak göster
  geom_point() + 
  
  ## güven aralıkları için bir hata çubuğu ekleyin
  geom_errorbar(aes(xmin = conf.low, xmax = conf.high)) + 
  
  ## OR = 1'in referans için nerede olduğunu kesikli çizgi olarak göster
  geom_vline(xintercept = 1, linetype = "dashed")
  
```


<!-- ======================================================= -->

### **easystats** paketleri {.unnumbered}

**ggplot2**'nin sağladığı iyi düzeyde kontrolü istemiyorsanız, alternatif olarak **easystats** paketlerinin bir kombinasyonunu kullanabilirsiniz.

**parameters** paketindeki 'model_parameters()' fonksiyonu, **broom** paket işlevi 'tidy()' ile eşdeğerdir. **see** paketi daha sonra bu çıktıları kabul eder ve bir "ggplot()" nesnesi olarak varsayılan bir Forest grafiği oluşturur.

```{r easystats_forest}
pacman::p_load(easystats)
 
## kesme değerini çok değişkenli sonuçlarınızdan kaldırın 
final_mv_reg %>% 
  model_parameters(exponentiate = TRUE) %>% 
  plot()
  
```


<!-- ======================================================= -->

## Kaynaklar {  }

Bu sayfanın içeriği şu kaynaklar ve çevrimiçi gösterimlerden yararlanılarak hazırlanmıştır.

[R'da Linear regression](https://www.datacamp.com/community/tutorials/linear-regression-R)  

[gtsummary](http://www.danieldsjoberg.com/gtsummary/articles/tbl_regression.html)  

[UCLA stats sayfası](https://stats.idre.ucla.edu/other/dae/)  

[sthda stepwise regression](http://www.sthda.com/english/articles/36-classification-methods-essentials/150-stepwise-logistic-regression-essentials-in-r/)   

```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/regression.Rmd-->


# Eksik Veri { }

```{r, out.width=c("50%"), echo=F}
knitr::include_graphics(here::here("images", "missingness.png"))
knitr::include_graphics(here::here("images", "missingness_overview.png"))
```

Bu sayfada aşağıdakilerin nasıl yapılacağı anlatılacaktır:

1) Eksikliği değerlendirin
2) Eksikliğe göre satırları filtreleyin
3) Zaman içinde eksikleri çizin
4) Grafiklerde "Boş Veri"nin nasıl görüntüleneceğini ele alın
5) Eksik değer atamasını gerçekleştirin: MCAR, MAR, MNAR 



<!-- ======================================================= -->
## Hazırlık { }

### Paketleri yükleyin {.unnumbered}

Bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran *ve* kullanım için yükleyen **pacman**'dan `p_load()` vurgusunu yapıyoruz. **base** R'dan `library()` ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakabilirsiniz.

```{r}
pacman::p_load(
  rio,           # İçe aktar/Dışa aktar
  tidyverse,     # Veri yönetimi ve görselleştirme
  naniar,        # Eksikliği değerlendir ve görselleştir
  mice           # Eksik veri yerine aktarma
)
```


### Verileri içe aktar {.unnumbered}

Simüle edilmiş bir Ebola salgınından vakaların veri setini içe aktarıyoruz. Takip etmek isterseniz, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>"clean" satır listesi dosyasını indirmek için tıklayın </a> (.rds dosyası olarak). Verilerinizi **rio** paketinden `import()` fonksiyonuyla içe aktarın (.xlsx, .rds, .csv gibi birçok dosya türünü kabul eder - ayrıntılar için [İçe aktarma ve dışa aktarma] sayfasına bakabilirsiniz).

```{r, echo=F}
# Satır listesini R'a içe aktar
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# Satır listesini içe aktar
linelist <- import("linelist_cleaned.rds")
```

Satır listesinin ilk 50 satırı aşağıda görüntülenmektedir.

```{r, message=FALSE, echo=F}
# Satır listesi verisini tabloda göster
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


### İçe aktarma işleminde eksikliği dönüştürme {.unnumbered}

Verilerinizi içe aktarırken, eksik olarak sınıflandırılması gereken değerlerin farkında olun. Örneğin, 99, 999, "Eksik", boş hücreler ("") veya boşluklu hücreler (" "). Veri içe aktarma komutu sırasında bunları 'NA'ya (R'ın eksik veri sürümü) dönüştürebilirsiniz.
Tam sözdizimi dosya türüne göre değiştiğinden, ayrıntılar için [Eksik veriler](#import_missing) ile ilgili sayfanın içe aktarılmasıyla ilgili sayfaya bakın.


<!-- ============================================ ========= -->
## R'da eksik değerler { }

Aşağıda, bazı bitişik değerler ve fonksiyonlarla birlikte, R'da eksikliğin sunulma ve değerlendirilme yollarını araştırıyoruz.

### "NA" {.unnumbered}

R'da, eksik değerler 'NA' ile temsil edilir. Bunun * tırnak işaretleri olmadan * yazıldığını unutmayın. "NA" farklıdır ve sadece normal bir karakter değeridir (aynı zamanda Beatles'ın Hey Jude şarkısından bir söz).

Verilerinizin "99" veya "Eksik" veya "Bilinmeyen" gibi eksikleri temsil etmenin başka yolları olabilir - "boş" görünen boş karakter değerini "" veya tek bir boşluk " " bile olabilir. Bunların farkında olun ve [içe aktarma sırasında bunları 'NA'ya dönüştürün](#import_missing) veya 'na_if()' ile veri temizleme sırasında yapabilirsiniz.

Veri temizleme işleminizde, tüm 'NA'ları "Eksik" veya 'replace_na()'ya benzer şekilde veya faktörler için 'fct_explicit_na()' ile de değiştirmek isteyebilirsiniz.




### "NA" sürümleri {.unnumbered}

Çoğu zaman, "NA" eksik bir değeri temsil eder ve her şey yolunda gider. Ancak, bazı durumlarda, bir nesne sınıfına (karakter, sayısal, vb.) özgü "NA"nın *varyasyonları* gereksinimiyle karşılaşabilirsiniz. Bu nadiren olacak, ancak bilmenizde fayda vardır.
Bunun için tipik senaryo, **dplyr** fonksiyonu "case_while()" ile yeni bir sütun oluştururken gerçekleşmektedir. [Verileri ve temel fonksiyonları temizleme](#clean_case_while) sayfasında açıklandığı gibi, bu fonksiyon veri çerçevesindeki her satırı değerlendirir, satırların belirtilen mantıksal ölçütlerini (kodun sağ tarafı) karşılayıp karşılamadığını değerlendirir ve doğru yeni değerini atar ( kodun sol tarafı). *Önemli olan: sağ taraftaki tüm değerler aynı sınıf olmalıdır*.

```{r, eval=F}
linelist <- linelist %>% 
  
  # "Yaş" sütunundan yeni "yaş_yıl" sütununu oluştur
  mutate(age_years = case_when(
    age_unit == "years"  ~ age,       # eğer yaş yıl şeklinde verildiyse, orijinal değeri atayın
    age_unit == "months" ~ age/12,    # eğer yaş ay şeklinde verildiyse, 12'ye bölün
    is.na(age_unit)      ~ age,       # eğer yaş birimi eksikse, yılmış gibi kabul edin
    TRUE                 ~ NA_real_)) # diğer durumlarda kayıp veri olarak atayın
```

Sağ tarafta 'NA' istiyorsanız, aşağıda listelenen özel 'NA' seçeneklerinden birini belirtmeniz gerekebilir. Diğer sağ taraftaki değerler karakter ise, bunun yerine "Missing" kullanmayı düşünün veya aksi takdirde "NA_character_" kullanın. Hepsi sayısal ise, 'NA_real_' kullanın. Hepsi tarih veya mantıklıysa, 'NA' kullanabilirsiniz.

* `NA` - tarihler veya mantıksal DOĞRU/YANLIŞ için kullanın
* `NA_character_` - karakterler için kullanın
* `NA_real_` - sayısal değerler için kullanın

Yine, yeni bir sütun oluşturmak için `case_while()` kullanmıyorsanız bu varyasyonlarla karşılaşmanız pek olası değildir. Daha fazla bilgi için [NA ile ilgili R belgelerine](https://stat.ethz.ch/R-manual/R-devel/library/base/html/NA.html) bakabilirsiniz.





### 'NULL' {.unnumbered}

'NULL', R'dan ayrılmış başka bir değerdir. Bu, ne doğru ne de yanlış olan bir ifadenin mantıksal temsilidir. Değerleri tanımsız olan ifadeler veya fonksiyonlar tarafından döndürülür. Belirli senaryolarda "NULL" döndürmek için fonksiyon yazmadıkça veya belki de [**shiny** uygulaması][Shiny Panoları] yazmadıkça NULL değerini genellikle bir değer olarak atamayın.

Boşluk `is.null()` kullanılarak değerlendirilebilir ve `as.null()` ile dönüşüm yapılabilir.

"NULL" ve "NA" arasındaki farkla ilgili bu [blog gönderisine](https://www.r-bloggers.com/2010/04/r-na-vs-null/) bakabilirsiniz.




### `NaN` {.unnumbered}

İmkansız değerler "NaN" özel değeri ile temsil edilir. Bunun bir örneği, R'ı 0'ı 0'a bölmeye zorlamanızdır. Bunu `is.nan()` ile değerlendirebilirsiniz. "is.infinite()" ve "is.finite()" gibi tamamlayıcı fonksiyonlarla da karşılaşabilirsiniz.


### "Inf" {.unnumbered}

"Inf", örneğin bir sayıyı 0'a böldüğünüzde olduğu gibi sonsuz bir değeri temsil eder.

Bunun işinizi nasıl etkileyebileceğine dair bir örnek olarak: Diyelim ki şu değerleri içeren bir "z" vektörünüz/sütununuz var: "z <- c(1, 22, NA, Inf, NaN, 5)"

En yüksek değeri bulmak için sütunda 'max()' kullanmak istiyorsanız, 'NA'yı hesaplamadan çıkarmak için 'na.rm = TRUE'yu kullanabilirsiniz, ancak 'Inf' ve 'NaN' arta kalacak ve `Inf` döndürülecektir. Bunu çözmek için, hesaplamada yalnızca sonlu değerlerin kullanılacağı şekilde alt kümeler için "[ ]" ve "is.finite()" köşeli parantezlerini kullanabilirsiniz: "max(z[is.finite(z)])".

```{r, eval=F}
z <- c(1, 22, NA, Inf, NaN, 5)
max(z)                           # NA'ya döner
max(z, na.rm=T)                  # Inf'ye döner
max(z[is.finite(z)])             # 22'ye döner
```


### Örnekler {.unnumbered}  


R Komutları | Çıktısı
----------|--------------
`5 / 0` | `Inf`  
`0 / 0` | `NaN`  
`5 / NA` | `NA`  
`5 / Inf | `0`  
`NA - 5` | `NA`  
`Inf / 5` | `Inf`  
`class(NA)` | "logical"  
`class(NaN)` | "numeric"  
`class(Inf)` | "numeric"  
`class(NULL)` | "NULL"  

"Zorlamanın getirdiği NA'lar" yaygın bir uyarı mesajıdır. Bu, aksi takdirde sayısal olan bir vektöre karakter değeri eklemek gibi geçersiz bir dönüştürme yapmaya çalışırsanız olabilir.

```{r}
as.numeric(c("10", "20", "thirty", "40"))
```

Bir vektörde "NULL" yok sayılır.

```{r}
my_vector <- c(25, NA, 10, NULL)  # tanımla
my_vector                         # yazdır
```


Bir sayının varyansı "NA" ile sonuçlanır.

```{r}
var(22)
```


<!-- ======================================================= -->
## Faydalı fonksiyonları{ }

Aşağıdakiler, eksik değerleri değerlendirirken veya işlerken yararlı **base** R fonksiyonlarıdır:


### `is.na()` ve `!is.na()` {.unnumbered}

Eksik değerleri belirlemek için `is.na()` kullanın veya eksik olmayan değerleri belirlemek için tersini (önde `!` ile) kullanın. Bunların her ikisi de mantıksal bir değer ("DOĞRU" veya "YANLIŞ") döndürür. 'DOĞRU' sayısını saymak için elde edilen vektörü 'sum()' ile toplayabileceğinizi unutmayın, ör. `sum(is.na(linelist$date_outcome))`.    

```{r}
my_vector <- c(1, 4, 56, NA, 5, NA, 22)
is.na(my_vector)
!is.na(my_vector)
sum(is.na(my_vector))
```


### `na.omit()` {.unnumbered}

Bu fonksiyon, bir veri çerçevesine uygulanırsa, *herhangi bir* eksik değere sahip satırları kaldıracaktır. Aynı zamanda **base** R'dandır.
Bir vektöre uygulanırsa, uygulandığı vektörden 'NA' değerlerini kaldıracaktır. Örneğin:

```{r}
na.omit(my_vector)
```

### `drop_na()` {.unnumbered}

Bu, [veri temizleme ardışık düzeninde][Verileri ve temel fonksiyonları temizleme] yararlı olan bir **tidyr** fonksiyonudur. Parantezler boş olarak çalıştırılırsa, *herhangi bir* eksik değeri olan satırları kaldırır. Sütun adları parantez içinde belirtilirse, bu sütunlarda eksik değerlere sahip satırlar atlanır. Sütunları belirtmek için "tidyselect" sözdizimini de kullanabilirsiniz.

```{r, eval=F}
linelist %>% 
  drop_na(case_id, date_onset, age) # bu sütunlardan herhangi biri için satır eksik değerleri bırakır
```


### `na.rm = DOĞRU` {.unnumbered}

'max()', 'min()', 'sum()' veya 'mean()' gibi bir matematiksel işlevi çalıştırdığınızda, herhangi bir 'NA' değeri mevcutsa, döndürülen değer 'NA' olacaktır. Bu varsayılan davranış kasıtlıdır, böylece verilerinizden herhangi biri eksikse uyarılırsınız.

Hesaplamadan eksik değerleri kaldırarak bunu önleyebilirsiniz. Bunu yapmak için "na.rm = TRUE" bağımsız değişkenini ekleyin ("na.rm", "NA"yı kaldır" anlamına gelir).

```{r}
my_vector <- c(1, 4, 56, NA, 5, NA, 22)

mean(my_vector)     

mean(my_vector, na.rm = TRUE)
```



<!-- ======================================================= -->
## Bir veri çerçevesindeki eksikliği değerlendir { }

**naniar** paketini, "linelist" veri çerçevesindeki eksiklikleri değerlendirmek ve görselleştirmek için kullanabilirsiniz.  

```{r}
# paketi kurun ve/veya yükleyin
pacman::p_load(naniar)
```

### Eksikliği ölçme {.unnumbered}

Eksik olan tüm değerlerin yüzdesini bulmak için `pct_miss()` kullanın. Eksik değerlerin sayısını almak için `n_miss()` kullanın.

```{r}
# eksik TÜM veri çerçevesi değerlerinin yüzdesi
pct_miss(linelist)
```

Aşağıdaki iki fonksiyon, sırasıyla herhangi bir eksik değere sahip veya tamamen tamamlanmış satırların yüzdesini döndürür. "NA"nın eksik anlamına geldiğini ve ``""` veya `" "` eksik olarak sayılamayacağını unutmayın.

```{r}
# Herhangi bir değeri eksik olan satırların yüzdesi
pct_miss_case(linelist)   # sayımlar için n_complete() kullanın
```

```{r}
# Tamamlanan satırların yüzdesi (eksik değer yok)  
pct_complete_case(linelist) # sayımlar için n_complete() kullanın
```



### Eksikliği görselleştirme {.unnumbered}

`gg_miss_var()` fonksiyonu size her sütundaki eksik değerlerin sayısını (veya %) gösterecektir. Birkaç nüans:

* Gruplara göre grafiği görmek için `facet = ` değişkenlerine bir sütun adı (tırnak içinde değil) ekleyebilirsiniz.
* Varsayılan olarak, yüzdeler yerine sayılar gösterilir, bunu `show_pct = TRUE` ile değiştirin
* `+ labs(...)` ile normal bir `ggplot()` için olduğu gibi eksen ve başlık etiketleri ekleyebilirsiniz.


```{r}
gg_miss_var(linelist, show_pct = TRUE)
```

Burada veriler fonksiyona `%>%` yoluyla tünellenerek iletilir. `facet = ` değişkeni ayrıca verileri bölmek için kullanılır.

```{r}
linelist %>% 
  gg_miss_var(show_pct = TRUE, facet = outcome)
```


Veri çerçevesini her bir değerin eksik olup olmadığını gösteren bir ısı haritası olarak görselleştirmek için vis_miss()'i kullanabilirsiniz. 
Ayrıca veri çerçevesinden belirli sütunları 'select()' ile seçerek, yalnızca bu sütunların gösterilmesini sağlayabilirsiniz.

```{r}
# Tüm veri çerçevesindeki eksikliğin ısı grafiği  
vis_miss(linelist)
```


### Eksiklik ilişkilerini keşfedin ve görselleştirin {.unnumbered}

Olmayan bir şeyi nasıl görselleştirirsiniz??? Varsayılan olarak, "ggplot()" grafiklerden eksik değerlere sahip noktaları kaldırır.

**naniar**, `geom_miss_point()` aracılığıyla bir çözüm sunar. İki sütunlu bir dağılım grafiği oluştururken, değerlerden biri eksik, diğeri mevcut olan kayıtlar, eksik değerler sütundaki en düşük değerden %10 daha düşük olarak ayarlanarak ve belirgin bir şekilde renklendirilerek gösterilir.

Aşağıdaki dağılım grafiğinde kırmızı noktalar, bir sütunun değerinin mevcut olduğu ancak diğer sütunun değerinin eksik olduğu kayıtlardır. Bu, eksik değerlerin eksik olmayan değerlere göre dağılımını görmenizi sağlar.


```{r}
ggplot(
  data = linelist,
  mapping = aes(x = age_years, y = temp)) +     
  geom_miss_point()
```

Veri çerçevesindeki *başka bir sütun tarafından katmanlandırılmış* eksiklikleri değerlendirmek için, veri çerçevesindeki bir yüzdelik ısı haritasını *bir faktör/kategorik (veya tarih) sütun* ile döndüren 'gg_miss_fct()' fonksiyonu ile sağlayın:

```{r}
gg_miss_fct(linelist, age_cat5)
```


Bu fonksiyon, eksiklerin zaman içinde nasıl değiştiğini görmek için bir tarih sütunu ile de kullanılabilir:

```{r}
gg_miss_fct(linelist, date_onset)
```




### "Gölge" sütunları {.unnumbered}

Bir sütundaki eksikliği ikinci bir sütundaki değerlere göre görselleştirmenin başka bir yolu da **naniar**'ın oluşturabileceği "gölgeyi" kullanmaktır. `bind_shadow()` mevcut her sütun için bir ikili `NA`/``NA` değil` sütunu oluşturur ve tüm bu yeni sütunları "_NA" ekiyle orijinal veri kümesine bağlar. Bu, sütun sayısını iki katına çıkarır - aşağıda göreceğiniz üzere:


```{r}
shadowed_linelist <- linelist %>% 
  bind_shadow()

names(shadowed_linelist)
```

Bu "gölge" sütunlar, eksik değerlerin oranını başka bir sütuna göre çizmek için kullanılabilir.

Örneğin, aşağıdaki grafik, "days_onset_hosp" (semptom başlangıcından hastaneye yatışa kadar geçen gün sayısı) eksik kayıtların oranını, bu kaydın "tarih_hastaneye yatış" değerine göre gösterir. Esasen, x ekseni sütununun yoğunluğunu çiziyorsunuz, ancak sonuçları ('renk = ') ilgilenilen bir gölge sütunu ile katmanlıyorsunuz. Bu analiz, x ekseni bir sayısal veya tarih sütunuysa en iyi sonucu verir.


```{r, message = F}
ggplot(data = shadowed_linelist,          # gölge sütunlu veri çerçevesi
  mapping = aes(x = date_hospitalisation, # sayısal veya tarih sütunu
                colour = age_years_NA)) + # ilgi alanı gölge sütunu
  geom_density()                          # yoğunluk eğrilerini çizme
```

Bu "gölge" sütunları, aşağıda gösterildiği gibi istatistiksel bir özet oluşturmak için de kullanabilirsiniz:

```{r}
linelist %>%
  bind_shadow() %>%                # gösteri sütunlarını oluştur
  group_by(date_outcome_NA) %>%    # katmanlama için gölge sütunları
  summarise(across(
    .cols = age_years,             # hesaplamalar için ilgilenilen değişken
    .fns = list("mean" = mean,     # hesaplanacak istatistikler
                "sd" = sd,
                "var" = var,
                "min" = min,
                "max" = max),  
    na.rm = TRUE))                 # stat hesaplamaları için diğer değişkenler
```


Bir sütunun zaman içinde eksik olan değerlerinin oranını çizmenin alternatif bir yolu aşağıda gösterilmiştir. **naniar** içermez. Bu örnek, eksik olan haftalık gözlemlerin yüzdesini gösterir.

1) Verileri, gözlemlerin oranını "NA" (ve diğer ilgili değerler) ile özetleyerek yararlı bir zaman biriminde (günler, haftalar vb.) toplayın.
2) Eksik oranı `ggplot()` kullanarak bir çizgi olarak çizin.

Aşağıda, satır listesini alıyoruz, hafta için yeni bir sütun ekliyoruz, verileri haftaya göre gruplandırıyoruz ve ardından değerin eksik olduğu o haftanın kayıtlarının yüzdesini hesaplıyoruz. (not: 7 günün yüzdesini istiyorsanız, hesaplama biraz farklı olacaktır).

```{r}
outcome_missing <- linelist %>%
  mutate(week = lubridate::floor_date(date_onset, "week")) %>%   # yeni hafta sütunu oluşturun
  group_by(week) %>%                                             # satırları haftaya göre gruplayın
  summarise(                                                     # her haftayı özetleyin
    n_obs = n(),                                                  # kayıtların sayısı
    
    outcome_missing = sum(is.na(outcome) | outcome == ""),        # değeri eksik olan kayıt sayısı
    outcome_p_miss  = outcome_missing / n_obs,                    # değeri eksik kayıtların oranı
  
    outcome_dead    = sum(outcome == "Death", na.rm=T),           # ölü olarak kayıt sayısı
    outcome_p_dead  = outcome_dead / n_obs) %>%                   # ölü olarak kayıtların oranı
  
  tidyr::pivot_longer(-week, names_to = "statistic") %>%         # hafta dışındaki tüm sütunları ggplot için uzun biçime döndür
  filter(stringr::str_detect(statistic, "_p_"))                  # sadece orantı değerlerini tut
```

Sonra eksik oranı haftaya göre bir çizgi olarak çizeriz. **ggplot2** çizim paketine aşina değilseniz [ggplot temelleri] sayfasına bakabilirsiniz.

```{r, message=F, warning=F}
ggplot(data = outcome_missing)+
    geom_line(
      mapping = aes(x = week, y = value, group = statistic, color = statistic),
      size = 2,
      stat = "identity")+
    labs(title = "Weekly outcomes",
         x = "Week",
         y = "Proportion of weekly records") + 
     scale_color_discrete(
       name = "",
       labels = c("Died", "Missing outcome"))+
    scale_y_continuous(breaks = c(seq(0,1,0.1)))+
  theme_minimal()+
  theme(legend.position = "bottom")
```





<!-- ======================================================= -->
## Eksik değerlere sahip verileri kullanma


### Eksik değerlere sahip satırları filtreleyin {.unnumbered}

Eksik değerlere sahip satırları hızla kaldırmak için **dplyr** `drop_na()` fonksiyonunu kullanın.

Orijinal 'linelist', 'nrow(linelist)' satırlarına sahiptir. Ayarlanan satır sayısı aşağıda gösterilmiştir:

```{r}
linelist %>% 
  drop_na() %>%     # HERHANGİ eksik değerleri olan satırları kaldırın
  nrow()
```

Belirli sütunlarda eksik olan satırların bırakılmasını belirtebilirsiniz:

```{r}
linelist %>% 
  drop_na(date_onset) %>% # date_onset eksik satırları kaldırın
  nrow()
```

Sütunları arka arkaya listeleyebilir veya ["tidyselect" yardımcı işlevlerini](#clean_tidyselect) kullanabilirsiniz:

```{r}
linelist %>% 
  drop_na(contains("date")) %>% # herhangi bir "tarih" sütununda satır eksik değerleri kaldırın 
  nrow()
```



<!-- ======================================================= -->
### `ggplot()` içindeki `NA`yı işleme {.unnumbered}

Bir başlıktaki bir çizimden hariç tutulan değerlerin sayısını bildirmek genellikle akıllıca olur. Aşağıda bir örnek verilmiştir:

'ggplot()' içinde, 'labs()' ve içine bir 'caption = ' ekleyebilirsiniz. Altyazıda, değerleri bir cümleye dinamik olarak yapıştırmak için **stringr** paketinden `str_glue()` kullanabilirsiniz, böylece verilere uyum sağlarlar. Bir örnek aşağıdadır:

* Yeni bir satır için `\n` kullanımına dikkat edin.
* Birden fazla sütun, çizilmeyen değerlere katkıda bulunacaksa (örneğin, çizimde yaş veya cinsiyet yansıtılıyorsa), gösterilmeyen sayıyı doğru bir şekilde hesaplamak için bu sütunları da filtrelemeniz gerektiğini unutmayın.

```{r, eval=F}
labs(
  title = "",
  y = "",
  x = "",
  caption  = stringr::str_glue(
  "n = {nrow(central_data)} from Central Hospital;
  {nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown."))  
```

Bazen, "ggplot()" komutundan önceki komutlarda dizeyi bir nesne olarak kaydetmek ve "str_glue()" içindeki adlandırılmış dize nesnesine başvurmak daha kolay olabilir.


<!-- ======================================================= -->
###  Faktörlerde "NA" {.unnumbered} 

İlgilendiğiniz sütun bir faktörse, "NA" değerlerini bir karakter değerine dönüştürmek için **forcats** paketinden "fct_explicit_na()" kullanın. [Faktörler] sayfasında daha fazla ayrıntıya bakabilirsiniz. Varsayılan olarak, yeni değer "(Eksik)" şeklindedir ancak bu, `na_level =` değişkeni ile ayarlanabilir.

```{r}
pacman::p_load(forcats)   # paketi yükle

linelist <- linelist %>% 
  mutate(gender = fct_explicit_na(gender, na_level = "Missing"))

levels(linelist$gender)
```



<!-- ======================================================= -->
## Atama { }


Bazen, verilerinizi analiz ederken, "boşlukları doldurmak" ve eksik verileri eklemek önemli olabilir. Tüm eksik değerleri çıkardıktan sonra bir veri kümesini her zaman basitçe analiz edebilirsiniz. Ancak bu, birçok yönden sorunlara neden olabilir. İşte iki örnek:

1) Eksik değerlere sahip tüm gözlemleri veya büyük miktarda eksik veriye sahip değişkenleri kaldırarak, bazı analiz türlerini yapma gücünüzü veya yeteneğinizi azaltabilirsiniz. Örneğin, daha önce keşfettiğimiz gibi, linelist veri kümemizdeki gözlemlerin yalnızca küçük bir kısmında tüm değişkenlerimizde eksik veri yoktur. Veri setimizin çoğunu kaldırırsak, çok fazla bilgi kaybederiz! Ve değişkenlerimizin çoğunda bir miktar eksik veri var - çoğu analiz için çok fazla verisi olan her değişkeni bırakmak da muhtemelen makul değildir.

2) Verilerinizin neden eksik olduğuna bağlı olarak, yalnızca eksik olmayan verilerin analizi yanlı veya yanıltıcı sonuçlara yol açabilir. Örneğin, daha önce öğrendiğimiz gibi, bazı hastaların ateş veya öksürük gibi bazı önemli semptomları olup olmadığına ilişkin verileri kaçırıyor olabiliriz. Ancak, bir olasılık olarak, belki de bu bilgi çok hasta olmayan insanlar için kaydedilmemiştir. Bu durumda, bu gözlemleri kaldırmış olsaydık, veri kümemizdeki en sağlıklı insanlardan bazılarını hariç tutmuş olurduk ve bu gerçekten herhangi bir sonucu saptırabilirdi.

Ne kadarının eksik olduğunu görmenin yanı sıra verilerinizin neden eksik olabileceğini düşünmek de önemlidir. Bunu yapmak, eksik verileri yüklemenin ne kadar önemli olabileceğine ve ayrıca sizin durumunuzda hangi eksik verileri yükleme yönteminin en iyi olabileceğine karar vermenize yardımcı olabilir.

### Eksik veri türleri {.unnumbered}

İşte üç genel eksik veri türü:

1) **Rastgele Tamamen Eksik** (MCAR). Bu, verilerin eksik olma olasılığı ile verilerinizdeki diğer değişkenlerden herhangi biri arasında bir ilişki olmadığı anlamına gelir. Eksik olma olasılığı tüm durumlarda aynıdır. Bu nadir görülen bir durumdur. Ancak, verilerinizin MCAR olduğuna inanmak için güçlü bir nedeniniz varsa, yalnızca eksik olmayan verileri empoze etmeden analiz ediyorsa, sonuçlarınızı etkilemeyecektir (ancak biraz güç kaybedebilirsiniz). [TODO: MCAR için istatistiksel testleri tartışmayı düşünün]

2) **Rastgele Eksik** (MAR). Bu isim aslında biraz yanıltıcıdır, çünkü MAR, sahip olduğunuz diğer bilgilere dayanarak verilerinizin sistematik, öngörülebilir bir şekilde eksik olduğu anlamına gelir. Örneğin, belki de veri setimizde eksik bir ateş değeri olan her gözlem aslında kaydedilmemiştir çünkü üşüyen ve ağrıyan her hastanın sadece ateşi olduğu varsayıldığından ateşleri hiç ölçülmemiştir. Eğer doğruysa, titreme ve ağrılı her eksik gözlemin de bir ateşi olduğunu kolayca tahmin edebilir ve bu bilgiyi eksik verilerimizi değerlendirmek için kullanabiliriz. Uygulamada, bu daha çok bir spektrumdur. Belki bir hastada hem üşüme hem de ağrı varsa, ateşi ölçülmediyse de ateşi olma olasılığı daha yüksekti, ama her zaman değil. Mükemmel bir şekilde öngörülebilir olmasa bile yine de öngörülebilir. Yaygın bir eksik veri türüdür.

3) **Rastgele Eksik Değil** (MNAR veya NMAR). Bu, bir değerin eksik olma olasılığının sistematik OLMADIĞINI veya sahip olduğumuz diğer bilgiler kullanılarak öngörülebilir olmadığını, ancak rastgele olarak da eksik olmadığını varsayar. Bu durumda, bilinmeyen veya hakkında bilgi sahibi olmadığınız nedenlerden dolayı veriler eksiktir. Örneğin, veri setimizde yaşla ilgili bilgiler eksik olabilir, çünkü bazı çok yaşlı hastalar kaç yaşında olduklarını ya bilmiyorlar ya da söylemeyi reddediyorlardır. Bu durumda, yaşa ilişkin eksik veriler, değerin kendisiyle ilgilidir (ve dolayısıyla rastgele değildir) ve sahip olduğumuz diğer bilgilere dayanarak tahmin edilebilir değildir. MNAR karmaşıktır ve çoğu zaman bununla başa çıkmanın en iyi yolu, verilerin neden eksik olduğu hakkında daha fazla veri veya bilgi toplamaya çalışmaktır.

Genel olarak, MCAR verilerini empoze etmek genellikle oldukça basittir, MNAR ise imkansız değilse de çok zordur. Yaygın veri atama yöntemlerinin çoğu MAR'ı varsayar.

### Faydalı paketler {.unnumbered}

Eksik verileri yüklemek için bazı yararlı paketler Mmisc, missForest (eksik verileri yüklemek için rastgele forestları kullanır) ve MICE'dir (Multivariate Imputation by Chained Equations- Zincirli Denklemlerle Çok Değişkenli Tahminleme). Bu bölüm için sadece çeşitli teknikleri uygulayan MICE paketini kullanacağız. MICE paketi üreticisi, burada daha fazla ayrıntıya giren eksik verilerin empoze edilmesi hakkında bir çevrimiçi kitap yayınlamıştır (https://stefvanbuuren.name/fimd/).

Fare paketini yüklemek için kod:

```{r}
pacman::p_load(mice)
```

### Ortalama Atama {.unnumbered}

Bazen basit bir analiz yapıyorsanız veya MCAR'ı varsayabileceğinizi düşünmek için güçlü bir nedeniniz varsa, eksik sayısal değerleri o değişkenin ortalamasına kolayca ayarlayabilirsiniz. Belki de veri setimizde eksik olan sıcaklık ölçümlerinin ya MCAR olduğunu ya da sadece normal değerler olduğunu varsayabiliriz. Veri kümemizdeki eksik sıcaklık değerlerini ortalama sıcaklık değeriyle değiştiren yeni bir değişken oluşturma kodu burada. Bununla birlikte, birçok durumda verileri ortalamayla değiştirmek yanlılığa neden olabilir, bu nedenle kullanırken dikkatli olun.

```{r}
linelist <- linelist %>%
  mutate(temp_replace_na_with_mean = replace_na(temp, mean(temp, na.rm = T)))
```

Kategorik verileri belirli bir değerle değiştirmek için de benzer bir işlem yapabilirsiniz. Tüm gözlemlerin çıktılarının eksik verili olmasına karşın ("Ölüm" veya "İyileşme" olabilir) ölümlerden oluştuğunu bildiğinizi farz edin (not: bu aslında bu veri kümesi için doğru değildir):

```{r}
linelist <- linelist %>%
  mutate(outcome_replace_na_with_death = replace_na(outcome, "Death"))
```

### Regresyon ataması {.unnumbered}

Biraz daha gelişmiş bir yöntem, eksik bir değerin ne olabileceğini tahmin etmek için bir tür istatistiksel model kullanmak ve bunu tahmin edilen değerle değiştirmektir. Burada, sıcaklığın eksik olduğu, ancak yaş ve ateşin olmadığı tüm gözlemler için, tahmin edici olarak ateş durumu ve yaş kullanılarak basit doğrusal regresyon kullanılarak tahmin değerleri oluşturmaya bir örnek verilmiştir. Pratikte bu tür basit yaklaşımlardan daha iyi bir model kullanmak istersiniz.

```{r, warning=F, message=F}
simple_temperature_model_fit <- lm(temp ~ fever + age_years, data = linelist)

#sadece sıcaklığın eksik olduğu gözlemler için değerleri tahmin etmek için basit sıcaklık modelimizi kullanma
predictions_for_missing_temps <- predict(simple_temperature_model_fit,
                                        newdata = linelist %>% filter(is.na(temp))) 
```

Veya, eksik sıcaklık gözlemleri için emsal değerler oluşturmak üzere MICE paketi aracılığıyla aynı modelleme yaklaşımını kullanarak:

```{r}
model_dataset <- linelist %>%
  select(temp, fever, age_years)  

temp_imputed <- mice(model_dataset,
                            method = "norm.predict",
                            seed = 1,
                            m = 1,
                            print = F)

temp_imputed_values <- temp_imputed$imp$temp

```


Bu, eksik verileri tahmin edilen değerlerle değiştirmek için missForest paketini kullanmak gibi bazı daha gelişmiş yöntemlerle aynı türde bir yaklaşımdır. Bu durumda, tahmin modeli doğrusal bir regresyon yerine random forest'tir. Bunu yapmak için diğer model türlerini de kullanabilirsiniz. Bununla birlikte, bu yaklaşım MCAR altında iyi çalışsa da, MAR veya MNAR'ın durumunuzu daha doğru tanımladığına inanıyorsanız biraz dikkatli olmalısınız. Tahmininizin kalitesi, tahmin modelinizin ne kadar iyi olduğuna bağlı olacaktır ve çok iyi bir modelde bile, empoze edilen verilerinizin değişkenliği iyi tahmin edilemeyebilir.

### LOCF ve BOCF {.unnumbered}

İleriye taşınan son gözlem (Last observation carried forward- LOCF) ve ileriye taşınan temel gözlem (Baseline observation carried forward-BOCF), zaman serisi/boylamsal veriler için değerlendirme yöntemleridir. Buradaki fikir, eksik verilerin yerine önceki gözlenen değeri almaktır. Art arda birden fazla değer eksik olduğunda, yöntem en son gözlenen değeri arar.

**tidyr** paketindeki `fill()` fonksiyonu hem LOCF hem de BOCF ataması için kullanılabilir (ancak, **HMISC**, **zoo** ve **data.table** gibi diğer paketler ayrıca bunu yapmak için yöntemler içerir). `fill()` sözdizimini göstermek için 2000 ve 2001 yıllarının her çeyreği için bir hastalık vakalarının sayısını içeren basit bir zaman serisi veri seti oluşturacağız. Ancak, Q1'den sonraki çeyrekler için yıl değeri eksik olduğundan onları saymamız gerekecek. 'fill()' bağlantısı [Pivoting data] sayfasında da gösterilmektedir.

```{r}
# basit veri setimizi oluşturmak
disease <- tibble::tribble(
  ~quarter, ~year, ~cases,
  "Q1",    2000,    66013,
  "Q2",      NA,    69182,
  "Q3",      NA,    53175,
  "Q4",      NA,    21001,
  "Q1",    2001,    46036,
  "Q2",      NA,    58842,
  "Q3",      NA,    44568,
  "Q4",      NA,    50197)

# eksik yıl değerlerinin ataması:
disease %>% fill(year)

```

Not: `fill()` fonskiyonunu kullanmadan önce verilerinizin doğru şekilde sıralandığından emin olun. `fill()` varsayılan olarak "aşağı" doldurma şeklindedir, ancak `.direction` parametresini değiştirerek değerleri farklı yönlere de uygulayabilirsiniz. Yıl değerinin yalnızca yılın sonunda kaydedildiği ve önceki çeyrekler için eksik olduğu benzer bir veri seti yapabiliriz:

```{r}
# biraz farklı veri kümemizi oluşturmak
disease <- tibble::tribble(
  ~quarter, ~year, ~cases,
  "Q1",      NA,    66013,
  "Q2",      NA,    69182,
  "Q3",      NA,    53175,
  "Q4",    2000,    21001,
  "Q1",      NA,    46036,
  "Q2",      NA,    58842,
  "Q3",      NA,    44568,
  "Q4",    2001,    50197)

# eksik yıl değerlerini "yukarı" yönde atamak:
disease %>% fill(year, .direction = "up")

```

Bu örnekte, LOCF ve BOCF açıkça yapılması gereken doğru şeylerdir, ancak daha karmaşık durumlarda bu yöntemlerin uygun olup olmadığına karar vermek daha zor olabilir. Örneğin hastanede yatan bir hasta için ilk günden sonra eksik laboratuvar değerleriniz olabilir. Bazen bu, laboratuvar değerlerinin değişmediği anlamına gelebilir... ama aynı zamanda hastanın iyileştiği ve değerlerinin ilk günden sonra çok farklı olacağı anlamına da gelebilir! Bu yöntemleri dikkatli kullanın.


### Çoklu Atama {.unnumbered}

MICE paketinin yazarı tarafından daha önce bahsettiğimiz çevrimiçi kitap (https://stefvanbuuren.name/fimd/), birden fazla değerlemenin ayrıntılı bir açıklamasını ve neden kullanmak isteyeceğinizi içermektedir. Ancak, işte yöntemin temel bir açıklaması:

Birden çok atama yaptığınızda, eksik değerlerin makul veri değerlerine atfedildiği birden çok veri kümesi oluşturursunuz (araştırma verilerinize bağlı olarak, bu atfedilen veri kümelerinden daha fazlasını veya daha azını oluşturmak isteyebilirsiniz, ancak MICE paketi varsayılan sayıyı 5'e ayarlar). Aradaki fark, her bir empoze edilen değerin tek, belirli bir değerden ziyade tahmini bir dağılımdan çekilmesidir (bu nedenle bir miktar rastgelelik içerir). Sonuç olarak, bu veri kümelerinin her biri biraz farklı emsal değerlere sahip olacaktır (ancak, eksik olmayan veriler bu empoze edilen veri kümelerinin her birinde aynı olacaktır). Bu yeni veri kümelerinin her birinde atama yapmak için hala bir tür tahmine dayalı model kullanıyorsunuz (MICE *Tahmini Ortalama Eşleştirme*, *lojistik regresyon* ve *random forest* dahil olmak üzere birçok tahmin yöntemi seçeneği vardır) ancak MICE paketinin modelleme detaylarına dikkat etmelisiniz.

Ardından, bu yeni atfedilen veri kümelerini oluşturduktan sonra, bu yeni empoze edilmiş veri kümelerinin her biri için yapmayı planladığınız istatistiksel modeli veya analizi uygulayabilir ve 
modellerin sonuçlarını bir araya toplayabilirsiniz. Bu, hem MCAR hem de birçok MAR ayarındaki yanlılığı azaltmak için çok iyi çalışır ve genellikle daha doğru standart hata tahminleriyle sonuçlanır.

Burada, bir yaş ve ateş durumu (yukarıdaki basitleştirilmiş model_veri kümemiz) kullanarak satır listesi veri kümemizdeki sıcaklığı tahmin etmek için Çoklu Atama işleminin uygulanmasına bir örnek verilmiştir:

```{r}
# model_dataset'imizdeki tüm değişkenler için eksik değerler atamak ve 10 yeni atanmış veri kümesi oluşturmak
multiple_imputation = mice(
  model_dataset,
  seed = 1,
  m = 10,
  print = FALSE) 

model_fit <- with(multiple_imputation, lm(temp ~ age_years + fever))

base::summary(mice::pool(model_fit))
```

Burada MICE'nin standart yöntemi Tahmini Ortalama Eşleştirme yöntemini kullandık. Daha sonra, bu veri kümelerinin her birinde basit doğrusal regresyonlardan elde edilen sonuçları ayrı ayrı tahmin etmek ve havuzlamak için bu emsal veri kümelerini kullandık. Üzerinde durduğumuz birçok ayrıntı ve MICE paketini kullanırken Çoklu Atama  işlemi sırasında ayarlayabileceğiniz birçok ayar vardır. Örneğin, her zaman sayısal verileriniz olmaz ve başka atama yöntemlerini kullanmanız gerekebilir (diğer birçok veri ve yöntem türü için MICE paketini kullanmaya devam edebilirsiniz). Ancak, eksik veriler önemli bir sorun olduğunda daha sağlam bir analiz için, Çoklu Atama iyi bir çözümdür ancak, her zaman tam bir vaka analizi yapmaktan daha fazla işe yaramaz.





<!-- ======================================================= -->
## Kaynaklar { }

Kılavuz [naniar package](https://cran.r-project.org/web/packages/naniar/vignettes/getting-started-w-naniar.html)

Galeri [missing value visualizations](https://cran.r-project.org/web/packages/naniar/vignettes/naniar-visualisation.html)

[Çevrimiçi kitap](https://stefvanbuuren.name/fimd/) R'da birden fazla değer atama hakkında MICE paketi yaratıcısının kitabı
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/missing_data.Rmd-->


# Standardize edilmiş hızlar { }  

Bu sayfa, hastaneye yatış veya ölüm oranları gibi bir çıktıyı yaş ve cinsiyet gibi özelliklere göre standardize etmenin iki yolunu gösterecektir. 

* **dsr** paketini kullanma
* **PHEindicatormethods** paketini kullanma 

Birden fazla ülkeden nüfus verileri, standart nüfus verileri, ölümler vb. birleştirilmesi için yaygın kullanımı olduğu için, veri hazırlama/temizleme/birleştirme süreçlerini kapsamlı bir şekilde göstererek başlıyoruz.

## Genel bakış  

Standardizasyonun iki ana yöntemi vardır: Direkt ve indirekt standardizasyon.
A ve B ülkeleri için ölüm hızlarını yaşa ve cinsiyete göre standardize etmek ve bu ülkeler arasındaki standardize edilmiş oranları karşılaştırmak istediğimizi varsayalım.

* Direk standardizasyon için, A ülkesi ve B ülkesi için her yaş ve cinsiyet tabakası için risk altındaki popülasyon büyüklüğüve ölümlerin sayısını bilmeniz gerekecektir. Örneğimizdeki bir katman 15-44 yaş arası kadınlar olabilir. 
* İndirekt standardizasyon için, her ülkenin toplam ölüm sayısı, yaş ve cinsiyet yapısını bilmeniz gerekir. Dolayısıyla bu seçenek, yaşa ve cinsiyete özgü ölüm hızları veya nüfus sayıları mevcut değilse uygulanabilir. Direkt standardizasyondaki tahminler örneklem varyasyonundan etkileneceğinden; tabaka başına küçük sayıların olması durumunda indirekt standardizasyon tercih edilir.  

<!-- ======================================================= -->
## Hazırlık {  }

Standardizasyonun nasıl yapıldığını göstermek için, A ve B ülkelerinin yaşa (5 yıllık tabakalar halinde) ve cinsiyete (kadın, erkek) göre kurgusal nüfus büyüklükleri ve ölüm sayımlarını kullanacağız. Veri setlerini kullanıma hazır hale getirmek için aşağıdaki hazırlık adımlarını gerçekleştireceğiz:  

1. Paketlerin yüklenmesi  
2. Veri tabanlarının yüklenmesi 
3. İki ülkenin nüfus ve ölüm verilerini birleştirilmesi
4. Yaş-cinsiyet katmanı başına bir satır olacak şekilde daha uzun şekilde pivotlama
5. Referans popülasyonunu (dünya standart nüfusu) temizleme ve ülke verilerine ekleme 

Senaryonuzda, verileriniz farklı bir biçimde gelebilir. Belki verileriniz il, şehir veya başka bir hizmet alanına göre düzenlenmiştir. Her ölüm için bir satır ve bu ölümlerin her biri (veya önemli bir kısmı) için yaş ve cinsiyet bilgileri olabilir. Bu durumda, yaş-cinsiyet katmanlarına göre olay ve nüfus sayıları içeren bir veri tabanı oluşturmak için [Verileri gruplandırma], [Verileri pivotlama] ve [Tanımlayıcı tablolar] sayfalarına bakın.

Ayrıca bir referans popülasyona, standart popülasyona ihtiyacımız vardır. Bu alıştırma için `world_standard_population_by_sex`'i kullanacağız. Dünya standart nüfusu, 46 ülkenin nüfusuna dayanmaktadır ve 1960 yılında geliştirilmiştir. Birçok “standart” popülasyon vardır - bir örnek olarak, [NHS İskoçya'nın web sitesi](https://www.opendata.nhs.scot/dataset/standard-populations) Avrupa Standart Nüfusu, Dünya Standart Nüfusu ve İskoçya Standardı hakkında detaylı  bilgi içermektedir. (European Standard Population, World Standard Population and Scotland Standard Population).

<!-- ======================================================= -->
### Paketlerin yüklenmesi {.unnumbered}

Bu kod kümesi, analizler için gereken paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen **pacman**'ın `p_load()` fonksiyonunu vurguluyoruz. Ayrıca, R tabanından `library()` ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R’ın temelleri] sayfasına bakın.

```{r}
pacman::p_load(
     rio,                 # verileri içe/dışa aktar
     here,                # dosyaları bul
     tidyverse,           # veri yönetimi ve görselleştirme
     stringr,             # karakterleri ve dizeleri (string) temizleme
     frailtypack,         # frailty modelleri için dsr için gerekli
     dsr,                 # hızları standardize et
     PHEindicatormethods) # hızların  standardizasyonu için alternatif
```


<span style="color: orange;">**DİKKAT:_** Daha yeni bir R sürümüne sahipseniz, **dsr** paketi doğrudan CRAN'den indirilemez. Ancak, yine de bu paket CRAN arşivinden temin edilebilir. Bu şekilde paketi yükleyebilir ve kullanabilirsiniz. </span>

Mac kullanıcısı olmayanlar için:  

```{r, eval=F} 
packageurl <- "https://cran.r-project.org/src/contrib/Archive/dsr/dsr_0.2.2.tar.gz"
install.packages(packageurl, repos=NULL, type="source")
```

```{r, eval=FALSE}
# Diğer çözüm
require(devtools)
devtools::install_version("dsr", version="0.2.2", repos="http:/cran.us.r.project.org")
```

Mac kullanıcıları için:  

```{r, eval=FALSE}
require(devtools)
devtools::install_version("dsr", version="0.2.2", repos="https://mac.R-project.org")
```




### Popülasyon verisinin yüklenmesi {.unnumbered}  

El kitabındaki tüm örnek verilerin nasıl indirileceğine ilişkin talimatlar için [Verilerin ve el kitabının indirilmesi] sayfasına bakın. Aşağıdaki `import()` komutlarını çalıştırarak Standardizasyon sayfası verilerini Github depomuzdan doğrudan R'a aktarabilirsiniz:  

```{r, eval=F}
# A ülkesi için demografik veriyi doğrudan Github'dan içe aktarın
A_demo <- import("https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics.csv")

# A ülkesi için ölümleri doğrudan Github'dan içe aktarın
A_deaths <- import("https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryA.csv")

# B ülkesi için demografik veriyi doğrudan Github'dan içe aktarın
B_demo <- import("https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics_2.csv")

# B ülkesi için ölümleri doğrudan Github'dan içe aktarın
B_deaths <- import("https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryB.csv")

# B ülkesi için demografik veriyi doğrudan Github'dan içe aktarın
standard_pop_data <- import("https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/world_standard_population_by_sex.csv")

```


İlk önce karşılaştıracağımız iki ülke olan “Ülke A” ve “Ülke B” için demografik verileri (5 yıllık yaş kategorisine göre kadın ve erkek sayıları) yüklüyoruz.  

```{r, echo=F}
# A ülkesi
A_demo <- rio::import(here::here("data", "standardization", "country_demographics.csv")) %>% 
     mutate(Country = "A") %>% 
     select(Country, everything()) %>% # re-arrange
     mutate(age_cat5 = str_replace_all(age_cat5, "\\+", "")) # remove + symbols
```

```{r, eval=F}
# A ülkesi
A_demo <- import("country_demographics.csv")
```

```{r message=FALSE, echo=F}
DT::datatable(A_demo, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


```{r, echo=F}
# B ülkesi
B_demo <- rio::import(here::here("data", "standardization", "country_demographics_2.csv")) %>% 
     mutate(Country = "B") %>% 
     select(Country, everything()) # re-arrange
```

```{r, eval=F}
# B ülkesi
B_demo <- import("country_demographics_2.csv")
```

```{r message=FALSE, echo=F}
DT::datatable(B_demo, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```





### Ölüm sayılarının yüklenmesi {.unnumbered}  

Elimizde uygun bir şekilde, ilgilenilen zaman dilimindeki yaş ve cinsiyete göre ölüm sayıları da bulunmaktadır. Her ülkenin ölüm sayıları aşağıda gösterilen ayrı bir dosyadadır.   

```{r, echo=F}
A_males <- c(224, 257, 251, 245, 334, 245, 154, 189, 334, 342, 565, 432, 543, 432, 245, 543, 234, 354) # A Ülkesindeki erkekler
B_males <- c(34, 37, 51, 145, 434, 120, 100, 143, 307, 354, 463, 639, 706, 232, 275, 543, 234, 274) # B Ülkesindeki erkekler
A_females <- c(194, 254, 232, 214, 316, 224, 163, 167, 354, 354, 463, 574, 493, 295, 175, 380, 177, 392) # A Ülkesindeki kadınlar
B_females <- c(54, 24, 32, 154, 276, 254, 123, 164, 254, 354, 453, 654, 435, 354, 165, 432, 287, 395) # B Ülkesindeki kadınlar

age_cat5 <- c("0-4", "5-9", "10-14", "15-19", "20-24", "25-29",  "30-34", "35-39", "40-44",
                                                                                "45-49", "50-54", "55-59",
                                                                                "60-64", "65-69", "70-74",
                                                                                "75-79", "80-84", "85")
A_deaths <- data.frame(Country = "A", AgeCat = age_cat5, Male = A_males, Female = A_females)
B_deaths <- data.frame(Country = "B", AgeCat = age_cat5, Male = B_males, Female = B_females)
```

A Ülkesindeki Ölümler
```{r message=FALSE, echo=F}
DT::datatable(A_deaths, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

B Ülkesindeki Ölümler

```{r message=FALSE, echo=F}
DT::datatable(B_deaths, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


```{r, echo=F}
rio::export(A_deaths, here::here("data", "standardization", "deaths_countryA.csv"))
rio::export(B_deaths, here::here("data", "standardization", "deaths_countryB.csv"))
```



### Nüfus ve ölüm verilerinin temizliği {.unnumbered}  


Bu verileri aşağıdaki şekillerde birleştirmemiz ve dönüştürmemiz gerekiyor:

* Ülke popülasyonlarını tek bir veri tabanında birleştirin ve her bir yaş-cinsiyet katmanının bir satır olması için "uzun" şekilde pivotlayın
* Ülke ölüm sayılarını tek bir veri tabanında birleştirin ve her bir yaş-cinsiyet katmanının bir satır olması için "uzun" şekilde pivotlayın
* Ölümleri nüfusla birleştirin

İlk olarak, ülke popülasyonları veri tabanlarını birleştirip, daha sonra uzun biçimde pivotlar ve temizlik yaparız. Daha fazla ayrıntı için [Verilerin pivotlanması] sayfasına bakın. 

```{r}
pop_countries <- A_demo %>%  # A ülkesi veritabanı ile başla
     bind_rows(B_demo) %>%        # Satırları B veri tabanıyla bağla, çünkü sütunlar aynı şekilde adlandırılır
     pivot_longer(                       # uzun şekilde pivotlama
          cols = c(m, f),                   # birleştirilecek sütunlar
          names_to = "Sex",                 # kategoriyi ("m" veya "f") içeren yeni sütunun adı 
          values_to = "Population") %>%     # özetlenen sayısal değerleri içeren yeni sütunun adı
     mutate(Sex = recode(Sex,            # anlaşılması için değerleri yeniden kodla
          "m" = "Male",
          "f" = "Female"))
```

Birleşik nüfus verileri şimdi şöyle görünür (A ve B ülkelerini görmek için tıklayın):

```{r message=FALSE, echo=F}
DT::datatable(pop_countries, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Şimdi de iki ölüm veri setinde benzer işlemler yapıyoruz.

```{r}
deaths_countries <- A_deaths %>%    # A ülkesi ölüm veritabanı ile başlayın
     bind_rows(B_deaths) %>%        # Satırları B veri tabanıyla bağla, çünkü sütunlar aynı şekilde adlandırılır
     pivot_longer(                  # uzun şekilde pivotlama
          cols = c(Male, Female),        # birleştirilecek sütunlar
          names_to = "Sex",              # kategoriyi ("m" veya "f") içeren yeni sütunun adı
          values_to = "Deaths") %>%      # özetlenen sayısal değerleri içeren yeni sütunun adı
     rename(age_cat5 = AgeCat)      # anlaşılması için değerleri yeniden kodla
```

Ölüm verileri şimdi böyle görünüyor ve her iki ülkeden de veriler içermekte: 

```{r message=FALSE, echo=F}
DT::datatable(deaths_countries, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Şimdi `Country`, `age_cat5` ve `Sex` ortak sütunlarına dayalı ölüm ve nüfus verilerini birleştiriyoruz. Bu işlem, `Deaths` sütununu ekler.

```{r}
country_data <- pop_countries %>% 
     left_join(deaths_countries, by = c("Country", "age_cat5", "Sex"))
```

Artık `Sex`, `age_cat5` ve `Country`'yi faktör olarak sınıflandırabilir ve [Faktörler] sayfasında açıklandığı gibi **forcats** paketinden `fct_relevel()` fonksiyonunu kullanarak seviye sırasını ayarlayabiliriz. Unutulmamalıdır ki, faktör seviyelerinin sınıflandırılması verileri gözle görülür şekilde değiştirmez, ancak `arrange()` komutu verileri ülkeye, yaş kategorisine ve cinsiyete göre sıralar.

```{r, warning=F, message=F}
country_data <- country_data %>% 
  mutate(
    Country = fct_relevel(Country, "A", "B"),
      
    Sex = fct_relevel(Sex, "Male", "Female"),
        
    age_cat5 = fct_relevel(
      age_cat5,
      "0-4", "5-9", "10-14", "15-19",
      "20-24", "25-29",  "30-34", "35-39",
      "40-44", "45-49", "50-54", "55-59",
      "60-64", "65-69", "70-74",
      "75-79", "80-84", "85")) %>% 
          
  arrange(Country, age_cat5, Sex)

```

```{r message=FALSE, echo=F}
DT::datatable(country_data, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

<span style="color: orange;">**_DİKKAT:_** Her tabakada az sayıda ölüm varsa, yaşa göre 5 yıllık kategoriler yerine 10 veya 15 yıllık kategorileri kullanmayı düşünün.</span>



### Referans popülasyonun yüklenmesi {.unnumbered}  

Son olarak, direkt  standardizasyon için referans popülasyonu (cinsiyete göre dünya “standart nüfusu”) içe aktarıyoruz.

```{r, echo=F}
# Referans popülasyon
standard_pop_data <- rio::import(here::here("data", "standardization", "world_standard_population_by_sex.csv")) %>% 
     rename(age_cat5 = AgeGroup)
```

```{r, eval=F}
# Referans popülasyon
standard_pop_data <- import("world_standard_population_by_sex.csv")
```

```{r message=FALSE, echo=F}
DT::datatable(standard_pop_data, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```



<!-- ======================================================= -->
### Referans popülasyon verisinin temizliği {.unnumbered}

`country_data` ve `standard_pop_data` veri çerçevelerindeki yaş kategorisi değerlerinin hizalanması gerekir.  

Şu anda, `standart_pop_data` veri çerçevesinden `age_cat5` sütununun değerleri "yıllar" ve "artı" kelimelerini içerirken `country_data` veri çerçevesindeki sütun bu kelimeleri içermemektedir. Yaş kategorisi değerlerini eşleştirmemiz gerekecek. Bu kalıpları boşluksuz olarak `""` biçiminde değiştirmek için [Karakterler ve dizeler] sayfasında açıklandığı gibi **stringr** paketinden `str_replace_all()` komutunu kullanıyoruz.

Ayrıca, **dsr** paketi standart popülasyonda sayıları içeren sütunun `"pop"` olarak adlandırılmasını bekler. Bu yüzden bu sütunu bu şekilde yeniden adlandırıyoruz.

```{r}
# Sütun değerlerinden belirli dizeyi kaldır
standard_pop_clean <- standard_pop_data %>%
     mutate(
          age_cat5 = str_replace_all(age_cat5, "years", ""),   # "year"'ı kaldır
          age_cat5 = str_replace_all(age_cat5, "plus", ""),    # "plus"'ı kaldır
          age_cat5 = str_replace_all(age_cat5, " ", "")) %>%   # " " boşluğu kaldır
     
     rename(pop = WorldStandardPopulation)   # dsr paketi tarafından tanınması için sütun adını "pop" olarak değiştir
```

<span style="color: orange;">**_DİKKAT:_** Bir artı *sembolünü* kaldırmak için `str_replace_all()` kullanmayı denerseniz, özel bir sembol olduğu için çalışmayacaktır. `str_replace_call(column, "\\+", "")` örneğinde olduğu gibi önüne iki ters eğik çizgi koyarak özel özelliklerden kaçınabilirsiniz.</span>

### Standart popülasyon ile veri tabanının oluşturulması {#standard_all .unnumbered}  

Son olarak, [aşağıda](#standard_phe) ayrıntıları verilen **PHEindicatormethods** paketi, ülke için gerçekleşen olay (ölüm), nüfus sayıları ve standart popülasyon verilerini istemektedir. Bu amaçla bir `all_data` veri tabanı oluşturacağız.

```{r}
all_data <- left_join(country_data, standard_pop_clean, by=c("age_cat5", "Sex"))
```

Tam veri tabanı bu şekilde görülmektedir:  

```{r message=FALSE, echo=F}
DT::datatable(all_data, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```



<!-- ======================================================= -->
## **dsr** paketi {  }

Aşağıda, **dsr** paketini kullanarak direkt standardize edilmiş hızları hesaplamayı ve karşılaştırmayı gösteriyoruz. **dsr** paketi, direkt standardize edilmiş hızları hesaplamanıza ve karşılaştırmanıza olanak tanır (indirekt standardize edilmiş oranlar yok!).

Veri Hazırlama bölümünde ülkeler ve standart nüfus için ayrı ayrı veri tabanları oluşturduk:

1) Ülke için tabaka başına nüfus ve ölüm sayısını içeren bir nüfus tablosu olan `country_data` nesnesi
2) Referans popülasyonumuz olan World Standard Population için tabaka başına popülasyonu gösteren içeren `standard_pop_clean` nesnesi 

Bu ayrı veri tabanlarını **dsr** yaklaşımı için kullanacağız.  


<!-- ======================================================= -->
### Standardize edilmiş hızlar {.unnumbered}

Aşağıda, yaş ve cinsiyet için direkt standardize edilmiş oranları ülkeler için hesaplıyoruz. Bu işlem için `dsr()` fonksiyonunu kullanıyoruz.

Not: `dsr()`, ülke popülasyonları ve olay sayıları (ölümler) için bir veri tabanı *ve* referans popülasyonu için **ayrı bir** veri tabanı bekler. Ayrıca bu referans popülasyon veri tabanında birim-zaman sütun adının “pop” olmasını bekler (bunu veri Hazırlama bölümünde sağladık)

Aşağıdaki kodda görüldüğü gibi bu fonksiyon için birçok argüman vardır. Dikkat çekici bir şekilde, `event =` ölümler sütununa ve `fu =` ("follow up"- “takip”), `Population` sütununa ayarlanmıştır. Karşılaştırma alt gruplarını `Country` sütunu olarak belirledik ve `age_cat5` ve `Sex`'e göre standardize ettik. Bu son iki sütuna belirli bir argüman atanmaz. Ayrıntılar için `?dsr` komutuna bakınız.

```{r, warning=F, message=F}
# Yaş ve cinsiyet için direkt standardize edilmiş hızları ülke başına hesapla
mortality_rate <- dsr::dsr(
     data = country_data,  # tabaka başına ölüm sayısını içeren nesneyi belirt
     event = Deaths,       # tabaka başına ölüm sayısını içeren sütun
     fu = Population,      # tabaka başına nüfus sayısını içeren sütun
     subgroup = Country,   # karşılaştırmak istediğimiz birimler
     age_cat5,             # standardize etmek istediğimiz özellikler
     Sex,
     refdata = standard_pop_clean, # pop olarak adlandırılan sütundaki sayılarla referans popülasyonu
     method = "gamma",      # 95% güven aralığını hesaplayan yöntem
     sig = 0.95,            # anlamlılık düzeyi
     mp = 100000,           # 100.000 kişilik nüfus başına hız istiyoruz
     decimals = 2)          # ondalık basamak sayısı


# Çıktıyı iyi görünen bir HTML tablosu olarak yazdır
knitr::kable(mortality_rate) # direkt standardizasyondan önce ve sonra ölüm oranını göster
```

Yukarıda, A ülkesinin B ülkesinden daha düşük bir kaba ölüm hızına sahip olduğunu, ancak yaş ve cinsiyet için direkt standardizasyon sonrası, A ülkesinin daha yüksek bir standardize edilmiş hıza sahip olduğunu görüyoruz.


<!-- ======================================================= -->
### Standardize hız oranları {.unnumbered}

```{r,warning=F, message=F}
# Calculate RR
mortality_rr <- dsr::dsrr(
     data = country_data, # tabaka başına ölüm sayısını içeren nesneyi belirt
     event = Deaths,      # tabaka başına ölüm sayısını içeren sütun
     fu = Population,     # tabaka başına nüfus sayısını içeren sütun
     subgroup = Country,  # karşılaştırmak istediğimiz birimler
     age_cat5,
     Sex,                 # standardize istediğimiz özellikler
     refdata = standard_pop_clean, # pop olarak adlandırılan sütundaki sayılarla referans popülasyonu
     refgroup = "B",      # karşılaştırma için referans
     estimate = "ratio",  # tahmin tipi
     sig = 0.95,          # anlamlılık seviyesi
     mp = 100000,         # 100.000 kişilik nüfus başına hız istiyoruz
     decimals = 2)        # ondalık basamak sayısı

# Tabloyu yazdır
knitr::kable(mortality_rr) 
```

Standardize ölüm oranı, A ülkesinde B ülkesine kıyasla 1,22 kat daha yüksektir (%95 GA 1,17-1,27).

<!-- ======================================================= -->
### Standardize hız farkı {.unnumbered}

```{r, warning=F, message=F}
# Calculate RD
mortality_rd <- dsr::dsrr(
     data = country_data,       # tabaka başına ölüm sayısını içeren nesneyi belirt
     event = Deaths,            # tabaka başına ölüm sayısını içeren sütun 
     fu = Population,           # tabaka başına nüfus sayısını içeren sütun
     subgroup = Country,        # karşılaştırmak istediğimiz birimler
     age_cat5,                  # standardize istediğimiz özellikler
     Sex,                        
     refdata = standard_pop_clean, # pop olarak adlandırılan sütundaki sayılarla referans popülasyonu
     refgroup = "B",            # karşılaştırma için referans
     estimate = "difference",   # tahmin tipi
     sig = 0.95,                # anlamlılık seviyesi
     mp = 100000,               # 100.000 kişilik nüfus başına hız istiyoruz
     decimals = 2)              # ondalık basamak sayısı

# Tabloyu yazdır
knitr::kable(mortality_rd) 
```

A Ülkesi, B ülkesine kıyasla 100.000 nüfus başına 4.24 ek ölüme (%95 GA 3.24-5.24) sahiptir.




<!-- ======================================================= -->
## **PHEindicatormethods** paketi {#standard_phe  }

Standardize hızları hesaplamanın başka bir yolu da **PHEindicatormethods** paketidir. Bu paket, direkt ve indirekt olarak standardize edilmiş hızları hesaplamanıza olanak tanır. İkisini de göstereceğiz.

Bu bölüm, Hazırlık bölümünün sonunda oluşturulan `all_data` veri tabanını kullanacaktır. Bu veri tabanı, ülke popülasyonlarını, ölüm olaylarını ve dünya için standart referans popülasyonu içerir. [Burada](#standard_all) görüntüleyebilirsiniz.


<!-- ======================================================= -->
### Direkt standardize edilmiş hızlar {.unnumbered}

Aşağıda, önce verileri ülkeye göre gruplandırıyoruz ve ardından ülke başına direkt standardize edilmiş hızları elde etmek için `phe_dsr()` fonksiyonuna aktarıyoruz.

Not: Referans (standart) popülasyon, **ülkeye özgü veri tabanında bir sütun** olarak veya **ayrı bir vektör** olarak verilebilir. Ülkeye özel veri tabanı oluşturulduysa, `stdpoptype= "field"` olarak ayarlanmalıdır. Vektör olarak sağlanmışsa, `stdpoptype = "vector"` olarak ayarlanmalıdır. İkinci durumda, kayıtlar pozisyona göre eşleştirileceğinden, satırların tabaklara göre sıralamasının hem ülkeye özgü veri tabanında hem de referans popülasyonda benzer olduğundan emin olmalısınız. Aşağıdaki örneğimizde, ülkeye özgü veri tabanında bir sütun olarak referans popülasyon verilmiştir.

Daha fazla bilgi için `?phr_dsr` ile ilgili yardıma veya Referanslar bölümündeki bağlantılara bakabilirsiniz

```{r}
# yaş ve cinsiyet için direkt standardize edilmiş hızları ülke başına hesapla
mortality_ds_rate_phe <- all_data %>%
     group_by(Country) %>%
     PHEindicatormethods::phe_dsr(
          x = Deaths,                 # gözlemlenen olay sayısını içeren sütun
          n = Population,             # her tabaka için standart olmayan nüfusu içeren sütunlar
          stdpop = pop,               # her tabaka için standart popülasyonlar
          stdpoptype = "field")       # bağımsız bir vektör için "vector-vektör" veya verilerde standart popülasyonların olduğu durumlarda "field-alan"

# Tabloyu yazdır
knitr::kable(mortality_ds_rate_phe)
```

<!-- ======================================================= -->
### İndirekt standardize edilmiş hızlar {#standard_indirect .unnumbered}

İnidirekt standardizasyon için, tabaka başına ölüm sayısı, nüfus ve bir referans popülasyona ihtiyacınız vardır. Bu örnekte, `standart_pop_clean` referans popülasyonu tabaka başına ölüm sayısını içermediğinden, *B ülkesini referans popülasyon* olarak kullanarak A ülkesi için hızları hesaplayacağız.

Aşağıda, önce B ülkesinden referans popülasyonu oluşturuyoruz. Ardından, A ülkesi için ölüm ve nüfus verilerini çıkarıyoruz, bu verileri referans popülasyonla birleştiriyoruz ve indirekt standardize edilmiş hızları elde etmek için `phe_isr()` fonksiyonuna aktarıyoruz. Tabii ki, bunun tersini de yapabilirsiniz.

Not: Aşağıdaki örneğimizde, referans popülasyonu ayrı bir veri tabanı olarak verilmiştir. Bu durumda, kayıtlar pozisyona göre eşleştirileceğinden, `x =`, `n =`, `x_ref =` ve `n_ref =` vektörlerinin tümünün, ülkemize özgü veri tabanıyla aynı standardizasyon kategorisi (tabaka) değerlerine göre sıralandığından emin oluruz.

Daha fazla bilgi için `?phr_isr` komutu ile ilgili yardıma veya Referanslar bölümündeki bağlantılara bakın.  

```{r}
# Referans popülasyonu oluştur
refpopCountryB <- country_data %>% 
  filter(Country == "B") 

# A ülkesi için yaş ve cinsiyete göre indirekt standardize edilmiş hızları hesapla
mortality_is_rate_phe_A <- country_data %>%
     filter(Country == "A") %>%
     PHEindicatormethods::phe_isr(
          x = Deaths,                 # gözlemlenen olay sayısını içeren sütun
          n = Population,             # her tabaka için standardize edilmemiş popülasyonu içeren sütunlar
          x_ref = refpopCountryB$Deaths,  # her tabaka için referans ölüm sayısı
          n_ref = refpopCountryB$Population)  # her tabaka için referans popülasyon

# Tabloyu yazdır
knitr::kable(mortality_is_rate_phe_A)
```

<!-- ======================================================= -->
## Kaynaklar {  }

**dsr** paketini kullanarak başka bir tekrarlanabilir örnek görmek isterseniz, lütfen [bu skece]( https://mran.microsoft.com/snapshot/2020-02-12/web/packages/dsr/vignettes/dsr.html) bakın.

**PHEindicatormethods** paketini kullanan başka bir örnek için lütfen [bu web sitesine](https://mran.microsoft.com/snapshot/2018-10-22/web/packages/PHEindicatormethods/vignettes/IntroductiontoPHEindicatormethods.html) gidin.

**PHEindicatormethods** referans [pdf dosyasına](https://cran.r-project.org/web/packages/PHEindicatormethods/PHEindicatormethods.pdf) bakın. 


```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/standardization.Rmd-->


# Hareketli ortalamalar { }  

```{r, out.width=c("100%"), echo=F}
knitr::include_graphics(here::here("images", "moving_avg_epicurve.png"))
```


Bu sayfa, hareketli ortalamaları hesaplamak ve görselleştirmek için iki yöntemi kapsayacaktır: 

1) **slider** paketi ile hesaplama
2) **tidyquant* paketi ile `ggplot()` komutu *içinde* hesaplama  



<!-- ======================================================= -->
## Hazırlık {  }

### Paketleri yükleme {.unnumbered}

Bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini göstermektedir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen **pacman**'ın `p_load()` fonksiyonunu öneriyoruz. Ayrıca, R tabanından `library()` ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] sayfasına bakın.


```{r}
pacman::p_load(
  tidyverse,      # verinin yönetimi ve görselleştirilmesi için
  slider,         # hareketli ortalamaları hesaplamak için
  tidyquant       # ggplot içinde hareketli ortalamaları hesaplamak için
)
```


### Verinin içe aktarımı {.unnumbered}

Simüle edilmiş Ebola salgını vakalarını içeren veri setini içe aktarıyoruz. Takip etmek istiyorsanız, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>“temiz” satır listesini</a> (.rds dosyası olarak) indirmek için tıklayın. **rio** paketinden `import()` fonksiyonu ile verileri içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için İçe Aktarma ve Dışa Aktarma sayfasına bakın).  


```{r, echo=F}
# satır listesini içe aktar
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# satır listesini içe aktar
linelist <- import("linelist_cleaned.xlsx")
```

Satır listesinin ilk 50 satırı aşağıda görüntülenir.

```{r, message=FALSE, echo=F}
# satırlistesini tablo olarak göster
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


<!-- ======================================================= -->
## **slider** ile hesaplama {  }

**Grafik haline getirmeden önce bir veri çerçevesinde hareketli ir ortalama hesaplamak için bu yaklaşımı kullanın.**  

**slider** paketi, yuvarlanan ortalamaları, kümülatif toplamları, yuvarlanan regresyonları vb. hesaplamak için "kayan pencere" fonksiyonu içerir. Bir veri çerçevesini bir satır vektörü olarak ele alır ve bir veri çerçevesi üzerinde satır bazında yinelemelere izin verir.

Ortak fonksiyonlardan bazıları:  

* `slide_dbl()` - kayan pencere kullanarak işlem gerçekleştiren *sayısal* bir sütunu yineler (dolayısıyla "_dbl")
  * `slide_sum()` - `slide_dbl()` için yuvarlanan toplam kısayol fonksiyonu  
  * `slide_mean()` - `slide_dbl()` için yuvarlanan ortalama kısayol fonksiyonu
* `slide_index_dbl()` - pencere ilerlemesini *indekslemek* için ayrı bir sütun kullanarak; yuvarlanan pencereyi sayısal bir sütuna uygular (bazı tarihler eksikken tarihe göre yuvarlanıyorsa kullanışlıdır) 
  * `slide_index_sum()` - indeksleme ile birlikte yuvarlanan toplam kısayol fonksiyonu  
  * `slide_index_mean()` - indekslemeli yuvarlanan ortalama kısayol fonksiyonu
  
**slider** paketi, bu sayfada Kaynaklar bölümünde ele alınan birçok başka fonkisyona da sahiptir. En yaygın olanlara kısaca değineceğiz.

**Temel argümanlar**  

* Varsayılan ilk argüman olan `.x`, yinelenecek ve fonksiyonu uygulayacak vektördür.
* `.i` = **slider** fonksiyonların "indeks" versiyonları için - geçişi "indekslemek" için bir sütun oluşturur [aşağıdaki bölüme bakın](#roll_index)) 
* `.f = `, varsayılan ikinci argüman;
  * `Ortalama` gibi parantezsiz yazılmış bir fonksiyon veya 
  * Bir fonksiyona dönüştürülecek bir formül. Örneğin `~ .x - ortalama(.x)`, mevcut değerden pencerenin değerinin ortalamasını hesaplar ve elde edilen sonucu sunar.
* Daha fazla ayrıntı için bu [kaynak materyaline bakın](https://davisvaughan.github.io/slider/reference/slide.html)



**Pencere büyüklüğü**  

`.before`, `.after` veya her iki argümanı kullanarak pencerenin boyutunu belirtin: 

* `.before = ` - Bir tamsayı verin  
* `.after = ` - Bir tamsayı verin  
* `.complete = ` - Yalnızca eksiksiz pencerelerde hesaplama yapılmasını istiyorsanız bunu `DOĞRU` olarak ayarlayın

Örneğin, mevcut değeri ve önceki altı değeri içeren 7 günlük bir pencere elde etmek için `.before = 6` argümanını kullanın. “Ortalanmış” bir pencere elde etmek için hem `.before =` hem de `.after =` için aynı sayıyı sağlayın.

Varsayılan olarak, `.complete = FALSE` olarak kodlanmıştır, bu nedenle tam satır penceresi mevcut değilse, fonksiyonlar hesaplamayı gerçekleştirmek için mevcut satırları kullanacaktır. Bu argümanı `DOĞRU` olarak ayarlamak, hesaplamaların yalnızca eksiksiz pencerelerde gerçekleştirilmesini sağlar. 

**Pencerenin genişletilmesi**  

*Kümülatif* işlemleri gerçekleştirmek için, `.before =` argümanını `Inf` olarak ayarlayın. Bu argüman, işlemi mevcut değerde ve daha önceki değerlerde yürütecektir.




### Tarihe göre yuvarlama {#roll_index .unnumbered}  

Uygulamalı epidemiyolojide yuvarlanan hesaplamanın en olası kullanım durumu, *zaman içinde* değişim gösteren bir ölçümün incelenmesidir (Örnek: Günlük vaka sayılarına dayalı olarak vaka insidansının yuvarlanan bir ölçümü)

Her tarih için değer içeren temiz bir zaman serisi veriniz varsa, burada [Zaman Serisi ve Salgın Tespiti](#timeseries_moving) sayfasında gösterildiği gibi `slide_dbl()` fonksiyonunu kullanabilirsiniz.

Bununla birlikte, birçok epidemiyoloji uygulamasında, kaydedilen hiçbir olayın gerçekleşmediği, verilerinizde eksik tarihler olabilir. Bu durumlarda, **slider** fonksiyonların "indeks" sürümlerini kullanmak doğrudur.


### İndekslenmiş veri {.unnumbered}  

Aşağıda, vaka satır listesinde `slide_index_dbl()` fonksiyonunu kullanan bir örnek gösterilmiştir. Diyelim ki hedefimiz 7 günlük bir insidansı hesaplamak (7 günlük bir pencere kullanarak vakaların toplamını göstermek). Yuvarlanan ortalama örneği için, [gruplandırılmış yuvarlanma](#roll_slider_group) ile ilgili aşağıdaki bölüme bakın.

Başlamak için, **dplyr**'den `count()` fonksiyonu ile hesaplandığı gibi, `satır listesinde` günlük vaka sayılarını göstermek için `daily_counts` veri kümesi oluşturulur.

```{r}
# günlük sayımların veri kümesini oluştur
daily_counts <- linelist %>% 
  count(date_hospitalisation, name = "new_cases")
```

`daily_counts` veri çerçevesinden `nrow(daily_counts)` satır elde edilebilir. Günlük vaka sayısında her gün bir satırla temsil edilmektedir, ancak özellikle salgının başlarında *bazı günler mevcut değil (o günlerde vaka tespit edilmemiştir)*.

```{r, echo=F}
DT::datatable(daily_counts, rownames = FALSE, options = list(pageLength = 6, scrollX=T) )
```

Standart bir yuvarlanma işlevinin (`slide_dbl()` gibi) 7 *günlük* değil 7 *satırlık* bir pencere kullanacağını bilmek önemlidir. Dolayısıyla, eksik tarihler varsa, bazı pencereler aslında 7 takvim gününden daha fazla uzatılacaktır!

`slide_index_dbl()` ile "akıllı" bir yuvarlanma penceresi elde edilebilir. "İndeks", işlevin yuvarlanan pencere için "indeks" olarak alacağı *ayrı bir sütun* kullandığı anlamına gelir. Pencere sadece veri çerçevesinin satırlarına bağlı değildir.

İndeks sütunu bir tarihse, pencere içeriğini **lubridate** `days()` veya `month()` fonksiyonları ile `.before =` ve/veya `.after =` olarak belirtebilirsiniz.  Bu durumda fonksiyon, pencerede olmayan günleri sanki oradaymış gibi (`NA` değerleri olarak) kabul edecektir.

Bir karşılaştırma gösterilirse. Aşağıda, düzenli ve indekslenmiş pencerelerle 7 günlük vaka insidansını hesaplıyoruz.


```{r}
rolling <- daily_counts %>% 
  mutate(                                # yeni sütunlar oluştur
    # Using slide_dbl()
    ###################
    reg_7day = slide_dbl(
      new_cases,                         # new_cases üzerinde hesapla
      .f = ~sum(.x, na.rm = T),          # fonksiyon, eksik değerler kaldırılmış sum() işlemidir
      .before = 6),                      # pencere mevcut SATIR ve 6 önceki SATIR
    
    # slide_index_dbl() kullanımı
    #########################
    indexed_7day = slide_index_dbl(
        new_cases,                       # new_cases üzerinde hesapla
        .i = date_hospitalisation,       # date_onset ile indekse eklenme 
        .f = ~sum(.x, na.rm = TRUE),     # fonksiyon, eksik değerlerin olmadığı sum() işlevidir
        .before = days(6))               # pencere mevcut GÜN ve 6 önceki GÜN
    )

```

İlk 7 satır için normal sütunda, *satırlar birbirine için 7 günlük aralık içinde olmamasına rağmen* istikrarlı artışı gözlemleyin! Komşu "indekslenmiş" sütun, eksik takvim günlerini de hesaba katar, bu nedenle 7 günlük toplamları, vakaların birbirlerinden daha uzak zamanlarda görüldüğü salgın döneminde çok daha düşüktür.

```{r, echo=F}
DT::datatable(rolling, rownames = FALSE, options = list(pageLength = 12, scrollX=T) )
```

Bu veri, `ggplot()` fonksiyonu  kullanılarak grafik haline getirilebilir.

```{r}
ggplot(data = rolling)+
  geom_line(mapping = aes(x = date_hospitalisation, y = indexed_7day), size = 1)
```




<!-- ### Rolling by month {.unnumbered}   -->

<!-- If you want to calculate statistics by month (e.g. sum, mean, max) you can do this with **dplyr** as described in the [Grouping data] page. Simply create a "month" column, group the data, and run your calculations with `summarise()`.   -->

<!-- If however, you want to calculate rolling statistics over several months (e.g a 2-month rolling window), you can use the `slide_period()` function from **slider**.   -->

<!-- ```{r} -->
<!-- monthly_mean = function(data){ -->
<!--   summarise(data, mean = mean(new_cases, na.rm=T)) -->
<!-- } -->

<!-- linelist %>%  -->
<!--   count(date_hospitalisation, name = "new_cases") %>%  -->
<!--   mutate( -->
<!--     slide_period_dfr( -->
<!--       new_cases,  -->
<!--       .i = date_hospitalisation, -->
<!--       .period = "month", -->
<!--       .f = monthly_mean))  #~mean(.x, na.rm=T))) -->

<!--       #values_col = new_cases, -->
<!--       #index_col = date_hospitalisation -->
<!--     )) -->



<!-- ``` -->


### Gruba göre yuvarlanma {#roll_slider_group .unnumbered}  

**slider** fonksiyonlarını kullanmadan önce verilerinizi gruplandırırsanız, kayan pencereler grup olarak uygulanacaktır. Satırlarınızı *grup bazında* istediğiniz sıraya göre düzenlemeye özen gösteriniz.

Her yeni grup başladığında, kayan pencere yeniden başlayacaktır. Bu nedenle, bilinmesi gereken bir ayrıntı vardır. Verileriniz gruplandırılmışsa *ve* `.complete = TRUE` olarak ayarladıysanız, gruplar arasındaki her geçişte boş değerler elde edersiniz. Fonksiyon satırlar arasında aşağı doğru hareket ettikçe, gruplandırma sütunundaki her geçiş, hesaplamaya izin vermek için minimum pencere boyutunun oluşturulma sürecini yeniden başlatacaktır.

Verileri gruplandırmayla ilgili ayrıntılar için [Verilerin Gruplandırılması] ile ilgili el kitabı sayfasına bakın.

Aşağıda, listedeki vakaları tarihe *ve* hastaneye göre sayıyoruz. Daha sonra sıraları artan şekilde, önce hastaneye göre sonra da tarihe göre sıralamaktayız. Sonrasında `group_by()` fonksiyonunu ayarlıyoruz. Ardından yeni yuvarlanan ortalamamızı oluşturabiliriz.


```{r}
grouped_roll <- linelist %>%

  count(hospital, date_hospitalisation, name = "new_cases") %>% 

  arrange(hospital, date_hospitalisation) %>%   # satırları hastaneye ve ardından tarihe göre düzenle
  
  group_by(hospital) %>%              # hastaneye göre grupla
    
  mutate(                             # yuvarlanan ortalama  
    mean_7day_hosp = slide_index_dbl(
      .x = new_cases,                 # hastane-gün başına vaka sayısı
      .i = date_hospitalisation,      # giriş tarihi indeksi
      .f = mean,                      # mean() kullanımı                  
      .before = days(6)               # mevcut günü ve önceki 6 günü kullan
      )
  )

```

İşte yeni veri seti: 

```{r, echo=F}
DT::datatable(grouped_roll, rownames = FALSE, options = list(pageLength = 12, scrollX=T) )
```


Artık `ggplot()` içinde `~ hastaneyi - hospital` `facet_wrap()` içinde belirterek verileri grup bazında görüntüleyerek hareketli ortalamaları çizebiliriz. Burada iki şekil oluşturuyoruz - günlük vaka sayılarını gösteren bir `geom_col()` ve 7 günlük hareketli ortalamayı gösteren bir `geom_line()`.


```{r, warning=F, message=F}
ggplot(data = grouped_roll)+
  geom_col(                       # günlük vaka sayılarını gri çubuklar olarak çiz
    mapping = aes(
      x = date_hospitalisation,
      y = new_cases),
    fill = "grey",
    width = 1)+
  geom_line(                      # hastaneye göre renklendirilen çizgi olarak yuvarlanan ortalama grafiği
    mapping = aes(
      x = date_hospitalisation,
      y = mean_7day_hosp,
      color = hospital),
    size = 1)+
  facet_wrap(~hospital, ncol = 2)+ # hastane başına mini grafikler oluştur
  theme_classic()+                 # arka planı basitleştir  
  theme(legend.position = "none")+ # çizelgeyi (legend) kaldır
  labs(                            # grafik etiketlerini ekle
    title = "7-day rolling average of daily case incidence",
    x = "Date of admission",
    y = "Case incidence")
```


<span style="color: red;">**TEHLİKE:_** *"slide() tsibble 0.9.0'da kullanımdan kaldırılmıştır ve artık geçersizdir”* şeklinde bir hata alırsanız, lütfen bunun yerine `slider::slide()` kullanın. Bu, **tsibble** paketindeki `slide()` fonksiyonunun, slider paketindeki `slide()` fonksiyonunu maskelediği anlamına gelir. `Slider::slide_dbl()` şekklinde komutunuzda paketi belirterek bu hatayı düzeltin.</span>


<!-- You can group the data prior to using a **slider** function. For example, if you want to calculate the same 7-day rolling sum as above, but by hospital. above rolling mean delay from symptom onset to hospital admission (column `days_onset_hosp`).   -->

<!-- You can group the data by the month of symptom onset using **lubridate**'s `floor_date()` as described in the [Grouping data] page. Then, use `slide_index_dbl()` as before but set your window extent using `months()` (also from **lubridate**).  -->

<!-- f you want a rolling average by *months*, you can use **lubridate** to group the data by month, and then apply `slide_index_dbl()` as below shown for a three-month rolling average:   -->

<!-- ```{r} -->
<!-- months_delay <- linelist %>% -->
<!--   arrange(date_onset) %>%    # drop rows missing date of onset -->
<!--   group_by(hospital) %>%  -->
<!--   #group_by(month_onset = floor_date(date_onset, "month")) %>% # create and group by month of onset  -->
<!--   mutate( -->
<!--     delay_7d = slide_index_dbl( -->
<!--       days_onset_hosp,                  # calculate avg based on value in new_cases column -->
<!--       .i = date_onset,                 # index column is date_onset, so non-present dates are included in 7day window  -->
<!--       .f = ~mean(.x, na.rm = TRUE),     # function is mean() with missing values removed -->
<!--       .before = days(7)), -->

<!--     delay_month = slide_index_dbl( -->
<!--       days_onset_hosp,                  # calculate avg based on value in new_cases column -->
<!--       .i = date_onset,                 # index column is date_onset, so non-present dates are included in 7day window  -->
<!--       .f = ~mean(.x, na.rm = TRUE),     # function is mean() with missing values removed -->
<!--       .before = months(1)))               # window is the month and the prior month -->


<!-- # window is the month and the prior month -->

<!-- ``` -->

<!-- ```{r} -->
<!-- ggplot(data = months_delay, mapping = aes(x = month_onset))+ -->
<!--   geom_line(mapping = aes(y = )) -->

<!-- ``` -->






<!-- ======================================================= -->
## `ggplot()` içinde **tidyquant** hesabı {  }

**tidyquant** paketi, bir `ggplot()` komutunun *içinde* hareketli ortalamaları hesaplamak için başka bir yaklaşım sunar.

*Satır listesinin* altındaki veriler, başlangıç tarihine göre sayılır ve soluk bir çizgi (`alpha` < 1) olarak çizilir. Üstte, **tidyquant** paketinden `geom_ma()` ile oluşturulan, belirtilen renk ve kalınlıkta 7 günlük (`n = 7`) pencereli bir satır yer alır.

Varsayılan olarak `geom_ma()` basit hareketli ortalama kullanır (`ma_fun = "SMA"`), ancak başka türler de belirtilebilir, örneğin:

* "EMA" - üstel hareketli ortalama (son gözlemlere daha fazla ağırlık verilir)  
* "WMA" - ağırlıklı hareketli ortalama (ağırlık, hareketli ortalamadaki gözlemleri ağırlıklandırmak için kullanılır)  
* Diğerleri fonksiyon belgelerinde bulunabilir 

```{r}
linelist %>% 
  count(date_onset) %>%                 # gün başına vaka sayımı
  drop_na(date_onset) %>%               # başlangıç tarihi eksik vakaları kaldır
  ggplot(aes(x = date_onset, y = n))+   # ggplot’u başlat
    geom_line(                          # ham değerleri çiz
      size = 1,
      alpha = 0.2                       # yarı şeffaf çizgi
      )+             
    tidyquant::geom_ma(                 # hareketli ortalama grafiği çiz
      n = 7,           
      size = 1,
      color = "blue")+ 
  theme_minimal()                       # sade arka plan
```

**tidyquant**'ta bulunan seçenekler hakkında daha fazla ayrıntı için bu [skece](https://cran.r-project.org/web/packages/tidyquant/vignettes/TQ04-charting-with-tidyquant.html) bakın.


<!-- ## Rolling regression  -->

<!-- ```{r} -->
<!-- a <- linelist %>% -->
<!--   separate(time_admission, into = c("hour", "minute"), sep = ":") %>%  -->
<!--   count(days_onset_hosp, hour) %>%  -->
<!--   mutate(reg_admit_hour = slide(., ~lm(days_onset_hosp ~ hour), .before = 3, .complete = T)) %>%  -->
<!--   mutate(coeff = reg_admit_hour[[1]]) -->

<!-- ggplot()+ -->
<!--   geom_point(aes(x = hour, y = days_onset_hosp)) -->

<!-- ``` -->

<!-- ```{r} -->
<!-- linelist %>%  -->
<!--   mutate( -->

<!--   ) -->

<!-- ``` -->


<!-- ======================================================= -->
## Kaynaklar {  }


[slider paketi için yararlı çevrimiçi skeç](https://cran.r-project.org/web/packages/slider/vignettes/slider.html)  

[slider github sayfası](https://github.com/DavisVaughan/slider)

[slider skeci](https://davisvaughan.github.io/slider/articles/slider.html)  

[tidyquant skeci](https://cran.r-project.org/web/packages/tidyquant/vignettes/TQ04-charting-with-tidyquant.html)

Hafta sonlarını ve tatilleri "atlamanızı" gerekiyorsa, **almanac** paketini kullabilirsiniz.



```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/moving_average.Rmd-->


# Zaman serileri ve salgınların tespit edilmesi  { }  

<!-- ======================================================= -->
## Genel bakış  {  }

Bu sekme, zaman serisi analizi için gereken birkaç paketin kullanımını göstermektedir. Bu tip analizler öncelikle tidyvers [**tidyverts**](https://tidyverts.org/) ailesinden gelen paketlerle yapılır, ancak bulaşıcı hastalık epidemiyolojisi için daha uygun olan RECON trend paketini [**trending**](https://github.com/reconhub/trending) de kullanır. 

Aşağıdaki örnekte, Almanya'da hazırlanmış Campylobacter bir veri setini kullandığımıza dikkat edin (ayrıntılar için el kitabının [veri bölümüne](https://epirhandbook.com/download-handbook-and-data.html) bakabilirsiniz). Ancak, aynı kodu birden fazla ülke veya başka tabakalar içeren bir veritabanlarında çalıştırmak istiyorsanız, r4epis github deposunda örnek bir kod şablonu bulunmaktadır.[r4epis github repo](https://github.com/R4EPI/epitsa). 

Kapsanan konular:

1. Zaman serisi verileri
2. Tanımlayıcı analiz
3. Uyum (fitting) regresyonları
4. İki zaman serisinin ilişkisi
5. Salgın tespiti
6. Kesintili zaman serisi



<!-- ======================================================= -->
## Hazırlık {  }

### Paketler {.unnumbered}

Bu kod kümesi, analizler için gereken paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman'ın p_load() fonksiyonunu vurguluyoruz. Ayrıca temel R'dan library() ile paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R temelleri sayfasına bakın. [R temelleri](https://epirhandbook.com/r-basics.html)  

```{r load_packages}
pacman::p_load(rio,          # Dosyanın içe aktarılması
               here,         # Dosyanın yerinin bulunması
               tidyverse,    # veri yönetimi + ggplot2 grafikleri
               tsibble,      # zaman serisi veri tabanlarını işlemek
               slider,       # hareketli ortalamaları hesaplamak için
               imputeTS,     # eksik değerleri doldurmak için
               feasts,       # zaman serilerinde ayrıştırma ve otokorelasyon için
               forecast,     # sin ve cosin terimlerini verilere uydurun (not: feasts sonrası yüklenmelidir)
               trending,     # model oluştur ve değerlendir
               tmaptools,    # yer adlarına göre coğrafi koordinatları (boylam/enlem) almak için
               ecmwfr,       # copernicus uydu CDS API ile etkileşim için
               stars,        # .nc (iklim verileri) dosyalarını okumak için
               units,        # for defining units of measurement (climate data)
               yardstick,    # model doğruluğuna bakmak için
               surveillance  # sapma tespiti için
               )

``` 

### Veri yükleme {.unnumbered}

Bu el kitabında kullanılan tüm verileri, [el kitabının ve verilerin indirilmesi] sayfasındaki talimatlar aracılığıyla indirebilirsiniz.  

Bu bölümde kullanılan örnek veri seti, 2001 ve 2011 yılları arasında Almanya'da rapor edilen haftalık kampilobakter vaka sayılarıdır. Bu veri dosyasını (.xlsx) indirmek için buraya tıklayabilirsiniz.<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/time_series/campylobacter_germany.xlsx' class='download-button'>(.xlsx) olarak görülecektir.</span></a> 

Bu veri seti, surveillance paketinde bulunan veri setinin küçültülmüş bir versiyonudur. (detaylar için surveillance paketini yükleyin ve bkz. ?campyDE) [**surveillance**](https://cran.r-project.org/web/packages/surveillance/)

Bu verileri rio paketinden import() fonksiyonu ile içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe Aktarma ve Dışa Aktarma] sayfasına bakın). 

```{r read_data_hide, echo=F}
# sayımları R'ye aktar
counts <- rio::import(here::here("data", "time_series", "campylobacter_germany.xlsx"))
```

```{r read_data_show, eval=F}
# sayımları R'ye aktar
counts <- rio::import("campylobacter_germany.xlsx")
```

Sayımların ilk 10 satırı aşağıda gösterilmiştir

```{r inspect_data, message=FALSE, echo=F}
# sayım verilerini tablo olarak göster
DT::datatable(head(counts, 10), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Temiz veri {.unnumbered}

Aşağıdaki kod, tarih sütununun uygun biçimde olmasını sağlar. Bu sekme için tsibble paketini kullanacağız ve bu nedenle bir takvim haftası değişkeni oluşturmak için yearweek fonksiyonu kullanılacaktır. Bunu yapmanın başka yolları da vardır (ayrıntılar için [Tarihlerle çalışma](https://epirhandbook.com/working-with-dates.html) sayfasına bakın), ancak zaman serileri için en iyisi tarihleri tek bir çerçeve (**tsibble**) içinde tutmaktır.


```{r clean_data}

## tarih sütununun uygun biçimde olduğundan emin olun
counts$date <- as.Date(counts$date)

## bir takvim haftası değişkeni oluşturun
## Pazartesi gününden başlayarak haftaların ISO tanımlarına uyumlu hale getirilmesi
counts <- counts %>% 
     mutate(epiweek = yearweek(date, week_start = 1))

```

### İklim verisinin indirilmesi  {.unnumbered} 

Bu sayfanın iki zaman serisi bölümünde, kampilobakter vaka sayılarını iklim verileriyle karşılaştıracağız.
Dünyanın herhangi bir yerindeki iklim verileri AB'nin Copernicus Uydusundan indirilebilir. 

Bunlar kesin ölçümler değildir, ancak bir modele dayalıdır (interpolasyona benzer), tahminlerin yanı sıra küresel saatlik bilgi kapsamı elde edilebilir.

Bu iklim veri dosyalarının her birini [el kitabının ve verilerin indirilmesi] sayfasından indirebilirsiniz.
  
Burada gösterim amacıyla, verileri Copernicus iklim veri deposundan çekmek için ecmwfr paketini kullanmak için gereken R kodunu tanıtacağız. Bunun çalışması için ücretsiz bir hesap oluşturmanız gerekecektir. Paketin web sitesinde bunun nasıl yapılacağına dair yararlı bir yol gösterilmiştir[walkthrough](https://github.com/bluegreen-labs/ecmwfr#use-copernicus-climate-data-store-cds).

Aşağıda, uygun API anahtarlarına sahip olduğunuzda, bunun nasıl yapılacağına ilişkin örnek kod verilmiştir. Aşağıdaki X'leri hesap kimliklerinizle değiştirmeniz gerekir. Her seferinde bir yıllık veri indirmeniz gerekir, aksi takdirde sunucu zaman aşımına uğrayacaktır.

Verilerini indirmek istediğiniz konumun koordinatlarından emin değilseniz, açık sokak haritalarından koordinatları almak için tmaptools paketini kullanabilirsiniz. Alternatif bir seçenek photon paketidir,[**photon**](https://github.com/rCarto/photon) ancak bu henüz CRAN'da yayınlanmamıştır; photon’un güzel yanı, aramanız için birkaç eşleşme olduğunda daha fazla bağlamsal veri sağlamasıdır.


```{r weather_data, eval = FALSE}

## konum koordinatlarını al
coords <- geocode_OSM("Germany", geometry = "point")

## ERA-5 sorgulaması için boylamları/enlemleri bir araya getirin (sınırlayıcı kutu)
## (tek bir noktanın koordinatlarının tekrar edebileceği gibi)
request_coords <- str_glue_data(coords$coords, "{y}/{x}/{y}/{x}")


## Kopernik uydusundan modellenen verileri çekme (ERA-5 yeniden analizi)
## https://cds.climate.copernicus.eu/cdsapp#!/software/app-era5-explorer?tab=app
## https://github.com/bluegreen-labs/ecmwfr

## hava durumu verileri için anahtar ayarla
wf_set_key(user = "XXXXX",
           key = "XXXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXX",
           service = "cds") 

## ilgilenilen her yıl için çalıştırın (aksi takdirde sunucu zaman aşımına uğrar)
for (i in 2002:2011) {
  
  ## sorguyu bir araya getir
  ## nasıl yapılacağı için buraya bakın: https://bluegreen-labs.github.io/ecmwfr/articles/cds_vignette.html#the-request-syntax
  ## yukarıdaki eklenti düğmesini kullanarak isteği bir listeye dönüştürün (listeye python)
  ## Hedef, çıktı dosyasının adıdır!

  request <- request <- list(
    product_type = "reanalysis",
    format = "netcdf",
    variable = c("2m_temperature", "total_precipitation"),
    year = c(i),
    month = c("01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"),
    day = c("01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12",
            "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24",
            "25", "26", "27", "28", "29", "30", "31"),
    time = c("00:00", "01:00", "02:00", "03:00", "04:00", "05:00", "06:00", "07:00",
             "08:00", "09:00", "10:00", "11:00", "12:00", "13:00", "14:00", "15:00",
             "16:00", "17:00", "18:00", "19:00", "20:00", "21:00", "22:00", "23:00"),
    area = request_coords,
    dataset_short_name = "reanalysis-era5-single-levels",
    target = paste0("germany_weather", i, ".nc")
  )
  
 # dosyayı indirin ve mevcut çalışma dizininde saklayın
  file <- wf_request(user     = "XXXXX",  # kullanıcı ID (kimlik doğrulama için)
                     request  = request,  # istek
                     transfer = TRUE,     # dosyayı indir 
                     path     = here::here("data", "Weather")) ## dosyayı kaydetmek için yolak
  }

```

### İklim verisinin yüklenmesi {.unnumbered}

İster iklim verilerini el kitabımız üzerinden indirmiş olun, ister yukarıdaki kodu kullanmış olun, artık bilgisayarınızda aynı klasörde saklanan 10 yıllık “.nc” iklim veri dosyalarına sahip olmalısınız.

Bu dosyaları stars paketiyle R'a aktarmak için aşağıdaki kodu kullanın.


```{r read_climate, warning = FALSE, message = FALSE}

## hava durumu klasörüne giden yolu tanımlayın 
file_paths <- list.files(
  here::here("data", "time_series", "weather"), # replace with your own file path 
  full.names = TRUE)

## sadece şu anki ilgi alanına sahip olanları saklayın
file_paths <- file_paths[str_detect(file_paths, "germany")]

## tüm dosyaları stars nesnesi olarak oku
data <- stars::read_stars(file_paths)
```

Bu dosyalar nesne verisi olarak içe aktarıldıktan sonra onları bir veri çerçevesine dönüştüreceğiz.

```{r}
## veri çerçevesine değiştir
temp_data <- as_tibble(data) %>% 
  ## değişkenler ekleyin ve birimleri düzeltin
  mutate(
    ## takvim haftası değişkeni oluşturun
    epiweek = tsibble::yearweek(time), 
    ## tarih değişkeni oluşturun (takvim haftasının başlangıcı)
    date = as.Date(epiweek),
    ## sıcaklığı kelvin'den santigrat dereceye değiştir
    t2m = set_units(t2m, celsius), 
    ## yağışı metreden milimetreye değiştir
    tp  = set_units(tp, mm)) %>% 
  ## haftaya göre gruplandır (tarihi de sakla)
  group_by(epiweek, date) %>% 
  ## haftalık ortalamanın özetlenmesi
  summarise(t2m = as.numeric(mean(t2m)), 
            tp = as.numeric(mean(tp)))

```




<!-- ======================================================= -->
## Zaman serisi verisi   {  }

Zaman serisi verilerini yapılandırmak ve işlemek için bir dizi farklı paket vardır. Bahsedildiği gibi, tidyverts paket ailesine odaklanacağız ve bu nedenle zaman serisi nesnemizi tanımlamak için tsibble paketini kullanacağız. Zaman serisi nesnesi olarak tanımlanan bir veri setine sahip olmak, analizimizi yapılandırmanın çok daha kolay olduğu anlamına gelir.

Bunu yapmak için tsibble() fonksiyonunu kullanırız ve "indeks"i, yani ilgilenilen zaman birimini belirten değişkeni belirtiriz. Bizim durumumuzda bu, epiweek değişkenidir.

Örneğin, il bazında haftalık sayıları olan bir veri setimiz olsaydı, key = değişkenini kullanarak gruplama değişkenini de belirleyebilirdik. Bu, her grup için analiz yapmamızı sağlar. 



```{r ts_object}

## zaman serisi nesnesini tanımla
counts <- tsibble(counts, index = epiweek)

```

class(counts)'a baktığınızda, düzenli bir veri çerçevesi ("tbl_df", "tbl", "data.frame") olmanın yanı sıra, bir zaman serisi veri çerçevesinin ("tbl_ts") ek özelliklerine sahip olduğunu gösterir.

ggplot2 kullanarak verilerinize hızlıca göz atabilirsiniz. Olay örgüsünde net bir mevsimsel motif olduğunu ve eksik veri olmadığını görüyoruz. Ancak, her yılın başında raporlama ile ilgili bir sorun var gibi görünüyor; vakalar yılın son haftasında düşmekte ve sonraki yılın ilk haftasında artmaktadır. 


```{r basic_plot}

## haftaya göre vakaların bir çizgi grafiğini çizin
ggplot(counts, aes(x = epiweek, y = case)) + 
     geom_line()

```


<span style="color: red;">**_TEHLİKE:_** Çoğu veri kümesi bu örnek kadar temiz değildir. Aşağıdaki gibi duplikasyonları ve eksikleri kontrol etmeniz gerekecektir. </span>

<!-- ======================================================= -->
### Duplikasyonlar {.unnumbered}

tsibble yinelenen gözlemlere izin vermez. Bu nedenle, her satırın benzersiz veya (anahtar değişkene göre) grup içinde benzersiz olması gerekir. Paket, kopyaları tanımlamaya yardımcı olan birkaç işleve sahiptir. Bunlar, satırın bir kopya olup olmadığına dair bir DOĞRU/YANLIŞ vektörü veren are_duplicated() ve size duplike satırların veri çerçevesini veren duplicates() fonksiyonlarını içerir.

İstediğiniz satırları nasıl seçeceğinizle ilgili daha fazla ayrıntı için Tekilleştirme (De-duplikasyon) sayfasına bakabilirsiniz. [Tekilleştirme](https://epirhandbook.com/de-duplication.html)


```{r duplicates, eval = FALSE}

## satırların kopya olup olmadığını DOĞRU/YANLIŞ vektörü olarak çıkarın
are_duplicated(counts, index = epiweek) 

## yinelenen satırların veri çerçevesini çıkarın
duplicates(counts, index = epiweek) 

```

<!-- ======================================================= -->
### Eksikler {.unnumbered}

Yukarıdaki kısa incelememizde hiçbir eksik olmadığını gördük, ancak yeni yıl civarında raporlama gecikmesinde bir sorun olduğunu da gördük. Bu sorunu çözmenin bir yolu, bu değerleri eksik olarak ayarlamak ve ardından değerleri atfetmek olabilir. Zaman serisi atamasının en basit şekli, en son kayıp olmayan ve bir sonraki kayıp olmayan değer arasına düz bir çizgi çizmektir. Bunu yapmak için imputeTS paketinden na_interpolation() fonksiyonunu kullanacağız.


Tahmin için değerler atamada diğer seçenekler için [Eksik veri](https://epirhandbook.com/missing-data.html) sayfasına bakabilirsiniz.  

Diğer bir alternatif, hareketli ortalama hesaplamak, belirgin raporlama sorunlarını denemek ve düzeltmek olabilir (bir sonraki bölüme ve Hareketli ortalamalar sayfasına bakın)[Hareketli ortalamalar](https://epirhandbook.com/moving-averages.html)). 

```{r missings}

## raporlama sorunları olan haftalar yerine eksikleri olan bir değişken oluşturun
counts <- counts %>% 
     mutate(case_miss = if_else(
          ## epiweek 52, 53, 1 veya 2 içeriyorsa
          str_detect(epiweek, "W51|W52|W53|W01|W02"), 
          ## sonrasında eksik olarak ayarlayın
          NA_real_, 
          ## aksi takdirde değeri saklayın
          case
     ))

## alternatif olarak eksikleri doğrusal trendle interpolasyon yapın
## en yakın iki bitişik nokta arasında
counts <- counts %>% 
  mutate(case_int = imputeTS::na_interpolation(case_miss)
         )

## orijinaline kıyasla hangi değerlerin atfedildiğini (impute) kontrol etmek için
ggplot_na_imputations(counts$case_miss, counts$case_int) + 
  ## geleneksel bir grafik oluşturun (siyah eksenli ve beyaz arka planlı)
  theme_classic()

```




<!-- ======================================================= -->
## Tanımlayıcı analizler {  }



<!-- ======================================================= -->
### Hareketli ortalamalar  {#timeseries_moving .unnumbered}

Veriler çok gürültülüyse (yukarı ve aşağı atlamalar sayılır), hareketli bir ortalama hesaplamak yardımcı olabilir. Aşağıdaki örnekte, her hafta için önceki dört haftadaki ortalama vaka sayısını hesaplıyoruz. Bu hesap ile, verilerin daha yorumlanabilir hale gelmesi için düzeltme yapılır. Örneğimiz için bu düzeltmenin faydası kısıtlıdır, bu yüzden daha fazla analiz için interpolasyonlu verilere bağlı kalınacaktuır. Daha fazla ayrıntı için Hareketli ortalamalar sayfasına bakın. [Hareketli ortalamalar](https://epirhandbook.com/moving-averages.html). 

```{r moving_averages}

## hareketli bir ortalama değişkeni oluşturun (eksiklerle ilgilenilecektir)
counts <- counts %>% 
     ## ma_4w değişkenini oluştur
     ## case değişkeninin her satırının üzerine kaydırın
     mutate(ma_4wk = slider::slide_dbl(case, 
                               ## her satır için ad hesapla
                               ~ mean(.x, na.rm = TRUE),
                               ## önceki dört haftayı kullan
                               .before = 4))

## farkını hızla görselleştirin 
ggplot(counts, aes(x = epiweek)) + 
     geom_line(aes(y = case)) + 
     geom_line(aes(y = ma_4wk), colour = "red")

```


<!-- ======================================================= -->
### Periyodisite {.unnumbered}

Aşağıda bir periodogram oluşturmak için özel bir fonksiyon tanımlıyoruz. R'de fonksiyonların nasıl yazılacağı hakkında bilgi için Fonksiyon yazma sayfasına bakın.

İlk olarak fonksiyon tanımlanır. Fonksiyonun argümanları, sütun sayıları olan bir veri tabanını, veri tabanının ilk haftası olan başlangıç_haftası =, yılda kaç periyot olduğunu gösteren bir sayıyı (örneğin 52, 12) ve son olarak çıktı stilini içerir (aşağıdaki koddaki ayrıntılara bakın).



```{r periodogram}
## Fonksiyonun argümanları
#####################
## x veritabanıdır
## x içindeki oranlar ya da sayımlar değişkendir
## start_week is the first week in your dataset
## periyot bir yıldaki birim sayısıdır 
## çıktı, dönüş spektral periodogramı ya da peak görülen haftalardır.
  ## "periodogram" veya "weeks"

# Fonksiyonu tanımlamak
periodogram <- function(x, 
                        counts, 
                        start_week = c(2002, 1), 
                        period = 52, 
                        output = "weeks") {
  

    ## bir tsibble olmadığından emin olun, projeye filtre uygulayın ve yalnızca ilgilenilen sütunları tutun
    prepare_data <- dplyr::as_tibble(x)
    
    # veriyi hazırla <- prepare_data[prepare_data[[strata]] == j, ]
    prepare_data <- dplyr::select(prepare_data, {{counts}})
    
    ## spec.pgram ile kullanılabilecek bir ara zaman serisi (“zoo”) oluşturun
    zoo_cases <- zoo::zooreg(prepare_data, 
                             start = start_week, frequency = period)
    
    ## hızlı fourier dönüşümü kullanmayan bir spektral periodogram elde edin
    periodo <- spec.pgram(zoo_cases, fast = FALSE, plot = FALSE)
    
    ## pieak haftaları elde edin 
    periodo_weeks <- 1 / periodo$freq[order(-periodo$spec)] * period
    
    if (output == "weeks") {
      periodo_weeks
    } else {
      periodo
    }
    
}

## en yüksek frekanslara sahip haftaları çıkarmak için spektral periodogram alın
## (mevsimsellik kontrolü)
periodo <- periodogram(counts, 
                       case_int, 
                       start_week = c(2002, 1),
                       output = "periodogram")

## görselleştirme için bir veri çerçevesine tam spektrum ve frekans yerleştirilir
periodo <- data.frame(periodo$freq, periodo$spec)

## en sık meydana gelen periyodikliği gösteren bir periodogram çizin
ggplot(data = periodo, 
                aes(x = 1/(periodo.freq/52),  y = log(periodo.spec))) + 
  geom_line() + 
  labs(x = "Period (Weeks)", y = "Log(density)")
 

 
## haftaları içeren vektörü artan sırayla elde edin 
peak_weeks <- periodogram(counts, 
                          case_int, 
                          start_week = c(2002, 1), 
                          output = "weeks")


```

<span style="color: black;">**_NOT:_** Yukarıdaki haftaları sinüs ve kosinüs terimlerine eklemek mümkündür, ancak bu terimleri oluşturmak için bir fonksiyon kullanacağız (aşağıdaki regresyon bölümüne bakınız) </span>

<!-- ======================================================= -->
### Ayrıştırma {.unnumbered}

Klasik ayrıştırma, bir zaman serisini parçalara ayırmak için kullanılır ve bu parçalar birlikte gördüğünüz modeli oluşturur. Bu farklı parçalar şunlardır:

• Trend döngüsü (verinin uzun vadeli seyri)
• Mevsimsellik (tekrarlanan modeller)
• Rastgele (trend ve sezon çıkarıldıktan sonra kalan)


```{r decomposition, warning=F, message=F}

## sayımlar veri tabanını ayrıştır 
counts %>% 
  # additif klasik ayrıştırma modeli uygula 
  model(classical_decomposition(case_int, type = "additive")) %>% 
  ## önemli bilgileri modelden çıkarın
  components() %>% 
  ## grafik oluştur 
  autoplot()

```

<!-- ======================================================= -->
### Otokorelasyon {.unnumbered}

Otokorelasyon size her haftadaki sayımlar ile önceki haftalardaki sayımlar (gecikme olarak adlandırılır) arasındaki ilişkiyi anlatır.

ACF() fonksiyonunu kullanarak, farklı gecikmelerdeki ilişkiyi bize bir dizi çizgi gösteren bir grafik oluşturabiliriz. Gecikmenin 0 (x = 0) olduğu yerde, çizgi gözlem ile kendisi arasındaki ilişkiyi gösterdiğinden (burada gösterilmemiştir) her zaman 1 olacaktır. Burada gösterilen ilk satır (x = 1), her gözlem ile bir önceki gözlem arasındaki ilişkiyi gösterir (1 gecikme), ikincisi gözlem ile iki önceki gözlem arasındaki ilişkiyi gösterir (2 gecikme) ve gecikme sayıları bu şekilde artarak devam eder (Her bir gözlem ile 1 yıllık (52 hafta öncesi) gözlem arasındaki ilişkiyi gösteren 52’ye kadar)

PACF() fonksiyonunun kullanılması (kısmi otokorelasyon için) aynı ilişkiyi gösterir, ancak aradaki diğer tüm haftalar için ayarlanmış bir ölçüttür. Kısmi otokorelasyon, periyodikliği belirlemek için daha az yararlıdır.


```{r autocorrelation}

## sayım veri tabanını kullanma
counts %>% 
  ## yıl içindeki gecikmeleri kullanarak otokorelasyonu hesaplayın
  ACF(case_int, lag_max = 52) %>% 
  ## grafik oluşturun
  autoplot()
 

 
## sayım veri tabanını kullanma 
counts %>% 
  ## yıl içindeki gecikmeleri kullanarak kısmi otokorelasyonu hesaplayın
  PACF(case_int, lag_max = 52) %>% 
  ## grafik oluşturun
  autoplot()

```

Ljung-Box testini (stats paketinde) kullanarak zaman serisinde null hipotezini (yani otokorelasyonlu olup olmadığı) test edebilirsiniz. Anlamlı bir p değeri, verilerde otokorelasyon olduğunu gösterir.


```{r ljung_box}

## bağımsızlık testi 
Box.test(counts$case_int, type = "Ljung-Box")

```


<!-- ======================================================= -->
## Uyum regresyonları {  }

Bir zaman serisine çok sayıda farklı regresyon sığdırmak mümkündür, ancak burada negatif iki terimli regresyonun nasıl sığdırılacağını göstereceğiz - çünkü bu genellikle bulaşıcı hastalıklardaki sayım verileri için en uygun olanıdır.

<!-- ======================================================= -->
### Fourier terimleri  {.unnumbered}

Fourier terimleri, sinüs ve kosinüs eğrilerinin eş epi hafta ve case_int değişkenlerini kullanarak fourier terimleri ekleyindeğeridir. Aradaki fark, bu terimlerin verilerinizi açıklamak için en uygun eğri kombinasyonunu bulmaya dayalı bulunmasıdır.

Yalnızca bir fourier terimine kullanacak olsaydınız, periodogramınızda görülen en sık meydana gelen gecikmeniz için (bizim durumumuzda 52 hafta) bir sinüs ve bir kosinüs kullanmaya eşdeğer olacaktır. Forecast paketindeki fourier() fonksiyonunu kullanıyoruz.

Aşağıdaki kodda $ operatörünü kullanarak atadık, çünkü fourier() iki sütun oluşturur (biri sinüs, diğeri kosinüs için) ve bu nedenle bunlar veri tabanına "fourier" adı verilen bir liste olarak eklenir - ancak bu liste daha sonra regresyonda normal bir değişken olarak kullanılabilir: 


```{r fourier}

## epi hafta ve case_int değişkenlerini kullanarak fourier terimleri ekleyin
counts$fourier <- select(counts, epiweek, case_int) %>% 
  fourier(K = 1)
```

<!-- ======================================================= -->
### Negatif binomial {.unnumbered}

Temel istatistik (base stats) veya MASS fonksiyonlarını (örn. lm(), glm() ve glm.nb()) kullanarak uyumlu regresyonlar oluşturmak mümkündür. Bununla birlikte, uygun güven ve tahmin aralıklarının (aksi takdirde mevcut olmayan) hesaplanmasına izin verdiği için, trending paketindeki fonksiyonları kullanacağız. Bu fonksiyonların sintaksı aynıdır ve bir çıktı değişkeni, ardından bir tilde (~) belirtir ve ardından artı (+) ile ayırarak ilgilendiğiniz çeşitli maruz kalma değişkenlerinizi eklersiniz.

Diğer fark, önce modeli tanımlamamız ve ardından onu verilere fit() ile uydurmamızdır.  Bu, aynı sintaksa sahip birden çok farklı modeli karşılaştırmaya izin verdiği için yararlıdır.


<span style="color: darkgreen;">**_İPUCU:_** Sayılar yerine oranları kullanmak istiyorsanız, offset(log(population) terimini ekleyerek popülasyon değişkenini logaritmik bir offset terimi olarak dahil edebilirsiniz. Bu durumda bir oran oluşturmak için predict() fonksiyonunu kullanmadan önce popülasyonu 1 olarak ayarlamanız gerekir. </span>

<span style="color: darkgreen;">**_İPUCU:_** ARIMA veya prophet gibi daha karmaşık modelleri uygulamak için fable paketine bakAbilirsiniz. [**fable**](https://fable.tidyverts.org/index.html).</span>

```{r nb_reg, warning = FALSE}

## uydurmak istediğiniz modeli tanımlayın (negatif binom)
model <- glm_nb_model(
  ## ilgilenilen sonuç olarak vaka sayısını belirlemek
  case_int ~
    ## trendi hesaba katmak için epiweek'i kullanın
    epiweek +
    ## mevsimselliği hesaba katmak için fourier terimlerini kullanın
    fourier)

## sayım veri tabanını kullanarak modelinize uydurun
fitted_model <- trending::fit(model, data.frame(counts))

## güven ve tahmin aralıklarını hesaplayın
observed <- predict(fitted_model, simulate_pi = FALSE)

## regresyonunuzu görselleştirin 
ggplot(data = observed, aes(x = epiweek)) + 
  ## model tahmini için bir satır ekleyin
  geom_line(aes(y = estimate),
            col = "Red") + 
  ## tahmin aralıkları için bir bant ekleyin
  geom_ribbon(aes(ymin = lower_pi, 
                  ymax = upper_pi), 
              alpha = 0.25) + 
  ## gözlemlenen vaka sayılarınız için bir satır ekleyin
  geom_line(aes(y = case_int), 
            col = "black") + 
  ## geleneksel bir grafik oluşturun (siyah eksenli ve beyaz arka planlı)
  theme_classic()

```

<!-- ======================================================= -->
### Artıklar (Residuals) {.unnumbered}

Modelimizin gözlemlenen verilere ne kadar uyum gösterdiğini görmek için artıklara bakmamız gerekir. Artıklar, gözlemlenen değerler ile modelden tahmin edilen değerler arasındaki farktır. Bunu basitçe case_int - tahmin formülünü kullanarak hesaplayabiliriz, ancak residuals() fonksiyonu bunu bizim için doğrudan regresyondan çıkarır.

Aşağıdan gördüğümüz gibi modelle tüm varyansı açıklamamaktayız. Daha fazla fourier terimi kullanmamız ve genliği ele almamız gerekebilir. Ancak bu örnek için olduğu gibi bırakacağız. Grafikler, modelimizin tepe ve diplerde (sayılar en yüksek ve en düşük olduğunda) daha kötü olduğunu ve gözlemlenen sayıları olduğundan daha az tahmin etme olasılığının (underestimate) yüksek olabileceğini gösteriyor.



```{r, warning=F, message=F}

## artıkların hesabı 
observed <- observed %>% 
  mutate(resid = residuals(fitted_model$fitted_model, type = "response"))

## artıklar zaman içinde oldukça sabit mi (değilse: salgın? uygulamada değişiklik?)
observed %>%
  ggplot(aes(x = epiweek, y = resid)) +
  geom_line() +
  geom_point() + 
  labs(x = "epiweek", y = "Residuals")
 

 
## artıklarda otokorelasyon var mı (hatanın bir motifi var mı?)
observed %>% 
  as_tsibble(index = epiweek) %>% 
  ACF(resid, lag_max = 52) %>% 
  autoplot()
 

 
## artıklar normal olarak dağılmış mı (tahminin altında mı yoksa üzerinde mi?)
observed %>%
  ggplot(aes(x = resid)) +
  geom_histogram(binwidth = 100) +
  geom_rug() +
  labs(y = "count") 
 

 
## gözlemlenen sayıları artıklarıyla karşılaştırın
  ## ayrıca motif görülmemeli
observed %>%
  ggplot(aes(x = estimate, y = resid)) +
  geom_point() +
  labs(x = "Fitted", y = "Residuals")
 

 
## artıkların otokorelasyonunu test edin
## H0, artıkların beyaz gürültü (yani rastgele) olmasıdır
## bağımsızlık testi
## p değeri anlamlıysa rastgele değil
Box.test(observed$resid, type = "Ljung-Box")
 
## 
##  Box-Ljung test
## 
## data:  observed$resid
## X-squared = 346.64, df = 1, p-value < 2.2e-16


```

<!-- ======================================================= -->
## İki zaman serisinin ilişkisi   {  }

Burada, campylobacter vaka sayılarını açıklamak için hava durumu verilerini (özellikle sıcaklık) kullanmayı inceliyoruz. 

<!-- ======================================================= -->
### Veritabanlarının birleştirilmesi {.unnumbered}

Hafta değişkenini kullanarak veri tabanlarımızı birleştirebiliriz. Birleştirme hakkında daha fazla bilgi için birleştirme ilgili el kitabı bölümüne bakın. [joining](https://epirhandbook.com/joining-data.html).

```{r join}

## sol birleştirme, böylece yalnızca sayılarda mevcut olan satırlarımız olur 
## temp_data'dan tarih değişkenini çıkarın (aksi takdirde yinelenir)

counts <- left_join(counts, 
                    select(temp_data, -date),
                    by = "epiweek")

```

<!-- ======================================================= -->
### Tanımlayıcı analizler {.unnumbered}

Görünür bir ilişki olup olmadığını görmek için önce verilerinizi çizin. Aşağıdaki grafik, iki değişkenin mevsimselliği yönünden görünür bir ilişki olduğunu ve sıcaklığın vaka sayısından birkaç hafta önce zirveye ulaştığını göstermektedir. Verilerin pivotlanması hakkında daha fazla bilgi için, verilerin pivotlanmasıyla ilgili el kitabı bölümüne bakın. [pivoting data](https://epirhandbook.com/pivoting-data.html). 

```{r basic_plot_bivar}

counts %>% 
  ## sadece ilgilendiğimiz değişkenler veritabanında kalır  
  select(epiweek, case_int, t2m) %>% 
  ## verilerinizi uzun formatta değiştirin
  pivot_longer(
    ## anahtar olarak epiweek'i kullanın
    !epiweek,
    ## sütun adlarını yeni "ölçü" sütununa taşıyın
    names_to = "measure", 
    ## hücre değerlerini yeni "değerler" sütununa taşı
    values_to = "value") %>% 
  ## yukarıdaki veritabanından bir grafik oluşturun 
  ## epiweek'i x ekseninde ve değerler (sayılar/santigrat) y ekseninde grafik çizin
  ggplot(aes(x = epiweek, y = value)) + 
    ## sıcaklık ve vaka sayıları için ayrı bir grafik oluşturun
    ## kendi y eksenlerini ayarlamalarına izin verin
    facet_grid(measure ~ ., scales = "free_y") +
    ## ikisini de bir çizgi grafiği olarak çizin 
    geom_line()

```

<!-- ======================================================= -->
### Gecikmeler ve çapraz korelasyonlar  {.unnumbered}

Vakalar ve sıcaklık arasında hangi haftaların en çok ilişkili olduğunu test etmek çapraz korelasyon uygulanır. feasts paketinden çapraz korelasyon fonksiyonunu (CCF()) kullanabiliriz. Ayrıca autoplot() fonksiyonunu kullanarak (arrange kullanmak yerine) grafik oluşturabilirsiniz. 

```{r cross_correlation, warning=FALSE}

counts %>% 
  ## interpolasyonlu sayımlar ve sıcaklık arasındaki çapraz korelasyonu hesaplayın
  CCF(case_int, t2m,
      ## maksimum gecikmeyi 52 hafta olarak ayarlayın
      lag_max = 52, 
      ## korelasyon katsayısını hesaplayın
      type = "correlation") %>% 
  ## korelasyon katsayısını azalan biçimde dizin
  ## en yüksek ilişkili gecikmeleri göster
  arrange(-ccf) %>% 
  ## sadece ilk 10'u gösterin 
  slice_head(n = 10)


```

Burada 4 haftalık bir gecikmenin en yüksek oranda ilişkili olduğunu görüyoruz, bu nedenle regresyonumuza dahil etmek için gecikmeli bir sıcaklık değişkeni oluşturuyoruz.

<span style="color: red;">**_TEHLİKE:_** Gecikmeli sıcaklık değişkenindeki verilerin ilk dört haftasının eksik olduğunu (NA) unutmayın - çünkü veri almak için önceki dört hafta mevcut değildi. Bu veri tabanını trending predict() fonksiyonuyla kullanmak için, daha aşağıda predict() fonksiyonu içinde simulate_pi = FALSE argümanını kullanmamız gerekir. Simulate (simüle et) seçeneğini kullanmak istediysek, aşağıdaki kod parçasına drop_na(t2m_lag4) terimini ekleyerek eksikleri çıkararak yeni bir veri tabanı olarak kaydetmeliyiz.</span>  
 

```{r lag_tempvar}

counts <- counts %>% 
  ## sıcaklık için dört hafta gecikmeli yeni bir değişken oluşturun
  mutate(t2m_lag4 = lag(t2m, n = 4))


```


<!-- ======================================================= -->
### İki değişkenli negatif binomial  {.unnumbered}

Daha önce gösterildiği gibi negatif bir binom regresyon modeli geliştiriyoruz. Bu sefer modelimize dört hafta gecikmeli sıcaklık değişkenini ekliyoruz.

<span style="color: orange;">**_UYARI:_** predict() değişkeninde simulate_pi = FALSE kullanımına dikkat edin. Bunun nedeni, trending’in varsayılan davranışının bir tahmin aralığı oluşturmak için ciTools paketini kullanmasıdır. NA (eksik) sayılar varsa bu paket çalışmaz ve daha granüler aralıklar üretir. Ayrıntılar için ?trending::predict.trending_model_fit'e bakın. </span>  

```{r nb_reg_bivar, warning = FALSE}

## uydurmak istediğiniz modeli tanımlayın (negatif binom)
model <- glm_nb_model(
  ## ilgilenilen çıktı olarak vaka sayısını belirleyin 
  case_int ~
    ## trendi hesaba katmak için epiweek'i kullanın
    epiweek +
    ## mevsimselliği hesaba katmak için fourier terimlerini kullanın
    fourier + 
    ## dört hafta gecikmeli sıcaklık değişkenini kullanın
    t2m_lag4
    )

## sayım veri tabanını kullanarak uyumlu modelinizi oluşturun
fitted_model <- trending::fit(model, data.frame(counts))

## güven aralıklarını ve tahmin aralıklarını hesaplayın
observed <- predict(fitted_model, simulate_pi = FALSE)


```


Tek tek terimleri araştırmak için, get_model() fonksiyonunu kullanarak orijinal negatif binom regresyonunu trend formatından çıkarabilir sonrasında üstel tahminleri ve ilişkili güven aralıklarını elde etmek için broom paketi tidy() işlevine iletebiliriz. Bu bize, trend ve mevsimsellik için kontrol edildikten sonra gecikmeli sıcaklığın vaka sayılarına benzer olduğunu ve vaka sayılarıyla anlamlı olarak ilişkili (tahmini ~ 1)  olduğunu gösterir. Bu sonuç , gecikmeli sıcaklık değişkeninin gelecekteki vaka sayılarını tahmin etmek için iyi bir değişken olabileceğini düşündürmektedir (iklim tahminleri zaten hazır olduğu için). 

```{r results_nb_reg_bivar}

fitted_model %>% 
  ## orijinal negatif binom regresyonunu elde edin 
  get_model() %>% 
  ## sonuçların tidy veri çerçevesini elde edin
  tidy(exponentiate = TRUE, 
       conf.int = TRUE)

```

Modelin hızlı görsel incelemesi, modelin gözlemlenen vaka sayılarını tahmin etmede daha iyi bir iş çıkarabileceğini gösterir.

```{r plot_nb_reg_bivar, warning=F, message=F}

## regresyonunuzu çiz
ggplot(data = observed, aes(x = epiweek)) + 
  ## model tahmini için bir satır ekleyin
  geom_line(aes(y = estimate),
            col = "Red") + 
  ## tahmin aralıkları için bir bant ekleyin
  geom_ribbon(aes(ymin = lower_pi, 
                  ymax = upper_pi), 
              alpha = 0.25) + 
  ## gözlemlenen vaka sayılarınız için bir satır ekleyin
  geom_line(aes(y = case_int), 
            col = "black") + 
  ## geleneksel bir grafik oluşturun (siyah eksenli ve beyaz arka planlı)
  theme_classic()



```


#### Rezidüeller (Artıklar) {.unnumbered}

Modelimizin gözlemlenen verilerle ne kadar uyumlu olduğunu görmek için artıkları tekrar araştırırız. Buradaki sonuçlar ve yorum önceki regresyona benzer, bu nedenle sıcaklık değişkenini içermeyen daha basit bir modele bağlı kalmak daha uygun olabilir.

```{r}
## artıkları hesapla
observed <- observed %>% 
  mutate(resid = case_int - estimate)

## artıklar zaman içinde oldukça sabit mi (değilse: salgın? uygulamada değişiklik?)
observed %>%
  ggplot(aes(x = epiweek, y = resid)) +
  geom_line() +
  geom_point() + 
  labs(x = "epiweek", y = "Residuals")
 
## Uyarı: Eksik değerler içeren 4 satır kaldırıldı (geom_path).

 
## artıklarda otokorelasyon var mı (hatanın bir motifi var mı?)
observed %>% 
  as_tsibble(index = epiweek) %>% 
  ACF(resid, lag_max = 52) %>% 
  autoplot()
 

 
## artıklar normal dağılım gösteriyor mu (tahminin altında mı yoksa üzerinde mi?)
observed %>%
  ggplot(aes(x = resid)) +
  geom_histogram(binwidth = 100) +
  geom_rug() +
  labs(y = "count") 
 
## Uyarı: Sonlu olmayan değerler içeren 4 satır kaldırıldı (stat_bin).

 
## gözlemlenen sayıları artıklarıyla karşılaştırın
  ## ayrıca tekrarlama olmamalı
observed %>%
  ggplot(aes(x = estimate, y = resid)) +
  geom_point() +
  labs(x = "Fitted", y = "Residuals")
 
## Uyarı: Eksik değerler içeren 4 satır kaldırıldı (geom_point).

 
## artıkların otokorelasyonunu test edin
## H0, artıkların beyaz gürültü (yani rastgele) olmasıdır
## bağımsızlık testi
## p değeri anlamlıysa rastgele değildir
Box.test(observed$resid, type = "Ljung-Box")

```

<!-- ======================================================= -->
## Salgınların tespit edilmesi  {  }

Burada salgınları tespit etmek için iki (benzer) yöntem göstereceğiz. İlki, yukarıdaki bölümler üzerine kuruludur. Regresyonları önceki yıllara uydurmak için trending paketini kullanıyoruz ve ardından gelecek yıl görmeyi umduğumuzu değerleri tahmin ediyoruz. Gözlenen sayımlar beklediğimizin üzerindeyse, bir salgın olduğunu gösterebilir. İkinci yöntem benzer ilkelere dayanmaktadır ancak aşırı değerlerin (aberration) tespiti için bir dizi farklı algoritmaya sahip surveillance paketini kullanır.

<span style="color: orange;">**_UYARI:_** Normalde, mevcut yılla ilgilenirsiniz (yalnızca mevcut haftaya kadar olan sayıları bildiğiniz için). Bu örnekte 2011'in 39. haftasındaymış gibi analiz yapıyoruz.</span>

<!-- ======================================================= -->
### **trending** paketi {.unnumbered}

Bu yöntem için bir temel tanımlarız, genellikle yaklaşık 5 yıllık veri olmalıdır). Temel veriler için bir regresyon modeli oluştururuz ve ardından bunu gelecek yıl için tahmin elde etmek için kullanırız.

<!-- ======================================================= -->
#### Kesim (eşik) tarihi { -}

Tarihlerinizi tek bir yerde tanımlamak ve ardından bunları kodunuzun geri kalanında kullanmak daha kolaydır.

Burada bir başlangıç tarihi (gözlemlerimizin başladığı tarih) ve bir bitiş tarihi (temel dönemimizin sonu olan- ve tahmine ne zaman başlayacağımızın tarihi) tanımlarız. ~Ayrıca ilgilendiğimiz yılda (tahmin edeceğimiz yılda) kaç hafta olduğunu da tanımlarız ~. Ayrıca, temel kesim tarihimiz ile tahmin etmek istediğimiz bitiş tarihi arasında kaç hafta olduğunu da tanımlarız.



<span style="color: black;">**_NOT:_** Bu örnekte, şu anda Eylül 2011'in sonundaymış gibi davranıyoruz (“2011 W39”).</span>  

```{r cut_off}

## başlangıç tarihini tanımlayın (gözlemlerin başladığı zaman)
start_date <- min(counts$epiweek)

## bir bitiş haftası tanımlayın (temel verinin sonu, tahmin döneminin başlangıcı)
cut_off <- yearweek("2010-12-31")

## ilgilenilen son tarihi tanımlayın (yani tahminin sonu)
end_date <- yearweek("2011-12-31")

## ilgilenilen dönemde (yıl) kaç hafta bulun
num_weeks <- as.numeric(end_date - cut_off)

```


<!-- ======================================================= -->
#### Satır eklemek  {.unnumbered}

Tidyverse formatında tahmin yapabilmek için, veri setimizde doğru sayıda satıra, yani yukarıda tanımlanan end_date tarihine kadar her hafta için bir satıra ihtiyacımız var. Aşağıdaki kod, bu satırları bir gruplama değişkenine göre eklemenize izin verir - örneğin, bir veri tabanında birden fazla ülkemiz varsa, ülkeye göre gruplayabilir ve ardından her biri için uygun satırlar ekleyebiliriz. tsibble'ın group_by_key() fonksiyonu , bu gruplandırmayı yapmamıza ve ardından gruplanmış verileri dplyr fonkisyonlarına, group_modify() ve add_row()'a geçirmemize izin verir. Ardından, verilerde mevcut olan maksimum hafta değerinden bir sonraki hafta ile bitiş haftası arasındaki hafta sırasını belirleriz.

```{r add_rows}

## yılın sonuna kadar eksik haftaları ekleyin
counts <- counts %>%
  ## bölgeye göre grup
  group_by_key() %>%
  ## her grup için en yüksek epiweek’ten yıl sonuna kadar satır ekleyin
  group_modify(~add_row(.,
                        epiweek = seq(max(.$epiweek) + 1, 
                                      end_date,
                                      by = 1)))


```



<!-- ======================================================= -->
#### Fourier terimleri {.unnumbered}

Fourier terimlerimizi yeniden tanımlamamız gerekiyor - çünkü bu terimleri temel tarihe uydurmak ve gelecek yıl için ekstrapole etmek istiyoruz. Bunu yapmak için fourier() fonkisyonundan iki çıktı listesini bir araya getirmemiz gerekiyor; ilki temel veriler içindir ve ikincisi ilgilenilen yılı (h argümanını tanımlayarak) tahmin eder.

Not: Satırları bağlamak için rbind() (tidyverse’teki bind_rows yerine) kullanmalıyız, çünkü fourier sütunları bir liste biçimindedir (yani ayrı ayrı adlandırılmaz).

```{r fourier_terms_pred}


## fourier terimlerini tanımlayın (sincos)
counts <- counts %>% 
  mutate(
    ## 2010 kesim tarihinden önceki ve sonraki haftalar için fourier terimlerini birleştirin
    ## (yani 2011 fourier terimleri tahmin edilmektedir)
    fourier = rbind(
      ## önceki yıllar için fourier terimlerini getirin 
      fourier(
        ## sadece 2011'den önceki satırları tutun
        filter(counts, 
               epiweek <= cut_off), 
        ## bir dizi sin cos terimini dahil et
        K = 1
        ), 
      ## 2011 için fourier terimlerini tahmin edin (temel verileri kullanarak)
      fourier(
        ## sadece 2011'den önceki satırları tutun
        filter(counts, 
               epiweek <= cut_off),
        ## bir dizi sin cos terimini dahil et
        K = 1, 
        ## 52 hafta sonrasını tahmin et
        h = num_weeks
        )
      )
    )


```

<!-- ======================================================= -->
#### Verinin bölünmesi ve uyumlu regresyon {.unnumbered}

Şimdi veri setimizi temel periyoda (tahminin başladığı zamana kadarki veri) ve tahmin periyoduna bölmemiz gerekiyor. Bu, group_by()'den sonra dplyr group_split() fonkisyonu kullanılarak yapılır ve biri kesme işleminden önce diğeri sonra olmak üzere iki veri çerçevesi içeren bir liste oluşturur.

Daha sonra veri kümelerini listeden çıkarmak için purrr paketi pluck() fonksiyonunu kullanırız (bu fonksiyon köşeli parantez kullanmaya eşdeğer, örneğin dat[[1]] gibi ) ve daha sonra modelimizi temel verilere uydurabilir ve ardından kesintiden sonra ilgilendiğimiz veri için predict() fonksiyonunu kullanabiliriz.

Purrr hakkında daha fazla bilgi edinmek için Yineleme (iterasyon), döngüler ve listeler sayfasına bakın.


<span style="color: orange;">**_UYARI:_** predict() fonksiyonunda simulate_pi = FALSE argümanının kullanımına dikkat edin. Bunun nedeni, trend oluşturmanın varsayılan davranışının bir tahmin aralığını oluşturmak için ciTools paketinin kullanılmasıdır. NA (eksik) değerler varsa bu fonksiyon çalışmaz ve ayrıca daha granüler aralıklar üretir. Ayrıntılar için ?trending::predict.trending_model_fit'e bakın. </span>  

```{r forecast_regression, warning = FALSE}
# uyum ve tahmin için bölünmüş veriler
dat <- counts %>% 
  group_by(epiweek <= cut_off) %>%
  group_split()

## uydurmak istediğiniz modeli tanımlayın (negatif binom)
model <- glm_nb_model(
  ## set number of cases as outcome of interest
  case_int ~
    ## use epiweek to account for the trend
    epiweek +
    ## use the furier terms to account for seasonality
    fourier
)

# Uyum ve tahmin için hangi verilerin kullanılacağını tanımlayın
fitting_data <- pluck(dat, 2)
pred_data <- pluck(dat, 1) %>% 
  select(case_int, epiweek, fourier)

# modeli uydurun
fitted_model <- trending::fit(model, data.frame(fitting_data))

# Uydurulan veriler için sınır ve tahmin değerleri elde edin
observed <- fitted_model %>% 
  predict(simulate_pi = FALSE)

# tahmin için kullanılacak veri ile tahmin 
forecasts <- fitted_model %>% 
  predict(data.frame(pred_data), simulate_pi = FALSE)

## temel ve tahmin edilmiş veri tabanlarını birleştirin 
observed <- bind_rows(observed, forecasts)


```

Daha önce olduğu gibi modelimizi ggplot ile görselleştirebiliriz. %95 tahmin aralığının üzerindeki gözlemlenen değerleri dikkat çekmek amacıyla kırmızı noktalarla vurgularız. Bu sefer tahminin başladığı tarihi etiketlemek için dikey bir çizgi de ekliyoruz.

```{r forecast_plot}

## regresyonunuzu görselleştirin 
ggplot(data = observed, aes(x = epiweek)) + 
  ## model tahmini için bir satır ekleyin
  geom_line(aes(y = estimate),
            col = "grey") + 
  ## tahmin aralıkları için bir bant ekleyin
  geom_ribbon(aes(ymin = lower_pi, 
                  ymax = upper_pi), 
              alpha = 0.25) + 
  ## gözlemlenen vaka sayılarınız için bir çizgi grafiği ekleyin
  geom_line(aes(y = case_int), 
            col = "black") + 
  ## beklenenin üzerinde gözlenen sayımlar için saçılım grafiği
  geom_point(
    data = filter(observed, case_int > upper_pi), 
    aes(y = case_int), 
    colour = "red", 
    size = 2) + 
  ## tahminin nerede başladığını göstermek için dikey çizgi ve etiket ekleyin
  geom_vline(
           xintercept = as.Date(cut_off), 
           linetype = "dashed") + 
  annotate(geom = "text", 
           label = "Forecast", 
           x = cut_off, 
           y = max(observed$upper_pi) - 250, 
           angle = 90, 
           vjust = 1
           ) + 
  ## geleneksel bir grafik oluşturun (siyah eksenli ve beyaz arka planlı)
  theme_classic()
 
## Uyarı: Eksik değerler içeren 13 satır kaldırıldı(geom_path).

```



<!-- ======================================================= -->
#### Öngörünün doğrulanması (validasyonu)  {.unnumbered}

Artıkları incelemenin ötesinde, modelinizin gelecekteki durumları tahmin etmede ne kadar iyi olduğunu araştırmak önemlidir. Bu size eşik uyarılarınızın ne kadar güvenilir olduğu konusunda fikir verir.

Doğrulamanın geleneksel yolu, önceki yılı ne kadar iyi tahmin edebileceğinizi görmektir (çünkü “şimdiki yıl” için sayıları henüz bilmiyorsunuz).  Örneğin, veri setimizde 2010'u tahmin etmek için 2002'den 2009'a kadar olan verileri kullanıp sonra bu tahminlerin ne kadar doğru olduğunu ölçerdik. Ardından modeli 2010 verilerini içerecek şekilde uygulayıp 2011 sayılarını tahmin etmek için kullanın.

Aşağıdaki şekilde Hyndman ve arkadaşlarının “Tahmin ilkeleri ve uygulaması” bölümünde görülebileceği gibi.
*Hyndman et al* ["Forecasting principles 
and practice"](https://otexts.com/fpp3/). 

![](`r "https://otexts.com/fpp3/fpp_files/figure-html/traintest-1.png"`)
*Görsel yazarlardan alınan izinle yeniden oluşturulmuştur* 

Bu yöntemin dezavantajı, elinizdeki tüm verileri kullanmamanız ve modelin tahmin için kullandığınız son model olmamasıdır.

Bir alternatif, çapraz doğrulama adı verilen bir yöntem kullanmaktır. Bu senaryoda, bir yıl sonrasını tahmin etmek için birden fazla modele uydurabilmek için mevcut tüm verileri kaydırırsınız. Aynı makaleden [Hyndman ve arkadaşlarına ait metninden]((https://otexts.com/fpp3/) alınan aşağıdaki şekilde görüldüğü gibi, her modelde giderek daha fazla veri kullanıyorsunuz. 

Örneğin, ilk model 2003'ü tahmin etmek için 2002'yi kullanıyor , ikincisi 2004'ü tahmin etmek için 2002 ve 2003'ü kullanır, vb.
![](`r "https://otexts.com/fpp2/fpp_files/figure-html/cv1-1.png"`)
*Görsel yazarlardan alınan izinle yeniden oluşturulmuştur*

Aşağıda, veri kümeleri üzerinde döngü işlemini uygulamak için purrr paketinden map() fonksiyonunu kullanıyoruz. Daha sonra, doğruluk ölçülerini hesaplama amacıyla yardstick paketini kullanmak için elde ettiğimiz tahminleri bir veri tabanına aktarır ve orijinal vaka sayılarıyla birleştiririz. Aşağıda belirtilen dört ölçüyü hesaplıyoruz: Kök Ortalama Kare Hatası (RMSE), Ortalama mutlak hata (MAE), Ortalama mutlak ölçekli hata (MASE), Ortalama mutlak yüzde hatası (MAPE).

<span style="color: orange;">**_UYARI:_** predict() fonksiyonunda simulate_pi = FALSE argümanının kullanımına dikkat edin. Bunun nedeni, trend oluşturmanın varsayılan davranışının bir tahmin aralığını oluşturmak için ciTools paketinin kullanılmasıdır. NA (eksik) değerler varsa bu fonksiyon çalışmaz ve ayrıca daha granüler aralıklar üretir. Ayrıntılar için ?trending::predict.trending_model_fit'e bakın. </span>  

```{r cross_validation, warning = FALSE}

## Çapraz doğrulama: Kayan pencereye dayalı olarak önümüzdeki haftaları tahmin etme

## 52 haftalık pencerelerde kaydırarak verilerinizi genişletin (öncesi + sonrası)
## 52 hafta sonrasını tahmin etmek
## (daha uzun gözlem zincirleri oluşturur- eski verileri tutar)

## kaydırmak istediğiniz pencereyi tanımlayın
roll_window <- 52

## tahmin etmek istediğiniz haftaları tanımlayın  
weeks_ahead <- 52

## yinelenen, giderek daha uzun verilerden oluşan bir veri seti oluşturun
## her veri setini benzersiz bir kimlikle etiketleyin
## yalnızca ilgilenilen yıldan önceki vakaları kullanın (yani 2011)
case_roll <- counts %>% 
  filter(epiweek < cut_off) %>% 
  ## sadece hafta ve vaka sayısı değişkenlerini veri tabanında tut 
  select(epiweek, case_int) %>% 
    ## en son x sayıda gözlemi uzaklaştırın 
    ## önümüzdeki kaç haftayı tahmin etmek istediğinize bağlı olarak 
    ## (aksi takdirde "bilinmeyen" için tahmin yapılacaktır)
    slice(1:(n() - weeks_ahead)) %>%
    as_tsibble(index = epiweek) %>% 
    ## gruplandırma kimliği oluşturmak amacıyla x’teki her hafta için kaydırın
    ## kaydırma pencerisinin özgüllüğüne bağlı 
    stretch_tsibble(.init = roll_window, .step = 1) %>% 
  ## önceki vakası yokmuş gibi ilk çifti uzaklaştırın drop the first couple 
  filter(.id > roll_window)

## benzersiz veri setlerinin her biri için aşağıdaki kodu çalıştırın
forecasts <- purrr::map(unique(case_roll$.id), 
                        function(i) {
  
  ## yalnızca mevcut katlantının uygun olmasını sağlayın
  mini_data <- filter(case_roll, .id == i) %>% 
    as_tibble()
  
  ## tahmin için boş bir veri seti oluşturun
  forecast_data <- tibble(
    epiweek = seq(max(mini_data$epiweek) + 1,
                  max(mini_data$epiweek) + weeks_ahead,
                  by = 1),
    case_int = rep.int(NA, weeks_ahead),
    .id = rep.int(i, weeks_ahead)
  )
  
  ## tahmin verilerini orijinale ekleyin
  mini_data <- bind_rows(mini_data, forecast_data)
  
  ## en son eksik olmayan sayım verilerine dayalı olarak kesim tarhini tanımlayın
  cv_cut_off <- mini_data %>% 
    ## sadece eksik olmayan satırları tutun 
    drop_na(case_int) %>% 
    ## en son haftayı elde edin 
    summarise(max(epiweek)) %>% 
    ## bir veri çerçevesinde olmayacak şekilde dışa aktar 
    pull()
  
  ## mini_data’yı tsibble haline getirin
  mini_data <- tsibble(mini_data, index = epiweek)
  
  ## fourier terimlerini tanımlayın (sincos) 
  mini_data <- mini_data %>% 
    mutate(
    ## fourier terimlerini kesim tarihinden önceki ve sonraki haftaları kombine etmek için kullanın 
    fourier = rbind(
      ## önceki yıllardan fourier terimelerini getirin 
      forecast::fourier(
        ## sadece kesim öncesi satırları tutun 
        filter(mini_data, 
               epiweek <= cv_cut_off), 
        ## bir sin cos terim setini dahil edin 
        K = 1
        ), 
      ## takiben eden yıl için fourier terimlerini tahmin edin (temel veriyi kullanarak)
      fourier(
        ## sadece kesim öncesi satırları tutun
        filter(mini_data, 
               epiweek <= cv_cut_off),
        ## bir sin cos terim setini dahil edin
        K = 1, 
        ## 52 hafta sonrasını tahmin edin 
        h = weeks_ahead
        )
      )
    )

  
  
    # uyum ve tahmin için bölünmüş veriler
  dat <- mini_data %>% 
    group_by(epiweek <= cv_cut_off) %>%
    group_split()

  ## uydurmak istediğiniz modeli tanımlayın (negatif binom)
  model <- glm_nb_model(
    ## ilgilenilen çıktı olarak vaka sayısını ayarlayın 
    case_int ~
      ## trendi hesaba katmak için epiweek'i kullanın
      epiweek +
      ## mevsimselliği hesaba katmak için fourier terimlerini kullanın
      fourier
  )

  # Uyum ve tahmin için hangi verilerin kullanılacağını tanımlayın
  fitting_data <- pluck(dat, 2)
  pred_data <- pluck(dat, 1)
  
  # modeli uydurun 
  fitted_model <- trending::fit(model, fitting_data)
  
  # istenilen verilerle tahmin 
  forecasts <- fitted_model %>% 
    predict(data.frame(pred_data), simulate_pi = FALSE) %>% 
    ## sadece hafta ve tahmin değerini tutun 
    select(epiweek, estimate)
    
  }
  )

## listeyi tüm tahminlerle birlikte bir veri çerçevesine dönüştürün
forecasts <- bind_rows(forecasts)

## tahmin ile gözlenen verileri birleştirin 
forecasts <- left_join(forecasts, 
                       select(counts, epiweek, case_int),
                       by = "epiweek")

## {yardstick} ile ölçümlerin hesabı
  ## RMSE: Kök Ortalama Kare Hatası
  ## MAE:  Ortalama mutlak hata 
  ## MASE: Ortalama mutlak ölçekli hata
  ## MAPE: Ortalama mutlak yüzde hatası

model_metrics <- bind_rows(
  ## tahmin edilen veri setinizde gözlemlenen ile tahmin edileni karşılaştırın
  rmse(forecasts, case_int, estimate), 
  mae( forecasts, case_int, estimate),
  mase(forecasts, case_int, estimate),
  mape(forecasts, case_int, estimate),
  ) %>% 
  ## yalnızca metrik türünü ve çıktısını tutun
  select(Metric  = .metric, 
         Measure = .estimate) %>% 
  ## geniş formatta yapın, böylece satırları bağlayın
  pivot_wider(names_from = Metric, values_from = Measure)

## metrik modeli getirin 
model_metrics
  
```


<!-- ======================================================= -->
### **surveillance** paketi {.unnumbered}

Bu bölümde, salgın tespit algoritmalarına dayalı uyarı eşikleri oluşturmak için surveillance paketini kullanıyoruz. Pakette birkaç farklı yöntem mevcuttur, ancak burada iki seçeneğe odaklanacağız. Ayrıntılar için, kullanılan algoritmaların uygulaması ve teorisi hakkındaki bu makalelere bakın. [application](https://cran.r-project.org/web/packages/surveillance/vignettes/monitoringCounts.pdf)
ve [theory](https://cran.r-project.org/web/packages/surveillance/vignettes/glrnb.pdf).

İlk seçenek, iyileştirilmiş Farrington yöntemini kullanır. Bu yöntem, negatif bir binom glm'ye (trend dahil) uyum gösterir ve eşik değeri oluşturmak için geçmiş salgınları (aykırı değerler) düşük değer olarak kullanır. 

İkinci seçenek glrnb yöntemini kullanır. Bu aynı zamanda negatif bir binom glm'ye (genelleştirilmiş doğrusal modele) de uyar, ancak trend ve fourier terimlerini içerir (burada tercih edilir). Regresyon, "kontrol ortalamasını" (~uyumlu değerleri) hesaplamak için kullanılır - daha sonra her hafta için ortalamada kayma olup olmadığını değerlendirmek için hesaplanmış bir genelleştirilmiş olabilirlik oranı (likelihood ratio) istatistiği kullanır. Her hafta için eşiğin önceki haftaları hesaba kattığını unutmayın, bu nedenle sürekli bir kayma varsa bir alarm tetiklenecektir. (Ayrıca her alarmdan sonra algoritmanın sıfırlandığını unutmayın)

surveillance paketiyle çalışmak için öncelikle çerçeveye sığacak bir “gözetim zaman serisi” nesnesi (sts() fonksiyonunu kullanarak) tanımlamamız gerekir.

```{r surveillance_obj}

## gözetim zaman serisi nesnesini tanımla
## not. popülasyon nesnesine bir payda ekleyebilirsiniz (bkz. ?sts)
counts_sts <- sts(observed = counts$case_int[!is.na(counts$case_int)],
                 start = c(
              ## yalnızca start_date tarihinden itibaren yılı tutmak için alt küme
              as.numeric(str_sub(start_date, 1, 4)), 
              ## yalnızca start_date tarihinden itibaren haftayı tutmak için alt küme
              as.numeric(str_sub(start_date, 7, 8))), 
              ## veri türünü tanımlayın (bu durumda haftalık)
              freq = 52)

## dahil etmek istediğiniz hafta aralığını tanımlayın (ör. tahmin dönemi)
## not. sts nesnesi yalnızca kendilerine tanımlanmış hafta ya da yılları atamadan gözlemleri sayar 
## bu nedenle uygun olanı tanımlamak için verilerimizi kullanırız
weekrange <- cut_off - start_date


```

<!-- ======================================================= -->
Daha sonra Farrington yöntemi için parametrelerimizi bir liste halinde tanımlarız. Ardından farringtonFlexible() fonksiyonunu kullanarak algoritmayı çalıştırırız ve ardından bunu veri setimize dahil etmek için farringtonmethod@upperbound kullanarak bir uyarı eşiğini çıkarabiliriz. Farringtonmethod@alarm kullanarak her hafta için uyarı tetiklendiyse (eşiğin üzerindeyse) DOĞRU/YANLIŞ değerlerini çıkarmak da mümkündür. 

```{r farrington}

## kontrolü tanımlayın 
ctrl <- list(
  ## eşik için zaman periyodunu tanımlayın (yani 2011)
  range = which(counts_sts@epoch > weekrange),
  b = 9, ## temelden kaç yıl geriye 
  w = 2, ## haftalar halinde kaydırma penceresi 
  weightsThreshold = 2.58, ## geçmiş salgınların yeniden ağırlıklandırılması (geliştirilmiş noufaily yöntemi - orijinal öneriler 1)
  ## pastWeeksNotIncluded = 3, ## mevcut tüm haftaları kullanın (noufaily önerisi 26’yı çıkarın)
  trend = TRUE,
  pThresholdTrend = 1, ## 0.05 normally, however 1 is advised in the improved method (i.e. always keep)
  thresholdMethod = "nbPlugin",
  populationOffset = TRUE
  )

## farrington’ın esnek yöntemini uygulayın 
farringtonmethod <- farringtonFlexible(counts_sts, ctrl)

## orijinal veri setinde eşik adı verilen yeni bir değişken oluşturun
## farrington'dan gelen üst sınırı içerir
## not: bu yalnızca 2011'deki haftalar içindir (bu nedenle satırları alt kümelere ayırmanız gerekir)
counts[which(counts$epiweek >= cut_off & 
               !is.na(counts$case_int)),
              "threshold"] <- farringtonmethod@upperbound

```

Daha sonra sonuçları daha önce olduğu gibi ggplot'ta görselleştirebiliriz.

```{r plot_farrington, warning=F, message=F}

ggplot(counts, aes(x = epiweek)) + 
  ## gözlemlenen vaka sayılarını bir çizgi olarak ekleyin
  geom_line(aes(y = case_int, colour = "Observed")) + 
  ## sapma algoritmasının üst sınırını ekleyin 
  geom_line(aes(y = threshold, colour = "Alert threshold"), 
            linetype = "dashed", 
            size = 1.5) +
  ## renkleri belirleyin 
  scale_colour_manual(values = c("Observed" = "black", 
                                 "Alert threshold" = "red")) + 
  ## geleneksel bir grafik oluşturun (siyah eksenli ve beyaz arka planlı)
  theme_classic() + 
  ## lejantın (işaret tablosunun) başlığını kaldırın  
  theme(legend.title = element_blank())


```

<!-- ======================================================= -->
#### GLRNB yöntemi {.unnumbered}

Benzer şekilde GLRNB yöntemi için her bir parametremizi bir liste halinde tanımlıyoruz, ardından algoritmayı uygun hale getiriyoruz ve üst sınırları çıkarıyoruz.

<span style="color: orange;">**_UYARI:_** Bu yöntem, eşikleri hesaplamak için "kaba kuvvet" (önyüklemeye [bootstrapping’e] benzer) kullanır, bu nedenle uzun zaman alabilir!</span>

Ayrıntılar için [GLRNB gösterimi](https://cran.r-project.org/web/packages/surveillance/vignettes/glrnb.pdf) 
bakabilirsiniz.

```{r glrnb, warning = FALSE, message = FALSE}

## kontrol ayarlarını belirleyin 
ctrl <- list(
  ## hangi zaman dilimi için eşik değer isteneceğini tanımlayın (yani 2011)
  range = which(counts_sts@epoch > weekrange),
  mu0 = list(S = 1,    ## dahil edilecek fourier terimlerinin (harmonik) sayısı
  trend = TRUE,   ## trendin dahil edilip edilmeyeceği
  refit = FALSE), ## her alarmdan sonra modelin yeniden uydurulup uydurulmayacağı 
  ## cARL = GLR istatistiği için eşik (keyfi)
     ## 3 ~ yanlış pozitifleri en aza indirmek için orta yol
     ## 1, glm.nb'nin %99 tahmin aralığına uyar - zirvelerden sonraki değişikliklerle (uyarı için eşik düşürüldü)
   c.ARL = 2,
   # theta = log(1.5), ## salgın vakalarında %50 artışa eşittir
   ret = "cases"     ## vaka sayısı olarak üst sınıra dönüş eşiği
  )

## glrnb yöntemini uygula
glrnbmethod <- glrnb(counts_sts, control = ctrl, verbose = FALSE)

## orijinal veri setinde eşik adı verilen yeni bir değişken oluşturun
## glrnb'den üst sınırı içeren
## not. bu yalnızca 2011'deki haftalar içindir (bu nedenle satırları alt kümelere ayırmanız gerekir)
counts[which(counts$epiweek >= cut_off & 
               !is.na(counts$case_int)),
              "threshold_glrnb"] <- glrnbmethod@upperbound


```

Çıktıları daha önce olduğu gibi görselleştirin. 

```{r plot_glrnb, message=F, warning=F}

ggplot(counts, aes(x = epiweek)) + 
  ## gözlemlenen vaka sayılarını bir çizgi olarak ekleyin
  geom_line(aes(y = case_int, colour = "Observed")) + 
  ## sapma algoritmasının üst sınırına ekleyin
  geom_line(aes(y = threshold_glrnb, colour = "Alert threshold"), 
            linetype = "dashed", 
            size = 1.5) +
  ## renkleri belirleyin 
  scale_colour_manual(values = c("Observed" = "black", 
                                 "Alert threshold" = "red")) + 
  ## geleneksel bir grafik oluşturun (siyah eksenli ve beyaz arka planlı)
  theme_classic() + 
  ## lejantın (işaret tablosunun) başlığını kaldırın  
  theme(legend.title = element_blank())


```

<!-- ======================================================= -->
## Kesintili zaman serileri  {  }

Kesintili zaman serileri (ayrıca bölümlere ayrılmış regresyon veya müdahale analizi olarak da adlandırılır), genellikle aşıların hastalık insidansı üzerindeki etkisini değerlendirmede kullanılır. Ancak çok çeşitli müdahalelerin etkisini değerlendirmek için kullanılabilir. Örneğin, hastane prosedürlerinde değişiklikler veya bir popülasyona yeni bir hastalık türünün görülmesi. Bu örnekte, 2008'in sonunda Almanya'ya yeni bir Campylobacter türünün geldiğini farz edeceğiz ve bunun vaka sayısını etkileyip etkilemediğini göreceğiz. Negatif binom regresyonunu tekrar kullanacağız. Bu seferki regresyon, müdahaleden önce (veya burada yeni suşun gelişi) ve diğeri (ön/pre- ve son/post dönemler) olmak üzere iki kısma ayrılacaktır. Bu, iki zaman periyodunu karşılaştıran bir insidans oranı hesaplamamızı sağlar. Denklemi açıklamak anlatımı daha net hale getirebilir (eğer değilse, görmezden gelin!).

Negatif binom regresyon aşağıdaki gibi tanımlanabilir:

$$\log(Y_t)= β_0 + β_1 \times t+ β_2 \times δ(t-t_0) + β_3\times(t-t_0 )^+ + log(pop_t) + e_t$$

Neresi:
$Y_t$, $t$ anında gözlemlenen vaka sayısıdır
$pop_t$, $t$ anındaki 100.000'lerdeki nüfus büyüklüğüdür (burada kullanılmaz)
$t_0$ ön dönemin son yılıdır (varsa geçiş süresi dahil)
$δ(x$ gösterge işlevidir (x≤0 ise 0 ve x>0 ise 1'dir)
$(x)^+$ kesme operatörüdür (x>0 ise x, aksi takdirde 0'dır)
$e_t$ kalıntıyı belirtir
Gerektiğinde ek terimler trend ve sezon eklenebilir.

$β_2 \times δ(t-t_0) + β_3\times(t-t_0 )^+$ genelleştirilmiş doğrusaldır
sonrası dönemin bir parçasıdır ve ön dönemde sıfırdır.
Bu, $β_2$ ve $β_3$ tahminlerinin müdahalenin etkileri olduğu anlamına gelir.

Elimizdeki tüm verileri (yani geriye dönük olarak) kullanacağımızdan, burada tahmin yapmadan fourier terimlerini yeniden hesaplamamız gerekiyor. Ek olarak, regresyon için gereken ekstra terimleri hesaplamamız gerekiyor.

```{r define_terms_interrupted}

## epi hafta ve case_int değişkenlerini kullanarak fourier terimleri ekleyin
counts$fourier <- select(counts, epiweek, case_int) %>% 
  as_tsibble(index = epiweek) %>% 
  fourier(K = 1)

## müdahale haftasını tanımla
intervention_week <- yearweek("2008-12-31")

## regresyon için değişkenleri tanımlayın
counts <- counts %>% 
  mutate(
    ## formüldeki t'ye karşılık gelir
      ## hafta sayısı (muhtemelen düz epiweeks değişkenini de kullanabilir)
    # linear = row_number(epiweek), 
    ## formüldeki delta(t-t0)'a karşılık gelir
      ## müdahale öncesi veya sonrası dönem
    intervention = as.numeric(epiweek >= intervention_week), 
    ## formüldeki (t-t0)^+'a karşılık gelir
      ## müdahale sonrası hafta sayısı
      ## (0 ile hesaplanan değer arasındaki sayılardan daha büyük sayıyı seçin)
    time_post = pmax(0, epiweek - intervention_week + 1))

```

Daha sonra bu terimleri negatif bir binom regresyonuna uydurmak için kullanırız ve çıktısı yüzde değişimi olan bir tablo elde ederiz. Bu örnekte, önemli bir değişiklik görülmemiştir.

<span style="color: orange;">**_DİKKAT:_** Npredict() değişkeninde simulate_pi = FALSE kullanımına dikkat edin. Bunun nedeni, trending’in varsayılan davranışının bir tahmin aralığı oluşturmak için ciTools paketini kullanmasıdır. NA (eksik) sayılar varsa bu paket çalışmaz ve daha granüler aralıklar üretir. Ayrıntılar için ?trending::predict.trending_model_fit'e bakın. </span>  

```{r interrupted_regression, warning = FALSE}


## uydurmak istediğiniz modeli tanımlayın (negatif binom)
model <- glm_nb_model(
  ## ilgilenilen çıktı olarak vaka sayısını belirleyeni 
  case_int ~
    ## trendi hesaba katmak için epiweek'i kullanın
    epiweek +
    ## mevsimselliği hesaba katmak için fourier terimlerini kullanın
    fourier + 
    ## öncesi (pre-) veya sonrası (post-) dönemde ekleyin
    intervention + 
    ## müdahale sonrası zamanı ekleyin
    time_post
    )

## sayım veri setini kullanarak modelinizi uydurun 
fitted_model <- trending::fit(model, counts)

## güven ve tahmin aralıklarını hesaplayın
observed <- predict(fitted_model, simulate_pi = FALSE)



## tabloda tahminleri ve yüzde değişimini gösterin 
fitted_model %>% 
  ## orijinal negatif binom regresyonunu çıkarın
  get_model() %>% 
  ## sonuçların düzenli (tidy) veri çerçevesini elde edin 
  tidy(exponentiate = TRUE, 
       conf.int = TRUE) %>% 
  ## sadece müdahale değerini koruyun
  filter(term == "intervention") %>% 
  ## tahmin ve güven aralıkları için IRR'yi yüzde değişikliğine değiştirin
  mutate(
    ## ilgilenilen sütunların her biri için - yeni bir sütun oluşturun
    across(
      all_of(c("estimate", "conf.low", "conf.high")), 
      ## yüzde değişimini hesaplamak için formülü uygulayın
            .f = function(i) 100 * (i - 1), 
      ## yeni sütun adlarına bir sonek "_perc"  ekleyin
      .names = "{.col}_perc")
    ) %>% 
  ## yalnızca belirli sütunları tutun (ve yeniden adlandırın)
  select("IRR" = estimate, 
         "95%CI low" = conf.low, 
         "95%CI high" = conf.high,
         "Percentage change" = estimate_perc, 
         "95%CI low (perc)" = conf.low_perc, 
         "95%CI high (perc)" = conf.high_perc,
         "p-value" = p.value)

```

Daha önce olduğu gibi, regresyonun çıktılarını görselleştirebiliriz.

```{r plot_interrupted}

ggplot(observed, aes(x = epiweek)) + 
  ## gözlemlenen vaka sayılarını bir çizgi olarak ekle
  geom_line(aes(y = case_int, colour = "Observed")) + 
  ## model tahmini için bir satır ekleyin
  geom_line(aes(y = estimate, col = "Estimate")) + 
  ## tahmin aralıkları için bir bant ekleyin
  geom_ribbon(aes(ymin = lower_pi, 
                  ymax = upper_pi), 
              alpha = 0.25) + 
  ## tahminin nerede başladığını göstermek için dikey çizgi ve etiket ekleyin
  geom_vline(
           xintercept = as.Date(intervention_week), 
           linetype = "dashed") + 
  annotate(geom = "text", 
           label = "Intervention", 
           x = intervention_week, 
           y = max(observed$upper_pi), 
           angle = 90, 
           vjust = 1
           ) + 
  ## renkleri tanımlayın
  scale_colour_manual(values = c("Observed" = "black", 
                                 "Estimate" = "red")) + 
  ## geleneksel bir grafik oluşturun (siyah eksenli ve beyaz arka planlı)
  theme_classic()
 
## Uyarı: Eksik değerler içeren 13 satır kaldırıldı (geom_path).


```


<!-- ======================================================= -->
## Kaynaklar {  }

[Tahminleme: İlkeler ve uygulama ders kitabı](https://otexts.com/fpp3/)  
[EPIET zaman serisi analizi vaka çalışmaları](https://github.com/EPIET/TimeSeriesAnalysis)  
[Penn State kursu](https://online.stat.psu.edu/stat510/lesson/1) 
[Surveillance paketi metni](https://www.jstatsoft.org/article/view/v070i10)





```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/time_series.Rmd-->


# Salgın Modelleme { }  


<!-- ======================================================= -->
## Genel Bakış { }

Salgın modelleme için, oldukça karmaşık analizleri minimum çabayla yapmamızı sağlayan, büyüyen bir araç grubu vardır. Bu bölüm, bu araçların aşağıdaki amaçlarla nasıl kullanılacağına ilişkin bir genel bakış sağlayacaktır:

* etkin üreme sayısı R<sub>t</sub> ve iki katına çıkma süresi gibi ilgili istatistikleri tahmin etme
* gelecekteki insidansın kısa vadeli projeksiyonlarını üretme

Bu bölüm araçların altında yatan metodolojilere ve istatistiksel yöntemlere genel bir bakış *değildir*, bu nedenle bu konuyu kapsayan bazı makalelere bağlantılar için lütfen Kaynaklar sekmesine bakınız. Bu araçları kullanmadan önce yöntemleri anladığınızdan emin olun; bu, sonuçlarını doğru bir şekilde yorumlayabilmenizi sağlayacaktır.

Aşağıda, bu bölümde üreteceğimiz çıktılardan birine bir örnek verilmiştir.

```{r out.width=c('100%', '100%'), fig.show='hold', echo=F, fig.width = 12, fig.height = 9, message=F, warning=F}

## "paketleri kurun ve yükleyin"
pacman::p_load(tidyverse, EpiNow2, EpiEstim, here, incidence2, epicontacts, rio, projections)

## satır listesini yükleyin
linelist <- import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

## kişileri oluştur
contacts <- linelist %>%
  transmute(
    from = infector,
    to = case_id
  ) %>%
  drop_na()

## kişi temaslılarını oluştur
epic <- make_epicontacts(
  linelist = linelist,
  contacts = contacts, 
  directed = TRUE
)

## ## gama üretim zamanını tahmin et
## generation_time <- bootstrapped_dist_fit(
##   get_pairwise(epic, "date_infection"),
##   dist = "gamma",
##   max_value = 20,
##   bootstraps = 1
## )

## ## önbelleğe almak için dışa aktar
## export(
##   generation_time,
##   here("data/cache/epidemic_models/generation_time.rds")
## )

## önbelleğe alınmış oluşturma süresini içe aktar
generation_time <- import(here("data/cache/epidemic_models/generation_time.rds"))

## ## inkübasyon zamanını tahmin et
## incubation_period <- bootstrapped_dist_fit(
##   linelist$date_onset - linelist$date_infection,
##   dist = "lognormal",
##   max_value = 100,
##   bootstraps = 1
## )

## ## önbelleğe almak için dışa aktar
## export(
##   incubation_period,
##   here("data/cache/epidemic_models/incubation_period.rds")
## )

## önbelleğe alınmış inkübasyon dönemini içe aktar
incubation_period <- import(here("data/cache/epidemic_models/incubation_period.rds"))

## başlangıç tarihinden itibaren insidansı al
cases <- linelist %>%
  group_by(date = date_onset) %>%
  summarise(confirm = n())

## ## epinow'ı çalıştır
## epinow_res <- epinow(
##   reported_cases = cases,
##   generation_time = generation_time,
##   delays = delay_opts(incubation_period),
##   target_folder = here("data/cache/epidemic_models"),
##   return_output = TRUE,
##   output = "samples",
##   verbose = TRUE,
##   stan = stan_opts(samples = 750, chains = 4),
##   horizon = 21
## )

## ## önbelleğe almak için dışa aktar
## export(
##   epinow_res,
##   here("data/cache/epidemic_models/epinow_res.rds")
## )

## önbelleğe alınmış epinow sonuçlarını içe aktar
epinow_res <- import(here("data/cache/epidemic_models/epinow_res.rds"))

## özet grafiği çiz
plot(epinow_res)

```

<!-- ======================================================= -->
## Hazırlık {  }

R<sub>t</sub> tahmini için **EpiNow** ve **EpiEstim** olmak üzere iki farklı yöntem ve paketin yanı sıra vaka insidansını tahmin etmek için **projections** paketini kullanacağız.

Bu kod parçası, analizler için gereken paketlerin yüklenmesini gösterir.
Bu el kitabında, gerekirse paketi kuran *ve* kullanım için yükleyen **pacman**'dan `p_load()` vurgusunu yapıyoruz.
**base** R'dan `library()` ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakın.

	
```{r epidemic_models_packages, }
pacman::p_load(
   rio,          # dosya içe aktarma
   here,         # dosya konumlama
   tidyverse,    # Veri yönetimi + ggplot2 grafikleri
   epicontacts,  # bulaş ağlarının analizi
   EpiNow2,      # Rt tahminleme
   EpiEstim,     # Rt tahminleme
   projections,  # İnsidans öngörme
   incidence2,   # İnsidans verilerini işleme
   epitrix,      # Faydalı epi fonksiyonları
   distcrete     # Ayrık gecikme dağılımları
)
```
<!--discrete mi distcrete mi??? kodun son fonksiyonunda sıkıntı olabilir ======================================================= -->
	
Bu bölümdeki tüm analizler için temizlenmiş vaka satır listesini kullanacağız. Takip etmek isterseniz, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>"clean" dosyasını indirmek için tıklayın. " </a>
(.rds dosyası olarak). Bu el kitabında kullanılan tüm örnek verileri indirmek için [El kitabı ve verileri indir] sayfasına bakınız.

```{r, echo=F}
# Satır listesini R içine aktarma
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r eval=F}
# temizlenmiş satır listesini içe aktarma
linelist <- import("linelist_cleaned.rds")
```


<!-- ======================================================= -->
## R<sub>t</sub> Tahmini { }

### EpiNow2 vs. EpiEstim {.unnumbered}

Üreme sayısı R, bir hastalığın bulaşıcılığının bir ölçüsüdür ve enfekte vaka başına beklenen ikincil vaka sayısı olarak tanımlanır. Tamamen duyarlı bir popülasyonda bu değer, R<sub>0</sub> (Rnought) temel üreme sayısını temsil eder. Bununla birlikte, bir salgın veya pandemi sırasında bir popülasyondaki duyarlı bireylerin sayısı değiştikçe ve çeşitli müdahale önlemleri uygulandıkça, en yaygın olarak kullanılan ölçüm aktarılabilirlik, etkili üreme sayısıdır R<sub>t</sub>; bu, belirli bir _t_ zamanında virüslü vaka başına beklenen ikincil vaka sayısı olarak tanımlanır.

**EpiNow2** paketi, R<sub>t</sub> tahmini için en gelişmiş çerçeveyi sağlar. Diğer yaygın olarak kullanılan paket olan **EpiEstim**'e göre iki önemli avantajı vardır:

* Raporlamadaki gecikmeleri hesaba katar ve bu nedenle son veriler eksik olsa bile R<sub>t</sub> tahminini yapabilir.
* R<sub>t</sub>'yi raporlamanın başlangıç ​​tarihlerinden ziyade _enfeksiyon tarihlerinde_ tahmin eder; bu, bir müdahalenin etkisinin R<sub>t</sub>'deki bir değişikliğe gecikme ile değil hemen yansıtılacağı anlamına gelir.

Bununla birlikte, aynı zamanda iki önemli dezavantajı vardır:

* Bulaş süresi dağılımı (yani birincil ve ikincil vakaların enfeksiyonu arasındaki gecikmelerin dağılımı), kuluçka dönemi dağılımı (yani enfeksiyon ve semptom başlangıcı arasındaki gecikmelerin dağılımı) ve verilerinizle ilgili herhangi bir başka gecikme dağılımı (ör. raporlama tarihleriniz varsa, semptomların başlangıcından raporlamaya kadar olan gecikmelerin dağılımına ihtiyaç duyarsınız). Bu, R<sub>t</sub>'nin daha doğru bir şekilde tahmin edilmesini sağlayacak olsa da, **EpiEstim** yalnızca seri aralık dağılımını (yani, birincil ve ikincil vakanın semptom başlangıcı arasındaki gecikmelerin dağılımına) ihtiyaç duyar. Elinizdeki tek veri bu olduğunda çok kıymetlidir.

**EpiNow2**, **EpiEstim**'den önemli ölçüde daha yavaştır, anekdot olarak yaklaşık 100-1000 kat! Örneğin, bu bölümde ele alınan örnek salgın için R<sub>t</sub> tahmini yaklaşık dört saat sürer (bu, yüksek doğruluk sağlamak için çok sayıda yineleme için çalıştırılmasındandır. Gerekirse muhtemelen azaltılabilir, ancak ifade edilmek istenen algoritmanın genel olarak yavaş çalıştığıdır). R<sub>t</sub> tahminlerinizi düzenli olarak güncelliyorsanız, kullanışlı olmayabilir.
  
Bu nedenle hangi paketi kullanmayı seçeceğiniz, size sunulan verilere, zamana ve hesaplama kaynaklarına bağlı olacaktır.

### EpiNow2 {.unnumbered}

#### Tahmini gecikme dağılımları {.unnumbered}

**EpiNow2**'yi çalıştırmak için gereken gecikme dağılımları, sahip olduğunuz verilere bağlıdır. Esasen, R<sub>t</sub> tahmininde kullanmak istediğiniz bulaşma tarihinden olay tarihine kadar olan gecikmeyi tanımlayabilmeniz gerekir. Başlangıç ​​tarihlerini kullanıyorsanız, bu sadece kuluçka dönemi dağılımı olacaktır. Raporlama tarihlerini kullanıyorsanız, enfeksiyondan raporlamaya kadar olan gecikmeye ihtiyacınız vardır. Bu dağıtımın doğrudan bilinmesi pek mümkün olmadığından, **EpiNow2** birden çok gecikme dağıtımını birlikte zincirlemenize olanak tanır. Bu durumda, enfeksiyondan semptom başlangıcına (örneğin, muhtemelen bilinen kuluçka dönemi) ve semptom başlangıcından raporlamaya (genellikle verilerden tahmin edebileceğiniz) gecikmeyi bilmelisiniz.

Örnek satır listesindeki tüm vakalarımız için başlangıç ​​tarihlerine sahip olduğumuzdan, verilerimizi (örn. semptom başlangıç ​​tarihleri) enfeksiyon tarihine bağlamak için yalnızca kuluçka dönemi dağılımına ihtiyaç duyacağız. Bu dağılımı verilerden tahmin edebilir veya literatürdeki değerleri kullanabiliriz.

Ebola'nın kuluçka dönemine ilişkin bir literatür tahmini ([bu makaleden](https://www.nejm.org/doi/full/10.1056/nejmoa1411100) alınmıştır) ortalama 9.1, standart sapma 7.3 ve maksimum değer 30 aşağıdaki gibi belirtilecektir:

```{r epidemic_models_incubation_literature, eval=F}
incubation_period_lit <- list(
  mean = log(9.1),
  mean_sd = log(0.1),
  sd = log(7.3),
  sd_sd = log(0.1),
  max = 30
)
```

**EpiNow2** bu gecikme dağılımlarının bir **log** ölçeğinde sağlanmasını gerektirdiğini unutmayın, bu nedenle "log" her değerin etrafında çağrılır (kafa karıştırıcı bir şekilde doğal bir değerde sağlanması gereken "max" parametresi hariç). "mean_sd" ve "sd_sd", ortalamanın standart sapması ve standart sapmasının tahminlerini tanımlamaktadır. Bu durumda bunlar bilinmediğinden, oldukça gelişigüzel 0,1 değerini seçiyoruz.

Bu analizde,  kuluçka dönemi dağılımını tahmin etmemiz gibi değil, satır listesinde enfeksiyon ve başlangıç ​​arasında gözlemlenen gecikmelere uyacak bir lognormal dağılımı 'bootstrapped_dist_fit' fonksiyonu ile tahminliyoruz.

```{r epidemic_models_incubation_estimate, eval=F}
## inkübasyon süresini tahminleme
incubation_period <- bootstrapped_dist_fit(
  linelist$date_onset - linelist$date_infection,
  dist = "lognormal",
  max_value = 100,
  bootstraps = 1
)
```

İhtiyacımız olan diğer dağılım ise üreme süresidir. Bulaşma zamanları __ve__ iletim bağlantılarına ilişkin verilerimiz olduğundan, bu dağılımı, bulaşan-bulaşan çiftlerinin bulaşma süreleri arasındaki gecikmeyi hesaplayarak satır listesinden tahmin edebiliriz. Bunu yapmak için, **epicontacts** paketindeki kullanışlı `get_pairwise` fonksiyonunu kullanıyoruz. Bu, iletim çiftleri arasındaki satır listesi özelliklerinin ikili farklılıklarını hesaplamamıza izin veriyor. Önce bir epicontacts nesnesi oluşturuyoruz (daha fazla ayrıntı için [İletim zincirleri] sayfasına bakabilirsiniz):

```{r epidemic_models_epicontacts, eval=F}
## kişileri oluştur
contacts <- linelist %>%
  transmute(
    from = infector,
    to = case_id
  ) %>%
  drop_na()

## temaslı kişileri oluştur
epic <- make_epicontacts(
  linelist = linelist,
  contacts = contacts, 
  directed = TRUE
)
```

Daha sonra, "get_pairwise" kullanılarak hesaplanan iletim çiftleri arasındaki enfeksiyon sürelerindeki farkı bir gama dağılımına uydururuz:

```{r epidemic_models_generation_estimate, eval=F}
## gama oluşturma süresini tahmin et
generation_time <- bootstrapped_dist_fit(
  get_pairwise(epic, "date_infection"),
  dist = "gamma",
  max_value = 20,
  bootstraps = 1
)
```

#### **EpiNow2** Çalıştırmak {.unnumbered}

Şimdi sadece **dplyr** `group_by()` ve `n()` fonskiyonlarıyla kolayca yapabileceğimiz satır listesinden günlük insidansı hesaplamamız gerekiyor. **EpiNow2** sütun adlarının "date" ve "confirm" olmasını gerektirdiğini unutmayın.

```{r epidemic_models_cases, eval=F}
## başlangıç tarihlerinden insidans almak
cases <- linelist %>%
  group_by(date = date_onset) %>%
  summarise(confirm = n())
```

Daha sonra 'epinow' fonksiyonunu kullanarak R<sub>t</sub> değerini tahmin edebiliriz. Girişlerle ilgili bazı notlar:

* 'delays' değişkenine herhangi bir sayıda 'zincirleme' gecikme dağılımı sağlayabiliriz; onları sadece 'delay_opts' işlevi içindeki incubation_period' nesnesinin yanına ekleyebiliriz.
* "return_output", çıktının yalnızca bir dosyaya kaydedilmesini değil, R içinde döndürülmesini sağlar.
* "verbose" ilerlemenin bir okumasını istediğimizi belirtir.
* "horizon", gelecekteki insidansı kaç gün için tahmin etmek istediğimizi gösterir.
* Çıkarımı ne kadar süreyle çalıştırmak istediğimizi belirtmek için 'stan' değişkenine ek seçenekler iletiyoruz. Artan "örnekler" ve "zincirler", belirsizliği daha iyi karakterize eden daha doğru bir tahmin verecektir, ancak çalışması daha uzun sürecektir..

```{r epidemic_models_run_epinow, eval=F}
## epinow çalıştır
epinow_res <- epinow(
  reported_cases = cases,
  generation_time = generation_time,
  delays = delay_opts(incubation_period),
  return_output = TRUE,
  verbose = TRUE,
  horizon = 21,
  stan = stan_opts(samples = 750, chains = 4)
)
```

#### Çıktıları analiz etme {.unnumbered}

Kodun çalışması bittiğinde, aşağıdaki gibi çok kolay bir şekilde bir özet çizebiliriz. Resmin tamamını görmek için kaydırınız. 


```{r out.width=c('100%', '100%'), fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F }
## özet grafiği çiz
plot(epinow_res)
```

Ayrıca çeşitli özet istatistiklere de bakabiliriz:

```{r epidemic_models_epinow_summary,}
## özet tablo
epinow_res$summary
```

Daha fazla analiz ve özel çizim için, `$estimates$summarised` üzerinden özetlenen günlük tahminlere erişebilirsiniz. **dplyr** ile kullanım kolaylığı için bunu varsayılan 'veri.tablosu'ndan 'tibble'a çevireceğiz.

```{r epidemic_models_to_tibble, eval=F}
## özeti çıkar ve tibble'a dönüştür
estimates <- as_tibble(epinow_res$estimates$summarised)
estimates
```

```{r epidemic_models_tibble_show,  echo = F}
## çıktıları göster
estimates <- as_tibble(epinow_res$estimates$summarised)
DT::datatable(
  estimates,
  rownames = FALSE,
  filter = "top",
  options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap'
)
```

Örnek olarak, ikiye katlama süresinin ve R<sub>t</sub>'nin bir grafiğini yapalım. Aşırı yüksek katlama zamanlarını planlamaktan kaçınmak için, R<sub>t</sub> birin çok üzerinde olduğunda, salgının yalnızca ilk birkaç ayına bakacağız.

Tahmini büyüme oranından iki katına çıkma süresini hesaplamak için "log(2)/growth_rate" formülünü kullanırız.

```{r epidemic_models_plot_epinow_cusotom, out.width=c('100%', '100%'), fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}

## medyan çizim için geniş df yapın
df_wide <- estimates %>%
  filter(
    variable %in% c("growth_rate", "R"),
    date < as.Date("2014-09-01")
  ) %>%
  ## büyüme oranlarını ikiye katlama sürelerine dönüştürme
  mutate(
    across(
      c(median, lower_90:upper_90),
      ~ case_when(
        variable == "growth_rate" ~ log(2)/.x,
        TRUE ~ .x
      )
    ),
    ## dönüşümü yansıtmak için değişkeni yeniden adlandırın
    variable = replace(variable, variable == "growth_rate", "doubling_time")
  )

## nicel çizim için uzun df yapın
df_long <- df_wide %>%
  ## burada eşleşen nicelikleri eşleştiriyoruz (örneğin, alt_90 ila üst_90)
  pivot_longer(
    lower_90:upper_90,
    names_to = c(".value", "quantile"),
    names_pattern = "(.+)_(.+)"
  )

## grafik yapın
ggplot() +
  geom_ribbon(
    data = df_long,
    aes(x = date, ymin = lower, ymax = upper, alpha = quantile),
    color = NA
  ) +
  geom_line(
    data = df_wide,
    aes(x = date, y = median)
  ) +
  ## alt simge etiketine izin vermek için label_parsed kullanın
  facet_wrap(
    ~ variable,
    ncol = 1,
    scales = "free_y",
    labeller = as_labeller(c(R = "R[t]", doubling_time = "Doubling~time"), label_parsed),
    strip.position = 'left'
  ) +
  ## nicel şeffaflığı manuel olarak tanımla
  scale_alpha_manual(
    values = c(`20` = 0.7, `50` = 0.4, `90` = 0.2),
    labels = function(x) paste0(x, "%")
  ) +
  labs(
    x = NULL,
    y = NULL,
    alpha = "Credibel\ninterval"
  ) +
  scale_x_date(
    date_breaks = "1 month",
    date_labels = "%b %d\n%Y"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    strip.background = element_blank(),
    strip.placement = 'outside'
  )

```

<!-- ======================================================= -->
### EpiEstim {.unnumbered}

**EpiEstim**'i çalıştırmak için günlük insidans hakkında veri sağlamamız ve seri aralığı (yani semptomların başlangıcı arasındaki gecikmelerin dağılımını (birincil ve ikincil vakalar) belirtmemiz gerekir).

İnsidans verileri **EpiEstim**'e bir vektör, veri çerçevesi veya orijinal **insidans** paketinden bir "insidans" nesnesi olarak sağlanabilir. İçe aktamalar ve yerel olarak edinilen enfeksiyonlar arasında bile ayrım yapabilirsiniz. Daha fazla detay için `?estimate_R` adresindeki belgelere bakabilirsiniz.


Girdiyi **incidence2** kullanarak oluşturacağız. **incidence2** paketiyle ilgili daha fazla örnek için [Salgın eğrileri] ile ilgili sayfaya bakabilirsiniz. **incidence2** paketinde, "estimateR()"nin beklenen girdisiyle tam olarak uyuşmayan güncellemeler olduğundan, gerekli bazı küçük ek adımlar vardır. İnsidans nesnesi, tarihlerin ve ilgili vaka sayılarının bulunduğu bir tibble'dan oluşur. Tüm tarihlerin dahil edildiğinden emin olmak için **tidyr**'den 'complete()' kullanırız. Daha sonra sonraki bir adımda 'estimate_R()' tarafından beklenenle hizalanacak şekilde sütunları 'yeniden adlandırın()'.

```{r epidemic_models_epiestim_incidence,}
## başlangıç tarihinden itibaren insidansı almak
cases <- incidence2::incidence(linelist, date_index = date_onset) %>% # günlere göre vaka sayılarını al
  tidyr::complete(date_index = seq.Date(                              # tüm tarihlerin temsil edildiğinden emin olun
    from = min(date_index, na.rm = T),
    to = max(date_index, na.rm=T),
    by = "day"),
    fill = list(count = 0)) %>%                                       # NA sayılarını 0'a çevir
  rename(I = count,                                                   # EstimateR'a göre beklenen adlarla yeniden adlandırın
         
         dates = date_index)
```

Paket, ayrıntıları "?estimate_R" adresindeki belgelerde sağlanan seri aralığı belirtmek için çeşitli seçenekler sunar. Biz burada bunlardan ikisini ele alacağız.

#### Literatürden seri aralık tahminlerini kullanma {.unnumbered}

`method = "parametric_si"` seçeneğini kullanarak, make_config` fonksiyonu kullanılarak oluşturulan bir `config` nesnesindeki seri aralığın ortalamasını ve standart sapmasını manuel olarak belirtebiliriz. [Bu belgede] https://bmcmedicine.biomedcentral.com/articles/10.1186/s12916-014-0196-0'da tanımlanan sırasıyla 12,0 ve 5,2'lik bir ortalama ve standart sapma kullanıyoruz:

```{r epidemic_models_epiestim_config,}
## make config
config_lit <- make_config(
  mean_si = 12.0,
  std_si = 5.2
)
```

Daha sonra `estimate_R` fonksiyonuyla R<sub>t</sub> değerini tahmin edebiliriz:

```{r epidemic_models_epiestim_lit,  warning = FALSE}
epiestim_res_lit <- estimate_R(
  incid = cases,
  method = "parametric_si",
  config = config_lit
)
```

ve çıktıların bir özetini çizin:

```{r epidemic_models_epiestim_lit_plot,  warning = FALSE}
plot(epiestim_res_lit)
```

#### Verilerden seri aralık tahminlerini kullanma {.unnumbered}

Semptom başlangıç tarihlerine ve iletim bağlantılarına ilişkin verilere sahip olduğumuz için, bulaştırıcı-enfekte çiftlerinin başlangıç tarihleri arasındaki gecikmeyi hesaplayarak satır listesinden seri aralığı da tahmin edebiliriz. **EpiNow2** bölümünde yaptığımız gibi, **epicontacts** paketindeki `get_pairwise` fonksiyonunu kullanacağız, bu da iletim çiftleri arasındaki satır listesi özelliklerinin ikili farklarını hesaplamamızı sağlar. Önce bir epicontacts nesnesi oluşturuyoruz (daha fazla ayrıntı için [İletim zincirleri] sayfasına bakın):

```{r epidemic_models_epicontacts_epiestim, eval=F}
## kişileri oluştur
contacts <- linelist %>%
  transmute(
    from = infector,
    to = case_id
  ) %>%
  drop_na()

## temaslıları oluştur
epic <- make_epicontacts(
  linelist = linelist,
  contacts = contacts, 
  directed = TRUE
)
```

Daha sonra, "get_pairwise" kullanılarak hesaplanan iletim çiftleri arasındaki başlangıç tarihlerindeki farkı bir gama dağılımına uydururuz. Bu yerleştirme prosedürü için **epitrix** paketindeki kullanışlı 'fit_disc_gamma'yı kullanıyoruz, çünkü bir _ayrıştırılmış_ dağıtıma ihtiyacımız var.

```{r epidemic_models_incubation_estimate_epiestim,  warning = FALSE}
## gama seri aralığını tahmin et
serial_interval <- fit_disc_gamma(get_pairwise(epic, "date_onset"))
```

Daha sonra bu bilgiyi `config` nesnesine iletiyoruz, **EpiEstim**'i tekrar çalıştırıyoruz ve sonuçları çiziyoruz:

```{r epidemic_models_epiestim_emp,  warning = FALSE}
## yapılandırma yap
config_emp <- make_config(
  mean_si = serial_interval$mu,
  std_si = serial_interval$sd
)

## epiestim çalıştır
epiestim_res_emp <- estimate_R(
  incid = cases,
  method = "parametric_si",
  config = config_emp
)

## grafik çıktısı al
plot(epiestim_res_emp)
```

#### Tahmin zaman pencerelerini belirtme {.unnumbered}

Bu varsayılan seçenekler, haftalık kayan bir tahmin sağlar ve kesin bir tahmin için R<sub>t</sub>'ı salgında çok erken tahmin ettiğinize dair bir uyarı görevi görebilir. Aşağıda gösterildiği gibi tahmin için daha ileri bir başlangıç tarihi ayarlayarak bunu değiştirebilirsiniz. Ne yazık ki, **EpiEstim**, her zaman penceresi için başlangıç ve bitiş tarihlerine atıfta bulunan bir _tam sayı_ vektörü sağlamanız gerektiğinden, bu tahmin sürelerini belirtmek için yalnızca çok hantal bir yol sağlar.

```{r epidemic_models_epiestim_config_late,}

## 1 Haziran'da başlayan bir tarih vektörü tanımlayın
start_dates <- seq.Date(
  as.Date("2014-06-01"),
  max(cases$dates) - 7,
  by = 1
) %>%
  ## sayısala dönüştürmek için başlangıç tarihini çıkarın
  `-`(min(cases$dates)) %>%
  ## tam sayıya çevirin
  as.integer()

## bir haftalık sürgülü pencere protokolüne altı gün ekleyin
end_dates <- start_dates + 6
  
## yapılandırma yap
config_partial <- make_config(
  mean_si = 12.0,
  std_si = 5.2,
  t_start = start_dates,
  t_end = end_dates
)
```
Şimdi **EpiEstim**'i yeniden çalıştırıyoruz ve tahminlerin yalnızca Haziran'dan itibaren başladığını görebiliyoruz:

```{r epidemic_models_epiestim_config_late_run,}

## epiestim'i çalıştır
epiestim_res_partial <- estimate_R(
  incid = cases,
  method = "parametric_si",
  config = config_partial
)

## çıktıları grafikleştir
plot(epiestim_res_partial)

```

#### Çıktıları analiz etme {.unnumbered}

Ana çıkışlara `$R` üzerinden erişilebilir. Örnek olarak, bir R<sub>t</sub> grafiği ve R<sub>t</sub> çarpımı ve o gün rapor edilen vaka sayısı tarafından verilen bir "iletim potansiyeli" ölçüsü oluşturacağız. Bu, yeni nesil enfeksiyonda beklenen vaka sayısını temsil eder.

```{r epidemic_models_epiestim_plot_full, out.width=c('100%', '100%'), fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}

## medyan için geniş veri çerçevesi yapın
df_wide <- epiestim_res_lit$R %>%
  rename_all(clean_labels) %>%
  rename(
    lower_95_r = quantile_0_025_r,
    lower_90_r = quantile_0_05_r,
    lower_50_r = quantile_0_25_r,
    upper_50_r = quantile_0_75_r,
    upper_90_r = quantile_0_95_r,
    upper_95_r = quantile_0_975_r,
    ) %>%
  mutate(
    ## medyan tarihini t_start ve t_end'den çıkarın
    dates = epiestim_res_emp$dates[round(map2_dbl(t_start, t_end, median))],
    var = "R[t]"
  ) %>%
  ## günlük insidans verilerinde birleştirme  
  left_join(cases, "dates") %>%
  ## tüm r tahminlerinde riski hesapla
  mutate(
    across(
      lower_95_r:upper_95_r,
      ~ .x*I,
      .names = "{str_replace(.col, '_r', '_risk')}"
    )
  ) %>%
  ## ayrı r tahminleri ve risk tahminleri
  pivot_longer(
    contains("median"),
    names_to = c(".value", "variable"),
    names_pattern = "(.+)_(.+)"
  ) %>%
  ## faktör seviyeleri atamak
  mutate(variable = factor(variable, c("risk", "r")))

## niceliklerden uzun veri çerçevesi yapmak
df_long <- df_wide %>%
  select(-variable, -median) %>%
  ## seperate r/risk estimates and quantile levels
  pivot_longer(
    contains(c("lower", "upper")),
    names_to = c(".value", "quantile", "variable"),
    names_pattern = "(.+)_(.+)_(.+)"
  ) %>%
  mutate(variable = factor(variable, c("risk", "r")))

## grafik yapmak
ggplot() +
  geom_ribbon(
    data = df_long,
    aes(x = dates, ymin = lower, ymax = upper, alpha = quantile),
    color = NA
  ) +
  geom_line(
    data = df_wide,
    aes(x = dates, y = median),
    alpha = 0.2
  ) +
  ## alt simge etiketine izin vermek için label_parsed kullanın
  facet_wrap(
    ~ variable,
    ncol = 1,
    scales = "free_y",
    labeller = as_labeller(c(r = "R[t]", risk = "Transmission~potential"), label_parsed),
    strip.position = 'left'
  ) +
  ## nicel şeffaflığı manuel olarak tanımla
  scale_alpha_manual(
    values = c(`50` = 0.7, `90` = 0.4, `95` = 0.2),
    labels = function(x) paste0(x, "%")
  ) +
  labs(
    x = NULL,
    y = NULL,
    alpha = "Credible\ninterval"
  ) +
  scale_x_date(
    date_breaks = "1 month",
    date_labels = "%b %d\n%Y"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    strip.background = element_blank(),
    strip.placement = 'outside'
  )
  
```

<!-- ======================================================= -->
## Tahmini insidans { }

### EpiNow2 {.unnumbered}

**EpiNow2**, R<sub>t</sub> tahmininin yanı sıra, başlık altındaki **EpiSoon** paketi ile entegrasyon yoluyla R<sub>t</sub> tahminini ve vaka sayılarının projeksiyonlarını da destekler. Tek yapmanız gereken, 'epinow' fonksiyon çağrınızda, geleceğe kaç gün yansıtmak istediğinizi belirten 'horizon' değişkenini belirtmek; **EpiNow2**'nin nasıl kurulup çalıştırılacağına ilişkin ayrıntılar için "R<sub>t</sub> Tahmini" altındaki **EpiNow2** bölümüne bakabilirsiniz. Bu bölümde, "epinow_res" nesnesinde saklanan bu analizin çıktılarını çizeceğiz.

```{r epidemic_models_episoon, out.width=c('100%', '100%'), fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}

## grafik için minimum tarihi belirleyin
min_date <- as.Date("2015-03-01")

## özetlenmiş tahminleri çıkar
estimates <-  as_tibble(epinow_res$estimates$summarised)

## vaka insidansı hakkında ham verileri ayıklayın
observations <- as_tibble(epinow_res$estimates$observations) %>%
  filter(date > min_date)

## vaka sayılarının öngörülen tahminlerini çıkarın
df_wide <- estimates %>%
  filter(
    variable == "reported_cases",
    type == "forecast",
    date > min_date
  )

## nicel çizim için daha da uzun formata dönüştürün
df_long <- df_wide %>%
  ## burada eşleşen nicelikleri eşleştiriyoruz (örneğin, alt_90 ila üst_90)
  pivot_longer(
    lower_90:upper_90,
    names_to = c(".value", "quantile"),
    names_pattern = "(.+)_(.+)"
  )

## çizimi yapın
ggplot() +
  geom_histogram(
    data = observations,
    aes(x = date, y = confirm),
    stat = 'identity',
    binwidth = 1
  ) +
  geom_ribbon(
    data = df_long,
    aes(x = date, ymin = lower, ymax = upper, alpha = quantile),
    color = NA
  ) +
  geom_line(
    data = df_wide,
    aes(x = date, y = median)
  ) +
  geom_vline(xintercept = min(df_long$date), linetype = 2) +
  ## nicel şeffaflığı manuel olarak tanımla
  scale_alpha_manual(
    values = c(`20` = 0.7, `50` = 0.4, `90` = 0.2),
    labels = function(x) paste0(x, "%")
  ) +
  labs(
    x = NULL,
    y = "Daily reported cases",
    alpha = "Credible\ninterval"
  ) +
  scale_x_date(
    date_breaks = "1 month",
    date_labels = "%b %d\n%Y"
  ) +
  theme_minimal(base_size = 14)

```

### Projeksiyonlar {.unnumbered}

RECON tarafından geliştirilen **projeksiyonlar** paketi, etkin üreme sayısı R<sub>t</sub> ve seri aralığı hakkında bilgi gerektiren kısa vadeli insidans tahminleri yapmayı çok kolaylaştırır. Burada literatürden seri aralık tahminlerinin nasıl kullanılacağını ve satır listesinden kendi tahminlerimizin nasıl kullanılacağını ele alacağız.

#### Literatürden seri aralık tahminlerini kullanma {.unnumbered}

**projeksiyonlar**, **discrete** paketinden 'discrete' sınıfının ayrık bir seri aralık dağılımını gerektirir. [Bu yazıda](https://bmcmedicine.biomedcentral.com/articles/10.1186/s12916-014-0196-0) tanımlanan ortalama 12.0 ve standart sapması 5.2 olan bir gama dağılımı kullanacağız. Bu değerleri bir gama dağılımı için gereken şekil ve ölçek parametrelerine dönüştürmek için, **epitrix** paketindeki 'gamma_mucv2shapescale' fonkdiyonunu kullanacağız.

```{r epidemic_models_projections_distcrete,}

## ortalama mu ve katsayısından şekil ve ölçek parametreleri alın
## varyasyon (ör. standart sapmanın ortalamaya oranı)
shapescale <- epitrix::gamma_mucv2shapescale(mu = 12.0, cv = 5.2/12)

## ayrık nesne yapmak
serial_interval_lit <- distcrete::distcrete(
  name = "gamma",
  interval = 1,
  shape = shapescale$shape,
  scale = shapescale$scale
)

```

İşte seri aralığın doğru göründüğünden emin olmak için hızlı bir kontrol. Az önce tanımladığımız gama dağılımının yoğunluğuna, 'dgamma' çağırmaya eşdeğer olan '$d' ile erişiriz:

```{r epidemic_models_projections_distcrete_plot,}

## seri aralığın doğru göründüğünden emin olmak için kontrol edin
qplot(
  x = 0:50, y = serial_interval_lit$d(0:50), geom = "area",
  xlab = "Serial interval", ylab = "Density"
)

```

####  Verilerinden seri aralık tahminlerini kullanma {.unnumbered}

Semptom başlangıç tarihlerine ve iletim bağlantılarına ilişkin verilere sahip olduğumuz için, bulaştırıcı-enfekte çiftlerinin başlangıç tarihleri arasındaki gecikmeyi hesaplayarak satır listesinden seri aralığı da tahmin edebiliriz. **EpiNow2** bölümünde yaptığımız gibi, **epicontacts** paketindeki `get_pairwise` fonksiyonunu kullanacağız. Bu da iletim çiftleri arasındaki satır listesi özelliklerinin ikili farklarını hesaplamamıza izin verir. Önce bir epicontacts nesnesi oluşturuyoruz (daha fazla ayrıntı için [İletim zincirleri] sayfasına bakabilirsiniz:

```{r epidemic_models_epicontacts_projections, eval=F}
## kişileri üretin 
contacts <- linelist %>%
  transmute(
    from = infector,
    to = case_id
  ) %>%
  drop_na()

## temaslı kişileri üretin
epic <- make_epicontacts(
  linelist = linelist,
  contacts = contacts, 
  directed = TRUE
)
```

Daha sonra iletim çiftleri arasındaki başlangıç tarihlerindeki farkı bir gama dağılımına uydururuz, "get_pairwise" kullanarak hesaplarız. _Ayrık_ bir dağıtım gerektirdiğinden, bu yerleştirme prosedürü için **epitrix** paketindeki kullanışlı 'fit_disc_gamma'yı kullanıyoruz.

```{r epidemic_models_incubation_estimate_projections,  warning = FALSE}
## gama seri aralığını tahmin et
serial_interval <- fit_disc_gamma(get_pairwise(epic, "date_onset"))

## tahmini inceleme
serial_interval[c("mu", "sd")]
```

#### Tahmini insidans {.unnumbered}

Gelecekteki vakaları tahmin etmek için, yine de bir “insidans” nesnesi şeklinde tarihsel vakayı ve ayrıca makul R<sub>t</sub> değerleri örneğini sağlamamız gerekiyor. Bu değerleri, önceki bölümde ("Tahmini R<sub>t</sub>" başlığı altında) **EpiEstim** tarafından oluşturulan ve 'epiestim_res_emp' nesnesi içinde depolanan R<sub>t</sub> tahminlerini kullanarak üreteceğiz. Aşağıdaki kodda, R<sub>t</sub> için ortalama ve standart sapma tahminlerini çıkarıyoruz. Salgının son zaman penceresi (bir vektördeki son öğeye erişmek için "tail" fonksiyonunu kullanarak) ve "rgamma" kullanarak bir gama dağılımından 1000 değeri simüle edin. İleriye dönük projeksiyonlar için kullanmak istediğiniz kendi R<sub>t</sub> değerleri vektörünüzü de sağlayabilirsiniz.

```{r epidemic_models_projection_setup,  warning = FALSE}

## başlangıç tarihlerinden insidans nesnesi oluşturun
inc <- incidence::incidence(linelist$date_onset)

## en son tahminden makul r değerleri çıkar
mean_r <- tail(epiestim_res_emp$R$`Mean(R)`, 1)
sd_r <- tail(epiestim_res_emp$R$`Std(R)`, 1)
shapescale <- gamma_mucv2shapescale(mu = mean_r, cv = sd_r/mean_r)
plausible_r <- rgamma(1000, shape = shapescale$shape, scale = shapescale$scale)

## dağıtımı kontrol et
qplot(x = plausible_r, geom = "histogram", xlab = expression(R[t]), ylab = "Counts")

```

Daha sonra gerçek tahmini yapmak için `project()` fonksiyonunu kullanırız. 'n_days' değişkenleri ile kaç gün için projeksiyon yapmak istediğimizi ve 'n_sim' değişkeni kullanarak simülasyonların sayısını belirliyoruz.

```{r epidemic_models_make_projection,}

## projeksiyon yapma
proj <- project(
  x = inc,
  R = plausible_r,
  si = serial_interval$distribution,
  n_days = 21,
  n_sim = 1000
)

```

Daha sonra 'plot()' ve 'add_projections()' fonksiyonlarını kullanarak insidansı ve projeksiyonları kolayca çizebiliriz. Köşeli parantez operatörünü kullanarak yalnızca en son durumları göstermek için 'insidans' nesnesini kolayca alt kümeye koyabiliriz.

```{r epidemic_models_plot_projection, out.width=c('100%', '100%'), fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}

## insidans ve projeksiyon çizimi
plot(inc[inc$dates > as.Date("2015-03-01")]) %>%
  add_projections(proj)

```

Çıktıyı bir veri çerçevesine dönüştürerek günlük vaka sayılarının ham tahminlerini de kolayca çıkarabilirsiniz.

```{r epidemic_models_projection_df, eval=F, warning = FALSE}
## ham veriler için veri çerçevesine dönüştür
proj_df <- as.data.frame(proj)
proj_df
```

```{r epidemic_models_projection_dt,  echo = F}

## ham veriler için veri çerçevesine dönüştür
proj_df <- as.data.frame(proj)

## veri tablosu çıktısı
DT::datatable(
  proj_df[1:11],
  rownames = FALSE,
  filter = "top",
  options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap'
)

```


<!-- ======================================================= -->
## Kaynaklar {  }

* **EpiEstim**'de uygulanan metodolojiyi açıklayan [makale](https://www.sciencedirect.com/science/article/pii/S1755436519300350).
* **EpiNow2**'de uygulanan metodolojiyi açıklayan [makale](https://wellcomeopenresearch.org/articles/5-112/v1).
* R<sub>t</sub> tahminine yönelik çeşitli metodolojik ve pratik hususları açıklayan [makale](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1008409).
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/epidemic_models.Rmd-->


# Temaslı izlemi { }


Bu sayfa, bu tür verilere özgü bazı önemli hususları ve yaklaşımları ekleyerek, kişi izleme verilerinin açıklayıcı analizini gösterir.

Bu sayfa, diğer sayfalarda kapsanan temel R veri yönetimi ve görselleştirme yetkinliklerinin çoğuna atıfta bulunur (ör. veri temizleme, özet oluşturma, tablolar, zaman serisi analizleri), ancak operasyonel karar verme için yararlı olan kişi izlemeye özgü örnekleri yine de vurgulayacağız. Örneğin, zaman içinde veya coğrafi alanlar arasında temaslı izleme takip verilerinin görselleştirilmesini veya ilgili temaslı izleme yöneticileri için temiz Temel Performans Göstergesi (KPI) tablolarının oluşturulmasını içerir.

Gösteri amacıyla [Veriye.Git](https://www.who.int/tools/godata) platformundan örnek temaslı izleme verilerini kullanacağız. Burada kapsanan ilkeler, diğer platformlardan gelen temaslı izleme verileri için geçerli olacaktır - verilerinizin yapısına bağlı olarak yalnızca farklı veri ön işleme adımlarından geçmeniz gerekebilir.

Go.Data projesi hakkında daha fazla bilgiyi [Github Documentation sitesinde](https://worldhealthorganization.github.io/godata/) veya [Community of Practice](https://community-godata.who.int/) sitesinden okuyabilirsiniz.

## Hazırlık


### Paketleri yükleyin {.unnumbered}

Bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran *ve* kullanım için yükleyen **pacman**'dan `p_load()` vurgusunu yapıyoruz. **base** R'dan `library()` ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakın.

```{r, message = F}
pacman::p_load(
  rio,          # veriyi içe aktar  
  here,         # göreli dosya yolları  
  janitor,      # veri temizleme ve tablolar
  lubridate,    # tarihlerle çalışmak
  epikit,       # age_categories() fonksiyonu
  apyramid,     # yal piramitleri
  tidyverse,    # veri işleme ve görselleştirme
  RColorBrewer, # renk paletleri
  formattable,  # süslü tablolar
  kableExtra    # tablo biçimlendirme
)
```


### Verileri içe aktarma {.unnumbered}

Kişilerin ve "takiplerinin" örnek veri kümelerini içe aktaracağız. Bu veriler Go.Data API'sinden alınmış, yuvalanmamış ve ".rds" dosyaları olarak depolanmıştır.

Bu el kitabı için tüm örnek verileri [El kitabını ve verileri indir] sayfasından indirebilirsiniz.

Bu sayfaya özel örnek temaslı izleme verilerini indirmek istiyorsanız, aşağıdaki üç indirme bağlantısını kullanın:

<a href='https://github.com/WorldHealthOrganization/godata/blob/master/analytics/r-reporting/data/cases_clean.rds?raw=true' class='download-button'>
	İndire tıklayınız
	<span>vaka inceleme verileri (.rds file)</span>
</a>

<a href='https://github.com/WorldHealthOrganization/godata/blob/master/analytics/r-reporting/data/contacts_clean.rds?raw=true' class='download-button'>
	İndire tıklayınız
	<span>iletişim kayıt verileri (.rds file)</span>
</a>

<a href='https://github.com/WorldHealthOrganization/godata/blob/master/analytics/r-reporting/data/followups_clean.rds?raw=true' class='download-button'>
	İndire tıklayınız
	<span>temaslı izlem verileri (.rds file)</span>
</a>

<!-- ```{r out.width = "100%", fig.align = "center", echo=F} -->
<!-- knitr::include_graphics(here::here("images", "godata_api_github.png")) -->
<!-- ``` -->


İndirilebilir dosyalardaki orijinal formlarında, veriler Go.Data API'si tarafından sağlanan verileri yansıtır ([API'ler hakkında bilgi edinin](#import_api)). Örneğin, buradaki amaçlar için, bu sayfada okumayı kolaylaştıracak verileri temizleyeceğiz. Bir Go.Data örneği kullanıyorsanız, verilerinizi nasıl alacağınıza ilişkin talimatların tamamını [buradan](https://github.com/WorldHealthOrganization/godata/tree/master/analytics/r-reporting) görüntüleyebilirsiniz.

Aşağıda, veri kümeleri **rio** paketinden `import()` fonksiyonu kullanılarak içe aktarılır. Verileri içe aktarmanın çeşitli yolları için [İçe ve dışa aktar] hakkındaki sayfaya bakın. Dosya yolunu belirtmek için `burada()` kullanıyoruz - bilgisayarınıza özel dosya yolunu sağlamalısınız. Daha sonra gösterim amacıyla basitleştirmek için verilerin yalnızca belirli sütunlarını seçmek için `select()` kullanırız.

#### Vaka verileri {.unnumbered}

Bu veriler, vakaların bir tablosu ve bunlarla ilgili bilgilerdir.

```{r}
cases <- import(here("data", "godata", "cases_clean.rds")) %>% 
  select(case_id, firstName, lastName, gender, age, age_class,
         occupation, classification, was_contact, hospitalization_typeid)
```

` nrow(cases)` vakaları :  

```{r, message=FALSE, echo=F}
DT::datatable(cases, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

#### Kişi verileri {.unnumbered}

Bu veriler, tüm kişilerin ve bunlarla ilgili bilgilerin bir tablosudur. Yine, kendi dosya yolunuzu sağlayın. İçe aktardıktan sonra, aşağıdakileri içeren birkaç ön veri temizleme adımı gerçekleştiririz:

* Age_class'ı bir faktör olarak ayarlayın ve seviye sırasını tersine çevirin, böylece daha genç yaşlar ilk sırada yer alır.
* Birini yeniden adlandırırken yalnızca belirli sütunu seçin
* Bazı örnek görselleştirmelerin netliğini artırmak için, yönetici düzeyi 2 eksik olan satırları "Djembe"ye yapay olarak atayın


```{r}
contacts <- import(here("data", "godata", "contacts_clean.rds")) %>% 
  mutate(age_class = forcats::fct_rev(age_class)) %>% 
  select(contact_id, contact_status, firstName, lastName, gender, age,
         age_class, occupation, date_of_reporting, date_of_data_entry,
         date_of_last_exposure = date_of_last_contact,
         date_of_followup_start, date_of_followup_end, risk_level, was_case, admin_2_name) %>% 
  mutate(admin_2_name = replace_na(admin_2_name, "Djembe"))
```

` nrow(contacts)`, `contacts` verisetinin satırları:  

```{r, message=FALSE, echo=F}
DT::datatable(contacts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

#### Takip verileri {.unnumbered}

Bu veriler, ilgili kişilerle "takip" etkileşimlerinin kayıtlarıdır. Her temasın, maruz kaldıktan sonra 14 gün boyunca her gün bir karşılaşma yapması gerekiyor.

Birkaç temizleme adımını içe aktarıp gerçekleştiriyoruz. Belirli sütunları seçiyoruz ve ayrıca bir karakter sütununu tüm küçük harf değerlerine dönüştürüyoruz.  

```{r}
followups <- rio::import(here::here("data", "godata", "followups_clean.rds")) %>% 
  select(contact_id, followup_status, followup_number,
         date_of_followup, admin_2_name, admin_1_name) %>% 
  mutate(followup_status = str_to_lower(followup_status))
```

" nrow(followups)"-row "followups" veri kümesinin ilk 50 satırı (her satır bir takip etkileşimidir ve sonuç durumu "followup_status" sütunundadır):

```{r, message=FALSE, echo=F}
DT::datatable(head(followups, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

#### İlişki verileri {.unnumbered}

Burada vakalar ve kişiler arasındaki ilişkiyi gösteren verileri içe aktarıyoruz. Gösterilecek belirli bir sütunu seçiyoruz. 

```{r}
relationships <- rio::import(here::here("data", "godata", "relationships_clean.rds")) %>% 
  select(source_visualid, source_gender, source_age, date_of_last_contact,
         date_of_data_entry, target_visualid, target_gender,
         target_age, exposure_type)
```

Aşağıda, vakalar ve ilgili kişiler arasındaki tüm ilişkileri kaydeden "ilişkiler" veri kümesinin ilk 50 satırı verilmiştir.

```{r, message=FALSE, echo=F}
DT::datatable(head(relationships, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```



## Tanımlayıcı analizler

Vakalarınız, temaslılarınız ve ilişkileri hakkında tanımlayıcı analizler yapmak için bu el kitabının diğer sayfalarında kapsanan teknikleri kullanabilirsiniz. Aşağıda bazı örnekler verilmiştir.


### Demografi {.unnumbered}

[Demografik piramitler][Demografik piramitler ve Likert ölçekleri] ile ilgili sayfada gösterildiği gibi, yaş ve cinsiyet dağılımını görselleştirebilirsiniz (burada **apyramid** paketini kullanıyoruz).


#### Temaslıların yaşı ve cinsiyeti {.unnumbered}

Aşağıdaki piramit, temaslıların yaş dağılımını cinsiyete göre karşılaştırmaktadır. Yaşı eksik olan kişilerin en üstteki bilinmeyen çubuklarına dahil edildiğini unutmayın. Bu varsayılan davranışı değiştirebilirsiniz, ancak daha sonra bir başlıkta eksik olan numarayı listelemeyi düşünebilirsiniz.

```{r, warning=F, message=F}
apyramid::age_pyramid(
  data = contacts,                                   # temaslı verisetini kullanma
  age_group = "age_class",                           # kategorik yaş sütunu
  split_by = "gender") +                             # piramidin yarısının cinsiyeti
  labs(
    fill = "Gender",                                 # göstergenin başlığı
    title = "Age/Sex Pyramid of COVID-19 contacts")+ # grafiğin başlığı
  theme_minimal()                                    # basit arkaplan
```


Go.Data veri yapısıyla, 'ilişkiler' veri kümesi hem vakaların hem de ilgili kişilerin yaşlarını içerir, böylece bu veri kümesini kullanabilir ve bu iki insan grubu arasındaki farkları gösteren bir yaş piramidi oluşturabilirsiniz. "İlişkiler" veri çerçevesi, sayısal yaş sütunlarını kategorilere dönüştürmek için değiştirilecektir (bkz. [Temizleme verileri ve temel işlevler] sayfası). Ayrıca, **ggplot2** ile çizimi kolaylaştırmak için veri çerçevesini daha uzun süre döndürürüz (bkz. [Özetleme verileri]).

```{r}
relation_age <- relationships %>% 
  select(source_age, target_age) %>% 
  transmute(                              # transmute, mutate() gibidir ancak bahsedilmeyen tüm diğer sütunları kaldırır
    source_age_class = epikit::age_categories(source_age, breakers = seq(0, 80, 5)),
    target_age_class = epikit::age_categories(target_age, breakers = seq(0, 80, 5)),
    ) %>% 
  pivot_longer(cols = contains("class"), names_to = "category", values_to = "age_class")  


relation_age
```


Şimdi bu dönüştürülmüş veri setini daha önce olduğu gibi 'age_pyramid()' ile çizebiliriz, ancak 'gender' yerine 'category' (temaslı veya vaka) koyabiliriz.

```{r, warning=F, message=F}
apyramid::age_pyramid(
  data = relation_age,                               # değiştirilmiş ilişki veri kümesini kullan
  age_group = "age_class",                           # kategorik yaş sütunu
  split_by = "category") +                           # vakalar ve temaslılar tarafından
  scale_fill_manual(
    values = c("orange", "purple"),                  # renkleri VE etiketleri belirtmek için
    labels = c("Case", "Contact"))+
  labs(
    fill = "Legend",                                           # göstergenin başlığı
    title = "Age/Sex Pyramid of COVID-19 contacts and cases")+ # grafiğin başlığı
  theme_minimal()                                              # basit arkaplan
```

Mesleki dağılım gibi diğer özellikleri de görebiliriz (örneğin pasta grafiği şeklinde).

```{r, warning=F, message=F}
# Veri kümesini temizleyin ve mesleğe göre sayıları alın
occ_plot_data <- cases %>% 
  mutate(occupation = forcats::fct_explicit_na(occupation),  # NA eksik değerleri bir kategori yapın
         occupation = forcats::fct_infreq(occupation)) %>%   # sıklık sırasına göre sıra faktörü seviyeleri
  count(occupation)                                          # mesleğe göre sayıları alın
  
# pasta grafiği yapın
ggplot(data = occ_plot_data, mapping = aes(x = "", y = n, fill = occupation))+
  geom_bar(width = 1, stat = "identity") +
  coord_polar("y", start = 0) +
  labs(
    fill = "Occupation",
    title = "Known occupations of COVID-19 cases")+
  theme_minimal() +                    
  theme(axis.line = element_blank(),
        axis.title = element_blank(),
        axis.text = element_blank())
```


### Vaka başına kişi sayısı {.unnumbered}

Vaka başına temaslı sayısı, temaslı numaralandırmanın kalitesini ve nüfusun halk sağlığı müdahalesine uygunluğunu değerlendirmek için önemli bir ölçü olabilir.

Veri yapınıza bağlı olarak bu, tüm vakaları ve ilgili kişileri içeren bir veri seti ile değerlendirilebilir. Go.Data veri kümelerinde, vakalar ("kaynaklar") ve kişiler ("hedefler") arasındaki bağlantılar "ilişkiler" veri kümesinde depolanır.

Bu veri kümesinde her satır bir ilgili kişidir ve kaynak vaka satırda listelenir. Birden fazla vakayla ilişkisi olan hiç kimse yok, ancak bu varsa, planlamadan önce olanları hesaba katmanız gerekebilir (ve onları da keşfedin!).

Kaynak vaka başına satır (kişi) sayısını sayarak başlarız. Bu bir veri çerçevesi olarak kaydedilir.  

```{r}
contacts_per_case <- relationships %>% 
  count(source_visualid)

contacts_per_case
```

Bu verileri bir histogram olarak çizmek için `geom_histogram()`  kullanıyoruz. 

```{r, warning=F, message=F}
ggplot(data = contacts_per_case)+        # yukarıda oluşturulan sayım veri çerçevesiyle başlayın
  geom_histogram(mapping = aes(x = n))+  # vaka başına kişi sayısının histogramını yazdırın
  scale_y_continuous(expand = c(0,0))+   # y ekseninde 0'ın altındaki fazla boşluğu kaldırın
  theme_light()+                         # arka planı basitleştirin
  labs(
    title = "Number of contacts per case",
    y = "Cases",
    x = "Contacts per case"
  )
  

```



## Temaslı Takibi


Temaslı izleme verileri genellikle karantinadaki kişilerin günlük semptom kontrollerinin sonuçlarını kaydeden "takip" verilerini içerir. Bu verilerin analizi, yanıt stratejisini bilgilendirebilir, takip kaybı riski altındaki veya hastalık geliştirme riski altındaki temaslıları belirleyebilir.



### Veri temizleme {.unnumbered}

Bu veriler çeşitli biçimlerde bulunabilir. Kişi başına bir satır ve takip eden "gün" başına bir sütun içeren "geniş" formatlı bir Excel sayfası olarak bulunabilirler. "Uzun" ve "geniş" verilerin açıklamaları ve verilerin nasıl daha geniş veya daha uzun döndürüleceği için [Pivoting data] bölümüne bakabilirsiniz.

Go.Data örneğimizde, bu veriler, takip etkileşimi başına bir satır ile "uzun" bir formatta olan "takipler" veri çerçevesinde depolanır. İlk 50 satır şöyle görünür:

```{r, message=FALSE, echo=FALSE}
#ilk 50 kişi satır listesi verilerini tablo olarak gösterin
DT::datatable(head(followups, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


<span style="color: orange;">**_UYARI:_** Takip verileriyle uğraşırken mükerrerlere dikkat edin; çünkü belirli bir temaslı için aynı gün içinde birkaç hatalı takip olabilir. Belki bir hata gibi görünüyor ama gerçeği yansıtıyor olabilir - ör. bir iletişim izleyicisi, ilgili kişiye ulaşamadıkları günün erken saatlerinde bir takip formu gönderebilir ve kendilerine daha sonra ulaşıldığında ikinci bir form gönderebilir. Yinelenenleri nasıl ele almak istediğinize ilişkin operasyonel bağlama göre değişecektir. - yalnızca yaklaşımınızı net bir şekilde belgelediğinizden emin olun. </span>

Kaç tane "mükerrer" satır örneğimiz olduğunu *görelim*:

```{r}
followups %>% 
  count(contact_id, date_of_followup) %>%   # benzersiz contact_days alın
  filter(n > 1)                             # sayının 1'den fazla olduğu kayıtları görüntüleyin  
```

Örnek verilerimizde, bunun geçerli olduğu tek kayıt, kimliği eksik olanlardır! Bunları kaldırabiliriz. Ancak, öğretmek amacıyla, tekilleştirme adımlarını göstereceğiz. Böylece kişi başına günde yalnızca bir izlemi yapılan ile muhatap olunur. Daha fazla ayrıntı için [Tekilleştirme] ile ilgili sayfaya bakabilirsiniz. En son karşılaşma kaydının doğru olduğunu varsayacağız. Ayrıca 'followup_number' sütununu (1 - 14 aralığında olması gereken takip "günü") temizleme fırsatını da kullanıyoruz.

```{r, warning=F, message=F}
followups_clean <- followups %>%
  
  # yinelenenleri kaldırın
  group_by(contact_id, date_of_followup) %>%        # temaslı günü başına grup satırları
  arrange(contact_id, desc(date_of_followup)) %>%   # takip tarihine göre her temas günü için satırlar düzenleyin (en son en üstte)
  slice_head() %>%                                  # benzersiz kişi kimliği başına yalnızca ilk satırı tutun  
  ungroup() %>% 
  
  # diğer temizlemeler
  mutate(followup_number = replace(followup_number, followup_number > 14, NA)) %>% # hatalı verileri temizle
  drop_na(contact_id)                               # eksik contact_id olan satırları kaldırın
```

Her takip eden karşılaşma için, bir takip durumumuz var (örneğin, karşılaşmanın olup olmadığı ve olduysa, temasta belirti olup olmadığı gibi). Tüm değerleri görmek için 'followup_status' ile hızlı bir 'tabyl()' (**janitor**'dan) veya 'table()' (R **tabanı**ndan) (bkz. [Tanımlayıcı tablolar]) sonuçların her birinin sıklığını görebilmek için çalıştırabiliriz. 

Bu veri setinde "seen_not_ok", "semptomlarla görülen" ve "seen_ok", "semptomsuz görülen" anlamına gelir.

```{r}
followups_clean %>% 
  tabyl(followup_status)
```


### Zaman içinde grafik {.unnumbered}

Tarih verileri sürekli olduğundan, x eksenine atanan 'date_of_followup' ile bunları çizmek için bir histogram kullanacağız. 'followup_status' sütununa atadığımız 'aes()' içinde bir 'fill = 'değişkenleri belirleyerek "yığınlanmış" bir histogram elde edebiliriz. Sonuç olarak, 'labs()' öğesinin 'fill = ' değişkenini kullanarak gösterge başlığını ayarlayabilirsiniz.

Temaslıların dalgalar halinde tanımlandığını (muhtemelen salgın vaka dalgalarına karşılık gelen) ve takip tamamlamanın salgın boyunca görünüşte iyileşmediğini görebiliriz.

```{r, warning=F, message=F}
ggplot(data = followups_clean)+
  geom_histogram(mapping = aes(x = date_of_followup, fill = followup_status)) +
  scale_fill_discrete(drop = FALSE)+   # göstergedeki tüm faktör seviyelerini (followup_status), kullanılmayanları bile gösterin
  theme_classic() +
  labs(
    x = "",
    y = "Number of contacts",
    title = "Daily Contact Followup Status",
    fill = "Followup Status",
    subtitle = str_glue("Data as of {max(followups$date_of_followup, na.rm=T)}"))   # dinamik altyazı
  
```


<span style="color: orange;">**_UYARI:_** Çok sayıda çizim hazırlıyorsanız (örneğin, birden fazla konu için), göstergelerin değişen seviyelerde veri tamamlama veya veri birleştirme ile bile aynı görünmesini isteyeceksiniz. Verilerde tüm takip durumlarının bulunmadığı grafikler olabilir, ancak yine de bu kategorilerin göstergelerde standart olarak görünmesini istiyorsunuz. Ggplot'larda (yukarıdaki gibi), 'scale_fill_discrete()' için 'drop = FALSE' değişkenini belirtebilirsiniz. Tablolarda, tüm faktör düzeyleri için sayıları gösteren 'tabyl()' kullanın veya **dplyr**'den 'count()' kullanıyorsanız, tüm faktör düzeyleri için sayıları dahil etmek için '.drop = FALSE' bağımsız değişkenini ekleyin.</span>  

### Günlük bireysel izleme {.unnumbered}

Salgınınız yeterince küçükse, her bir kişiye ayrı ayrı bakmak ve takipleri boyunca durumlarını görmek isteyebilirsiniz. Neyse ki, bu "izlemeler" veri kümesi halihazırda takip "sayısı" (1-14) sütununu içeriyor. Verilerinizde bu yoksa, karşılaşma tarihi ile ilgili kişi için takibin başlaması amaçlanan tarih arasındaki farkı hesaplayarak oluşturabilirsiniz.

Uygun bir görselleştirme mekanizması (eğer vaka sayısı çok büyük değilse), `geom_tile()` ile yapılmış bir ısı grafiği olabilir. [Isı grafiği] sayfasında daha fazla ayrıntıya bakın.

```{r, warning=F, message=F}
ggplot(data = followups_clean)+
  geom_tile(mapping = aes(x = followup_number, y = contact_id, fill = followup_status),
            color = "grey")+       # gri kılavuz çizgileri
  scale_fill_manual( values = c("yellow", "grey", "orange", "darkred", "darkgreen"))+
  theme_minimal()+
  scale_x_continuous(breaks = seq(from = 1, to = 14, by = 1))
```


###  Grubuna göre analiz et {.unnumbered}

Belki de bu takip verileri, operasyonel karar verme için günlük veya haftalık olarak görüntülenmektedir. Coğrafi alana veya kişi izleme ekibine göre daha anlamlı ayrıştırmalar isteyebilirsiniz. Bunu `group_by()` için sağlanan sütunları ayarlayarak yapabiliriz.

```{r, warning=F, message=F}

plot_by_region <- followups_clean %>%                                        # takip veri seti ile başlayın
  count(admin_1_name, admin_2_name, followup_status) %>%   # benzersiz bölge durumuna göre sayıları al (sayılarla 'n' sütununu oluşturur)
  
  
  ggplot(                                         # ggplot() başlatın
    mapping = aes(x = reorder(admin_2_name, n),     # 'n' sütunundaki sayısal değerlere göre yönetici faktör düzeylerini yeniden sıralayın
                  y = n,                            # 'n' sütunundan çubuğun yükseklikleri
                  fill = followup_status,           # durumlarına göre renk yığılmış çubuklar
                  label = n))+                      # geom_label()'e geçmek için              
  geom_col()+                                     # yığılmış çubuklar, yukarıdan devredilen haritalama
  geom_text(                                      # metin ekleme, yukarıdan devredilen haritalama
    size = 3,                                         
    position = position_stack(vjust = 0.5), 
    color = "white",           
    check_overlap = TRUE,
    fontface = "bold")+
  coord_flip()+
  labs(
    x = "",
    y = "Number of contacts",
    title = "Contact Followup Status, by Region",
    fill = "Followup Status",
    subtitle = str_glue("Data as of {max(followups_clean$date_of_followup, na.rm=T)}")) +
  theme_classic()+                                                                      # Arka planı basitleştirin
  facet_wrap(~admin_1_name, strip.position = "right", scales = "free_y", ncol = 1)      # yönleri tanıtın

plot_by_region
```

<!-- If this was disaggregated by contact tracer, perhaps we would want to add a threshold line to display total # contacts that normally one person or area/team can handle, and how the current workload compares. We just do this by using `geom_hline()` function. -->

<!-- ```{r, warning=F, message=F} -->

<!-- plot_by_region +  -->
<!--      geom_hline(aes(yintercept=25), color="#C70039", linetype = "dashed") # fictitious threshold at 25 contacts -->

<!-- ``` -->



## KPI Tabloları

Kişi takibi performansını izlemek için farklı ayrıştırma seviyelerinde ve farklı zaman dilimlerinde hesaplanabilen ve izlenebilen bir dizi farklı Temel Performans Göstergesi (KPI) vardır. Hesaplamaları yapıp ve temel tablo formatına sahip olduğunuzda; farklı KPI'ları değiştirmek oldukça kolaydır.

[ResolveToSaveLives.org](https://contacttracingplaybook.resolvetosavelives.org/checklists/metrics) kaynağındaki bu gibi çok sayıda kişi izleme KPI'sı kaynağı vardır. Çalışmanın çoğu, veri yapınızı gözden geçirecek ve tüm dahil etme/hariç tutma kriterlerini düşünecektir. Aşağıda birkaç örnek gösteriyoruz; Go.Data meta veri yapısını kullanarak:

Kategori          | Gösterge                 | Go.Data Numeratör         | Go.Data paydası
------------------|--------------------------|---------------------------|--------------------
Süreç Göstergesi - Temaslı İzleme Hızı|Vaka raporundan sonraki 24 saat içinde görüşülen ve izole edilen vakaların yüzdesi | (``date_of_reporting` - `date_of_data_entry`) < 1 gün VE (`isolation_startdate` - `date_of_data_entry`) < 1 gün OLDUĞU YERDE "case_id" SAYIMI | "case_id" SAYIMI
İşlem Göstergesi - Kişi İzleme Hızı|Alındıktan sonraki 24 saat içinde bildirilen ve karantinaya alınan kişilerin yüzdesi| 'followup_status' == "SEEN_NOT_OK" VEYA "SEEN_OK" VE 'date_of_followup' - 'date_of_reporting' < 1 gün OLDUĞU YERDE 'contact_id' SAYIMI| "contact_id" SAYIMI
Süreç Göstergesi - Testin Tamlığı|Semptomların başlamasından sonraki 3 gün içinde test edilen ve görüşülen yeni semptomatik vakaların yüzdesi|  (`date_of_reporting` - `date_of_onset`) < =3 gün OLDUĞU YERDE "vaka_kimliği" SAYIMI| "vaka_kimliği" SAYIMI
Sonuç Göstergesi - Genel|mevcut kişi listesindeki yeni vakaların yüzdesi| `was_contact` OLDUĞU YERDE `case_id` SAYIMI== "TRUE"| `case_id` SAYIMI

Aşağıda, yönetici alanlarındaki iletişim takibini göstermek için güzel bir tablo görseli oluşturmaya yönelik örnek bir alıştırmayı inceleyeceğiz. Sonunda, **formattable** paketi ile sunuma uygun hale getireceğiz (ancak **flextable** gibi başka paketleri de kullanabilirsiniz - bkz. [Sunum için tablolar]).

Bunun gibi bir tabloyu nasıl oluşturacağınız, temaslı izleme verilerinizin yapısına bağlı olacaktır. **dplyr** fonksiyonlarını kullanarak verileri nasıl özetleyeceğinizi öğrenmek için [Açıklayıcı tablolar] sayfasını kullanın.

Dinamik olacak ve veriler değiştikçe değişecek bir tablo oluşturacağız. Sonuçları ilginç hale getirmek için, tabloyu belirli bir günde çalıştırmayı simüle etmemize izin verecek bir "rapor_tarihi" ayarlayacağız (10 Haziran 2020'yi seçiyoruz). Veriler o tarihe kadar filtrelenir.

```{r, warning=F, message=F}
# Raporun bu tarihten itibaren verilerle çalıştırılmasını simüle etmek için "Rapor tarihi"ni ayarlayın
report_date <- as.Date("2020-06-10")

# Rapor tarihini yansıtacak takip verileri oluşturun.
table_data <- followups_clean %>% 
  filter(date_of_followup <= report_date)
```


Şimdi, veri yapımıza dayanarak aşağıdakileri yapacağız:

1) "Takip" verileriyle başlayın ve her benzersiz kişi için içerecek şekilde özetleyin:
   * En son kayıt tarihi (karşılaşmanın durumu ne olursa olsun)
   * Temaslının "görüldüğü" en son karşılaşma tarihi
   * Nihai "görülen" karşılaşmadaki karşılaşma durumu (örneğin semptomlu, semptomlar olmadan)
2) Bu verileri genel iletişim durumu, bir temaslıya son maruz kalma tarihi vb. gibi diğer bilgileri içeren temaslı verileriyle birleştirin. Ayrıca, son temastan bu yana geçen gün sayısı gibi her bir ilgili temaslı için ilgilenilen metrikleri hesaplayacağız.
3) Gelişmiş iletişim verilerini coğrafi bölgeye (`admin_2_name`) göre gruplandırıyoruz ve bölge başına özet istatistikleri hesaplıyoruz
4) Son olarak, sunum için tabloyu güzelce biçimlendiriyoruz.


İlk olarak, ilgilenilen bilgileri almak için takip verilerini özetliyoruz:

```{r, warning=F, message=F}
followup_info <- table_data %>% 
  group_by(contact_id) %>% 
  summarise(
    date_last_record   = max(date_of_followup, na.rm=T),
    date_last_seen     = max(date_of_followup[followup_status %in% c("seen_ok", "seen_not_ok")], na.rm=T),
    status_last_record = followup_status[which(date_of_followup == date_last_record)]) %>% 
  ungroup()
```

İşte veriler böyle görünüyor: 

```{r, echo=F}
DT::datatable(followup_info, rownames = FALSE, options = list(pageLength = 12, scrollX=T), class = 'white-space: nowrap' )
```


Şimdi bu bilgiyi "kişiler" veri kümesine ekleyeceğiz ve bazı ek sütunları hesaplayacağız.

```{r}
contacts_info <- followup_info %>% 
  right_join(contacts, by = "contact_id") %>% 
  mutate(
    database_date       = max(date_last_record, na.rm=T),
    days_since_seen     = database_date - date_last_seen,
    days_since_exposure = database_date - date_of_last_exposure
    )
```

İşte veriler böyle görünüyor. Sağdaki "kişiler" sütununu ve en sağdaki yeni hesaplanmış sütunu not edin.

```{r, echo=F}
DT::datatable(contacts_info, rownames = FALSE, options = list(pageLength = 12, scrollX=T), class = 'white-space: nowrap' )
```


Ardından, özet istatistik sütunlarından oluşan kısa bir veri çerçevesi elde etmek için kişi verilerini bölgeye göre özetleyeceğiz.

```{r}
contacts_table <- contacts_info %>% 
  
  group_by(`Admin 2` = admin_2_name) %>%
  
  summarise(
    `Registered contacts` = n(),
    `Active contacts`     = sum(contact_status == "UNDER_FOLLOW_UP", na.rm=T),
    `In first week`       = sum(days_since_exposure < 8, na.rm=T),
    `In second week`      = sum(days_since_exposure >= 8 & days_since_exposure < 15, na.rm=T),
    `Became case`         = sum(contact_status == "BECAME_CASE", na.rm=T),
    `Lost to follow up`   = sum(days_since_seen >= 3, na.rm=T),
    `Never seen`          = sum(is.na(date_last_seen)),
    `Followed up - signs` = sum(status_last_record == "Seen_not_ok" & date_last_record == database_date, na.rm=T),
    `Followed up - no signs` = sum(status_last_record == "Seen_ok" & date_last_record == database_date, na.rm=T),
    `Not Followed up`     = sum(
      (status_last_record == "NOT_ATTEMPTED" | status_last_record == "NOT_PERFORMED") &
        date_last_record == database_date, na.rm=T)) %>% 
    
  arrange(desc(`Registered contacts`))

```


```{r, echo=F}
DT::datatable(contacts_table, rownames = FALSE, options = list(pageLength = 12, scrollX=T), class = 'white-space: nowrap' )
```

Ve şimdi, "başlangıç" tarihini gösteren bir dipnot da dahil olmak üzere **biçimlendirilebilir** ve **knitr** paketlerinden stil uyguluyoruz.

```{r}
contacts_table %>%
  mutate(
    `Admin 2` = formatter("span", style = ~ formattable::style(
      color = ifelse(`Admin 2` == NA, "red", "grey"),
      font.weight = "bold",font.style = "italic"))(`Admin 2`),
    `Followed up - signs`= color_tile("white", "orange")(`Followed up - signs`),
    `Followed up - no signs`= color_tile("white", "#A0E2BD")(`Followed up - no signs`),
    `Became case`= color_tile("white", "grey")(`Became case`),
    `Lost to follow up`= color_tile("white", "grey")(`Lost to follow up`), 
    `Never seen`= color_tile("white", "red")(`Never seen`),
    `Active contacts` = color_tile("white", "#81A4CE")(`Active contacts`)
  ) %>%
  kable("html", escape = F, align =c("l","c","c","c","c","c","c","c","c","c","c")) %>%
  kable_styling("hover", full_width = FALSE) %>%
  add_header_above(c(" " = 3, 
                     "Of contacts currently under follow up" = 5,
                     "Status of last visit" = 3)) %>% 
  kableExtra::footnote(general = str_glue("Data are current to {format(report_date, '%b %d %Y')}"))

```


## Bulaş Matrisleri

[Isı grafikleri] sayfasında tartışıldığı gibi, "geom_tile()" kullanarak "kimin kime bulaştırdığını" gösteren bir matris oluşturabilirsiniz.

Yeni kişiler oluşturulduğunda, Go.Data bu ilişki bilgilerini "ilişkiler" API uç noktasında saklar ve bu veri setinin ilk 50 satırını aşağıda görebiliriz. Bu, her bir temasın kendi kaynak durumuna zaten katılmış olduğu göz önüne alındığında, nispeten az adımla bir ısı grafiği oluşturabileceğimiz anlamına gelir.

```{r, warning=F, message=F, echo=F}
# ilişki verilerinin ilk 50 satırını tablo olarak göster
DT::datatable(head(relationships, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Yukarıda vakaları ve ilgili kişileri karşılaştıran yaş piramidi için yapıldığı gibi, ihtiyacımız olan birkaç değişkeni seçebilir ve hem kaynaklar (vakalar) hem de hedefler (temaslılar) için kategorik yaş gruplamaları içeren sütunlar oluşturabiliriz.

```{r}
heatmap_ages <- relationships %>% 
  select(source_age, target_age) %>% 
  mutate(                              # transmute fonksiyonu, mutate() gibidir ancak diğer tüm sütunları kaldırır
    source_age_class = epikit::age_categories(source_age, breakers = seq(0, 80, 5)),
    target_age_class = epikit::age_categories(target_age, breakers = seq(0, 80, 5))) 
```

Daha önce açıklandığı gibi, çapraz tablo oluşturuyoruz;

```{r, warning=F, message=FALSE}

cross_tab <- table(
  source_cases = heatmap_ages$source_age_class,
  target_cases = heatmap_ages$target_age_class)

cross_tab
```

orantılarla uzun biçime dönüştürün;

```{r, warning=FALSE, message=FALSE}

long_prop <- data.frame(prop.table(cross_tab))

```

ve yaşa göre bir ısı haritası oluşturun.


```{r, warning=F, message=F}

ggplot(data = long_prop)+       # oranlarda sıklık olarak uzun veriler kullanın
  geom_tile(                    # görselleştirin
    aes(
      x = target_cases,         # vaka yaşı x ekseninde
      y = source_cases,         # kaynak yaşı y ekseninde
      fill = Freq))+            # arkaplan rengi verilerdeki Sıklık sütunudur
  scale_fill_gradient(          # dolgu rengini ayarlayın
    low = "blue",
    high = "orange")+
  theme(axis.text.x = element_text(angle = 90))+
  labs(                         # etiketler
    x = "Target case age",
    y = "Source case age",
    title = "Who infected whom",
    subtitle = "Frequency matrix of transmission events",
    fill = "Proportion of all\ntranmsission events"     # göstergenin başlığı
  )

```


## Kaynaklar  

https://github.com/WorldHealthOrganization/godata/tree/master/analytics/r-reporting

https://worldhealthorganization.github.io/godata/

https://community-godata.who.int/
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/contact_tracing.Rmd-->


# Anket analizi { }  

<!-- ======================================================= -->
## Genel bakış {  }

Bu sayfa, anket analizi için çeşitli paketlerin kullanımını göstermektedir.

Çoğu anket R paketleri, ağırlıklı analiz yapmak için [**survey** paketine](https://cran.r-project.org/web/packages/survey/index.html) güvenir. **survey** paketinin yanı sıra [**srvyr**](https://cran.r-project.org/web/packages/srvyr/index.html) (tidyverse-stili kodlamaya izin veren bir **survey** sarmalayıcısı) ve [**gtsummary**](https://cran.r-project.org/web/packages/gtsummary/index.html)  (yayına hazır tablolara izin veren bir **survey** sarmalayıcısı) kullanacağız. Orijinal **survey** paketi tidyverse-stili kodlamaya izin vermese de, anket ağırlıklı genelleştirilmiş doğrusal modellere izin verme avantajına sahiptir (bu sayfaya daha sonraki bir tarihte eklenecektir). Örnekleme ağırlıkları oluşturmak için [**sitrep paketinden**](https://github.com/R4EPI/sitrep) bir fonksiyonu kullanmayı da göstereceğiz (*n.b* , bu paket şu anda CRAN'da değil, ancak github'dan kurulabilir).

Bu sayfanın çoğu ["R4Epis" projesi](https://r4epis.netlify.app/) için yapılan çalışmalara dayanmaktadır; ayrıntılı kod ve R-markdown şablonları için ["R4Epis" github sayasına](https://github.com/R4EPI/sitrep) bakabilirsiniz. **survey** paketine ait kodlardan bazıları, [EPIET vaka çalışmalarının](https://github.com/EPIET/RapidAssessmentSurveys) ilk sürümlerini temel almaktadır.

Şu anda bu sayfa, örneklem büyüklüğü hesaplamalarını veya örneklemeyi ele almamaktadır. Örnek boyutu hesaplayıcıyı kullanmak için basit bir kullanım için [OpenEpi'ye](https://www.openepi.com/Menu/OE_Menu.htm) bakabilirsiniz. El kitabının [GIS temelleri](https://epirhandbook.com/gis-basics.html) sayfasında eninde sonunda uzamsal rastgele örnekleme üzerine bir bölüm mevcuttur ve bu sayfa sonunda örnekleme çerçeveleri ve örnek boyutu hesaplamaları hakkında bir bölüme sahip olacaktır.

1. Anket verisi
2. Gözlem süresi
3. Ağırlıklandırma
4. Anket tasarım nesneleri
5. Tanımlayıcı analiz 
6. Ağırlıklı orantılar
7. Ağırlıklı hızlar

<!-- ======================================================= -->
## Hazırlık {  }

### Paketler {.unnumbered}

Bu kod parçası, analizler için gereken paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen **pacman** paketinden `p_load()` fonksiyonunu kullanacağız. Ayrıca  R tabanı'dan `library()` ile paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] sayfasına bakabilirsiniz. 

Burada ayrıca, github'dan henüz CRAN'da yayınlanmayan bir paketi yüklemek için **pacman** paketinden `p_load_gh()` fonksiyonunu kullanmayı gösteriyoruz.

```{r}

## paketleri CRAN'dan yükle
pacman::p_load(rio,          # Dosya içe aktarma
               here,         # Dosya bulucu
               tidyverse,    # veri yönetimi + ggplot2 grafikleri
               tsibble,      # zaman serisi veri kümelerini işleme
               survey,       # anket işlevleri için
               srvyr,        # anket paketi için dplyr sarmalayıcı
               gtsummary,    # tablolar üretmek için anket paketi için sarıcı
               apyramid,     # yaş piramitleri oluşturmaya adanmış bir paket
               patchwork,    # ggplot'ları birleştirmek için
               ggforce       # alüvyon/sankey grafikleri için
               ) 

## paketleri github'dan yükle
pacman::p_load_gh(
     "R4EPI/sitrep"          # gözlem süresi / ağırlıklandırma fonksiyonları için
)

``` 

### Veri yükleme {.unnumbered}

Bu bölümde kullanılan örnek veri kümeleri aşağıda listelenmiştir:

-   kurgusal ölüm anketi verileri.
-   araştırma alanı için kurgusal nüfus sayımları. 
-   kurgusal ölüm anketi verileri için veri sözlüğü.

Bu, MSF OCA etik inceleme kurulu tarafından önceden onaylanmış ankete dayanmaktadır. Kurgusal veri seti ["R4Epis" projesi](https://r4epis.netlify.app/) kapsamında üretilmiştir. Bunların tümü, [Open Data Kit'e](https://opendatakit.org/) dayalı bir veri toplama yazılımı olan [KoboToolbox](https://www.kobotoolbox.org/) kullanılarak toplanan verilere dayanmaktadır.

Kobo, hem toplanan verileri hem de bu veri kümesi için veri sözlüğünü dışa aktarmanıza olanak tanır. Veri temizlemeyi basitleştirdiği ve değişkenleri/soruları aramak için kullanışlı olduğu için bunu yapmanızı şiddetle tavsiye etmekteyiz.


<span style="color: darkgreen;">**_İPUCU:_** Kobo veri sözlüğünün anket sayfasının "name" sütununda değişken adları vardır. Her değişken için olası değerler, seçenekler sayfasında belirtilmiştir. Seçenekler sekmesinde “name” kısaltılmış değere sahiptir ve “label::english” ve “label::french” sütunları gerekli uzun versiyonlara da sahiptir. Bir Kobo sözlük excel dosyasını içe aktarmak için **epidict** paketi `msf_dict_survey()` fonksiyonunu kullanarak bu adları otomatik olarak yeniden biçimlendirebilirsiniz. Bu sayede kodlarınızı tekrardan kullanma şansınız olur.</span>

<span style="color: orange;">**_DİKKAT:_** Bu örnek veri kümesi dışa aktarılan formatı ile aynı değildir (Kobo'da farklı anket düzeylerini ayrı ayrı dışa aktardığınız gibi) - farklı düzeyleri birleştirmek için aşağıdaki anket verileri bölümüne bakmalısınız.</span>

Veri kümesi, **rio** paketinden `import()` fonksiyonu kullanılarak içe aktarılır. Verileri içe aktarmanın çeşitli yolları için [İçe ve dışa aktarma](https://epirhandbook.com/import-and-export.html) sayfasına bakın.

```{r echo = FALSE}
# anket verilerini içe aktar
survey_data <- rio::import(here::here("data", "surveys", "survey_data.xlsx"))

# sözlüğü R’ın içine aktar
survey_dict <- rio::import(here::here("data", "surveys", "survey_dict.xlsx")) 

# nüfus verilerini R’ın içine aktar
population <- rio::import(here::here("data", "surveys", "population.xlsx"))
```

```{r eval = FALSE}
# anket verilerini içe aktar
survey_data <- rio::import("survey_data.xlsx")

# sözlüğü R’ın içine aktar
survey_dict <- rio::import("survey_dict.xlsx") 
```

Anketin ilk 10 satırı aşağıda gösterilmiştir.

```{r, message = FALSE, echo = FALSE}
# anket verilerini tablo olarak göster
DT::datatable(head(survey_data, 10), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Uygun ağırlıklar üretebilmemiz için örneklem popülasyonundaki verileri de içe aktarmak istiyoruz. Bu veriler farklı formatlarda olabilir, ancak aşağıda görüldüğü gibi olmasını öneririz (bu sadece bir excel'e yazılabilir).

```{r read_data_pop_show, eval = FALSE}
# nüfus verilerini içe aktar
population <- rio::import("population.xlsx")
```

Anketin ilk 10 satırı aşağıda gösterilmiştir.

```{r message=FALSE, echo=F}
# anket verilerini tablo olarak göster
DT::datatable(head(population, 10), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Küme anketleri için küme düzeyinde anket ağırlıkları eklemek isteyebilirsiniz. Bu verileri yukarıdaki gibi okuyabilirsiniz. Alternatif olarak, yalnızca birkaç sayı varsa, bunlar bir tibble'a aşağıdaki gibi girilebilir. Her durumda, anket verilerinizle eşleşen bir küme tanımlayıcısına sahip bir sütuna ve her bir kümedeki hane sayısını içeren başka bir sütuna ihtiyacınız olacaktır.

```{r cluster_counts}

## her kümedeki hane sayısını tanımla
cluster_counts <- tibble(cluster = c("village_1", "village_2", "village_3", "village_4", 
                                     "village_5", "village_6", "village_7", "village_8",
                                     "village_9", "village_10"), 
                         households = c(700, 400, 600, 500, 300, 
                                        800, 700, 400, 500, 500))

```

### Veri temizleme {.unnumbered}

Aşağıdaki kodlar, tarih sütununun uygun biçimde olmasını sağlar. Bunu yapmanın başka yolları da vardır (ayrıntılar için [Tarihlerle çalışma](https://epirhandbook.com/working-with-dates.html) sayfasına bakın), ancak tarihleri tanımlamak için sözlüğü kullanmak hızlı ve kolaydır.

Ayrıca **epikit* paketindeki `age_categories()` fonksiyonunu kullanarak bir yaş grubu değişkeni oluşturuyoruz - ayrıntılar için el kitabındaki [Verileri temizleme](https://epirhandbook.com/working-with-dates.html) bölümüne bakabilirsiniz. Ek olarak, çeşitli kümelerin hangi bölgede olduğunu tanımlayan bir karakter değişkeni oluşturuyoruz.

Son olarak, tüm evet/hayır değişkenlerini DOĞRU/YANLIŞ değişkenlere yeniden kodlarız - aksi takdirde bunlar **survey** orantı fonksiyonları tarafından kullanılamaz.

```{r cleaning}

## sözlükten tarih değişkeni adlarını seç 
DATEVARS <- survey_dict %>% 
  filter(type == "date") %>% 
  filter(name %in% names(survey_data)) %>% 
  ## filter to match the column names of your data
  pull(name) # select date vars
  
## tarihleri değiştir
survey_data <- survey_data %>%
  mutate(across(all_of(DATEVARS), as.Date))


## yıl değişkenine yalnızca ay cinsinden yaşı olanları ekle (on ikiye böl)
survey_data <- survey_data %>% 
  mutate(age_years = if_else(is.na(age_years), 
                             age_months / 12, 
                             age_years))

## yaş grubu değişkenini tanımla
survey_data <- survey_data %>% 
     mutate(age_group = age_categories(age_years, 
                                    breakers = c(0, 3, 15, 30, 45)
                                    ))


## farklı bir değişkenin gruplarına dayalı bir karakter değişkeni oluştur
survey_data <- survey_data %>% 
  mutate(health_district = case_when(
    cluster_number %in% c(1:5) ~ "district_a", 
    TRUE ~ "district_b"
  ))


## sözlükten evet/hayır değişken isimlerini seç
YNVARS <- survey_dict %>% 
  filter(type == "yn") %>% 
  filter(name %in% names(survey_data)) %>% 
  ## filter to match the column names of your data
  pull(name) # select yn vars
  
## tarihleri değiştir 
survey_data <- survey_data %>%
  mutate(across(all_of(YNVARS), 
                str_detect, 
                pattern = "yes"))

```



<!-- ======================================================= -->
## Anket verisi {  }

Anketler için kullanılabilecek çok sayıda farklı örnekleme tasarımı vardır. Burada şu kodları göstereceğiz:
- Tabakalı
- Küme
- Tabakalı ve küme

Yukarıda açıklandığı gibi (anketinizi nasıl tasarladığınıza bağlı olarak) her seviye için veriler Kobo'dan ayrı bir veri seti olarak dışa aktarılacaktır. Örneğimizde, haneler için bir düzey ve bu hanelerdeki bireyler için bir düzey vardır.

Bu iki seviye benzersiz bir tanımlayıcı ile birbirine bağlanır. Bir Kobo veri kümesi için bu değişken, bireysel düzeyde "_parent_index" ile eşleşen hane düzeyinde "_index" dir. Bu, eşleşen her bireyle hane için yeni satırlar oluşturacaktır, ayrıntılar için [Verileri ekleme](https://epirhandbook.com/joining-data.html) ilgili el kitabı bölümüne bakabilirsiniz.

```{r merge_data_levels, eval = FALSE}

## eksiksiz bir veri seti oluşturmak için bireysel ve hane verilerini birleştir
survey_data <- left_join(survey_data_hh, 
                         survey_data_indiv,
                         by = c("_index" = "_parent_index"))


## iki düzeyin endekslerini birleştirerek benzersiz bir tanımlayıcı oluştur
survey_data <- survey_data %>% 
     mutate(uid = str_glue("{index}_{index_y}"))

```

<!-- ======================================================= -->
## Gözlem süresi {  }

Mortalite araştırmaları için, ilgilendiğimiz döneme ait uygun bir ölüm oranını hesaplayabilmek için her bireyin bölgede ne kadar süredir bulunduğunu bilmek istiyoruz. Bu, tüm anketlerde geçerli değildir, ancak özellikle ölüm anketleri için bu önemlidir, çünkü bunlar sık sık hareketli veya göç etmiş nüfuslarda kullanılabilir.

Bunu yapmak için önce, geri çağırma dönemi olarak da bilinen ilgilendiğimiz süreyi tanımlarız (yani, katılımcılardan soruları cevaplarken rapor vermelerinin istendiği süre). Daha sonra bu süreyi, uygun olmayan tarihleri kayıp olarak ayarlamak için kullanabiliriz, örneğin ölümler ilgili dönemin dışından bildirilirse.

```{r recall_period}

## geri çağırma süresinin başlangıcını/sonunu ayarla
## veri setinden tarih değişkenleri olarak değiştirilebilir
## (örn. başlangıç tarihi & anket tarihi)
survey_data <- survey_data %>% 
  mutate(recall_start = as.Date("2018-01-01"), 
         recall_end   = as.Date("2018-05-01")
  )


# kurallara göre uygunsuz tarihleri NA olarak ayarla
## örneğin, başlangıçtan önce varışlar, bitişten sonra ayrılışlar
survey_data <- survey_data %>%
      mutate(
           arrived_date = if_else(arrived_date < recall_start, 
                                 as.Date(NA),
                                  arrived_date),
           birthday_date = if_else(birthday_date < recall_start,
                                  as.Date(NA),
                                  birthday_date),
           left_date = if_else(left_date > recall_end,
                              as.Date(NA),
                               left_date),
           death_date = if_else(death_date > recall_end,
                               as.Date(NA),
                               death_date)
           )

```

Daha sonra her birey için başlangıç ve bitiş tarihlerini tanımlamak için tarih değişkenlerimizi kullanabiliriz. Tarihlerin nedenlerini belirlemek için **sitrep** paketinden `find_start_date()` fonksiyonunu kullanabilir ve ardından bunu günler arasındaki farkı (kişi-zaman) hesaplamak için kullanabiliriz.

başlangıç tarihi: Geri çağırma döneminiz içindeki en erken uygun varış olayı Geri çağırma sürenizin başlangıcı (önceden tanımladığınız) veya varsa, geri çağırma başlangıcından sonraki bir tarih (örneğin varışlar veya doğumlar)

bitiş tarihi: Geri çağırma süreniz içindeki en erken uygun ayrılma olayı Geri çağırma sürenizin sonu ya da varsa, geri çağırma süresinin bitiminden önceki bir tarih (örn. ayrılışlar, ölümler)

```{r observation_time}

## başlangıç ve bitiş tarihleri/nedenleri için yeni değişkenler oluştur
survey_data <- survey_data %>% 
     ## ankete girilen en erken tarihi seç
     ## doğumlardan, hane girişlerinden ve kamp varışlarından
     find_start_date("birthday_date",
                  "arrived_date",
                  period_start = "recall_start",
                  period_end   = "recall_end",
                  datecol      = "startdate",
                  datereason   = "startcause" 
                 ) %>%
     ## ankete girilen en erken tarihi seç
     ## kamptan ayrılma, ölüm ve çalışmanın bitiminden
     find_end_date("left_date",
                "death_date",
                period_start = "recall_start",
                period_end   = "recall_end",
                datecol      = "enddate",
                datereason   = "endcause" 
               )


## başlangıçta/sonda olanları etiketle (doğumlar/ölümler hariç)
survey_data <- survey_data %>% 
     mutate(
       ##geri çağırma süresinin başlangıcı olarak başlangıç tarihini gir (boş olanlar için)
       startdate = if_else(is.na(startdate), recall_start, startdate), 
       ## geri çağırma periyoduna eşitse, başlangıç nedenini başlangıçta gösterecek şekilde ayarla
       ## doğum tarihine eşit değilse
       startcause = if_else(startdate == recall_start & startcause != "birthday_date",
                              "Present at start", startcause), 
       ## geri çağırma süresinin bitimi için bitiş tarihini gir (boş olanlar için)
       enddate = if_else(is.na(enddate), recall_end, enddate), 
       ## son nedeni, geri çağırma sonuna eşitse, sonunda sunacak şekilde ayarla
       ## ölüm tarihine eşit olmadıkça
       endcause = if_else(enddate == recall_end & endcause != "death_date", 
                            "Present at end", endcause))


## Gözlem süresini gün olarak tanımla
survey_data <- survey_data %>% 
  mutate(obstime = as.numeric(enddate - startdate))

```


<!-- ======================================================= -->
## Ağırlıklandırma {  }

Anket ağırlıkları eklemeden önce hatalı gözlemleri bırakmanız önemlidir. Örneğin, negatif gözlem süresine sahip gözlemleriniz varsa, bunları kontrol etmeniz gerekecektir (bunu **sitrep** paketinden `assert_positive_timespan()` fonksiyonuyla yapabilirsiniz. Başka bir şey de boş satırlar bırakmak istiyorsanız (örneğin `drop_na(uid)` ile) veya kopyaları kaldırabilirsiniz (ayrıntılar için El Kitabının [Tekilleştirme] bölümüne bakın). İzinsiz olanların da çıkarılması gerekir.

Bu örnekte, bırakmak ve ayrı bir veri çerçevesinde saklamak istediğimiz durumları filtreliyoruz - bu şekilde anketten hariç tutulanları tanımlayabiliriz. Ardından, bu bırakılan durumları anket verilerimizden çıkarmak için **dplyr** paketinden `anti_join()` fonksiyonunu kullanırız.

<span style="color: red;">**_TEHLİKE:_** Ağırlık değişkeninizde veya anket tasarımınızla ilgili herhangi bir değişkende (örneğin yaş, cinsiyet, tabaka veya küme değişkenleri) eksik değerler olamaz.</span>  

```{r remove_unused_data}

## düşürdüğünüz vakaları tanımlayabilmek için sakla (ör.rıza dışı
## veya yanlış köy/küme)
dropped <- survey_data %>% 
  filter(!consent | is.na(startdate) | is.na(enddate) | village_name == "other")

## kullanılmayan satırları anket veri setinden çıkarmak için bırakılan vakaları kullan 
survey_data <- anti_join(survey_data, dropped, by = names(dropped))

```

Yukarıda bahsedildiği gibi, üç farklı çalışma tasarımı (katmanlı, küme ve tabakalı küme) için ağırlıkların nasıl ekleneceğini gösteriyoruz. Bunlar, kaynak popülasyon ve/veya incelenen kümeler hakkında bilgi gerektirir. Bu örnek için tabakalı küme kodunu kullanacağız, ancak çalışma tasarımınız için en uygun olanı kullanın.

```{r survey_weights}

# tabakalı ------------------------------------------------------------------
# "surv_weight_strata" adında bir değişken oluştur
# her birey için ağırlıklar içerir - yaş grubuna, cinsiyete ve sağlık bölgesine göre
survey_data <- add_weights_strata(x = survey_data,
                                         p = population,
                                         surv_weight = "surv_weight_strata",
                                         surv_weight_ID = "surv_weight_ID_strata",
                                         age_group, sex, health_district)

## küme ---------------------------------------------------------------------

# hane başına görüşülen bireylerin kişi sayısını al
# hane (ebeveyn) indeks değişkeni sayılarına sahip bir değişken ekler
survey_data <- survey_data %>%
  add_count(index, name = "interviewed")


## küme ağırlıkları oluştur
survey_data <- add_weights_cluster(x = survey_data,
                                          cl = cluster_counts,
                                          eligible = member_number,
                                          interviewed = interviewed,
                                          cluster_x = village_name,
                                          cluster_cl = cluster,
                                          household_x = index,
                                          household_cl = households,
                                          surv_weight = "surv_weight_cluster",
                                          surv_weight_ID = "surv_weight_ID_cluster",
                                          ignore_cluster = FALSE,
                                          ignore_household = FALSE)


# tabakalı ve küme ---------------------------------------------------------
# küme ve tabalalar için bir anket ağırlığı oluştur
survey_data <- survey_data %>%
  mutate(surv_weight_cluster_strata = surv_weight_strata * surv_weight_cluster)

```


<!-- ======================================================= -->
## Anket tasarım nesneleri {  }

Çalışma tasarımınıza göre anket nesnesi oluşturun. Ağırlık orantılarını vb. hesaplamak için veri çerçeveleri ile aynı şekilde kullanılır. Bundan önce gerekli tüm değişkenlerin oluşturulduğundan emin olun.

Dört seçenek vardır, kullanmadıklarınızı yorumlayarak kodun dışında bırakın:

- Basit rastgele 
- Tabakalı 
- Küme 
- Tabakalı küme

Bu şablon için - anketleri iki ayrı katmanda (sağlık bölgeleri A ve B) gruplandırdığımızı farz edeceğiz. Bu nedenle, genel tahminler elde etmek için küme ve tabaka ağırlıklarının birleştirilmesine ihtiyacımız var.

Daha önce de belirtildiği gibi, bunu yapmak için iki paket mevcuttur. Klasik olan **survey** paketidir; ve daha sonra düzenli tidyverse dostu nesneler ve işlevler yapan **srvyr** adında bir sarmalayıcı paket vardır. Burada her ikisini de göstereceğiz, ancak bu bölümdeki kodun çoğunun **srvyr** tabanlı nesneleri kullanacağını unutmayın. Tek istisna, **gtsummary** paketinin yalnızca anket nesnelerini kabul etmesidir.

### **Survey** paketi

**survey** paketi, R tabanı kodlamasını etkin bir şekilde kullanır ve bu nedenle tüneller (`%>%`) veya diğer **dplyr** sözdizimini kullanmak mümkün değildir. **survey** paketiyle, uygun kümeler, ağırlıklar ve tabakalarla bir anket nesnesi tanımlamak için `svydesign()` fonksiyonunu kullanırız. 

<span style="color: black;">**_NOT:_** Değişkenlerin önünde yaklaşık işareti (`~`) kullanmamız gerekir, bunun nedeni paketin formüllere dayalı değişkenler atamak için R tabanı sözdizimini kullanmasıdır.</span>

```{r survey_design}

# basit rastgele ---------------------------------------------------------------
base_survey_design_simple <- svydesign(ids = ~1, # küme kimliği yok demek için 1
                   weights = NULL,               # Ağırlık eklenmedi
                   strata = NULL,                # örnekleme basitti (tabaka yok)
                   data = survey_data            # veri kümesini belirtmek zorunda
                  )

## tabakalı --------------------------------------------------------------------
base_survey_design_strata <- svydesign(ids = ~1,  # küme kimliği yok demek için 1
                   weights = ~surv_weight_strata, # yukarıda oluşturulan ağırlık değişkeni
                   strata = ~health_district,     # örnekleme bölgelere göre tabakalandırılmıştır
                   data = survey_data             # veri kümesini belirtmek zorunda
                  )

# küme -------------------------------------------------------------------------
base_survey_design_cluster <- svydesign(ids = ~village_name, # küme kimlikleri
                   weights = ~surv_weight_cluster, # yukarıda oluşturulan ağırlık değişkeni
                   strata = NULL,                 # örnekleme basitti (tabaka yok)
                   data = survey_data              # veri kümesini belirtmek zorunda
                  )

# tabakalı küme ----------------------------------------------------------------
base_survey_design <- svydesign(ids = ~village_name,      # küme kimlikleri
                   weights = ~surv_weight_cluster_strata, # yukarıda oluşturulan ağırlık değişkeni
                   strata = ~health_district,             # örnekleme bölgelere göre tabakalandırılmıştır
                   data = survey_data                     # veri kümesini belirtmek zorunda
                  )
```


### **Srvyr** paketi  

**srvyr** paketiyle, yukarıdakiyle aynı argümanlara sahip olan ancak tünellere (`%>%`) izin veren `as_survey_design()` fonksiyonunu kullanabiliriz ve bu nedenle tilde (`~`) kullanmamız gerekmez.

```{r survey_design_srvyr}
## basit rastgele --------------------------------------------------------------
survey_design_simple <- survey_data %>% 
  as_survey_design(ids = 1, # küme kimliği yok demek için 1
                   weights = NULL, # Ağırlık eklenmedi
                   strata = NULL # örnekleme basitti (tabaka yok)
                  )
## tabakalı --------------------------------------------------------------------
survey_design_strata <- survey_data %>%
  as_survey_design(ids = 1, # küme kimliği yok demek için 1
                   weights = surv_weight_strata, # yukarıda oluşturulan ağırlık değişkeni
                   strata = health_district # örnekleme bölgelere göre tabakalandırılmıştır
                  )
## küme ------------------------------------------------------------------------
survey_design_cluster <- survey_data %>%
  as_survey_design(ids = village_name, # küme kimlikleri
                   weights = surv_weight_cluster, # yukarıda oluşturulan ağırlık değişkeni
                   strata = NULL # örnekleme basitti (tabaka yok)
                  )

## tabakalı küme ---------------------------------------------------------------
survey_design <- survey_data %>%
  as_survey_design(ids = village_name, # küme kimlikleri
                   weights = surv_weight_cluster_strata, # yukarıda oluşturulan ağırlık değişkeni
                   strata = health_district # örnekleme bölgelere göre tabakalandırılmıştır
                  )
```

<!-- ======================================================= -->
## Tanımlayıcı analiz {  }

Temel tanımlayıcı analiz ve görselleştirme, el kitabının diğer bölümlerinde kapsamlı bir şekilde ele alınmıştır, bu nedenle burada üzerinde durmayacağız. Ayrıntılar için [tanımlayıcı tablolar](https://epirhandbook.com/descriptive-tables.html), [istatistiksel testler](https://epirhandbook.com/simple-statistical-tests.html), [sunum tabloları](https://epirhandbook.com/tables-for-presentation.html), [ggplot temelleri](https://epirhandbook.com/tables-for-presentation.html) ve [R markdown raporları](https://epirhandbook.com/r-markdown-reports.html) ile ilgili bölümlere bakabilirsiniz.

Bu bölümde, örnekleminizdeki yanlılığı nasıl araştırıp bunu görselleştireceğimize odaklanacağız. Ayrıca alüvyon/sankey diyagramlarını kullanarak bir anket ortamında nüfus akışını görselleştirmeye bakacağız.

Genel olarak, aşağıdaki tanımlayıcı analizleri dahil etmeyi düşünmelisiniz:

- Dahil edilen kümelerin, hanelerin ve bireylerin nihai sayısı
- Dışlanan kişi sayısı ve dışlanma nedenleri
- Küme başına medyan (aralık) hane ve hane başına birey sayısı


### Örnekleme yanlılığı

Örnekleminiz ve kaynak popülasyon arasındaki her yaş grubundaki orantıları karşılaştırın. Bu, potansiyel örnekleme yanlılığını vurgulayabilmek için önemlidir. Benzer şekilde, cinsiyete göre dağılımlara bakarak da bunu tekrarlayabilirsiniz.

Bu p değerlerinin yalnızca gösterge niteliğinde olduğunu ve kaynak popülasyona kıyasla çalışma örneğinizdeki dağılımların açıklayıcı bir tartışmasının (veya aşağıdaki yaş piramitleriyle görselleştirmenin) binom testinin kendisinden daha önemli olduğunu unutmayın. Bunun nedeni, örnek boyutunun artmasının, verilerinizi ağırlıklandırdıktan sonra alakasız olabilecek farklılıklara yol açmamasıdır.


```{r descriptive_sampling_bias, warning = FALSE}

## çalışma popülasyonunun sayıları ve orantıları
ag <- survey_data %>% 
  group_by(age_group) %>% 
  drop_na(age_group) %>% 
  tally() %>% 
  mutate(proportion = n / sum(n), 
         n_total = sum(n))

## kaynak popülasyonun sayıları ve orantıları
propcount <- population %>% 
  group_by(age_group) %>%
    tally(population) %>%
    mutate(proportion = n / sum(n))

## iki tablonun sütunlarını birbirine bağla, yaşa göre grupla ve bir
## n/toplamın popülasyondan önemli ölçüde farklı olup olmadığını görmek için binom testi orantısı.
  ## buradaki son ek, iki veri kümesinin her birindeki sütunların sonuna metne ekler
left_join(ag, propcount, by = "age_group", suffix = c("", "_pop")) %>%
  group_by(age_group) %>%
  ## broom::tidy(binom.test()) binom testinden bir veri çerçevesi yapar ve
  ## p.value, parametre, conf.low, conf.high, method ve değişkenlerini ekleyecektir.
  ## Burada sadece p.value kullanacağız. diğerlerini dahil edebilirsiniz
  ## güven aralıklarını bildirmek istiyorsanız sütunlar
  mutate(binom = list(broom::tidy(binom.test(n, n_total, proportion_pop)))) %>%
  unnest(cols = c(binom)) %>% # important for expanding the binom.test data frame
  mutate(proportion_pop = proportion_pop * 100) %>%
  ## Yanlış pozitifleri düzeltmek için p-değerlerini ayarla
  ## (çünkü birden fazla yaş grubunu test ediyor). Bu sadece yapacak
  ## birçok yaş kategoriniz varsa bir fark verir
  mutate(p.value = p.adjust(p.value, method = "holm")) %>%
                      
  ## Yalnızca 0,001'in üzerindeki p değerlerini göster (<0,001 olarak rapor edilenler)
  mutate(p.value = ifelse(p.value < 0.001, 
                          "<0.001", 
                          as.character(round(p.value, 3)))) %>% 
  
  ## sütunları uygun şekilde yeniden adlandır
  select(
    "Age group" = age_group,
    "Study population (n)" = n,
    "Study population (%)" = proportion,
    "Source population (n)" = n_pop,
    "Source population (%)" = proportion_pop,
    "P-value" = p.value
  )
```



### Demografik piramitler

Demografik (veya yaş-cinsiyet) piramitler, anket popülasyonunuzdaki dağılımı görselleştirmenin kolay bir yoludur. Anket tabaklarına göre yaş ve cinsiyet için [tanımlayıcı tabloları](https://epirhandbook.com/descriptive-tables.html) oluşturmayı da düşünmeye değer. Yukarıda oluşturulan anket tasarım nesnemizi kullanarak ağırlıklı orantılara izin verdiği için **apyramid** paketini kullanmayı göstereceğiz. [Demografik piramitler](https://epirhandbook.com/demographic-pyramids-and-likert-scales.html) oluşturmaya yönelik diğer seçenekler, el kitabının bu bölümünde kapsamlı bir şekilde ele alınmıştır. Ayrıca, orantıları olan bir grafik üretmek için birkaç satır kodlama kaydeden, `age_pyramid()` adlı **sitrep** paketinden bir sarmalayıcı işlevi kullanacağız.

Yukarıda örnekleme yanlılığı bölümünde görülen resmi binom farklılık testinde olduğu gibi, burada örneklenen popülasyonumuzun kaynak popülasyondan önemli ölçüde farklı olup olmadığını ve ağırlıklandırmanın bu farkı düzeltip düzeltmediğini görselleştirmekle ilgileniyoruz. Bunu yapmak için **ggplot** görselleştirmelerimizi yan yana göstermek için **patchwork** paketini kullanacağız; ayrıntılar için el kitabının [ggplot ipuçları](https://epirhandbook.com/ggplot-tips.html?q=patch#combine-plots) bölümündeki grafikleri birleştirme bölümüne bakın. Kaynak popülasyonumuzu, ağırlıksız anket popülasyonumuzu ve ağırlıklı anket popülasyonumuzu görselleştireceğiz. Anketinizin her katmanına göre görselleştirmeyi de düşünebilirsiniz - buradaki örneğimizde bu, `stack_by = "health_district"` argümanını kullanmak olacaktır (ayrıntılar için `?age_pyramid` komutuna bknz.).

<span style="color: black;">**_NOT:_** x ve y eksenleri piramitlerde çevrilir.</span>

```{r weighted_age_pyramid, warning = FALSE, message = FALSE, fig.show = "hold", fig.width = 15}

## x ekseni sınırlarını ve etiketlerini tanımlayın -----------------------------
## (bu sayıları grafiğinizin değerleri olacak şekilde güncelle)
max_prop <- 35      # göstermek istediğiniz en yüksek orantıyı seç
step <- 5           # etiketler arasında istediğiniz boşluğu seç

## bu kısım, vektörü yukarıdaki sayıları kullanarak eksen sonları ile tanımlar.
breaks <- c(
    seq(max_prop/100 * -1, 0 - step/100, step/100), 
    0, 
    seq(0 + step / 100, max_prop/100, step/100)
    )

## bu kısım vektörü yukarıdaki sayıları kullanarak eksen limitleri ile tanımlar.
limits <- c(max_prop/100 * -1, max_prop/100)

## bu kısım, vektörü, eksen etiketleriyle birlikte yukarıdaki sayıları kullanarak tanımlar.
labels <-  c(
      seq(max_prop, step, -step), 
      0, 
      seq(step, max_prop, step)
    )


## ayrı ayrı grafikler oluştur  ------------------------------------------------

## kaynak popülasyonu grafiklendir 
## not: bunun genel nüfus için daraltılması gerekiyor (yani sağlık bölgelerinin kaldırılması)
source_population <- population %>%
  ## yaş ve cinsiyetin faktörler olduğundan emin ol
  mutate(age_group = factor(age_group, 
                            levels = c("0-2", 
                                       "3-14", 
                                       "15-29",
                                       "30-44", 
                                       "45+")), 
         sex = factor(sex)) %>% 
  group_by(age_group, sex) %>% 
  ## birlikte her sağlık bölgesi için sayıları ekle
  summarise(population = sum(population)) %>% 
  ## genel orantıyı hesaplayabilmek için gruplandırmayı kaldır
  ungroup() %>% 
  mutate(proportion = population / sum(population)) %>% 
  ## piramid grafiği
  age_pyramid(
            age_group = age_group, 
            split_by = sex, 
            count = proportion, 
            proportional = TRUE) +
  ## sadece y ekseni etiketini göster (aksi takdirde her üç çizimde de tekrarlanır)
  labs(title = "Source population", 
       y = "", 
       x = "Age group (years)") + 
  ## x eksenini tüm grafikler için aynı yap
  scale_y_continuous(breaks = breaks, 
    limits = limits, 
    labels = labels)
  
  
## ağırlıksız örnek popülasyonunu grafiklendir
sample_population <- age_pyramid(survey_data, 
                 age_group = "age_group", 
                 split_by = "sex",
                 proportion = TRUE) + 
  ## sadece x ekseni etiketini göster (aksi takdirde her üç grafikte de tekrarlanır)
  labs(title = "Unweighted sample population", 
       y = "Proportion (%)", 
       x = "") + 
  ## x eksenini tüm grafikler için aynı yap
  scale_y_continuous(breaks = breaks, 
    limits = limits, 
    labels = labels)


## ağırlıklı örnek popülasyonunu grafiklendir 
weighted_population <- survey_design %>% 
  ## değişkenlerin faktör olduğundan emin ol
  mutate(age_group = factor(age_group), 
         sex = factor(sex)) %>%
  age_pyramid(
    age_group = "age_group",
    split_by = "sex", 
    proportion = TRUE) +
  ## sadece x ekseni etiketini göster (aksi takdirde her üç grafikte de tekrarlanır)
  labs(title = "Weighted sample population", 
       y = "", 
       x = "")  + 
  ## x eksenini tüm grafikler için aynı yap
  scale_y_continuous(breaks = breaks, 
    limits = limits, 
    labels = labels)

## üç grafiğin tümünü birleştir ------------------------------------------------
## + kullanarak üç grafiği yan yana birleştir
source_population + sample_population + weighted_population + 
  ## sadece bir legand göster ve temayı tanımla 
  ## temayı plot_layout() ile birleştirmek için & kullanımına dikkat et
  plot_layout(guides = "collect") & 
  theme(legend.position = "bottom",                    # açıklamayı aşağıya taşı
        legend.title = element_blank(),                # başlığı kaldır
        text = element_text(size = 18),                # metin boyutunu değiştir
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1) # x ekseni metnini çevir
       )
```


### Alluvial/sankey diagramı

Bireyler için başlangıç noktalarını ve sonuçları görselleştirmek, genel bir bakış elde etmek için çok yardımcı olabilir. Mobil popülasyonlar için oldukça açık bir uygulama var, ancak kohortlar veya bireyler için durumlarda geçişlerin olduğu diğer durumlar gibi çok sayıda başka uygulama var. Bu diyagramların alüvyon, sankey ve paralel kümeler dahil olmak üzere birkaç farklı adı vardır - ayrıntılar el kitabının [Diyagramlar ve çizelgeler](https://epirhandbook.com/diagrams-and-charts.html#alluvialsankey-diagrams) bölümündedir.

```{r visualise_population_flow}

## verileri özetle
flow_table <- survey_data %>%
  count(startcause, endcause, sex) %>%  # sayımları al 
  gather_set_data(x = c("startcause", "endcause"))     # grafiklendirme için formatı değiştir


## veri kümesini çiz 
  ## x ekseninde başlangıç ve bitiş nedenleri
  ## gather_set_data, her olası kombinasyon için bir kimlik oluşturur
  ## y ile bölme, olası başlangıç/bitiş kombinasyonlarını verir
  ## n'nin sayı olarak verdiği değer (orantı olarak da değiştirilebilir)
ggplot(flow_table, aes(x, id = id, split = y, value = n)) +
  ## cinsiyete göre renk çizgileri
  geom_parallel_sets(aes(fill = sex), alpha = 0.5, axis.width = 0.2) +
  ## etiket kutularını gri doldur
  geom_parallel_sets_axes(axis.width = 0.15, fill = "grey80", color = "grey80") +
  ## metin rengini ve açısını değiştir (ayarlanması gerekiyor)
  geom_parallel_sets_labels(color = "black", angle = 0, size = 5) +
  ## ayarlanmış y ve x eksenleri (muhtemelen daha fazla dikey alana ihtiyaç duyar)
  scale_x_discrete(name = NULL, expand = c(0, 0.2)) + 
  ## eksen etiketlerini kaldır
  theme(
    title = element_text(size = 26),
    text = element_text(size = 26),
    axis.line = element_blank(),
    axis.ticks = element_blank(),
    axis.text.y = element_blank(),
    panel.background = element_blank(),
    legend.position = "bottom",                    # açıklamayı aşağıya taşı
    legend.title = element_blank(),                # başlığı kaldır
  )

```


<!-- ======================================================= -->
## Ağırlıklı orantılar {  }

Bu bölüm, ilişkili güven aralıkları ve tasarım etkisi ile birlikte ağırlıklı sayımlar ve oranlar için tabloların nasıl üretileceğini detaylandıracaktır. Aşağıdaki paketlerdeki işlevleri kullanan dört farklı seçenek vardır: **survey**, **srvyr**, **sitrep** ve **gtsummary**. Standart bir epidemiyoloji stili tablosu oluşturmak üzere minimum kodlama için, **srvyr** kodunun sarmalayıcısı olan **sitrep** fonksiyonunu öneriyoruz; Ancak bunun henüz CRAN'da olmadığını ve gelecekte değişebileceğini unutmayın. Aksi takdirde, **survey** kodu muhtemelen en istikrarlı ve uzun vadeli paket olacaktır, oysa **srvyr** paketi en iyi şekilde derli toplu iş akışlarına uymaktadır. **gtsummary** fonksiyonları çok fazla potansiyele sahip olsa da, bu kitap yazıldığı sırada deneysel ve eksiktirler.


### **Survey** paketi 

Ağırlıklı orantılar ve beraberindeki %95 güven aralıklarını elde etmek için **survey** paketinden `svyciprop()` fonksiyonunu kullanabiliriz. Uygun bir tasarım efekti, `svyprop()` fonksiyonu yerine `svymean()` kullanılarak da çıkarılabilir. `svyprop()` fonksiyonunun yalnızca 0 ile 1 (veya DOĞRU/YANLIŞ) arasındaki değişkenleri kabul ediyor gibi göründüğünü, dolayısıyla kategorik değişkenlerin çalışmayacağını belirtmekte fayda var.

<span style="color: black;">**_NOT:_** **survey** paketinden gelen foksiyonlar ayrıca **srvyr** tasarım nesnelerini de kabul etmektedir, ancak burada anket **survey** nesnesini yalnızca tutarlılık için kullandık. </span>


```{r survey_props}

## ağırlıklı sayılar üretme
svytable(~died, base_survey_design)

## ağırlıklı orantılar üretme
svyciprop(~died, base_survey_design, na.rm = T)

## tasarım efektini al
svymean(~died, base_survey_design, na.rm = T, deff = T) %>% 
  deff()

```

Yukarıda gösterilen **survey** fonksiyonları, aşağıda kendimizi tanımladığımız, `svy_prop` adlı bir fonksiyonda birleştirebiliriz; ve daha sonra bu fonksiyonu **purrr** paketindeki `map()` ile birlikte birkaç değişken üzerinde [yineleme](https://epirhandbook.com/iteration-loops-and-lists.html)  yapmak ve bir tablo oluşturmak için kullanabiliriz. **purrr** hakkında ayrıntılar için el kitabı yineleme bölümüne bakabilirsiniz.

```{r survey_prop_fun}
# Ağırlıklı sayıları, oranlatıları, CI ve tasarım etkisini hesaplamak için fonksiyonu tanımla
# x tırnak içindeki değişkendir 
# tasarım, sizin anket tasarım nesnenizdir

svy_prop <- function(design, x) {
  
  ## ilgilenilen değişkeni bir formüle koy
  form <- as.formula(paste0( "~" , x))
  ## svytable'dan yalnızca DOĞRU sayım sütununu sakla
  weighted_counts <- svytable(form, design)[[2]]
  ## orantıları hesapla (yüzdeleri almak için 100 ile çarpın)
  weighted_props <- svyciprop(form, design, na.rm = TRUE) * 100
  ## güven aralıklarını çıkarın ve yüzdeleri elde etmek için çarp
  weighted_confint <- confint(weighted_props) * 100
  ## tasarım etkisini hesaplamak için svymean kullanın ve yalnızca DOĞRU sütununu koru
  design_eff <- deff(svymean(form, design, na.rm = TRUE, deff = TRUE))[[TRUE]]
  
  ## tek bir veri çerçevesinde birleştir
  full_table <- cbind(
    "Variable"        = x,
    "Count"           = weighted_counts,
    "Proportion"      = weighted_props,
    weighted_confint, 
    "Design effect"   = design_eff
    )
  
  ## tabloyu veri çerçevesi olarak döndür
  full_table <- data.frame(full_table, 
             ## remove the variable names from rows (is a separate column now)
             row.names = NULL)
  
  ## sayısalları tekrar sayısal olarak değiştir
  full_table[ , 2:6] <- as.numeric(full_table[, 2:6])
  
  ## veri çerçevesini döndür
  full_table
}

## bir tablo oluşturmak için birkaç değişken üzerinde yineleme yap
purrr::map(
  ## ilgilenilen değişkenleri tanımla
  c("left", "died", "arrived"), 
  ## durum fonksiyonu kullanımı ve bu fonksiyon için argümanlar (tasarım)
  svy_prop, design = base_survey_design) %>% 
  ## listeyi tek bir veri çerçevesine daralt
  bind_rows() %>% 
  ## yuvarla
  mutate(across(where(is.numeric), round, digits = 1))

```


### **Srvyr** paketi 

**srvyr** ile bir tablo oluşturmak için **dplyr** sözdizimini kullanabiliriz. `survey_mean()` fonksiyonunun kullanıldığını ve orantı argümanının belirtildiğini ve ayrıca tasarım etkisini hesaplamak için aynı fonksiyonu kullanıldığını unutmayın. Bunun nedeni, **srvyr** paketinin yukarıdaki bölümde kullanılan `svyciprop()` ve `svymean()` **survey** paketi fonksiyonun her ikisinin de etrafını sarmasıdır.

<span style="color: black;">**_NOT:_** Kategorik değişkenlerden orantıları **srvyr** paketini kullanarak da almak pek mümkün görünmüyor, buna ihtiyacınız varsa **sitrep** paketini kullanmanız gerekir. Detaylar için aşağıdaki bölüme göz atın.</span>

```{r srvyr_prop}

## srvyr tasarım nesnesini kullan
survey_design %>% 
  summarise(
    ## ağırlıklı sayıları üret
    counts = survey_total(died), 
    ## ağırlıklı orantıları ve güven aralıkları üret
    ## yüzde almak için 100 ile çarp
    props = survey_mean(died, 
                        proportion = TRUE, 
                        vartype = "ci") * 100, 
    ## tasarım efekti üret
    deff = survey_mean(died, deff = TRUE)) %>% 
  ## sadece ilgi alanlarını tut
  ## (standart hataları bırakın ve orantı hesaplamasını tekrarla)
  select(counts, props, props_low, props_upp, deff_deff)

```

Burada da **purrr** paketini kullanarak birden çok değişken üzerinde [yineleme](https://epirhandbook.com/iteration-loops-and-lists.html) yapacak bir fonksiyon yazabiliriz. **purrr** hakkında ayrıntılar için el kitabı yineleme bölümüne bakabilirsiniz.

```{r srvyr_prop_fun}

# Ağırlıklı sayıları, orantıları, CI ve tasarım etkisini hesaplamak için işlevi tanımla
# tasarım, sizin anket tasarım nesnenizdir
# x tırnak içindeki değişkendir


srvyr_prop <- function(design, x) {
  
  summarise(
    ## anket tasarım nesnesini kullan
    design, 
    ## ağırlıklı sayıları üret
    counts = survey_total(.data[[x]]), 
    ## ağırlıklı orantıları ve güven aralıkları üret
    ## yüzde almak için 100 ile çarp
    props = survey_mean(.data[[x]], 
                        proportion = TRUE, 
                        vartype = "ci") * 100, 
    ## tasarım efekti üret
    deff = survey_mean(.data[[x]], deff = TRUE)) %>% 
  ## değişken adını ekle
  mutate(variable = x) %>% 
  ## sadece ilgi alanlarını tut
  ## (standart hataları bırak ve orantı hesaplamasını tekrarla)
  select(variable, counts, props, props_low, props_upp, deff_deff)
  
}
  

## bir tablo oluşturmak için birkaç değişken üzerinde yineleme yap
purrr::map(
  ## ilgilenilen değişkenleri tanımla
  c("left", "died", "arrived"), 
  ## durum fonksiyonu kullanımı ve bu fonksiyon için argümanlar (tasarım)
  ~srvyr_prop(.x, design = survey_design)) %>% 
  ## listeyi tek bir veri çerçevesine daralt
  bind_rows()
  

```


### **Sitrep** paketi

**sitrep** paketinin `tab_survey()` fonksiyonu, minimum kodlama ile ağırlıklı tablolar oluşturmanıza olanak tanıyan **srvyr** paketi için bir sarmalayıcıdır. Ayrıca kategorik değişkenler için ağırlıklı orantıları hesaplamanıza olanak tanır.

```{r sitrep_props}

## anket tasarım nesnesini kullan
survey_design %>% 
  ## ilgilenilen değişkenlerin isimlerini alıntı yapılmadan ilet
  tab_survey(arrived, left, died, education_level,
             deff = TRUE,   # tasarım etkisini hesapla
             pretty = TRUE  # oranı ve %95 CI'yi birleştir
             )

```


### **Gtsummary** paketi

**gtsummary** paketinde henüz güven aralıklarını veya tasarım efektini eklemek için yerleşik fonksiyonlar yok gibi görünüyor. Burada, güven aralıkları eklemek için bir fonksiyonun nasıl tanımlanacağını ve ardından `tbl_svysummary()` fonksiyonunu kullanılarak oluşturulan bir **gtsummary** tablosuna güven aralıklarının nasıl ekleneceğini gösteriyoruz.

```{r gtsummary_table}


confidence_intervals <- function(data, variable, by, ...) {
  
  ## güven aralıklarını çıkarın ve yüzdeleri elde etmek için çarp
  props <- svyciprop(as.formula(paste0( "~" , variable)),
              data, na.rm = TRUE)
  
  ## güven aralıklarını çıkar
  as.numeric(confint(props) * 100) %>% ## sayısal yap ve yüzde için çarp
    round(., digits = 1) %>%           ## bir haneye yuvarla
    c(.) %>%                           ## sayıları matristen çıkar
    paste0(., collapse = "-")          ## tek karakterle birleştir
}

## anket paketi tasarım nesnesini kullan
tbl_svysummary(base_survey_design, 
               include = c(arrived, left, died),   ## dahil etmek istediğiniz değişkenleri tanımla
               statistic = list(everything() ~ c("{n} ({p}%)"))) %>% ## ilgi istatistiklerini tanımla
  add_n() %>%  ## add the weighted total 
  add_stat(fns = everything() ~ confidence_intervals) %>% ## güven aralığını ekle
  ## sütun başlıklarını değiştir
  modify_header(
    list(
      n ~ "**Weighted total (N)**",
      stat_0 ~ "**Weighted Count**",
      add_stat_1 ~ "**95%CI**"
    )
    )

```


<!-- ======================================================= -->
## Ağırlıklı hızlar {  }

Benzer şekilde ağırlıklı hızlar için (ölüm hızları gibi) **survey** veya **srvyr** paketini kullanabilirsiniz. Birkaç değişken üzerinde yineleme yapmak için benzer şekilde (yukarıdakilere benzer) fonksiyonlar yazabilirsiniz. Ayrıca **gtsummary** için yukarıdaki gibi bir fonksiyon oluşturabilirsiniz, ancak şu anda dahili bir fonksiyonelliği bulunmamaktadır.


### **Survey** paketi

```{r survey_ratio}

ratio <- svyratio(~died, 
         denominator = ~obstime, 
         design = base_survey_design)

ci <- confint(ratio)

cbind(
  ratio$ratio * 10000, 
  ci * 10000
)

```


### **Srvyr** paketi

```{r srvyr_ratio}

survey_design %>% 
  ## gözlem süresini hesaba katmak için kullanılan anket hızı
  summarise(
    mortality = survey_ratio(
      as.numeric(died) * 10000, 
      obstime, 
      vartype = "ci")
    )

```


<!-- ======================================================= -->
## Kaynaklar {  }

[UCLA istatistik sayfası](https://stats.idre.ucla.edu/r/seminars/survey-data-analysis-with-r/)  

[Anket verilerini ücretsiz analiz edin](http://asdfree.com/)  

[srvyr paketi](http://gdfe.co/srvyr/)  

[gtsummary paketi](http://www.danieldsjoberg.com/gtsummary/reference/index.html) 

[EPIET anket vaka çalışmaları](https://github.com/EPIET/RapidAssessmentSurveys)
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/survey_analysis.Rmd-->


<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Sağkalım Analizi { }  


```{r out.width = c('75%'), fig.align='center', fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "survival_analysis.png"))
```

<!-- ======================================================= -->
## Genel Bakış {}


*Sağkalım analizi*, belirli bir birey veya birey grubu için, **_başarısızlık_** (bir hastalığın ortaya çıkması, bir hastalıktan iyileşme, ölüm, tedaviye yanıttan sonra nüks...) olarak adlandırılan  bir olay noktasını tanımlamaya odaklanır. Bu, bireylerin gözlemlendiği **_başarısızlık süresi_** (veya kohort/nüfus temelli çalışmalarda **_izleme süresi_**) olarak adlandırılan bir süreden sonra ortaya çıkar. Başarısızlık süresini belirlemek için, daha sonra bir başlangıç zamanı tanımlamak gerekir (bu, dahil etme tarihi, teşhis tarihi olabilir...). 

Sağkalım analizinin nihayi çıktısı, başlangıç noktası ile  olay arasındaki zamandır. Mevcut tıbbi araştırmalarda, örneğin klinik çalışmalarda bir tedavinin etkisini veya çeşitli kanser sağkalım ölçümlerini değerlendirmek için kanser epidemiyolojisinde yaygın olarak kullanılmaktadır.


Genellikle **_sağkalım ihtimali_** ile ifade edilir;ki bu, ilgilenilen olayın t süresi boyunca gerçekleşmemiş olma olasılığıdır.


**_Sansürleme_**: Sansür; izlem sonunda, bazı kişilerin ilgilendikleri olay olmadığında ve bu nedenle gerçek zamanlarının bilinmediği durumlarda meydana gelir. Burada çoğunlukla doğru sansürlemeye odaklanacağız, ancak genel olarak sansürleme ve sağkalım analizi hakkında daha fazla ayrıntı için referansları görebilirsiniz. 


```{r echo=F, eval=F, out.width = "80%", out.height="80%", fig.align = "center"}
 
#Add a figure from the following chunks for the last version of the page
#do not forget to save the output figure in "images"
# knitr::include_graphics(here::here("images", "survanalysis.png"))

```  

<!-- ======================================================= -->
## Hazırlık {  }

### Paketleri yükleyin {.unnumbered}

R'da sağkalım analizlerini çalıştırmak için en yaygın kullanılan paketlerden biri **survival** paketidir. Önce o kurulur ve ardından bu bölümde kullanılacak diğer paketlerin yanı sıra o da yüklenir:

Bu el kitabında, gerekirse paketi kuran *ve* kullanım için yükleyen **pacman**'dan `p_load()` vurgusu yapılmaktadır. R tabanı'ndan `library()` ile kurulu paketler de yüklenebilir. R paketleri hakkında daha fazla bilgi için [R'ın temelleri] sayfasına bakabilirsiniz.  

```{r, echo=F, message=FALSE, warning=FALSE}

# install/load the different packages needed for this page
pacman::p_load(
  survival,      # survival analysis 
  survminer,     # survival analysis
  rio,           # importing data  
  here,          # relative file pathways  
  janitor,       # tabulations
  SemiCompRisks, # dataset examples and advanced tools for working with Semi-Competing Risks data
  tidyverse,     # data manipulation and visualization
  Epi,           # stat analyses in Epi
  survival,      # survival analysis
  survminer      # survival analysis: advanced KM curves
)


```


Bu sayfa, önceki sayfaların çoğunda kullanılan ve uygun bir sağkalım verisine sahip olmak için bazı değişiklikler uyguladığımız satır listesini kullanarak sağkalım analizlerini araştırmaktadır.


### Veri kümesini içe aktar {.unnumbered}

Simüle edilmiş bir Ebola salgınından vakaların veri seti içe aktarılmaktadır. Takip etmek için; <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>"temiz satır listesi" dosyasını indirmek için tıklayın.</a> (.rds dosyası olarak). **rio** paketinden `import()` işleviyle veriler içe aktarılabilir (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe ve dışa aktarma] sayfasına bakılabilir).  

```{r echo=F}
# import linelist
linelist_case_data <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r eval=F}
# import linelist
linelist_case_data <- rio::import("linelist_cleaned.rds")
```

### Veri yönetimi ve dönüştürme {.unnumbered}

Kısacası, sağkalım verileri aşağıdaki üç özelliğe sahip olarak tanımlanabilir:

1) Bağımlı değişken veya sonuç, iyi tanımlanmış bir olayın meydana gelmesine kadar geçen bekleme süresidir.
2) Gözlemler, bazı birimler için verilerin analiz edildiği sırada ilgili olayın meydana gelmediği anlamında sansürlenir.
3) Bekleme süresi üzerindeki etkisini değerlendirmek veya kontrol etmek istediğimiz öngörüler veya açıklayıcı değişkenler vardır.

Böylece, bu yapıya uymak ve sağkalım analizini yürütmek için gereken farklı değişkenler ortaya çıkarılmaktadır.

- Bu analiz için yeni bir veri çerçevesini `linelist_surv` olarak;
- İlgilendiğimiz olayı "ölüm" olarak; (dolayısıyla sağkalım olasılığımız, başlangıç zamanından belirli bir süre sonra sağkalım olasılığı olacaktır),
- Başlangıç zamanı ile sonuç zamanı arasındaki izlem süresini (`futime`) *gün olarak*;
- Sansürlenmiş hastalar iyileşen veya nihai sonucu bilinmeyen, yani "ölüm" olayının gözlemlenmediği hastalar olarak  (`event=0`);
tanımlanmaktadır.

<span style="color: orange;">**_DİKKAT:_** Gerçek bir kohort çalışmasında, bireyler gözlendiğinde, başlangıç zamanı ve izlem sonu hakkındaki bilgiler bilindiği için, başlangıç tarihi veya sonuç tarihi bilinmiyorsa gözlemler kaldırılacaktır. Ayrıca başlangıç tarihinin sonuç tarihinden sonra olduğu durumlar da yanlış kabul edildiğinden kaldırılacaktır.</span>

<span style="color: darkgreen;">**_İPUCU:_** Bir tarihe göre büyük (>) veya küçük (<) olarak filtrelemenin eksik değerlere sahip satırları kaldırabileceği göz önüne alındığında, filtreyi yanlış tarihlere uygulamak eksik tarihlere sahip satırları da kaldıracaktır.</span>

Ardından, içinde yalnızca 3 yaş kategorisi bulunan bir `age_cat_small` sütunu oluşturmak için `case_while()` kullanılmaktadır.

```{r }
#create a new data called linelist_surv from the linelist_case_data

linelist_surv <-  linelist_case_data %>% 
     
  dplyr::filter(
       # remove observations with wrong or missing dates of onset or date of outcome
       date_outcome > date_onset) %>% 
  
  dplyr::mutate(
       # create the event var which is 1 if the patient died and 0 if he was right censored
       event = ifelse(is.na(outcome) | outcome == "Recover", 0, 1), 
    
       # create the var on the follow-up time in days
       futime = as.double(date_outcome - date_onset), 
    
       # create a new age category variable with only 3 strata levels
       age_cat_small = dplyr::case_when( 
            age_years < 5  ~ "0-4",
            age_years >= 5 & age_years < 20 ~ "5-19",
            age_years >= 20   ~ "20+"),
       
       # previous step created age_cat_small var as character.
       # now convert it to factor and specify the levels.
       # Note that the NA values remain NA's and are not put in a level "unknown" for example,
       # since in the next analyses they have to be removed.
       age_cat_small = fct_relevel(age_cat_small, "0-4", "5-19", "20+")
       )
```


<span style="color: darkgreen;">**_İPUCU:_** Oluşturulan yeni sütunlar, `futime` hakkında bir özet ve oluşturulduğu `event` ve `outcome` arasında bir çapraz tablo yapılarak doğrulanabilir. Bu doğrulamanın yanı sıra, sağkalım analizi sonuçlarını yorumlarken medyan takip süresini iletmek iyi bir alışkanlıktır.</span>

```{r }

summary(linelist_surv$futime)

# cross tabulate the new event var and the outcome var from which it was created
# to make sure the code did what it was intended to
linelist_surv %>% 
  tabyl(outcome, event)
```

Doğru atamaları sağlamak için yeni age_cat_small var ve eski age_cat sütunu çapraz tablo haline getirilmektedir.  

```{r}
linelist_surv %>% 
  tabyl(age_cat_small, age_cat)
```

Şimdi, belirli değişkenlere (yeni oluşturulanlar dahil) bakarak `linelist_surv` verilerinin ilk 10 gözlemi gözden geçirilmektedir.


```{r}
linelist_surv %>% 
  select(case_id, age_cat_small, date_onset, date_outcome, outcome, event, futime) %>% 
  head(10)
```

Bu yeni sütunun cinsiyete göre dağılımı hakkında daha fazla ayrıntıya sahip olmak için `age_cat_small` ve `gender` sütunları da çapraz tablo haline getirilebilir. [Açıklayıcı tablolar] sayfasında açıklandığı gibi **janitor**'dan `tabyl()` ve *adorn* fonksiyonları kullanılmaktadır. 

<!-- For this we use the `stat.table()` function of the **Epi** package. -->

```{r}

linelist_surv %>% 
  tabyl(gender, age_cat_small, show_na = F) %>% 
  adorn_totals(where = "both") %>% 
  adorn_percentages() %>% 
  adorn_pct_formatting() %>% 
  adorn_ns(position = "front")

```

<!-- Epi::stat.table(  -->
<!--   #give variables for the cross tabulation -->
<!--   list( -->
<!--     gender,  -->
<!--     age_cat_small -->
<!--     ), -->

<!--   #precise the function you want to call (mean,count..) -->
<!--   list(  -->
<!--     count(), -->
<!--     percent(age_cat_small) -->
<!--     ),  -->

<!--   #add margins -->
<!--   margins=T,  -->

<!--   #data used -->
<!--   data = linelist_surv  -->
<!--   ) -->

<!-- ``` -->


<!-- ======================================================= -->
## Sağkalım analizinin temelleri {}


### Sağkalım analiz materyali oluşturma {.unnumbered}

İzlem süresi ve olay sütunlarından bir hayatta kalma nesnesi oluşturmak için ilk olarak **survival**'den `Surv()` kısmını kullanılır.

Böyle bir adımın sonucu, zaman bilgisini ve ilgilenilen olayın (ölüm) gözlemlenip gözlemlenmediğini özetleştiren *surv* türünde bir nesne üretmektir. Bu nesne nihai olarak sonraki model formüllerinin sağ tarafında kullanılacaktır (bkz. [belgeler](https://cran.r-project.org/web/packages/survival/vignettes/survival.pdf)).  


```{r survobj }
# Use Suv() syntax for right-censored data
survobj <- Surv(time = linelist_surv$futime,
                event = linelist_surv$event)
```

<!-- ```{r} -->
<!-- survobj <- with(linelist_surv, -->

<!--                 survival::Surv(futime, event) -->

<!--                 ) -->
<!-- ``` -->


İncelemek için, burada yalnızca bazı önemli sütunları görüntüleyen `linelist_surv` verilerinin ilk 10 satırı verilmiştir.  

```{r}
linelist_surv %>% 
  select(case_id, date_onset, date_outcome, futime, outcome, event) %>% 
  head(10)
```

Burada `survobj`un ilk 10 unsuru izlenmektedir. Esasen bir gözlemin doğru sansürlenip sansürlenmediğini göstermek için, "+" ile  birlikte izlem süresi vektörü olarak yazdırılır. Rakamların yukarıda ve aşağıda nasıl hizalandığını görülmektedir.  

```{r}
#print the 50 first elements of the vector to see how it presents
head(survobj, 10)
```


### İlk analizleri çalıştırma {.unnumbered}

Gözlemlenen olay zamanlarında atlamalı bir adım fonksiyonu olan genel (marjinal) hayatta kalma eğrisinin **_Kaplan Meier_** (KM) tahminleri için varsayılan hesaplamalara uyan bir *survfit nesnesi* üretmek için `survfit()` işlevini kullanarak analize başlanır. Sonuçta *survfit nesnesi* bir veya daha fazla sağkalım eğrisi içerir ve model formülünde bir yanıt değişkeni olarak *Surv* nesnesi kullanılarak oluşturulur.  

<span style="color: black;">**_NOT:_** Kaplan-Meier tahmini, sağkalım fonksiyonunun parametrik olmayan maksimum olabilirlik tahminidir (MLE). . (daha fazla bilgi için kaynaklara bakın).</span>

Bu *survfit nesnesinin* özeti, *yaşam tablosu*'nu verecektir. Gerçekleşen (artan şekilde) bir olayın takip edilen her bir zaman adımı için (`time`):  

* Olayı geliştirme riski altında olan kişi sayısı (henüz olaya sahip olmayan veya sansürlenmemiş kişiler: `n.risk`),
* Olayı geliştirenler: (`n.event`),
* Yukarıdakilerin devamı olarak: Olayın *gelişmeme* olasılığı (ölmeme veya belirli bir zamandan sonra sağkalım olasılığı) bulunur;
* Son olarak, bu olasılık için standart hata ve güven aralığı türetilir ve görüntülenir. 

KM tahminleri, daha önce Surv nesnesi "survobj" un yanıt değişkeni olduğu formül kullanılarak oturtulur. Genel sağkalım için modeli çalıştırılan kesinlik "~ 1" 'dir.  

```{r fit}
# fit the KM estimates using a formula where the Surv object "survobj" is the response variable.
# "~ 1" signifies that we run the model for the overall survival  
linelistsurv_fit <-  survival::survfit(survobj ~ 1)

#print its summary for more details
summary(linelistsurv_fit)

```


`summary()` kullanılırken `times` seçeneği eklenebilir ve sağkalım bilgisinin görülmek istendiği zamanlar belirtilebilir.

```{r print_spec_times}

#print its summary at specific times
summary(linelistsurv_fit, times = c(5,10,20,30,60))

```


`print()` fonksiyonu da kullanılabilir. `print.rmean = TRUE` argümanı, ortalama sağkalım süresini ve standart hatayı (se) elde etmek için kullanılır.

<span style="color: black;">**_NOT:_** Kısıtlı ortalama sağkalım süresi (RMST), kanser sağkalım analizinde giderek daha fazla kullanılan ve kısıtlı T süresine kadar hastaları gözlemlediğimiz, göz önüne alındığında genellikle hayatta kalma eğrisinin altındaki alan olarak tanımlanan spesifik bir hayatta kalma ölçüsüdür. (Daha fazla ayrıntı için kaynaklar bölümüne bakın).


```{r, mean_survtime}
# print linelistsurv_fit object with mean survival time and its se. 
print(linelistsurv_fit, print.rmean = TRUE)

```


<span style="color: darkgreen;">**_İPUCU:_** *surv nesnesi* doğrudan `survfit()` işlevinde oluşturulabilir ve bir kod satırı kaydedilebilir. Bu daha sonra şöyle görünecektir: `linelistsurv_quick <-  survfit(Surv(futime, event) ~ 1, data=linelist_surv)`.</span>


### Kümülatif risk {.unnumbered}  

`summary()` işlevinin yanı sıra, `survfit()` nesnesinin yapısı hakkında daha fazla ayrıntı veren `str()` işlevi de kullanılabilir. Liste 16 unsurdan meydana gelir.  

Bu unsurlardan önemli bir tanesi de sayısal bir vektör olan `cumhaz` 'dır. Bu, **_kümülatif risk_**  in gösterilmesine izin verecek şekilde belirlenebilir, **_risk_** **_olayın anlık meydana gelme oranı_** dır (kaynaklara bakınız).

```{r fit_struct}

str(linelistsurv_fit)

```

<!-- ======================================================= -->
### Kaplan-Meier eğrilerinin çizilmesi  {.unnumbered}

KM tahminleri yerleştirildikten sonra, "Kaplan-Meier eğrisi" ni çizen temel `plot()` işlevi kullanılarak belirli bir süre boyunca sağkalım olasılığı görselleştirilebilir. Başka bir deyişle, aşağıdaki eğri, tüm hasta grubunda sağkalım deneyiminin geleneksel bir gösterimidir.

Eğrideki min ve max takip süresi hızlı bir şekilde doğrulanabilir.  

Yorumlamanın kolay bir yolu, başlangıçta tüm katılımcıların hala hayatta olduğunu ve sağkalım olasılığının %100 olduğunu söylemektir. Hastalar öldükçe bu olasılık zamanla azalır. 60 günlük izlemden sağ kalanların oranı %40 civarındadır.

```{r }

plot(linelistsurv_fit, 
     xlab = "Days of follow-up",    # x-axis label
     ylab="Survival Probability",   # y-axis label
     main= "Overall survival curve" # figure title
     )

```

KM sağkalım tahminlerinin güven aralığı da varsayılan olarak çizilir ve `plot()` komutuna `conf.int = FALSE` seçeneği eklenerek reddedilebilir.

İlgilenilen olay "ölüm" olduğu için, sağkalım oranlarının tamamlayıcılarını tanımlayan bir eğri çizmek, kümülatif ölüm oranlarının çizilmesini sağlayacaktır. Bu, mevcut bir çizime bilgi ekleyen `lines()` ile yapılabilir.  


```{r}

# original plot
plot(
  linelistsurv_fit,
  xlab = "Days of follow-up",       
  ylab = "Survival Probability",       
  mark.time = TRUE,              # mark events on the curve: a "+" is printed at every event
  conf.int = FALSE,              # do not plot the confidence interval
  main = "Overall survival curve and cumulative mortality"
  )

# draw an additional curve to the previous plot
lines(
  linelistsurv_fit,
  lty = 3,             # use different line type for clarity
  fun = "event",       # draw the cumulative events instead of the survival 
  mark.time = FALSE,
  conf.int = FALSE
  )

# add a legend to the plot
legend(
  "topright",                               # position of legend
  legend = c("Survival", "Cum. Mortality"), # legend text 
  lty = c(1, 3),                            # line types to use in the legend
  cex = .85,                                # parametes that defines size of legend text
  bty = "n"                                 # no box type to be drawn for the legend
  )

```

<!-- ======================================================= -->
## Sağkalım eğrilerinin karşılaştırılması 

Gözlemlenen katılımcılarımızın veya hastalarımızın farklı gruplar içindeki sağkalımını karşılaştırmak için, önce ilgili sağkalım eğrilerine bakmamız ve ardından bağımsız gruplar arasındaki farkı değerlendirmek için testler yapmamız gerekebilir. Bu karşılaştırma cinsiyet, yaş, tedavi, komorbidite bazında gruplarla ilgili olabilir...

### Log rank testi {.unnumbered}

Log rank testi, iki veya daha fazla *bağımsız* grup arasındaki tüm sağkalım deneyimini karşılaştıran popüler bir testtir ve sağkalım eğrilerinin aynı (örtüşen) olup olmadığını gösteren bir test olarak düşünülebilir (gruplar arasında sağkalımda hiçbir farkın olmadığı sıfır hipotezi).  **Hayatta kalma paketi**  nin `survdiff()` işlevi, `rho = 0` (varsayılan) belirttiğimizde log rank testinin çalıştırılmasına izin verir. Log rank istatistiği yaklaşık olarak bir ki-kare test istatistiği şeklinde dağıtıldığından, test sonuçları bir p-değeri ile birlikte bir ki-kare değeri verir.

İlk önce sağkalım eğrileri cinsiyet grubuna göre karşılaştırılır. Bunun için eğriler önce görselleştirilmeye çalışılır (iki hayatta kalma eğrisinin örtüşüp örtüşmediğini kontrol edilir). Biraz farklı bir formülle yeni bir *survfit nesnesi* oluşturulup; ardından *survdiff nesnesi* oluşturulur.

Formülün sağ tarafına ` ~ gender` yerleştirilerek, genel sağkalıma göre değil, cinsiyete göre planlama yapılır.  


```{r comp_surv, warning=FALSE}

# create the new survfit object based on gender
linelistsurv_fit_sex <-  survfit(Surv(futime, event) ~ gender, data = linelist_surv)
```

Şimdi sağkalım eğrileri cinsiyete göre çizilebilir. Renkler ve açıklamalar tanımlanmadan önce cinsiyet sütunundaki katman düzeylerinin *sıra* sına bakılır.  

```{r}
# set colors
col_sex <- c("lightgreen", "darkgreen")

# create plot
plot(
  linelistsurv_fit_sex,
  col = col_sex,
  xlab = "Days of follow-up",
  ylab = "Survival Probability")

# add legend
legend(
  "topright",
  legend = c("Female","Male"),
  col = col_sex,
  lty = 1,
  cex = .9,
  bty = "n")
```

Şimdi `survdiff()` kullanılarak sağkalım eğrileri arasındaki fark testi hesaplanabilir.

```{r}
#compute the test of the difference between the survival curves
survival::survdiff(
  Surv(futime, event) ~ gender, 
  data = linelist_surv
  )

```

Kadınlar ve erkekler için sağkalım eğrilerinin örtüştüğü ve log-rank testinin kadınlar ve erkekler arasında bir sağkalım farkı olduğuna dair kanıt vermediği görülmektedir.

Diğer bazı R paketleri, farklı gruplar için sağkalım eğrilerinin gösterilmesine ve bir defada farkın test edilmesine izin verir. **survminer** paketindeki `ggsurvplot()` işlevi kullanılarak, eğriye her grup için yazdırılmış risk tabloları ve log-rank testinden elde edilen p değeri de eklenebilir. 

<span style="color: orange;">**_DİKKAT:_** **survminer** işlevleri, sağkalım nesnesini * ve* sağkalım nesnesine sığdırmak için kullanılan verilerin yeniden belirtilmesini gerektirir. Spesifik olmayan hata mesajlarından kaçınmak için bu işlemin yapılması ihmal edilmemelidir. </span>

```{r, warning=F, message=F}

survminer::ggsurvplot(
    linelistsurv_fit_sex, 
    data = linelist_surv,          # again specify the data used to fit linelistsurv_fit_sex 
    conf.int = FALSE,              # do not show confidence interval of KM estimates
    surv.scale = "percent",        # present probabilities in the y axis in %
    break.time.by = 10,            # present the time axis with an increment of 10 days
    xlab = "Follow-up days",
    ylab = "Survival Probability",
    pval = T,                      # print p-value of Log-rank test 
    pval.coord = c(40,.91),        # print p-value at these plot coordinates
    risk.table = T,                # print the risk table at bottom 
    legend.title = "Gender",       # legend characteristics
    legend.labs = c("Female","Male"),
    font.legend = 10, 
    palette = "Dark2",             # specify color palette 
    surv.median.line = "hv",       # draw horizontal and vertical lines to the median survivals
    ggtheme = theme_light()        # simplify plot background
)

```


Ayrıca enfeksiyon kaynağına (kontaminasyon kaynağı) göre sağkalım farklılıkları test edilmek istenebilir.  

Bu durumda, Log rank testi, `alfa= 0,005` değerinde sağkalım olasılıkları arasında bir fark olduğuna dair yeterli kanıt sağlar. Cenazelerde enfekte olan hastaların sağkalım olasılıkları, başka yerlerde enfekte olan hastaların sağkalım olasılıklarından daha yüksektir; bu da sağkalım avantajı olduğunu düşündürür.

```{r}

linelistsurv_fit_source <-  survfit(
  Surv(futime, event) ~ source,
  data = linelist_surv
  )

# plot
ggsurvplot( 
  linelistsurv_fit_source,
  data = linelist_surv,
  size = 1, linetype = "strata",   # line types
  conf.int = T,
  surv.scale = "percent",  
  break.time.by = 10, 
  xlab = "Follow-up days",
  ylab= "Survival Probability",
  pval = T,
  pval.coord = c(40,.91),
  risk.table = T,
  legend.title = "Source of \ninfection",
  legend.labs = c("Funeral", "Other"),
  font.legend = 10,
  palette = c("#E7B800","#3E606F"),
  surv.median.line = "hv", 
  ggtheme = theme_light()
)

```

<!-- ======================================================= -->
## Cox regresyon analizi {}

Cox orantılı hazards regresyonu, sağkalım analizi için en popüler regresyon tekniklerinden biridir. Cox modeli, orantılı hazards varsayımı gibi uygun bir kullanım için doğrulanması gereken *önemli varsayımlar* gerektirdiğinden başka modeller de kullanılabilir (kaynaklara bakın). 

Cox orantılı hazards regresyon modelinde, etkinin ölçüsü, katılımcının belirli bir süreye kadar yaşadığı göz önüne alındığında, başarısızlık riski (veya örneğimizde ölüm riski) olan **_hazard rate_** (HR)'dir. Genellikle, *bağımsız* grupları risklerine göre karşılaştırmakla ilgileniriz ve çoklu lojistik regresyon analizi ortamındaki bir olasılık oranına benzer bir tehlike oranı (HR) kullanırız. **survival** paketindeki `cox.ph()` işlevi modele uyması için kullanılır. **survival** paketindeki `cox.zph()` işlevi ise bir Cox regresyon modeli uyumu için orantılı hazards varsayımını test etmek için kullanılabilir. 

<span style="color: black;">**_NOT:_** Bir olasılık 0 ile 1 aralığında olmalıdır. Ancak hazard (tehlike/risk), bir zaman birimi başına beklenen olay sayısını temsil eder. 

* Bir prediktör için tehlike oranı 1'e yakınsa, o prediktör sağkalımı etkilemez,
* HR 1'den küçükse, prediktör koruyucudur (yani, iyileştirilmiş sağkalım ile ilişkilidir),
* ve HR 1'den büyükse, prediktör risk artışı (veya azalmış sağkalım) ile ilişkilidir.</span> 

### Cox modelini uyarlama {.unnumbered}

İlk olarak yaş ve cinsiyetin sağkalım üzerindeki etkilerini değerlendirmek için bir model uyarlanabilir. Sadece modeli yazdırarak elde edilen bilgiler:

  + prediktörler ile sonuç arasındaki ilişkiyi ölçen tahmini regresyon katsayıları `coef`,
   + *hazard oranı* nı üreten üstelleri (yorumlanabilirlik için `exp(coef)`),
   + onların standart hatası `se(coef)`,
   + z-skoru: 0'dan uzakta tahmin edilen katsayının standart hata miktarı,
   + ve p değeri: Tahmini katsayının 0 olma olasılığı.
  
Cox model nesnesine uygulanan `summary()` işlevi, tahmini HR'nin güven aralığı ve farklı test puanları gibi daha fazla bilgi verir.

İlk ortak değişken `gender` in etkisi ilk satırda sunulmaktadır. `genderm` (erkek) yazdırılır, bu da ilk katman seviyesinin ("f"), yani kadın grubunun cinsiyet için referans grubu olduğunu gösterir. Bu nedenle, test parametresinin yorumu, kadınlara kıyasla erkeklerinkiyle aynıdır. p değeri, cinsiyetin beklenen tehlike üzerindeki etkisine veya cinsiyet ile tüm nedenlere bağlı ölüm arasındaki ilişkiye dair yeterli kanıt olmadığını gösterir.

Aynı kanıt eksikliği, yaş grubuyla ilgili olarak da belirtilmiştir.

```{r coxmodel_agesex}

#fitting the cox model
linelistsurv_cox_sexage <-  survival::coxph(
              Surv(futime, event) ~ gender + age_cat_small, 
              data = linelist_surv
              )


#printing the model fitted
linelistsurv_cox_sexage


#summary of the model
summary(linelistsurv_cox_sexage)

```


Modeli çalıştırmak ve sonuçlara bakmak ilginç olsa da, orantılı hazards varsayımlarına uyulup uyulmadığını doğrulamak için göz atmak zamandan tasarruf etmenize yardımcı olabilir..

```{r test_assumption}

test_ph_sexage <- survival::cox.zph(linelistsurv_cox_sexage)
test_ph_sexage

```


<span style="color: black;">**_NOT:_** Cox modeli hesaplanırken, bağların nasıl ele alınacağını belirleyen *yöntem* adlı ikinci bir argüman belirtilebilir. *varsayılan* "efron" dur ve diğer seçenekler "breslow" ve "exact" dır.</span>

Başka bir modelde, enfeksiyonun kaynağı ve başlangıç tarihi ile kabul arasındaki gün sayısı gibi daha fazla risk faktörü eklenir. Bu sefer, ilerlemeden önce orantılı hazards varsayımını doğrularız.

Bu modele sürekli bir prediktör (`days_onset_hosp`) eklendi. Bu durumda, parametre tahminlerini, diğer prediktörleri sabit tutarak, prediktördeki her bir birimlik artış için nispi tehlikenin beklenen logundaki artış olarak yorumlanır. İlk önce orantılı hazards varsayımı doğrulanır.  

```{r coxmodel_fit_ph,  message=FALSE}

#fit the model
linelistsurv_cox <-  coxph(
                        Surv(futime, event) ~ gender + age_years+ source + days_onset_hosp,
                        data = linelist_surv
                        )


#test the proportional hazard model
linelistsurv_ph_test <- cox.zph(linelistsurv_cox)
linelistsurv_ph_test
```

Bu varsayımın grafiksel doğrulaması, **survminer** paketindeki `ggcoxzph()` fonksiyonu ile gerçekleştirilebilir.

```{r}
survminer::ggcoxzph(linelistsurv_ph_test)

```


Model sonuçları, başlangıçtan hastaneye başvurana kadar olan süre ile tüm nedenlere bağlı mortalite arasında negatif bir ilişki olduğunu göstermektedir. Cinsiyet sabit tutulduğunda, bir gün sonra hastaneye başvuran bir kişide beklenen risk, diğerinden 0,9 kat daha düşüktür. Ya da daha açık bir anlatımla, hastaneye başvuruya başlama süresindeki bir birimlik artış, ölüm riskinde %10,7'lik (`coef *100`) bir azalma ile ilişkilidir.

Ayrıca sonuçlar enfeksiyon kaynağı ile tüm nedenlere bağlı ölümler arasında pozitif bir ilişki olduğunu göstermektedir. Yani cenaze dışında bir enfeksiyon kaynağı olan hastalarda ölüm riski (1.21x) artmaktadır.


```{r coxmodel_summary,  message=FALSE}

#print the summary of the model
summary(linelistsurv_cox)

```


Bu ilişki bir tablo ile doğrulanabilir:  


```{r}
linelist_case_data %>% 
  tabyl(days_onset_hosp, outcome) %>% 
  adorn_percentages() %>%  
  adorn_pct_formatting()

```


Bu ilişkinin verilerde neden var olduğunun düşünülmesi ve araştırılması gerekir. Olası bir açıklama, daha sonra kabul edilecek kadar uzun yaşayan hastaların başlangıçta daha az şiddetli hastalığa sahip olmaları olabilir. Belki de daha olası bir başka açıklama, simüle edilmiş sahte bir veri seti kullanıldığı için bu modelin gerçeği yansıtmamasıdır!  


<!-- ======================================================= -->

### Forest grafikleri {.unnumbered}

Daha sonra, **survminer paketi** nin `ggforest()` işleviyle pratik forest grafikleri kullanılarak cox modelinin sonuçları görselleştirilebilir..

```{r forestp}

ggforest(linelistsurv_cox, data = linelist_surv)

```

<!-- ======================================================= -->
## Sağkalım modellerinde zamana bağlı değişkenler {}

Aşağıdaki bölümlerden bazıları, faydalı bir kaynaktan izin alınarak uyarlanmıştır [introduction to survival analysis in R](https://www.emilyzabor.com/tutorials/survival_analysis_in_r_tutorial.html) by [Dr. Emily Zabor](https://www.emilyzabor.com/) 

Son bölümde, ilgilenilen ortak değişkenler ve sağkalım sonuçları arasındaki ilişkileri incelemek için Cox regresyonunu kullanma ele alındı. Ancak bu analizler, başlangıçta, yani olayın takip süresi başlamadan önce ölçülen ortak değişkene dayanır.

Takip süresi başladıktan **sonra** ölçülen bir ortak değişkenle ilgileniyorsanız ne olur? Ya da zamanla değişebilen bir ortak değişkeniniz varsa?

Örneğin, zaman içinde değişebilen hastane laboratuvar değerleri ölçümlerini tekrarladığınız klinik verilerle çalışıyor olabilirsiniz. Bu, bir **Zaman Bağımlı Ortak Değişken** örneğidir. Bunu ele almak için özel bir kuruluma ihtiyacınız var, ancak neyse ki cox modeli çok esnektir ve bu tür veriler **sağkalım** paketindeki araçlarla da modellenebilir. 

### Zaman bağımlı ortak değişken kurulumu {.unnumbered} 

R'daki zaman bağımlı ortak değişkenlerin analizi, özel bir veri setinin kurulmasını gerektirir. İlgileniyorsanız, **sağkalım** paketi yazarının bu konu hakkındaki daha ayrıntılı makalesine bakılabilir [Cox Modelinde Zamana Bağlı Ortak Değişkenleri ve Zamana Bağlı Katsayıları Kullanma](https://cran.r-project.org/web/packages/survival/vignettes/timedep.pdf).

Bunun için, 137 kemik iliği nakli hastasının verilerini içeren `BMT` adlı `SemiCompRisks` paketinden yeni bir veri seti kullanılabilir. Odaklanılacak değişkenler şunlardır:  

* `T1` - ölüme veya son takibe kadar geçen süre (gün olarak)
* `delta1` - ölüm göstergesi; 1-Ölü, 0-Canlı
* `TA` - akut graft-versus-host hastalığına kadar geçen süre (gün olarak)
* `deltaA` - akut graft-versus-host hastalığı göstergesi;
   * 1 - Gelişmiş akut graft-versus-host hastalığı
   * 0 - Hiçbir zaman akut graft-versus-host hastalığı geliştirmedi.

Bu veri seti **sağkalım** paketinden **temel** R komutu `data()` kullanarak yüklenir; bu, zaten yüklü olan bir R paketine dahil olan verileri yüklemek için kullanılabilir. `BMT` veri çerçevesi R ortamında görünecektir.  

```{r}
data(BMT, package = "SemiCompRisks")
```

#### Özgün hasta tanımlayıcısı ekleme {.unnumbered}  

`BMT` verilerinde, istenilen veri seti çeşidini oluşturmak için gerekli olan özgün bir ID sütunu yoktur. Bu nedenle, **tidyverse** paketinden **tibble** `rowid_to_column()` işlevini `my_id` adlı yeni bir ID sütunu oluşturmak için kullanılır (1'den başlayarak sıralı satır kimlikleriyle veri çerçevesinin başına sütun ekler) . Veri çerçevesi `bmt` olarak adlandırılır.  

```{r}
bmt <- rowid_to_column(BMT, "my_id")
```

Veri seti şimdi şöyle görünür:  

```{r message=FALSE, echo=F}
DT::datatable(bmt, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

#### Hasta dizilerini genişletme {.unnumbered}  

Daha sonra, yeniden yapılandırılmış veri setini oluşturmak için `event()` ve `tdc()` yardımcı işlevleriyle `tmerge()` işlevi kullanılır. Amaç; her hasta için, farklı bir `deltaA` değerine sahip oldukları her zaman aralığı için ayrı bir satır oluşturmak üzere veri setini yeniden yapılandırmaktır. Bu durumda, veri toplama döneminde akut graft-versus-host hastalığı geliştirip geliştirmediğine bağlı olarak her hasta en fazla iki sıraya sahip olabilir. Akut graft-versus-host hastalığı gelişimi için yeni göstergeye `agvhd` adı verilir.

- `tmerge()`, her hasta için tanımlanan farklı ortak değişken değerler için birden fazla zaman aralığı içeren uzun bir veri seti oluşturur
- `event()`, yeni oluşturulan zaman aralıklarıyla uyumlu olacak yeni olay göstergesini yaratır
- `tdc()` , yeni oluşturulan zaman aralıklarına uygun olarak zamana bağlı ortak değişken sütunu `agvhd` yi oluşturur

```{r}
td_dat <- 
  tmerge(
    data1 = bmt %>% select(my_id, T1, delta1), 
    data2 = bmt %>% select(my_id, T1, delta1, TA, deltaA), 
    id = my_id, 
    death = event(T1, delta1),
    agvhd = tdc(TA)
    )
```

Bunun ne işe yaradığını görmek için ilk 5 özgün hastaya ait verilere bakıldığında orijinal verilerdeki ilgili değişkenler bu şekilde görünür:

```{r}
bmt %>% 
  select(my_id, T1, delta1, TA, deltaA) %>% 
  filter(my_id %in% seq(1, 5))
```

Aynı hastalar için yeni veri seti şuna benzer:

```{r}
td_dat %>% 
  filter(my_id %in% seq(1, 5))
```

Şimdi bazı hastalarımızın veri setinde yeni değişkenimiz `agvhd` için farklı bir değere sahip oldukları aralıklara karşılık gelen iki satırı var. Örneğin, Hasta 1 artık 0 zamanından 67. zamana kadar sıfır `agvhd` değerine ve 67'den 2081'e kadar 1 değerine sahip iki satıra sahiptir. 

### Zamana bağlı ortak değişkenlerle cox regresyonu {.unnumbered} 

Veriler yeniden şekillendirildiğine ve yeni zamana bağlı `aghvd` değişkeni eklediğine göre, şimdi basit tek değişkenli bir cox regresyon modeli uygulanabilir. Daha önce olduğu gibi aynı `coxph()` işlevi kullanılabilir; `time1 = ` ve `time2 = ` bağımsız değişkenlerini kullanarak her bir aralık için hem başlangıç hem de bitiş zamanını belirtmek için `Surv()` işlevini değiştirmek yeterlidir. 


```{r}
bmt_td_model = coxph(
  Surv(time = tstart, time2 = tstop, event = death) ~ agvhd, 
  data = td_dat
  )

summary(bmt_td_model)
```

Yine, **survminer paketi** 'nden `ggforest()` işlevi kullanılarak cox model sonuçları görselleştirilebilir.:

```{r}

ggforest(bmt_td_model, data = td_dat)

```

Forest grafiğinden, güven aralığından ve p-değerinden görülebildiği üzere, basit modelimiz bağlamında ölüm ile akut graft-versus-host hastalığı arasında güçlü bir ilişki yok gibi görünmektedir. 

<!-- ======================================================= -->
## Kaynaklar {  }

[Sağkalım Analizi Bölüm I: Temel kavramlar ve ilk analizler](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2394262/)

[R'da Sağkalım Analizi](https://www.emilyzabor.com/tutorials/survival_analysis_in_r_tutorial.html)

[Bulaşıcı hastalık araştırmalarında sağkalım analizi: Olayları zaman içinde tanımlama](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2954271/)

[Gelişmiş sağkalım modelleri Princeton ile ilgili bölüm](https://data.princeton.edu/wws509/notes/c7.pdf)

[Cox Modelinde Zamana Bağlı Ortak Değişkenleri ve Zamana Bağlı Katsayıları Kullanma](https://cran.r-project.org/web/packages/survival/vignettes/timedep.pdf)

[R kopya kağıdında sağkalım analizi](https://publicifsv.sund.ku.dk/~ts/survival/survival-cheat.pdf)

[Survminer kopya kağıdı](https://paulvanderlaken.files.wordpress.com/2017/08/survminer_cheatsheet.pdf)

[Ek materyal olarak sağlanan R Kodu ile kanser kayıt verileri için farklı sağkalım ölçüleri hakkında bir sayfa](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6322561/)
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/survival_analysis.Rmd-->

# Coğrafi Bilgi Sistemleri (CBS) Temelleri { }  

```{r, out.width=c('100%', '100%'), echo=F}
knitr::include_graphics(here::here("images", "gis_head_image.png"))
```

<!-- ======================================================= -->
## Genel Bakış { }

Verilerinizin uzamsal yönleri, salgının durumuna ilişkin pek çok içgörü sağlayabilir ve aşağıdaki gibi soruları yanıtlayabilir:

* Mevcut hastalık noktaları nerede?
* Kümelenme noktaları zaman içinde nasıl değişti?
* Sağlık tesislerine ulaşım nasıl? Herhangi bir iyileştirme gerekli mi?

Bu CBS sayfasının mevcut odak noktası, salgın yanıtında uygulamalı epidemiyologların ihtiyaçlarını ele almaktır. **tmap** ve **ggplot2** paketlerini kullanarak temel mekansal veri görselleştirme yöntemlerini keşfedeceğiz. Ayrıca **sf** paketi ile bazı temel uzamsal veri yönetimi ve sorgulama yöntemlerini de inceleyeceğiz. Son olarak, **spdep** paketini kullanarak uzamsal ilişkiler, uzamsal otokorelasyon ve uzamsal regresyon gibi *mekansal istatistik* kavramlarına kısaca değineceğiz.



## Anahtar terimler {}

Aşağıda bazı temel terminolojiyi tanıtıyoruz. CBS ve mekansal analize kapsamlı bir giriş için, Referanslar bölümünde listelenen daha uzun öğreticilerden veya kurslardan birini incelemenizi öneririz.

**Coğrafi Bilgi Sistemi (CBS)** - CBS, mekansal verileri toplamak, yönetmek, analiz etmek ve görselleştirmek için bir çerçeve veya ortamdır.

### CBS yazılımı {.unnumbered}

Bazı popüler CBS yazılımları, harita geliştirme ve mekansal analiz için işaretle ve tıkla etkileşimine izin verir. Bu araçlar, kod öğrenmeye gerek olmaması ve simgeleri ve özellikleri bir haritaya manuel olarak seçme ve yerleştirme kolaylığı gibi avantajlarla birlikte gelir. İşte iki popüler olan:

**ArcGIS** - ESRI şirketi tarafından geliştirilen, çok popüler ancak oldukça pahalı olan ticari bir CBS yazılımı

**QGIS** - ArcGIS'in yapabileceği hemen hemen her şeyi yapabilen ücretsiz bir açık kaynaklı CBS yazılımı. [QGIS'i buradan indirebilirsiniz](https://qgis.org/en/site/forusers/download.html)

R'ı bir CBS olarak kullanmak, "işaretle ve tıkla" yerine bir "komut satırı arayüzüne" sahip olduğundan (istenen sonucu elde etmek için kodlamanız gerekir) ilk başta daha korkutucu görünebilir. Ancak, tekrar tekrar haritalar üretmeniz veya tekrarlanabilir bir analiz oluşturmanız gerekiyorsa bu büyük bir avantajdır.

### Mekansal veri {.unnumbered}

CBS'de kullanılan iki temel konumsal veri biçimi vektör ve hücresel(raster) veridir:

**Vektör Verileri** - CBS'de kullanılan en yaygın konumsal veri biçimi olan vektör verileri, köşelerin ve yolların geometrik özelliklerinden oluşur. Vektör uzamsal verileri ayrıca yaygın olarak kullanılan üç türe ayrılabilir:

  * *Noktalar* - Bir nokta, bir koordinat sistemindeki belirli bir konumu temsil eden bir koordinat çiftinden (x,y) oluşur. Noktalar, uzamsal verilerin en temel biçimidir ve bir durumu (yani hasta evi) veya bir konumu (yani hastaneyi) bir harita üzerinde belirtmek için kullanılabilir.

  * *Çizgiler* - Çizgi, birbirine bağlı iki noktadan oluşur. Çizgilerin bir uzunluğu vardır ve yollar veya nehirler gibi şeyleri belirtmek için kullanılabilir.

  * *Çokgenler* - Çokgen, noktalarla birbirine bağlanan en az üç doğru parçasından oluşur. Çokgen özellikleri bir uzunluğa (yani alanın çevresi) ve ayrıca bir alan ölçümüne sahiptir. Çokgenler bir alanı (yani bir köyü) veya bir yapıyı (yani bir hastanenin gerçek alanını) belirtmek için kullanılabilir.

**Hücresel Veri** - Uzamsal veriler için alternatif bir format olan hücresel veriler, her hücrenin yükseklik, sıcaklık, eğim, orman örtüsü vb. gibi bilgileri içeren bir hücre matrisidir (örneğin pikseller). Bunlar genellikle hava fotoğrafları, uydu görüntüler, vb. Rasterler (yani hücresel haritalar), vektör verilerinin altında “temel haritalar” olarak da kullanılabilir.

### Uzamsal verileri görselleştirme {.unnumbered}

Bir harita üzerinde uzamsal verileri görsel olarak temsil etmek için, CBS yazılımı, farklı özelliklerin birbiriyle ilişkili olarak nerede olması gerektiği hakkında yeterli bilgi sağlamanızı gerektirir. Çoğu kullanım durumu için geçerli olan vektör verilerini kullanıyorsanız, bu bilgiler genellikle bir şekil dosyasında depolanır:

**Shapefiles** - Shapefile, çizgilerden, noktalardan veya çokgenlerden oluşan "vektör" uzamsal verileri depolamak için yaygın bir veri biçimidir. Tek bir şekil dosyası aslında en az üç dosyadan oluşan bir koleksiyondur - .shp, .shx ve .dbf. Şekil dosyasının okunabilmesi için tüm bu alt bileşen dosyalarının belirli bir dizinde (klasörde) bulunması gerekir. Bu ilişkili dosyalar, e-posta yoluyla gönderilmek veya bir web sitesinden indirilmek üzere bir ZIP klasörüne sıkıştırılabilir.

Şekil dosyası, özelliklerin kendileri ve bunların Dünya yüzeyinde nereye yerleştirileceği hakkında bilgi içerecektir. Bu önemlidir, çünkü Dünya bir küre iken, haritalar tipik olarak iki boyutludur; uzamsal verilerin nasıl "düzleştirileceğine" ilişkin seçimler, ortaya çıkan haritanın görünümü ve yorumlanması üzerinde büyük bir etkiye sahip olabilir.

**Koordinat Referans Sistemleri (CRS)** - CRS, Dünya yüzeyindeki coğrafi özellikleri konumlandırmak için kullanılan koordinat tabanlı bir sistemdir. Birkaç temel bileşeni vardır:

  * *Koordinat Sistemi* - Birçok farklı koordinat sistemi vardır, bu nedenle koordinatlarınızın hangi sistemden olduğunu bildiğinizden emin olun. Enlem/boylam dereceleri yaygındır, ancak [UTM](https://www.maptools.com/tutorials/utm/quick_guide) koordinatlarını da görebilirsiniz.
  
 * *Birimler* - Koordinat sisteminiz için birimlerin ne olduğunu öğrenin (ör. ondalık dereceler, metreler)

  * *Datum* - Dünya'nın belirli bir modellenmiş versiyonu. Bunlar yıllar içinde revize edilmiştir, bu nedenle harita katmanlarınızın aynı veriyi kullandığından emin olun. Özellikle herhangi bir konum verisi elde edilirken yatay ve düşey konumunu tanımlamak için başlangıç alınan bir referans yüzeyi gereklidir. Yer'in şeklini ve boyutunu tanımlayan bu yüzeye Datum adı verilmektedir.

  * *Projeksiyon* - Gerçekten yuvarlak olan dünyayı düz bir yüzeye (harita) yansıtmak için kullanılan matematiksel denklem.

Aşağıda gösterilen haritalama araçlarını kullanmadan uzamsal verileri özetleyebileceğinizi unutmayın. Bazen coğrafyaya göre (ör. ilçe, ülke vb.) basit bir tablo yeterlidir!



## CBS'yi kullanmaya başlama

Bir harita yapmak için sahip olmanız ve düşünmeniz gereken birkaç önemli öğe var. Bunlar şunları içerir:

  * Bir **veri kümesi** -- bu, uzamsal bir veri biçiminde olabilir (yukarıda belirtildiği gibi şekil dosyaları gibi) veya uzamsal bir biçimde olmayabilir (örneğin sadece bir csv olarak).
  
  * Veri kümeniz uzamsal biçimde değilse ayrıca bir **referans veri kümesine** ihtiyacınız olacaktır. Referans verileri, verilerin uzamsal temsilinden ve belirli özelliklerin konum ve adres bilgilerini içeren materyali içeren ilgili **niteliklerden** oluşur.
  
    + Önceden tanımlanmış coğrafi sınırlarla (örneğin, idari bölgeler) çalışıyorsanız, referans şekil dosyaları genellikle bir devlet kurumundan veya veri paylaşım kuruluşundan ücretsiz olarak indirilebilir. Şüpheye düştüğünüzde,  Google "[bölgeler] şekil dosyası" başlamak için iyi bir yerdir.
    
    + Adres bilginiz varsa ancak enlem ve boylam yoksa, kayıtlarınız için uzamsal referans verilerini almak için bir **coğrafi kodlama motoru** kullanmanız gerekebilir.
    
  * Veri kümelerinizdeki bilgileri hedef kitlenize **nasıl sunmak istediğiniz** hakkında fikriniz olmalı. Birçok farklı harita türü vardır ve ihtiyaçlarınıza en uygun harita türünü düşünmek önemlidir.

### Verilerinizi görselleştirmek için harita türleri {.unnumbered}

**Choropleth haritası** - coğrafi bölgeleri bir öznitelik değerine göre temsil etmek için renklerin, gölgelerin veya desenlerin kullanıldığı bir tür tematik haritadır. Örneğin, daha büyük bir değer, daha küçük bir değerden daha koyu bir renkle gösterilebilir. Bu harita türü, bir değişkeni ve onun tanımlanmış bölgeler veya jeopolitik alanlar arasında nasıl değiştiğini görselleştirirken özellikle kullanışlıdır.

```{r, out.width = '50%', fig.align = "center", fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "gis_choropleth.png"))
```

**Vaka yoğunluğu ısı haritası** - renklerin bir değerin yoğunluğunu temsil etmek için kullanıldığı, ancak verileri gruplamak için tanımlanmış bölgeleri veya jeopolitik sınırları kullanmadığı bir tür tematik haritadır. Bu harita türü tipik olarak "sıcak noktaları" veya yüksek yoğunluklu veya nokta yoğunluğuna sahip alanları göstermek için kullanılır.

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "gis_heatmap.png"))
```

**Nokta yoğunluğu haritası** - verilerinizdeki öznitelik değerlerini temsil etmek için noktaları kullanan tematik bir harita türüdür. Bu tür harita en iyi, verilerinizin dağılımını görselleştirmek ve kümeleri görsel olarak taramak için kullanılır.

```{r, fig.align = "center", echo=F}
# nokta yoğunluğu fotoğrafı buraya
```

**Oransal semboller haritası (dereceli semboller haritası)** - bir choropleth haritasına benzer bir tematik harita, ancak bir özelliğin değerini belirtmek için renk kullanmak yerine, değere göre bir sembol (genellikle bir daire) kullanır. Örneğin, daha büyük bir değer, daha küçük bir değerden daha büyük bir sembolle gösterilebilir. Bu harita türü en iyi, coğrafi bölgelerdeki verilerinizin boyutunu veya miktarını görselleştirmek istediğinizde kullanılır.

```{r, fig.align = "center", echo=F}
# orantısal semboller fotoğrafı buraya
```

Karmaşık coğrafi kalıpları göstermek için birkaç farklı görselleştirme türünü de birleştirebilirsiniz. Örneğin aşağıdaki haritadaki vakalar (noktalar) en yakın sağlık kuruluşuna göre renklendirilmiştir (bkz. lejand). Büyük kırmızı daireler, belirli bir yarıçaptaki *sağlık tesisi hizmet alanlarını* ve herhangi bir hizmet alanı dışında kalan parlak kırmızı vaka noktalarını gösterir:

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "gis_hf_catchment.png"))
```

Not: Bu CBS sayfasının birincil odak noktası, saha salgın yanıtı bağlamına dayanmaktadır. Bu nedenle sayfanın içeriği, temel uzamsal veri manipülasyonlarını, görselleştirmeleri ve analizleri kapsayacaktır.


<!-- ======================================================= -->
## Hazırlık {  }

### Paketleri yükleyin {.unnumbered}

Bu kod parçası, analizler için gereken paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran *ve* kullanım için yükleyen **pacman**'dan `p_load()` vurgusunu yapıyoruz. R tabanından `library()` ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakabilirsiniz.

```{r}
pacman::p_load(
  rio,           # verileri içe aktarmak için
  here,          # dosyaları bulmak için
  tidyverse,     # verileri temizlemek, işlemek ve çizmek için (ggplot2 paketini içerir)
  sf,            # Basit Özellik formatı kullanarak uzamsal verileri yönetmek için
  tmap,          # basit haritalar üretmek için hem etkileşimli hem de statik haritalar için çalışır
  janitor,       # sütun adlarını temizlemek için
  OpenStreetMap, # ggplot haritasına OSM altlık haritası eklemek için
  spdep          # mekansal istatistik
  ) 
                  
```

[CRAN "Uzamsal Görev Görünümü"nde](https://cran.r-project.org/web/views/Spatial.html) uzamsal verilerle ilgilenen tüm R paketlerinin bir özetini görebilirsiniz.


### Örnek vaka verileri {.unnumbered}

Gösteri amacıyla, simüle edilmiş Ebola salgını "satır listesi" veri çerçevesinden rastgele 1000 vakalık bir örneklemle çalışacağız (hesaplamalı olarak, daha az vakayla çalışmak bu el kitabında daha kolaydır). Takip etmek isterseniz, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>"clean" dosyasını indirmek için tıklayın.</a> (.rds dosyası olarak).

Vakaların rastgele bir örneğini aldığımız için, kodları kendi başınıza çalıştırdığınızda sonuçlarınız burada gösterilenden biraz farklı görünebilir.

**rio** paketinden `import()` fonksiyonuyla verileri içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe aktarma ve dışa aktarma] sayfasına bakın).

```{r, echo=F}
# temizlenmiş vaka satır listesini içe aktarmak
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))  
```

```{r, eval=F}
# temizlenmiş vaka satır listesini içe aktarmak
linelist <- import("linelist_cleaned.rds")  
```

Daha sonra R **tabanı**ndan `sample()` kullanarak 1000 satırlık rastgele bir örnek seçiyoruz.

```{r}
# satır listesindeki satır sayısından 1000 rastgele satır numarası üretmek
sample_rows <- sample(nrow(linelist), 1000)

# yalnızca örnek satırları ve tüm sütunları tutmak için alt küme satır listesi üretmek
linelist <- linelist[sample_rows,]
```

Şimdi sınıf veri çerçevesi olan bu 'linelist'i "sf" (uzaysal özellikler) sınıfının bir nesnesine dönüştürmek istiyoruz. Satır listesinin, her vakanın ikametgahının enlem ve boylamını temsil eden iki sütun "boy" ve "en" olduğu göz önüne alındığında, bu kolay olacaktır.

**sf** (uzaysal özellikler) paketini ve onun 'st_as_sf()' fonksiyonunu 'linelist_sf' dediğimiz yeni nesneyi yaratmak için kullanırız. Bu yeni nesne, esasen satır listesiyle aynı görünüyor, ancak "boy" ve "enlem" sütunları koordinat sütunları olarak belirlenmiş ve noktalar görüntülendiğinde bir koordinat referans sistemi (CRS) atanmıştır. 4326, koordinatlarımızı, GPS koordinatları için standart olan [World Geodetic System 1984 (WGS84)](https://gisgeography.com/wgs84-world-geodetic-system/) temelinde tanımlar.

```{r}
# sf nesnesi oluşturmk
linelist_sf <- linelist %>%
     sf::st_as_sf(coords = c("lon", "lat"), crs = 4326)
```

Orijinal "satır listesi" veri çerçevesi bu şekilde görünür. Bu gösterimde, yalnızca "date_onset" ve "geometry" (yukarıdaki boylam ve enlem alanlarından oluşturulan ve veri çerçevesindeki son sütun olan) sütununu kullanacağız.

```{r}
DT::datatable(head(linelist_sf, 10), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Yönetici sınır şekil dosyaları {.unnumbered}

**Sierra Leone: Yönetici sınır şekil dosyaları**

Sierra Leone için tüm idari sınırları önceden İnsani Veri Değişimi'nden (HDX) [web sitesi burada](https://data.humdata.org/dataset/sierra-leone-all-ad-min-level-boundaries) indirdik. ). Alternatif olarak, bu el kitabı için bunları ve diğer tüm örnek verileri [El kitabını ve verileri indir] sayfasında açıklandığı gibi R paketimiz aracılığıyla indirebilirsiniz.

Şimdi Admin Level 3 şekil dosyasını R'a kaydetmek için aşağıdakileri yapacağız:

1) Şekil dosyasını içe aktarın
2) Sütun adlarını temizleyin
3) Yalnızca ilgi alanlarını korumak için satırları filtreleyin

Bir şekil dosyasını içe aktarmak için **sf**'den `read_sf()` fonksiyonunu kullanırız. Dosya yolu `here()` ile sağlanır. - bizim durumumuzda dosya, "data", "gis" ve "shp" alt klasörlerinde "sle_adm3.shp" dosya adıyla R projemizin içindedir (daha fazla bilgi için [İçe aktarma ve dışa aktarma] ve [R projeleri] sayfalarına bakabilirsiniz). Kendi dosya yolunuzu sağlamanız gerekecek.

```{r, echo=F}
sle_adm3_raw <- sf::read_sf(here("data", "gis", "shp", "sle_adm3.shp"))
```


Daha sonra, şekil dosyasının sütun adlarını standartlaştırmak için **janitor** paketinden `clean_names()` kullanıyoruz. Ayrıca sadece "Western Area Urban" veya "Western Area Rural" admin2name ile satırları tutmak için `filter()` kullanırız.

```{r}
# ADM3 seviyesi temizlik 
sle_adm3 <- sle_adm3_raw %>%
  janitor::clean_names() %>% # sütun isimlerini standardize etmek
  filter(admin2name %in% c("Western Area Urban", "Western Area Rural")) # belirli alanları tutmak için filtrelemek
```

Aşağıda, içe aktarma ve temizleme işleminden sonra şekil dosyasının nasıl göründüğünü görebilirsiniz. *sağa doğru kaydırın* yönetici düzeyi 0 (ülke), yönetici düzeyi 1, yönetici düzeyi 2 ve son olarak yönetici düzeyi 3 olan sütunların nasıl olduğunu görmek için her düzeyin bir karakter adı ve benzersiz bir "pcode" tanımlayıcısı vardır. Pcode, artan her yönetici düzeyiyle birlikte genişler; SL (Sierra Leone) -> SL04 (Batı) -> SL0410 (Batı Bölgesi Kırsal) -> SL040101 (Koya Kırsal).

```{r message=FALSE, echo=F}
#şekil dosyasını tablo olarak göstermek
DT::datatable(head(sle_adm3, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```



### Nüfus verileri {.unnumbered}

**Sierra Leone: ADM3'e göre nüfus**

Bu veriler tekrar HDX'ten (bağlantı [buradan](https://data.humdata.org/dataset/sierra-leone-population)) veya [bu sayfada] açıklandığı gibi **epirhandbook** R paketimizden indirilebilir. [El kitabını ve verileri indirin]. .csv dosyasını yüklemek için `import()` kullanıyoruz. Ayrıca, sütun adı sözdizimini standartlaştırmak için içe aktarılan dosyayı `clean_names()` öğesine iletiyoruz.

```{r}
# ADM3'e göre nüfus
sle_adm3_pop <- import(here("data", "gis", "population", "sle_admpop_adm3_2020.csv")) %>%
  clean_names()
```

Popülasyon dosyası böyle görünüyor. Her yetki alanında "erkek" nüfus, "kadın" nüfus, "toplam" nüfus ve yaş grubuna göre nüfus dökümü sütunlarının nasıl olduğunu görmek için sağa kaydırın.

```{r message=FALSE, echo=F}
# nüfusu tablo olarak göstermek
DT::datatable(head(sle_adm3_pop, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


### Sağlık Tesisleri {.unnumbered}

**Sierra Leone: OpenStreetMap'ten alınan sağlık tesisi verileri**

Yine sağlık tesislerinin konumlarını HDX [buradan](https://data.humdata.org/dataset/hotosm_sierra_leone_health_facilities) veya [el kitabını ve verileri indir] sayfasındaki talimatlar aracılığıyla indirdik.

Tesis noktaları şekil dosyasını `read_sf()` ile içe aktarıyoruz, sütun adlarını tekrar temizliyoruz ve ardından yalnızca "hastane", "klinik" veya "doktorlar" olarak etiketlenmiş noktaları tutmak için filtreliyoruz.


```{r}
# OSM sağlık tesisi şekil dosyası
sle_hf <- sf::read_sf(here("data", "gis", "shp", "sle_hf.shp")) %>% 
  clean_names() %>%
  filter(amenity %in% c("hospital", "clinic", "doctors"))
```

İşte ortaya çıkan veri çerçevesi - tesis adını ve "geometri" koordinatlarını görmek için *sağa kaydırın*.

```{r message=FALSE, echo=F}
# nüfusu tablo olarak göstermek
DT::datatable(head(sle_hf, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```





<!-- ======================================================= -->
## Koordinatları grafikleştirme{ }

Bu durumda X-Y koordinatlarını (boylam/enlem, noktalar) çizmenin en kolay yolu, bunları doğrudan hazırlık bölümünde oluşturduğumuz `linelist_sf` nesnesinden nokta olarak çizmektir.

**tmap** paketi, hem statik ("çizim" modu) hem de etkileşimli ("görünüm" modu) için yalnızca birkaç satır kodla basit eşleme yetenekleri sunar. **tmap** sözdizimi **ggplot2**'ninkine benzerdir, öyle ki komutlar `+' ile birbirine eklenir. Bu [gösterimde](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html) daha fazla ayrıntı okuyabilirsiniz.


1) **tmap** modunu ayarlayın. Bu durumda statik çıktılar üreten "plot" modunu kullanacağız.

```{r, warning = F, message=F}
tmap_mode("plot") # "görünüm" veya "grafik"i seçin
```

Aşağıda, noktalar tek başına çizilir.`tm_shape()``,`linelist_sf` nesneleri ile sağlanır. Daha sonra boyut ve rengi belirterek `tm_dots()` aracılığıyla noktalar ekliyoruz. "linelist_sf" bir sf nesnesi olduğundan, enlem/boylam koordinatlarını ve koordinat referans sistemini (CRS) içeren iki sütunu zaten belirledik: 


```{r, warning = F, message=F}
# noktalar sadece vakalar
tm_shape(linelist_sf) + tm_dots(size=0.08, col='blue')
```

Yalnız, puanlar bize fazla bir şey söylemez. Dolayısıyla idari sınırları da haritalandırmalıyız:

Yine `tm_shape()` kullanıyoruz
(bkz. [dokümantasyon] https://www.rdocumentation.org/packages/tmap/versions/3.3/topics/tm_shape)) ancak vaka noktaları şekil dosyası sağlamak yerine, idari sınır şekil dosyası (çokgenler) sağlıyoruz.

`bbox = ` değişkeniyle (bbox "sınırlayıcı kutu" anlamına gelir) koordinat sınırlarını belirleyebiliriz. Önce harita gösterimini `bbox` olmadan ve sonra onunla birlikte gösteriyoruz.  

```{r, out.width = c('50%', '50%'), fig.show='hold', warning=F, message=F}
# Çokgenler sadece idari sınırlar
tm_shape(sle_adm3) +               # yönetici sınırları şekil dosyası
  tm_polygons(col = "#F7F7F7")+    # çokgenleri açık gri olarak göster
  tm_borders(col = "#000000",      # renk ve çizgi ağırlığı ile sınırları göster
             lwd = 2) +
  tm_text("admin3name")            # her çokgen için görüntülenecek sütun metni


# Yukarıdakiyle aynı, ancak sınırlayıcı kutudan yakınlaştırma ile
tm_shape(sle_adm3,
         bbox = c(-13.3, 8.43,    # corner
                  -13.2, 8.5)) +  # corner
  tm_polygons(col = "#F7F7F7") +
  tm_borders(col = "#000000", lwd = 2) +
  tm_text("admin3name")

```


Ve şimdi hem noktalar hem de çokgenler birlikte:

```{r, warning=F, message=FALSE}
# Hepsi birlikte
tm_shape(sle_adm3, bbox = c(-13.3, 8.43, -13.2, 8.5)) +     
  tm_polygons(col = "#F7F7F7") +
  tm_borders(col = "#000000", lwd = 2) +
  tm_text("admin3name")+
tm_shape(linelist_sf) +
  tm_dots(size=0.08, col='blue', alpha = 0.5) +
  tm_layout(title = "Distribution of Ebola cases")   # haritaya isim vermek

```


R'daki eşleme seçeneklerinin iyi bir karşılaştırmasını okumak için bu [blog gönderisine](https://rstudio-pubs-static.s3.amazonaws.com/324400_69a673183ba449e9af4011b1eeb456b9.html) bakabilirsiniz.




<!-- ============================================ ========= -->
## Mekansal birleşimler {}

Verileri bir veri kümesinden diğerine *birleştirmeye* aşina olabilirsiniz. Bu el kitabının [Birleştirme verileri] sayfasında çeşitli yöntemler tartışılmaktadır. Bir uzamsal birleşim benzer bir amaca hizmet eder, ancak uzamsal ilişkilerden yararlanır. Gözlemleri doğru bir şekilde eşleştirmek için sütunlardaki ortak değerlere güvenmek yerine, bir özelliğin bir diğerinin *içinde* olması veya bir diğerine *en yakın komşu* olması veya belirli bir yarıçapın *tampon* içinde olması gibi uzamsal ilişkilerini kullanabilirsiniz. 


**sf** paketi, uzamsal birleşimler için çeşitli yöntemler sunar. Bu [başvuruda](https://r-spatial.github.io/sf/reference/geos_binary_pred.html) st_join yöntemi ve uzamsal birleştirme türleri hakkında daha fazla belgeye bakabilirsiniz.


### Çokgendeki noktalar {.unnumbered}
**Mekansal olarak vakalara idari birimler atama**

İşte ilginç bir muamma: vakaların satır listesi, vakaların idari birimleri hakkında herhangi bir bilgi içermiyor. İlk veri toplama aşamasında bu tür bilgileri toplamak ideal olsa da, uzamsal ilişkilerine dayalı olarak bireysel vakalara idari birimler de atayabiliriz (yani nokta bir çokgenle kesişir).

Aşağıda, durum konumlarımızı (noktaları) ADM3 sınırları (poligonlar) ile uzamsal olarak keseceğiz:

1) Satır listesi(puan) ile başlayın
2) Sınırlara uzamsal birleştirme, birleştirme türünü "st_intersects" olarak ayarlayın
3) Yeni yönetim sınırı sütunlarından yalnızca belirli bir kısmını tutmak için `select()` kullanın

```{r, warning=F, message=F}
linelist_adm <- linelist_sf %>%
  
  # idari sınır dosyasını uzamsal kesişime dayalı olarak satır listesine ekleyin
  sf::st_join(sle_adm3, join = st_intersects)
```

'sle_adms'deki tüm sütunlar satır listesine eklendi! Artık her vaka, içinde bulunduğu idari seviyeleri detaylandıran sütunlara sahiptir. Bu örnekte, yeni sütunlardan yalnızca ikisini (yönetici düzeyi 3) tutmak istiyoruz, bu nedenle eski sütun adlarını ve yalnızca iki ek ilgiyi "select()" yapıyoruz: 

```{r, warning=F, message=F}
linelist_adm <- linelist_sf %>%
  
  # idari sınır dosyasını uzamsal kesişime dayalı olarak satır listesine ekleyin
  sf::st_join(sle_adm3, join = st_intersects) %>% 
  
  # Eski sütun adlarını ve ilgilendiğiniz iki yeni yönetici adlarını saklayın
  select(names(linelist_sf), admin3name, admin3pcod)
```

Aşağıda, yalnızca görüntüleme amacıyla, noktanın çokgen şekilleriyle uzamsal olarak kesiştiği yere bağlı olarak ilk on vakayı ve bunların admin seviyesi 3 (ADM3) yargı yetkilerini görebilirsiniz. 

```{r, warning=F, message=F}
# Şimdi her bir vakaya eklenmiş ADM3 adlarını göreceksiniz.
linelist_adm %>% select(case_id, admin3name, admin3pcod)
```

Şimdi durumlarımızı idari birime göre tanımlayabiliriz - uzaysal birleşmeden önce yapamadığımız bir şey!

```{r, warning=F, message=F}
# İdari birime göre vaka sayılarını içeren yeni veri çerçevesi yapın
case_adm3 <- linelist_adm %>%          # yeni yönetici sütunlarına sahip satır listesiyle başlayın
  as_tibble() %>%                      # daha iyi görüntü için tibble'a dönüştürün
  group_by(admin3pcod, admin3name) %>% # admin birimine göre gruplandır, hem ada hem de pkoda göre
  summarise(cases = n()) %>%           # satırları özetle ve say
  arrange(desc(cases))                     # azalan sırada düzenle

case_adm3
```

Ayrıca idari birime göre vaka sayımlarının bir çubuk grafiğini de oluşturabiliriz.

Bu örnekte, ggplot()'a 'linelist_adm' ile başlıyoruz, böylece çubukları frekansa göre sıralayan 'fct_infreq()' gibi faktör fonksiyonlarını uygulayabiliriz (ipuçları için [Faktörler] sayfasına bakınız).

```{r, warning=F, message=F}
ggplot(
    data = linelist_adm,                       # yönetici birimi bilgilerini içeren satır listesiyle başlayın
    mapping = aes(
      x = fct_rev(fct_infreq(admin3name))))+ # x ekseni, frekansa göre sıralanmış (tersine çevrilmiş) yönetici birimleridir
   geom_bar()+                      # çubuk oluştur, yükseklik satır sayısıdır
   coord_flip()+ # adm birimlerinin daha kolay okunması için X ve Y eksenlerini çevirin
   theme_classic()+ # arka planı basitleştirir
   labs( # başlık ve etiket
    x = "Admin level 3",
    y = "Number of cases",
    title = "Number of cases, by adminstative unit",
    caption = "As determined by a spatial join, from 1000 randomly sampled cases from linelist"
  )
```


<!-- ======================================================= -->
### En yakın komşu {.unnumbered}

**En yakın sağlık kuruluşunu / toplanma alanını bulma**

Hastalık sıcak noktaları ile ilgili olarak sağlık tesislerinin nerede olduğunu bilmek faydalı olabilir.

Bireysel vakalara en yakın sağlık tesisini görselleştirmek için `st_join()` fonksiyonundan (**sf** paketi) *st_nearest_feature* birleştirme yöntemini kullanabiliriz.

1) Satır listesinin şekil dosyası `linelist_sf` ile başlıyoruz
2) Sağlık tesislerinin ve kliniklerin konumları olan `sle_hf` ile mekansal olarak birleştiriyoruz (puan)

```{r, warning=F, message=F}
# Her vakaya en yakın sağlık kuruluşu
linelist_sf_hf <- linelist_sf %>%                  # satır listesini şekil dosyası ile başla
  st_join(sle_hf, join = st_nearest_feature) %>%   # vaka verilerine en yakın klinikten alınan veriler
  select(case_id, osm_id, name, amenity) %>%       # sağlık tesisinin adı, türü ve geometrisi dahil olmak üzere ilgili sütunları tutmak
  rename("nearest_clinic" = "name")                # netlik için yeniden adlandırın
```

Aşağıda (ilk 50 satır) her vakanın artık en yakın klinik/hastaneye ait verileri olduğunu görebiliriz.

```{r message=FALSE, echo=F}
DT::datatable(head(linelist_sf_hf, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


Vakaların yaklaşık %30'u için en yakın sağlık kuruluşunun "Den Clinic" olduğunu görebiliyoruz.

```{r}
# Sağlık kuruluşuna göre vaka sayıları
hf_catchment <- linelist_sf_hf %>%   # en yakın klinik verilerini içeren satır listesiyle başlayın
  as.data.frame() %>%                # şekil dosyasından veri çerçevesine dönüştür
  count(nearest_clinic,              # satırları "ad" ile sayın (kliniğin)
        name = "case_n") %>%         # yeni sayım sütununu "case_n" olarak ata
  arrange(desc(case_n))              # azalan sırada düzenlemek

hf_catchment                         # konsola yazdırmak
```

Sonuçları görselleştirmek için **tmap** kullanabiliriz - bu sefer daha kolay görüntüleme için etkileşimli mod

```{r, warning=F, message=F}
tmap_mode("view")   # tmap modunu etkileşimli olarak ayarla

# vakaları ve klinik noktaları çizin 
tm_shape(linelist_sf_hf) +            # vaka grafikleri
  tm_dots(size=0.08,                  # en yakın klinik tarafından renklendirilen vakalar
          col='nearest_clinic') +    
tm_shape(sle_hf) +                    # klinik tesisleri büyük siyah noktalarla çizin
  tm_dots(size=0.3, col='black', alpha = 0.4) +      
  tm_text("name") +                   # tesis adı ile üzerine bindirme
tm_view(set.view = c(-13.2284, 8.4699, 13), # yakınlaştırmayı ayarla (merkez kodları, yakınlaştırma)
        set.zoom.limits = c(13,14))+
tm_layout(title = "Cases, colored by nearest clinic")
```


### Tamponlar {.unnumbered}

Ayrıca en yakın sağlık kuruluşuna 2,5 km (~30 dakika) yürüme mesafesinde kaç vaka bulunduğunu da keşfedebiliriz.

*Not: Daha doğru mesafe hesaplamaları için, sf nesnenizi UTM (düzlemsel bir yüzeye yansıtılan Dünya) gibi ilgili yerel harita projeksiyon sistemine yeniden yansıtmak daha iyidir. Bu örnekte, basit olması için Dünya Jeodezi Sistemi (WGS84) Coğrafi koordinat sistemine bağlı kalacağız (Dünya küresel / yuvarlak bir yüzeyde temsil edilir, bu nedenle birimler ondalık derece cinsindendir). Genel bir dönüşüm kullanacağız: 1 ondalık derece = ~111km.*

Bu [esri makalesinde](https://www.esri.com/arcgis-blog/products/arcgis-pro/mapping/gcs_vs_pcs/) harita projeksiyonları ve koordinat sistemleri hakkında daha fazla bilgi bulabilirsiniz. Bu [blog](http://www.geo.hunter.cuny.edu/~jochen/gtech201/lectures/lec6concepts/map%20coordinate%20systems/how%20to%20choose%20a%20projection.htm) harita projeksiyonu ve ilgi alanına ve haritanızın / analizinizin içeriğine bağlı olarak uygun bir projeksiyonun nasıl seçilebileceği gibi farklı türlerden bahsetmektedir.


**İlkin**, her sağlık tesisinin çevresinde ~2,5 km yarıçaplı dairesel bir tampon oluşturun. Bu, **tmap**'teki `st_buffer()` fonksiyonuyla yapılır. Haritanın birimi enlem/boylam ondalık derece cinsinden olduğundan, "0,02" bu şekilde yorumlanır. Harita koordinat sisteminiz metre cinsinden ise sayının metre cinsinden verilmesi gerekir.

```{r, warning=F, message=F}
sle_hf_2k <- sle_hf %>%
  st_buffer(dist=0.02)       # ondalık derece, yaklaşık 2,5 km'ye eşittir 
```

Aşağıda, tampon bölgeleri şu şekilde çiziyoruz:

```{r, warning=F, message=F}
tmap_mode("plot")
# Create circular buffers
tm_shape(sle_hf_2k) +
  tm_borders(col = "black", lwd = 2)+
tm_shape(sle_hf) +                    # klinik tesislerini büyük kırmızı noktalarla çizin
  tm_dots(size=0.3, col='black')      
```


**İkinci olarak*, bu arabellekleri 'st_join()' ve *st_intersects* birleştirme türünü kullanarak durumlar (noktalar) ile kesiştiririz. Yani tamponlardan gelen veriler kesiştikleri noktalara birleştirilir.

```{r, warning=F, message=F}
# Vakaları arabelleklerle kesiştirin
linelist_sf_hf_2k <- linelist_sf_hf %>%
  st_join(sle_hf_2k, join = st_intersects, left = TRUE) %>%
  filter(osm_id.x==osm_id.y | is.na(osm_id.y)) %>%
  select(case_id, osm_id.x, nearest_clinic, amenity.x, osm_id.y)
```

Şimdi sonuçları sayabiliriz: ` nrow(linelist_sf_hf_2k[is.na(linelist_sf_hf_2k$osm_id.y),])` 1000 vakadan herhangi biri arabellekle kesişmedi (bu değer eksik) ve bu yüzden en yakın sağlık kuruluşundan 30 dakikadan fazla yürüyün.

```{r}
# Sağlık tesisi tamponlarından herhangi biriyle kesişmeyen vakalar
linelist_sf_hf_2k %>% 
  filter(is.na(osm_id.y)) %>%
  nrow()
```

Sonuçları, herhangi bir arabellekle kesişmeyen vakaların kırmızı görüneceği şekilde görselleştirebiliriz.

```{r, out.width = '100%', warning=F, message=F}
tmap_mode("view")

# İlk önce vakaları puan olarak görüntüleyin
tm_shape(linelist_sf_hf) +
  tm_dots(size=0.08, col='nearest_clinic') +

# klinik tesisleri büyük siyah noktalarla çizin
tm_shape(sle_hf) +                    
  tm_dots(size=0.3, col='black')+   

# Ardından sağlık tesisi arabelleklerini çoklu çizgilerle kaplayın
tm_shape(sle_hf_2k) +
  tm_borders(col = "black", lwd = 2) +

# Herhangi bir sağlık tesisi tamponunun parçası olmayan vakaları vurgulayın
# kırmızı noktalarda
tm_shape(linelist_sf_hf_2k %>%  filter(is.na(osm_id.y))) +
  tm_dots(size=0.1, col='red') +
tm_view(set.view = c(-13.2284,8.4699, 13), set.zoom.limits = c(13,14))+

# Başlık ekleyin
tm_layout(title = "Cases by clinic catchment area")

```



### Diğer uzamsal birleşimler {.unnumbered}

"Birleştirme" bağımsız değişkeni için alternatif değerler şunları içerir ([belgelerden](https://r-spatial.github.io/sf/reference/st_join.html))
* st_contains_properly  
* st_contains  
* st_covered_by  
* st_covers  
* st_crosses  
* st_disjoint  
* st_equals_exact  
* st_equals  
* st_is_within_distance  
* st_nearest_feature  
* st_overlaps  
* st_touches  
* st_within  





## Choropleth haritaları {}


Choropleth haritaları, verilerinizi önceden tanımlanmış alan, genellikle idari birim veya sağlık alanı ile görselleştirmek için faydalı olabilir. Salgın müdahalesinde bu, örneğin yüksek insidans oranlarına sahip belirli alanlar için kaynak tahsisinin hedeflenmesine yardımcı olabilir.

Artık tüm vakalara atanan idari birim adlarına sahip olduğumuza göre (yukarıdaki uzamsal birleştirmeler bölümüne bakın), vaka sayılarını alana göre eşleştirmeye başlayabiliriz (choropleth haritaları).

ADM3'e göre popülasyon verisi de elimizde olduğundan, bu bilgiyi daha önce oluşturulan *case_adm3* tablosuna ekleyebiliriz.

Her bir idari birimin ve vaka sayısının bir özet tablosu olan önceki 'case_adm3' adımında oluşturulan veri çerçevesi ile başlıyoruz.

1) "sle_adm3_pop" popülasyon verileri, "case_adm3" veri çerçevesindeki "admin3pcod" sütunundaki ve "sle_adm3_pop içindeki "adm_pcode" sütunundaki ortak değerler temelinde **dplyr**'den bir "left_join()" kullanılarak birleştirilir `. [Birleştirme verileri] ile ilgili sayfaya bakın).
2) Yalnızca yararlı sütunları tutmak için yeni veri çerçevesine "select()" uygulanır - "toplam" toplam nüfustur
3) 10.000 nüfus başına vaka sayısı, `mutate()` ile yeni bir sütun olarak hesaplanır.

```{r}
# Nüfus verilerini ekleyin ve 10.000 nüfus başına vakaları hesaplayın
case_adm3 <- case_adm3 %>% 
     left_join(sle_adm3_pop,                             # pop veri kümesinden sütunlar ekle
               by = c("admin3pcod" = "adm3_pcode")) %>%  # bu iki sütundaki ortak değerlere dayalı olarak birleştir
     select(names(case_adm3), total) %>%                 # toplam nüfus da dahil olmak üzere yalnızca önemli sütunları tut
     mutate(case_10kpop = round(cases/total * 10000, 3)) # 3 ondalık basamağa yuvarlanmış 10.000 başına büyük/küçük harf oranıyla yeni sütun oluştur

case_adm3                                                # izlemek için konsola yazdır
```

Eşleme için bu tabloya ADM3 çokgen şekil dosyasıyla katılın

```{r, warning=F, message=F}
case_adm3_sf <- case_adm3 %>%                 #vakalarla başlayın ve yönetici birimine göre puan verin
  left_join(sle_adm3, by="admin3pcod") %>%    # ortak sütunla şekil dosyası verilerine katıl
  select(objectid, admin3pcod,                # yalnızca belirli ilgi sütunlarını tut
         admin3name = admin3name.x,           # bir sütunun adını temizle
         admin2name, admin1name,
         cases, total, case_10kpop,
         geometry) %>%                        # geometriyi koru, böylece çokgenler çizilebilir
  drop_na(objectid) %>%                       # drop empty rows
  st_as_sf()                                  # şekil dosyasına çevir

```


Sonuçların haritalanması

```{r, message=F, warning=F}
# tmap modu
tmap_mode("plot")               # statik haritayı görüntüle

# poligonları çiz
tm_shape(case_adm3_sf) + 
        tm_polygons("cases") +  # vaka sayısına göre renk sütunu
        tm_text("admin3name")   # ismi göster
```

İnsidans oranlarını da haritalayabiliriz

```{r, warning=F, message=F}
# 10.000 nüfus başına vakalar
tmap_mode("plot")             # statik görüntüleme modu

# çizim
tm_shape(case_adm3_sf) +                # polygonlqrı çiz
  tm_polygons("case_10kpop",            # vaka oranını içeren sütuna göre renklendir
              breaks=c(0, 10, 50, 100), # renkler için kırılma noktaları tanımlayın
              palette = "Purples"       # mor renk paleti kullanın
              ) +
  tm_text("admin3name")                 # metni göster

```

## ggplot2 ile haritalandırma
**ggplot2** kullanımına zaten aşina iseniz, verilerinizin statik haritalarını oluşturmak için bu paketi kullanabilirsiniz. 'geom_sf()' fonksiyonu, verilerinizdeki hangi özelliklerin (noktalar, çizgiler veya çokgenler) olduğuna bağlı olarak farklı nesneler çizecektir. Örneğin, bir choropleth haritası oluşturmak için çokgen geometrili "sf" verilerini kullanarak bir "ggplot()" içinde "geom_sf()" kullanabilirsiniz.

Bunun nasıl çalıştığını göstermek için daha önce kullandığımız ADM3 çokgen şekil dosyasıyla başlayabiliriz. Bunların Sierra Leone'deki Yönetici Düzey 3 bölgeleri olduğunu hatırlayın:

```{r}
sle_adm3
```

Eşlemek istediğimiz verileri şekil dosyası nesnesine eklemek için **dplyr**'deki `left_join()` fonksiyonunu kullanabiliriz. Bu durumda, daha önce oluşturduğumuz 'case_adm3' veri çerçevesini, idari bölgelere göre vaka sayılarını özetlemek için kullanacağız; ancak, bir veri çerçevesinde depolanan herhangi bir veriyi eşlemek için aynı yaklaşımı kullanabiliriz.

```{r}
sle_adm3_dat <- sle_adm3 %>% 
  inner_join(case_adm3, by = "admin3pcod") # iç birleştirme = yalnızca her iki veri nesnesinde de tutuluyorsa

select(sle_adm3_dat, admin3name.x, cases) # seçili değişkenleri konsola yazdır
```

Bölgeye göre vaka sayımlarının sütun grafiğini yapmak için, **ggplot2** kullanarak, `geom_col()`u şu şekilde çağırabiliriz:

```{r, fig.align = "center"}
ggplot(data=sle_adm3_dat) +
  geom_col(aes(x=fct_reorder(admin3name.x, cases, .desc=T),   # 'vakaları' azaltarak x eksenini yeniden sıralayın
               y=cases)) +                                  # y ekseni bölgeye göre vaka sayısıdır
  theme_bw() +
  labs(                                                     # şekil metnini ayarla
    title="Number of cases, by administrative unit",
    x="Admin level 3",
    y="Number of cases"
  ) + 
  guides(x=guide_axis(angle=45))                            # açı x ekseni etiketleri daha iyi sığdırmak için 45 derecedir

```

Bunun yerine vaka sayımlarının bir choropleth haritası yapmak için **ggplot2** kullanmak istiyorsak, `geom_sf()` fonksiyonunu çağırmak için benzer sözdizimini kullanabiliriz:

```{r, fig.align = "center"}
ggplot(data=sle_adm3_dat) + 
  geom_sf(aes(fill=cases))    # dolguyu vaka sayısı değişkenine göre değiştirecek şekilde ayarla

```

Ardından, **ggplot2** genelinde tutarlı olan dilbilgisini kullanarak haritamızın görünümünü özelleştirebiliriz, örneğin:

```{r, fig.align = "center"}
ggplot(data=sle_adm3_dat) +                           
  geom_sf(aes(fill=cases)) +						
  scale_fill_continuous(high="#54278f", low="#f2f0f7") +    # renk derecesini değiştir
  theme_bw() +
  labs(title = "Number of cases, by administrative unit",   # şekil metnini ayarla
       subtitle = "Admin level 3"
  )
```

**ggplot2** ile rahat çalışan R kullanıcıları için, `geom_sf()`, temel harita görselleştirmeleri için uygun olan basit ve doğrudan bir uygulama sunar. Daha fazla bilgi edinmek için [geom_sf() gösterimi](https://ggplot2.tidyverse.org/reference/ggsf.html) veya [ggplot2 kitabını](https://ggplot2-book.org/maps.html) okuyabilirsiniz.



<!-- ======================================================= -->
## Altlık Haritalar{ }

### OpenStreetMap {.unnumbered}

Aşağıda, OpenStreetMap özelliklerini kullanarak **ggplot2** haritası için bir altlık haritanın nasıl elde edileceğini açıklıyoruz. Alternatif yöntemler arasında, Google'a ücretsiz kayıt gerektiren **ggmap** kullanımı yer almaktadır ([detaylar](https://www.earthdatascience.org/courses/earth-analytics/lidar-raster-data-r/ggmap-basemap/)) .

[**OpenStreetMap**](https://en.wikipedia.org/wiki/OpenStreetMap), ücretsiz düzenlenebilir bir dünya haritası oluşturmaya yönelik ortak bir projedir. Temel coğrafi konum verileri (örneğin şehirlerin konumları, yollar, doğal özellikler, havaalanları, okullar, hastaneler, yollar vb.), projenin birincil çıktısı olarak kabul edilir.

Öncelikle altlık haritamızı alacağımız **OpenStreetMap** paketini yüklüyoruz.

Ardından, **OpenStreetMap** paketinden ([dosyalar](https://www.rdocumentation.org/packages/OpenStreetMap/versions/0.3.4/konular/openmap) 'openmap()' fonksiyonunu kullanarak tanımladığımız 'harita' nesnesini oluşturuyoruz). Aşağıdakileri sağlıyoruz:

* 'upperLeft' ve 'lowRight' altlık harita döşemesinin sınırlarını belirten iki koordinat çifti
  * Bu durumda, satır listesinin satırlarından max ve min'i koyuyoruz, böylece harita verilere dinamik olarak yanıt verecek
* `zoom =` (null ise otomatik olarak belirlenir)
* `type =` hangi tür altlık harita - burada birkaç olasılık listeledik ve kod şu anda ilkini (`[1]`) "osm" kullanıyor
* `mergeTiles =` DOĞRU seçtik, böylece temel döşemeler tek bir yerde birleştirildi.

```{r, message=FALSE, warning=FALSE}
# paketi yükle
pacman::p_load(OpenStreetMap)

# Enlem/boylam koordinat aralığına göre altlık haritayı sığdır. Döşeme türünü seç.
map <- openmap(
  upperLeft = c(max(linelist$lat, na.rm=T), max(linelist$lon, na.rm=T)),   # altlık harita döşemelerinin sınırı
  lowerRight = c(min(linelist$lat, na.rm=T), min(linelist$lon, na.rm=T)),
  zoom = NULL,
  type = c("osm", "stamen-toner", "stamen-terrain", "stamen-watercolor", "esri","esri-topo")[1])
```

Bu altlık haritasını **OpenStreetMap** paketinden `autoplot.OpenStreetMap()` kullanarak şimdi çizersek, eksenlerdeki birimlerin enlem/boylam koordinatları olmadığını görürsünüz. Farklı bir koordinat sistemi kullanıyor. Vaka konutlarını (enlem/boylamda depolanan) doğru bir şekilde görüntülemek için bunun değiştirilmesi gerekir.

```{r, warning=F, message=F}
autoplot.OpenStreetMap(map)
```

Bu nedenle **OpenStreetMap** paketindeki `openproj()` fonksiyonu ile haritayı enlem/boylam şekline dönüştürmek istiyoruz. Altlık harita olarak 'map'i ve ayrıca istediğimiz Koordinat Referans Sistemini (CRS) sağlıyoruz. Bunu, WGS 1984 projeksiyonu için "proj.4" karakter dizisini sağlayarak yapıyoruz, ancak CRS'yi başka şekillerde de sağlayabilirsiniz. (bir proj.4 dizesinin ne olduğunu anlamak için bkz. [bu sayfa](https://www.earthdatascience.org/courses/earth-analytics/spatial-data-r/understand-epsg-wkt-and-other-crs-definition-file-types/)

```{r, warning=F, message=F}
# WGS84 projeksiyonu
map_latlon <- openproj(map, projection = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
```

Şimdi grafiği oluşturduğumuzda eksenler boyunca enlem ve boylam koordinatları olduğunu görüyoruz. Koordinat sistemi dönüştürüldü. Artık vakalarımız üst üste bindirilirse doğru şekilde çizilecek!

```{r, warning=F, message=F}
# Grafik haritası. ggplot ile çalışmak için "autoplot" kullanılmalıdır
autoplot.OpenStreetMap(map_latlon)
```

Daha fazla bilgi için Eğitimlere [buradan](http://data-analytics.net/cep/Schedule_files/geospatial.html) ve [buradan](https://www.rdocumentation.org/packages/OpenStreetMap/versions/0.3.4/) bakın Konular/autoplot.OpenStreetMap) ulaşabilirsiniz.


## Konturlu yoğunluk ısı haritaları {}

Aşağıda, bir satır listesiyle (vaka başına bir satır) başlayarak, bir altlık harita üzerinde vakaların konturlu bir yoğunluk ısı haritasının nasıl elde edileceğini açıklıyoruz.

1) Yukarıda açıklandığı gibi OpenStreetMap'ten altlık harita döşemesi oluşturun
2) Enlem ve boylam sütunlarını kullanarak durumları 'linelist'ten çizin
3) Noktaları **ggplot2**'den `stat_density_2d()` ile bir yoğunluk ısı haritasına dönüştürün,

Enlem/boylam koordinatlarına sahip bir altlık haritamız olduğunda, yerleşim yerlerinin enlem/boylam koordinatlarını kullanarak durumlarımızı en üste çizebiliriz.

Altlık haritayı oluşturmak için "autoplot.OpenStreetMap()" fonksiyonunu temel alan **ggplot2** fonksiyonları, aşağıda "geom_point()" ile gösterildiği gibi, kolayca en üste eklenecektir:

```{r, warning=F, message=F}
# Grafik haritası. ggplot ile çalışmak için "autoplot" kullanılmalıdır
autoplot.OpenStreetMap(map_latlon)+                 # altlık haritası ile başla
  geom_point(                                       # satır listesinin enlem ve boylam sütunlarından xy noktaları ekleyin 
    data = linelist,                                
    aes(x = lon, y = lat),
    size = 1, 
    alpha = 0.5,
    show.legend = FALSE) +                          # göstergeleri tamamen bırak
  labs(x = "Longitude",                             # başlıklar ve etiketler
       y = "Latitude",
       title = "Cumulative cases")

```

Yukarıdaki haritanın yorumlanması zor olabilir, özellikle de noktalar çakışıyorsa. Bunun yerine **ggplot2** `stat_density_2d()` fonksiyonunu kullanarak 2 boyutlu bir yoğunluk haritası çizebilirsiniz. Hala satır listesi enlem/boylam koordinatlarını kullanıyorsunuz, ancak 2B çekirdek yoğunluğu tahmini yapılıyor ve sonuçlar kontur çizgileriyle - bir topografik harita gibi - gösteriliyor. [Belgelerin tamamını buradan okuyabilirsiniz](https://ggplot2.tidyverse.org/reference/geom_density_2d.html)

```{r, warning=F, message=F}
# altlık haritası ile başla
autoplot.OpenStreetMap(map_latlon)+
  
  # yoğunluk grafiğine ekle
  ggplot2::stat_density_2d(
        data = linelist,
        aes(
          x = lon,
          y = lat,
          fill = ..level..,
          alpha = ..level..),
        bins = 10,
        geom = "polygon",
        contour_var = "count",
        show.legend = F) +                          
  
  # renk dağılımını belirle
  scale_fill_gradient(low = "black", high = "red")+
  
  # etiketler 
  labs(x = "Longitude",
       y = "Latitude",
       title = "Distribution of cumulative cases")

```



<!-- ======================================================= -->
### Zaman serisi ısı haritası {.unnumbered}

Yukarıdaki yoğunluk ısı haritası *kümülatif durumları* gösterir. Satır listesinden türetilen *semptom başlangıç ayına* dayalı olarak ısı haritasını şekillendirerek salgını zaman ve mekan içinde inceleyebiliriz.

Başlangıç Yılı ve Ayı ile yeni bir sütun oluşturarak "satır listesi" ile başlıyoruz. R **tabanı**ndaki 'format()' fonksiyonu, bir tarihin görüntülenme şeklini değiştirir. Bu durumda "YYYY-AA" istiyoruz.

```{r, warning=F, message=F}
# başlangıç ayını dışa aktar
linelist <- linelist %>% 
  mutate(date_onset_ym = format(date_onset, "%Y-%m"))

# Değerleri inceleyin
table(linelist$date_onset_ym, useNA = "always")
```

Şimdi, yoğunluk ısı haritasına **ggplot2** aracılığıyla yüzey oluşturmayı tanıtıyoruz. Yeni sütun satır olarak kullanılarak `facet_wrap()` uygulanır. Anlaşılır olması için yüzey sütunlarının sayısını 3 olarak ayarladık.

```{r, warning=F, message=F}
# paketler
pacman::p_load(OpenStreetMap, tidyverse)

# altlık haritası ile başlayın
autoplot.OpenStreetMap(map_latlon)+
  
  # yoğunluk grafiği ekleyin
  ggplot2::stat_density_2d(
        data = linelist,
        aes(
          x = lon,
          y = lat,
          fill = ..level..,
          alpha = ..level..),
        bins = 10,
        geom = "polygon",
        contour_var = "count",
        show.legend = F) +                          
  
  # renk dağılımını belirle
  scale_fill_gradient(low = "black", high = "red")+
  
  # etiketler 
  labs(x = "Longitude",
       y = "Latitude",
       title = "Distribution of cumulative cases over time")+
  
  # grafiği başlangıç ayı-yılına göre şekillendirin
  facet_wrap(~ date_onset_ym, ncol = 4)               

```

<!-- MEKANSAL İSTATİSTİK BÖLÜMÜ GELİŞTİRİLİYORmuş :)-->
## Mekansal istatistikler
Şimdiye kadarki tartışmalarımızın çoğu, mekansal verilerin görselleştirilmesine odaklandı. Bazı durumlarda, verilerinizdeki özniteliklerin uzamsal ilişkilerini ölçmek için *mekansal istatistikler* kullanmak da ilginizi çekebilir. Bu bölüm uzamsal istatistikteki bazı temel kavramlara çok kısa bir genel bakış sunacak ve daha kapsamlı uzamsal analizler yapmak istiyorsanız keşfetmenize yardımcı olacak bazı kaynaklar önerecektir.

### Mekansal ilişkiler {.unnumbered}

Herhangi bir uzamsal istatistiği hesaplamadan önce, verilerimizdeki özellikler arasındaki ilişkileri belirlememiz gerekir. Mekansal ilişkileri kavramsallaştırmanın birçok yolu vardır, ancak kullanımı basit ve yaygın olarak uygulanabilir bir model *bitişiklik* modelidir. Bu modelde, bir sınırı veya “komşuluğu” paylaşan alanlar arasında coğrafi bir ilişki beklemekteyiz.

**spdep** paketi ile kullandığımız `sle_adm3` datasında yönetim bölgesi poligonları arasındaki komşuluk ilişkilerini ölçebiliyoruz. *vezir* bitişikliğini belirleyeceğiz, bu, bölgelerin sınırları boyunca en az bir noktayı paylaştıkları takdirde komşu olacağı anlamına gelmektedir. Alternatif olarak, bölgelerin bir kenarı paylaşmasını gerektiren *kale* bitişikliği olacaktır - bizim durumumuzda, düzensiz çokgenlerle, ayrım önemsizdir, ancak bazı durumlarda vezir ve kale arasındaki seçim etkili olabilir.

```{r}
sle_nb <- spdep::poly2nb(sle_adm3_dat, queen=T) # komşuluklar yaratın 
sle_adjmat <- spdep::nb2mat(sle_nb)    # komşu ilişkilerini özetleyen matris oluşturun
sle_listw <- spdep::nb2listw(sle_nb)   # listw (ağırlık listesi) nesnesi oluştur -- buna daha sonra ihtiyacımız olacak

sle_nb
round(sle_adjmat, digits = 2)
```

Yukarıda yazdırılan matris, 'sle_adm3' verilerimizdeki 9 bölge arasındaki ilişkileri göstermektedir. 0 puan, iki bölgenin komşu olmadığını gösterirken, 0 dışında herhangi bir değer, bir komşu ilişkisini gösterir. Matristeki değerler, her bölgenin toplam satır ağırlığı 1 olacak şekilde ölçeklendirilir.

Bu komşu ilişkileri görselleştirmenin daha iyi bir yolu, onları çizmektir:
```{r, fig.align='center', results='hide'}
plot(sle_adm3_dat$geometry) +                                           # alan sınırlarını grafikleştir
  spdep::plot.nb(sle_nb,as(sle_adm3_dat, 'Spatial'), col='grey', add=T) # komşuluk ilişkileri ekle
```

Komşu çokgenleri tanımlamak için bir bitişiklik yaklaşımı kullandık; tanımladığımız komşulara bazen **bitişiklik tabanlı komşular** da denir. Ancak bu, coğrafi bir ilişkiye sahip olması beklenen bölgeleri seçmenin sadece bir yoludur. Coğrafi ilişkileri belirlemeye yönelik en yaygın alternatif yaklaşımı **mesafeye dayalı komşular** oluşturur; kısaca bunlar:
  
  * **K-en yakın komşular** - Merkezler (her çokgen bölgesinin coğrafi ağırlıklı merkezi) arasındaki mesafeye bağlı olarak, komşu olarak *n* en yakın bölgeleri seçin. Bir maksimum mesafe yakınlık eşiği de belirtilebilir. **spdep**'te "knearneigh()" kullanabilirsiniz (bkz. [belgeler](https://r-spatial.github.io/spdep/reference/knearneigh.html)).
  
  * **Mesafe eşiği komşuları** - Bir mesafe eşiği içindeki tüm komşuları seçin. **spdep**'te, bu komşu ilişkiler "dnearneigh()" kullanılarak tanımlanabilir (bkz. [belgeler](https://www.rdocumentation.org/packages/spdep/versions/1.1-7/topics/dnearneigh)) .

### Mekansal otokorelasyon {.unnumbered}

Tobler'in sık sık alıntılanan birinci coğrafya yasası, "her şey diğer her şeyle ilişkilidir, ancak yakın şeyler uzaktaki şeylerden daha fazla ilişkilidir" der. Epidemiyolojide bu genellikle, belirli bir bölgedeki belirli bir sağlık sonucu riskinin, uzaktaki bölgelere kıyasla komşu bölgelere daha benzer olduğu anlamına gelir. Bu kavram, **uzaysal otokorelasyon** olarak resmileştirilmiştir. Benzer değerlere sahip coğrafi özelliklerin uzayda bir araya toplandığı istatistiksel özellik olarak tanımlanır. Uzamsal otokorelasyonun istatistiksel ölçüleri, verilerinizdeki *mekansal kümelemenin kapsamını* ölçmek, *kümelemenin nerede gerçekleştiğini* belirlemek ve verilerinizdeki farklı değişkenler arasındaki *paylaşılan uzamsal otokorelasyon modellerini belirlemek* için kullanılabilir. Bu bölüm, bazı yaygın uzamsal otokorelasyon ölçülerine ve bunların R'da nasıl hesaplanacağına genel bir bakış sunar.

**Moran'ın İ İstatistiği** - Bu, bir bölgedeki bir değişkenin değeri ile komşu bölgelerdeki aynı değişkenin değerleri arasındaki korelasyonun genel bir özet istatistiğidir. Moran'ın I istatistiği tipik olarak -1 ile 1 arasındadır. 0 değeri uzamsal korelasyon modeli olmadığını gösterirken 1 veya -1'e yakın değerler sırasıyla daha güçlü uzamsal otokorelasyonu (benzer değerler birbirine yakındır) veya uzamsal dağılımı (benzersiz değerler birbirine yakındır) gösterir.

Örnek olarak, daha önce haritalandırdığımız Ebola vakalarındaki uzamsal otokorelasyonu ölçmek için Moran'ın İ istatistiğini hesaplayacağız (unutmayın, bu simüle edilmiş salgın "satır listesi" veri çerçevesinden vakaların bir alt kümesidir). **spdep** paketinde bu hesaplamayı bizim için yapabilen "moran.test" fonskiyonu vardır:

```{r}
moran_i <-spdep::moran.test(sle_adm3_dat$cases,    # ilgilenilen değişken içim sayısal vektör
                            listw=sle_listw)       # komşu ilişkilerini özetleyen listw nesnesi

moran_i                                            # yazdırma sonuçları
```

'moran.test()' fonksiyonunun çıktısı bize 'round(moran_i$estimate[1],2)' Moran I istatistiğini gösterir. Bu, verilerimizde uzamsal otokorelasyonun varlığını gösterir - özellikle, benzer sayıda Ebola vakası olan bölgelerin birbirine yakın olması muhtemeldir. "moran.test()" tarafından sağlanan p değeri, uzaysal otokorelasyonun olmadığı sıfır hipotezi altındaki beklentiyle karşılaştırılarak oluşturulur ve resmi bir hipotez testinin sonuçlarını bildirmeniz gerekiyorsa kullanılabilir.

**Yerel Moran I** - *yerelleştirilmiş* uzamsal otokorelasyonu tanımlamak için yukarıda hesaplanan (küresel) Moran I istatistiğini ayrıştırabiliriz; bu durum verilerimizdeki belirli kümeleri tanımlamamızı sağlar. Bazen **Yerel Mekansal İlişki Göstergesi (LISA)** istatistiği olarak adlandırılan bu istatistik, her bir bölge etrafındaki mekansal otokorelasyonun kapsamını özetler. Haritada "sıcak" ve "soğuk" noktaları bulmak için faydalı olabilir.

Bir örnek göstermek için, yukarıda kullanılan Ebola vaka sayıları için Yerel Moran'ın I istatistiğini **spdep**'ten `local_moran()` fonksiyonuyla hesaplayabilir ve eşleyebiliriz:
```{r, fig.align='center'}
# yereli hesapla
local_moran <- spdep::localmoran(                  
  sle_adm3_dat$cases,                              # ilgi değişkeni
  listw=sle_listw                                  # komşu ağırlıkları ile listw nesnesi
)

# sf verilerine sonuçları birleştirme
sle_adm3_dat<- cbind(sle_adm3_dat, local_moran)    

# harita grafiği
ggplot(data=sle_adm3_dat) +
  geom_sf(aes(fill=Ii)) +
  theme_bw() +
  scale_fill_gradient2(low="#2c7bb6", mid="#ffffbf", high="#d7191c",
                       name="Local Moran's I") +
  labs(title="Local Moran's I statistic for Ebola cases",
       subtitle="Admin level 3 regions, Sierra Leone")

```

**Getis-Ord Gi\** - Bu, etkin nokta analizi için yaygın olarak kullanılan başka bir istatistiktir. Bu istatistiğin popülaritesi büyük ölçüde ArcGIS'teki Sıcak Nokta Analizi aracındaki kullanımıyla ilgilidir. Tipik olarak, komşu bölgeler arasındaki bir değişkenin değerindeki farkın normal bir dağılım izlemesi gerektiği varsayımına dayanır. Komşularına kıyasla, belirli bir değişkenin önemli ölçüde daha yüksek (sıcak nokta) veya önemli ölçüde daha düşük (soğuk nokta) değerlerine sahip bölgeleri belirlemek için bir z-skoru yaklaşımı kullanır.

**spdep**'teki `localG()` fonksiyonunu kullanarak *Gi* istatistiğini hesaplayabilir ve eşleyebiliriz:

```{r}
# Yerel G analizi gerçekleştir
getis_ord <- spdep::localG(
  sle_adm3_dat$cases,
  sle_listw
)

# sf verisine sonuçları ekleme
sle_adm3_dat$getis_ord <- getis_ord

# harita grafiği
ggplot(data=sle_adm3_dat) +
  geom_sf(aes(fill=getis_ord)) +
  theme_bw() +
  scale_fill_gradient2(low="#2c7bb6", mid="#ffffbf", high="#d7191c",
                       name="Gi*") +
  labs(title="Getis-Ord Gi* statistic for Ebola cases",
       subtitle="Admin level 3 regions, Sierra Leone")

```

Gördüğünüz gibi *Getis-Ord Gi* haritası daha önce hazırladığımız Yerel Moran'ın İ haritasından biraz farklı görünüyor. Bu, iki istatistiği hesaplamak için kullanılan yöntemin biraz farklı olduğunu yansıtır; hangisini kullanmanız gerektiği, özel kullanım durumunuza ve ilgilendiğiniz araştırma sorusuna bağlıdır.

**Lee's L testi** - İki değişkenli uzamsal korelasyon için istatistiksel bir testtir. Belirli bir *x* değişkeni için uzamsal kalıbın, uzamsal olarak *x* ile ilişkili olduğu varsayılan başka bir değişken olan *y*'nin uzamsal kalıbına benzer olup olmadığını test etmenizi sağlar.

Bir örnek vermek gerekirse, simüle edilmiş salgındaki Ebola vakalarının mekansal düzeninin, nüfusun mekansal düzeniyle ilişkili olup olmadığını test edelim. Başlamak için, 'sle_adm3' verilerimizde bir 'population' değişkenine ihtiyacımız var. Daha önce yüklediğimiz 'sle_adm3_pop' veri çerçevesinden 'total' değişkenini kullanabiliriz.

```{r}
sle_adm3_dat <- sle_adm3_dat %>% 
  rename(population = total)                          # toplamı nüfus olarak yeniden adlandır
```

Benzer görünüp görünmediklerini görmek için iki değişkenin uzamsal modellerini yan yana hızlı bir şekilde görselleştirebiliriz:
```{r, fig.align='center', warning=F, message=F}
tmap_mode("plot")

cases_map <- tm_shape(sle_adm3_dat) + tm_polygons("cases") + tm_layout(main.title="Cases")
pop_map <- tm_shape(sle_adm3_dat) + tm_polygons("population") + tm_layout(main.title="Population")

tmap_arrange(cases_map, pop_map, ncol=2)   # 2x1 yönlerine göre düzenleyin
```

Görsel olarak, desenler farklı görünüyor. İki değişkendeki uzamsal otokorelasyon modelinin ilişkili olup olmadığını istatistiksel olarak test etmek için **spdep** içindeki `lee.test()` fonksiyonunu kullanabiliriz. Modeller arasında korelasyon yoksa L istatistiği 0'a yakın, güçlü bir pozitif korelasyon varsa 1'e yakın (yani modeller benzer) ve güçlü bir negatif korelasyon varsa -1'e yakındır (örn. desenler terstir).

```{r, warning=F, message=F}
lee_test <- spdep::lee.test(
  x=sle_adm3_dat$cases,          # karşılaştırılacak değişken 1
  y=sle_adm3_dat$population,     # karşılaştırılacak değişken 2
  listw=sle_listw                # komşu ağırlıkları ile listw nesnesi
)

lee_test
```

Yukarıdaki çıktı, iki değişkenimiz için Lee'nin L istatistiğinin, zayıf negatif korelasyonu gösteren `round(lee_test$estimate[1],2)' olduğunu göstermektedir. Vaka ve nüfus düzeninin birbiriyle ilişkili olmadığına dair görsel değerlendirmemizi doğrular ve vakaların mekânsal düzeninin kesinlikle yüksek riskli bölgelerdeki nüfus yoğunluğunun bir sonucu olmadığına dair kanıt sağlar.

Lee L istatistiği, uzamsal olarak dağılmış değişkenler arasındaki ilişki hakkında bu tür çıkarımlar yapmak için faydalı olabilir; ancak, iki değişken arasındaki ilişkinin doğasını daha ayrıntılı olarak tanımlamak veya kafa karıştırıcı duruma göre ayarlamak için *uzaysal regresyon* tekniklerine ihtiyaç duyulacaktır. Bunlar aşağıdaki bölümde kısaca açıklanmıştır.

### Mekansal regresyon {.unnumbered}

Uzamsal verilerinizdeki değişkenler arasındaki ilişkiler hakkında istatistiksel çıkarımlar yapmak isteyebilirsiniz. Bu durumlarda, *uzaysal regresyon* tekniklerini, yani verilerinizdeki birimlerin uzamsal organizasyonunu açıkça dikkate alan regresyon yaklaşımlarını anlamak yararlıdır. Genel Lineer Modeller (GLM) gibi standart regresyon modelleri yerine uzamsal regresyon modellerini dikkate almanız gerekebilecek bazı nedenler şunlardır:

  * Standart regresyon modelleri, artıkların birbirinden bağımsız olduğunu varsayar. Güçlü bir *uzaysal otokorelasyon* varlığında, standart bir regresyon modelinin artıklarının da uzaysal olarak otokorelasyona sahip olması muhtemeldir, dolayısıyla bu varsayımı ihlal eder. Bu, model sonuçlarının yorumlanmasında sorunlara yol açabilir, bu durumda uzamsal bir model tercih edilir.
  
  * Regresyon modelleri ayrıca tipik olarak *x* değişkeninin etkisinin tüm gözlemlerde sabit olduğunu varsayar. *Mekansal heterojenlik* durumunda, tahmin etmek istediğimiz etkiler uzaya göre değişebilir ve bu farklılıkları ölçmekle ilgilenebiliriz. Bu durumda, uzamsal regresyon modelleri, etkileri tahmin etmek ve yorumlamak için daha fazla esneklik sunar.
  
Mekansal regresyon yaklaşımlarının ayrıntıları bu el kitabının kapsamı dışındadır. Bu bölüm bunun yerine en yaygın uzamsal regresyon modellerine ve kullanımlarına genel bir bakış sunacak ve bu alanı daha fazla araştırmak isterseniz kullanılabilecek referanslara yönlendirecektir.

**Uzamsal hata modelleri** - Bu modeller, uzamsal birimler arasındaki hata terimlerinin ilişkili olduğunu varsayar; bu durumda veriler, standart bir "Ordinary Least Squares (OLS)" modelinin varsayımlarını ihlal eder. Uzamsal hata modellerine bazen **eşzamanlı otoregresif (SAR) modeller** de denir. **spatialreg** paketindeki 'errorsarlm()' fonksiyonu kullanılarak sığdırılabilirler (eskiden **spdep**'in bir parçası olan uzamsal regresyon fonksiyonları).

**Uzamsal gecikme modelleri** - Bu modeller, *i* bölgesi için bağımlı değişkenin yalnızca *i* içindeki bağımsız değişkenlerin değerinden değil, aynı zamanda *i*'ye komşu bölgelerdeki bu değişkenlerin değerlerinden de etkilendiğini varsayar. Uzamsal hata modelleri gibi, uzaysal gecikme modelleri de bazen **eşzamanlı otoregresif (SAR) modeller** olarak tanımlanır. **spatialreg** paketindeki `lagsarlm()` fonskiyonu kullanılarak sığdırılabilirler.

**spdep** paketi, standart OLS, uzamsal gecikme ve uzamsal hata modelleri arasında karar vermek için birkaç faydalı tanı testi içerir. *Lagrange Çarpanı teşhisleri* olarak adlandırılan bu testler, verilerinizdeki uzamsal bağımlılığın türünü belirlemek ve hangi modelin en uygun olduğunu seçmek için kullanılabilir. `lm.LMtests()` fonksiyonu, tüm Lagrange Çarpan testlerini hesaplamak için kullanılabilir. Anselin (1988) ayrıca Lagrange Çarpan testlerinin sonuçlarına dayanarak hangi uzaysal regresyon modelinin kullanılacağına karar vermek için kullanışlı bir akış şeması aracı sağlar:

```{r, fig.align='center', echo=F}
knitr::include_graphics(here::here("images", "gis_lmflowchart.jpg"))
```

**Bayesin hiyerarşik modelleri** - Bayes yaklaşımları, uzaysal analizdeki bazı uygulamalar için yaygın olarak kullanılır, en yaygın olarak [hastalık haritalama](https://pubmed.ncbi.nlm.nih.gov/15690999/). Vaka verilerinin seyrek olarak dağıtıldığı (örneğin, nadir bir sonuç durumunda) veya istatistiksel olarak "gürültülü" olduğu durumlarda tercih edilirler, çünkü altta yatan gizli mekansal verileri hesaba katarak hastalık riskinin "düzeltilmiş" tahminlerini oluşturmak için kullanılabilirler. Bu, tahminlerin kalitesini artırabilir. Bunlar ayrıca, hem bağımsız hem de bağımlı değişkenlerde uzamsal olarak bağımlı ve bağımsız varyasyonu açıklayabilen, verilerde bulunabilen karmaşık uzamsal korelasyon modellerinin araştırmacı tarafından önceden belirlenmesine (önceki seçim yoluyla) izin verir. R'da, Bayesin hiyerarşik modelleri **CARbayes** paketi kullanılarak sığdırılabilir (bkz. [gösterim](https://cran.r-project.org/web/packages/CARBayes/vignettes/CARBayes.pdf)) veya R -INLA (bkz. [web sitesi](https://www.r-inla.org/home) ve [ders kitabı](https://becarioprecario.bitbucket.io/inla-gitbook/)). R ayrıca JAGS veya WinBUGS gibi Bayes tahmini yapan harici yazılımları çağırmak için de kullanılabilir.

<!--Konu çok teknikti çevirirken çoğu yeri anlamadım. Sonraki çevirilerde alanın uzmanı birisi bir göz atsa faydası olur. ============================================= ========= -->
## Kaynaklar {  }

* R'ın Basit Özellikleri ve sf paketi [gösterim](https://cran.r-project.org/web/packages/sf/vignettes/sf1.html)


* R tmap paketi [gösterim](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html)


* ggmap: [ggplot2 ile Mekansal Görselleştirme](https://journal.r-project.org/archive/2013-1/kahle-wickham.pdf)


* [R ile harita oluşturmaya giriş, farklı paketlere genel bakış](https://bookdown.org/nicohahn/making_maps_with_r5/docs/introduction.html)

* R'da Mekansal Veriler [(EarthLab kursu)](https://www.earthdatascience.org/courses/earth-analytics/spatial-data-r/)

* R'da Uygulamalı Uzamsal Veri Analizi [ders kitabı](https://link.springer.com/book/10.1007/978-1-4614-7618-4)

* **SpatialEpiApp** - [R paketi olarak indirilebilen bir Shiny uygulaması](https://github.com/Paula-Moraga/SpatialEpiApp), kendi verilerinizi sağlamanıza ve haritalama, küme analizi ve mekansal istatistikleri sağlar.


* R'da Mekansal Ekonometriye Giriş [atölye](http://www.econ.uiuc.edu/~lab/workshop/Spatial_in_R.html)
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/gis.Rmd-->

# (PART) Data Visualization {.unnumbered}
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/cat_data_viz.Rmd-->


# Sunum için tablolar { }  


```{r echo=FALSE, fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}

linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds")) 

border_style = officer::fp_border(color="black", width=1)

pacman::p_load(
  rio,            # içe/dışa aktar
  here,           # dosya yolağı
  flextable,      # HTML tablosu oluştur 
  officer,        # tablolar için yardımcı fonksiyonlar
  tidyverse)      # veri yönetimi, özetlemesi ve görselleştirilmesi

table <- linelist %>% 
  # filtrele
  ########
  #filter(!is.na(outcome) & hospital != "Missing") %>%  # Eksik sonuç veya hastane olan vakaları kaldır
  
  # Hastane sonuç grubu başına özet değerleri al
  ###############################################
  group_by(hospital, outcome) %>%                      # Grup verisi
  summarise(                                           # İlgilenilen göstergelerin yeni özet sütunları oluştur
    N = n(),                                            # Hastane-sonuç grubu başına satır sayısı   
    ct_value = median(ct_blood, na.rm=T)) %>%           # Grup başına medyan CT değeri
  
  # Toplamları ekle
  ############
  bind_rows(                                           # Önceki tabloyu mini toplamlar tablosuyla birleştir
    linelist %>% 
      filter(!is.na(outcome) & hospital != "Missing") %>%
      group_by(outcome) %>%                            # Hastaneye göre değil, yalnızca sonuca göre gruplandır   
      summarise(
        N = n(),                                       # Tüm veri kümesi için satır sayısı     
        ct_value = median(ct_blood, na.rm=T))) %>%     # Tüm veri seti için medyan CT değeri
  
  # Geniş pivotlama ve format
  ########################
  mutate(hospital = replace_na(hospital, "Total")) %>% 
  pivot_wider(                                         # uzundan genişe pivotla
    values_from = c(ct_value, N),                       # yeni değerler ct ve count sütunlarından alınır
    names_from = outcome) %>%                           # yeni sütun adları sonuçlardan alınır
  mutate(                                              # yeni sütun ekle
    N_Known = N_Death + N_Recover,                               # sonucu bilinen satır sayısı
    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # ölen vakaların yüzdesi (1 ondalık basamağa kadar)
    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # iyileşen vakaların yüzdesi (1 ondalık basamağa kadar)
  select(                                              # Sütunları yeniden sırala
    hospital, N_Known,                                   # Giriş sütunları
    N_Recover, Pct_Recover, ct_value_Recover,            # İyileşen vaka sütunları
    N_Death, Pct_Death, ct_value_Death)  %>%             # Ölen vaka sütunları
  arrange(N_Known) %>%                                 # Satırları en düşükten en yükseğe doğru düzenle (Toplam satırı en altta)

  # formatlama
  ############
  flextable() %>% 
  add_header_row(
    top = TRUE,                # Yeni başlık, mevcut başlık satırının üstüne eklenir
    values = c("Hospital",     # Aşağıdaki her sütun için başlık değerleri
               "Total cases with known outcome", 
               "Recovered",    # Bu, bunun ve sonraki iki sütunun en üst düzey başlığı olacak
               "",
               "",
               "Died",         # Bu, bunun ve sonraki iki sütunun en üst düzey başlığı olacak
               "",             # "Öldü" ile birleştirileceği için boş bırak
               "")) %>% 
    set_header_labels(         # Orijinal başlık satırındaki sütunları yeniden adlandır
      hospital = "", 
      N_Known = "",                  
      N_Recover = "Total",
      Pct_Recover = "% of cases",
      ct_value_Recover = "Median CT values",
      N_Death = "Total",
      Pct_Death = "% of cases",
      ct_value_Death = "Median CT values")  %>% 
  merge_at(i = 1, j = 3:5, part = "header") %>% # Yeni başlık satırında 3 ile 5 arasındaki sütunları yatay olarak birleştir
  merge_at(i = 1, j = 6:8, part = "header") %>%  
  border_remove() %>%  
  theme_booktabs() %>% 
  vline(part = "all", j = 2, border = border_style) %>%   # at column 2 
  vline(part = "all", j = 5, border = border_style) %>%   # at column 5
  merge_at(i = 1:2, j = 1, part = "header") %>% 
  merge_at(i = 1:2, j = 2, part = "header") %>% 
  width(j=1, width = 2.7) %>% 
  width(j=2, width = 1.5) %>% 
  width(j=c(4,5,7,8), width = 1) %>% 
  flextable::align(., align = "center", j = c(2:8), part = "all") %>% 
  bg(., part = "body", bg = "gray95")  %>% 
  #bg(., j=c(1:8), i= ~ hospital == "Military Hospital", part = "body", bg = "#91c293") %>% 
  bg(j = 7, i = ~ Pct_Death >= 55, part = "body", bg = "red") %>% 
  colformat_num(., j = c(4,7), digits = 1) %>%
  bold(i = 1, bold = TRUE, part = "header") %>% 
  bold(i = 7, bold = TRUE, part = "body")

table
```


Bu sayfa, **flextable** paketi ile özet veri çerçevelerinin sunuma hazır tablolara nasıl dönüştürüleceğini göstermektedir. Bu tablolar powerpoint slaytlarına, HTML sayfalarına, PDF veya Word belgelerine vb. eklenebilir.

**flextable**'ı kullanmadan *önce*, özet tablosunu veri çerçevesi olarak oluşturmanız gerekmektedir. Tablolar, çapraz tablolar, özetler ve açıklayıcı istatistiklerin hesaplanması gibi [Tanımlayıcı tablolar] ve [Özetleme verileri] sayfalarındaki yöntemleri kullanabilirsiniz. Veri çerçevesine uygulanan **flextable** daha sonraki sunumlara uygulanabilir.

Tablo oluşturmak için kullanılabilecek birçok R paketi vardır - bu sayfada **flextable**'ı vurgulamak istedik. **knitr** paketini ve onun `kable()` fonksiyonunu kullanan bir örnek [Temaslı takibi] sayfasında bulunabilir. Benzer şekilde, **DT** paketi [Shiny Gösterge Tabloları] sayfasında vurgulanmıştır. **GT** ve **huxtable** gibi diğerleri [Önerilen paketler] sayfasında bahsedilmiştir.


<!-- ======================================================= -->
## Hazırlık {  }

### Paketleri yükleme {.unnumbered} 

**flextable**'ı kurun ve yükleyin. Bu el kitabında, paketi kuran *ve* kullanım için yükleyen **pacman**'dan `p_load()` kullanacağız. R tabanından `library()` içeren paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] sayfasına bakabilirsiniz.

```{r}
pacman::p_load(
  rio,            # içe/dışa aktar
  here,           # dosya yolağı
  flextable,      # HTML tablosu oluştur 
  officer,        # tablolar için yardımcı fonksiyonlar
  tidyverse)      # veri yönetimi, özetlemesi ve görselleştirilmesi

```

### Verileri içe aktarma {.unnumbered}  

Başlamak için, simüle edilmiş bir Ebola salgınından temizlenmiş vaka listesini içe aktarıyoruz. Takip etmek isterseniz, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>"temiz satır listesi" dosyasını indirmek için tıklayın.</a> (.rds dosyası olarak). **rio** paketinden `import()` fonksiyonuyla verileri içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe aktarma ve dışa aktarma] sayfasına bakın). 


```{r, echo=F}
# satır listesini R'a aktar
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# satır listesini içe aktar
linelist <- import("linelist_cleaned.rds")
```

Çizgi listesinin ilk 50 satırı aşağıda görüntülenmektedir:

```{r, message=FALSE, echo=F}
# satır listesini tablo olarak göster
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Tabloyu hazırlama {.unnumbered}  

**flextable** kullanmaya *başlamadan önce* tablonuzu veri çerçevesine *dönüştürmeniz* gerekecektir. **janitor** ve **dplyr** gibi paketleri kullanarak bir veri çerçevesinin nasıl oluşturulacağını öğrenmek için [Tanımlayıcı tablolar] ve [Veri pivotlama] sayfalarına bakabilirsiniz. İçeriği, görüntülenmesini istediğiniz gibi satırlar ve sütunlar halinde düzenlemelisiniz. Ardından, veri çerçevesinin rengi, başlığı, yazı tipleri vb. ile görüntülemek için **flextable**'e geçirilecektir.
  
Aşağıda, [Tanımlayıcı tablolar] sayfasından, vaka `satır listesi` örnek olarak kullanılmıştır. Hazırlanan tabloda toplamlar satırı ile hastaneye göre hasta sonuçları ve CT değerlerini özetlenmiştir. 

```{r message=FALSE, warning=FALSE}
table <- linelist %>% 
  
  # Hastane sonuç grubu başına özet değerleri al
  ###############################################
  group_by(hospital, outcome) %>%                      # Grup verisi
  summarise(                                           # İlgilenilen göstergelerin yeni özet sütunları oluştur
    N = n(),                                            # Hastane-sonuç grubu başına satır sayısı   
    ct_value = median(ct_blood, na.rm=T)) %>%           # Grup başına medyan CT değeri
  
  # Toplamları ekle
  ############
  bind_rows(                                           # Önceki tabloyu mini toplamlar tablosuyla birleştir
    linelist %>% 
      filter(!is.na(outcome) & hospital != "Missing") %>%
      group_by(outcome) %>%                            # Hastaneye göre değil, yalnızca sonuca göre gruplandır  
      summarise(
        N = n(),                                       # Tüm veri kümesi için satır sayısı    
        ct_value = median(ct_blood, na.rm=T))) %>%     # Tüm veri seti için medyan CT değeri
  
  # Geniş pivotlama ve format
  ########################
  mutate(hospital = replace_na(hospital, "Total")) %>% 
  pivot_wider(                                         # uzundan genişe pivotla
    values_from = c(ct_value, N),                       # yeni değerler ct ve count sütunlarından alınır
    names_from = outcome) %>%                           # yeni sütun adları sonuçlardan alınır
  mutate(                                              # yeni sütun ekle
    N_Known = N_Death + N_Recover,                               # sonucu bilinen sayı
    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # ölen vakaların yüzdesi (1 ondalık basamağa kadar)
    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # iyileşen vakaların yüzdesi (1 ondalık basamağa kadar)
  select(                                              # Sütunları yeniden sırala
    hospital, N_Known,                                   # Giriş sütunları
    N_Recover, Pct_Recover, ct_value_Recover,            # İyileşen vaka sütunları
    N_Death, Pct_Death, ct_value_Death)  %>%             # Ölen vaka sütunları
  arrange(N_Known)                                     # Satırları en düşükten en yükseğe doğru düzenle (Toplam satırı en altta)

table  # yazdır

```




<!-- ======================================================= -->
## Temel flextable {  }

### Flextable oluşturma {.unnumbered}  

**flextable** nesnelerini oluşturmak ve yönetmek için, önce veri çerçevesini `flextable()` fonksiyonundan geçirilir. Sonuç `my_table` olarak kaydedilir.

```{r}

my_table <- flextable(table) 
my_table

```

Bu yapıldıktan sonra, daha fazla **flextable** biçimlendirme fonksiyonları aracılığıyla `my_table` nesnesi aşamalı olarak yönlendirilebilir. 

Bu sayfada, anlaşılır olması için ara adımlarda tablo `my_table` olarak kaydedilecek ve **flextable** fonksiyonları bit-bit eklenecektir. Kodun başından sonuna kadar *tümünü* tek bir yığın halinde yazılmış olarak görmek isterseniz, aşağıdaki [Bütün kodlar](#tbl_pres_all) bölümünü ziyaret edebilirsiniz. 

**flextable** koduna ait her bir satırının genel sözdizimi aşağıdaki gibidir:

* `function(table, i = X, j = X, part = "X")`, burada:
  * `function`, sütun genişliklerini belirlemek için `width()`, arka plan renklerini ayarlamak için `bg()`, metnin merkeze/sağa/sola hizalı olup olmadığını ayarlamak için `align()` gibi birçok farklı fonksiyondan biri olabilir.
  * `table = ` veri çerçevesinin adıdır, ancak veri çerçevesi fonksiyona aktarılıyorsa belirtilmesine gerek yoktur.
  * `part = ` fonksiyonun tablonun hangi bölümüne uygulandığını belirtir. Örneğin. "başlık", "gövde" veya "tümü".
  * `i = ` fonksiyonun uygulanacağı *satırı* belirtir, burada `X` satır numarasıdır. Birden fazla satır varsa, ör. birinci ila üçüncü satırlar arasında şu şekilde yazılabilir: `i = c(1:3)`. 'Gövde' seçiliyse, ilk satırın başlık bölümünün altından başladığını unutmayın.
  * `j = ` fonksiyonun uygulanacağı *sütununu* belirtir, burada `X` sütun numarası veya adıdır. Birden çok sütun varsa, ör. beşinci ve altıncı, şu şekilde yazılabilir: `j = c(5,6)`. 
  
**flextable** biçimlendirme fonksiyonlarına ait tam listeyi [burada](https://davidgohel.github.io/flextable/reference/index.html) bulabilir veya `?flextable` komutunu girerek belgeleri inceleyebilirsiniz.


### Sütun genişliği {.unnumbered}

Her hücrede yalnızca bir metin satırı olacak şekilde tabloyu güzelce genişleten `autofit()` fonksiyonunu kullanabiliriz. `qflextable()` fonksiyonu, `flextable()` ve `autofit()` için uygun bir kısayoldur.

```{r}

my_table %>% autofit()

```

Ancak, özellikle hücreler içinde çok uzun değerler varsa, bu fonksiyon her zaman uygun olmayabilir, tablo sayfaya sığmayabilir. 

Bunun yerine genişlikleri `width()` fonksiyonu ile belirtebilir. Hangi genişlik değerini koyacağınızı bilmek biraz zaman alabilir. Aşağıdaki örnekte, sütun 1, 2, 4 ve 8 için farklı genişlikler belirlenmiştir.

```{r}

my_table <- my_table %>% 
  width(j=1, width = 2.7) %>% 
  width(j=2, width = 1.5) %>% 
  width(j=c(4,5,7,8), width = 1)

my_table
  
```

### Sütun başlıkları {.unnumbered}

Tablo içeriklerinin daha kolay yorumlanması için daha net başlıklar istenir.

Bu tablo için, aynı alt grupları kapsayan sütunların birlikte gruplanabilmesi için ikinci bir başlık katmanı eklemek istiyoruz. Bu `top = TRUE` argümanı ve `add_header_row()` fonksiyonu ile yapılmaktadır. Daha sonra birleştirilecek sütunlar için `""` boş değer bırakılarak, her sütunun yeni adı `values =` argümanıyla verilmektedir.  

İkinci başlıktaki başlık adları ayrı bir `set_header_labels()` komutuyla yeniden adlandırılır.

Son olarak, üst başlıktaki belirli sütun başlıklarını "birleştirmek" için, `merge_at()` fonksiyonu kullanılır.

```{r}
my_table <- my_table %>% 
  
  add_header_row(
    top = TRUE,                # Yeni başlık, mevcut başlık satırının üstüne eklenir
    values = c("Hospital",     # Aşağıdaki her sütun için başlık değerleri
               "Total cases with known outcome", 
               "Recovered",    # Bu, bunun ve sonraki iki sütunun en üst düzey başlığı olacak
               "",
               "",
               "Died",         # Bu, bunun ve sonraki iki sütunun en üst düzey başlığı olacak
               "",             # "Öldü" ile birleştirileceği için boş bırak
               "")) %>% 
    
  set_header_labels(         # Orijinal başlık satırındaki sütunları yeniden adlandır
      hospital = "", 
      N_Known = "",                  
      N_Recover = "Total",
      Pct_Recover = "% of cases",
      ct_value_Recover = "Median CT values",
      N_Death = "Total",
      Pct_Death = "% of cases",
      ct_value_Death = "Median CT values")  %>% 
  
  merge_at(i = 1, j = 3:5, part = "header") %>% # Yeni başlık satırında 3 ile 5 arasındaki sütunları yatay olarak birleştir
  merge_at(i = 1, j = 6:8, part = "header")     # HYeni başlık satırında 6 ile 8 arasındaki sütunları yatay olarak birleştir

my_table  # print

```

### Kenarlıklar ve arka plan {.unnumbered}  

Çeşitli **flextable** fonksiyonlarıyla kenarlıkları, iç çizgileri vb. ayarlayabilirsiniz. `border_remove()` ile mevcut tüm sınırları kaldırarak başlamak genellikle daha kolaydır.  

Ardından, tabloyu `theme_box()`, `theme_booktabs()` veya `theme_alafoli()` öğelerine geçirerek varsayılan kenarlık temalarını uygulayabilirsiniz.

Çeşitli fonksiyonlara dikey ve yatay çizgiler ekleyebilirsiniz. `hline()` ve `vline()` sırasıyla belirli bir satıra veya sütuna satır ekler. Her birinin içinde "part  =" öğesini "tümü", "gövde" veya "başlık" olarak belirtmelisiniz. Dikey çizgiler için sütunu `j = ` ve yatay çizgiler için satırı `i = ` olarak belirtmelisiniz. `vline_right()`, `vline_left()`, `hline_top()` ve `hline_bottom()` gibi diğer işlevler yalnızca dış taraflara satır ekler.

Tüm bu fonksiyonlarda, çizgi stili `border = ` olarak belirtilmelidir ayrıca **officer** paketinden `fp_border()` fonksiyonunu kullanan ayrı bir komutun çıktısı şeklinde olmalıdır. Bu fonksiyon, çizginin genişliğini ve rengini tanımlamanıza yardımcı olur. Bunu aşağıda gösterildiği gibi tablo komutlarının üzerinde tanımlayabilirsiniz.  

```{r}
# sınır çizgisi için stil tanımla
border_style = officer::fp_border(color="black", width=1)

# tabloya sınır çizgileri ekle
my_table <- my_table %>% 

  # Mevcut tüm sınırları kaldır
  border_remove() %>%  
  
  # önceden belirlenmiş bir tema ayarıyla yatay çizgiler ekle
  theme_booktabs() %>% 
  
  # İyileşen ve Ölen bölümleri ayırmak için dikey çizgiler ekleyin
  vline(part = "all", j = 2, border = border_style) %>%   # sütun 2'de 
  vline(part = "all", j = 5, border = border_style)       # sütun 5'de

my_table
```

### Yazı tipi ve hizalama {.unnumbered}

**flextable**'daki `align()` fonksiyonunu kullanarak en soldaki sütun dışındaki tüm sütunlar hastane adlarıyla ortalayarak hizalanabilir.

```{r}
my_table <- my_table %>% 
   flextable::align(align = "center", j = c(2:8), part = "all") 
my_table
```

Ek olarak, başlık yazı tipi boyutunu artırabilir ve ardından kalın olarak değiştirebilir. Toplam satırı da kalın olarak değiştirebilir.

```{r}

my_table <-  my_table %>%  
  fontsize(i = 1, size = 12, part = "header") %>%   # başlığın font büyüklüğünü değiştir
  bold(i = 1, bold = TRUE, part = "header") %>%     # başlığın kalınlığını ayarla
  bold(i = 7, bold = TRUE, part = "body")           # toplam satırın kalınlığını ayarla (gövdenin 7. satırı)

my_table

```

`colformat_num()` fonksiyonunu kullanarak orantı sütunlarının yalnızca bir ondalık basamak göstermesi sağlanabilir. Bunun, `round()` fonksiyonuyla veri yönetimi aşamasında da yapılabileceğini unutmayın.

```{r}
my_table <- colformat_num(my_table, j = c(4,7), digits = 1)
my_table
```

### Hücreleri birleştirme {.unnumbered}  

Başlık satırındaki hücreler yatay olarak birleştirilebileciği gibi, `merge_at()` kullanılarak ve satırları (`i`) ve sütunu (`j`) belirtilerek hücreler dikey olarak da birleştirebilir. Burada daha fazla yer açmak için "Hastane" ve "Sonucu bilinen toplam vaka" değerleri dikey olarak birleştirilmektedir. 

```{r}
my_table <- my_table %>% 
  merge_at(i = 1:2, j = 1, part = "header") %>% 
  merge_at(i = 1:2, j = 2, part = "header")

my_table
```

### Arka plan rengi {.unnumbered}

Tablonun içeriğini başlıklardan ayırt etmek için ek biçimlendirme eklemek istenebilir. Örneğin, arka plan rengini değiştirme. Bu örnekte tablo gövdesini gri olarak değiştirmekteyiz.

```{r}
my_table <- my_table %>% 
    bg(part = "body", bg = "gray95")  

my_table 
```


<!-- ======================================================= -->
## Koşullu biçimlendirme {  }

Belirli bir kuralı karşılayan bir sütundaki tüm değerler vurgulanabilir. Örneğin, vakaların %55'inden fazlasının öldüğü yer. Ölçütleri `i =` veya `j =` argümanına, önünde bir tilde `~` gelecek şekilde koyulması yeterlidir. Değerler görüntülenen başlığa değil, veri çerçevesindeki sütununa refere edilmelidir. 

```{r}

my_table %>% 
  bg(j = 7, i = ~ Pct_Death >= 55, part = "body", bg = "red") 

```

Veya, ilgilenilen bir hastane gibi belirli bir kriteri karşılayan tüm satır vurgulanabilir. Ölçütlerin tüm sütunlara uygulanabilmesi için sütun (`j`) argümanının kaldırılması yeterlidir.

```{r}

my_table %>% 
  bg(., i= ~ hospital == "Military Hospital", part = "body", bg = "#91c293") 

```

## Bütün kodlar {#tbl_pres_all}  


Aşağıda, yukarıdaki bölümlerdeki bahsi geçen bütün kodlar paylaşılmaktadır.  

```{r}  

border_style = officer::fp_border(color="black", width=1)

pacman::p_load(
  rio,            # içe/dışa aktar
  here,           # dosya yolağı
  flextable,      # HTML tablosu oluştur 
  officer,        # tablolar için yardımcı fonksiyonlar
  tidyverse)      # veri yönetimi, özetlemesi ve görselleştirilmesi

table <- linelist %>% 

  # Hastane sonuç grubu başına özet değerleri al
  ###############################################
  group_by(hospital, outcome) %>%                      # Grup verisi
  summarise(                                           # İlgilenilen göstergelerin yeni özet sütunları oluştur
    N = n(),                                            # Hastane-sonuç grubu başına satır sayısı   
    ct_value = median(ct_blood, na.rm=T)) %>%           # Grup başına medyan CT değeri
  
  # Toplamları ekle
  ############
  bind_rows(                                           # Önceki tabloyu mini toplamlar tablosuyla birleştir
    linelist %>% 
      filter(!is.na(outcome) & hospital != "Missing") %>%
      group_by(outcome) %>%                            # Hastaneye göre değil, yalnızca sonuca göre gruplandır  
      summarise(
        N = n(),                                       # Tüm veri kümesi için satır sayısı    
        ct_value = median(ct_blood, na.rm=T))) %>%     # Tüm veri seti için medyan CT değeri
  
  # Geniş pivotlama ve format
  ########################
  mutate(hospital = replace_na(hospital, "Total")) %>% 
  pivot_wider(                                         # uzundan genişe pivotla
    values_from = c(ct_value, N),                       # yeni değerler ct ve count sütunlarından alınır
    names_from = outcome) %>%                           # yeni sütun adları sonuçlardan alınır
  mutate(                                              # yeni sütun ekle
    N_Known = N_Death + N_Recover,                               # sonucu bilinen satırların sayısı
    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # ölen vakaların yüzdesi (1 ondalık basamağa kadar)
    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # iyileşen vakaların yüzdesi (1 ondalık basamağa kadar)
  select(                                              # Sütunları yeniden sırala
    hospital, N_Known,                                   # Giriş sütunları
    N_Recover, Pct_Recover, ct_value_Recover,            # İyileşen vaka sütunları
    N_Death, Pct_Death, ct_value_Death)  %>%             # Ölen vaka sütunları
  arrange(N_Known) %>%                                 # Satırları en düşükten en yükseğe doğru düzenle (Toplam satırı en altta)

  # formatlama
  ############
  flextable() %>%              # tablo yukarıdan aktarılır
  add_header_row(
    top = TRUE,                # Yeni başlık, mevcut başlık satırının üstüne eklenir
    values = c("Hospital",     # Aşağıdaki her sütun için başlık değerleri
               "Total cases with known outcome", 
               "Recovered",    # Bu, bunun ve sonraki iki sütunun en üst düzey başlığı olacak
               "",
               "",
               "Died",         # Bu, bunun ve sonraki iki sütunun en üst düzey başlığı olacak
               "",             # "Öldü" ile birleştirileceği için boş bırak
               "")) %>% 
    set_header_labels(         # Orijinal başlık satırındaki sütunları yeniden adlandır
      hospital = "", 
      N_Known = "",                  
      N_Recover = "Total",
      Pct_Recover = "% of cases",
      ct_value_Recover = "Median CT values",
      N_Death = "Total",
      Pct_Death = "% of cases",
      ct_value_Death = "Median CT values")  %>% 
  merge_at(i = 1, j = 3:5, part = "header") %>% # Yeni başlık satırında 3 ile 5 arasındaki sütunları yatay olarak birleştir
  merge_at(i = 1, j = 6:8, part = "header") %>%  
  border_remove() %>%  
  theme_booktabs() %>% 
  vline(part = "all", j = 2, border = border_style) %>%   # at column 2 
  vline(part = "all", j = 5, border = border_style) %>%   # at column 5
  merge_at(i = 1:2, j = 1, part = "header") %>% 
  merge_at(i = 1:2, j = 2, part = "header") %>% 
  width(j=1, width = 2.7) %>% 
  width(j=2, width = 1.5) %>% 
  width(j=c(4,5,7,8), width = 1) %>% 
  flextable::align(., align = "center", j = c(2:8), part = "all") %>% 
  bg(., part = "body", bg = "gray95")  %>% 
  bg(., j=c(1:8), i= ~ hospital == "Military Hospital", part = "body", bg = "#91c293") %>% 
  colformat_num(., j = c(4,7), digits = 1) %>%
  bold(i = 1, bold = TRUE, part = "header") %>% 
  bold(i = 7, bold = TRUE, part = "body")

table
```


<!-- ======================================================= -->
## Tablonun kaydedilmesi {  }

Tablonun nihai çıktınıza entegre edilmesinin farklı yolları vardır.

### Tek bir tablonun kaydedilmesi {.unnumbered}

Tabloları Word, PowerPoint, HTML veya görüntü (PNG) dosyaları olarak dışa aktarabilirsiniz. Bunu yapmak için aşağıdaki fonksiyonlardan uygun olanı kullanın:

* `save_as_docx()`  
* `save_as_pptx()`  
* `save_as_image()`  
* `save_as_html()`  

Örnek olarak aşağıda tablo word belgesi olarak kaydedilmektedir. İlk argümanın sözdizimine dikkat edilirse - sadece **flextable*  nesnesinin adı verilebilir, ör. `my_table` veya aşağıda gösterildiği gibi bir "ad" da verilebilir ("my table"). Ad, Word'deki tablonun başlığı olarak görünecektir. Aşağıda ayrıca PNG olarak kaydetme kodu da paylaşılmıştır.

```{r message=FALSE, warning=FALSE, eval=F}
# Tablo başlığını 'my table' olarak düzenle  
save_as_docx("my table" = my_table, path = "file.docx")

save_as_image(my_table, path = "file.png")
```

Bir **flextable** tablosunu resim olarak kaydetmek için `webshot` veya `webshot2` paketlerinin gerekli olduğunu unutmayın. Görüntüler şeffaf arka planla çıkartılabilir.

**flextable** çıktının 'canlı' bir sürümü belge biçiminde görüntülemek istenirse, `print()` fonksiyonu kullanılabilir. `preview = ` argümanı için aşağıdakilerden birini belirtmek gerekmektedir. Belge, bilgisayarınızda tanımlanan yazılım programında "açılır" ancak kaydedilmez. Bu durum, tablonun bir sayfaya / slayda sığıp sığmadığını kontrol etmek için yararlı olabilir böylece onu başka bir belgeye hızlı bir şekilde kopyalayabilirsiniz. Bağımsız değişken önizlemesini “pptx” veya “docx” olarak ayarlayabilirsiniz. 

```{r, eval=F}
print(my_table, preview = "docx") # Word örneği
print(my_table, preview = "pptx") # Powerpoint örneği 
```

### Tabloyu R markdown'da yazdırma {.unnumbered}  

Tablo nesnesi otomatik olarak bir belgenize veya R markdown çıktısına entegre edilebilir. Bu, değişen verilerle tablonun güncellenebileceği ve böylece sayıların yenilenebileceği anlamına gelmektedir.

Bu el kitabının [R Markdown ile Raporlar] sayfasındaki ayrıntılara bakın.

<!-- ======================================================= -->
## Kaynaklar {  }

[Tam **flextable** kitabı](https://ardata-fr.github.io/flextable-book/)
[İlgili Github sayfası](https://davidgohel.github.io/flextable/)  
[Tüm **flextable** fonksiyonlarının bir kılavuzu burada bulunabilir](https://davidgohel.github.io/flextable/reference/index.html)
[Örnek **flextable** tablolardan oluşan bir galeriye buradan erişilebilir](https://ardata-fr.github.io/flextable-gallery/gallery/)  
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/tables_presentation.Rmd-->


# ggplot temelleri {}

```{r, out.width=c('100%', '100%'), fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "ggplot_basics_top.png"))
```

**ggplot2** en popüler veri görselleştirme R paketidir. `ggplot()` fonksiyonu bu paketin merkezindedir ve tüm bu yaklaşım akademik camiada *"ggplot"* olarak; ortaya çıkan grafikler de sevgi dolu bir ifade ile "ggplots" olarak adlandırılır. Bu isimlerdeki "gg", şekilleri oluşturmak için kullanılan "**g**rammar of **g**raphics" (grafiklerin grameri) kalıbının kısaltmasıdır. **ggplot2**, işlevselliğini daha da artıran pek çok tamamlayıcı R paketlerinden yararlanmaktadır.

Sözdizimi, R tabanındaki fonksiyon ve komutlardan önemli ölçüde farklıdır ve öğrenmesi de bununla ilişkili olarak daha zordur. **ggplot2** fonksiyonlarını doğru kullanabilmek için genellikle, kullanıcılar verilerini, **tidyverse**e yüksek düzeyde uyumlu bir şekilde biçimlendirmek gerekir, bu da pek çok paketi birlikte kullanmayı zorunlu kılar.

Bu sayfada **ggplot2** ile çizim yapmanın temellerini ele alacağız. Planlarınızın gerçekten güzel görünmesini sağlayacak öneriler ve gelişmiş teknikler için [ggplot ipuçları] sayfasına bakabilirsiniz.

Kaynaklar bölümünde bağlantılı birkaç kapsamlı **ggplot2** rehberi bulabilirsiniz. Ayrıca RStudio web sitesinden [ggplot ile veri görselleştirme kopya kağıdını](https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf) indirebilirsiniz. Veri görselleştirmelerinizi daha yaratıcı bir şekilde yaparken birkaç ilham almak isterseniz, [R grafiği galerisi](https://www.r-graph-gallery.com/) ve [Data-to-viz](https://www.data-to-viz.com/caveats.html) gibi web sitelerini incelemenizi öneririz.


<!-- ======================================================= -->
## Hazırlık {}

### Paketlerin yüklenmesi {.unnumbered}

Aşağıdaki bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran *ve* kullanım için yükleyen **pacman**'dan `p_load()` fonksiyonunu kullanacağız. R tabanından `library()` ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] sayfasına bakabilirsiniz.

```{r}
pacman::p_load(
  tidyverse,      # ggplot2 ve diğer veri yönetim paketlerini içerir
  rio,            # içe / dışa aktarma
  here,           # dosya lokasyonu bulma
  stringr         # metinle çalışmak için   
)
```

### Verileri içe aktarma {.unnumbered}  

Örnek için Ebola salgınını simüle vakaların veri setini içe aktaracağız. Örneği takip etmek isterseniz, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>"temiz satır listesi" dosyasını indirmek için tıklayın.</a> (.rds dosyası olarak). Verilerinizi **rio** paketinden `import()` işleviyle içe aktarabilirsiniz (.xlsx, .rds, .csv gibi birçok dosya türünü kabul eder - ayrıntılar için [İçe aktarma ve dışa aktarma] sayfasına bakabilirsiniz).

```{r,  echo=F}
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

```

```{r, eval=F}
linelist <- rio::import("linelist_cleaned.rds")
```

Satır listesinin ilk 50 satırı aşağıda gösterilmiştir. "age" (yaş), "wt_kg" (kilo cinsinden ağırlık), "ct_blood" (CT değerleri) ve "days_onset_hosp" (başlangıç tarihi ile hastaneye yatış arasındaki fark) sürekli değişkenlerine odaklanacağız.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


### Genel temizleme {.unnumbered}

Çizilecek verileri hazırlarken, verilerin mümkün olduğunca ["tidy" veri standartlarına](https://r4ds.had.co.nz/tidy-data.html) uygun düzenlemek gerekir. Bunun nasıl yapılacağı, bu el kitabının [Verileri temizleme ve temel işlevler] gibi veri yönetimi sayfalarında ayrıntılı olarak açıklanmıştır.

Verileri çizim için daha iyi hale getirmek için kullanılan bazı basit yollar, verilerin içeriğini görüntüleme için daha iyi hale getirmeyi içerebilir. Bu yolların, veri işlemeyi her zaman daha da kolaylaştıracağı anlamına gelmez. Örneğin:

* Bir karakter sütunundaki `NA` değerlerini "Bilinmeyen" karakter dizesiyle değiştirme  
* Sütunu *faktör* sınıfına çevirerek, değerleri sıralı düzeylere dönüştürme 
* Bazı sütunları, alt çizgi vb. içeren "veri dostu" değerlerinin normal metin veya büyük/küçük harfe dönüştürülmesi (bkz. [Karakterler ve dizeler]) 

İşte bu yolların bazı örnekleri:

```{r, }
# sütunların görüntü sürümünü daha kolay adlara değiştirme
linelist <- linelist %>%
  mutate(
    gender_disp = case_when(gender == "m" ~ "Male",        # m'den Male'e çevirme 
                            gender == "f" ~ "Female",      # f'den Female'e çevirme
                            is.na(gender) ~ "Unknown"),    # NA'dan Unknown'a çevirme
    
    outcome_disp = replace_na(outcome, "Unknown")          # replace NA outcome with "unknown"
  )
```

### Uzun formata döndürme {.unnumbered}

Veri yapısıyla ilgili olarak, **ggplot2** için genellikle verilerimizi *daha uzun* biçimlere döndürmek isteyebiliriz. Bununla ilgili daha fazla bilgiyi [Verilerin Pivotlanması] sayfasında bulabilirsiniz.

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "pivoting", "pivot_longer_new.png"))
```

Örneğin, `satır listesi`ndeki her bir vaka ve ilişkili verilerini "geniş" bir biçimde çizmek istediğimizi varsayalım. Aşağıda, yalnızca `case_id` ve semptomların sütunlarını içeren `symptoms_data` adlı bir mini satır listesi oluşturuyoruz.

```{r}
symptoms_data <- linelist %>% 
  select(c(case_id, fever, chills, cough, aches, vomit))
```

Bu mini-satır listesinin ilk 50 satırı aşağıdaki şekilde görünür - her bir semptomun sütunda nasıl "geniş" olarak biçimlendirildiklerini görebilirsiniz:

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(symptoms_data, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Spesifik semptomları olan vakaların sayısını çizmek istersek, her semptomun belirli bir sütunda olması gerçeğiyle sınırlıyız. Ancak, semptom sütunlarını aşağıdaki gibi daha uzun bir biçime *pivot*layabiliriz:

```{r, }
symptoms_data_long <- symptoms_data %>%    # symptoms_data adlı "mini" satır listesiyle başla
  
  pivot_longer(
    cols = -case_id,                       # case_id dışındaki tüm sütunları döndür (tüm belirti sütunları)
    names_to = "symptom_name",             # semptomları içeren yeni sütun için ad ata
    values_to = "symptom_is_present") %>%  # değerleri tutan yeni sütun için ad ata (evet/hayır)
  
  mutate(symptom_is_present = replace_na(symptom_is_present, "unknown")) # NA'yı "unknown"a dönüştür

```

İşte ilk 50 satır. Burada vakaların 5 satırı olduğunu unutmayın - her olası semptom için bir tane. Yeni `symptom_name` ve `symptom_is_present` sütunları, pivotlamanın sonucudur. Bu formatın diğer işlemler için çok yararlı olmayabileceğini, ancak çizim için faydalı olduğunu unutmayın.

```{r, message=FALSE, echo=F}
DT::datatable(head(symptoms_data_long, 50), rownames = FALSE, filter="top", options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )
```


<!-- ======================================================= -->
## ggplot temelleri {}

**"Grafiklerin grameri" - ggplot2**  

**ggplot2** ile çizim, çizim katmanları ve tasarım öğelerinin birbirinin üzerine "eklenmesi" prensibine dayanır. Her komut bir öncekine bir artı sembolü (`+`) ile eklenir. Sonuç, kaydedilebilen, değiştirilebilen, yazdırılabilen, dışa aktarılabilen vb. çok katmanlı bir çizim nesnesidir.

ggplot nesneleri oldukça karmaşık olabilir, ancak katmanların temel sırası genellikle şöyle görünür:

1. Başta temel `ggplot()` komutuyla başlayın - bu, ggplot fonksiyonunu "açar" ve sonraki işlevlerin "+" ile eklenmesine izin verir. Tipik olarak veri kümesi de bu komutta belirtilir.
2. "Geom" katmanlarını ekleyin - bu işlevler verileri *geometriler* (*şekiller*) olarak görselleştirir, ör. çubuk grafik, çizgi grafiği, dağılım grafiği, histogram (veya bir kombinasyon!) olarak. Bu işlevlerin tümü, önek olarak "geom_" ile başlar.
3. Eksen etiketleri, başlık, yazı tipleri, boyutlar, renk şemaları, göstergeler veya eksen dönüşü gibi tasarım öğelerini çizime ekleyin

Basit bir kod dizilim örneği aşağıdaki gibidir. Her bir bileşeni aşağıdaki bölümlerde açıklayacağız.

```{r, eval=F}
# my_data sütunlarındaki verileri kırmızı noktalar olarak çiz
ggplot(data = my_data)+                   # "my_data" veri kümesini kullan
  geom_point(                             # bir nokta katmanı ekle (noktalar)
    mapping = aes(x = col1, y = col2),    # veri sütununu eksene "haritala"
    color = "red")+                       # geom için diğer özellikler
  labs()+                                 # buraya başlıklar, eksen etiketleri vb. eklenir
  theme()                                 # burada veri olmayan çizim öğelerinin (eksenler, başlık vb.) rengi, yazı tipi, boyutu vb. ayarlanır 
```


## `ggplot()`  

Herhangi bir ggplot2 grafiğinin açılış komutu `ggplot()` şeklindedir. Bu komut, üzerine katmanların ekleneceği boş bir arka plan oluşturur. Bir `+` sembolü ile ek katmanların eklenmesinin yolunu "açar".

Tipik olarak, `ggplot()` komutu, çizim için gerekli olan `data =` argümanını içerir. Bu, grafiğin sonraki katmanları için kullanılacak varsayılan veri kümesini ayarlar. 

Bu komut, kapanış parantezlerinden sonra bir `+` ile bitecektir. Bu, komutu "açık" bırakır. ggplot yalnızca, tam komut sonunda bir `+` *olmadan* son bir katman içerdiğinde yürütülür/görünür.

```{r, eval=F}
# Bu komut, boş bir arka planı olan bir grafik yaratacaktır.
ggplot(data = linelist)
```


## Geomlar

Boş bir arka plan kesinlikle yeterli değildir - verilerden (örneğin çubuk grafikler, histogramlar, dağılım grafikleri, kutu grafikleri) geometriler (şekiller) oluşturmanız gerekir.

Grafikler, ilk `ggplot()` komutuna `geom` katmanları eklenerek yapılır. `Geom` oluşturabilen birçok **ggplot2** fonksiyonu mevcuttur. Bu fonksiyonların her biri `geom_` ile başlar, bu nedenle onlardan genel olarak `geom_XXXX()` olarak bahsedeceğiz. **ggplot2**'de gönüllüler tarafından oluşturulmuş 40'tan fazla geoms bulunmaktadır. Bunları [ggplot2 galerisinden](https://exts.ggplot2.tidyverse.org/gallery/) görüntüleyebilirsiniz. Bazı yaygın geomlar aşağıda listelenmiştir:  

* Histogramlar - `geom_histogram()`  
* Çubuk grafikler - `geom_bar()` yada `geom_col()` (["Çubuk grafikleri" bölümüne bakabilirsiniz](#ggplot_basics_bars))  
* Kutu grafiği - `geom_boxplot()`  
* Noktalar (örn. dağılım grafikleri) - `geom_point()`  
* Çizgi grafikler - `geom_line()` yada `geom_path()`  
* Trend eğrileri - `geom_smooth()`  

Bir çizimde bir veya birden fazla geom görüntüleyebilirsiniz. Her biri önceki **ggplot2** komutlarına bir `+' ile eklenir ve sonraki coğrafi konumlar öncekilerin üzerine yerleştirilecek şekilde sırayla çizilir.


## Verileri grafiğe eşleme {#ggplot_basics_mapping}  

Çoğu geom fonksiyonunda şekilleri oluştururken *ne için kullanacakları* söylenmelidir - bu nedenle fonksiyonda *verilerinizdeki sütunları* ilgili grafikle eşleştirerek eksenini, şeklini, rengini, boyutunu vb. tanımlamalısınız. vb. Çoğu grafik konum verileri için, eşlenmesi gereken *temel* bileşenler x ekseni ve (gerekirse) y eksenidir.

Bu "eşleme", `mapping = ` argümanıyla gerçekleşir. `mapping` için sağladığınız eşlemeler `aes()` fonksiyonunda sarılmalıdır, bu nedenle aşağıda gösterildiği gibi `mapping = aes(x = col1, y = col2)` şeklinde yazabilirsiniz.

Aşağıda, `ggplot()` komutunda veriler `linelist` durumu olarak ayarlanır. `mapping = aes()` argümanında `age` sütunu x eksenine, `wt_kg` sütunu ise y eksenine eşlenir.

`+` işaretinden sonra çizim komutları devam eder. `geom` fonksiyonu olan `geom_point()` ile bir şekil oluşturulur. Bu geom, yukarıdaki `ggplot()` komutundan eşlemeleri *devralır* - eksen-sütun atamalarını bilir ve bu ilişkileri alan üzerinde *noktalar* olarak görselleştirmeye devam eder.

```{r, warning=F, message=F}
ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+
  geom_point()
```

Başka bir örnek olarak, aşağıdaki komutlar aynı verileri, biraz farklı bir eşlemeyi ve farklı bir geom'u kullanır. `geom_histogram()` fonksiyonu, sayımlar y ekseni otomatik olarak oluşturulduğundan, yalnızca x eksenine eşlenmiş bir sütun gerektirir.

```{r, warning=F, message=F}
ggplot(data = linelist, mapping = aes(x = age))+
  geom_histogram()
```


### Grafik estetiği {.unnumbered}  

ggplot terminolojisinde "estetik" konusunun belirli bir anlamı vardır. Burada estetik, *çizilmiş verinin* görsel bir özelliğini ifade eder. Buradaki "estetik" ifadesinin *geomlarda/şekillerde* çizilen verileri de kapsadığını unutmayın - başlıklar, eksen etiketleri, arka plan rengi gibi genel İngilizcede "estetik" kelimesiyle ilişkilendirebileceğiniz çevredeki görüntü değil. ggplot'ta bu ayrıntılara "temalar" denir ve bir `theme()` komutuyla ayarlanır (bkz. [bu bölüm](#ggplot_basics_themes)).

Bu nedenle, çizim nesnesinin *estetiği*, çizilen verilerin renkleri, boyutları, asetatları, yerleşimi vb. olabilir. Tüm geomlar aynı estetik seçeneklere sahip değildir, ancak çoğu geom tarafından kullanılabilir. İşte bazı örnekler: 

* `shape =` Bir noktayı nokta, yıldız, üçgen veya kare olarak `geom_point()` ile gösterme... 
* `fill = ` İç renk (örneğin bir çubuk veya kutu grafiği) 
* `color =` Bir çubuğun, kutu grafiğinin vb. dış çizgisi veya `geom_point()` kullanılıyorsa noktanın rengi
* `size = ` Boyut (ör. çizgi kalınlığı, nokta boyutu) 
* `alpha = ` Şeffaflık (1 = opak, 0 = görünmez)  
* `binwidth = ` Histogram bölmelerinin genişliği 
* `width = ` "Çubuk grafiği" sütunlarının genişliği 
* `linetype =` Çizgi türü (ör. düz, kesikli, noktalı)

Bu çizim nesnesi *estetiğine* değerler iki şekilde atanabilir:

1) Tüm çizilen gözlemlere uygulanacak statik bir değer (ör. ``color = "blue"`) atanması  
2) Her bir gözlemin görüntülenmesi o sütundaki değerine bağlı olacak şekilde bir veri sütununa (ör. `color = hospital`) atanması

<!-- *These non-axis aesthetics can be assigned static values (e.g. `size = 1`) or can be mapped to a column (e.g. `size = age`).* If you want the aesthetic to be assigned a static value, the assignment is placed *outside* the `mapping = aes()`. If you want the aesthetic to be scaled/depend on the value in each row of data, the assignment is made *inside* the `mapping = aes()`.   -->

### Statik bir değer ayarlama {.unnumbered}  

Çizim nesnesine ait estetik değerlerin statik olmasını istiyorsanız, yani - verilerdeki her gözlem için aynı olmasını istiyorsanız, atamasını geom içine, ancak herhangi bir `mapping = aes()` ifadesinin *dışına* yazmalısınız. Bu atamalar `size = 1` veya `color = "blue"` gibi görünebilir. İşte iki örnek:

* İlk örnekte, `mapping = aes()`, `ggplot()` komutunun içindedir ve eksenler, verilerdeki yaş ve ağırlık sütunlarına eşlenir. Çizim estetiğindeki `color = `, `size = ` ve `alpha = `(saydamlık) parametrelerine statik değerler atanır. Anlaşılır olması için, bu, daha sonra çizim estetiği için farklı değerler alacak başka geom'lar ekleyebileceğiniz için 'geom_point()' işlevinde yapılmıştır. 
* İkinci örnekte, histogram yalnızca bir sütuna eşlenen x eksenini gerektirmektedir. `binwidth = `, `color = `, `fill = ` (iç renk) ve `alpha =` parametreleri geom içinde tekrar statik değerlere ayarlanır.

```{r, out.width=c('50%', '50%'), fig.show='hold', warning=F, message=F}
# dağılım grafiği
ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  # veri ve eksen eşlemesini ayarla
  geom_point(color = "darkgreen", size = 0.5, alpha = 0.2)         # statik nokta estetiğini ayarla

# histogram
ggplot(data = linelist, mapping = aes(x = age))+       # veri ve eksenleri ayarla
  geom_histogram(                # histogramı göster
    binwidth = 7,                # kutuların genişliği
    color = "red",               # sınır çizgi rengi
    fill = "blue",               # kutu iç rengi
    alpha = 0.1)                 # kutu şeffaflığı
```


### Sütun değerlerine ölçekleme {.unnumbered}  

Alternatif olarak, çizim nesnesi estetiğini bir sütundaki değerlerle ölçekleyebiliriz. Bu yaklaşımda, estetiğin görüntüsü, o veri sütunundaki gözlemin değerine bağlı olacaktır. Sütun değerleri sürekli ise, o estetik için görüntü ölçeği de (açıklama) sürekli olacaktır. Sütun değerleri ayrıysa, gösterge her bir değeri görüntüleyecek ve çizilen veriler belirgin bir şekilde "gruplanmış" olarak görünecektirr (bu sayfanın [gruplandırma](#ggplotgroups) bölümünde daha fazlasını okuyabilirsiniz).

Bunu başarmak için, estetiği bir *sütun adına* eşlemeniz gerekmektedir (tırnak içinde değil). Bu eşleme, *`mapping  = aes()` fonksiyonu* içinde yapılmalıdır (not: [aşağıda](##ggplot_basics_map_loc) tartışıldığı gibi kodda bu eşleme atamalarını yapabileceğiniz birkaç yer vardır).

İki örnek aşağıda verilmiştir. 

* İlk örnekte, `color =` parametresi (her noktanın) `age` sütununa eşlenir - açıklamada bir ölçek belirir! Şimdilik ölçeğin var olduğuna dikkat etmeniz yeterlidir- sonraki bölümlerde nasıl değiştirileceğini paylaşcağız. 
* İkinci örnekte, iki yeni çizim estetiği de sütunlarla eşlenir (`color = ` ve `size = `), `shape = ` ve `alpha = ` parametreleri herhangi bir `mapping = aes()` fonksiyonu dışındaki statik değerlere eşlenir.

```{r, out.width=c('50%', '50%'), fig.show='hold', warning=F, message=F}
# dağılım grafiği
ggplot(data = linelist,   # veri ayarla
       mapping = aes(     # estetiği sütun değerlerine eşle
         x = age,           # x eksenini yaşa eşle          
         y = wt_kg,         # y eksenini ağırlıkla eşle
         color = age)
       )+     # yaşa göre rengi eşle
  geom_point()         # verileri nokta olarak göster

# dağılım grafiği
ggplot(data = linelist,   # veri ayarla
       mapping = aes(     # estetiği sütun değerlerine eşle
         x = age,           # x eksenini yaşa eşle           
         y = wt_kg,         # y eksenini ağırlıkla eşle
         color = age,       # yaşa göre rengi eşle
         size = age))+      # yaşa göre boyutu eşle
  geom_point(             # verileri nokta olarak göster
    shape = "diamond",      # noktalar elmas olarak görüntülenir
    alpha = 0.3)            # nokta şeffaflığı 30%


```

Not: Eksen atamaları her zaman verilerdeki sütunlara atanır (statik değerlere değil) ve bu her zaman `mapping = aes()` içinde yapılır.

Daha karmaşık grafikler oluştururken çizim katmanlarınızı ve estetiğinizi takip etmek daha da önemli hale gelir - örneğin birden fazla geom içeren grafikler. Aşağıdaki örnekte, `size = ` parametresi iki kez atanır - bir kez `geom_point()` için ve bir kez de `geom_smooth()` için - her ikisi de statik bir değer olarak.

```{r, warning=F, message=F}
ggplot(data = linelist,
       mapping = aes(           # estetiği sütunlara eşle
         x = age,
         y = wt_kg,
         color = age_years)
       ) + 
  geom_point(                   # her veri satırı için puan ekle
    size = 1,
    alpha = 0.5) +  
  geom_smooth(                  # trend eğrisi ekle
    method = "lm",              # linear metodla
    size = 2)                   # çizgi boyutunu (çizgi genişliği) 2 yap
```


### Harita atamaları nerede yapılır {#ggplot_basics_map_loc .unnumbered}

`mapping = aes()` içindeki estetik haritalama, çizim komutlarınızda birden fazla kez yazılabilir. Bu argüman, en üstteki `ggplot()` komutuna ve/veya altındaki her bir geoma yazılabilir. Nüanslar şunları içerir:

* En üstteki `ggplot()` komutunda yapılan eşleme atamaları (`x = ` ve `y = ` öğelerinin nasıl devralındığı gibi atamalar) aşağıdaki herhangi bir geomda varsayılan olarak devralınır.
* Bir geom içinde yapılan eşleme atamaları yalnızca o geom için geçerlidir 

Benzer şekilde, en üstteki `ggplot()` içinde belirtilen `data = ` aşağıdaki herhangi bir geomda varsayılan olarak geçerli olacaktır, ancak her bir geom için farklı veri de belirtebilirsiniz (ancak bu daha zordur).

Böylece, aşağıdaki komutların her biri aynı grafiği oluşturacaktır:

```{r, eval=F, warning=F, message=F}
# Bu komutlar tam olarak aynı grafiği üretecek
ggplot(data = linelist, mapping = aes(x = age))+
  geom_histogram()

ggplot(data = linelist)+
  geom_histogram(mapping = aes(x = age))

ggplot()+
  geom_histogram(data = linelist, mapping = aes(x = age))
```


### Grouplar {#ggplotgroups .unnumbered}  

Verileri kolayca gruplayabilir ve "gruba göre çizebilirsiniz". Aslında, bunu zaten yaptınız!

Bir `mapping = aes()` argümanı içinde "grouping" sütununu uygun çizim estetiğine atayın. Yukarıda, `age` sütununa `size = ` argümanını atadığımızda sürekli değerler kullanarak bunu gösterdik. Ancak bu, ayrık/kategorik sütunlar için aynı şekilde çalışır.

Örneğin, puanların cinsiyete göre görüntülenmesini istiyorsanız, `mapping = aes(color = gender)` değerini ayarlamanız gerekmektedir. Otomatik olarak bir açıklama belirir. Bu atama, en üstteki `ggplot()` komutundaki `mapping = aes()` argümanı içinde yapılabilir (ve geom tarafından miras alınabilir) veya geom içinde ayrı bir `mapping = aes()` içinde ayarlanabilir. Aşağıdaki her iki yaklaşım da aşağıda gösterilmiştir:

```{r, warning=F, message=F}
ggplot(data = linelist,
       mapping = aes(x = age, y = wt_kg, color = gender))+
  geom_point(alpha = 0.5)
```

```{r, eval=F}
# Bu alternatif kod aynı grafiği üretir
ggplot(data = linelist,
       mapping = aes(x = age, y = wt_kg))+
  geom_point(
    mapping = aes(color = gender),
    alpha = 0.5)

```

Geom değerlerine bağlı olarak, verileri gruplamak için farklı argümanlar kullanmanız gerekeceğini unutmayın. `geom_point()` için büyük olasılıkla `color = `, `shape = ` veya `size = ` kullanacaksınız. Oysa `geom_bar()` için `fill = ` argümanını kullanmanız daha olasıdır. Bu sadece geoma ve gruplamaları yansıtmak istediğiniz grafik estetiğine bağlıdır.

Bilginize - verileri gruplandırmanın en temel yolu, yalnızca `mapping = aes()` içindeki `group = ` argümanını kullanmaktır. Ancak, bu tek başına renkleri, dolguyu veya şekilleri değiştirmeyecektir. Ayrıca yeni bir açıklama oluşturacaktır. Yine de veriler gruplandırılmıştır, bu nedenle istatistiksel görüntüler etkilenebilir.

Bir grafikteki grupların sırasını ayarlamak için [ggplot ipuçları] sayfasına veya [Faktörler] sayfasına bakabilirsiniz. Aşağıdaki bölümlerde, sürekli ve kategorik verilerin çizilmesine ilişkin birçok gruplanmış grafik örneği bulunmaktadır.


## Yüzeyler / Küçük katlar {#ggplot_basics_facet}  

Yüzeyler veya "küçük katlar", bir grafiği, veri grubu başına bir panel ("yüzey") olacak şekilde çok panelli bir şekle bölmek için kullanılır. Aynı tip çizim, her biri aynı veri setinin bir alt grubunu kullanarak, birden çok kez oluşturulabilir.

Yüzey ekleme, **ggplot2** ile birlikte gelen bir fonksiyondur, bu nedenle model "panellerinin" açıklamaları ve eksenleri otomatik olarak hizalanır. [ggplot ipuçları] sayfasında tartışılan ve tamamen farklı çizimleri (**cowplot** ve **patchwork**) tek bir şekilde birleştirmek için kullanılan başka paketler de vardır.

Yüzey ekleme, aşağıdaki **ggplot2** işlevlerinden biriyle yapılır:

  1. `facet_wrap()` *tek* değişkenin her düzeyine ait farklı bir panel oluşturmak için kullanılır. Örnek olarak, bir bölgedeki her hastane için farklı bir salgın eğrisi gösteriyor olabilir. Değişken, tanımlanmış başka bir sıralamaya sahip bir faktör olmadığı sürece, yönler alfabetik olarak sıralanır.
  + Yüzeylerin düzenini belirlemek için belirli seçenekleri çağırabilirsiniz, örn. Yönlü grafiklerin düzenlendiği satır veya sütun sayısını kontrol etmek için `nrow = 1` veya `ncol = 1`.
  
  2. `facet_grid()` yüzey düzenlemesine ikinci bir değişken getirmek istediğinizde kullanılır. Burada her bir alan, *iki sütundaki* değerler arasındaki kesişimi gösterir. Örneğin, her bir hastane-yaş grubu için salgın eğrileri, hastaneler üstte (sütunlar) ve yaş grupları yanda (sıralar) bulunur.
  + alt gruplar bir dizilimde gösterildiğinden `nrow` ve `ncol` ile alakalı değildir 

Bu fonksiyonların her biri, yüzey eklemek için sütunları belirten bir söz dizimini kabul eder. Her ikisi de bir tilde `~` işaretinin her iki tarafında birer tane olmak üzere en fazla iki sütunu kabul eder. 

* `facet_wrap()` için genellikle, `facet_wrap(~hospital)` gibi önüne bir tilde (`~`) gelen sütunun adını yazarsınız. Ancak iki sütunu `facet_wrap(outcome ~ hospital)` şeklinde yazabilirsiniz - her benzersiz kombinasyon ayrı bir panelde görüntülenecektir. Ancak bir dizilim halinde düzenlenmeyecektir. Başlıklar birleşik terimleri gösterecek ve bunlar sütunlara karşılık satırları özel olarak göstermeyecektir. Yalnızca bir yönlü değişken sağlıyorsanız, formülün diğer tarafında yer tutucu olarak nokta `.` kullanabilirsiniz - aşağıdaki kod örneklerine bakın.

* `facet_grid()` için formülde bir veya iki sütun da belirtebilirsiniz (dizilim 'satırlar ~ sütunlar' şeklindedir). Yalnızca birini belirtmek istiyorsanız, tildenin diğer tarafına `facet_grid(. ~ hospital)` veya `facet_grid(hospital ~ .)` gibi bir nokta `.` koyabilirsiniz.

Yüzeyler, hızlı bir şekilde karmaşıklaşabilir - yüzey eklemeyi seçtiğiniz her bir değişkenin çok fazla düzeye sahip olmadığından emin olmalısınız. Tesislerin yaş grubuna göre günlük sıtma vaka sayılarından oluşan sıtma veri seti ile ilgili bazı örnekler için [El kitabı ve verileri indirme] sayfasına bakabilirsiniz.

Aşağıda, basit örnek için bazı değişiklikleri içe aktarıp düzenliyoruz:

```{r, , warning=F, message=F}
# Bu veriler, tesis-gününe göre günlük sıtma vakası sayılarıdır.
malaria_data <- import(here("data", "malaria_facility_count_data.rds")) %>%  # içe aktar
  select(-submitted_date, -Province, -newid)                                 # gereksiz sütunları kaldır

```

Sıtma verilerinin ilk 50 satırı aşağıdadır. `malaria_tot` sütununun yanı sıra yaş grubuna göre sayımları içeren sütunlar olduğunu unutmayın (bunlar ikinci, `facet_grid()` örneğinde kullanılacaktır). 

```{r, message=FALSE, echo=F}
DT::datatable(head(malaria_data, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


### `facet_wrap()` {.unnumbered}

`malaria_tot` ve `District` sütunlarına odaklanalım. Şimdilik yaşa özel sayım sütunlarını yok sayabilirsiniz. `malaria_tot` sütununda verilen belirtilen y ekseni yüksekliğinde her gün için bir sütun üreten `geom_col()` ile salgın eğrileri çizeceğiz (veriler zaten günlük sayılardır, bu nedenle `geom_col()` kullanıyoruz - bkz. [aşağıdaki "Çubuk grafiği" bölümü](#ggplot_basics_bars)). 

`facet_wrap()` komutunu eklediğimizde, bir tilde ve sonra yüzey üzerinde sütunu tanımlarız (bu durumda `District`). Yaklaşık işaretinin sol tarafına başka bir sütun yerleştirebilirsiniz, - bu her kombinasyon için bir yüzey oluşturacaktır - ancak bunu bunun yerine `facet_grid()` ile yapmanızı öneririz. Bu kullanım örneğinde, "Bölge"nin her benzersiz değeri için bir yüzey oluşturulur.

```{r, warning=F, message=F}
# Bölgelere göre yüzeyleri olan bir grafik
ggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +
  geom_col(width = 1, fill = "darkred") +       # sayım verilerini sütun olarak çiz
  theme_minimal()+                              # arka plan panellerini basitleştir
  labs(                                         # grafik etiketleri, başlık vb. ekle
    x = "Date of report",
    y = "Malaria cases",
    title = "Malaria cases by district") +
  facet_wrap(~District)                       # yüzeyler oluşturuldu
```

### `facet_grid()` {.unnumbered}  

İki değişkeni çaprazlamak için `facet_grid()` yaklaşımını kullanabiliriz. Diyelim ki `District` verilerini yaşa göre gruplandırmak istiyoruz. Bu verileri ggplot tarafından tercih edilen "long" formatına sokmak için yaş sütunlarında bazı verileri dönüştürmemiz gerekiyor. Yaş gruplarının hepsinin kendine ait sütunları mevcut - biz onları `age_group` a ve `num_cases` adlı sütunlarda toplamak istiyoruz. Bu işlem hakkında daha fazla bilgi için [Pivoting data] sayfasına bakabilirsiniz.

```{r, message=F, warning=F}
malaria_age <- malaria_data %>%
  select(-malaria_tot) %>% 
  pivot_longer(
    cols = c(starts_with("malaria_rdt_")),  # sütunları long formatına çevir
    names_to = "age_group",      # sütun adları yaş grubu olacak
    values_to = "num_cases"      # tek bir sütuna sayılar aktarılacak (num_cases)
  ) %>%
  mutate(
    age_group = str_replace(age_group, "malaria_rdt_", ""),
    age_group = forcats::fct_relevel(age_group, "5-14", after = 1))
```

İlk 50 veri satırı aşağıdaki gibi görünmektedir:

```{r, message=FALSE, echo=F}
DT::datatable(head(malaria_age, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

İki değişkeni `facet_grid()` öğesine ilettiğinizde, en kolay yöntem, x'in satır ve y'nin sütun olduğu formül gösterimini (örneğin `x ~ y`) kullanmak olacaktır. Burada, `age_group` ve `District` sütunlarının her bir kombinasyonunun çizimlerinde `facet_grid()` kullanılımı gösterilmiştir.

```{r, message=F, warning=F}
ggplot(malaria_age, aes(x = data_date, y = num_cases)) +
  geom_col(fill = "darkred", width = 1) +
  theme_minimal()+
  labs(
    x = "Date of report",
    y = "Malaria cases",
    title = "Malaria cases by district and age group"
  ) +
  facet_grid(District ~ age_group)
```

### Serbest veya sabit eksenler {.unnumbered}  

Yüzey düzenlemesi sırasında görüntülenen eksen ölçekleri, varsayılan olarak tüm yüzeylerde aynıdır (sabit). Bu, çapraz karşılaştırma için yararlıyken her zaman uygun format olmayabilir.

`facet_wrap()` veya `facet_grid()` kullanırken, "serbest" eksenleri belirlemek için `scales = "free_y"` argümanını kullanabilir veya panellerin y eksenlerini veri alt kümelerine uygun bir şekilde ölçeklendirmesi için serbest bırakabiliriz. Bu, özellikle alt kategorilerden biri için gerçek sayıların küçük olması ve eğilimlerin görülmesinin zorlaşması durumunda işe yarayabilir. "free_y" yerine, x eksenini serbest kılmak için (örneğin tarihlerde) "free_x" veya her iki eksen için "serbest" yazabiliriz. `facet_grid` fonksiyonunda, aynı satırdaki yüzeyler için y ölçeğinin ve aynı sütundaki yüzeyler için x ölçeğinin aynı olacağına dikkat etmelisiniz.

Yalnızca `facet_grid` kullanıldığı durumlarda, `space = "free_y"` veya `space = "free_x"` argümanlarını ekleyebiliriz. Böylece yüzeyin gerçek yüksekliği veya genişliği, içindeki şeklin değerlerine göre ağırlıklandırılır. Bu, yalnızca `scales = "free"` (y veya x) argümanı mevcutsa çalışır.

```{r, message=FALSE, warning=FALSE}

# Serbest y ekseni
ggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +
  geom_col(width = 1, fill = "darkred") +       # sayım verilerini sütun olarak çiz
  theme_minimal()+                              # arka plan panellerini basitleştir
  labs(                                         # grafik etiketleri, başlık vb. ekle
    x = "Date of report",
    y = "Malaria cases",
    title = "Malaria cases by district - 'free' x and y axes") +
  facet_wrap(~District, scales = "free")        # yüzeyler oluşturuldu
```


<!-- ```{r fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')} -->
<!-- # A) Facet hospitalsation date by hospital, free y axis -->
<!-- ggplot(data = linelist %>% filter(hospital != "Missing"), # filter removes unknown hospital -->
<!--        aes(x = date_hospitalisation ))+ -->
<!--   geom_histogram(binwidth=7) + # Bindwidth = 7 days -->
<!--   labs(title = "A) Histogram with free y axis scales")+ -->
<!--   facet_grid(hospital~., # Facet with hospital as the row  -->
<!--              scales = "free_y") # Free the y scale of each facet -->

<!-- # B) Facet hospitalisation date by hospital, free y axis and vertical spacing -->
<!-- ggplot(data = linelist %>% filter(hospital != "Missing"), # filter removes unknown hospital -->
<!--        aes(x = date_hospitalisation ))+ -->
<!--   geom_histogram(binwidth=7) + # Bindwidth = 7 days -->
<!--   labs(title = "B) Histogram with free y axis scales and spacing")+ -->
<!--   facet_grid(hospital~., # Facet with hospital as the row  -->
<!--              scales = "free_y", # Free the y scale of each facet -->
<!--              space = "free_y") # Free the vertical spacing of each facet to optimise space -->

<!-- ``` -->

### Yüzeylerde faktör düzeyi sırası {.unnumbered}  

Faktör seviyelerinin yüzeyler *içinde* nasıl yeniden sıralanacağını öğrenmek için bu [blog yazısına](https://juliasilge.com/blog/reorder-within/) bakabilirsiniz.

## Grafikleri depolama  

### Grafikleri kaydetme {.unnumbered}

Varsayılan olarak bir `ggplot()` komutunu çalıştırdığınızda, grafik Plots RStudio bölmesinde görüntülenecektir. Ancak, `<-` atama operatörünü kullanarak ve ona bir isim vererek grafiği bir nesne olarak da kaydedebilirsiniz. Bundan sonra, nesne adının kendisi çalıştırılmadıkça grafik yazdırılmayacaktır. Ek olarak, nesne adını `print()` ile sararak da yazdırabilirsiniz, ancak bu bir kerede birden çok grafiği yazdırmak için kullanılan bir *for döngüsü* gibi belirli durumlarda gereklidir (bkz. [Yineleme, döngüler ve listeler] sayfası).

```{r, warning=F, message=F}
# grafiği tanımla
age_by_wt <- ggplot(data = linelist, mapping = aes(x = age_years, y = wt_kg, color = age_years))+
  geom_point(alpha = 0.1)

# yazdır
age_by_wt    
```


### Kayıtlı grafikleri değiştirme {.unnumbered}  

**ggplot2** ile ilgili güzel bir şey de, bir grafiği (yukarıdaki gibi) tanımlayabilmeniz ve ardından buna adından başlayarak yeni katmanlar ekleyebilmenizdir. Orijinal grafiği oluşturan tüm komutları tekrarlamanız gerekmez!

Örneğin, yukarıda tanımlanan `age_by_wt` grafiğini 50 yaş sütununda dikey bir çizgi içerecek şekilde değiştirmek için, sadece bir '+' ile ek katmanlar eklemeye başlarız.  

```{r, warning=F, message=F}
age_by_wt+
  geom_vline(xintercept = 50)
```


### Grafikleri dışa aktarma {.unnumbered}   

**ggplot2**'den `ggsave()` fonksiyonuyla grafikleri dışa kolayca aktarabiliriz. Bunu iki şekilde de yapabiliriz:

* Grafik nesnesinin adını, ardından dosya yolunu ve uzantılı adı belirterek 
  * Örnek: `ggsave(my_plot, here("plots", "my_plot.png"))`  
* Yazdırılan son grafiği kaydetmek için komutu bir dosya yolu ile çalıştırarak 
  * Örnek: `ggsave(here("plots", "my_plot.png"))`  
  
Dosya yolunda dosya uzantısını tanımlayarak; png, pdf, jpeg, tiff, bmp, svg gibi pek çok formatta dışarı aktarabilirsiniz.  

Ayrıca `width = `, `height = ` ve `units = ` ("in", "cm" veya "mm") bağımsız değişkenlerini de tanımlayabilirsiniz. Çizim çözünürlüğü için bir sayı ile `dpi =` argümanını ekleyebilirsiniz (ör. 300). "?ggsave" komutunu girerek veya [çevrimiçi belgeleri](https://ggplot2.tidyverse.org/reference/ggsave.html) okuyarak fonksiyonu daha ayrıntılı inceleyebilirsiniz.

İstediğiniz dosya yolunu sağlamak için `burada()` sözdizimini kullanabileceğinizi unutmayın. Daha fazla bilgi için [İçe ve dışa aktar] sayfasına bakabilirsiniz. 

## Etiketler 

Elbette grafik etiketlerini eklemek veya ayarlamak isteyeceksiniz. Bunlar en kolay şekilde, tıpkı geom'larda olduğu gibi `+` ile grafiğe eklenen 'labs()' fonksiyonu ile düzenlenir.

`labs()` fonksiyonu içinde aşağıdaki argümanları kullanabilirsiniz:

* `x = ` ve `y = ` x ve y ekseni başlığı (etiketler) 
* `title = ` Ana grafik başlığı 
* `subtitle = ` Grafiğin alt başlığı, başlığın altında daha küçük metinle
* `caption = ` Grafik başlığı, varsayılan olarak sağ altta

İşte daha önce yaptığımız, ancak daha güzel etiketlerle bir grafik:

```{r, warning=F, message=F}
age_by_wt <- ggplot(
  data = linelist,   # veriyi belirle
  mapping = aes(     # estetiği sütun değerlerine eşle
         x = age,           # x eksenini yaşa eşle           
         y = wt_kg,         # y eksenini ağırlıkla eşle
         color = age))+     # rengi yaşla eşle
  geom_point()+           # verileri nokta olarak göster
  labs(
    title = "Age and weight distribution",
    subtitle = "Fictional Ebola outbreak, 2014",
    x = "Age in years",
    y = "Weight in kilos",
    color = "Age",
    caption = stringr::str_glue("Data as of {max(linelist$date_hospitalisation, na.rm=T)}"))

age_by_wt
```

Dize metnine dinamik R kodunu yerleştirmek için altyazı atamasında **stringr** paketinden `str_glue()` fonksiyonunu nasıl kullandığımıza dikkat edin. Başlık, ilgili tarihteki maksimum hastane yatış süresini yansıtan "verileri" gösterecektir. Daha fazla bilgiyi [Karakterler ve dizeler] sayfasından okuyabilirsiniz.  

*Açıklama* başlığının belirlenmesine ilişkin bir not: Açıklamalarda birden fazla skalanız olabileceğinden, tek bir "açıklama başlığı" argümanı yoktur. `labs()` içinde, açıklamayı oluşturmak için kullanılan çizim estetiğinde gerekli argümanı kullanarak başlığı tanımlayabilirsiniz. Örneğin, açıklama oluşturmak için yukarıda `color = age` argümanını kullandık. Bu nedenle, `labs()` fonksiyonuna `color = ` argümanını ekler ve istediğimiz açıklama başlığını yazarız (büyük Y ile "Yaş"). Açıklamayı `aes(fill = COLUMN)` ile oluşturursanız, `labs()` içinde bu açıklamanın başlığını ayarlamak için `fill =` yazmak zorundasınız. [ggplot ipuçları] sayfasındaki renk ölçekleriyle ilgili bölüm, açıklamaları düzenleme hakkında daha fazla ayrıntı ve `scales_()` fonksiyonuyla alternatif yaklaşımları içermektedir.


## Temalar {#ggplot_basics_themes} 

**ggplot2**'nin en iyi yanlarından biri, grafik üzerinde sahip olduğunuz kontrol düzeyidir - her şeyi tanımlayabilirsiniz! Yukarıda bahsedilen, veri şekilleri/geometrileri ile ilgili *olmayan* tasarım özellikleri `theme()` fonksiyonu içerisinde düzenlenir. Örneğin, arka plan rengi, kılavuz çizgilerinin varlığı/yokluğu ve metnin yazı tipi/boyutu/renk/hizalaması (başlıklar, alt yazılar, açıklamalar, eksen başlıkları...). Bu düzenlemeler iki yolla yapılabilir:

* Kapsamlı ayarlamalar yapmak için bir [*tam tema*](https://ggplot2.tidyverse.org/reference/ggtheme.html) "theme_()" fonksiyonu kullanma - örn. `theme_classic()`, `theme_minimal()`, `theme_dark()`, `theme_light()` `theme_grey()`, `theme_bw()`
* `theme()` içinde grafiğin her yönünü ayrı ayrı düzenleme


### Tam temalar {.unnumbered}  

Oldukça basit oldukları için, aşağıda tüm tema işlevlerini göstereceğiz ve burada daha fazla açıklamayacağız. `theme()` ile yapılan tüm mikro ayarlamaların, tam bir tema kullanıldıktan *sonra* yapılması gerektiğini unutmamalısınız.

Bunları boş parantez ile yazınız.

```{r, out.width=c('50%', '50%'), fig.show='hold', warning=F, message=F}

ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  
  geom_point(color = "darkgreen", size = 0.5, alpha = 0.2)+
  labs(title = "Theme classic")+
  theme_classic()

ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  
  geom_point(color = "darkgreen", size = 0.5, alpha = 0.2)+
  labs(title = "Theme bw")+
  theme_bw()

ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  
  geom_point(color = "darkgreen", size = 0.5, alpha = 0.2)+
  labs(title = "Theme minimal")+
  theme_minimal()

ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  
  geom_point(color = "darkgreen", size = 0.5, alpha = 0.2)+
  labs(title = "Theme gray")+
  theme_gray()
  


```

### Temayı düzenleme {.unnumbered}  

`theme()` fonksiyonu, her biri grafiğin çok özel bir yönünü düzenleyen pek çok sayıda argüman alabilir. Tüm argümanları ele almamız mümkün değil, ancak onların tamamı geçerli olan genel kalıbı tanımlayacağız. İhtiyacınız olan argüman adını nasıl bulacağınızı göstereceğiz. Bu fonksiyonun temel sözdizimi aşağıdaki gibidir:

1. `theme()` fonksiyonu içinde, düzenlemek istediğiniz grafiğin argüman adını `plot.title = ` olarak yazın.
3. Argümana bir `element_()` fonksiyonu ekleyin
  + Çoğu zaman `element_text()` fonksiyonu kullanılır, ancak sık kullanılan diğerleri de arka plan renkleri için `element_rect()` veya grafik öğelerini kaldırmak için `element_blank()`
4. `element_()` fonksiyonu içinde, istediğiniz ince ayarları yapmak için argümanlar kullanın. 

Biliyoruz, bu açıklama oldukça soyuttu. Daha iyi açıklamak adına bir kaç örnek paylaşacağız.

Aşağıdaki grafiğin oldukça saçma bir örnek olduğunun farkındayız, ancak size grafikleri nasıl ayarlayabileceğinizi göstermekte bize yardımcı olacak.  

* İlk olarak tanımlanan `age_by_wt` grafiğiyle başlayıp `theme_classic()` fonksiyonunu ekliyoruz
* Daha ince ayarlamalar için `theme()` fonksiyonu ve ayarlanacak her grafik öğesi için bir argüman ekleriz.

Argümanları mantıksal bir şekilde düzenlemek güzel olabilir. Aşağıda bir kaçını tanımladık:  

* `legend.position = ` "alt", "üst", "sol" ve "sağ" gibi basit değerleri kabul etmesi bakımından benzersizdir. Ancak genellikle metinle ilgili argümanlar, ayrıntıları `element_text()` *içine* yerleştirmenizi gerektirir.
* `element_text(size = 30)` ile başlık boyutu  
* `element_text(hjust = 0)` ile yazıyı yatay olarak hizalama (sağdan sola)
* Altyazı, `element_text(face = "italic")` ile italik yazılır

```{r, , warning=F, message=F}
age_by_wt + 
  theme_classic()+                                 # önceden tanımlanmış tema ayarlamaları
  theme(
    legend.position = "bottom",                    # açıklamayı aşağıya taşı
    
    plot.title = element_text(size = 30),          # başlığın boyutu 30
    plot.caption = element_text(hjust = 0),        # sola hizalı başlık
    plot.subtitle = element_text(face = "italic"), # italik alt başlık
    
    axis.text.x = element_text(color = "red", size = 15, angle = 90), # yalnızca x ekseni metnini ayarlar
    axis.text.y = element_text(size = 15),         # yalnızca y ekseni metnini ayarlar
    
    axis.title = element_text(size = 20)           # her iki eksen başlığını da ayarlar
    )     
```

Burada özellikle yaygın olan bazı `tema()` argümanları verilmiştir. Değişikliği yalnızca bir eksene uygulamak için ".x" veya ".y" ekini ekleyebilirsiniz. 

`theme()` argümanı                 |Etkilediği yer
-----------------------------------|----------------------------------
`plot.title = element_text()`      |Ana başlık
`plot.subtitle = element_text()`   |Alt başlık
`plot.caption = element_text()`    |Başlık (family, face, color, size, angle, vjust, hjust...) 
`axis.title = element_text()`      |Eksen başlığı (x ve y) (size, face, angle, color...)
`axis.title.x = element_text()`    |X ekseni başlığı (y ekseni için `.y` ekini kullanın)
`axis.text = element_text()`       |Eksen metni (x ve y)
`axis.text.x = element_text()`     |X ekseni metni (y ekseni için `.y` ekini kullanın)  
`axis.ticks = element_blank()`     |Eksen işaretlerini kaldır
`axis.line = element_line()`       |Eksen çizgisi (colour, size, linetype: solid dashed dotted etc)
`strip.text = element_text()`      |Yön şerit metni (colour, face, size, angle...)
`strip.background = element_rect()`|Yön şeridi (fill, colour, size...)  

Daha pek çok tema argümanı mevcuttur! Hepsini nasıl hatırlayabilirim diye endişelenmenize gerek yok - hepsini hatırlamanız imkansız. Neyse ki size yardımcı olacak birkaç araç var:

Tam bir liste içeren [tema değiştirme](https://ggplot2.tidyverse.org/reference/theme.html) hakkındaki **tidyverse** belgeleri.  

<span style="color: darkgreen;">**_İPUCU:_** Konsola 90'dan fazla `theme()` argümanının listesini yazdırmak için **ggplot2** paketinden `theme_get()` fonksiyonunu çalıştırın.</span>  

<span style="color: darkgreen;">**_İPUCU:_** Grafiğin bir öğesini kaldırmak isterseniz, bunu `theme()` aracılığıyla da yapabilirsiniz. Tamamen kaybolması için bir argümana `element_blank()`ı eklemeniz yeterlidir. Açıklamalar için de `legend.position = "none"` argümanını kullanabilirsiniz.</span>  


## Renkler  

Lütfen [ggplot ipuçları sayfasının renk skalalarıyla ilgili bölüme](#ggplot_tips_colors) bakın.


## **ggplot2** içine tünelleme  

Verilerinizi temizlemek ve dönüştürmek için tünelleme metodunu kullandıysanız, dönüştürülmüş bu verileri `ggplot()`a kolayca geçirebilirsiniz.

Veri kümesini fonksiyondan fonksiyona taşıma işlemi, `ggplot()` kullanımında "+" eklenmiş gibi davranacaktır. Bu durumda, otomatik olarak iletilen veri kümesi olarak tanımlandığından, `data = ` argümanını kullanmaya gerek olmadığını unutmayın.

Kodun söz dizimi aşağıdaki gibi görülebilir: 

```{r, warning=F, message=F}
linelist %>%                                                     # satır listesiyle başla
  select(c(case_id, fever, chills, cough, aches, vomit)) %>%     # sütunları seç
  pivot_longer(                                                  # long formatına dönüştür
    cols = -case_id,                                  
    names_to = "symptom_name",
    values_to = "symptom_is_present") %>%
  mutate(                                                        # eksik verileri düzenle
    symptom_is_present = replace_na(symptom_is_present, "unknown")) %>% 
  
  ggplot(                                                        # ggplot'u başlat
    mapping = aes(x = symptom_name, fill = symptom_is_present))+
  geom_bar(position = "fill", col = "black") +                    
  theme_classic() +
  labs(
    x = "Symptom",
    y = "Symptom status (proportion)"
  )
```


## Sürekli verilere ait grafikler

Bu sayfa boyunca, sürekli veri grafiklerine ait birçok örneği zaten gördünüz. Burada bunları kısaca tekrarlayıp birkaç varyasyonu paylaşacağız.

Burada kapsanan görselleştirmeler aşağıda listelenmiştir:

* Bir sürekli değişken için grafikler:
  * **Histogram**, sürekli bir değişkenin dağılımını sunar
  * **Kutu grafiği** 25., 50. ve 75. yüzdelikleri, dağılımın uçlarını ve aykırı değerleri gösterir ([önemli kısıtlamaları öğrenmek için linke tıklaın](https://www.data-to-viz.com/caveat/boxplot.html)).  
  * **Jitter grafiği**, tüm değerleri 'titreyen' noktalar olarak gösterir, böylece ikisi aynı değere sahip olsa bile (çoğunlukla) bütün noktalar görülebilir.
  * **Violin grafiği**, 'kemanın' simetrik genişliğine dayalı sürekli bir değişkenin dağılımını gösterir 
  * **Sina grafiği**, tek tek noktaları ve dağılımı simetrik şekilde (**ggforce** paketi aracılığıyla) gösterir. Jitter ve Violin grafiklerinin bir kombinasyonudur.  
* İki sürekli değişken için **Dağılım grafiği**.
* Üç sürekli değişken için **Isı grafikleri** ([Isı grafikleri] sayfasına bağlantılı)

### Histogramlar {.unnumbered}

Histogramlar çubuk grafikler gibi görünebilir, ancak farklıdır çünkü *sürekli* bir değişkenin dağılımını ölçerler. "Çubuklar" arasında boşluk yoktur ve `geom_histogram()` fonksiyonu için yalnızca bir sütun sağlanır.

Aşağıda, sürekli verileri aralık halinde gruplayan ve değişen yükseklikteki bitişik çubuklarda görüntüleyen **histogram** kodları paylaşılmıştır. Grafik çizimi, `geom_histogram()` kullanılarak yapılır. `geom_histogram()`, `geom_bar()` ve `geom_col()` arasındaki farkı anlamak için ggplot temelleri sayfasının ["Çubuk grafiği" bölümüne](#ggplot_basics_bars) bakabilirsiniz.

Aşağıdaki örnekte vakaların yaş dağılımını göstereceğiz. `mapping = aes()` argümanı içinde, dağılımını görmek istediğiniz sütunu tanımlamanız gerekmektedir. Bu sütunu x veya y eksenine atayabilirsiniz.

Satırlar, sayısal yaşlarına göre "bin"lere atanacak ve bunlar, çubuklarla temsil edilecektir. `bins = ` argümanıyla çubuk sayısını belirtirseniz, kırılma noktaları, histogramın minimum ve maksimum değerleri arasında eşit aralıklarla yerleştirilir. `bins =` argümanı belirtilmemişse, uygun sayıdaki bin değeri tahmin edilir ve çizimden sonra bu aşağıdaki mesaj görüntülenir:

```{r fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}
## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
``` 

`bins =` için bir sayı belirtmek istemiyorsanız, alternatif olarak ilgili eksenin birimlerini `binwidth =` argümanıyla tanımlayabilirsiniz. Aşağıda farklı "bin" sayısı ve genişliklerini gösteren birkaç örnek veriyoruz:

```{r fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}
# A) Normal histogram
ggplot(data = linelist, aes(x = age))+  # x parametresi tanımla
  geom_histogram()+
  labs(title = "A) Default histogram (30 bins)")

# B) Daha çok bin
ggplot(data = linelist, aes(x = age))+  # x parametresi tanımla
  geom_histogram(bins = 50)+
  labs(title = "B) Set to 50 bins")

# C) Daha az "bin"
ggplot(data = linelist, aes(x = age))+  # x parametresi tanımla
  geom_histogram(bins = 5)+
  labs(title = "C) Set to 5 bins")

# D) Çok bin
ggplot(data = linelist, aes(x = age))+  # x parametresi tanımla
  geom_histogram(binwidth = 1)+
  labs(title = "D) binwidth of 1")

```

Düzleştirilmiş oranlar elde etmek için `geom_density()` fonksiyonunu kullanabilirsiniz:

```{r, fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}
# Oran eksenli frekans, düzleştirilmiş
ggplot(data = linelist, mapping = aes(x = age)) +
  geom_density(size = 2, alpha = 0.2)+
  labs(title = "Proportional density")

# Oran ekseni ile yığılmış frekans, düzleştirilmiş
ggplot(data = linelist, mapping = aes(x = age, fill = gender)) +
  geom_density(size = 2, alpha = 0.2, position = "stack")+
  labs(title = "'Stacked' proportional densities")
```

"Yığılmış" bir histogram (sürekli bir veri sütunundan) oluşturmak için aşağıdakilerden birini yapabilirsiniz:

1) 'aes()' fonksiyonu içindeki 'fill = ' argümanına atanmış bir gruplandırma sütununu 'geom_histogram()' fonksiyonuyla birlikte kullanma,
2) Muhtemelen okunması daha kolay olan `geom_freqpoly()` fonksiyonunu kullanma (`binwidth = ` argümanını kullanmaya devam edebilirsiniz),
3) Tüm değerlerin oranlarını görmek için `y = after_stat(yoğunluk)` değerini ayarlama (bu sözdizimini tam olarak kullanın - verileriniz değişmedi). Not: *grup başına* oranları gösterecektir.

Her bir seçenek aşağıda gösterilmiştir (*kodlardaki `color = ` vs `fill = ` kullanımına dikkat edin):

```{r, fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}
# "Yığılmış" histogram
ggplot(data = linelist, mapping = aes(x = age, fill = gender)) +
  geom_histogram(binwidth = 2)+
  labs(title = "'Stacked' histogram")

# Sıklık 
ggplot(data = linelist, mapping = aes(x = age, color = gender)) +
  geom_freqpoly(binwidth = 2, size = 2)+
  labs(title = "Freqpoly")

# Oran eksenli frekans
ggplot(data = linelist, mapping = aes(x = age, y = after_stat(density), color = gender)) +
  geom_freqpoly(binwidth = 5, size = 2)+
  labs(title = "Proportional freqpoly")

# Oran eksenli frekans, düzleştirilmiş
ggplot(data = linelist, mapping = aes(x = age, y = after_stat(density), fill = gender)) +
  geom_density(size = 2, alpha = 0.2)+
  labs(title = "Proportional, smoothed with geom_density()")
```

Biraz eğlenmek istiyorsanız, **ggridges** paketinden ["geom_density_ridges"i deneyebilirsiniz](https://cran.r-project.org/web/packages/ggridges/vignettes/introduction.html) . 

**tidyverse** [geom_histogram() sayfasındaki](https://ggplot2.tidyverse.org/reference/geom_histogram.html) histogramlar hakkında daha fazla bilgi edinebilirsiniz.


### Çubuk grafikleri {.unnumbered}

Çubuk grafikleri yaygındır, ancak önemli kısıtlamalara sahiptir. İlk olarak gerçek dağılımı gizleyebilirler - ör. iki modlu bir dağıtım. Detaylı bilgi için [R grafiği galerisine](https://www.r-graph-gallery.com/boxplot.html) ve bu [data-to-viz makalesine](https://www.data-to-viz.com/caveat/boxplot.html) bakabilirsiniz. Bununla birlikte, çeyrekler arasındaki mesafeyi ve aykırı değerleri güzel bir şekilde gösterirler - böylece dağılımı daha ayrıntılı gösteren diğer grafik türlerinin üzerine eklenebilirler.

Aşağıda size bir kutu grafiğinin çeşitli bileşenlerini hatırlatıyoruz:

```{r, out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "boxplot.png"))
```

Bir çubuk grafiği oluşturmak için `geom_boxplot()` fonksiyonunu kullanırken, genellikle `aes()` içinde yalnızca bir ekseni (x veya y) eşlersiniz. Tanımlanan eksen, grafiklerin yatay mı yoksa dikey mi olduğunu belirler.

Çoğu geomlarda, `color = ` veya `fill = ` gibi bir estetiği `aes()` içindeki bir sütuna eşleyerek grup başına bir çizim oluşturursunuz. Bununla birlikte, çubuk grafiğinde sütunu boş bir eksene (x veya y) atayarak elde edebilirsiniz. Aşağıda, kod örneklerinin ilkinde *tüm* yaş değerlerinin çubuk grafiği kodlanmıştır. İkincisinde ise veri kümesindeki her (eksik olmayan) cinsiyet için bir çubuk grafiği kodlanmıştır. Kaldırılmadığı sürece `NA` (eksik) değerlerin ayrı bir kutu grafiği olarak görüneceğini unutmayın. Bu örnekte, her grafiğin farklı bir renk olması için `outcome` sütununa farklı bir `fill` argümanı tanımladık - ancak rutinde bu gerekli değildir.

```{r fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}
# A) Genel yaş grafiği
ggplot(data = linelist)+  
  geom_boxplot(mapping = aes(y = age))+   # only y axis mapped (not x)
  labs(title = "A) Overall boxplot")

# B) Cinsiyete göre çubuk grafiği
ggplot(data = linelist, mapping = aes(y = age, x = gender, fill = gender)) + 
  geom_boxplot()+                     
  theme(legend.position = "none")+   # remove legend (redundant)
  labs(title = "B) Boxplot by gender")      
```

Bir dağılım grafiğinin ("marjinal" grafikler) kenarına kutu grafiği eklemenin nasıl yapıldığını görmek için [ggplot ipuçları] sayfasına bakabilirsiniz. 


### Violin, jitter ve sina grafikleri {.unnumbered}

Aşağıda, dağılımları göstermek için **violin** (`geom_violin`) ve **jitter grafiklerinin** (`geom_jitter`) nasıl kodlandığı gösterilmiştir. Bu seçenekleri `aes()` içine ekleyerek dolgu veya rengin de veriler tarafından belirlenmesini sağlayabilirsiniz.

```{r fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}


# A) Jitter grafiği
ggplot(data = linelist %>% drop_na(outcome),      # Eksik değerleri kaldır
       mapping = aes(y = age,                     # Sürekli değişken
           x = outcome,                           # Gruplama değişkeni
           color = outcome))+                     # Renk değişkeni
  geom_jitter()+                                  # Jitter grafiği oluştur
  labs(title = "A) jitter plot by gender")     



# B) Violin grafiği
ggplot(data = linelist %>% drop_na(outcome),       # Eksik değerleri kaldır
       mapping = aes(y = age,                      # Sürekli değişken
           x = outcome,                            # Gruplama değişkeni
           fill = outcome))+                       # Dolgu değişkeni (renk)
  geom_violin()+                                   # Violin grafiği oluştur
  labs(title = "B) violin plot by gender")    
```


**ggforce** paketindeki `geom_sina()` fonksiyonunu kullanarak iki grafiği birleştirebilirsiniz. Sina, jitter noktalarını violin grafiği şeklinde çizer. Violin grafiği üzerine eklendiğinde (şeffaflığı düzenlenerek), oluşan yeni grafiğin görsel olarak yorumlanması daha kolay olabilir.

```{r, warning=F, message=F}

# A) Sina grafiği
ggplot(
  data = linelist %>% drop_na(outcome), 
  aes(y = age,           # numerik değişken
      x = outcome)) +    # grup değişkeni
  geom_violin(
    aes(fill = outcome), # dolgu (violin grafiğinin arka planının rengi)
    color = "white",     # beyaz anahat
    alpha = 0.2)+        # şefaflık
  geom_sina(
    size=1,                # jitter noktalarının boyutunu değiştir
    aes(color = outcome))+ # renk (noktaların rengi)
  scale_fill_manual(       # Death/recovery violin grafiği arka planı için dolguyu tanımla
    values = c("Death" = "#bf5300", 
              "Recover" = "#11118c")) + 
  scale_color_manual(      # death/recover noktaları için renkleri tanımla
    values = c("Death" = "#bf5300", 
              "Recover" = "#11118c")) + 
  theme_minimal() +                                # Gri arka planı kaldır
  theme(legend.position = "none") +                # Gereksiz açıklamayı kaldır
  labs(title = "B) violin and sina plot by gender, with extra formatting")      


```


### İki sürekli değişken  {.unnumbered}

Benzer sözdizimini takip ederek, `geom_point()`, bir **dağılım grafiğinde** iki sürekli değişkeni birbirine karşı çizmenize izin verir. Bu, dağılımlarından ziyade gerçek değerleri göstermek için kullanışlıdır. Yaş ve kilonun temel bir dağılım grafiği (A)'da gösterilmektedir. (B)'de, satır listesindeki iki sürekli değişken arasındaki ilişkiyi göstermek için yine `facet_grid()` fonksiyonunu kullanıyoruz.

```{r fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}
# Ağırlık ve yaşın temel dağılım grafiği
ggplot(data = linelist, 
       mapping = aes(y = wt_kg, x = age))+
  geom_point() +
  labs(title = "A) Scatter plot of weight and age")

# Cinsiyete ve Ebola sonucuna göre ağırlık ve yaş dağılım grafiği
ggplot(data = linelist %>% drop_na(gender, outcome), # filtre eksik olmayan cinsiyeti/sonucu korur
       mapping = aes(y = wt_kg, x = age))+
  geom_point() +
  labs(title = "B) Scatter plot of weight and age faceted by gender and outcome")+
  facet_grid(gender ~ outcome) 

```


### Üç sürekli değişken {.unnumbered}  

Bir *ısı grafiği* oluşturmak için `fill = ` argümanını kullanarak üç sürekli değişkeni görüntüleyebilirsiniz. Her "hücrenin" rengi, üçüncü sürekli veri sütununun değerini yansıtacaktır. Daha fazla ayrıntı ve birkaç örnek için [ggplot ipuçları] ve [Isı grafikleri] hakkındaki sayfaya bakabilirsiniz.

R'da 3D grafikler oluşturmanın yolları vardır, ancak uygulamalı epidemiyoloji için bunların yorumlanması genellikle zordur ve bu nedenle karar verme süreçlerinde daha az kullanılırlar. 


## Kategorik verilere ait grafikler

Kategorik veriler karakter değerleri, mantıksal (DOĞRU/YANLIŞ) veya faktör olabilir ([Faktörler] sayfasına bakınız).

### Hazırlık  {.unnumbered}

#### Veri yapısı {.unnumbered}  

Kategorik verileriniz hakkında anlamanız gereken ilk şey, verilerin bir satır listesi gibi ham gözlemler olarak mı yoksa sayıları veya oranları tutan bir özet veya toplu veri çerçevesi olarak mı var olduğudur. Verilerinizin durumu, kullandığınız çizim fonksiyonunu etkiler: 

* Verileriniz gözlem başına bir satır içeren ham gözlemlerse, büyük olasılıkla `geom_bar()` fonksiyonunu kullanacaksınız. 
* Verileriniz zaten sayılar veya oranlar halinde toplanmışsa, büyük olasılıkla 'geom_col()' fonksiyonunu kullanacaksınız.


#### Sütun sınıfı ve değer sıralaması {.unnumbered}  

Bu aşamadan sonra, çizmek istediğiniz sütunların sınıfını incelemelisiniz. Önce R tabanından `class()` ve **janitor** paketinden `tabyl()` fonksiyonuyla `hospital` sütununa bakıyoruz.

```{r}
# Hastane sütununun sınıfını görüntüleyin - bunun bir karakter olduğunu görebiliriz
class(linelist$hospital)

# Hastane sütunundaki değerlere ve oranlara bakın
linelist %>% 
  tabyl(hospital)
```

Hastane adları olduğu ve varsayılan olarak alfabetik olarak sıralandığı için içindeki değerlerin karakter olduğunu görebiliriz. Kırılımları sunarken en son sırada olmasını tercih edeceğimiz 'Other' ve 'Missing' değerleri de mevcuttur. Bu yüzden bu sütunu bir faktöre değiştirip yeniden sıralıyoruz. Konu, [Faktörler] sayfasında daha ayrıntılı olarak ele alınmaktadır.

```{r}
# Faktöre dönüştürün ve seviye sırasını "Other" ve "Missing" en son olacak şekilde tanımlayın
linelist <- linelist %>% 
  mutate(
    hospital = fct_relevel(hospital, 
      "St. Mark's Maternity Hospital (SMMH)",
      "Port Hospital", 
      "Central Hospital",
      "Military Hospital",
      "Other",
      "Missing"))

```


```{r}
levels(linelist$hospital)
```

### `geom_bar()` {#ggplot_basics_bars .unnumbered}  

Çubuk yüksekliğinin (veya yığılmış çubuk bileşenlerinin yüksekliğinin) *verilerdeki ilgili satırların sayısını* yansıtmasını istiyorsanız, `geom_bar()` fonksiyonunu kullanmalısınız. `width = ` çizim estetiği ayarlanmadığı sürece, bu çubukların aralarında boşluklar olacaktır.

* Yalnızca bir eksene sütun atayın (tipik olarak x ekseni). x ve y eksenlerinin her ikisine de sütun tanımlarsanız, `Error: stat_count() can only have an x or y aesthetic.` hatasını alırsınız. 
* `mapping = aes()` içinde bir `fill = ` argümanına sütun ekleyerek yığılmış çubuk grafiği oluşturabilirsiniz.
* Karşı eksen, satır sayısını temsil ettiği için varsayılan olarak "count" olarak adlandırılacaktır. 

Aşağıda, sonucu y eksenine atadık, ancak bu aynı kolaylıkla x ekseni de olabilirdi. Daha uzun karakter değerleriniz varsa, bazen çubukları yana çevirip açıklamayı en alta koymak iyi bir seçenek olabilir. Bu, faktör seviyelerinizin nasıl sıralandığını etkileyebilir - bu durumda, "missing" ve "other" değerlerini en alta koymak için sıralamayı `fct_rev()` ile tersine çeviriyoruz.

```{r, out.width=c('50%', '50%'), fig.show='hold'}
# A) Tüm vakaların çıktıları
ggplot(linelist %>% drop_na(outcome)) + 
  geom_bar(aes(y = fct_rev(hospital)), width = 0.7) +
  theme_minimal()+
  labs(title = "A) Number of cases by hospital",
       y = "Hospital")


# B) Tüm vakaların hastaneye göre çıktıları
ggplot(linelist %>% drop_na(outcome)) + 
  geom_bar(aes(y = fct_rev(hospital), fill = outcome), width = 0.7) +
  theme_minimal()+
  theme(legend.position = "bottom") +
  labs(title = "B) Number of recovered and dead Ebola cases, by hospital",
       y = "Hospital")

```


### `geom_col()` {.unnumbered}  

Çubuk yüksekliğinin (veya yığılmış çubuk bileşenlerinin yüksekliğinin) verilerde bulunan önceden hesaplanmış *değerleri* yansıtmasını istiyorsanız, `geom_col()` fonksiyonunu kullanmalısınız. Bunlar genellikle özet, "toplanmış" sayılar veya oranlardır.

`geom_col()` fonksiyonunda *her iki* eksen için de sütun atamalısınız. Tipik olarak x ekseni sütununuz ayrık verilerden oluşurken y ekseni sütununuz sayısaldır.

Diyelim ki `outcomes` veri setimiz var:  

```{r, echo = F}
outcomes <- linelist %>% 
  drop_na() %>% 
  group_by(outcome) %>% 
  count %>% 
  ungroup() %>% # Grubu çöz, böylece oran toplamın dışında kalsın
  mutate(proportion = n/sum(n)*100) # yüzdeyi hesapla
  
outcomes # Tam tabloyu görüntüle
```

Aşağıda, Ebola hasta sonuçlarının dağılımını gösteren basit bir çubuk grafiği oluşturmak için `geom_col` fonksiyonu kullanılmıştır. `geom_col` fonksiyonunda hem x hem de y tanımlanmalıdır. Burada x kategorik değişkendir ve y "oran"dır.

```{r, fig.height = 3, fig.width=4.5}
# Tüm vakaların çıktıları
ggplot(outcomes) + 
  geom_col(aes(x=outcome, y = proportion)) +
  labs(subtitle = "Number of recovered and dead Ebola cases")

```

Hastanelere göre dağılımları göstermek için tablomuzun daha fazla bilgi içermesi ve "long" formatında olması gerekir. Bu tabloyu `outcome` ve `hospital` birleşik kategorilerinin frekanslarıyla oluşturuyoruz (gruplandırma ipuçları için [Gruplama verileri] sayfasına bakabilirsiniz).

```{r, fig.height = 4, fig.width=6}
outcomes2 <- linelist %>% 
  drop_na(outcome) %>% 
  count(hospital, outcome) %>%  # hastaneye ve sonuca göre sayımları al
  group_by(hospital) %>%        # Oranlar hastane toplamı dışında olacak şekilde gruplandır
  mutate(proportion = n/sum(n)*100) # hastane toplamının oranlarını hesapla

head(outcomes2) # verili göster
```

Daha sonra bazı ek biçimlendirmelerle ggplot'u oluştururuz:

  * **Axis flip**: Hastane isimlerini okuyabilmemiz için ekseni `coord_flip()` fonksiyonu ile değiştirdik.
  * **Columns side-by-side**: Ölüm ve iyileşme çubuklarının yığılması yerine yan yana sunulması için bir `position = "dodge"` argümanı eklendi. Not yığılmış çubuklar varsayılandır.
  * **Column width**: 'Genişlik' tanımlanır, bu nedenle sütunlar mümkün olan tam genişliğin yarısı kadar incelir.
  * **Column order**: 'Other' ve 'Missing' altta olacak şekilde, `scale_x_discrete(limits=rev)` ile kategorilerin sırasını y ekseninde tersine çevrildi. `scale_y_discrete` yerine x kullandığımıza dikkat edin, çünkü hastane `aes()`'in `x` argümanında tanımlanmıştır. (görsel olarak y ekseninde olsa bile). Bunu yapıyoruz çünkü Ggplot, biz tersini söylemedikçe kategorileri geriye doğru sıralamaktadır.
  * **Other details**: Sırasıyla `labs` ve `scale_fill_color` argümanları içine eklenen etiket/başlık ve renkler.
  
```{r, fig.height = 4, fig.width=8}

# Tüm vakaların hastaneye göre çıktıları
ggplot(outcomes2) +  
  geom_col(
    mapping = aes(
      x = proportion,                 # önceden hesaplanmış orantı değerlerini göster
      y = fct_rev(hospital),          # missing/other altta kalması için ters çevir
      fill = outcome),                # sonuca göre yığılmış
    width = 0.5)+                    # daha ince çubuklar (max: 1)
  theme_minimal() +                  # Minimal tema 
  theme(legend.position = "bottom")+
  labs(subtitle = "Number of recovered and dead Ebola cases, by hospital",
       fill = "Outcome",             # açıklama başlığı
       y = "Count",                  # y ekseni başlığı
       x = "Hospital of admission")+ # x ekseni başlığı
  scale_fill_manual(                 # renkleri manuel ekle
    values = c("Death"= "#3B1c8C",
               "Recover" = "#21908D" )) 

```


Oranların ikili olduğuna dikkat edin, bu nedenle 'recover' verilerini bırakıp sadece ölen oranını göstermeyi tercih edebiliriz. Bu sadece örnekleme amaçlıdır.

Tarih verilerinde `geom_col()` fonksiyonunu kullanıyorsanız (örneğin, toplu verilerden bir dış eğri) - çubuklar arasındaki "boşluğu" kaldırmak için `width = ` argümanını ayarlamalısınız. Günlük veri seti kullanılıyorsa `width = 1`. Haftalık ise, `width = 7`. Ayların düzgün bir şekilde gösterilmesi mümkün değildir çünkü her ayın gün sayısı bir diğerinden farklıdır.


### `geom_histogram()` {.unnumbered}  

Histogramlar çubuk grafikler gibi görünebilir, ancak farklıdır çünkü *sürekli* bir değişkenin dağılımını ölçerler. "Çubuklar" arasında boşluk yoktur ve `geom_histogram()` fonksiyonu için yalnızca bir sütun gerekir. Verilerin nasıl gruplanacağını belirtmek için `bin_width = ` ve `breaks = ` gibi histograma özgü argümanlar vardır. Yukarıdaki sürekli verilerle ilgili bölüm ve [Salgın eğrileri] sayfasaında daha detaylı bilgi bulabilirsiniz. 


## Kaynaklar  

Özellikle ggplot ile ilgili çevrimiçi olarak çok miktarda kaynak mevcuttur. Bunlardan bazıları:

* [ggplot2 kopya kağıdı](http://r-statistics.co/ggplot2-cheatsheet.html)
* [başka bir kopya kağıdı](https://biostats.w.uib.no/the-ggplot2-cheat-sheet-by-rstudio/)
* [tidyverse ggplot temelleri sayfası](https://ggplot2.tidyverse.org/reference/)  
* [sürekli değişkenleri çizmek](http://www.sthda.com/english/articles/32-r-graphics-essentials/131-plot-two-continuous-variables-scatter-graph-and-alternatives/)  
* [Veri Bilimi için R'da veri görselleştirme bölümü](https://r4ds.had.co.nz/data-visualisation.html)
* [iletişim için grafikler](https://r4ds.had.co.nz/graphics-for-communication.html)  
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/ggplot_basics.Rmd-->


# ggplot ipuçları {} 

Bu sayfada, ggplot'larınızı keskin ve gösterişli hale getirmek için ipuçlarını ve püf noktalarını ele alacağız. Temel bilgiler için [ggplot temelleri] sayfasına bakabilirsiniz.

Kaynaklar bölümünde bağlantılı birkaç kapsamlı [**ggplot2** eğitimi](https://ggplot2.tidyverse.org/) vardır. Bu [ggplot hatırlatma sayfası ile veri görselleştirmeyi](https://rstudio.com/resources/cheatsheets/) RStudio web sitesinden de indirebilirsiniz. İlham almak için [R grafiği galerisi](https://www.r-graph-gallery.com/) ve [Data-to-viz](https://www.data-to-viz.com/caveats.html) sayfalarını incelemenizi şiddetle tavsiye ederiz.

## Hazırlık {}

### Paketleri yükleme {.unnumbered}

Bu kod parçası, analizler için gereken paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran *ve* kullanım için yükleyen **pacman**'dan 'p_load()' vurgusunu yapıyoruz. R **tabanı**ndan `library()` ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakabilirsiniz.

```{r}
pacman::p_load(
  tidyverse,      # ggplot2 ve diğerlerini içerir
  rio,            # içe / dışa aktar
  here,           # dosyayı bul
  stringr,        # karakterlerle çalışmak   
  scales,         # sayıları çevirmek
  ggrepel,        # akıllıca yerleştirilmiş etiketler
  gghighlight,    # arsanın bir bölümünü vurgula
  RColorBrewer    # renk skalaları
)
```

### Verileri içe aktarma {.unnumbered}

Bu sayfa için, simüle edilmiş bir Ebola salgınından vakaların veri setini içe aktarıyoruz. Takip etmek isterseniz, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>"clean" dosyasını indirmek için tıklayın.</a> (.rds dosyası olarak). **rio** paketinden `import()` fonksiyonuyla verileri içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe aktarma ve dışa aktarma] sayfasına bakabilirsiniz).

```{r,  echo=F}
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

```

```{r, eval=F}
linelist <- rio::import("linelist_cleaned.rds")
```

Satır listesinin ilk 50 satırı aşağıda görüntülenir.

```{r, message=FALSE, echo=F}
# satır listesi verilerini tablo olarak göster
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

## Renk, dolgu, eksen vb. için ölçekler {#ggplot_tips_colors}

**ggplot2**'de, çizilen verilerin estetiği (ör. boyut, renk, şekil, dolgu, çizim ekseni) verilerdeki sütunlarla eşlendiğinde, tam görüntü ilgili "ölçek" komutuyla ayarlanabilir. Bu bölümde bazı yaygın ölçek ayarlamalarını açıklıyoruz.

### Renk şemaları

**ggplot2** ile başlangıçta anlaşılması zor olabilecek bir şey, renk şemalarının kontrolüdür. Bu bölümün noktalar, çubuklar, çizgiler, döşemeler vb. *çizim nesnelerinin* (geomlar/şekiller) rengini tartıştığını unutmayın. Aksesuar metninin, başlıkların veya arka plan renginin rengini ayarlamak için  [ggplot temelleri] sayfasının bölümü olan [Temalar](#ggplot_basics_themes) bölümüne bakınız.

*Arsa nesnelerinin* "rengini" kontrol etmek için, ya `renk = ` estetiğini (*dış* renk) ya da `dolgu = ` estetiğini (*iç* renk) ayarlayacaksınız. Bu modelin bir istisnası, gerçekten yalnızca noktanın rengini (iç ve dış) kontrol eden 'color = ' öğesini kontrol edebileceğiniz 'geom_point()' fonksiyonudur.

Renk veya dolguyu ayarlarken "kırmızı" gibi R tarafından tanınan renk adlarını kullanabilir (bkz. [tam liste](http://sape.inf.usi.ch/quick-reference/ggplot2/color) veya `?colors`) veya "#ff0505"` gibi belirli bir onaltılık renkler kullanılabilir.

```{r, warning=F, message=F}
# histogram - 
ggplot(data = linelist, mapping = aes(x = age))+       # veri ve eksenleri ayarla
  geom_histogram(                # histogram göster
    binwidth = 7,                # kutu genişliği
    color = "red",               # kutu çizgi rengi
    fill = "lightblue")          # kutu iç rengi (dolgu) 
```


[Gggplot temelleri] bölümünde [verileri çizime eşleme](#ggplot_basics_mapping) ile ilgili olarak açıklandığı gibi, 'fill = ' ve 'color = ' gibi estetikler bir 'mapping = aes()' ifadesinin *dışında*  veya birinin *içinde* tanımlanabilir. "aes()" * dışında* ise, atanan değer statik olmalıdır (ör. 'color= "mavi"') ve geom tarafından çizilen *tüm* veriler için geçerli olacaktır. *içeride* ise, estetik, 'renk = hastane"' gibi bir sütuna eşlenmelidir ve ifade, verilerdeki o satırın değerine göre değişecektir. Birkaç örnek:

```{r, out.width=c('50%', '50%'), fig.show='hold', warning=F, message=F}
# Noktalar ve çizgi için statik renk
ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     
  geom_point(color = "purple")+
  geom_vline(xintercept = 50, color = "orange")+
  labs(title = "Static color for points and line")

# Sürekli sütuna eşlenen renk
ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     
  geom_point(mapping = aes(color = temp))+         
  labs(title = "Color mapped to continuous column")

# Ayrık sütuna eşlenen renk
ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     
  geom_point(mapping = aes(color = gender))+         
  labs(title = "Color mapped to discrete column")

# çubuk grafiği, ayrı sütuna doldur, statik değere renk
ggplot(data = linelist, mapping = aes(x = hospital))+     
  geom_bar(mapping = aes(fill = gender), color = "yellow")+         
  labs(title = "Fill mapped to discrete column, static color")

```


### Ölçekler {#ggplot_tips_scales .unnumbered} 

Bir sütunu bir çizim estetiğine eşlediğinizde (örneğin, `x = `, `y = `, `fill = `, `color = `...), grafiğiniz bir ölçek/lejand kazanacaktır. Yukarıda, atanan sütunun sınıfına bağlı olarak ölçeğin sürekli, ayrık, tarih vb. değerlerinin nasıl olabileceğini görün. Sütunlara eşlenmiş birden fazla estetiğiniz varsa, arsanızın birden çok ölçeği olacaktır.

Uygun `scales_()` fonksiyonu ile terazileri kontrol edebilirsiniz. **ggplot()**'un ölçek fonksiyonlarının şu şekilde yazılmış 3 bölümü vardır: `scale_AESTHETIC_METHOD()`.

1) İlk kısım olan `scale_()` düzeltildi.
2) İkinci kısım olan ESTETİK, ölçeği ayarlamak istediğiniz estetik olmalıdır (`_fill_`, `_shape_`, `_color_`, `_size_`, `_alpha_`...) - buradaki seçenekler de '_x_' ve '_y_' içerir.
3) Üçüncü kısım olan YÖNTEM, sütunun sınıfına ve nasıl kontrol etmek istediğine bağlı olarak `_discrete()`, `continuous()`, `_date()`, `_gradient()` veya `_manual()` olacaktır. Başkaları da var, ancak bunlar en sık kullanılanlardır.

Tartı için doğru işlevi kullandığınızdan emin olun! Aksi takdirde, ölçek komutunuz hiçbir şeyi değiştirmiş gibi görünmeyecektir. Birden fazla teraziniz varsa, bunları ayarlamak için birden fazla terazi işlevi kullanabilirsiniz! Örneğin:

### Ölçek değişkenleri {.unnumbered}

Bazı örtüşmeler olsa da, her tür ölçeğin kendi değişkenleri vardır. Fonksiyon değişkeni belgelerini görmek için R konsolunda `?scale_color_discrete` gibi fonksiyonu sorgulayabilirsiniz.

Sürekli ölçekler için, 'seq()' ile bir değerler dizisi sağlamak için 'breaks = ' kullanın (aşağıdaki örnekte gösterildiği gibi 'to = ', 'from = ' ve 'by = ' alın. Eksenlerin etrafındaki dolgu alanını ortadan kaldırmak için "expand= c(0,0)" değerini ayarlayın (bu herhangi bir "_x_" veya "_y_" ölçeğinde kullanılabilir.

Ayrık ölçekler için, seviye görünümünün sırasını `breaks =` ile ve değerlerin nasıl görüntüleneceğini `labels =` değişkeniyle ayarlayabilirsiniz. Bunların her birine bir karakter vektörü sağlayın (aşağıdaki örneğe bakın). Ayrıca, "na.translate = FALSE" ayarını yaparak "NA"yı kolayca bırakabilirsiniz.

Tarih ölçeklerinin nüansları, [Salgın eğrileri] sayfasında daha kapsamlı bir şekilde ele alınmaktadır.


### Manuel ayarlamalar {.unnumbered}

En kullanışlı püf noktalardan biri, renkleri açıkça istediğiniz gibi atamak için "manuel" ölçekleme fonksiyonlarını kullanmaktır. Bunlar, "scale_xxx_manual()" sözdizimine sahiptir(ör. "scale_colour_manual()" veya "scale_fill_manual()"). Aşağıdaki bağımsız değişkenlerin her biri aşağıdaki kod örneğinde gösterilmiştir.

* `values =` değişkeniyle veri değerlerine renkler atayın
* 'NA' için 'na.value = ' ile bir renk belirtin
* Göstergede değerlerin nasıl *yazılacağını* `labels = ` değişkeni ile değiştirin
* Gösterge başlığını `name = ` ile değiştirin


Aşağıda, bir çubuk grafiği oluşturuyoruz ve varsayılan olarak nasıl göründüğünü gösteriyoruz ve ardından üç ölçek ayarlıyoruz - sürekli y ekseni ölçeği, ayrık x ekseni ölçeği ve dolgunun manuel olarak ayarlanması (iç çubuk rengi).


```{r, warning=F, message=F}
# TEMEL - ölçek ayarı yok
ggplot(data = linelist)+
  geom_bar(mapping = aes(x = outcome, fill = gender))+
  labs(title = "Baseline - no scale adjustments")

# AYARLANAN ÖLÇEKLER
ggplot(data = linelist)+
  
  geom_bar(mapping = aes(x = outcome, fill = gender), color = "black")+
  
  theme_minimal()+                   # arka planı basitleştir
  
  scale_y_continuous(                # y ekseni için sürekli ölçek (sayılar)
    expand = c(0,0),                 # dolgu yok
    breaks = seq(from = 0,
                 to = 3000,
                 by = 500))+
  
  scale_x_discrete(                   # x ekseni için ayrık ölçek (cinsiyet)
    expand = c(0,0),                  # dolgu yok
    drop = FALSE,                     # tüm faktör seviyelerini göster (verilerde olmasa bile)
    na.translate = FALSE,             # Boş sonuçlarını grafikten kaldır
    labels = c("Died", "Recovered"))+ # Değerlerin gösterimini değiştir
    
  
  scale_fill_manual(                  # Dolguyu manuel olarak belirtin (çubuk iç rengi)
    values = c("m" = "violetred",     # renk atamak için verilerdeki referans değerleri
               "f" = "aquamarine"),
    labels = c("m" = "Male",          # lejandı yeniden etiketleyin (hataları önlemek için "=" atamasını kullanın)
              "f" = "Female",
              "Missing"),
    name = "Gender",                  # lejand başlığı
    na.value = "grey"                 # eksik değerler için bir renk atama
  )+
  labs(title = "Adjustment of scales") # Doldurma açıklamasının başlığını ayarlayın
```

### Sürekli eksen ölçekleri {.unnumbered}

Veriler çizim eksenlerine eşlendiğinde, bunlar da ölçek komutlarıyla ayarlanabilir. Yaygın bir örnek, sürekli veriler içeren bir sütuna eşlenen bir eksenin (ör. y ekseni) görüntüsünü ayarlamaktır.

`scale_y_continuous()` kullanarak ggplot'taki değerlerin kesintilerini veya gösterimini ayarlamak isteyebiliriz. Yukarıda belirtildiği gibi, ölçek boyunca "kesmeler" olarak hizmet edecek bir değerler dizisi sağlamak için "kesmeler =" bağımsız değişkenini kullanın. Bunlar sayıların görüntüleneceği değerlerdir. Bu bağımsız değişkene, istenen kesme değerlerini içeren bir "c()" vektörü sağlayabilir veya R tabanı fonksiyonu "seq()" kullanarak düzenli bir sayı dizisi sağlayabilirsiniz. Bu 'seq()' fonksiyonu 'to = ', 'from = ' ve 'by = ' kabul eder.

```{r, warning=F, message=F, out.width=c('50%', '50%'), fig.show='hold'}
# TEMEL - ölçek ayarı yok
ggplot(data = linelist)+
  geom_bar(mapping = aes(x = outcome, fill = gender))+
  labs(title = "Baseline - no scale adjustments")


ggplot(data = linelist)+
  geom_bar(mapping = aes(x = outcome, fill = gender))+
  scale_y_continuous(
    breaks = seq(
      from = 0,
      to = 3000,
      by = 100)
  )+
  labs(title = "Adjusted y-axis breaks")

```



#### Yüzdeleri göster {.unnumbered}

Orijinal veri değerleriniz oranlarsa, aşağıda gösterildiği gibi ölçekler komutunuzda `labels = scales::percent` sağlayarak bunları kolayca "%" ile yüzdeler olarak görüntüleyebilirsiniz.

Bir alternatif, değerleri karaktere dönüştürmek ve sona "%" karakteri eklemek olsa da, verileriniz artık sürekli sayısal değerler olmayacağından bu yaklaşım sorunlara yol açacaktır.


```{r, warning=F, message=F, out.width=c('50%', '50%'), fig.show='hold'}
# Orjinal y ekseni oranları
#############################
linelist %>%                                   # satır listesi ile başlama
  group_by(hospital) %>%                       # veriyi hastaneye göre gruplandırma
  summarise(                                   # özet kolonlar oluşturma
    n = n(),                                     # gruptaki toplam satır sayısı
    deaths = sum(outcome == "Death", na.rm=T),   # gruptaki ölüm sayısı
    prop_death = deaths/n) %>%                   # gruptaki ölüm oranı
  ggplot(                                      # çizime başlama
    mapping = aes(
      x = hospital,
      y = prop_death))+ 
  geom_col()+
  theme_minimal()+
  labs(title = "Display y-axis original proportions")



# Y ekseni oranlarını yüzdelik olarak gösterme
########################################
linelist %>%         
  group_by(hospital) %>% 
  summarise(
    n = n(),
    deaths = sum(outcome == "Death", na.rm=T),
    prop_death = deaths/n) %>% 
  ggplot(
    mapping = aes(
      x = hospital,
      y = prop_death))+
  geom_col()+
  theme_minimal()+
  labs(title = "Display y-axis as percents (%)")+
  scale_y_continuous(
    labels = scales::percent                   
  )

```

#### Logaritmik ölçeği {.unnumbered}

Sürekli bir ekseni logaritmik ölçeğine dönüştürmek için, ölçek komutuna `trans = "log2"` ekleyin. Örnek olarak, ilgili 'preparedness_index' ve kümülatif vaka değerleri ile bölgelerin bir veri çerçevesini oluşturuyoruz.

```{r}
plot_data <- data.frame(
  region = c("A", "B", "C", "D", "E", "F", "G", "H", "I"),
  preparedness_index = c(8.8, 7.5, 3.4, 3.6, 2.1, 7.9, 7.0, 5.6, 1.0),
  cases_cumulative = c(15, 45, 80, 20, 21, 7, 51, 30, 1442)
)

plot_data
```

"I" bölgesi için kümülatif vakalar, diğer tüm bölgelerden çarpıcı biçimde daha fazladır. Bunun gibi durumlarda, okuyucunun daha az kümülatif vaka ile bölgeler arasındaki farklılıkları görebilmesi için bir logaritmik ölçeği kullanarak y eksenini görüntülemeyi seçebilirsiniz.

```{r, warning=F, message=F, out.width=c('50%', '50%'), fig.show='hold'}
# Orijinal y ekseni
preparedness_plot <- ggplot(data = plot_data,  
       mapping = aes(
         x = preparedness_index,
         y = cases_cumulative))+
  geom_point(size = 2)+            # her bölgeye nokta 
  geom_text(
    mapping = aes(label = region),
    vjust = 1.5)+                  # yazı etiketleri ekleme
  theme_minimal()

preparedness_plot                  # orijinal grafiği yazdıe


# dönüştürülmüş y ekseni ile yazdır
preparedness_plot+                   # yukarıda kaydedilen grafik ile başlayın
  scale_y_continuous(trans = "log2") # y ekseni için dönüşüm ekle
```



### Gradyan ölçekleri {.unnumbered}

Dolgu gradyan ölçekleri ek nüanslar içerebilir. Varsayılanlar genellikle oldukça hoştur, ancak değerleri, kesmeleri vb. ayarlamak isteyebilirsiniz.

Sürekli bir renk skalasının nasıl ayarlanacağını göstermek için, vakaların yaşlarını ve kaynak vakalarını içeren [Temaslı izlemi] sayfasından bir veri seti kullanacağız.


```{r, warning=F, message=F}
case_source_relationships <- rio::import(here::here("data", "godata", "relationships_clean.rds")) %>% 
  select(source_age, target_age) 
```

Aşağıda, bir "hücresel" ısı karosu yoğunluk grafiği üretiyoruz. Nasıl olduğunu detaylandırmayacağız (yukarıdaki paragraftaki bağlantıya bakabilirsiniz) ancak renk skalasını nasıl ayarlayabileceğimize odaklanacağız. `stat_density2d()` **ggplot2** fonksiyonu hakkında [buradan](https://ggplot2.tidyverse.org/reference/geom_density_2d.html) daha fazla bilgi edinebilirsiniz. `fill` ölçeğinin nasıl *sürekli* olduğuna dikkat edin. 

```{r, warn=F, message=F}
trans_matrix <- ggplot(
    data = case_source_relationships,
    mapping = aes(x = source_age, y = target_age))+
  stat_density2d(
    geom = "raster",
    mapping = aes(fill = after_stat(density)),
    contour = FALSE)+
  theme_minimal()
```

Şimdi doldurma ölçeğinde bazı varyasyonlar gösteriyoruz:

```{r, out.width=c('50%', '50%'), fig.show='hold', warning=F, message=F}
trans_matrix
trans_matrix + scale_fill_viridis_c(option = "plasma")
```

Şimdi ölçeğin kırılma noktalarını ayarlamanın bazı örneklerini gösteriyoruz:

* `scale_fill_gradient()` iki rengi kabul eder (yüksek/düşük)
* `scale_fill_gradientn()` herhangi bir uzunluktaki bir renk vektörünü "değerler =" olarak kabul eder (ara değerler eklemlenmiş olacaktır) 
* [`scales::rescale()`](https://www.rdocumentation.org/packages/scales/versions/0.4.1/topics/rescale) renklerin gradyan boyunca nasıl konumlandırılacağını ayarlamak için kullanılır. Konum vektörünüzü 0 ile 1 arasında olacak şekilde yeniden ölçeklendirir.


```{r, out.width=c('50%', '50%'), fig.show='hold', warning=F, message=F}
trans_matrix + 
  scale_fill_gradient(     # Çift taraflı gradyan ölçeği
    low = "aquamarine",    # düşük değer
    high = "purple",       # yüksek değer
    na.value = "grey",     # Boş için değer
    name = "Density")+     # Lejand Başlığı
  labs(title = "Manually specify high/low colors")

# Ölçeklendirmek 3+ renk
trans_matrix + 
  scale_fill_gradientn(    # 3 renkli ölçek (low/mid/high)
    colors = c("blue", "yellow","red") # y dönüş için yeterli
  )+
  labs(title = "3-color scale")

# Ölçek boyunca renklerin yerleşimini ayarlamak için rescale() kullanımı
trans_matrix + 
  scale_fill_gradientn(    # herhangi bir sayıda rengi sağlamak
    colors = c("blue", "yellow","red", "black"),
    values = scales::rescale(c(0, 0.05, 0.07, 0.10, 0.15, 0.20, 0.3, 0.5)) # renkler için konumlar 0 ile 1 arasında yeniden ölçeklenir
    )+
  labs(title = "Colors not evenly positioned")

# dolgu rengini alan kesme değerleri için sınırların kullanılması
trans_matrix + 
  scale_fill_gradientn(    
    colors = c("blue", "yellow","red"),
    limits = c(0, 0.0002))+
  labs(title = "Restrict value limits, resulting in grey space")

```

### Paletler {.unnumbered}

#### Colorbrewer ve Viridis {.unnumbered}
Daha genel olarak, önceden tanımlanmış paletler istiyorsanız, "scale_xxx_brewer" veya "scale_xxx_viridis_y" fonksiyonlarını kullanabilirsiniz.

'brewer' fonksiyonları [colorbrewer.org](colorbrewer.org) paletlerinden çizim yapabilir.

'viridis' fonksiyonları, viridis (renk körü dostu!) paletlerinden alınmıştır, bunlar "hem renkli hem de siyah-beyaz olarak algısal olarak tek biçimli renk haritaları sağlar. Ayrıca, yaygın renk körlüğü biçimlerine sahip izleyiciler tarafından algılanmak üzere tasarlanmıştır. (daha fazlasını [buradan](https://ggplot2.tidyverse.org/reference/scale_viridis.html) ve [buradan](https://bids.github.io/colormap/) okuyabilirsiniz). Fonksiyonun sonunda bunu belirterek paletin ayrık, sürekli veya ikili olup olmadığını tanımlayın (örneğin ayrık 'scale_xxx_viridis_d' dir).

Grafiğinizi bu [renk körlüğü simülatöründe](https://www.color-blindness.com/coblis-color-blindness-simulator/) test etmeniz önerilir. Kırmızı/yeşil renk düzeniniz varsa, bunun yerine soğuk (kırmızı-mavi) bir şema deneyin [burada](https://www.visualisingdata.com/2019/08/five-ways-to-design-for-red-green-colour-blindness/#:~:text=The%20pink%2Dred%20through%20to,green%20hues%20used%20by%20default.)

İşte çeşitli renk şemaları kullanan [ggplot basics] sayfasından bir örnek.

```{r, out.width=c('50%'), fig.show='hold', warning=F, message=F} 
symp_plot <- linelist %>%                                         # satırlistesi ile başla
  select(c(case_id, fever, chills, cough, aches, vomit)) %>%     # sütunları seç
  pivot_longer(                                                  # daha uzun döndür
    cols = -case_id,                                  
    names_to = "symptom_name",
    values_to = "symptom_is_present") %>%
  mutate(                                                        # eksik verileri tamamla
    symptom_is_present = replace_na(symptom_is_present, "unknown")) %>% 
  ggplot(                                                        # ggplot'a başla
    mapping = aes(x = symptom_name, fill = symptom_is_present))+
  geom_bar(position = "fill", col = "black") +                    
  theme_classic() +
  theme(legend.position = "bottom")+
  labs(
    x = "Symptom",
    y = "Symptom status (proportion)"
  )

symp_plot  # kendinden olan renkleri yazdır

#################################
# el ile özelleştirdiğin renkleri yazdır
symp_plot +
  scale_fill_manual(
    values = c("yes" = "black",         # renkleri açıkça tanımla
               "no" = "white",
               "unknown" = "grey"),
    breaks = c("yes", "no", "unknown"), # faktörleri doğru sırala
    name = ""                           # lejandı başlıksız olarak ayarla

  ) 

#################################
# viridis ile ayrık renklerle yazdırın
symp_plot +
  scale_fill_viridis_d(
    breaks = c("yes", "no", "unknown"),
    name = ""
  )


```



<!-- ======================================================= -->
## Ayrık değişkenlerin sırasını değiştirmek {}

Kesikli değişkenlerin göründüğü sırayı değiştirmek, genellikle "ggplot2" grafiklerinde yeni olan kişiler için anlaşılması zordur. Bunu nasıl yapacağınızı anlamak kolaydır, ancak 'ggplot2'nin başlık altında ayrık değişkenleri nasıl ele aldığını anladıktan sonra. Genel olarak konuşursak, ayrı bir değişken kullanılıyorsa, otomatik olarak bir "faktör" türüne dönüştürülür - bu, faktörleri varsayılan olarak alfabetik sıraya göre sıralar. Bunu halletmek için, grafikte görünmesini istediğiniz sırayı yansıtacak şekilde faktör düzeylerini yeniden sıralamanız yeterlidir. "Faktör" nesnelerinin nasıl yeniden sıralanacağı hakkında daha ayrıntılı bilgi için kılavuzun faktör bölümüne bakabilirsiniz.

Yaş gruplarını kullanarak yaygın bir örneğe bakabiliriz - varsayılan olarak 5-9 yaş grubu yaş gruplarının ortasına yerleştirilir (alfanumerik sıra verilir), ancak faktörleri yeniden seviyelendirerek onu 0-4 yaş grubunun arkasına  taşıyabiliriz.

```{r, , warning=F, message=F}
ggplot(
  data = linelist %>% drop_na(age_cat5),                         # age_cat5'in eksik olduğu satırları kaldırın
  mapping = aes(x = fct_relevel(age_cat5, "5-9", after = 1))) +  # faktörü yeniden seviyelendirin

  geom_bar() +
  
  labs(x = "Age group", y = "Number of hospitalisations",
       title = "Total hospitalisations by age group") +
  
  theme_minimal()


```

#### **ggthemr** {.unnnumbered}

Ayrıca **ggthemr** paketini kullanmayı düşünün. Bu paketi [buradaki](https://github.com/Mikata-Project/ggthemr) talimatları kullanarak Github'dan indirebilirsiniz. Estetik açıdan çok hoş paletler sunar, ancak bunların tipik olarak 7 veya 8'den fazla renk istiyorsanız sınırlayıcı olabilecek maksimum sayıda değere sahip olduğunu unutmayın.






## Kontur çizgileri

Kontur grafikleri, birbirini kapsayabilecek birçok noktanız olduğunda ("üst çizim") yardımcı olur. Yukarıda kullanılan durum-kaynak verileri tekrar çizilir, ancak daha basit bir şekilde 'stat_density2d()' ve 'stat_density2d_filled()' kullanılarak - bir topografik harita gibi - ayrı kontur seviyeleri elde edilir. İstatistikler hakkında daha fazla bilgiyi [buradan](https://ggplot2.tidyverse.org/reference/geom_density_2d.html) okuyabilirsiniz.


```{r, out.width=c('50%'), fig.show='hold', warning=F, message=F}
case_source_relationships %>% 
  ggplot(aes(x = source_age, y = target_age))+
  stat_density2d()+
  geom_point()+
  theme_minimal()+
  labs(title = "stat_density2d() + geom_point()")


case_source_relationships %>% 
  ggplot(aes(x = source_age, y = target_age))+
  stat_density2d_filled()+
  theme_minimal()+
  labs(title = "stat_density2d_filled()")

```



## Marjinal dağılımlar

Bir "geom_point()" dağılım grafiğinin kenarlarındaki dağılımları göstermek için, **ggExtra** paketini ve onun "ggMarginal()" fonksiyonunu kullanabilirsiniz. Orijinal ggplot'unuzu bir nesne olarak kaydedin, ardından aşağıda gösterildiği gibi `ggMarginal()` öğesine iletin. İşte temel değikenler:

* `type = ` değerini "histogram", "density" "boxplot", "violin" veya "densigram" olarak belirtmelisiniz.
* Varsayılan olarak, her iki eksen için de marjinal grafikler görünecektir. Yalnızca bir tane istiyorsanız, `margins =` öğesini "x" veya "y" olarak ayarlayabilirsiniz.
* Diğer isteğe bağlı argümanlar arasında `fill = ` (çubuk rengi), `color = ` (çizgi rengi), `size = ` (sınır boyutuna göre grafik boyutu, dolayısıyla daha büyük sayı marjinal grafiği küçültür).
* `xparams = ` ve `yparams =` için eksene özel başka değişkenler sağlayabilirsiniz. Örneğin, aşağıda gösterildiği gibi farklı histogram kutusu boyutlarına sahip olunablir.

Marjinal grafiklerin grupları yansıtmasını sağlayabilirsiniz ("ggplot()" eşleme estetiğinizde "color =" a atanan sütunlar). Bu durumda, "ggMarginal()" bağımsız değişkeni "groupColour =" veya "groupFill =" aşağıda gösterildiği gibi "TRUE" olarak ayarlayın.

Detaylı bilgiye R fonksiyonu `?ggMarginal` veya [Bu gösterim](https://cran.r-project.org/web/packages/ggExtra/vignettes/ggExtra.html), [R Graph Gallery](https://www.r-graph-gallery.com/277-marginal-histogram-for-ggplot2.html) yoluyla erişebilirsiniz.

```{r, message=FALSE, warning=FALSE}
# ggExtra'yı kurun/yükleyin
pacman::p_load(ggExtra)

# Ağırlık ve yaşın temel saçılım grafiği
scatter_plot <- ggplot(data = linelist)+
  geom_point(mapping = aes(y = wt_kg, x = age)) +
  labs(title = "Scatter plot of weight and age")
```

Marjinal histogramlar eklemek için `type = "histogram"` kullanın. Sıralanmış histogramları almak için isteğe bağlı olarak "groupFill = TRUE" ayarını yapabilirsiniz.

```{r, message=FALSE, warning=FALSE}
# histogramlar ile
ggMarginal(
  scatter_plot,                     # marjinal histogramlar ekle
  type = "histogram",               # histogramları belirtmek
  fill = "lightblue",               # çubuk doldurma
  xparams = list(binwidth = 10),    # x ekseni marjinali için diğer parametreler
  yparams = list(binwidth = 5))     # y ekseni marjinal için diğer parametreler
```

Gruplandırılmış/renkli değerlerle marjinal yoğunluk grafiği:

```{r, message=FALSE, warning=FALSE}

# Sonuca göre renklendirilmiş dağılım grafiği
# Sonuç sütunu ggplot'ta renk olarak atanır. (groupFill in ggMarginal TRUE olarak ayarlandı)
scatter_plot_color <- ggplot(data = linelist %>% drop_na(gender))+
  geom_point(mapping = aes(y = wt_kg, x = age, color = gender)) +
  labs(title = "Scatter plot of weight and age")+
  theme(legend.position = "bottom")

ggMarginal(scatter_plot_color, type = "density", groupFill = TRUE)
```

Marjinal grafiğin göreli boyutunu ayarlamak için `size =` değişkenini ayarlayın. Daha küçük sayı, daha büyük bir marjinal grafik yapar. Ayrıca `color=`  ve aşağıda, yalnızca bir eksende görünmesi için "margins =" değişkeni gösterimi ile bir marjinal kutu grafiği verilmiştir:

```{r, message=FALSE, warning=FALSE}
# kutu grafiği ile 
ggMarginal(
  scatter_plot,
  margins = "x",      # sadece x ekseni marjinal grafiğini göster
  type = "boxplot")   
```



<!-- ======================================================= -->
## Akıllı Etiketleme {}

**ggplot2**'de çizimlere metin eklemek de mümkündür. Bununla birlikte, metin etiketlerinin genellikle bir grafikteki veri noktalarıyla çatıştığı, dağınık veya okunması zor görünmelerine neden olan dikkate değer bir sınırlama mevcuttur. Temel pakette bununla başa çıkmanın ideal bir yolu yoktur, ancak bununla uğraşmayı çok basit hale getiren **ggrepel** olarak bilinen bir **ggplot2** eklentisi vardır.

**ggrepel** paketi, "geom_label()" ve "geom_text()" fonksiyonlarının yerine geçen "geom_label_repel()" ve "geom_text_repel()" adlı iki yeni fonksiyon sağlar. Düzgün etiketler üretmek için bunları kullanabilirsiniz. Fonksiyon içinde, "aes()" estetiğini her zaman olduğu gibi eşleştirin, ancak görüntülemek istediğiniz değerleri (örneğin hasta kimliği veya adı vb.) içeren bir sütun adı sağladığınız "label =" bağımsız değişkenini eklemiş olun. Aşağıda gösterildiği gibi `str_glue()` içindeki sütunları ve yeni satırları (`\n`) birleştirerek daha karmaşık etiketler oluşturabilirsiniz.

Birkaç ipucu:

* Her zaman çizgi parçaları çizmek için "min.segment.length = 0" veya onları asla çizmemek için "min.segment.length = Inf" kullanın
* Metin boyutunu ayarlamak için `aes()` dışında `size =` kullanın
* Etiketler ve ilgili noktaları arasındaki itme derecesini değiştirmek için `force =` kullanın (varsayılan 1'dir)
* Etiketin değere göre renklendirilmesi için 'aes()' içine 'fill = ' ekleyin
  * Lejandda bir "a" harfi görünebilir - onu kaldırmak için `guides(fill = guide_legend(override.aes ​​= aes(color = NA)))+` ekleyin

Daha fazlası için ayrıntılı şu eğitime başvurabilirsiniz. [eğitim](https://ggrepel.slowkow.com/articles/examples.html).

```{r, , warning=F, message=F}
pacman::p_load(ggrepel)

linelist %>%                                               # vaka listesi ile başla
  group_by(hospital) %>%                                   # hastaneye göre gruplandır
  summarise(                                               # hastane başına özet değerlerle yeni veri seti oluşturun
    n_cases = n(),                                           # hastane başına vaka sayısı
    delay_mean = round(mean(days_onset_hosp, na.rm=T),1),    # hastane başına ortalama gecikme
  ) %>% 
  ggplot(mapping = aes(x = n_cases, y = delay_mean))+      # veri çerçevesini ggplot'a gönder
  geom_point(size = 2)+                                    # puan ekle
  geom_label_repel(                                        # nokta etiketleri ekle
    mapping = aes(
      label = stringr::str_glue(
        "{hospital}\n{n_cases} cases, {delay_mean} days")  # etiket nasıl görüntülenir
      ), 
    size = 3,                                              # etiketlerdeki metin boyutu
    min.segment.length = 0)+                               # tüm çizgi parçalarını göster              
  labs(                                                    # eksen etiketleri ekle
    title = "Mean delay to admission, by hospital",
    x = "Number of cases",
    y = "Mean delay (days)")
```

Grafiğin her bir "geom" katmanı için farklı "data =" sağlamak üzere standart "ggplot()" sözdizimini kullanarak, veri noktalarının yalnızca bir alt kümesini etiketleyebilirsiniz. Aşağıda, tüm durumlar çizilmiştir, ancak yalnızca birkaçı etiketlenmiştir.

```{r, warning=F, message=FALSE}

ggplot()+
  # Tüm noktalar gri
  geom_point(
    data = linelist,                                   # bu katmana sağlanan tüm veriler
    mapping = aes(x = ht_cm, y = wt_kg),
    color = "grey",
    alpha = 0.5)+                                              # gri ve yarı şeffaf
  
  # Birkaç nokta siyah
  geom_point(
    data = linelist %>% filter(days_onset_hosp > 15),  # bu katmana sağlanan filtrelenmiş veriler
    mapping = aes(x = ht_cm, y = wt_kg),
    alpha = 1)+                                                # varsayılan siyah, şeffaf değil
  
  # birkaç nokta için nokta etiketleri
  geom_label_repel(
    data = linelist %>% filter(days_onset_hosp > 15),  # etiketler için verileri filtreleyin
    mapping = aes(
      x = ht_cm,
      y = wt_kg,
      fill = outcome,                                          # sonuca göre etiket rengi
      label = stringr::str_glue("Delay: {days_onset_hosp}d")), # str_glue() ile oluşturulan etiket
    min.segment.length = 0) +                                  # hepsi için çizgi parçalarını göster
  
  # "a" harfini gösterge kutularından çıkarın
  guides(fill = guide_legend(override.aes = aes(color = NA)))+
  
  # eksen etiketleri
  labs(
    title = "Cases with long delay to admission",
    y = "weight (kg)",
    x = "height(cm)")
```





<!-- ======================================================= -->
## Zaman eksenleri {}

ggplot'ta zaman eksenleriyle çalışmak göz korkutucu görünebilir, ancak birkaç temel fonksiyonla çok kolay hale getirilmiştir. Saat veya tarihle çalışırken, doğru değişkenlerin tarih veya tarih-saat sınıfı olarak biçimlendirildiğinden emin olmanız gerektiğini unutmayın - bu konuda daha fazla bilgi için [Tarihlerle çalışma] sayfasına veya örnekler için [Salgın eğrileri] sayfasına (ggplot bölümü) bakabilirsiniz.

"ggplot2"de tarihlerle çalışmak için en kullanışlı fonksiyon kümesi, ölçeklerdir ('scale_x_date()', 'scale_x_datetime()') ve bunların aynı kökteki y ekseni fonksiyonları). Eksen etiketlerine ne sıklıkla sahip olduğunuzu ve eksen etiketlerinin nasıl biçimlendirileceğini tanımlamanıza olanak tanır. Tarihlerin nasıl biçimlendirileceğini öğrenmek için _tarihlerle çalışma_ bölümüne tekrar bakın! Tarihlerin nasıl görüneceğini belirtmek için "date_breaks" ve "date_labels" bağımsız değişkenlerini kullanabilirsiniz:

  1. "date_breaks", eksen kırılmalarının ne sıklıkta gerçekleşeceğini belirlemenize olanak tanır - buraya bir dize iletebilirsiniz (örneğin ""3 ay"" veya "2 gün"')
  
  2. "date_labels", tarihlerin gösterildiği biçimi tanımlamanıza olanak tanır. Bu bağımsız değişkenlere bir tarih biçimi dizesi iletebilirsiniz (örneğin ""%b-%d-%Y"`):


```{r, , warning=F, message=F}
# mevcut olduğunda başlangıç tarihine göre salgın eğrisi yapın
ggplot(linelist, aes(x = date_onset)) +
  geom_histogram(binwidth = 7) +
  scale_x_date(
    # 1 ayda 1 mola
    date_breaks = "1 months",
    # etiketler aydan sonra tarihi göstermelidir
    date_labels = "%b %d"
  ) +
  theme_classic()

```



<!-- ======================================================= -->
## Vurgulama {}

Bir grafikteki belirli öğelerin vurgulanması, bir değişkenin belirli bir örneğine dikkat çekmenin ve aynı zamanda tüm veri kümesinin dağılımı hakkında bilgi sağlamanın yararlı bir yoludur. Bu, **ggplot2** tabanında kolayca yapılmasa da, bunu yapmanıza yardımcı olabilecek **gghighlight** olarak bilinen harici bir paket vardır. Bunun ggplot sözdizimi içinde kullanımı kolaydır.

**gghighlight** paketi, bu efekti elde etmek için 'gghighlight()' fonksiyonunu kullanır. Kullanmak için, fonksiyona mantıklı bir ifade sağlayın - bunun oldukça esnek sonuçları olabilir, ancak burada satır listemizdeki vakaların yaş dağılımının bir örneğini sonuca göre vurgulayarak göstereceğiz.

```{r, , warning=F, message=F}
# gghighlight yükle
library(gghighlight)

# sonuç değişkeninde NA değerlerini bilinmeyenle değiştirin
linelist <- linelist %>%
  mutate(outcome = replace_na(outcome, "Unknown"))

# yaşa göre tüm vakaların bir histogramını üretmek
ggplot(
  data = linelist,
  mapping = aes(x = age_years, fill = outcome)) +
  geom_histogram() + 
  gghighlight::gghighlight(outcome == "Death")     # Hastanın öldüğü durumları vurgulayın.

```

Bu aynı zamanda faset fonksiyonları ile de iyi çalışır - kullanıcının, faset için geçerli olmayan vurgulanmış arka plan verileriyle faset grafikleri oluşturmasını sağlar! Aşağıda vakaları haftaya göre sayıyor ve hastaneye göre salgın eğrilerini çiziyoruz ("color =" ve "facet_wrap()", "hastane" sütununa ayarlı).

```{r, , warning=F, message=F}

# yaşa göre tüm vakaların bir histogramını üretmek
linelist %>% 
  count(week = lubridate::floor_date(date_hospitalisation, "week"),
        hospital) %>% 
  ggplot()+
  geom_line(aes(x = week, y = n, color = hospital))+
  theme_minimal()+
  gghighlight::gghighlight() +                      # Hastanın öldüğü örnekleri vurgulayın
  facet_wrap(~hospital)                              # sonuca göre yönler yapmak

```





## Birden çok veri kümesini çizme

Aynı çizimdeki birden çok veri kümesinden çizim yapmak için eksenleri düzgün şekilde hizalamanın zor olabileceğini unutmayın. Aşağıdaki stratejilerden birini düşünün:

* Çizimden önce verileri birleştirin ve veri kümesini yansıtan bir sütunla "uzun" biçime dönüştürün
* İki grafiği birleştirmek için **cowplot** veya benzer bir paket kullanın (aşağıya bakın)


<!-- ============================================ ========= -->
## Grafikleri birleştirmek {}

Grafikleri birleştirmek için çok yararlı olan iki paket **cowplot** ve **patchwork**'tür. Bu sayfada, ara sıra **patchwork** kullanımıyla çoğunlukla **cowplot**'a odaklanacağız.

İşte çevrimiçi [cowplot'a giriş](https://cran.r-project.org/web/packages/cowplot/vignettes/introduction.html). Her fonksiyon için daha kapsamlı belgeleri çevrimiçi olarak [buradan](https://www.rdocumentation.org/packages/cowplot/versions/1.1.1) okuyabilirsiniz. Aşağıda en yaygın kullanım durumlarından ve fonksiyonlarından birkaçını ele alacağız.

**cowplot** paketi **ggplot2** ile birlikte çalışır - temel olarak, onu ggplot'ları ve açıklamalarını bileşik rakamlarda düzenlemek ve birleştirmek için kullanırsınız. Ayrıca R  **tabanı** grafiklerini de kabul edebilir.

```{r}
pacman::p_load(
  tidyverse,      # veri işleme ve görselleştirme
  cowplot,        # grafikleri birleştir
  patchwork       # grafikleri birleştir
)
```


Yönlendirme ([ggplot temelleri] sayfasında açıklanmıştır) çizim için uygun bir yaklaşım olsa da, bazen nispeten kısıtlayıcı yaklaşımından istediğiniz sonuçları elde etmek mümkün değildir. Burada, grafikleri daha büyük bir alana yapıştırarak birleştirmeyi seçebilirsiniz. Bunun için çok iyi bilinen üç paket vardır - **cowplot**, **gridExtra** ve **patchwork**. Ancak, bu paketler büyük ölçüde aynı şeyleri yapar, bu nedenle bu bölüm için **cowplot** üzerine odaklanacağız.

### `plot_grid()` {.unnumbered}

**cowplot** paketi oldukça geniş bir fonksiyon yelpazesine sahiptir, ancak bunun en kolay kullanımı `plot_grid()` kullanılarak elde edilebilir. Bu, bir ızgara oluşumunda önceden tanımlanmış grafikleri düzenlemenin etkili bir yoludur. Sıtma veri seti ile başka bir örnek üzerinde çalışabiliriz - burada toplam vakaları bölgeye göre çizebilir ve ayrıca zaman içindeki salgın eğrisini gösterebiliriz.


```{r, , warning=F, message=F}
malaria_data <- rio::import(here::here("data", "malaria_facility_count_data.rds")) 

# ilçeye göre toplam vakaların çubuk grafiği
p1 <- ggplot(malaria_data, aes(x = District, y = malaria_tot)) +
  geom_bar(stat = "identity") +
  labs(
    x = "District",
    y = "Total number of cases",
    title = "Total malaria cases by district"
  ) +
  theme_minimal()

# zamanla salgın eğrisi
p2 <- ggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +
  geom_col(width = 1) +
  labs(
    x = "Date of data submission",
    y =  "number of cases"
  ) +
  theme_minimal()

cowplot::plot_grid(p1, p2,
                  # 1 sütun ve iki satır - üst üste yığılmış
                   ncol = 1,
                   nrow = 2,
                   # üst arsa, saniyenin 2/3'ü kadar uzun
                   rel_heights = c(2, 3))


```




### Göstergeleri birleştir {.unnumbered}

Grafikleriniz aynı göstergelere sahipse, bunları birleştirmek nispeten basittir. Grafikleri birleştirmek için yukarıdaki **cowplot** yaklaşımını kullanın, ancak göstergeyi bunlardan birinden kaldırın (tekrarlanacaktır).

Grafikleriniz farklı göstergelere sahipse, alternatif bir yaklaşım kullanmalısınız:

1) `theme(legend.position = "none")` kullanarak grafiklerinizi göstergeler *olmadan* oluşturun ve kaydedin
2) Aşağıda gösterildiği gibi `get_legend()` kullanarak her bir grafikten göstergeleri ayıklayın - *ancak lejantı gerçekten göstermek için değiştirilmiş grafiklerden lejantları çıkarın*
3) Göstergeleri bir gösterge panelinde birleştirin
4) Grafikler ve göstergeler panelini birleştirin


Örnek için iki grafiği ayrı ayrı gösteriyoruz ve sonra kendi açıklamaları (çirkin ve verimsiz alan kullanımı) gösteren bir ızgarada düzenliyoruz:

```{r, out.width=c('50%'), fig.show='hold', warning=F, message=F}
p1 <- linelist %>% 
  mutate(hospital = recode(hospital, "St. Mark's Maternity Hospital (SMMH)" = "St. Marks")) %>% 
  count(hospital, outcome) %>% 
  ggplot()+
  geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+
  scale_fill_brewer(type = "qual", palette = 4, na.value = "grey")+
  coord_flip()+
  theme_minimal()+
  labs(title = "Cases by outcome")


p2 <- linelist %>% 
  mutate(hospital = recode(hospital, "St. Mark's Maternity Hospital (SMMH)" = "St. Marks")) %>% 
  count(hospital, age_cat) %>% 
  ggplot()+
  geom_col(mapping = aes(x = hospital, y = n, fill = age_cat))+
  scale_fill_brewer(type = "qual", palette = 1, na.value = "grey")+
  coord_flip()+
  theme_minimal()+
  theme(axis.text.y = element_blank())+
  labs(title = "Cases by age")

```

İki grafik, lejantlarını/göstergelerini birleştirmeden "plot_grid()" kullanılarak birleştirildiğinde şöyle görünür:

```{r, warning=F, message=F}
cowplot::plot_grid(p1, p2, rel_widths = c(0.3))
```

Ve şimdi göstergeleri nasıl birleştireceğimizi gösteriyoruz. Esasen yaptığımız şey, her bir grafiği *açıklaması olmadan* tanımlamaktır (`theme(legend.position = "none"`) ve sonra `get_legend()` fonksiyonunu kullanarak her bir grafiğin göstergesini *ayrı ayrı* **cowplot** dan tanımlarız. Kaydedilen çizimden lejandı çıkardığımızda, lejandı tekrar `+' eklememiz gerekiyor, buna yerleşimi belirtmek ("sağ") ve lejandların ve başlıklarının hizalanması için daha küçük ayarlamalar da dahildir. Lejandları dikey olarak bir araya getirin ve ardından iki grafiği yeniden birleştirin.  

```{r, warning=F, message=F}

# Açıklama olmadan grafik 1'i tanımlayın
p1 <- linelist %>% 
  mutate(hospital = recode(hospital, "St. Mark's Maternity Hospital (SMMH)" = "St. Marks")) %>% 
  count(hospital, outcome) %>% 
  ggplot()+
  geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+
  scale_fill_brewer(type = "qual", palette = 4, na.value = "grey")+
  coord_flip()+
  theme_minimal()+
  theme(legend.position = "none")+
  labs(title = "Cases by outcome")


# Açıklama olmadan grafik 2'yi tanımlayın
p2 <- linelist %>% 
  mutate(hospital = recode(hospital, "St. Mark's Maternity Hospital (SMMH)" = "St. Marks")) %>% 
  count(hospital, age_cat) %>% 
  ggplot()+
  geom_col(mapping = aes(x = hospital, y = n, fill = age_cat))+
  scale_fill_brewer(type = "qual", palette = 1, na.value = "grey")+
  coord_flip()+
  theme_minimal()+
  theme(
    legend.position = "none",
    axis.text.y = element_blank(),
    axis.title.y = element_blank()
  )+
  labs(title = "Cases by age")


# p1'den lejandı çıkar (p1'den + lejand)
leg_p1 <- cowplot::get_legend(p1 +
                                theme(legend.position = "right",        # dikey lejandı çıkar
                                      legend.justification = c(0,0.5))+ # böylece lejandlar hizalanır
                                labs(fill = "Outcome"))                 # lejand başlığı
# p2'den lejandı çıkar (p2'den + lejand)
leg_p2 <- cowplot::get_legend(p2 + 
                                theme(legend.position = "right",            
                                      legend.justification = c(0,0.5))+  
                                labs(fill = "Age Category"))             

# lejand hizalaması için boş bir grafik oluşturun
#blank_p <- patchwork::plot_spacer() + theme_void()

# lejand paneli oluşturun, üst üste olabilir (veya yukarıda yorumlanan aralayıcıyı kullanın)
legends <- cowplot::plot_grid(leg_p1, leg_p2, nrow = 2, rel_heights = c(.3, .7))

# iki grafiği ve birleştirilmiş lejand panelini birleştirin
combined <- cowplot::plot_grid(p1, p2, legends, ncol = 3, rel_widths = c(.4, .4, .2))

combined  # yazdır


```

Bu çözüm, [bu gönderiden](https://stackoverflow.com/questions/52060601/ggplot-multiple-legends-arrangement) öğrenildi ve lejandları [bu gönderiden](https://github.com/wilkelab/cowplot/issues/33) hizalamak için küçük bir düzeltme yapıldı.


<span style="color: darkgreen;">**_İPUCU:_** Eğlenceli not - **cowplot**'taki "inek-COW", yaratıcının adından gelir - Claus O. Wilke.</span>


### Ek grafikler {.unnumbered}

**cowplot** kullanarak bir grafiği diğerine yerleştirebilirsiniz. İşte dikkat edilmesi gerekenler:

* Ana grafiği **cowplot**'tan `theme_half_open()` ile tanımlayın; lejandın üstte veya altta olması en iyisi olabilir
* İç metin grafiğini tanımlayın. En iyisi, bir lejanda ihtiyacınız olmayan bir grafiğe sahip olmaktır. Aşağıda gösterildiği gibi `element_blank()` ile çizim teması öğelerini kaldırabilirsiniz.
* Bunları ana çizime ggdraw()' uygulayarak birleştirin, ardından içteki çizime 'draw_plot()' ekleyerek ve koordinatları (sol alt köşenin x ve y), tüm ana grafiğin oranı olarak yüksekliği ve genişliği belirterek birleştirin . 


```{r, out.width=c('100%'), fig.show='hold', warning=F, message=F}

# Ana grafiği tanımla
main_plot <- ggplot(data = linelist)+
  geom_histogram(aes(x = date_onset, fill = hospital))+
  scale_fill_brewer(type = "qual", palette = 1, na.value = "grey")+ 
  theme_half_open()+
  theme(legend.position = "bottom")+
  labs(title = "Epidemic curve and outcomes by hospital")


# İç metin grafiğini tanımlayın
inset_plot <- linelist %>% 
  mutate(hospital = recode(hospital, "St. Mark's Maternity Hospital (SMMH)" = "St. Marks")) %>% 
  count(hospital, outcome) %>% 
  ggplot()+
    geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+
    scale_fill_brewer(type = "qual", palette = 4, na.value = "grey")+
    coord_flip()+
    theme_minimal()+
    theme(legend.position = "none",
          axis.title.y = element_blank())+
    labs(title = "Cases by outcome") 


# Ana öğeyi iç metinle birleştirin
cowplot::ggdraw(main_plot)+
     draw_plot(inset_plot,
               x = .6, y = .55,    #x = .07, y = .65,
               width = .4, height = .4)

```


Bu teknik, bu iki gösterim içinde daha fazla açıklanmıştır:

[Wilke laboratuvarı](https://wilkelab.org/cowplot/articles/drawing_with_on_plots.html)
[draw_plot() belgeleri](https://www.rdocumentation.org/packages/cowplot/versions/1.1.1/topics/draw_plot)




<!-- ============================================ ========= -->
## Çift eksen {}

İkincil bir y ekseni genellikle bir "ggplot2" grafiğine istenen bir ektir. Veri görselleştirme topluluğunda bu tür grafiklerin geçerliliği hakkında güçlü bir tartışma olsa da ve bunlar genellikle önerilmese de, yöneticiniz yine de bunları isteyebilir. Aşağıda, bunları elde etmek için bir yöntem sunuyoruz: iki ayrı grafiği birleştirmek için **cowplot** paketini kullanmak.

Bu yaklaşım, biri solda y ekseni ve diğeri sağda y ekseni olan iki ayrı grafik oluşturmayı içerir. Her ikisi de belirli bir "theme_cowplot()" kullanır ve aynı x eksenine sahip olmalıdır. Daha sonra üçüncü bir komutta iki grafik hizalanır ve üst üste bindirilir. Bu  **cowplot**'un özelliği [sitede](https://wilkelab.org/cowplot/articles/aligning_plots.html) ayrıntılı olarak açıklanmaktadır.

Bu tekniği göstermek için, salgın eğrisini, ölen hastaların haftalık yüzdesinin bir çizgisiyle kaplayacağız. Bu örneği, x eksenindeki tarihlerin hizalanmasını, bir çubuk grafiği başka bir grafikle hizalamaktan daha karmaşık olduğu için kullanıyoruz. Dikkat edilmesi gereken bazı şeyler:

* Salgın eğrisi ve çizgi, çizimden önceki haftalarda toplanır *ve* "tarih_araları" ve "tarih_etiketleri" aynıdır - bunu, üst üste bindirildiklerinde iki grafiğin x-eksenlerinin aynı olması için yaparız.
* y ekseni, 'scale_y_continuous()' un 'position = ' değişkeni ile 2. grafik için sağ tarafa taşınır.
* Her iki grafik de `theme_cowplot()` fonksiyonunu kullanır

[Salgın eğrileri] sayfasında bu tekniğin başka bir örneğine dikkat çekilmiştir - kümülatif insidansı eğri üzerine bindirerek.

** 1. Grafiği Üretmek**
Bu aslında salgın eğrisidir. Sadece kullanımını göstermek için `geom_area()` kullanıyoruz (varsayılan olarak bir çizginin altındaki alan)

```{r, warning=F, message=F}
pacman::p_load(cowplot)            # Cowplot'u yükle/kur

p1 <- linelist %>%                 # grafiği nesne olarak kaydet
     count(
       epiweek = lubridate::floor_date(date_onset, "week")) %>% 
     ggplot()+
          geom_area(aes(x = epiweek, y = n), fill = "grey")+
          scale_x_date(
               date_breaks = "month",
               date_labels = "%b")+
     theme_cowplot()+
     labs(
       y = "Weekly cases"
     )

p1                                      # grafiği göster
```

**2. Grafiği Üretmek**
Ölen vakaların haftalık yüzdesinin bir satırını gösteren ikinci grafiği oluşturun. 

```{r, warning=F, message=F}

p2 <- linelist %>%         # grafiği nesne olarak kaydet
     group_by(
       epiweek = lubridate::floor_date(date_onset, "week")) %>% 
     summarise(
       n = n(),
       pct_death = 100*sum(outcome == "Death", na.rm=T) / n) %>% 
     ggplot(aes(x = epiweek, y = pct_death))+
          geom_line()+
          scale_x_date(
               date_breaks = "month",
               date_labels = "%b")+
          scale_y_continuous(
               position = "right")+
          theme_cowplot()+
          labs(
            x = "Epiweek of symptom onset",
            y = "Weekly percent of deaths",
            title = "Weekly case incidence and percent deaths"
          )

p2     # grafiği göster
```

Şimdi yatay ve dikey hizalamayı ("hv", "h", "v", "none" da olabilir) belirterek, `align_plots()` fonksiyonunu kullanarak grafiği hizalıyoruz. "tblr" ile tüm eksenlerin (üst, alt, sol ve sağ) hizalamasını da belirtiyoruz. Çıktı sınıf listesidir (2 eleman).

Ardından, ggdraw()'ı (**cowplot**'tan) kullanarak ve 'aligned_plots' nesnesinin iki parçasına atıfta bulunarak iki grafiği birlikte çiziyoruz.

```{r, warning=F, message=F}
aligned_plots <- cowplot::align_plots(p1, p2, align="hv", axis="tblr")         # iki grafiği hizalayın ve liste olarak kaydedin
aligned_plotted <- ggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])  # üst üste bindirin ve görsel grafiği kaydedin
aligned_plotted                                                                # bindirilmiş grafikleri yazdır

```



<!-- ### Statistical transformation {.unnumbered}   -->
<!-- Another way to do this to have the second axis be a direct transformation of the secondary axis.  -->

<!-- Differences in axis values will be purely cosmetic - if you want to show two different variables on one graph, with different y-axis scales for each variable, this will not work without some work behind the scenes. To obtain this effect, you will have to transform one of your variables in the data, and apply the same transformation *in reverse* when specifying the axis labels. Based on this, you can either specify the transformation explicitly (e.g. variable a is around 10x as large as variable b) or calculate it in the code (e.g. what is the ratio between the maximum values of each dataset). -->


<!-- The syntax for adding a secondary axis is very straightforward! When calling a `scale_xxx_xxx()` function (e.g. `scale_y_continuous()`), use the `sec.axis` argument to call the `sec_axis()` function. The `trans` argument in this function allows you to specify the label transformation for the axis - provide this in standard tidyverse syntax.  -->

<!-- For example, if we want to show the number of positive RDTs in the malaria dataset for facility 1, showing 0-4 year olds and all cases on chart: -->


<!-- ```{r, , warning=F, message=F} -->

<!-- # take malaria data from facility 1 -->
<!-- malaria_facility_1 <- malaria_data %>% -->
<!--   filter(location_name == "Facility 1") -->

<!-- # calculate the ratio between malaria_rdt_0-4 and malaria_tot  -->

<!-- tf_ratio <- max(malaria_facility_1$malaria_tot, na.rm = T) / max(malaria_facility_1$`malaria_rdt_0-4`, na.rm = T) -->

<!-- # transform the values in the dataset -->

<!-- malaria_facility_1 <- malaria_facility_1 %>% -->
<!--   mutate(malaria_rdt_0_4_tf = `malaria_rdt_0-4` * tf_ratio) -->


<!-- # plot the graph with dual axes -->

<!-- ggplot(malaria_facility_1, aes(x = data_date)) + -->
<!--   geom_line(aes(y = malaria_tot, col = "Total cases")) + -->
<!--   geom_line(aes(y = malaria_rdt_0_4_tf, col = "Cases: 0-4 years old")) + -->
<!--   scale_y_continuous( -->
<!--     name = "Total cases", -->
<!--     sec.axis = sec_axis(trans = ~ . / tf_ratio, name = "Cases: 0-4 years old") -->
<!--   ) + -->
<!--   labs(x = "date of data collection") + -->
<!--   theme_minimal() + -->
<!--   theme(legend.title = element_blank()) -->



<!-- ``` -->






<!-- ## Sparklines   -->

<!-- UNDER CONSTRUCTION   -->
<!-- (perhaps move to Tables for presentation page) -->




## Size yardımcı olacak paketler


**ggplot2**'de gezinmenize yardımcı olmak için özel olarak tasarlanmış gerçekten anlaşılır bazı R paketleri vardır:


### İşaretle ve tıkla **ggplot2** ile **equisse** {.unnumbered}

"Bu eklenti, verilerinizi ggplot2 paketi ile görselleştirerek etkileşimli olarak keşfetmenizi sağlar. Çubuk grafikler, eğriler, dağılım grafikleri, histogramlar, kutu grafiği ve sf nesneleri çizmenize, ardından grafiği dışa aktarmanıza veya grafiği yeniden oluşturmak için kodu almanıza olanak tanır."

Eklentiyi RStudio menüsü veya `esquisse::esquisser()` ile kurun ve başlatın.

[Github sayfasına](https://github.com/dreamRs/esquisse) bakabilirsiniz.

[Belgeler](https://dreamrs.github.io/esquisse/index.html)





## Çeşitli


### Sayısal ekran {.unnumbered}

Çizimden önce bu komutu çalıştırarak bilimsel gösterimi devre dışı bırakabilirsiniz.

```{r, eval=F}
options(scipen=999)
```

Veya **scales** paketinden `number_format()` öğesini aşağıda gösterildiği gibi belirli bir değere veya sütuna uygulayın.

Sayıların nasıl görüntüleneceğini kolayca ayarlamak için **scales** paketindeki fonksiyonları kullanın. Bunlar, veri çerçevenizdeki sütunlara uygulanabilir, ancak örnek olarak tek tek sayılarda gösterilir. 

```{r}
scales::number(6.2e5)
scales::number(1506800.62,  accuracy = 0.1,)
scales::comma(1506800.62, accuracy = 0.01)
scales::comma(1506800.62, accuracy = 0.01,  big.mark = "." , decimal.mark = ",")
scales::percent(0.1)
scales::dollar(56)
scales::scientific(100000)
```

## Kaynaklar

Esinlenme
[ggplot grafik galerisi](https://www.tidyverse.org/blog/2018/07/ggplot2-3-0-0/)

Verilerin sunumu
Avrupa Hastalık Önleme ve Kontrol Merkezi [Sürveyans verilerinin sunumuna ilişkin kılavuzlar](https://ecdc.europa.eu/sites/portal/files/documents/Guidelines%20for%20presentation%20of%20surveillance%20data-final-with-cover-for-we....pdf)


Yönler ve etiketleyiciler
[Yüz şeritleri için etiketleyici kullanma](http://www.cookbook-r.com/Graphs/Facets_(ggplot2)/#modifying-facet-label-text)
[Etiketçiler](https://ggplot2.tidyverse.org/reference/labellers.html)

Faktörlerle sıralamayı ayarlama
[fct_reorder](https://forcats.tidyverse.org/reference/fct_reorder.html)
[fct_inorder](https://forcats.tidyverse.org/reference/fct_inorder.html)
[Bir kutu grafiği nasıl yeniden sıralanır](https://cmdlinetips.com/2019/02/how-to-reorder-a-boxplot-in-r/)
[ggplot2'de bir değişkeni yeniden sıralayın](https://www.r-graph-gallery.com/267-reorder-a-variable-in-ggplot2.html)
[Veri Bilimi için R - Faktörler](https://r4ds.had.co.nz/factors.html)

Göstergeler
[Lejand sırasını ayarlayın](https://stackoverflow.com/questions/38425908/reverse-stacking-order-without-affecting-legend-order-in-ggplot2-bar-charts)

Altyazılar
[Altyazı hizalaması](https://stackoverflow.com/questions/64701500/left-align-ggplot-caption)

Etiketler
[ggrepel](https://ggrepel.slowkow.com/articles/examples.html)

Yardımcı sayfaları
[ggplot2 ile güzel çizim](http://zevross.com/blog/2014/08/04/beauty-plotting-in-r-a-ggplot2-cheatsheet-3/)  




<!-- TO DO - Under construction -->


<!-- * Straight horizontal, vertical, or other line -->

<!-- You can also add straight lines to your plot with `geom_hline()` (horizontal), `geom_vline()` (vertical) or `geom_abline()` (with a specified y intercept and slope) -->


<!-- Using option `label_wrap_gen` in facet_wrap to have multiple strip lines -->
<!-- labels and colors of strips -->

<!-- Axis text vertical adjustment -->
<!-- rotation -->
<!-- Labellers -->

<!-- limit range with limit() and coord_cartesian(), ylim(), or scale_x_continuous() -->
<!-- theme_classic() -->

<!-- expand = c(0,0) -->
<!-- coord_flip() -->
<!-- tick marks -->

<!-- ggrepel -->
<!-- animations -->

<!-- remove -->
<!-- remove title -->
<!-- using fill = or color = in labs() -->
<!-- flip order / don't flip order -->
<!-- move location -->
<!-- color?    theme(legend.title = element_text(colour="chocolate", size=16, face="bold"))+ scale_color_discrete(name="This color is\ncalled chocolate!?") -->
<!-- Color of boxes behind points in legend  -->
<!--      theme(legend.key=element_rect(fill='pink'))   or use fill = NA to remove them. http://zevross.com/blog/2014/08/04/beautiful-plotting-in-r-a-ggplot2-cheatsheet-3/  -->
<!-- Change size of symbols in legend only guides(colour = guide_legend(override.aes = list(size=4))) -->


<!-- Turn off a layer in the legend -->
<!-- geom_text(data=nmmaps, aes(date, temp, label=round(temp)), size=4) -->
<!-- geom_text(data=nmmaps, aes(date, temp, label=round(temp), size=4), show_guide=FALSE) -->

<!-- Force a legend even if there is no aes().  -->
<!-- ggplot(nmmaps, aes(x=date, y=o3))+ -->
<!--      geom_line(aes(color="Important line"))+ -->
<!--      geom_point(aes(color="My points")) -->
<!-- Control the shape in the legend with guides - a list with linetype and shape -->
<!-- ggplot(nmmaps, aes(x=date, y=o3))+geom_line(aes(color="Important line"))+ -->
<!--    geom_point(aes(color="Point values"))+ -->
<!--   scale_colour_manual(name='', values=c('Important line'='grey', 'Point values'='red'), guide='legend') + -->
<!--   guides(colour = guide_legend(override.aes = list(linetype=c(1,0) -->
<!--                                                       , shape=c(NA, 16)))) -->
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/ggplot_tips.Rmd-->


# Salgın eğrileri { }  

```{r, out.width=c('75%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "epicurve_top.png"))
```    


Bir salgın eğrisi ("epi curve" olarak da bilinir), tipik olarak bir vaka kümesi veya salgın arasında geçici hastalık başlangıcı modelini görselleştirmek için kullanılan temel bir epidemiyolojik çizelgedir.

Salgın eğrisi analizi, zamansal eğilimleri, aykırı değerleri, salgının büyüklüğünü, en olası maruz kalma süresini, vaka nesilleri arasındaki zaman sonlarını ortaya çıkarabilir ve hatta tanımlanamayan bir hastalığın bulaşma şeklini belirlemeye yardımcı olabilir (örn. nokta kaynak, sürekli ortak kaynak, kişiden kişiye yayılma). [ABD CDC]'nin web sitesinde(https://www.cdc.gov/training/quicklearns/epimode/index.html) salgın eğrilerinin yorumlanmasıyla ilgili bir online ders bulunabilir.

Bu sayfada, R'da salgın eğrilerini üretmeye yönelik iki yaklaşım gösterilmektedir:  

* Basit komutlarla bir salgın eğrisi oluşturabilen **insidans2** paketi
* Daha karmaşık komutlar aracılığıyla gelişmiş özelleştirilebilirlik sağlayan **ggplot2** paketi

Ayrıca aşağıdakiler gibi özel kullanım durumları da ele alınmaktadır:  

* Toplu sayım verilerini çizme
* Küçük-katları kaplama veya üretme
* Hareketli ortalamaları uygulama
* Hangi verilerin "geçici" olduğunu veya raporlama gecikmelerine tabi olduğunu gösterme
* İkinci bir eksen kullanarak kümülatif vaka insidansını bindirme

<!-- ======================================================= -->
## Hazırlık


### Paketler {.unnumbered}  

Bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran *ve* kullanım için yükleyen **pacman**'ın `p_load()`işlevini vurguluyoruz. Ayrıca, R **tabanı**'ndan `library()`ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] ile ilgili sayfaya bakın.

```{r message=F, warning=F}
pacman::p_load(
  rio,          # file import/export
  here,         # relative filepaths 
  lubridate,    # working with dates/epiweeks
  aweek,        # alternative package for working with dates/epiweeks
  incidence2,   # epicurves of linelist data
  i2extras,     # supplement to incidence2
  stringr,      # search and manipulate character strings
  forcats,      # working with factors
  RColorBrewer, # Color palettes from colorbrewer2.org
  tidyverse     # data management + ggplot2 graphics
) 
```


### Verileri içe aktarma {.unnumbered}

Bu bölümde iki örnek veri seti kullanılmıştır:  

* Simüle edilmiş bir salgından bireysel vakaların sıra listesi
* Aynı simüle edilmiş salgından hastaneye göre toplu sayımlar 

Veri setleri, **rio** paketinden `import()`fonksiyonu kullanılarak içe aktarılır. Verileri içe aktarmanın çeşitli yolları için [İçe ve dışa aktarma] sayfasına bakın.


```{r, echo=F, message=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the counts data into R
count_data <- linelist %>% 
  group_by(hospital, date_hospitalisation) %>% 
  summarize(n_cases = dplyr::n()) %>% 
  filter(date_hospitalisation > as.Date("2013-06-01")) %>% 
  ungroup()
```


**Vaka satır listesi**

Simüle edilmiş bir Ebola salgınından vakaların veri setini içe aktarıyoruz. Adım adım izlenecek verileri indirmek istiyorsanız, [El kitabını ve verileri indir] sayfasındaki talimata bakın. Dosyanın çalışma dizininde olduğunu varsayıyoruz, bu nedenle bu dosya yolunda hiçbir alt klasör belirtilmemiştir.

```{r, eval=F}
linelist <- import("linelist_cleaned.xlsx")
```

İlk 50 satır aşağıda gösterilmiştir.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```



**Hastane tarafından toplanan vaka sayıları**  

El kitabının amaçları doğrultusunda, hastane tarafından haftalık toplu sayımların veri seti, aşağıdaki kodla `linelist` ‘den oluşturulur.

```{r, eval=F}
# import the counts data into R
count_data <- linelist %>% 
  group_by(hospital, date_hospitalisation) %>% 
  summarize(n_cases = dplyr::n()) %>% 
  filter(date_hospitalisation > as.Date("2013-06-01")) %>% 
  ungroup()
```

İlk 50 satır aşağıda görüntülenir:  

```{r message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(count_data, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```




### Parametreleri ayarlamak {.unnumbered}

Bir raporun hazırlanması için, verilerin güncel olduğu tarih ("veri tarihi") gibi düzenlenebilir parametreleri ayarlamak isteyebilirsiniz. Ardından, filtre uygularken veya dinamik altyazılarda kodunuzdaki `data_date` nesnesine başvurabilirsiniz.

```{r set_parameters}
## set the report date for the report
## note: can be set to Sys.Date() for the current date
data_date <- as.Date("2015-05-15")
```



### Tarihleri doğrulama {.unnumbered}

Her ilgili tarih sütununun Date sınıfı olduğunu ve uygun bir değer aralığına sahip olduğunu doğrulayın. Bunu, histogramlar için `hist()`'i veya `na.rm=TRUE` ile  `range()`'i veya aşağıdaki gibi `ggplot()`'u kullanarak yapabilirsiniz.

```{r, out.width = c('50%', '50%', '50%'), fig.show='hold', warning=F, message=F}
# check range of onset dates
ggplot(data = linelist)+
  geom_histogram(aes(x = date_onset))
```



<!-- ======================================================= -->
## **incidence2** paketi ile salgın eğrileri { }

Aşağıda, **insidans2** paketini kullanarak epi eğrilerinin nasıl yapıldığını gösteriyoruz. Bu paketin yazarları, kullanıcının **ggplot2** sözdizimini bilmesine gerek kalmadan salgın eğrilerinin oluşturmasına ve değiştirmesine izin vermeye çalıştılar. Bu sayfanın çoğu, **insidans2** [github sayfası](https://github.com/reconhub/incidence2)'nda bulunabilen paket gösterimlerinden uyarlanmıştır.


<!-- ======================================================= -->
### Basit örnek {.unnumbered}

***İnsidans2* paketiyle bir salgın eğrisi çizmek için 2 adım gereklidir:**
1) Bir *olay nesnesi* **oluşturun** (`incidence()`fonksiyonunu kullanarak)
    + Verileri sağlayın
    + `date_index = `  için tarih sütununu belirtin 
    + Vakaların toplanacağı `interval = ` belirtin  (günlük, haftalık, aylık..)
    + Herhangi bir gruplandırma sütununu belirtin (ör. cinsiyet, hastane, sonuç)
2)	Olay nesnesini **grafiklendirin**
    + Etiketleri, renkleri, başlıkları vb. belirtin.


Aşağıda, **incidence2** paketini yüklüyoruz, `date_onset` sütunundaki `linelist`‘den incidence nesnesini oluşturuyoruz ve günlük vakaları topluyoruz. Daha sonra olay nesnesinin bir özetini yazdırıyoruz.

```{r, warning=F, message=F}
# load incidence2 package
pacman::p_load(incidence2)

# create the incidence object, aggregating cases by day
epi_day <- incidence(       # create incidence object
  x = linelist,             # dataset
  date_index = date_onset,  # date column
  interval = "day"          # date grouping interval
  )
```

**incidence2** nesnesinin kendisi bir tibble (veri çerçevesi gibi) gibi görünür ve bir veri çerçevesi gibi yazdırılabilir veya daha fazla manipüle edilebilir.

```{r}
class(epi_day)
```

Yazdırıldığında `date_index` sütunu ve bir `count` sütunu olduğu görülmektedir.

```{r}
epi_day
```

Ayrıca nesnenin bir özetini yazdırabilirsiniz:  

```{r}
# print summary of the incidence object
summary(epi_day)
```

*incidence* nesnesini *grafiklendirmek* için, *incidence nesnesinin adında* `plot()`kullanın. Arka planda, `plot.incidence2()`fonksiyonu çağrılır, bu nedenle **incidence2**'ye özgü belgeleri okumak için `?plot.incidence2`'yi çalıştırırsınız.

```{r}
# plot the incidence object
plot(epi_day)
```

Çok sayıda küçük beyaz dikey çizgi fark ederseniz, resminizin boyutunu ayarlamaya çalışın. Örneğin, grafiğinizi `ggsave()`ile dışa aktarırsanız, `width = ` ve `height = ` sayıları sağlayabilirsiniz. Grafiği genişletirseniz bu çizgiler kaybolabilir.



### Vaka toplamanın zaman aralığını değiştirmek {.unnumbered}  
`incidence()`'ın `interval = ` bağımsız değişkeni, gözlemlerin dikey çubuklar halinde nasıl gruplandırıldığını tanımlar.

**Aralığı belirtin**  

**incidence2**, vakalarınızı salgın eğrisi çubuklarında nasıl birleştirmek istediğinizi belirtmek için esneklik ve anlaşılır sözdizimi sağlar. `interval = ` bağımsız değişkeni aşağıdaki gibi bir değer girin. Aşağıdakilerden herhangi birini çoğul olarak yazabilirsiniz (ör. “hafta**lar**”) ve öncesinde sayıları ekleyebilirsiniz (ör. “3 ay”).

Argüman seçeneği | Daha fazla açıklama 
------------------- | ------------------------------------ |
Sayı (1, 7, 13, 14, etc.) | Aralık başına gün sayısı  
"hafta" | not: Pazartesi başlangıç günü varsayılandır
"2 hafta" | ya da 3, 4, 5...
"Pazar haftası" | Pazar günleri başlayan haftalar (Peerşembe vb. de kullanılabilir)
"2 Pazar haftası" | ya da 3, 4, 5...
"MMWRhaftası" | hafta Pazar günleri başlar - bkz. ABD CDC
"ay" | ayın 1'i
"çeyrek" | çeyreğin 1. ayı
"2 ay" | ya da 3, 4, 5...
"yıl" | takvim yılının 1. günü


Aşağıda, satır listesine uygulandığında farklı aralıkların nasıl göründüğüne ilişkin örnekler verilmiştir. Tarih aralığı değiştikçe x eksenindeki tarih *etiketlerinin* varsayılan biçiminin ve sıklığının nasıl değiştiğine dikkat edin.

```{r incidence, out.width=c('50%', '50%', '50%', '50%'), fig.show='hold', warning=F, message=F}
# Create the incidence objects (with different intervals)
##############################
# Weekly (Monday week by default)
epi_wk      <- incidence(linelist, date_onset, interval = "Monday week")

# Sunday week
epi_Sun_wk  <- incidence(linelist, date_onset, interval = "Sunday week")

# Three weeks (Monday weeks by default)
epi_2wk     <- incidence(linelist, date_onset, interval = "2 weeks")

# Monthly
epi_month   <- incidence(linelist, date_onset, interval = "month")

# Quarterly
epi_quarter   <- incidence(linelist, date_onset, interval = "quarter")

# Years
epi_year   <- incidence(linelist, date_onset, interval = "year")


# Plot the incidence objects (+ titles for clarity)
############################
plot(epi_wk)+      labs(title = "Monday weeks")
plot(epi_Sun_wk)+  labs(title = "Sunday weeks")
plot(epi_2wk)+     labs(title = "2 (Monday) weeks")
plot(epi_month)+   labs(title = "Months")
plot(epi_quarter)+ labs(title = "Quarters")
plot(epi_year)+    labs(title = "Years")

```


<!-- **Begin at first case**   -->

<!-- If you want the intervals to begin at the first case, you can add the argument `standard = TRUE` to the `incidence()` command. This only works if the interval is either "week", "month", "quarter" or "year".   -->

**İlk tarih**

İsteğe bağlı olarak, `incidence()` komutunda `firstdate = `olarak tarih sınıfının bir değerini (ör. `as.Date("2016-05-01")`) belirtebilirsiniz. Verilirse, veriler bu aralığa kırpılacak ve aralıklar bu tarihte başlayacaktır.



### Gruplar {.unnumbered}

Gruplar `incidence()`komutunda belirtilir ve çubukları renklendirmek veya verileri yönlendirmek için kullanılabilir. Verilerinizdeki grupları belirtmek için, `incidence()` komutunda `groups =` bağımsız değişkenine sütun adlarını sağlayın (sütun adının çevresinde tırnak işareti yok). Birden fazla sütun belirtiyorsanız, adlarını `c()` içine koyun.

`na_as_group = TRUE` ayarını yaparak gruplandırma sütunlarında eksik değerleri olan durumların ayrı bir `NA` grubu olarak listelenmesini sağlayabilirsiniz. Aksi takdirde, grafikten hariç tutulurlar.   

*	*Çubukları bir gruplama sütununa göre renklendirmek* için, `plot()` komutunda, doldurmak/ `fill = `  için sütun adını tekrar temin etmeniz gerekir.

*	*Gruplandırma sütununu temel alan yönlendirmeler* için, **incidence2** ile ilgili görünümlerde aşağıdaki bölüme bakın.

Aşağıdaki örnekte, tüm salgındaki vakalar yaş kategorilerine göre gruplandırılmıştır. Eksik değerler grup olarak dahil edilir. Salgın eğrisi aralığı hafta olarak alınır.


```{r, message=F, warning=F}
# Create incidence object, with data grouped by age category
age_outbreak <- incidence(
  linelist,                # dataset
  date_index = date_onset, # date column
  interval = "week",       # Monday weekly aggregation of cases
  groups = age_cat,        # age_cat is set as a group
  na_as_group = TRUE)      # missing values assigned their own group

# plot the grouped incidence object
plot(
  age_outbreak,             # incidence object with age_cat as group
  fill = age_cat)+          # age_cat is used for bar fill color (must have been set as a groups column above)
labs(fill = "Age Category") # change legend title from default "age_cat" (this is a ggplot2 modification)
```
<span style="color: darkgreen;">**_İPUCU:_** Göstergenin başlığını, **incidence2** grafiğinize `+`  **ggplot2** komut `labs(fill = "your title")` ekleyerek değiştirin.</span>

Ayrıca, aşağıda gösterildiği gibi `plot()` içinde `stack = FALSE` ayarını yaparak gruplandırılmış çubukların yan yana görüntülenmesini sağlayabilirsiniz:

```{r, warning=F, message=F}
# Make incidence object of monthly counts. 
monthly_gender <- incidence(
 linelist,
 date_index = date_onset,
 interval = "month",
 groups = gender            # set gender as grouping column
)

plot(
  monthly_gender,   # incidence object
  fill = gender,    # display bars colored by gender
  stack = FALSE)    # side-by-side (not stacked)
``` 

Eksik değerlere sahip satırları grafikten çıkarmak için `na_as_group = ` bağımsız değişkenini `incidence()` komutunda FALSE olarak ayarlayabilirsiniz.




### Filtrelenmiş veri {.unnumbered}

Bir veri alt kümesinin salgın eğrisini çizmek için:  

1) Satır listesi verilerini filtreleyin  
2) `incidence()` komutuna filtrelenmiş verileri sağlayın  
3) İnsidans nesnesini grafiklendirin

Aşağıdaki örnek, yalnızca Central Hospital'daki vakaları göstermek için filtrelenmiş verileri kullanır.  

```{r, warning=F, message=F}
# filter the linelist
central_data <- linelist %>% 
  filter(hospital == "Central Hospital")

# create incidence object using filtered data
central_outbreak <- incidence(central_data, date_index = date_onset, interval = "week")

# plot the incidence object
plot(central_outbreak, title = "Weekly case incidence at Central Hospital")
```




### Toplu sayımlar {.unnumbered}

Orijinal verileriniz toplanmışsa (sayımlar), `incidence()` ile insidans nesnesini oluştururken `count = `  bağımsız değişkenine vaka sayılarını içeren sütunun adını girin.

Örneğin, bu veri çerçevesi `count_data`, hastane tarafından günlük sayımlarda toplanan satır listesidir. İlk 50 satır şöyle görünür:

```{r message=FALSE, echo=F}
DT::datatable(head(count_data,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

ScriptIf Analizinize yukarıdaki veri kümesi gibi günlük sayım verileriyle başlıyorsanız, bunu hastaneye göre haftalık bir salgın eğrisi dönüştürmek için `incidence()` komutunuz şöyle görünür:

```{r}
epi_counts <- incidence(              # create weekly incidence object
  count_data,                         # dataset with counts aggregated by day
  date_index = date_hospitalisation,  # column with dates
  count = n_cases,                    # column with counts
  interval = "week",                  # aggregate daily counts up to weeks
  groups = hospital                   # group by hospital
  )

# plot the weekly incidence epi curve, with stacked bars by hospital
plot(epi_counts,                      # incidence object
     fill = hospital)                 # color the bars by hospital
```




### Yönlendirmeler/küçük katlar {.unnumbered}  

Verileri gruba göre biçimlendirmek için (yani "küçük katlar" üretin):  

1)	insidans nesnesini oluşturduğunuzda `groups = ` için yönlendirme sütununu belirtin,  
2)	`plot()` yerine `facet_plot()` komutunu kullanın,
3)	Hangi gruplandırma sütunlarının `fill = ` ve hangilerinin `facets = ` olarak kullanılacağını belirtin.

Aşağıda, `incidence()` komutunda hem `hospital` hem de `outcome` sütunlarını gruplandırma sütunları olarak ayarladık. Daha sonra, `facet_plot()`içinde, her hastane için farklı bir salgın eğrisi istediğimizi ve her bir salgın eğrisi içindeki çubukların sonuca göre yığıp renklendirilmesi gerektiğini belirterek, salgın eğrisi çizeriz.
 

```{r, warning=F, message=F}
epi_wks_hosp_out <- incidence(
  linelist,                      # dataset
  date_index = date_onset,       # date column
  interval = "month",            # monthly bars  
  groups = c(outcome, hospital)  # both outcome and hospital are given as grouping columns
  )

# plot
incidence2::facet_plot(
  epi_wks_hosp_out,      # incidence object
  facets = hospital,     # facet column
  fill = outcome)        # fill column

```

**ggtree** paketinin (filogenetik ağaçları görüntülemek için kullanılır) ayrıca bir  `facet_plot()`fonksiyonu sahip olduğuna dikkat edin - bu nedenle yukarıda `incidence2::facet_plot()` belirtilmiştir.



### `plot()` ile yapılan değişiklikler  {.unnumbered} 

**incidence2** tarafından üretilen bir salgın eğrisi, *`plot()`fonksiyonu içindeki* bu bağımsız değişkenler aracılığıyla değiştirilebilir.

**Çubukların görünümünü değiştiren `plot()`bağımsız değişkenleri şunlardır:**  

Bağımsız değişken | Açıklama | Örnekler
------------------|---------------------------------------|-------------------
`fill = `|Çubuk rengi. `groups = ` önceden belirtilen bir renk veya sütun adı `incidence()` komutunda|`fill = "red"`, ya da `fill = gender`  
`color = ` |Her çubuğun etrafını veya bir çubuk içindeki her gruplamanın etrafını renklendirin|`border = "white"` 
`legend = `|Göstergenin yeri|“Alt”, “üst”, “sol”, “sağ” veya “hiçbiri” seçeneklerinden biri  
`alpha = `|Çubukların/bölmelerin şeffaflığı/1 tamamen opak, 0 tamamen şeffaf
`width = `|Çubukların zaman aralığına göre göreceli boyutunu gösteren 0 ile 1 arasındaki değer|`width = .7`  
`show_cases = `|Mantıksal olarak; DOĞRU ise, her durum bir bölme olarak gösterilir. Daha küçük salgınlarda en iyi şekilde görüntülenir.|`show_cases = TRUE`

**Tarih eksenini değiştiren `plot()`bağımsız değişkenleri şunlardır:**  

Bağımsız değişken(ler)|Açıklama
----------------------|----------------------------------------------------
`centre_dates = `|Tarih göstergelerinin çubukların ortasında mı yoksa çubukların başında mı görüneceği konusunda DOĞRU/YANLIŞ. 
`date_format = `|strptime ("%") sözdizimini kullanarak tarih görüntüleme biçimini ayarlayın. Yalnızca `centre_dates = FALSE` ise çalışır (ayrıntılar aşağıdadır).  
`n.breaks = `|İstenen yaklaşık x ekseni etiket sonu sayısı.  
`angle = `|x ekseni tarih etiketlerinin açısı (derece sayısı).  
`size = `|Nokta cinsinden metnin boyutu.

`date_breaks = ` bağımsız değişkenlerinin yalnızca `centre_dates = FALSE` olduğunda çalıştığını unutmayın. [Tarihlerle çalışma sayfasında] ayrıntılı olarak açıklandığı gibi, aşağıdaki strptime sözdizimini kullanarak tırnak içinde bir karakter değeri girin. "yeni satır" için `\n` kullanabilirsiniz.

%d = Ayın gün sayısı (5, 17, 28, v.b.)
%j = Yılın gün sayısı (Julian günü 001-366)
%a = Kısaltılmış hafta içi (Pzt, Slı, Çrşb, v.b.)
%A = Tam hafta içi (Pazartesi, Salı, v.b.)
%w = Hafta içi numarası (0-6, Pazar için 0)
%u = Hafta içi numarası (1-7, Pazartesi için 1)
%W = Hafta numarası (00-53, Pazartesi hafta başlangıcıdır)
%U = Hafta numarası (01-53, Pazar hafta başlangıcıdır)
%m = Hafta numarası (Örneğin 01, 02, 03, 04)
%b = Kısaltılmış ay (Ock, Şbt, v.b.)
%B = Tam ay (Ocak, Şubat, v.b.)
%y = 2 basamaklı yıl (örneğin 89)
%Y = 4 basamaklı yıl (örneğin 1989)
%h = saatler (24 saatlik saat)
%m = dakikalar
%s = saniyeler
%z = GMT’den karşılığı
%Z = Saat dilimi (karakter)



<!-- <span style="color: darkgreen;">**_TIP:_** For breaks every "nth" interval (e.g. every 4th), use `n.breaks = nrow(i)/n` (where “i” is your incidence object name and “n” is a number). If your data are grouped, you will need to multiply "n" by the number of unique groups.</span>   -->



**Grafik etiketlerini değiştiren `plot()`argümanları şunlardır:**

Argüman(lar)|Açıklama
----------------------|----------------------------------------------------
`title = `|Grafik başlığı|`title = "Epidemic curve of Acute Jaundice Syndrome (AJS)"`
`xlab = `|x ekseninin başlığı|`xlab = "Date of onset"`  
`ylab = `|y ekseninin başlığı|`ylab = "Daily case"`  
`size = `|Nokta cinsinden x ekseni metninin boyutu (diğer boyutları ayarlamak için ggplot'un temasını () kullanın)  


Yukarıdaki argümanların çoğunu kullanan bir örnek:  

```{r, warning=F, message=F}
# filter the linelist
central_data <- linelist %>% 
  filter(hospital == "Central Hospital")

# create incidence object using filtered data
central_outbreak <- incidence(
  central_data,
  date_index = date_onset,
  interval = "week",
  groups = outcome)

# plot incidence object
plot(
  central_outbreak,
  fill = outcome,                       # box/bar color
  legend = "top",                       # legend on top
  title = "Cases at Central Hospital",  # title
  xlab = "Week of onset",               # x-axis label
  ylab = "Week of onset",               # y-axis label
  show_cases = TRUE,                    # show each case as an individual box
  alpha = 0.7,                          # transparency 
  border = "grey",                      # box border
  angle = 30,                           # angle of date labels
  centre_dates = FALSE,                 # date labels at edge of bar
  date_format = "%a %d %b %Y\n(Week %W)" # adjust how dates are displayed
  )
```

Grafiğin görünümünü daha fazla ayarlamak için, `ggplot()` ile yapılan değişikliklerle ilgili aşağıdaki bölüme bakın.






### ggplot2 ile değişiklikler {.unnumbered}

Aşağıda gösterildiği gibi, insidans `plot()`fonksiyonunun kapanışından sonra `+` ile **ggplot2** değişiklikleri ekleyerek bir **insidans2** grafiğini daha fazla değiştirebilirsiniz.

Aşağıda, **incidence2** grafiklendirme sona erer ve ardından eksenleri değiştirmek, başlık eklemek ve kalın yazı tipini ve metin boyutunu ayarlamak için **ggplot2** komutları kullanılır.

`scale_x_date()`öğesini eklerseniz, `plot()`öğesindeki çoğu tarih biçimlendirmesinin üzerine yazılacağını unutmayın. Daha fazla seçenek için `ggplot()`salgın eğrisi bölümüne ve El Kitabı sayfası [ggplot ipuçları]na bakın.

```{r, warning=F, message=F}
# filter the linelist
central_data <- linelist %>% 
  filter(hospital == "Central Hospital")

# create incidence object using filtered data
central_outbreak <- incidence(
  central_data,
  date_index = date_onset,
  interval = "week",
  groups = c(outcome))

# plot incidence object
plot(
  central_outbreak,
  fill = outcome,                       # box/bar color
  legend = "top",                       # legend on top
  title = "Cases at Central Hospital",  # title
  xlab = "Week of onset",               # x-axis label
  ylab = "Week of onset",               # y-axis label
  show_cases = TRUE,                    # show each case as an individual box
  alpha = 0.7,                          # transparency 
  border = "grey",                      # box border
  centre_dates = FALSE,                   
  date_format = "%a %d %b\n%Y (Week %W)", 
  angle = 30                           # angle of date labels
  )+
  
  scale_y_continuous(
    breaks = seq(from = 0, to = 30, by = 5),  # specify y-axis increments by 5
    expand = c(0,0))+                         # remove excess space below 0 on y-axis
  
  # add dynamic caption
  labs(
    fill = "Patient outcome",                               # Legend title
    caption = stringr::str_glue(                            # dynamic caption - see page on characters and strings for details
      "n = {central_cases} from Central Hospital
      Case onsets range from {earliest_date} to {latest_date}. {missing_onset} cases are missing date of onset and not shown",
      central_cases = nrow(central_data),
      earliest_date = format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y'),
      latest_date = format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y'),      
      missing_onset = nrow(central_data %>% filter(is.na(date_onset)))))+
  
  # adjust bold face, and caption position
  theme(
    axis.title = element_text(size = 12, face = "bold"),    # axis titles larger and bold
    axis.text = element_text(size = 10, face = "bold"),     # axis text size and bold
    plot.caption = element_text(hjust = 0, face = "italic") # move caption to left
  )
  
```




### Renkleri değiştirmek  {.unnumbered}  

#### Bir palet belirtin {.unnumbered}  

`plot()`içindeki `col_pal = ` argümanına önceden tanımlanmış bir paletin adını sağlayın. **incidence2** paketi, önceden tanımlanmış 2 paletle gelir: "canlı" ve "sessiz". "Canlı"da ilk 6 renk belirgin ve "sessiz"de ilk 9 renk farklıdır. Bu sayılardan sonra renkler, diğer renklerin interpolasyonları/aracılarıdır. Bu önceden tanımlanmış paletler [bu web sitesinde](https://personal.sron.nl/~pault/#sec:qualitative) bulunabilir. Paletler, eksik veriler için ayrılan gri rengi hariç tutar (bu varsayılanı değiştirmek için `na_color = ` kullanın).

```{r out.width = c('50%', '50%'), fig.show='hold', warning = F, message = F}
# Create incidence object, with data grouped by age category  
age_outbreak <- incidence(
  linelist,
  date_index = date_onset,   # date of onset for x-axis
  interval = "week",         # weekly aggregation of cases
  groups = age_cat)

# plot the epicurve with default palette
plot(age_outbreak, fill = age_cat, title = "'vibrant' default incidence2 palette")

# plot with different color palette
#plot(age_outbreak, fill = age_cat, col_pal = muted, title = "'muted' incidence2 palette")
```

Ayrıca R **tabanı** paletlerinden birini de kullanabilirsiniz (palet adını tırnak işaretleri *olmadan* yazın).

```{r out.width = c('50%', '50%'), fig.show='hold', warning = F, message = F}
# plot with base R palette
plot(age_outbreak, fill = age_cat, col_pal = heat.colors, title = "base R heat.colors palette")

# plot with base R palette
plot(age_outbreak, fill = age_cat, col_pal = rainbow, title = "base R rainbow palette")
```

Ayrıca **viridis** paketinden veya **RColorBrewer** paketinden bir renk paleti ekleyebilirsiniz. Önce bu paketler yüklenmelidir, ardından aşağıda gösterildiği gibi ilgili `scale_fill_*()` fonksiyonlarını bir `+` ile ekleyin.

```{r out.width = c('50%', '50%'), fig.show='hold', warning = F, message = F}
pacman::p_load(RColorBrewer, viridis)

# plot with color palette
plot(age_outbreak, fill = age_cat, title = "Viridis palette")+
  scale_fill_viridis_d(
    option = "inferno",     # color scheme, try also "plasma" or the default
    name = "Age Category",  # legend name
    na.value = "grey")      # for missing values

# plot with color palette
plot(age_outbreak, fill = age_cat, title = "RColorBrewer palette")+
  scale_fill_brewer(
    palette = "Dark2",      # color palette, try also Accent, Dark2, Paired, Pastel1, Pastel2, Set1, Set2, Set3
    name = "Age Category",  # legend name
    na.value = "grey")      # for missing values
```


#### Manuel olarak belirtin {.unnumbered}  

Renkleri manuel olarak belirtmek için, **ggplot2** işlevini `scale_fill_manual()`ile `plot()`öğesine bir `+` ekleyin ve renk adlarının vektörünü veya HEX kodlarını bağımsız değişken `values = ` sağlayın. Listelenen renk sayısı, grup sayısına eşit olmalıdır. Eksik değerlerin bir grup olup olmadığına dikkat edin - [Faktörler] sayfasında açıklandığı gibi `fct_explicit_na()`işleviyle veri hazırlamanız sırasında "Missing" gibi bir karakter değerine dönüştürülebilirler.

```{r out.width = c('50%', '50%'), fig.show='hold', warning=F, message=F}
# manual colors
plot(age_outbreak, fill = age_cat, title = "Manually-specified colors")+
  scale_fill_manual(
    values = c("darkgreen", "darkblue", "purple", "grey", "yellow", "orange", "red", "lightblue"),  # colors
    name = "Age Category")      # Name for legend
```

[Ggplot ipuçları] sayfasında belirtildiği gibi, bir renk vektörü üzerinde `colorRampPalette()` kullanarak ve karşılığında istediğiniz renk sayısını belirterek kendi paletlerinizi oluşturabilirsiniz. Bu, birkaçını belirterek bir rampada birçok rengi elde etmenin iyi bir yoludur.

```{r}
my_cols <- c("darkgreen", "darkblue", "purple", "grey", "yellow", "orange")
my_palette <- colorRampPalette(my_cols)(12)  # expand the 6 colors above to 12 colors
my_palette
```
          
          
### Seviye sırasını ayarla {.unnumbered}  

Grup görünüm sırasını ayarlamak için (grafikte ve göstergede), gruplandırma sütunu sınıf Faktörü olmalıdır. Daha fazla bilgi için [Faktörler] sayfasına bakın.

İlk olarak, varsayılan sıralamayla hastaneye göre haftalık bir salgın eğrisini görelim:

```{r, message=F, warning=F}
# ORIGINAL - hospital NOT as factor
###################################

# create weekly incidence object, rows grouped by hospital and week
hospital_outbreak <- incidence(
  linelist,
  date_index = date_onset, 
  interval = "week", 
  groups = hospital)

# plot incidence object
plot(hospital_outbreak, fill = hospital, title = "ORIGINAL - hospital not a factor")
```

Şimdi sırayı "Eksik" ve "Diğer" salgın eğrisinin en üstünde olacak şekilde ayarlamak için aşağıdakileri yapabiliriz:  

* Faktörlerle çalışmak için **forcats** paketini yükleyin. 
* Veri kümesini ayarlayın - bu durumda aşağıdakileri içeren yeni bir veri kümesi (`plot_data`) tanımlayacağız:  
  * `gender` sütunu bir faktör olarak tanımlanır, seviyelerin sırası `fct_relevel()` ile ayarlanır, böylece “Diğer” ve “Eksik” ilk olur, böylece çubukların en üstünde görünürler.
* İnsidans nesnesi daha önce olduğu gibi oluşturulur ve grafiklendirilir  
* **ggplot2** değişiklikleri ekliyoruz; 
  * "Eksik" gri ve "Diğer" bej olacak şekilde renkleri manuel olarak atamak için `scale_fill_manual()` 
 



```{r, message=F, warning=F}
# MODIFIED - hospital as factor
###############################

# load forcats package for working with factors
pacman::p_load(forcats)

# Convert hospital column to factor and adjust levels
plot_data <- linelist %>% 
  mutate(hospital = fct_relevel(hospital, c("Missing", "Other"))) # Set "Missing" and "Other" as top levels


# Create weekly incidence object, grouped by hospital and week
hospital_outbreak_mod <- incidence(
  plot_data,
  date_index = date_onset, 
  interval = "week", 
  groups = hospital)

# plot incidence object
plot(hospital_outbreak_mod, fill = hospital)+
  
  # manual specify colors
  scale_fill_manual(values = c("grey", "beige", "darkgreen", "green2", "orange", "red", "pink"))+                      

  # labels added via ggplot
  labs(
      title = "MODIFIED - hospital as factor",   # plot title
      subtitle = "Other & Missing at top of epicurve",
      y = "Weekly case incidence",               # y axis title  
      x = "Week of symptom onset",               # x axis title
      fill = "Hospital")                         # title of legend     
```

<span style="color: darkgreen;">**_İPUCU:_** Yalnızca göstergenin sırasını tersine çevirmek istiyorsanız, bu **ggplot2** komut kılavuzlarını ekleyin `guides(fill = guide_legend(reverse = TRUE))`.</span>  



### Dikey klavuz çizgileri {.unnumbered}  

Varsayılan **incidence2** ayarlarıyla çizerseniz, dikey kılavuz çizgilerinin her tarih etiketinde ve her tarih etiketi arasında bir kez göründüğünü fark edebilirsiniz. Bu, ızgara çizgilerinin bazı çubukların üst kısmıyla kesişmesine neden olabilir.

<!-- [TO DO Note this paragraph is not applicable with version 1.0.0 of incidence2). You can specify the interval for the gridlines by adding **ggplot2**'s `scale_x_date()` command to your **incidence2** plot. Within it, specify the intervals for `date_breaks = ` and `date_minor_breaks = ` (e.g. "weeks" or "3 weeks" or "months"). Note that use of `scale_x_date()` will over-ride any formatting of the date labels in `plot()`, so you will need to specify any string format to `date_labels = ` as below.   -->

**ggplot2** komutunu `theme_classic()`ekleyerek tüm kılavuz çizgilerini kaldırabilirsiniz.

```{r, warning=F, message=F, out.width = c('50%', '50%', '50%'), fig.show='hold'}
# make incidence object
a <- incidence(
  central_data,
  date_index = date_onset,
  interval = "Monday weeks"
)

# Default gridlines
plot(a, title = "Default lines")

# Specified gridline intervals
# NOT WORKING WITH INCIDENCE2 1.0.0
# plot(a, title = "Weekly lines")+
#   scale_x_date(
#     date_breaks = "4 weeks",      # major vertical lines align on weeks
#     date_minor_breaks = "weeks",  # minor vertical lines every week
#     date_labels = "%a\n%d\n%b")   # format of date labels

# No gridlines
plot(a, title = "No lines")+
  theme_classic()                 # remove all gridlines
```

Bununla birlikte, haftalar kullanılıyorsa, `date_breaks` ve `date_minor_breaks` argümanlarının yalnızca *Pazartesi* haftaları için çalıştığını unutmayın. Haftalarınız haftanın başka bir günüyse, bunun yerine `breaks = ` ve `minor_breaks = ` argümanlarına manuel olarak bir tarih vektörü sağlamanız gerekir. `seq.Date()`kullanarak bunun örnekleri için **ggplot2** bölümüne bakın.

### Kümülatif insidans {.unnumbered}  

İnsidans nesnesini **incidence2** `cumulate()` komutuna ve ardından `plot()` komutuna ileterek, kümülatif insidansın bir grafiğini kolaylıkla üretebilirsiniz. Bu aynı zamanda `facet_plot()` ile de çalışır.

```{r}
# make weekly incidence object
wkly_inci <- incidence(
  linelist,
  date_index = date_onset,
  interval = "week"
)

# plot cumulative incidence
wkly_inci %>% 
  cumulate() %>% 
  plot()
```


**ggplot2** ile kümülatif insidansı çizmek için alternatif yöntem için bu sayfanın ilerisindeki bölüme bakın - örneğin, bir salgın eğrisi üzerine kümülatif bir insidans çizgisini bindirmek gibi.

### Ortalama yuvarlama  {.unnumbered}

**i2extras** paketindeki `add_rolling_average()`ile kolayca bir **incidence2** grafiğine hareketli bir ortalama ekleyebilirsiniz. İnsidans2 nesnenizi bu işleve ve ardından `plot()` öğesine iletin. `before = ` olarak ayarlayın, dönen ortalamaya dahil edilmesini istediğiniz önceki günlerin sayısı (varsayılan 2'dir). Verileriniz gruplandırılmışsa, hareketli ortalama grup başına hesaplanacaktır. 

```{r, warning=F, message=F}
rolling_avg <- incidence(                    # make incidence object
  linelist,
  date_index = date_onset,
  interval = "week",
  groups = gender) %>% 
  
  i2extras::add_rolling_average(before = 6)  # add rolling averages (in this case, by gender)

# plot
plot(rolling_avg) # faceted automatically because rolling average on groups
```

Verilere daha genel olarak yuvarlanan ortalamaların nasıl uygulanacağını öğrenmek için [Hareketli ortalamalar] hakkındaki El Kitabı sayfasına bakın.


<!-- ======================================================= -->
## ggplot2 ile salgın eğrileri { }

Salgın eğrinizi oluşturmak için `ggplot()`'u kullanmak daha fazla esneklik ve özelleştirme sağlar, ancak `ggplot()`'un nasıl çalıştığına dair daha fazla çaba ve anlayış gerektirir.

**incidence2** paketini kullanmaktan farklı olarak, vakaların zamana (haftalara, aylara vb.) göre toplanmasını *ve* tarih eksenindeki etiketlerin sonlanmalarını *manuel* olarak kontrol etmelisiniz. Bu dikkatle yönetilmelidir.

Bu örnekler, `linelist` veri kümesinin bir alt kümesini kullanır - yalnızca Central Hospital'daki vakalar.


```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r}
central_data <- linelist %>% 
  filter(hospital == "Central Hospital")
```

```{r, eval=F, echo=F}
detach("package:tidyverse", unload=TRUE)
library(tidyverse)
```


`ggplot()` ile bir salgın eğrisi oluşturmak için üç ana unsur vardır:

* Belirli "sonlanlanma" noktalarıyla ayırt edilen "bölmelere" toplanmış satır listesi vakaları içeren bir histogram,  
* Eksenler ve etiketleri için ölçekler,  
* Başlıklar, etiketler, altyazılar vb. dahil olmak üzere grafik görünümü için temalar. 


### Vaka bölmelerini belirtin {.unnumbered}  

Burada, vakaların histogram bölmelerinde ("çubuklar") nasıl toplanacağını belirteceğiz. Vakaların histogram bölmelerinde toplanmasının, x ekseninde görünecek tarihlerle mutlaka aynı sonlanmalar **olmadığını** bilmek önemlidir.

Aşağıda, günlük ve haftalık salgın eğrileri üretmek için belki de en basit kod verilmiştir.  

Aşırı kemerli `ggplot()` komutunda, veri kümesi `data = ` olarak sağlanır. Bu temel üzerine, bir histogramın geometrisi `+` ile eklenir. `geom_histogram()` içinde, `date_onset` sütunu x eksenine eşlenecek şekilde estetiği eşleriz. Ayrıca `geom_histogram()` içinde ama `aes()` içinde *değil*, histogram bölmelerinin  `binwidth =` değerini gün olarak ayarladık. Bu **ggplot2** sözdizimi kafa karıştırıcıysa, [ggplot temelleri] hakkındaki sayfayı inceleyin.

<span style="color: orange;">**_DİKKAT:_** `binwidth = 7` kullanarak haftalık vakaları grafiklendirmek, ilk durumda ilk 7 günlük bölmeyi başlatır, bu haftanın herhangi bir günü olabilir! Belirli haftalar oluşturmak için aşağıdaki bölüme bakın. </span>


``` {r ggplot_simple,  out.width = c('50%', '50%'), fig.show='hold', warning= F, message = F}
# daily 
ggplot(data = central_data) +          # set data
  geom_histogram(                      # add histogram
    mapping = aes(x = date_onset),     # map date column to x-axis
    binwidth = 1)+                     # cases binned by 1 day 
  labs(title = "Central Hospital - Daily")                # title

# weekly
ggplot(data = central_data) +          # set data 
  geom_histogram(                      # add histogram
      mapping = aes(x = date_onset),   # map date column to x-axis
      binwidth = 7)+                   # cases binned every 7 days, starting from first case (!) 
  labs(title = "Central Hospital - 7-day bins, starting at first case") # title
```

Bu Central Hopital veri setindeki ilk vakanın aşağıdakilerde semptom başlangıcı olduğunu not edelim:  

```{r}
format(min(central_data$date_onset, na.rm=T), "%A %d %b, %Y")
```

**Histogram bölme kesmelerini manuel olarak belirtmek için bölme `binwidth = ` argümanını *kullanmayın* ve bunun yerine `breaks = ` için bir tarih vektörü sağlayın.**

R **tabanı** işlevi `seq.Date()`ile tarihlerin vektörünü oluşturun. Bu fonksiyon `to = `, `from = ` ve `by = ` argümanlarını bekler. Örneğin, aşağıdaki komut, 15 Ocak'ta başlayan ve 28 Haziran'a kadar biten aylık tarihleri döndürür.

```{r}
monthly_breaks <- seq.Date(from = as.Date("2014-02-01"),
                           to = as.Date("2015-07-15"),
                           by = "months")

monthly_breaks   # print
```

Bu vektör `geom_histogram()`'a `breaks = ` olarak sağlanabilir:

```{r, warning=F, message=F}
# monthly 
ggplot(data = central_data) +  
  geom_histogram(
    mapping = aes(x = date_onset),
    breaks = monthly_breaks)+         # provide the pre-defined vector of breaks                    
  labs(title = "Monthly case bins")   # title
```

Basit bir haftalık tarih dizisi, `by = "week"` ile ayarlanarak döndürülebilir. Örneğin:

```{r}
weekly_breaks <- seq.Date(from = as.Date("2014-02-01"),
                          to = as.Date("2015-07-15"),
                          by = "week")
```

 
Belirli başlangıç ve bitiş tarihlerini sağlamaya bir alternatif, haftalık bölmelerin *ilk durumdan önceki Pazartesi günü* başlaması için *dinamik* kod yazmaktır. **Aşağıdaki örneklerde bu tarih vektörlerini kullanacağız.**
     
```{r}
# Sequence of weekly Monday dates for CENTRAL HOSPITAL
weekly_breaks_central <- seq.Date(
  from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 1), # monday before first case
  to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 1), # monday after last case
  by   = "week")
```  

Yukarıdaki oldukça göz korkutucu kodu açalım:  

* "from" değeri (dizinin en erken tarihi) şu şekilde oluşturulur: `date_onset` sütunundaki minimum tarih değeri (`min()` ile `na.rm=TRUE`) **lubridate** paketinden `floor_date()` öğesine beslenir. `floor_date()` "hafta" olarak ayarlandığında, her haftanın başlangıç gününün Pazartesi olması koşuluyla (`week_start = 1`) bu vakaların "hafta"sının başlangıç tarihini döndürür.  
* Benzer şekilde, "to" değeri (dizinin bitiş tarihi), son vakadan *sonraki* Pazartesi gününü döndürmek için `ceiling_date()` ters işlevi kullanılarak oluşturulur.  
* `seq.Date()` öğesinin “by” argümanı herhangi bir sayıda gün, hafta veya aya ayarlanabilir.   
* Pazar haftaları için `week_start = 7` kullanın.  

Bu sayfa boyunca bu veri vektörlerini kullanacağımız için, tüm salgın için bir tane de tanımladık (yukarıdakiler sadece Central Hospital içindir).  

```{r}
# Sequence for the entire outbreak
weekly_breaks_all <- seq.Date(
  from = floor_date(min(linelist$date_onset, na.rm=T),   "week", week_start = 1), # monday before first case
  to   = ceiling_date(max(linelist$date_onset, na.rm=T), "week", week_start = 1), # monday after last case
  by   = "week")
```

Bu `seq.Date()`çıktıları, histogram bölme sonlanmalarını oluşturmak için kullanılabilir, ancak aynı zamanda bölmelerden bağımsız olabilen tarih etiketleri için sonlanmalar da kullanılabilir. Sonraki bölümlerde tarih etiketleri hakkında daha fazla bilgi edinin.

<span style="color: darkgreen;">**_İPUCU:_** Daha basit bir `ggplot()` komutu için, bölme sonlanmalarını ve etiket sonlanmalarını önceden adlandırılmış vektörler olarak kaydedin ve yalnızca adlarını  `breaks = `  olarak değiştirin.</span>  







### Haftalık salgın eğrisi örneği {.unnumbered}  

**Aşağıda, hizalanmış çubuklar, tarih etiketleri ve dikey kılavuz çizgileri ile Pazartesi haftaları için haftalık salıgın eğrileri oluşturmak için ayrıntılı örnek kod verilmiştir.** Bu bölüm, hızlı bir şekilde koda ihtiyaç duyan kullanıcı içindir. Her yönü (temalar, tarih etiketleri vb.) derinlemesine anlamak için sonraki bölümlere geçin. Önemli:

* *Histogram bölme araları*, en erken vakadan önceki Pazartesi günü başlayacak ve son vakadan sonraki Pazartesi günü sona erecek şekilde yukarıda açıklandığı gibi `seq.Date()`ile tanımlanır.  
* *Tarih etiketleri*nin aralığı, `scale_x_date()` içinde `date_breaks =`  ile belirtilir.  
* Tarih etiketleri arasındaki küçük dikey kılavuz çizgilerinin aralığı, `date_minor_breaks = ` olarak belirtilir.
* x ve y ölçeklerinde `expand = c(0,0)`eksenlerin her iki yanındaki fazla boşluğu kaldırır, bu da tarih etiketlerinin ilk çubuktan başlamasını sağlar. 

```{r, warning=F, message=F}
# TOTAL MONDAY WEEK ALIGNMENT
#############################
# Define sequence of weekly breaks
weekly_breaks_central <- seq.Date(
      from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 1), # Monday before first case
      to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 1), # Monday after last case
      by   = "week")    # bins are 7-days 


ggplot(data = central_data) + 
  
  # make histogram: specify bin break points: starts the Monday before first case, end Monday after last case
  geom_histogram(
    
    # mapping aesthetics
    mapping = aes(x = date_onset),  # date column mapped to x-axis
    
    # histogram bin breaks
    breaks = weekly_breaks_central, # histogram bin breaks defined previously
    
    # bars
    color = "darkblue",     # color of lines around bars
    fill = "lightblue"      # color of fill within bars
  )+ 
    
  # x-axis labels
  scale_x_date(
    expand            = c(0,0),           # remove excess x-axis space before and after case bars
    date_breaks       = "4 weeks",        # date labels and major vertical gridlines appear every 3 Monday weeks
    date_minor_breaks = "week",           # minor vertical lines appear every Monday week
    date_labels       = "%a\n%d %b\n%Y")+ # date labels format
  
  # y-axis
  scale_y_continuous(
    expand = c(0,0))+             # remove excess y-axis space below 0 (align histogram flush with x-axis)
  
  # aesthetic themes
  theme_minimal()+                # simplify plot background
  
  theme(
    plot.caption = element_text(hjust = 0,        # caption on left side
                                face = "italic"), # caption in italics
    axis.title = element_text(face = "bold"))+    # axis titles in bold
  
  # labels including dynamic caption
  labs(
    title    = "Weekly incidence of cases (Monday weeks)",
    subtitle = "Note alignment of bars, vertical gridlines, and axis labels on Monday weeks",
    x        = "Week of symptom onset",
    y        = "Weekly incident cases reported",
    caption  = stringr::str_glue("n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown"))
```


#### Pazar haftaları {.unnumbered}  

Pazar haftaları için yukarıdaki grafiği elde etmek için birkaç değişiklik gereklidir, çünkü `date_breaks = "weeks"` sadece Pazartesi haftaları için çalışır.

* *Histogram bölmeleri*nin sonlanma noktaları Pazar günleri olarak ayarlanmalıdır (`week_start = 7`). 
* `scale_x_date()` içinde, tarih etiketlerinin ve dikey kılavuz çizgilerinin Pazar günleri hizalanmasını sağlamak için `breaks =` ve `minor_breaks = `  için benzer tarih sonlanmaları sağlanmalıdır.

Örneğin, Pazar haftaları için `scale_x_date()` komutu şöyle görünebilir:

```{r, eval=F}
scale_x_date(
    expand = c(0,0),
    
    # specify interval of date labels and major vertical gridlines
    breaks = seq.Date(
      from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7), # Sunday before first case
      to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7), # Sunday after last case
      by   = "4 weeks"),
    
    # specify interval of minor vertical gridline 
    minor_breaks = seq.Date(
      from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7), # Sunday before first case
      to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7), # Sunday after last case
      by   = "week"),
   
    # date label format
    date_labels = "%a\n%d %b\n%Y")+         # day, above month abbrev., above 2-digit year

```



###	Değere göre grup/renk  {.unnumbered}

Histogram çubukları, grup ve "yığılmış" olarak renklendirilebilir. Gruplandırma sütununu atamak için aşağıdaki değişiklikleri yapın. Ayrıntılar için [ggplot temelleri] sayfasına bakın.  

* Histogram estetik haritalama `aes()`içinde, sütun adını `group = ` ve `fill = ` bağımsız değişkenini eşleştirin. 
* `aes()` *dışındaki* herhangi bir `fill = ` argümanını kaldırın, çünkü içindekini geçersiz kılar.  
* `aes()` *içindeki* argümanlar *gruba göre* uygulanırken, *dışındaki* herhangi bir argüman tüm çubuklara uygulanacaktır (örneğin, yine de `color = ` dışarıda isteyebilirsiniz, böylece her çubuk aynı kenarlığa sahip olur). 

Çubukları cinsiyete göre gruplamak ve renklendirmek için `aes()`komutu şöyle görünür:  

```{r, eval=F}
aes(x = date_onset, group = gender, fill = gender)
```

Burada uygulanır:  

```{r, warning=F, message=F}
ggplot(data = linelist) +     # begin with linelist (many hospitals)
  
  # make histogram: specify bin break points: starts the Monday before first case, end Monday after last case
  geom_histogram(
    mapping = aes(
      x = date_onset,
      group = hospital,       # set data to be grouped by hospital
      fill = hospital),       # bar fill (inside color) by hospital
    
    # bin breaks are Monday weeks
    breaks = weekly_breaks_all,   # sequence of weekly Monday bin breaks for whole outbreak, defined in previous code       
    
    # Color around bars
    color = "black")
```


###	Renkleri ayarlamak {.unnumbered}  

* Her grup için dolguyu *manuel* olarak ayarlamak için `scale_fill_manual()` öğesini kullanın (not: `scale_color_manual()` farklıdır!).
  * Bir renk vektörü uygulamak için `values = ` argümanını kullanın.  
  * `NA` değerleri için bir renk belirtmek için `na.value = `  kullanın.  
  * Gösterge öğelerinin metnini değiştirmek için `labels = ` argümanını kullanın. Güvende olmak için, `c("old" = "new", "old" = "new")` gibi adlandırılmış bir vektör sağlayın veya verilerin kendisindeki değerleri ayarlayın.  
  * Açıklamaya uygun bir başlık koymak için `name = ` kullanın. 
* Renk ölçekleri ve paletler hakkında daha fazla ipucu için [ggplot temelleri] sayfasına bakın.

```{r, warning=F, message=F}
ggplot(data = linelist)+           # begin with linelist (many hospitals)
  
  # make histogram
  geom_histogram(
    mapping = aes(x = date_onset,
        group = hospital,          # cases grouped by hospital
        fill = hospital),          # bar fill by hospital
    
    # bin breaks
    breaks = weekly_breaks_all,        # sequence of weekly Monday bin breaks, defined in previous code
    
    # Color around bars
    color = "black")+              # border color of each bar
  
  # manual specification of colors
  scale_fill_manual(
    values = c("black", "orange", "grey", "beige", "blue", "brown"),
    labels = c("St. Mark's Maternity Hospital (SMMH)" = "St. Mark's"),
    name = "Hospital") # specify fill colors ("values") - attention to order!
```




###	Seviye sırasını ayarlamak {.unnumbered}  

Gruplandırılmış çubukların istiflendiği sıra, en iyi şekilde gruplandırma sütununu sınıf Faktörü olarak sınıflandırarak ayarlanır. Daha sonra faktör düzeyi sırasını (ve bunların görüntü etiketlerini) belirleyebilirsiniz. Ayrıntılar için [Faktörler] veya [ggplot ipuçları] sayfasına bakın.

Grafiği yapmadan önce, gruplandırma sütununu sınıf faktörüne dönüştürmek için **forcats** paketindeki `fct_relevel()` işlevini kullanın ve [Faktörler] sayfasında ayrıntılı olarak açıklandığı gibi seviye sırasını manuel olarak ayarlayın.  

```{r}
# load forcats package for working with factors
pacman::p_load(forcats)

# Define new dataset with hospital as factor
plot_data <- linelist %>% 
  mutate(hospital = fct_relevel(hospital, c("Missing", "Other"))) # Convert to factor and set "Missing" and "Other" as top levels to appear on epicurve top

levels(plot_data$hospital) # print levels in order
```

Aşağıdaki çizimde, öncekinden tek fark, `hospital` sütununu yukarıdaki gibi konsolide edilmiş olmasıdır ve gösterge sırasını tersine çevirmek için `guides()`kullanıyoruz, böylece “Eksik” göstergenin alt kısmındadır.

```{r, warning=F, message=F}
ggplot(plot_data) +                     # Use NEW dataset with hospital as re-ordered factor
  
  # make histogram
  geom_histogram(
    mapping = aes(x = date_onset,
        group = hospital,               # cases grouped by hospital
        fill = hospital),               # bar fill (color) by hospital
    
    breaks = weekly_breaks_all,         # sequence of weekly Monday bin breaks for whole outbreak, defined at top of ggplot section
    
    color = "black")+                   # border color around each bar
    
  # x-axis labels
  scale_x_date(
    expand            = c(0,0),         # remove excess x-axis space before and after case bars
    date_breaks       = "3 weeks",      # labels appear every 3 Monday weeks
    date_minor_breaks = "week",         # vertical lines appear every Monday week
    date_labels       = "%d\n%b\n'%y")+ # date labels format
  
  # y-axis
  scale_y_continuous(
    expand = c(0,0))+                   # remove excess y-axis space below 0
  
  # manual specification of colors, ! attention to order
  scale_fill_manual(
    values = c("grey", "beige", "black", "orange", "blue", "brown"),
    labels = c("St. Mark's Maternity Hospital (SMMH)" = "St. Mark's"),
    name = "Hospital")+ 
  
  # aesthetic themes
  theme_minimal()+                      # simplify plot background
  
  theme(
    plot.caption = element_text(face = "italic", # caption on left side in italics
                                hjust = 0), 
    axis.title = element_text(face = "bold"))+   # axis titles in bold
  
  # labels
  labs(
    title    = "Weekly incidence of cases by hospital",
    subtitle = "Hospital as re-ordered factor",
    x        = "Week of symptom onset",
    y        = "Weekly cases")
```

<span style="color: darkgreen;">**_İPUCU:_** Yalnızca göstergenin sırasını tersine çevirmek için bu **ggplot2** komutunu ekleyin: `guides(fill = guide_legend(reverse = TRUE))`.</span>  





###	Göstergeyi ayarlamak  {.unnumbered}

[ggplot ipuçları] sayfasında göstergeler ve ölçekler hakkında daha fazla bilgi edinin. İşte birkaç önemli nokta:  

* Gösterge başlığını ölçek işlevinde veya `labs(fill = "Legend title")` ile düzenleyin (`color = `  estetik kullanıyorsanız, `labs(color = "")` kullanın)  
* Gösterge başlığının olmaması için `theme(legend.title = element_blank())` kulanın.  
* `theme(legend.position = "top")` (göstergeyi kaldırmak için “alt”, “sol”, “sağ” veya “yok”) kullanın.
* Yatay gösterge için `theme(legend.direction = "horizontal")` kullanın.
* Göstergenin sırasını tersine çevirmek için `guides(fill = guide_legend(reverse = TRUE))` kullanın. 







###	Yan yana çubuklar {.unnumbered}  

Grup çubuklarının yan yana gösterimi (yığılmışın aksine) `geom_histogram()`içinde, `position = "dodge"` `aes()` dışına yerleştirilerek belirtilir.  

İkiden fazla değer grubu varsa, bunların okunması zorlaşabilir. Bunun yerine fasetli bir grafik (küçük katlar) kullanmayı düşünün. Bu örnekte okunabilirliği artırmak için eksik cinsiyet değerleri kaldırılmıştır.

```{r, warning=F, message=F}
ggplot(central_data %>% drop_na(gender))+   # begin with Central Hospital cases dropping missing gender
    geom_histogram(
        mapping = aes(
          x = date_onset,
          group = gender,         # cases grouped by gender
          fill = gender),         # bars filled by gender
        
        # histogram bin breaks
        breaks = weekly_breaks_central,   # sequence of weekly dates for Central outbreak - defined at top of ggplot section
        
        color = "black",          # bar edge color
        
        position = "dodge")+      # SIDE-BY-SIDE bars
                      
  
  # The labels on the x-axis
  scale_x_date(expand            = c(0,0),         # remove excess x-axis space below and after case bars
               date_breaks       = "3 weeks",      # labels appear every 3 Monday weeks
               date_minor_breaks = "week",         # vertical lines appear every Monday week
               date_labels       = "%d\n%b\n'%y")+ # date labels format
  
  # y-axis
  scale_y_continuous(expand = c(0,0))+             # removes excess y-axis space between bottom of bars and the labels
  
  #scale of colors and legend labels
  scale_fill_manual(values = c("brown", "orange"),  # specify fill colors ("values") - attention to order!
                    na.value = "grey" )+     

  # aesthetic themes
  theme_minimal()+                                               # a set of themes to simplify plot
  theme(plot.caption = element_text(face = "italic", hjust = 0), # caption on left side in italics
        axis.title = element_text(face = "bold"))+               # axis titles in bold
  
  # labels
  labs(title    = "Weekly incidence of cases, by gender",
       subtitle = "Subtitle",
       fill     = "Gender",                                      # provide new title for legend
       x        = "Week of symptom onset",
       y        = "Weekly incident cases reported")
```




###	Eksen sınırları {.unnumbered}  

Eksen değerlerinin kapsamını sınırlamanın iki yolu vardır:  

Genellikle tercih edilen yol, `xlim = c(min, max)` ve `ylim = c(min, max)` (min ve max değerlerini sağladığınız) kabul eden `coord_cartesian()`komutunu kullanmaktır. Bu, istatistikler ve özet ölçümler için önemli olan herhangi bir veriyi fiilen kaldırmadan bir "yakınlaştırma" görevi görür.

Alternatif olarak, `scale_x_date()`içinde `limits = c()` kullanarak maksimum ve minimum tarih değerlerini ayarlayabilirsiniz. Örneğin:

```{r eval=F}
scale_x_date(limits = c(as.Date("2014-04-01"), NA)) # sets a minimum date but leaves the maximum open.  
```

Benzer şekilde, x ekseninin belirli bir tarihe (örn. geçerli tarih) uzanmasını istiyorsanız, yeni vaka bildirilmemiş olsa bile şunları kullanabilirsiniz:  

```{r eval=F}
scale_x_date(limits = c(NA, Sys.Date()) # ensures date axis will extend until current date  
```

<span style="color: red;">**_TEHLİKE:_** y ekseni ölçek sonları veya sınırlarını ayarlarken dikkatli olun (örn. 0 ila 30 by 5: `seq(0, 30, 5)`). Bu tür statik sayılar, veriler sınırı aşacak şekilde değişirse grafiğinizi çok kısa kesebilir!.</span>



###	Tarih ekseni etiketleri/kılavuz çizgileri {.unnumbered} 

<span style="color: darkgreen;">**_İPUCU:_** Tarih ekseni **etiketlerinin** verilerin çubuklar halinde toplanmasından bağımsız olduğunu, ancak görsel olarak bölmeleri, tarih etiketlerini ve dikey kılavuz çizgilerini hizalamanın önemli olabileceğini unutmayın.</span>

**Tarih etiketlerini ve kılavuz çizgilerini değiştirmek** için, şu yollardan biriyle  `scale_x_date()` kullanın:

* **Histogram bölmeleriniz günler, Pazartesi haftaları, aylar veya yıllar ise:**   
  * Etiketlerin ve ana kılavuz çizgilerinin aralığını belirtmek için `date_breaks = ` kullanın (ör. "gün", "hafta", "3 hafta", "ay" veya "yıl").
  * Küçük dikey kılavuz çizgilerinin aralığını belirtmek için `date_minor_breaks = ` kullanın (tarih etiketleri arasında).  
  * Etiketlere ilk çubuktan başlamak için `expand = c(0,0)` ekleyin. 
  * Tarih etiketlerinin biçimini belirtmek için `date_labels = ` kullanın - ipuçları için tarihler sayfasına bakın (yeni bir satır için `\n` kullanın).  
* **Histogram bölmeleriniz Pazar haftalarıysa:**  
  * Her biri için bir tarih sonları dizisi sağlayarak `breaks = `  ve  `minor_breaks = ` kullanın.
  * Yukarıda açıklandığı gibi biçimlendirme için hala d`date_labels = ` ve `expand = ` kullanabilirsiniz. 

Bazı notlar:  

* `seq.Date()` kullanarak bir tarih dizisinin nasıl oluşturulacağına ilişkin talimatlar için açılış ggplot bölümüne bakın.  
* Tarih etiketleri oluşturmaya ilişkin ipuçları için [bu sayfaya](https://rdrr.io/r/base/strptime.html) veya [Tarihlerle çalışma sayfasına] bakın. 




#### Sunumlar {.unnumbered}

Aşağıda, bölmeler ve grafik etiketlerinin/kılavuz çizgilerinin hizalandığı ve hizalanmadığı grafiklerin bir gösterimi bulunmaktadır:  

```{r fig.show='hold', class.source = 'fold-hide', warning=F, message=F}
# 7-day bins + Monday labels
#############################
ggplot(central_data) +
  geom_histogram(
    mapping = aes(x = date_onset),
    binwidth = 7,                 # 7-day bins with start at first case
    color = "darkblue",
    fill = "lightblue") +
  
  scale_x_date(
    expand = c(0,0),               # remove excess x-axis space below and after case bars
    date_breaks = "3 weeks",       # Monday every 3 weeks
    date_minor_breaks = "week",    # Monday weeks
    date_labels = "%a\n%d\n%b\n'%y")+  # label format
  
  scale_y_continuous(
    expand = c(0,0))+              # remove excess space under x-axis, make flush
  
  labs(
    title = "MISALIGNED",
    subtitle = "! CAUTION: 7-day bars start Thursdays at first case\nDate labels and gridlines on Mondays\nNote how ticks don't align with bars")



# 7-day bins + Months
#####################
ggplot(central_data) +
  geom_histogram(
    mapping = aes(x = date_onset),
    binwidth = 7,
    color = "darkblue",
    fill = "lightblue") +
  
  scale_x_date(
    expand = c(0,0),                  # remove excess x-axis space below and after case bars
    date_breaks = "months",           # 1st of month
    date_minor_breaks = "week",       # Monday weeks
    date_labels = "%a\n%d %b\n%Y")+    # label format
  
  scale_y_continuous(
    expand = c(0,0))+                # remove excess space under x-axis, make flush 
  
  labs(
    title = "MISALIGNED",
    subtitle = "! CAUTION: 7-day bars start Thursdays with first case\nMajor gridlines and date labels at 1st of each month\nMinor gridlines weekly on Mondays\nNote uneven spacing of some gridlines and ticks unaligned with bars")


# TOTAL MONDAY ALIGNMENT: specify manual bin breaks to be mondays
#################################################################
ggplot(central_data) + 
  geom_histogram(
    mapping = aes(x = date_onset),
    
    # histogram breaks set to 7 days beginning Monday before first case
    breaks = weekly_breaks_central,    # defined earlier in this page
    
    color = "darkblue",
    
    fill = "lightblue") + 
  
  scale_x_date(
    expand = c(0,0),                   # remove excess x-axis space below and after case bars
    date_breaks = "4 weeks",           # Monday every 4 weeks
    date_minor_breaks = "week",        # Monday weeks 
    date_labels = "%a\n%d %b\n%Y")+      # label format
  
  scale_y_continuous(
    expand = c(0,0))+                # remove excess space under x-axis, make flush 
  
  labs(
    title = "ALIGNED Mondays",
    subtitle = "7-day bins manually set to begin Monday before first case (28 Apr)\nDate labels and gridlines on Mondays as well")


# TOTAL MONDAY ALIGNMENT WITH MONTHS LABELS:
############################################
ggplot(central_data) + 
  geom_histogram(
    mapping = aes(x = date_onset),
    
    # histogram breaks set to 7 days beginning Monday before first case
    breaks = weekly_breaks_central,            # defined earlier in this page
    
    color = "darkblue",
    
    fill = "lightblue") + 
  
  scale_x_date(
    expand = c(0,0),                   # remove excess x-axis space below and after case bars
    date_breaks = "months",            # Monday every 4 weeks
    date_minor_breaks = "week",        # Monday weeks 
    date_labels = "%b\n%Y")+          # label format
  
  scale_y_continuous(
    expand = c(0,0))+                # remove excess space under x-axis, make flush 
  
  theme(panel.grid.major = element_blank())+  # Remove major gridlines (fall on 1st of month)
          
  labs(
    title = "ALIGNED Mondays with MONTHLY labels",
    subtitle = "7-day bins manually set to begin Monday before first case (28 Apr)\nDate labels on 1st of Month\nMonthly major gridlines removed")


# TOTAL SUNDAY ALIGNMENT: specify manual bin breaks AND labels to be Sundays
############################################################################
ggplot(central_data) + 
  geom_histogram(
    mapping = aes(x = date_onset),
    
    # histogram breaks set to 7 days beginning Sunday before first case
    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7),
                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7),
                      by   = "7 days"),
    
    color = "darkblue",
    
    fill = "lightblue") + 
  
  scale_x_date(
    expand = c(0,0),
    # date label breaks and major gridlines set to every 3 weeks beginning Sunday before first case
    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7),
                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7),
                      by   = "3 weeks"),
    
    # minor gridlines set to weekly beginning Sunday before first case
    minor_breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7),
                            to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7),
                            by   = "7 days"),
    
    date_labels = "%a\n%d\n%b\n'%y")+  # label format
  
  scale_y_continuous(
    expand = c(0,0))+                # remove excess space under x-axis, make flush 
  
  labs(title = "ALIGNED Sundays",
       subtitle = "7-day bins manually set to begin Sunday before first case (27 Apr)\nDate labels and gridlines manually set to Sundays as well")

```





### Toplu veri {.unnumbered} 

Genellikle bir satır listesi yerine tesislerden, bölgelerden vb. toplu sayımlarla başlarsınız. `ggplot()` ile bir salgın eğrisi oluşturabilirsiniz ancak kod biraz farklı olacaktır. Bu bölüm, veri hazırlama bölümünde daha önce içe aktarılan `count_data` veri setini kullanacaktır. Bu veri seti, günlük hastane sayımlarına göre toplanan `linelist`'dir. İlk 50 satır aşağıda gösterilmiştir.

```{r message=FALSE, warning=F, echo=F}
# display the linelist data as a table
DT::datatable(head(count_data, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


####	Komut Dosyası Çizimi günlük sayımlar {.unnumbered}  

Bu *günlük sayımlardan* günlük bir salgın eğrisi çizebiliriz. İşte koddaki farklar:  

* Estetik haritalama `aes()` içinde, sayımlar sütunu olarak `y = ` belirtin (bu durumda, sütun adı `n_cases` 'dir).
* `stat = "identity"` argümanını `geom_histogram()`içine ekleyin; bu, çubuk yüksekliğinin varsayılan olarak satır sayısı değil, `y = ` değeri olması gerektiğini belirtir.  
* Çubuklar arasında dikey beyaz çizgileri önlemek için `width = ` argümanını ekleyin. 1'e ayarlanmış günlük veriler için 7'ye ayarlanmış haftalık sayım verileri için Aylık sayım verileri için beyaz çizgiler bir sorundur (her ayın farklı gün sayısı vardır) - x ekseninizi kategorik sıralı bir faktöre (aylar) dönüştürmeyi ve `geom_col()`kullanmayı düşünün.


```{r, message=FALSE, warning=F}
ggplot(data = count_data)+
  geom_histogram(
   mapping = aes(x = date_hospitalisation, y = n_cases),
   stat = "identity",
   width = 1)+                # for daily counts, set width = 1 to avoid white space between bars
  labs(
    x = "Date of report", 
    y = "Number of cases",
    title = "Daily case incidence, from daily count data")
```

####	Haftalık sayıların çizilmesi {.unnumbered}

Verileriniz zaten haftaya göre vaka sayılarıysa, bu veri kümesine benzeyebilirler (`count_data_weekly` olarak adlandırılır):

```{r, warning=F, message=F, echo=F}
# Create weekly dataset with epiweek column
count_data_weekly <- count_data %>%
  mutate(epiweek = lubridate::floor_date(date_hospitalisation, "week")) %>% 
  group_by(hospital, epiweek, .drop=F) %>% 
  summarize(n_cases_weekly = sum(n_cases, na.rm=T))   
```

`count_data_weekly` 'nin ilk 50 satırı aşağıda gösterilmiştir. Sayıların haftalar halinde toplandığını görebilirsiniz. Her hafta, haftanın ilk gününe göre görüntülenir (varsayılan olarak Pazartesi).

```{r message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(count_data_weekly, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Şimdi `x = ` salgın haftası sütunu olacak şekilde çizin. Estetik haritalamaya  `y = ` sayı sütununu eklemeyi ve yukarıda açıklandığı gibi `stat = "identity"` eklemeyi unutmayın.

```{r, warning=F, message=F}
ggplot(data = count_data_weekly)+
  
  geom_histogram(
    mapping = aes(
      x = epiweek,           # x-axis is epiweek (as class Date)
      y = n_cases_weekly,    # y-axis height in the weekly case counts
      group = hospital,      # we are grouping the bars and coloring by hospital
      fill = hospital),
    stat = "identity")+      # this is also required when plotting count data
     
  # labels for x-axis
  scale_x_date(
    date_breaks = "2 months",      # labels every 2 months 
    date_minor_breaks = "1 month", # gridlines every month
    date_labels = '%b\n%Y')+       #labeled by month with year below
     
  # Choose color palette (uses RColorBrewer package)
  scale_fill_brewer(palette = "Pastel2")+ 
  
  theme_minimal()+
  
  labs(
    x = "Week of onset", 
    y = "Weekly case incidence",
    fill = "Hospital",
    title = "Weekly case incidence, from aggregated count data by hospital")
```




###	Hareketli ortalamalar {.unnumbered}

Ayrıntılı bir açıklama ve çeşitli seçenekler için [Hareketli ortalamalar] sayfasına bakın. Aşağıda, **slider** paketi ile hareketli ortalamaları hesaplamak için bir seçenek bulunmaktadır. Bu yaklaşımda, *hareketli ortalama, çizimden önce veri setinde hesaplanır*:

1) Verileri gerektiği gibi sayımlar halinde toplayın (günlük, haftalık vb.) (bkz. [Verileri gruplandırma] sayfası).  
2) **slider** paketinden `slide_index()` ile oluşturulan hareketli ortalamayı tutmak için yeni bir sütun oluşturun.  
3) Hareketli ortalamayı, salgın eğrisi histogramının üstüne (sonra) bir `geom_line()`olarak çizin.

Yararlı çevrimiçi [**slider** paketi için belirtece](https://cran.r-project.org/web/packages/slider/vignettes/slider.html) bakın.


```{r, warning=F, message=F}
# load package
pacman::p_load(slider)  # slider used to calculate rolling averages

# make dataset of daily counts and 7-day moving average
#######################################################
ll_counts_7day <- linelist %>%    # begin with linelist
  
  ## count cases by date
  count(date_onset, name = "new_cases") %>%   # name new column with counts as "new_cases"
  drop_na(date_onset) %>%                     # remove cases with missing date_onset
  
  ## calculate the average number of cases in 7-day window
  mutate(
    avg_7day = slider::slide_index(    # create new column
      new_cases,                       # calculate based on value in new_cases column
      .i = date_onset,                 # index is date_onset col, so non-present dates are included in window 
      .f = ~mean(.x, na.rm = TRUE),    # function is mean() with missing values removed
      .before = 6,                     # window is the day and 6-days before
      .complete = FALSE),              # must be FALSE for unlist() to work in next step
    avg_7day = unlist(avg_7day))       # convert class list to class numeric


# plot
######
ggplot(data = ll_counts_7day) +  # begin with new dataset defined above 
    geom_histogram(              # create epicurve histogram
      mapping = aes(
        x = date_onset,          # date column as x-axis
        y = new_cases),          # height is number of daily new cases
        stat = "identity",       # height is y value
        fill="#92a8d1",          # cool color for bars
        colour = "#92a8d1",      # same color for bar border
        )+ 
    geom_line(                   # make line for rolling average
      mapping = aes(
        x = date_onset,          # date column for x-axis
        y = avg_7day,            # y-value set to rolling average column
        lty = "7-day \nrolling avg"), # name of line in legend
      color="red",               # color of line
      size = 1) +                # width of line
    scale_x_date(                # date scale
      date_breaks = "1 month",
      date_labels = '%d/%m',
      expand = c(0,0)) +
    scale_y_continuous(          # y-axis scale
      expand = c(0,0),
      limits = c(0, NA)) +       
    labs(
      x="",
      y ="Number of confirmed cases",
      fill = "Legend")+ 
    theme_minimal()+
    theme(legend.title = element_blank())  # removes title of legend
```




###	Fasetleme/küçük-katlar {.unnumbered}

Diğer ggplot'larda olduğu gibi, fasetli grafikler ("küçük katlar") oluşturabilirsiniz. Bu el kitabının [ggplot ipuçları] sayfasında açıklandığı gibi, ya `facet_wrap()` ya da `facet_grid()`kullanabilirsiniz. Burada `facet_wrap()`ile gösteriyoruz. Salgın eğrileri için, `facet_wrap()`genellikle daha kolaydır, çünkü muhtemelen yalnızca bir sütunda fasetleme yapmanız gerekir.

Genel sözdizimi `facet_wrap(rows ~ cols)`şeklindedir; burada yaklaşık işaretinin  (~) solunda fasetli grafiğin "satırları"na yayılacak bir sütunun adı ve yaklaşık işaretinin sağında, fasetli grafiğin “sütunlarına” yayılacak bir sütunun adı bulunur. En basitinden, yaklaşık işaretinin sağındaki bir sütun adı kullanın: `facet_wrap(~age_cat)`.


**Serbest eksenler**  
Her bir faset için eksenlerin ölçeklerinin aynı boyutlara "sabit" (varsayılan) veya "serbest" (yani, faset içindeki verilere göre değişecekleri) olup olmadığına karar vermeniz gerekecektir. Bunu, "free_x" veya "free_y" veya "free" belirterek `facet_wrap()` içindeki `scales = ` argümanı ile yapın.


**Fasetlerin sütun ve satır sayısı**  
Bu, `facet_wrap()`içinde `ncol = ` ve `nrow = ` ile belirtilebilir.


**Panellerin sırası**  
Görünüm sırasını değiştirmek için, fasetleri oluşturmak için kullanılan faktör sütununun düzeylerinin temel sırasını değiştirin.  


**Estetik**  
Yazı tipi boyutu ve yüzü, şerit rengi vb., `theme()` aracılığıyla aşağıdaki gibi argümanlarla değiştirilebilir:

* `strip.text = element_text()` (boyut, renk, yüz, açı…)
* `strip.background = element_rect()` (ör. element_rect(dolgu=“gri”))  
* `strip.position = ` (("alt", "üst", "sol" veya "sağ" şeridin konumu) 


**Şerit etiketleri**  
Faset grafiklerinin etiketleri, bir faktör olarak sütunun “etiketleri” aracılığıyla veya bir “etiketleyici” kullanılarak değiştirilebilir.  

**ggplot2**'deki `as_labeller()`işlevini kullanarak böyle bir etiketleyici yapın. Ardından, etiketleyiciyi, aşağıda gösterildiği gibi `facet_wrap()`öğesinin `labeller = `  argümanına yerleştirin.

```{r, class.source = 'fold-show'}
my_labels <- as_labeller(c(
     "0-4"   = "Ages 0-4",
     "5-9"   = "Ages 5-9",
     "10-14" = "Ages 10-14",
     "15-19" = "Ages 15-19",
     "20-29" = "Ages 20-29",
     "30-49" = "Ages 30-49",
     "50-69" = "Ages 50-69",
     "70+"   = "Over age 70"))
```

**Örnek bir fasetli grafik ** - `age_cat` sütunu ile fasetli.


```{r, warning=F, message=F}
# make plot
###########
ggplot(central_data) + 
  
  geom_histogram(
    mapping = aes(
      x = date_onset,
      group = age_cat,
      fill = age_cat),    # arguments inside aes() apply by group
      
    color = "black",      # arguments outside aes() apply to all data
        
    # histogram breaks
    breaks = weekly_breaks_central)+  # pre-defined date vector (see earlier in this page)
                      
  # The labels on the x-axis
  scale_x_date(
    expand            = c(0,0),         # remove excess x-axis space below and after case bars
    date_breaks       = "2 months",     # labels appear every 2 months
    date_minor_breaks = "1 month",      # vertical lines appear every 1 month 
    date_labels       = "%b\n'%y")+     # date labels format
  
  # y-axis
  scale_y_continuous(expand = c(0,0))+                       # removes excess y-axis space between bottom of bars and the labels
  
  # aesthetic themes
  theme_minimal()+                                           # a set of themes to simplify plot
  theme(
    plot.caption = element_text(face = "italic", hjust = 0), # caption on left side in italics
    axis.title = element_text(face = "bold"),
    legend.position = "bottom",
    strip.text = element_text(face = "bold", size = 10),
    strip.background = element_rect(fill = "grey"))+         # axis titles in bold
  
  # create facets
  facet_wrap(
    ~age_cat,
    ncol = 4,
    strip.position = "top",
    labeller = my_labels)+             
  
  # labels
  labs(
    title    = "Weekly incidence of cases, by age category",
    subtitle = "Subtitle",
    fill     = "Age category",                                      # provide new title for legend
    x        = "Week of symptom onset",
    y        = "Weekly incident cases reported",
    caption  = stringr::str_glue("n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown"))
```

Etiketleyiciler hakkında daha fazla bilgi için bu [bağlantıya](https://ggplot2.tidyverse.org/reference/labellers.html) bakın.  




####	Faset arka planında toplam salgın {.unnumbered}

Her fasetin arka planında toplam salgını göstermek için, ggplot'a boş parantezlerle `gghighlight()` işlevini ekleyin. Bu, **gghighlight** paketinden bir komuttur. Tüm yönlerdeki maksimum y ekseninin artık tüm salgının zirvesine dayandığını unutmayın. [ggplot ipuçları] sayfasında bu paketin daha fazla örneği mevcuttur.

```{r, warning=F, message=F}
ggplot(central_data) + 
  
  # epicurves by group
  geom_histogram(
    mapping = aes(
      x = date_onset,
      group = age_cat,
      fill = age_cat),  # arguments inside aes() apply by group
    
    color = "black",    # arguments outside aes() apply to all data
    
    # histogram breaks
    breaks = weekly_breaks_central)+     # pre-defined date vector (see top of ggplot section)                
  
  # add grey epidemic in background to each facet
  gghighlight::gghighlight()+
  
  # labels on x-axis
  scale_x_date(
    expand            = c(0,0),         # remove excess x-axis space below and after case bars
    date_breaks       = "2 months",     # labels appear every 2 months
    date_minor_breaks = "1 month",      # vertical lines appear every 1 month 
    date_labels       = "%b\n'%y")+     # date labels format
  
  # y-axis
  scale_y_continuous(expand = c(0,0))+  # removes excess y-axis space below 0
  
  # aesthetic themes
  theme_minimal()+                                           # a set of themes to simplify plot
  theme(
    plot.caption = element_text(face = "italic", hjust = 0), # caption on left side in italics
    axis.title = element_text(face = "bold"),
    legend.position = "bottom",
    strip.text = element_text(face = "bold", size = 10),
    strip.background = element_rect(fill = "white"))+        # axis titles in bold
  
  # create facets
  facet_wrap(
    ~age_cat,                          # each plot is one value of age_cat
    ncol = 4,                          # number of columns
    strip.position = "top",            # position of the facet title/strip
    labeller = my_labels)+             # labeller defines above
  
  # labels
  labs(
    title    = "Weekly incidence of cases, by age category",
    subtitle = "Subtitle",
    fill     = "Age category",                                      # provide new title for legend
    x        = "Week of symptom onset",
    y        = "Weekly incident cases reported",
    caption  = stringr::str_glue("n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown"))
```


####	Veri içeren bir faset {.unnumbered}  

Tüm verileri içeren bir model kutusuna sahip olmak istiyorsanız, tüm veri setini çoğaltın ve kopyaları tek bir model değeri olarak değerlendirin. Aşağıdaki bir "yardımcı" işlevi `CreateAllFacet()` bu konuda yardımcı olabilir (bu [blog yazısı](https://stackoverflow.com/questions/18933575/easily-add-an-all-facet-to-facet-wrap-in-ggplot2) sayesinde). Çalıştırıldığında, satır sayısı iki katına çıkar ve yinelenen satırların "tümü" değerine sahip olacağı ve orijinal satırların faset sütununun orijinal değerine sahip olacağı, `facet` adlı yeni bir sütun olacaktır. Şimdi sadece `facet` sütununda faset yapmanız gerekiyor.

Kullanabilmeniz için çalıştırılması gereken yardımcı fonksiyon buradadır:  

```{r}
# Define helper function
CreateAllFacet <- function(df, col){
     df$facet <- df[[col]]
     temp <- df
     temp$facet <- "all"
     merged <-rbind(temp, df)
     
     # ensure the facet value is a factor
     merged[[col]] <- as.factor(merged[[col]])
     
     return(merged)
}
```

Şimdi yardımcı işlevi veri setine `age_cat` sütununda uygulayın:  

```{r}
# Create dataset that is duplicated and with new column "facet" to show "all" age categories as another facet level
central_data2 <- CreateAllFacet(central_data, col = "age_cat") %>%
  
  # set factor levels
  mutate(facet = fct_relevel(facet, "all", "0-4", "5-9",
                             "10-14", "15-19", "20-29",
                             "30-49", "50-69", "70+"))

# check levels
table(central_data2$facet, useNA = "always")
```

`ggplot()` komutundaki dikkate değer değişiklikler şunlardır:  

* Kullanılan veriler artık central_data2'dir (yeni "facet" sütunu ile satırları ikiye katlayın).
* Etiketleyici kullanılıyorsa güncellenmesi gerekecek.  
* ●	İsteğe bağlı: dikey olarak yığılmış yüzeyler elde etmek için: model sütunu denklemin satır tarafına taşınır ve sağdaki "." ile değiştirilir.  (`facet_wrap(facet~.)`) ve `ncol = 1`.  Kaydedilmiş png çizim görüntüsünün genişliğini ve yüksekliğini de ayarlamanız gerekebilir ([ggplot ipuçlarında] `ggsave()`'e bakın).

```{r, fig.height=12, fig.width=5, warning=F, message=F}
ggplot(central_data2) + 
  
  # actual epicurves by group
  geom_histogram(
        mapping = aes(
          x = date_onset,
          group = age_cat,
          fill = age_cat),  # arguments inside aes() apply by group
        color = "black",    # arguments outside aes() apply to all data
        
        # histogram breaks
        breaks = weekly_breaks_central)+    # pre-defined date vector (see top of ggplot section)
                     
  # Labels on x-axis
  scale_x_date(
    expand            = c(0,0),         # remove excess x-axis space below and after case bars
    date_breaks       = "2 months",     # labels appear every 2 months
    date_minor_breaks = "1 month",      # vertical lines appear every 1 month 
    date_labels       = "%b\n'%y")+     # date labels format
  
  # y-axis
  scale_y_continuous(expand = c(0,0))+  # removes excess y-axis space between bottom of bars and the labels
  
  # aesthetic themes
  theme_minimal()+                                           # a set of themes to simplify plot
  theme(
    plot.caption = element_text(face = "italic", hjust = 0), # caption on left side in italics
    axis.title = element_text(face = "bold"),
    legend.position = "bottom")+               
  
  # create facets
  facet_wrap(facet~. ,                            # each plot is one value of facet
             ncol = 1)+            

  # labels
  labs(title    = "Weekly incidence of cases, by age category",
       subtitle = "Subtitle",
       fill     = "Age category",                                      # provide new title for legend
       x        = "Week of symptom onset",
       y        = "Weekly incident cases reported",
       caption  = stringr::str_glue("n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown"))
```








## Geçici veriler   


Salgın eğrilerinde gösterilen en son veriler genellikle geçici olarak işaretlenmeli veya raporlama gecikmelerine tabi olmalıdır. Bu, belirli sayıda gün boyunca dikey bir çizgi ve/veya dikdörtgen eklenerek yapılabilir. İşte iki seçenek:

1) `annotate()` kullanın:  
    + Bir satır için `annotate(geom = "segment")` kullanın. `x`, `xend`, `y`, ve `yend`'i temin edin. Boyutu, çizgi tipini (`lty`) ve rengi ayarlayın.  
    + Dikdörtgen için `annotate(geom = "rect")` kullanın. xmin/xmax/ymin/ymax'ı temin edin. Rengi ve alfayı ayarlayın.  
2) Verileri geçici duruma göre gruplandırın ve bu çubukları farklı şekilde renklendirin. 

<span style="color: orange;">**_DİKKAT:_** Bir dikdörtgen çizmek için `geom_rect()`'i deneyebilirsiniz, ancak şeffaflığı ayarlamak bir satır listesi bağlamında çalışmaz. Bu işlev, her gözlem/sıra için bir dikdörtgeni kaplar!. Çok düşük bir alfa (ör. 0.01) veya başka bir yaklaşım kullanın. </span>

### `annotate()` kullanma  {.unnumbered}

* `annotate(geom = "rect")` içinde, `xmin` ve `xmax` argümanlarına Date sınıfının girdileri verilmelidir.  
* Bu veriler haftalık çubuklar halinde toplandığından ve son çubuk, son veri noktasından sonraki Pazartesi gününe kadar uzandığından, gölgeli bölgenin 4 haftayı kapsıyor gibi görünebileceğini unutmayın.  
* İşte bir `annotate()` [online örneği](https://ggplot2.tidyverse.org/reference/annotate.html).


```{r, warning=F, message=F}
ggplot(central_data) + 
  
  # histogram
  geom_histogram(
    mapping = aes(x = date_onset),
    
    breaks = weekly_breaks_central,   # pre-defined date vector - see top of ggplot section
    
    color = "darkblue",
    
    fill = "lightblue") +

  # scales
  scale_y_continuous(expand = c(0,0))+
  scale_x_date(
    expand = c(0,0),                   # remove excess x-axis space below and after case bars
    date_breaks = "1 month",           # 1st of month
    date_minor_breaks = "1 month",     # 1st of month
    date_labels = "%b\n'%y")+          # label format
  
  # labels and theme
  labs(
    title = "Using annotate()\nRectangle and line showing that data from last 21-days are tentative",
    x = "Week of symptom onset",
    y = "Weekly case indicence")+ 
  theme_minimal()+
  
  # add semi-transparent red rectangle to tentative data
  annotate(
    "rect",
    xmin  = as.Date(max(central_data$date_onset, na.rm = T) - 21), # note must be wrapped in as.Date()
    xmax  = as.Date(Inf),                                          # note must be wrapped in as.Date()
    ymin  = 0,
    ymax  = Inf,
    alpha = 0.2,          # alpha easy and intuitive to adjust using annotate()
    fill  = "red")+
  
  # add black vertical line on top of other layers
  annotate(
    "segment",
    x     = max(central_data$date_onset, na.rm = T) - 21, # 21 days before last data
    xend  = max(central_data$date_onset, na.rm = T) - 21, 
    y     = 0,         # line begins at y = 0
    yend  = Inf,       # line to top of plot
    size  = 2,         # line size
    color = "black",
    lty   = "solid")+   # linetype e.g. "solid", "dashed"

  # add text in rectangle
  annotate(
    "text",
    x = max(central_data$date_onset, na.rm = T) - 15,
    y = 15,
    label = "Subject to reporting delays",
    angle = 90)
```


Aynı siyah dikey çizgi aşağıdaki kodla da elde edilebilir, ancak `geom_vline()` fonksiyonunu kullanarak yüksekliği kontrol etme yeteneğinizi kaybedersiniz:  

```{r, eval=F}
geom_vline(xintercept = max(central_data$date_onset, na.rm = T) - 21,
           size = 2,
           color = "black")
```



###	Çubukların rengi {.unnumbered}  

Alternatif bir yaklaşım, geçici veri çubuklarının rengini veya görüntüsünü ayarlamak olabilir. Veri hazırlama aşamasında yeni bir sütun oluşturabilir ve bunu, geçici verilerin `aes(fill = )`değeri diğer çubuklardan farklı bir renk veya alfa olacak şekilde verileri gruplamak için kullanabilirsiniz. 

```{r, message=F, warning=F}
# add column
############
plot_data <- central_data %>% 
  mutate(tentative = case_when(
    date_onset >= max(date_onset, na.rm=T) - 7 ~ "Tentative", # tenative if in last 7 days
    TRUE                                       ~ "Reliable")) # all else reliable

# plot
######
ggplot(plot_data, aes(x = date_onset, fill = tentative)) + 
  
  # histogram
  geom_histogram(
    breaks = weekly_breaks_central,   # pre-defined data vector, see top of ggplot page
    color = "black") +

  # scales
  scale_y_continuous(expand = c(0,0))+
  scale_fill_manual(values = c("lightblue", "grey"))+
  scale_x_date(
    expand = c(0,0),                   # remove excess x-axis space below and after case bars
    date_breaks = "3 weeks",           # Monday every 3 weeks
    date_minor_breaks = "week",        # Monday weeks 
    date_labels = "%d\n%b\n'%y")+      # label format
  
  # labels and theme
  labs(title = "Show days that are tentative reporting",
    subtitle = "")+ 
  theme_minimal()+
  theme(legend.title = element_blank())                 # remove title of legend
  
```


## Çok seviyeli tarih etiketleri  

*Alt etiket düzeylerini çoğaltmadan* çok düzeyli tarih etiketleri (ör. ay ve yıl) istiyorsanız, aşağıdaki yaklaşımlardan birini göz önünde bulundurun:  

Unutmayın - her bir etiketin parçalarını aşağıdaki yeni bir satıra koymak için `date_labels` veya `labels` argümanları *içinde* `\n` gibi araçları kullanabilirsiniz. Bununla birlikte, aşağıdaki kod, daha düşük bir satırda ve *yalnızca bir kez* yıllar veya aylar (örneğin) almanıza yardımcı olur. Aşağıdaki kodla ilgili birkaç not:

* Vaka sayıları estetik nedenlerle haftalar halinde toplanır. Ayrıntılar için salgın eğrisi sayfasına (toplanmış veri sekmesi) bakın..  
* Aşağıdaki yüzey oluşturma yaklaşımı histogramlarla iyi çalışmadığından, histogram yerine `geom_area()`çizgisi kullanılır.  


**Haftalık sayımlara toplayın**

```{r out.width = c('50%', '50%'), fig.show='hold', warning=F, message=F}

# Create dataset of case counts by week
#######################################
central_weekly <- linelist %>%
  filter(hospital == "Central Hospital") %>%   # filter linelist
  mutate(week = lubridate::floor_date(date_onset, unit = "weeks")) %>%  
  count(week) %>%                              # summarize weekly case counts
  drop_na(week) %>%                            # remove cases with missing onset_date
  complete(                                    # fill-in all weeks with no cases reported
    week = seq.Date(
      from = min(week),   
      to   = max(week),
      by   = "week"),
    fill = list(n = 0))                        # convert new NA values to 0 counts
```

**Grafik yapın**  

```{r, warning=F, message=F}
# plot with box border on year
##############################
ggplot(central_weekly) +
  geom_area(aes(x = week, y = n),    # make line, specify x and y
            stat = "identity") +             # because line height is count number
  scale_x_date(date_labels="%b",             # date label format show month 
               date_breaks="month",          # date labels on 1st of each month
               expand=c(0,0)) +              # remove excess space on each end
  scale_y_continuous(
    expand  = c(0,0))+                       # remove excess space below x-axis
  facet_grid(~lubridate::year(week), # facet on year (of Date class column)
             space="free_x",                
             scales="free_x",                # x-axes adapt to data range (not "fixed")
             switch="x") +                   # facet labels (year) on bottom
  theme_bw() +
  theme(strip.placement = "outside",         # facet labels placement
        strip.background = element_rect(fill = NA, # facet labels no fill grey border
                                        colour = "grey50"),
        panel.spacing = unit(0, "cm"))+      # no space between facet panels
  labs(title = "Nested year labels, grey label border")


# plot with no box border on year
#################################
ggplot(central_weekly,
       aes(x = week, y = n)) +              # establish x and y for entire plot
  geom_line(stat = "identity",              # make line, line height is count number
            color = "#69b3a2") +            # line color
  geom_point(size=1, color="#69b3a2") +     # make points at the weekly data points
  geom_area(fill = "#69b3a2",               # fill area below line
            alpha = 0.4)+                   # fill transparency
  scale_x_date(date_labels="%b",            # date label format show month 
               date_breaks="month",         # date labels on 1st of each month
               expand=c(0,0)) +             # remove excess space
  scale_y_continuous(
    expand  = c(0,0))+                      # remove excess space below x-axis
  facet_grid(~lubridate::year(week),        # facet on year (of Date class column)
             space="free_x",                
             scales="free_x",               # x-axes adapt to data range (not "fixed")
             switch="x") +                  # facet labels (year) on bottom
  theme_bw() +
  theme(strip.placement = "outside",                     # facet label placement
          strip.background = element_blank(),            # no facet lable background
          panel.grid.minor.x = element_blank(),          
          panel.border = element_rect(colour="grey40"),  # grey border to facet PANEL
          panel.spacing=unit(0,"cm"))+                   # No space between facet panels
  labs(title = "Nested year labels - points, shaded, no label border")
```

Yukarıdaki teknikler [bu](https://stackoverflow.com/questions/44616530/axis-labels-on-two-lines-with-nested-x-variables-year-below-months) ve stackoverflow.com'daki [bu](https://stackoverflow.com/questions/20571306/multi-row-x-axis-labels-in-ggplot-line-chart) gönderiden uyarlanmıştır.  






<!-- ======================================================= -->
## Çift eksen { }  

Veri görselleştirme topluluğu içinde ikili eksenlerin geçerliliği hakkında şiddetli tartışmalar olmasına rağmen, birçok salgın süpervizör hala ikinci bir eksenle kaplanmış yüzde içeren bir salgın eğrisi veya benzer bir grafik görmek istiyor. Bu, [ggplot ipuçları] sayfasında daha kapsamlı bir şekilde tartışılmıştır, ancak **cowplot** yöntemini kullanan bir örnek aşağıda gösterilmiştir:

* İki farklı grafik yapılır ve daha sonra **cowplot** paketi ile birleştirilir.  
* Grafikler tam olarak aynı x eksenine (belirlenen sınırlar) sahip olmalıdır, aksi takdirde veriler ve etiketler hizalanmayacaktır.  
* Her biri `theme_cowplot()`kullanır ve birinin y ekseni grafiğin sağ tarafına hareket ettirilir.  

```{r, warning=F, message=F}
#load package
pacman::p_load(cowplot)

# Make first plot of epicurve histogram
#######################################
plot_cases <- linelist %>% 
  
  # plot cases per week
  ggplot()+
  
  # create histogram  
  geom_histogram(
    
    mapping = aes(x = date_onset),
    
    # bin breaks every week beginning monday before first case, going to monday after last case
    breaks = weekly_breaks_all)+  # pre-defined vector of weekly dates (see top of ggplot section)
        
  # specify beginning and end of date axis to align with other plot
  scale_x_date(
    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # min/max of the pre-defined weekly breaks of histogram
  
  # labels
  labs(
      y = "Daily cases",
      x = "Date of symptom onset"
    )+
  theme_cowplot()


# make second plot of percent died per week
###########################################
plot_deaths <- linelist %>%                        # begin with linelist
  group_by(week = floor_date(date_onset, "week")) %>%  # create week column
  
  # summarise to get weekly percent of cases who died
  summarise(n_cases = n(),
            died = sum(outcome == "Death", na.rm=T),
            pct_died = 100*died/n_cases) %>% 
  
  # begin plot
  ggplot()+
  
  # line of weekly percent who died
  geom_line(                                # create line of percent died
    mapping = aes(x = week, y = pct_died),  # specify y-height as pct_died column
    stat = "identity",                      # set line height to the value in pct_death column, not the number of rows (which is default)
    size = 2,
    color = "black")+
  
  # Same date-axis limits as the other plot - perfect alignment
  scale_x_date(
    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # min/max of the pre-defined weekly breaks of histogram
  
  
  # y-axis adjustments
  scale_y_continuous(                # adjust y-axis
    breaks = seq(0,100, 10),         # set break intervals of percent axis
    limits = c(0, 100),              # set extent of percent axis
    position = "right")+             # move percent axis to the right
  
  # Y-axis label, no x-axis label
  labs(x = "",
       y = "Percent deceased")+      # percent axis label
  
  theme_cowplot()                   # add this to make the two plots merge together nicely
```

Şimdi iki grafiiği kaplamak için **cowplot** kullanın. x ekseni hizalamasına, y ekseninin yanına ve `theme_cowplot()`kullanımına dikkat edin.  

```{r, warning=F, message=F}
aligned_plots <- cowplot::align_plots(plot_cases, plot_deaths, align="hv", axis="tblr")
ggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])
```




## Kümülatif İnsidans {}

Not: **incidence2** kullanıyorsanız, basit bir fonksiyonla kümülatif insidansı nasıl üretebileceğinize ilişkin bölüme bakın. Bu sayfa, kümülatif insidansın nasıl hesaplanacağını ve `ggplot()`ile nasıl çizileceğini ele alacaktır.  

Bir vaka satır listesiyle başlıyorsanız, R **tabanından** `cumsum()` kullanarak bir salgındaki günlük kümülatif vaka sayısını içeren yeni bir sütun oluşturun:   

```{r}
cumulative_case_counts <- linelist %>% 
  count(date_onset) %>%                # count of rows per day (returned in column "n")   
  mutate(                         
    cumulative_cases = cumsum(n)       # new column of the cumulative number of rows at each date
    )
```

İlk 10 satır aşağıda gösterilmiştir:  

```{r message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(cumulative_case_counts, 10), rownames = FALSE, options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )
```



Bu kümülatif sütun daha sonra `geom_line()`kullanılarak `date_onset`'e göre çizilebilir:

```{r, warning=F, message=F}
plot_cumulative <- ggplot()+
  geom_line(
    data = cumulative_case_counts,
    aes(x = date_onset, y = cumulative_cases),
    size = 2,
    color = "blue")

plot_cumulative
```


Ayrıca yukarıda ve [ggplot ipuçları] sayfasında açıklanan **cowplot** yöntemi kullanılarak çift eksenli salgın eğrisi üzerine bindirilebilir:

```{r, warning=F, message=F}
#load package
pacman::p_load(cowplot)

# Make first plot of epicurve histogram
plot_cases <- ggplot()+
  geom_histogram(          
    data = linelist,
    aes(x = date_onset),
    binwidth = 1)+
  labs(
    y = "Daily cases",
    x = "Date of symptom onset"
  )+
  theme_cowplot()

# make second plot of cumulative cases line
plot_cumulative <- ggplot()+
  geom_line(
    data = cumulative_case_counts,
    aes(x = date_onset, y = cumulative_cases),
    size = 2,
    color = "blue")+
  scale_y_continuous(
    position = "right")+
  labs(x = "",
       y = "Cumulative cases")+
  theme_cowplot()+
  theme(
    axis.line.x = element_blank(),
    axis.text.x = element_blank(),
    axis.title.x = element_blank(),
    axis.ticks = element_blank())
```

Şimdi iki grafiği kaplamak için **cowplot** kullanın. x ekseni hizalamasına, y ekseninin kenarına ve `theme_cowplot()`kullanımına dikkat edildi.  

```{r, warning=F, message=F}
aligned_plots <- cowplot::align_plots(plot_cases, plot_cumulative, align="hv", axis="tblr")
ggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])
```


<!-- ======================================================= -->
## Kaynaklar { }








```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/epicurves.Rmd-->


# Demografik piramidler ve likert ölçekler {}  


```{r, out.width = c('50%', '50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "pop_pyramid_baseline.png"))

knitr::include_graphics(here::here("images", "likert.png"))
```


Demografik piramitler, yaş ve cinsiyet dağılımlarını göstermek için kullanışlıdır. Benzer kod, Likert tarzı anket sorularının sonuçlarını görselleştirmek için de kullanılabilir (örneğin, "Kesinlikle katılıyorum", "Katılıyorum", "Nötr", "Katılıyorum", "Kesinlikle katılmıyorum"). Bu sayfada aşağıdaki başlıkları ele alacağız: 

* **apyramid** paketini kullanarak hızlı ve kolay piramit grafiği oluşturma 
* `ggplot()` kullanarak daha fazla özelleştirilebilir piramit grafiği oluşturma
* Piramidin arka planında "temel" demografik bilgileri görüntüleme 
* Diğer veri türlerini görselleştirmek için piramit tarzı grafikler kullanma (ör. **Likert tarzı** anket sorularına verilen yanıtlar)


<!-- ======================================================= -->
## Hazırlık {}

### Paketleri yükleme {.unnumbered}

Aşağıdaki kod parçası, analizler için gerekli olan paketlerin yüklenmesini göstermektedir. Bu el kitabında, gerekirse paketi kuran *ve* kullanım için yükleyen **pacman**'dan `p_load()` fonksiyonunu ön plana çıkardık. R tabanından `library()` ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] sayfasına bakınız.

```{r}
pacman::p_load(rio,       # verileri içe aktarmak için
               here,      # dosyaları bulmak için
               tidyverse, # verileri temizlemek, işlemek ve çizmek için (ggplot2 paketini içerir)
               apyramid,  # yaş piramitleri oluşturmak için
               janitor,   # tablo ve veri temizlemek için
               stringr)   # başlık, alt yazı vb. dizelerle çalışmak için
```


### Veriyi içe aktarma {.unnumbered}  

Başlamak için, Ebola salgını simulasyonuna ait temizlenmiş vaka listesini içe aktarıyoruz. Takip etmek isterseniz, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>"temiz satır listesi" dosyasını indirmek için tıklayınız.</a> (.rds dosyası olarak). **rio** paketinden `import()` fonksiyonu ile veriler içe aktarılmalıdır (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe ve dışa aktarma] sayfasına bakınız).

```{r, echo=F}
# satır listesini R'a aktar
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# vaka satır listesini içe aktar 
linelist <- import("linelist_cleaned.rds")
```

Satır listesinin ilk 50 satırı aşağıda gösterilmiştir.

```{r, message=FALSE, echo=F}
# satır listesi verilerini bir tablo olarak göster
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Temizleme {.unnumbered}  

Geleneksel bir yaş/cinsiyet demografik piramidi oluşturmak için verilerin öncelikle aşağıda tanımlandığı gibi temizlenmesi gerekir: 

* Cinsiyet sütunu temizlenmelidir.  
* Kullanmak istediğiniz yönteme bağlı olarak yaş, sayısal olarak veya *yaş kategorisi* sütununda saklanmalıdır. 

Eğer Yaş kategorileri kullanılacaksa, sütun değerleri varsayılan olarak alfasayısal olarak veya sınıf faktörüne dönüştürülerek düzeltilmelidir.

Aşağıda, `gender` ve `age_cat5` sütunlarını incelemek için **janitor** paketinden `tabyl()` fonksiyonunu kullanıyoruz. 

```{r}
linelist %>% 
  tabyl(age_cat5, gender)
```

Ayrıca, temiz ve doğru şekilde sınıflandırıldığından emin olmak için "age" sütununu hızlıca histograma dönüştürüyoruz:

```{r}
hist(linelist$age)
```


<!-- ======================================================= -->
## **apyramid** paketi {}

**apyramid** paketi [R4Epis](https://r4epis.netlify.com/) projesinin bir ürünüdür. Bu paket hakkında daha fazla bilgiyi [buradan](https://cran.r-project.org/web/packages/apyramid/vignettes/intro.html) okuyabilirsiniz. Paket, hızlı bir şekilde bir yaş piramidi yapmanızı sağlar. Daha ayrıntılı durumlar için aşağıdaki bölüme bakabilirsiniz [`ggplot()` kullanarak](#demo_pyr_gg). R konsolunuza `?age_pyramid` girerek yardım sayfasında **apyramid** paketi hakkında daha fazla bilgi edinebilirsiniz.

### Linelist data {.unnumbered}  

Temizlenmiş 'satır listesi' veri setini kullanarak, `age_pyramid()` komutuyla basit bir yaş piramidi oluşturabiliriz. Bu komutta:

* `data = ` argümanı "satır listesi" veri çerçevesi olarak ayarlanır  
* `age_group = ` argümanı (y ekseni için) kategorik yaş sütununun adına ayarlanır (tırnak içinde)
* `split_by = ` argüman (x ekseni için) cinsiyet sütununa ayarlanır

```{r, warning=F, message=F}
apyramid::age_pyramid(data = linelist,
                      age_group = "age_cat5",
                      split_by = "gender")
```


Piramit, `proportional = TRUE` argümanı dahil edilerek, sayılar yerine x eksenindeki tüm verileri yüzdesi ile görüntülenebilir.

```{r, warning=F, message=F}
apyramid::age_pyramid(data = linelist,
                      age_group = "age_cat5",
                      split_by = "gender",
                      proportional = TRUE)
```

**agepyramid** paketini kullanırken, `split_by` sütunu ikili ise (ör. erkek/dişi veya evet/hayır), sonuç bir piramit olarak görünecektir. Bununla birlikte, `split_by` sütununda ikiden fazla değer varsa (`NA` dahil değildir), piramit "arka planda" gri çubuklar olan yönlü bir çubuk grafiği olarak görünecektir. Bu durum yaş grubu gibi yönlü olmayan verilerin aralığını gösterir. Bu durumda, `split_by =` değerleri her yön panelinin üstünde etiketler olarak görünecektir. Örneğin, `split_by = `, `hospital` sütununa atanırsa kodun nasıl yazılacağı aşağıda belirtilmiştir.

```{r, warning=F, message=F}
apyramid::age_pyramid(data = linelist,
                      age_group = "age_cat5",
                      split_by = "hospital")  
```

#### Eksik veriler {.unnumbered}  

Eğer eksik veriler `NA` olarak kodlanmışsa, `split_by = ` veya `age_group = ` sütunlarındaki eksik veri olan satırlar, grafiğin oluşmasını etkilemez. Varsayılan olarak bu satırlar gösterilmeyecektir. Bununla birlikte, `na.rm = FALSE` argümanıyla üstte, ayrı bir bitişik çubuk grafiğinde görünmelerini sağlayabilirsiniz.

```{r, warning=F, message=F}
apyramid::age_pyramid(data = linelist,
                      age_group = "age_cat5",
                      split_by = "gender",
                      na.rm = FALSE)         # show patients missing age or gender
```

#### Oranlar, renkler ve estetik {.unnumbered}  

Varsayılan olarak, çubuklar sayılarını belirtmektedir (yüzdelerini değil). Her grup kesikli bir orta çizgi ile gösterilir ve rengi yeşil/mordur. Bu parametrelerin her biri aşağıda gösterildiği gibi ayarlanabilir:

İstediğiniz estetik ve etiket ayarlamalarını standart `ggplot()` fonksiyonu ve "+" argümanını kullanarak ek `ggplot()` komutlarıyla belirleyebilirsiniz:

```{r, warning=F, message=F}
apyramid::age_pyramid(
  data = linelist,
  age_group = "age_cat5",
  split_by = "gender",
  proportional = TRUE,              # yüzdeyi göster, sayıları değil
  show_midpoint = FALSE,            # orta nokta çizgisini kaldır
  #pal = c("orange", "purple")      # burada alternatif renkler belirtebilirsiniz (ancak etiketleri değil)
  )+                 
  
  # additional ggplot commands
  theme_minimal()+                               # arka planı basitleştir
  scale_fill_manual(                             # renkleri VE etiketleri belirtin
    values = c("orange", "purple"),              
    labels = c("m" = "Male", "f" = "Female"))+
  labs(y = "Percent of all cases",              # x ve y laboratuvarları değiştirildiğine dikkat edin
       x = "Age categories",                          
       fill = "Gender", 
       caption = "My data source and caption here",
       title = "Title of my plot",
       subtitle = "Subtitle with \n a second line...")+
  theme(
    legend.position = "bottom",                          # açıklama aşağıya
    axis.text = element_text(size = 10, face = "bold"),  # font ve boyut
    axis.title = element_text(size = 12, face = "bold"))
```


### Toplu veri {.unnumbered}  

Yukarıdaki örnekler, verilerinizin gözlem başına bir satır olacak şekilde bir satır listesi biçiminde olduğunu varsaymaktadır. Verileriniz zaten yaş kategorisine göre sayılar halinde toplanmışsa, aşağıda gösterildiği gibi **apyramid** paketini kullanmaya devam edebilirsiniz.

Örnek olması için, satır listesi verilerini yaş kategorisine ve cinsiyete göre sayımlar halinde "geniş" bir formatta topluyoruz. Burada, verileriniz başlangıçta sayıymış gibi simüle edilecektir. İlgili sayfalarında [Gruplama verileri] ve [Özetleme verileri] hakkında daha fazla bilgi edinebilirsiniz.

```{r, warning=F, message=F}
demo_agg <- linelist %>% 
  count(age_cat5, gender, name = "cases") %>% 
  pivot_wider(
    id_cols = age_cat5,
    names_from = gender,
    values_from = cases) %>% 
  rename(`missing_gender` = `NA`)
```

...bu da veri setinin şu şekilde görünmesini sağlar: yaş kategorisi, erkek sayısı, kadın sayısı ve eksik veri sütunları.

```{r, echo=F, warning=F, message=F}
# Toplu veriyi göster
DT::datatable(demo_agg, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Bu verileri yaş piramidine uyarlamak için, veriler **dplyr** paketinden `pivot_longer()` fonksiyonuyla "long" formatına döndürülecektir. Bunun nedeni, `ggplot()` fonksiyonunun genellikle "long" verileri tercih etmesi ve **apyramid** paketinin `ggplot()`u kullanmasıdır.

```{r, warning=F, message=F}
# Toplu veriyi long formatına döndür
demo_agg_long <- demo_agg %>% 
  pivot_longer(
    col = c(f, m, missing_gender),            # long formatına çevrilecek sütunlar
    names_to = "gender",                # kategori sütunu için yeni ad
    values_to = "counts") %>%           # sayım sütunları için yeni ad
  mutate(
    gender = na_if(gender, "missing_gender")) # "missing_gender"ı NA'ya çevir
``` 

```{r, echo=F, warning=F, message=F}
# Toplu veriyi göster
DT::datatable(demo_agg_long, rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Ardından, verilerdeki ilgili sütunları belirtmek için `age_pyramid()` fonksiyonunun `split_by = ` ve `count = ` argümanını kullanın:

```{r, warning=F, message=F}
apyramid::age_pyramid(data = demo_agg_long,
                      age_group = "age_cat5",# yaş kategorisi sütunu için yeni ad
                      split_by = "gender",   # cinsiyet sütunu için yeni ad
                      count = "counts")      # vaka sayıları sütunu için yeni ad
```

Yukarıda "m" ve "f" faktör sırasının farklı olduğuna dikkat edin (ters piramit). Sıralamayı ayarlamak için, toplu verilerde cinsiyeti Faktör olarak yeniden tanımlamalı ve seviyeleri istediğiniz gibi sıralamalısınız. [Faktörler] sayfasına bakınız.


<!-- ======================================================= -->
## `ggplot()` {#demo_pyr_gg}

Yaş piramidinizi oluşturmak için `ggplot()`u kullanmak daha fazla esneklik sağlar, ancak `ggplot()`un nasıl çalıştığına dair daha fazla bilgi sahibi olmanız gerekmektedir. Çünkü bu pakette hata yapmak da daha kolaydır.

Demografik piramitler yapmak üzere `ggplot()`u kullanmak için, iki çubuk grafiği (her cinsiyet için bir tane) oluşturursunuz, bir grafikteki değerleri negatife çevirirsiniz ve son olarak çubuk grafiklerini dikey olarak, tabanlarını görüntülemek için x ve y eksenlerini çevirirsiniz.

### Hazırlık {.unnumbered}

Bu yaklaşım, `age_cat5` verilerinin *kategorik* değil, *sayısal* yaş sütununu kullanır. Bu yüzden bu sütunun sınıfının gerçekten sayısal olup olmadığını kontrol edeceğiz.

```{r}
class(linelist$age)
```

Aşağıdaki mantığı, `geom_histogram()` yerine `geom_col()` kullanarak kategorik verilerden bir piramit oluşturmak için de kullanabilirsiniz.

<!-- ======================================================= -->
### Grafiği oluşturma {.unnumbered} 

İlk olarak, `ggplot()` kullanarak bir piramit yapmak için aşağıdaki yaklaşımı anlamanız gerekmektedir:

* `ggplot()` içinde, sayısal yaş sütununu kullanarak **iki** histogram oluşturun: İki gruplama değerinin her biri için bir tane (bu durumda cinsiyetler erkek ve kadın). Bunu yapmak için, her bir histogram için veriler, ilgili filtreler "satır listesine" uygulanarak ilgili `geom_histogram()` komutlarında tanımlanır.

* Bir grafik pozitif değerlere sahip olacak, diğeri ise negatif değerlere dönüştürülecek - bu, grafiğin ortasında "0" değeri olan bir "piramit" yaratır. Negatif değerler, özel bir **ggplot2** terimi `..count..` kullanılarak ve -1 ile çarpılarak oluşturulur.

* `coord_flip()` komutu X ve Y eksenlerini değiştirerek grafiklerin 90 derece dönmesine ve piramidin oluşturulmasına neden olur.

* Son olarak, sayım ekseni değer etiketleri, piramidin her iki tarafında "pozitif" sayımlar olarak görünecek şekilde değiştirilmelidir (bir taraftaki temel değerlerin negatif olmasına rağmen). 

`geom_histogram()` fonksiyonu kullanılarak hazırlanan **basit** bir versiyonu aşağıdadır:

```{r, warning=F, message=F}
  # ggplotu başlat
  ggplot(mapping = aes(x = age, fill = gender)) +
  
  # kadın histogram
  geom_histogram(data = linelist %>% filter(gender == "f"),
                 breaks = seq(0,85,5),
                 colour = "white") +
  
  # erkek histogram (veriler negatife çevrilecek)
  geom_histogram(data = linelist %>% filter(gender == "m"),
                 breaks = seq(0,85,5),
                 mapping = aes(y = ..count..*(-1)),
                 colour = "white") +
  
  # X ve Y eksenlerini çevir
  coord_flip() +
  
  # sayım ekseni ölçeğini ayarla
  scale_y_continuous(limits = c(-600, 900),
                     breaks = seq(-600,900,100),
                     labels = abs(seq(-600, 900, 100)))
```

<span style="color: red;">**_TEHLİKE:_** Sayım ekseninizin **sınırları** çok düşük ayarlanmışsa ve bir sayım çubuğu bunları aşarsa, çubuk tamamen kaybolur veya yapay olarak kısaltılır! Rutin olarak güncellenen verileri analiz ediyorsanız buna dikkat etmelisiniz. Sayım ekseni sınırlarınızın aşağıdaki gibi verilerinize göre otomatik olarak ayarlanmasını sağlayarak bunu önleyebilirsiniz.</span>  

Bu basit versiyonda değiştirebileceğiniz/ekleyebileceğiniz pek çok şey vardır:  

* Sayım ekseni ölçeğini verilerinize göre otomatik olarak ayarlama (aşağıdaki uyarıda açıklanan hatalardan kaçınmalısınız) 
* Renkleri ve gösterge etiketlerini manuel olarak belirtme

**Sayıları yüzdelere dönüştürme**  

Sayıları yüzdelere (toplamına göre) dönüştürmek için, hazırlıklarınızı çizimden önce yapmanız gerekmektedir. Aşağıda, yeni yüzde sütunları oluşturmak için yaş-cinsiyet sayılarını, `ungroup()` ve ardından `mutate()` fonksiyonlarını kullanıyoruz. Cinsiyete göre yüzdeleri istiyorsanız, `ungroup()` adımını atlayabilirsiniz.


```{r, warning=F, message=F}
# toplama göre oranlamak için veri kümesi oluştur
pyramid_data <- linelist %>%
  count(age_cat5,
        gender,
        name = "counts") %>% 
  ungroup() %>%                 # grubu çöz, böylece yüzdeler gruba göre belirlenmesin
  mutate(percent = round(100*(counts / sum(counts, na.rm=T)), digits = 1), 
         percent = case_when(
            gender == "f" ~ percent,
            gender == "m" ~ -percent,     # erkeği negatife çevir
            TRUE          ~ NA_real_))    # NA değeri de sayısal olmalıdır
```

Daha da önemlisi, maksimum ve minimum değerleri kaydederek ölçeğin sınırlarının ne olması gerektiğini biliriz. Bunlar aşağıdaki `ggplot()` komutunda kullanılacaktır.   

```{r}
max_per <- max(pyramid_data$percent, na.rm=T)
min_per <- min(pyramid_data$percent, na.rm=T)

max_per
min_per
```

Son olarak yüzde verisi üzerinde `ggplot()` komutunu kullanıyoruz. Önceden tanımlı uzunlukları her yönde (pozitif ve "negatif") uzatmak için `scale_y_continuous()` fonksiyonunu tanımlıyoruz. Ondalık sayıları eksenin kenarı için uygun yöne (aşağı veya yukarı) yuvarlamak için `floor()` ve `ceiling()` argümanlarını kullanırız.

```{r, warning=F, message=F}
# ggplot başlangıcı
  ggplot()+  # varsayılan x ekseni, yıl cinsinden yaştır;

  # vaka veri grafiği
  geom_col(data = pyramid_data,
           mapping = aes(
             x = age_cat5,
             y = percent,
             fill = gender),         
           colour = "white")+       # her çubuğun etrafı beyaz
  
  # piramidi dikey yapmak için X ve Y eksenlerini çevir
  coord_flip()+
  

  # eksen boyunu düzenle
  # scale_x_continuous(breaks = seq(0,100,5), labels = seq(0,100,5)) +
  scale_y_continuous(
    limits = c(min_per, max_per),
    breaks = seq(from = floor(min_per),                # 2s ile değer dizisi
                 to = ceiling(max_per),
                 by = 2),
    labels = paste0(abs(seq(from = floor(min_per),     # mutlak değerler dizisi, 2s ile, "%" ile
                            to = ceiling(max_per),
                            by = 2)),
                    "%"))+  

  #renkleri ve açıklama etiketlerini manuel olarak belirle
  scale_fill_manual(
    values = c("f" = "orange",
               "m" = "darkgreen"),
    labels = c("Female", "Male")) +
  
  # etiket değerleri (şimdi X ve Y'nin çevrildiğini unutmayın)
  labs(
    title = "Age and gender of cases",
    x = "Age group",
    y = "Percent of total",
    fill = NULL,
    caption = stringr::str_glue("Data are from linelist \nn = {nrow(linelist)} (age or sex missing for {sum(is.na(linelist$gender) | is.na(linelist$age_years))} cases) \nData as of: {format(Sys.Date(), '%d %b %Y')}")) +
  
  # temayı görüntüle
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5), 
    plot.caption = element_text(hjust=0, size=11, face = "italic")
    )

```



<!-- ======================================================= -->
### Baz değerleriyle ile karşılaştırma  {.unnumbered} 

`ggplot()`un esnekliğiyle, arka planda "gerçek" veya "baz" nüfus piramidini temsil eden ikinci bir çubuk katmanına sahip olabilirsiniz. Bu, gözlemlenenleri taban çizgisiyle karşılaştırmak için güzel bir görselleştirme sağlayabilir.

Nüfus verilerini içe aktarın ve görüntüleyin (bkz. [El kitabını ve verileri indirin] sayfası):

```{r echo=F}
# nüfus demografisi verilerini içe aktar
pop <- rio::import(here::here("data", "standardization", "country_demographics.csv"))
```

```{r eval=F}
# nüfus demografisi verilerini içe aktar
pop <- rio::import("country_demographics.csv")
```

```{r, echo=F, warning=F, message=F}
# satır listesi verilerini bir tablo olarak göster
DT::datatable(pop, rownames = FALSE, options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )
```


İlk önce bazı veri yönetimi adımları: 

Burada görünmesini istediğimiz yaş kategorilerinin sırasını kaydediyoruz. `ggplot()`un uygulanma biçimindeki bazı tuhaflıklar nedeniyle, bu özel senaryoda bunları bir karakter vektörü olarak saklamak ve daha sonra çizim işlevinde kullanmak en kolay yoldur.

```{r}
# doğru yaş kategorisi seviyelerini kaydedin
age_levels <- c("0-4","5-9", "10-14", "15-19", "20-24",
                "25-29","30-34", "35-39", "40-44", "45-49",
                "50-54", "55-59", "60-64", "65-69", "70-74",
                "75-79", "80-84", "85+")
```

Popülasyon ve vaka verilerini **dplyr** paketinden `bind_rows()` fonksiyonu aracılığıyla birleştirin:

* İlk olarak, *tam olarak aynı* sütun adlarına, yaş kategorisi değerlerine ve cinsiyet değerlerine sahip olduklarından emin olmalısınız
* Verilerin aynı veri yapısına sahip olmalarını sağlayın: yaş kategorisi sütunları, cinsiyet, sayılar ve toplamın yüzdesi
* Bunları üst üste gelecek şekilde birbirine bağlayın (`bind_rows()`)



```{r, warning=F, message=F}
# toplamın yüzdesi ile nüfus verilerini oluştur/dönüştür
########################################################
pop_data <- pop %>% 
  pivot_longer(      # cinsiyet sütunlarını long formatına döndür
    cols = c(m, f),
    names_to = "gender",
    values_to = "counts") %>% 
  
  mutate(
    percent  = round(100*(counts / sum(counts, na.rm=T)),1),  # % of total
    percent  = case_when(                                                        
     gender == "f" ~ percent,
     gender == "m" ~ -percent,               # erkek ise, %'yi negatife çevir
     TRUE          ~ NA_real_))
```

Değiştirilen nüfus veri kümesini gözden geçirin

```{r, echo=F, warning=F, message=F}
# satır listesi verilerini bir tablo olarak göster
DT::datatable(pop_data, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Şimdi aynısını vaka satır listesi için uygulayın. Burada durum biraz farklıdır çünkü veriler vaka satırlarıyla başlıyor, sayılarla değil.  

```{r, warning=F, message=F}
# toplamın yüzdesi ile yaşa/cinsiyete göre vaka verileri oluştur
#######################################################
case_data <- linelist %>%
  count(age_cat5, gender, name = "counts") %>%  # yaş-cinsiyet gruplarına göre say
  ungroup() %>% 
  mutate(
    percent = round(100*(counts / sum(counts, na.rm=T)),1),  # yaş-cinsiyet grupları için toplamın yüzdesini hesapla
    percent = case_when(                                     # erkek ise %'yi negatife çevir
      gender == "f" ~ percent,
      gender == "m" ~ -percent,
      TRUE          ~ NA_real_))
```

Değiştirilen vaka veri kümesini gözden geçirin

```{r, message=FALSE, echo=F}
# satır listesi verilerini bir tablo olarak göster
DT::datatable(case_data, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Şimdi iki veri çerçevesi, biri diğerinin üzerinde olacak şekilde birleştirilmiştir (aynı sütun adlarına sahiptirler). Veri çerçevesinin her birini yeniden "adlandırabiliriz" ve her satırın hangi veri çerçevesinden kaynaklandığını gösterecek yeni bir "veri_kaynağı" sütunu oluşturmak için `.id = ` argümanını kullanabiliriz. Bu sütunu daha sonrasında `ggplot()` içinde filtrelemek için kullanabiliriz.

```{r, warning=F, message=F}
# vaka ve popülasyon verilerini birleştir (aynı sütun adları, age_cat değerleri ve cinsiyet değerleri)
pyramid_data <- bind_rows("cases" = case_data, "population" = pop_data, .id = "data_source")
```

Çizimin kapsamını tanımlamak için çizim işlevinde kullanılan maksimum ve minimum yüzde değerlerini saklayabilirsiniz (ve herhangi bir çubuğu daha kısa kesmeyin!)

```{r}
# Çizim sınırları için kullanılan yüzde ekseninin kapsamını tanımla
max_per <- max(pyramid_data$percent, na.rm=T)
min_per <- min(pyramid_data$percent, na.rm=T)
```

Şimdi grafik `ggplot()` ile hazırlanabilir:

* Nüfus verilerinin bir çubuk grafiği (daha geniş, daha şeffaf çubuklar)
* Vaka verilerinin bir çubuk grafiği (küçük, daha opak çubuk)


```{r, warning=F, message=F}

# ggplot'u başlat
##############
ggplot()+  # varsayılan x ekseni, yıl cinsinden yaştır;

  # nüfus veri grafiği
  geom_col(
    data = pyramid_data %>% filter(data_source == "population"),
    mapping = aes(
      x = age_cat5,
      y = percent,
      fill = gender),
    colour = "black",                               # çubukların etrafındaki siyah renk
    alpha = 0.2,                                    # daha şeffaf
    width = 1)+                                     # tam genişlik
  
  # vaka veri grafiği
  geom_col(
    data = pyramid_data %>% filter(data_source == "cases"), 
    mapping = aes(
      x = age_cat5,                               # orijinal X ekseni olarak yaş kategorileri
      y = percent,                                # orijinal Y ekseni olarak %
      fill = gender),                             # cinsiyete göre çubukların doldurulması
    colour = "black",                               # çubukların etrafındaki siyah renk
    alpha = 1,                                      # opak 
    width = 0.3)+                                   # yarım genişlik
  
  # piramidi dikey yapmak için X ve Y eksenlerini çevir
  coord_flip()+
  
  # yaş ekseninin doğru sıralandığından manuel olarak emin ol
  scale_x_discrete(limits = age_levels)+     # yukarıdaki parçada tanımlanmış
  
  # yüzde ekseni ayarla
  scale_y_continuous(
    limits = c(min_per, max_per),                                          # yukarıda tanımlanan min ve max
    breaks = seq(floor(min_per), ceiling(max_per), by = 2),                # min%'den maksimum% 2'ye
    labels = paste0(                                                       # etiketler için birlikte yapıştır...
              abs(seq(floor(min_per), ceiling(max_per), by = 2)), "%"))+                                                  

  # renkleri ve açıklama etiketlerini manuel olarak belirle
  scale_fill_manual(
    values = c("f" = "orange",         # verilerdeki değerlere renk ata
               "m" = "darkgreen"),
    labels = c("f" = "Female",
               "m"= "Male"),      # göstergede görünen etiketleri değiştir, not sırası
  ) +

  # grafik etiketleri, başlıklar, başlık  
  labs(
    title = "Case age and gender distribution,\nas compared to baseline population",
    subtitle = "",
    x = "Age category",
    y = "Percent of total",
    fill = NULL,
    caption = stringr::str_glue("Cases shown on top of country demographic baseline\nCase data are from linelist, n = {nrow(linelist)}\nAge or gender missing for {sum(is.na(linelist$gender) | is.na(linelist$age_years))} cases\nCase data as of: {format(max(linelist$date_onset, na.rm=T), '%d %b %Y')}")) +
  
  # opsiyonel estetik ayarlamalar
  theme(
    legend.position = "bottom",                             # açıklamayı aşağıya taşı
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0), 
    plot.caption = element_text(hjust=0, size=11, face = "italic"))

```


<!-- ======================================================= -->
## Likert ölçek {}

'ggplot()' ile bir nüfus piramidi yapmak için kullanılan teknikler, Likert ölçekli anket verilerinin çizimlerini yapmak için de kullanılabilir.

```{r, eval=F, echo=F}
data_raw <- import("P:/Shared/equateur_mve_2020/lessons learned/Ebola After-Action Survey - HQ epi team (form responses).csv")


likert_data <- data_raw %>% 
  select(2, 4:11) %>% 
  rename(status = 1,
         Q1 = 2,
         Q2 = 3,
            Q3 = 4,
            Q4 = 5,
            Q5 = 6,
            Q6 = 7,
            Q7 = 8,
            Q8 = 9) %>% 
  mutate(status = case_when(
           stringr::str_detect(status, "Mar") ~ "Senior",
           stringr::str_detect(status, "Jan") ~ "Intermediate",
           stringr::str_detect(status, "Feb") ~ "Junior",
           TRUE ~ "Senior")) %>% 
  mutate(Q4 = recode(Q4, "Not applicable" = "Very Poor"))

table(likert_data$status)

rio::export(likert_data, here::here("data", "likert_data.csv"))
```

Verileri içe aktarın ([El kitabını ve verileri indir] sayfasına bakabilirsiniz).

```{r echo=F}
# likert anketi yanıt verilerini içe aktar
likert_data <- rio::import(here::here("data", "likert_data.csv"))
```

```{r, eval=F}
# likert anketi yanıt verilerini içe aktar
likert_data <- rio::import("likert_data.csv")
```

Her katılımcının kategorik bir sınıflandırması (`status`) ve 4 puanlı Likert tipi bir ölçekte 8 soruya verdikleri yanıtlara ("Çok kötü", "Kötü", "İyi", "Çok iyi") ait verileri ele alacağız.

```{r, echo=F, message=FALSE}
# satır listesi verilerini bir tablo olarak göster
DT::datatable(likert_data, rownames = FALSE, filter="top", options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )
```

İlk olarak, veri yönetimi adımları: 

* Verileri `pivot_longer` fonksiyonuyla alt gruplarına döndürme
* Yanıtın genellikle "olumlu" veya "olumsuz" olmasına bağlı olarak yeni bir `direction` sütunu oluşturma
* `status` sütunu ve `Response` sütunu için Faktör düzeyi sırasını ayarlama  
* Maksimum sayım değerini, çizim sınırlarının uygun olması için saklama 


```{r, warning=F, message=F}
melted <- likert_data %>% 
  pivot_longer(
    cols = Q1:Q8,
    names_to = "Question",
    values_to = "Response") %>% 
  mutate(
    
    direction = case_when(
      Response %in% c("Poor","Very Poor")  ~ "Negative",
      Response %in% c("Good", "Very Good") ~ "Positive",
      TRUE                                 ~ "Unknown"),
    
    status = fct_relevel(status, "Junior", "Intermediate", "Senior"),
    
    # çalışması için 'Çok Zayıf' ve 'Zayıf' kelimeleri tersine çevirilmelidir
    Response = fct_relevel(Response, "Very Good", "Good", "Very Poor", "Poor")) 

# ölçek limitleri için en büyük değeri al
melted_max <- melted %>% 
  count(status, Question) %>% # sayıları al
  pull(n) %>%                 # sütunu 'n'i
  max(na.rm=T)                # maksimumu al
```


Şimdi grafiği hazırlayabiliriz. Yukarıdaki yaş piramitlerinde olduğu gibi iki çubuk grafiği oluşturuyoruz ve bunlardan birinin değerlerini negatife çeviriyoruz. 

`geom_bar()` fonksiyonunu kullanıyoruz çünkü verilerimiz toplu sayı olarak değil, gözlem başına bir satır olacak şekilde düzenlendi. Negatif değerleri (*-1*) tersine çevirmek için çubuk grafiklerden birinde özel **ggplot2** terimi olan `..count..`u ve değerlerin üstüne eklenmesi için `position = "stack"` argümanını kullanıyoruz.

```{r, warning=F, message=F}
# garfiği hazırla
ggplot()+
     
  # "olumsuz" yanıtların çubuk grafiği 
     geom_bar(
       data = melted %>% filter(direction == "Negative"),
       mapping = aes(
         x = status,
         y = ..count..*(-1),    # negatife çevrilen sayımlar
         fill = Response),
       color = "black",
       closed = "left",
       position = "stack")+
     
     # "olumlu" yanıtların çubuk grafiği
     geom_bar(
       data = melted %>% filter(direction == "Positive"),
       mapping = aes(
         x = status,
         fill = Response),
       colour = "black",
       closed = "left",
       position = "stack")+
     
     # X ve Y eksenlerini çevirin
     coord_flip()+
  
     # 0'da siyah dikey çizgi
     geom_hline(yintercept = 0, color = "black", size=1)+
     
    # etiketlerin tümünü pozitif sayılara dönüştür
    scale_y_continuous(
      
      # x ekseni ölçeğinin sınırları
      limits = c(-ceiling(melted_max/10)*11,    # 10 ile negatiften pozitife doğru sıra, kenarlar dışa doğru en yakın 5'e yuvarlanır
                 ceiling(melted_max/10)*10),   
      
      # x ekseni ölçeğinin değerleri
      breaks = seq(from = -ceiling(melted_max/10)*10,
                   to = ceiling(melted_max/10)*10,
                   by = 10),
      
      # x ekseni ölçeğinin etiketleri
      labels = abs(unique(c(seq(-ceiling(melted_max/10)*10, 0, 10),
                            seq(0, ceiling(melted_max/10)*10, 10))))) +
     
    # manuel olarak atanan renk skalaları
    scale_fill_manual(
      values = c("Very Good"  = "green4", # renk ata
                "Good"      = "green3",
                "Poor"      = "yellow",
                "Very Poor" = "red3"),
      breaks = c("Very Good", "Good", "Poor", "Very Poor"))+ # açıklamanın sırası
     
    
     
    # tüm grafiği şekillendirin, böylece her soru bir alt grafik olur
    facet_wrap( ~ Question, ncol = 3)+
     
    # etiketler, başlıklar, başlık
    labs(
      title = str_glue("Likert-style responses\nn = {nrow(likert_data)}"),
      x = "Respondent status",
      y = "Number of responses",
      fill = "")+

     # görselin ayarları 
     theme_minimal()+
     theme(axis.text = element_text(size = 12),
           axis.title = element_text(size = 14, face = "bold"),
           strip.text = element_text(size = 14, face = "bold"),  # alt başlıklar
           plot.title = element_text(size = 20, face = "bold"),
           panel.background = element_rect(fill = NA, color = "black")) # her metin etrafındaki siyah çerçeve
```


<!-- ======================================================= -->
## Kaynaklar {}

[apyramid dokümantasyonu](https://cran.r-project.org/web/packages/apyramid/vignettes/intro.html)



```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/age_pyramid.Rmd-->


# Isı grafikleri { }  


"Isı haritaları" veya "ısı karoları" olarak da bilinen ısı grafikleri, 3 değişkeni (x ekseni, y ekseni ve dolgu) görüntülemeye çalışırken yararlı görselleştirmeler olabilir. Aşağıda iki örnek gösteriliyor:  

* Yaşa göre bulaşma olaylarının görsel bir matrisi ("kim kime bulaştırdı")  
* Zaman içinde birçok tesis/yetki alanı genelinde raporlama ölçümlerini izleme  


```{r, out.width = c('50%', '50%'), fig.show='hold', warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "transmission_matrix.png"))

knitr::include_graphics(here::here("images", "heat_tile.png"))

```





<!-- ======================================================= -->
## Hazırlık { }

### Paketleri yükle {.unnumbered}  

Bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran *ve* kullanım için yükleyen **pacman**'ın `p_load()` fonksiyonunu vurguluyoruz. Ayrıca, R **tabanı**'ndan `library()` ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] sayfasına bakın.  

```{r}
pacman::p_load(
  tidyverse,       # data manipulation and visualization
  rio,             # importing data 
  lubridate        # working with dates
  )
```

**Veri setleri**  

Bu sayfa, iletim matrisi bölümü için simüle edilmiş bir salgının vaka satır listesini ve ölçüm izleme bölümü için tesise göre günlük sıtma vaka sayımlarının ayrı bir veri setini kullanır. Ayrı bölümlerine yüklenir ve temizlenirler.  







## Geçiş matrisi  

Isı karoları, matrisleri görselleştirmek için faydalı olabilir. Örnek olarak, bir salgında “kimin kime bulaştığını” göstermektir. Bu, aktarım olayları hakkında bilgi sahibi olduğunuzu varsayar.  

[Temaslı izleme] sayfasının, vakaların yaşlarının ve kaynaklarının veri çerçevesinin aynı satırında düzgün bir şekilde hizalandığı farklı (belki de daha basit) bir veri kümesi kullanarak bir ısı karosu temas matrisi oluşturmanın başka bir örneğini içerdiğine dikkat edin. Bu aynı veriler, [ggplot ipuçları] sayfasında bir *yoğunluk* haritası yapmak için kullanılır. Aşağıdaki bu örnek, bir durum satır listesinden başlar ve bu nedenle, çizilebilir bir veri çerçevesi elde etmeden önce önemli miktarda veri işlemeyi içerir. Yani seçebileceğiniz birçok senaryo var...


Simüle edilmiş bir Ebola salgınının vaka listesiyle başlıyoruz. Devam etmek istiyorsanız, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'> “temiz” satır listesini</a> (.rds dosyası olarak) indirmek için tıklayın. Verilerinizi **rio** paketinden `import()` fonksiyonuyla içe aktarın (.xlsx, .rds, .csv gibi birçok dosya türünü kabul eder - ayrıntılar için [İçe Aktarma ve Dışa Aktarma] sayfasına bakın).


Çizgi listesinin ilk 50 satırı, gösterim için aşağıda gösterilmiştir:   


```{r, echo=F}
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```


```{r, eval=F}
linelist <- import("linelist_cleaned.rds")
```


Bu satır listesinde:  

* `case_id` ile tanımlandığı gibi, vaka başına bir satır vardır
* Satır listesinde de bir vaka olan *bulaştırıcı*'nın `case_id`'sini içeren daha sonraki bir sütun olan `infector` vardır. 


```{r message=FALSE, echo=F}
# display the population as a table
DT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```



### Veri Hazırlama {.unnumbered}  

**Amaç**: Olası yaştan yaşa iletim yolu başına bir satır içeren ve satır listesindeki tüm gözlenen iletim olaylarının o satırın oranını kapsayan sayısal bir sütun içeren "uzun" tarzda bir veri çerçevesi elde etmemiz gerekiyor.  

Bu, aşağıdakileri elde etmek için birkaç veri işleme adımı alacaktır:   


#### 	Vaka veri çerçevesi yapmak {.unnumbered} 

Başlamak için, vakaların, yaşlarının ve bulaştırıcılarının bir veri çerçevesini oluşturuyoruz - veri çerçevesine `case_ages` diyoruz. İlk 50 satır aşağıda gösterilmiştir. 

```{r}
case_ages <- linelist %>% 
  select(case_id, infector, age_cat) %>% 
  rename("case_age_cat" = "age_cat")
```

```{r message=FALSE, echo=F}
# display the shapefile as a table
DT::datatable(head(case_ages, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

#### 	Bulaştırıcıların veri çerçevesini yapmak {.unnumbered}  

Ardından, bulaşıcıların veri çerçevesini oluşturuyoruz - şu anda tek bir sütundan oluşuyor. Bunlar, satır listesindeki bulaştırıcı kimlikleridir. Her vakanın bilinen bir bulaştırıcısı yoktur, bu nedenle eksik değerleri kaldırıyoruz. İlk 50 satır aşağıda gösterilmiştir.   


```{r}
infectors <- linelist %>% 
  select(infector) %>% 
  drop_na(infector)
```

```{r message=FALSE, echo=F}
# display the shapefile as a table
DT::datatable(head(infectors, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Daha sonra, bulaştırıcıların yaşlarını elde etmek için birleşimleri kullanırız. Bu basit değil, çünkü `linelist`'de, bulaştırıcının yaşları bu şekilde listelenmiyor. Bu sonuca, `linelist`'i bulaştırıcılara ekleyerek ulaşıyoruz. Bulaştırıcılarla başlıyoruz ve vaka `linelist`'ne `left_join()` (ekliyoruz), öyle ki `infector` kimliği sütunu sol taraftaki "temel" veri çerçevesi sağ taraftaki `linelist` veri çerçevesindeki `case_id` sütunuyla birleşiyor.

Böylece satır listesindeki (yaş dahil) bulaştırıcının vaka kaydındaki veriler bulaştırıcı satırına eklenir. İlk 50 satır aşağıda gösterilmiştir.   

```{r}
infector_ages <- infectors %>%             # begin with infectors
  left_join(                               # add the linelist data to each infector  
    linelist,
    by = c("infector" = "case_id")) %>%    # match infector to their information as a case
  select(infector, age_cat) %>%            # keep only columns of interest
  rename("infector_age_cat" = "age_cat")   # rename for clarity
```

```{r message=FALSE, echo=F}
# display the shapefile as a table
DT::datatable(head(infector_ages, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Daha sonra vakaları ve yaşlarını bulaştırıcılar ve yaşları ile birleştiriyoruz. Bu veri çerçevelerinin her biri sütun `infector`'e sahiptir, bu nedenle birleştirme için kullanılır. İlk satırlar aşağıda görüntülenir: 

```{r}
ages_complete <- case_ages %>%  
  left_join(
    infector_ages,
    by = "infector") %>%        # each has the column infector
  drop_na()                     # drop rows with any missing data
```


```{r message=FALSE, echo=F}
# display the shapefile as a table
DT::datatable(head(ages_complete, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Aşağıda, vaka ve enfeksiyon etkeni yaş grupları arasındaki sayıların basit bir çapraz tablosu. Netlik için etiketler eklendi.  

```{r}
table(cases = ages_complete$case_age_cat,
      infectors = ages_complete$infector_age_cat)
```


Bu tabloyu, R **taban**ından `data.frame()` ile bir veri çerçevesine dönüştürebiliriz, bu da onu otomatik olarak `ggplot()` için istenen “uzun” biçime dönüştürür. İlk satırlar aşağıda gösterilmiştir. 

```{r}
long_counts <- data.frame(table(
    cases     = ages_complete$case_age_cat,
    infectors = ages_complete$infector_age_cat))
```

```{r message=FALSE, echo=F}
# display the shapefile as a table
DT::datatable(head(long_counts, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


Şimdi biz de aynısını yapıyoruz, ancak tabloya R **taban**ından `prop.table()` uygularız, böylece sayımlar yerine toplamın oranlarını elde ederiz. İlk 50 satır aşağıda gösterilmiştir. 

```{r}
long_prop <- data.frame(prop.table(table(
    cases = ages_complete$case_age_cat,
    infectors = ages_complete$infector_age_cat)))
```

```{r message=FALSE, echo=F}
# display the shapefile as a table
DT::datatable(head(long_prop, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```




### Isı grafiği oluşturmak {.unnumbered}  

Şimdi nihayet `geom_tile()` fonksiyonunu kullanarak **ggplot2** paketi ile ısı grafiğini oluşturabiliriz. Renk/dolgu ölçekleri, özellikle de `scale_fill_gradient()` fonksiyonu hakkında daha kapsamlı bilgi edinmek için [ggplot ipuçları] sayfasına bakın.

* `geom_tile()` estetik `aes()`'inde x ve y'yi vaka yaşı ve bulaştırıcı yaşı olarak ayarlayın
* Ayrıca `aes()` içinde `fill = ` argümanını `Freq` sütununa ayarlayın - bu, kutucuk rengine dönüştürülecek değerdir
* `scale_fill_gradient()` ile bir ölçek rengi ayarlayın - yüksek/düşük renkleri belirleyebilirsiniz
  * `scale_color_gradient()` öğesinin farklı olduğuna dikkat edin! Bu durumda doldurmak istersiniz
* Renk “doldurma” yoluyla yapıldığından, gösterge başlığını değiştirmek için `labs()` içindeki `fill = ` bağımsız değişkenini kullanabilirsiniz. 

```{r}
ggplot(data = long_prop)+       # use long data, with proportions as Freq
  geom_tile(                    # visualize it in tiles
    aes(
      x = cases,         # x-axis is case age
      y = infectors,     # y-axis is infector age
      fill = Freq))+            # color of the tile is the Freq column in the data
  scale_fill_gradient(          # adjust the fill color of the tiles
    low = "blue",
    high = "orange")+
  labs(                         # labels
    x = "Case age",
    y = "Infector age",
    title = "Who infected whom",
    subtitle = "Frequency matrix of transmission events",
    fill = "Proportion of all\ntranmsission events"     # legend title
  )
  
```



<!-- ======================================================= -->
## Zaman içinde raporlama metrikleri { }

Halk sağlığında genellikle bir amaç, birçok kuruluş (tesisler, yargı alanları, vb.) için zaman içindeki eğilimleri değerlendirmektir. Bu tür eğilimleri zaman içinde görselleştirmenin bir yolu, x ekseninin zaman olduğu ve y ekseninde birçok öğenin bulunduğu bir ısı grafiğidir.  



### Veri Hazırlama {.unnumbered}

Birçok tesisten günlük sıtma raporlarının bir veri setini içe aktararak başlıyoruz. Raporlar bir tarih, il, ilçe ve sıtma sayılarını içerir. Bu verilerin nasıl indirileceği hakkında bilgi için [El kitabı ve verileri indirme] sayfasına bakın. İlk 30 satır aşağıdadır:   

```{r, echo=F}
facility_count_data <- rio::import(here::here("data", "malaria_facility_count_data.rds")) %>% 
  select(location_name, data_date, District, malaria_tot)
```

```{r, eval=F}
facility_count_data <- import("malaria_facility_count_data.rds")
```


```{r, echo=F}
DT::datatable(head(facility_count_data,30), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```


#### Toplama ve özetleme {.unnumbered}

**Bu örnekteki amaç**, günlük tesis *toplam* sıtma vakası sayılarını (önceki sekmede görülen) tesis raporlama performansının *haftalık* özet istatistiklerine dönüştürmektir - bu durum için *tesisin herhangi bir veriyi bildirdiği haftadaki günlerin oranı*dır. Bu örnek için sadece **Spring District** için veri göstereceğiz.

Bunu başarmak için aşağıdaki veri yönetimi adımlarını uygulayacağız:  

1) Verileri uygun şekilde filtreleyin (yere, tarihe göre)  
2) **lubridate** paketinden `floor_date()` kullanarak bir hafta sütunu oluşturun
    + Bu fonksiyon, her haftanın belirli bir başlangıç tarihini (ör. "Pazartesileri") kullanarak belirli bir tarihteki haftanın başlangıç tarihini döndürür.
3) Veriler, "tesis-hafta" analiz birimlerini oluşturmak için "konum" ve "hafta" sütunlarına göre gruplandırılır. 
4) `summarise()` işlevi, tesis-hafta grubu başına özet istatistikleri yansıtmak için yeni sütunlar oluşturur:
    + Haftada gün sayısı (7 - statik bir değer)  
    + Tesis-haftadan alınan rapor sayısı (7'den fazla olabilir!)  
    + Tesis haftası tarafından bildirilen sıtma vakalarının toplamı (sadece merak için)  
    + Tesis-haftadaki verilerin raporlandığı *özel* günlerin sayısı  
    + **Verilerin rapor edildiği tesis-hafta başına 7 günün yüzdesi**  
5) Veri setini tamamlamak için tüm olası tesis-hafta kombinasyonlarının kapsamlı bir listesi için veri çerçevesi `right_join()` ile birleştirilir. Tüm olası kombinasyonların matrisi, veri çerçevesinin bu iki sütununa veri tüneli akışı o anda olduğu gibi (`.` ile temsil edilir) `expand()` uygulanarak oluşturulur. Bir `right_join()` kullanıldığından, `expand()` veri çerçevesindeki tüm satırlar tutulur ve gerekirse `agg_weeks`'e eklenir. Bu yeni satırlar, `NA` (eksik) özetlenmiş değerlerle görünür.


Aşağıda adım adım gösteriyoruz:   

```{r, message=FALSE, warning=FALSE}
# Create weekly summary dataset
agg_weeks <- facility_count_data %>% 
  
  # filter the data as appropriate
  filter(
    District == "Spring",
    data_date < as.Date("2020-08-01")) 
```

Şimdi veri setinde, daha önce ` nrow(facility_count_data)` olduğunda, ` nrow(agg_weeks)` satırı vardır.

Ardından, her kayıt için haftanın başlangıç tarihini yansıtan bir `week` sütunu oluştururuz. Bu, **lubridate** paketi ve "hafta" olarak ayarlanan ve haftaların Pazartesi gününden itibaren başlayacağı (haftanın 1. günü - Pazar 7 olacaktır) `floor_date()` fonksiyonuyla elde edilir. Üst sıralar aşağıda gösterilmiştir. 

```{r}
agg_weeks <- agg_weeks %>% 
  # Create week column from data_date
  mutate(
    week = lubridate::floor_date(                     # create new column of weeks
      data_date,                                      # date column
      unit = "week",                                  # give start of the week
      week_start = 1))                                # weeks to start on Mondays 
```

Yeni hafta sütunu, veri çerçevesinin en sağında görülebilir   

```{r, echo=F}
DT::datatable(head(agg_weeks,30), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

Şimdi veriler tesis-haftalar halinde gruplandırılır ve tesis-hafta başına istatistik üretmek için bunlar özetlenir. İpuçları için [Açıklayıcı tablolar] sayfasına bakın. Gruplandırmanın kendisi veri çerçevesini değiştirmez, ancak sonraki özet istatistiklerin nasıl hesaplandığını etkiler.  

Üst sıralar aşağıda gösterilmiştir. Sütunların, istenen özet istatistikleri yansıtacak şekilde nasıl tamamen değiştiğine dikkat edin. Her satır bir tesis-haftayı yansıtır. 

```{r, warning=F, message=F}
agg_weeks <- agg_weeks %>%   

  # Group into facility-weeks
  group_by(location_name, week) %>%
  
  # Create summary statistics columns on the grouped data
  summarize(
    n_days          = 7,                                          # 7 days per week           
    n_reports       = dplyr::n(),                                 # number of reports received per week (could be >7)
    malaria_tot     = sum(malaria_tot, na.rm = T),                # total malaria cases reported
    n_days_reported = length(unique(data_date)),                  # number of unique days reporting per week
    p_days_reported = round(100*(n_days_reported / n_days))) %>%  # percent of days reporting
     
  ungroup(location_name, week)
```

```{r, echo=F}
DT::datatable(head(agg_weeks,30), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

Son olarak, daha önce eksik olsalar bile, olası TÜM tesis-haftalarının verilerde mevcut olduğundan emin olmak için aşağıdaki komutu çalıştırılır.

Kendi üzerinde bir `right_join()` kullanıyoruz (veri seti "." ile temsil edilir), ancak `week` ve `location_name` sütunlarının tüm olası kombinasyonlarını içerecek şekilde genişletildi. [Pivoting] sayfasındaki `expand()` işleviyle ilgili belgelere bakın. Bu kodu çalıştırmadan önce veri seti ` nrow(agg_weeks)` satırlarını içerir. 

```{r, message=F, warning=F}
# Create data frame of every possible facility-week
expanded_weeks <- agg_weeks %>% 
     tidyr::expand(location_name, week)
```

`expanded_weeks` burada:

```{r, echo=F}
DT::datatable(expanded_weeks, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

Bu kodu çalıştırmadan önce `agg_weeks`, ` nrow(agg_weeks)` satırlarını içerir. 

```{r}
# Use a right-join with the expanded facility-week list to fill-in the missing gaps in the data
agg_weeks <- agg_weeks %>%      
  right_join(expanded_weeks) %>%                            # Ensure every possible facility-week combination appears in the data
  mutate(p_days_reported = replace_na(p_days_reported, 0))  # convert missing values to 0                           
```

Bu kodu çalıştırdıktan sonra `agg_weeks`, ` nrow(agg_weeks)` satırlarını içerir.


<!-- ======================================================= -->
### Isı grafiği oluştur {.unnumbered}


`ggplot()`, **ggplot2** paketindeki `geom_tile()` kullanılarak yapılır:

* x eksenindeki haftalar tarihlere dönüştürülerek `scale_x_date()` kullanımına izin verilir,
* y eksenindeki `location_name` tüm tesis adlarını gösterecek,
* `fill`, `p_days_reported`, o tesisin haftalık performansı (sayısal),
* `scale_fill_gradient()` yüksek, düşük ve `NA` için renkleri belirterek sayısal dolguda kullanılır,
* `scale_x_date()`, her 2 haftada bir etiketleri ve formatlarını belirten x ekseninde kullanılır,
* Ekran temaları ve etiketleri gerektiği gibi ayarlanabilir. 




<!-- ======================================================= -->
### Temel {.unnumbered}  

Aşağıda, varsayılan renkler, ölçekler vb. kullanılarak temel bir ısı grafiği üretilmiştir.Yukarıda açıklandığı gibi, `geom_tile()` için `aes()` içinde bir x ekseni sütunu, y ekseni sütunu **ve** `fill = ` için bir sütun sağlamalısınız. Dolgu, kutucuk rengi olarak sunulan sayısal değerdir. 

```{r}
ggplot(data = agg_weeks)+
  geom_tile(
    aes(x = week,
        y = location_name,
        fill = p_days_reported))
```

### Temizlenmiş grafik {.unnumbered}

Aşağıda gösterildiği gibi ek **ggplot2** işlevleri ekleyerek bu grafiğin daha iyi görünmesini sağlayabiliriz. Ayrıntılar için [ggplot ipuçları] sayfasına bakın. 

```{r, message=FALSE, warning=FALSE}
ggplot(data = agg_weeks)+ 
  
  # show data as tiles
  geom_tile(
    aes(x = week,
        y = location_name,
        fill = p_days_reported),      
    color = "white")+                 # white gridlines
  
  scale_fill_gradient(
    low = "orange",
    high = "darkgreen",
    na.value = "grey80")+
  
  # date axis
  scale_x_date(
    expand = c(0,0),             # remove extra space on sides
    date_breaks = "2 weeks",     # labels every 2 weeks
    date_labels = "%d\n%b")+     # format is day over month (\n in newline)
  
  # aesthetic themes
  theme_minimal()+                                  # simplify background
  
  theme(
    legend.title = element_text(size=12, face="bold"),
    legend.text  = element_text(size=10, face="bold"),
    legend.key.height = grid::unit(1,"cm"),           # height of legend key
    legend.key.width  = grid::unit(0.6,"cm"),         # width of legend key
    
    axis.text.x = element_text(size=12),              # axis text size
    axis.text.y = element_text(vjust=0.2),            # axis text alignment
    axis.ticks = element_line(size=0.4),               
    axis.title = element_text(size=12, face="bold"),  # axis title size and bold
    
    plot.title = element_text(hjust=0,size=14,face="bold"),  # title right-aligned, large, bold
    plot.caption = element_text(hjust = 0, face = "italic")  # caption right-aligned and italic
    )+
  
  # plot labels
  labs(x = "Week",
       y = "Facility name",
       fill = "Reporting\nperformance (%)",           # legend title, because legend shows fill
       title = "Percent of days per week that facility reported data",
       subtitle = "District health facilities, May-July 2020",
       caption = "7-day weeks beginning on Mondays.")
```





<!-- ======================================================= -->
### Sıralı y ekseni {.unnumbered}  

Şu anda tesisler, aşağıdan yukarıya doğru "alfa-nümerik olarak" sıralanmıştır. Eğer y ekseni tesislerinin sırasını ayarlamak istiyorsanız, bunları sınıf faktörüne dönüştürün ve sırayı sağlayın. İpuçları için [Faktörler] sayfasına bakın.

Pek çok tesis olduğundan ve hepsini yazmak istemediğimizden, başka bir yaklaşım deneyeceğiz bu da tesisleri bir veri çerçevesinde sıralamak ve sonuç sütununu faktör düzeyi sırası olarak kullanmak olacak. Aşağıda, `location_name` sütunu bir faktöre dönüştürülür ve düzeylerinin sırası, tüm zaman aralığında tesis tarafından dosyalanan toplam raporlama günü sayısına göre belirlenir.

Bunu yapmak için, artan düzende düzenlenmiş, tesis başına toplam rapor sayısını temsil eden bir veri çerçevesi oluşturuyoruz. Grafikteki faktör seviyelerini sıralamak için bu vektör kullanılabilir.   

```{r}
facility_order <- agg_weeks %>% 
  group_by(location_name) %>% 
  summarize(tot_reports = sum(n_days_reported, na.rm=T)) %>% 
  arrange(tot_reports) # ascending order
```

Aşağıdaki veri çerçevesine bakın:   

```{r, echo=F}
DT::datatable(facility_order, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```




Şimdi, `agg_weeks` veri çerçevesindeki `location_name` faktör düzeylerinin sırası olmak için yukarıdaki veri çerçevesinden (`facility_order$location_name`) bir sütun kullanın: 

```{r, warning=F, message=F}
# load package 
pacman::p_load(forcats)

# create factor and define levels manually
agg_weeks <- agg_weeks %>% 
  mutate(location_name = fct_relevel(
    location_name, facility_order$location_name)
    )
```

Ve şimdi, location_name sıralı bir faktör olacak şekilde veriler yeniden çizilir: 

```{r, message=FALSE, warning=FALSE}
ggplot(data = agg_weeks)+ 
  
  # show data as tiles
  geom_tile(
    aes(x = week,
        y = location_name,
        fill = p_days_reported),      
    color = "white")+                 # white gridlines
  
  scale_fill_gradient(
    low = "orange",
    high = "darkgreen",
    na.value = "grey80")+
  
  # date axis
  scale_x_date(
    expand = c(0,0),             # remove extra space on sides
    date_breaks = "2 weeks",     # labels every 2 weeks
    date_labels = "%d\n%b")+     # format is day over month (\n in newline)
  
  # aesthetic themes
  theme_minimal()+                                  # simplify background
  
  theme(
    legend.title = element_text(size=12, face="bold"),
    legend.text  = element_text(size=10, face="bold"),
    legend.key.height = grid::unit(1,"cm"),           # height of legend key
    legend.key.width  = grid::unit(0.6,"cm"),         # width of legend key
    
    axis.text.x = element_text(size=12),              # axis text size
    axis.text.y = element_text(vjust=0.2),            # axis text alignment
    axis.ticks = element_line(size=0.4),               
    axis.title = element_text(size=12, face="bold"),  # axis title size and bold
    
    plot.title = element_text(hjust=0,size=14,face="bold"),  # title right-aligned, large, bold
    plot.caption = element_text(hjust = 0, face = "italic")  # caption right-aligned and italic
    )+
  
  # plot labels
  labs(x = "Week",
       y = "Facility name",
       fill = "Reporting\nperformance (%)",           # legend title, because legend shows fill
       title = "Percent of days per week that facility reported data",
       subtitle = "District health facilities, May-July 2020",
       caption = "7-day weeks beginning on Mondays.")
```





<!-- ======================================================= -->
### Değerleri göster  {.unnumbered}  


Her kutucuğun gerçek sayılarını görüntülemek için kutucukların üzerine bir `geom_text()` katmanı ekleyebilirsiniz. Çok sayıda küçük kutucuğunuz varsa, bunun hoş görünmeyebileceğini unutmayın!

Şu kod eklendi: `geom_text(aes(label = p_days_reported))`. Bu, her döşemeye metin ekler. Görüntülenen metin, bu durumda renk gradyanını oluşturmak için kullanılan `p_days_reported` ile aynı sayısal sütuna ayarlanmış olan `label = ` bağımsız değişkenine atanan değerdir. 



  
```{r, message=FALSE, warning=FALSE}
ggplot(data = agg_weeks)+ 
  
  # show data as tiles
  geom_tile(
    aes(x = week,
        y = location_name,
        fill = p_days_reported),      
    color = "white")+                 # white gridlines
  
  # text
  geom_text(
    aes(
      x = week,
      y = location_name,
      label = p_days_reported))+      # add text on top of tile
  
  # fill scale
  scale_fill_gradient(
    low = "orange",
    high = "darkgreen",
    na.value = "grey80")+
  
  # date axis
  scale_x_date(
    expand = c(0,0),             # remove extra space on sides
    date_breaks = "2 weeks",     # labels every 2 weeks
    date_labels = "%d\n%b")+     # format is day over month (\n in newline)
  
  # aesthetic themes
  theme_minimal()+                                    # simplify background
  
  theme(
    legend.title = element_text(size=12, face="bold"),
    legend.text  = element_text(size=10, face="bold"),
    legend.key.height = grid::unit(1,"cm"),           # height of legend key
    legend.key.width  = grid::unit(0.6,"cm"),         # width of legend key
    
    axis.text.x = element_text(size=12),              # axis text size
    axis.text.y = element_text(vjust=0.2),            # axis text alignment
    axis.ticks = element_line(size=0.4),               
    axis.title = element_text(size=12, face="bold"),  # axis title size and bold
    
    plot.title = element_text(hjust=0,size=14,face="bold"),  # title right-aligned, large, bold
    plot.caption = element_text(hjust = 0, face = "italic")  # caption right-aligned and italic
    )+
  
  # plot labels
  labs(x = "Week",
       y = "Facility name",
       fill = "Reporting\nperformance (%)",           # legend title, because legend shows fill
       title = "Percent of days per week that facility reported data",
       subtitle = "District health facilities, May-July 2020",
       caption = "7-day weeks beginning on Mondays.")
```




<!-- ======================================================= -->
## Kaynaklar { }

[scale_fill_gradient()](https://ggplot2.tidyverse.org/reference/scale_gradient.html)  

[R grafik galerisi - ısı haritası](https://ggplot2.tidyverse.org/reference/scale_gradient.html)  




```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/heatmaps.Rmd-->


# Diyagramlar ve çizelgeler { }  


```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "flow_chart.png"))
knitr::include_graphics(here::here("images", "sankey_diagram.png"))
```


Bu sayfa, aşağıdaki başlıkları kapsamaktadır:  

* **DiagrammeR* ve DOT dilini kullanan akış şemaları
* Alluvial/Sankey diyagramları  
* Etkinlik zaman çizelgeleri

<!-- * DAGs (Directed Acyclic Graphs)   -->
<!-- * GANTT charts   -->


<!-- ======================================================= -->
## Hazırlık { }

### Paketleri yükleme {.unnumbered}  

Bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen **pacman** paketinin `p_load()` işlevini vurguluyoruz. Ayrıca, R tabanından `library()` ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R temelleri sayfasına bakabilirsiniz.

```{r}
pacman::p_load(
  DiagrammeR,     # akış diyagramları için
  networkD3,      # Alluvial/Sankey diyagramları için
  tidyverse)      # veri yönetimi ve görselleştirme
```

### Verileri içe aktarma {.unnumbered}  

Bu sayfadaki içeriğin çoğu bir veri seti gerektirmez. Ancak, Sankey diyagramı bölümünde, simüle edilmiş bir Ebola salgınından vaka satır listesini kullanacağız. Bu bölümü takip etmek isterseniz, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>"temiz satır listesini" indirmek (.rds dosyası olarak) için tıklayabilirsiniz.</a> **rio** paketinden `import()` fonksiyonuyla verileri içe aktarabilirsiniz (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe ve Dışa Aktarma] sayfasına bakınız).  

```{r, echo=F}
# satır listesini R'a aktar
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# satır listesini içe aktar
linelist <- import("linelist_cleaned.rds")
```

Çizgi listesinin ilk 50 satırı aşağıda gösterilmiştir.

```{r, message=FALSE, echo=F}
# satır listesini tablo olarak göster
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


<!-- ======================================================= -->
## Akış diyagramları { }

Grafikler/akış şemaları oluşturmak için R paketi olan **DiagrammeR** kullanılabilir. Akış şemaları ister statik olabilirler veya isterse bir veri kümesindeki değişikliklere göre kısıtlı bir şekilde dinamik olarak ayarlanabilirler.

**Araçlar**  

`grViz()` fonksiyonu bir “Graphviz” diyagramı oluşturmak için kullanılır. Bu fonksiyon, diyagramı oluşturmak için talimatlar içeren bir karakter dizisi girişini kabul eder. Bu dizi içinde, talimatlar [DOT](https://graphviz.org/doc/info/lang.html) adı verilen farklı bir dilde yazılmıştır - temel bilgileri öğrenmek oldukça kolaydır.

**Temel yapı**  

1) `grViz("` talimatlarını açın 
2) Grafiğin yönlülüğünü ve adını belirtin ve parantezleri açın, örn. `digraph my_flow_chart {`
3) Grafik ifadesi (düzen, sıralama yönü)
4) Düğüm ifadeleri (düğüm oluşturma)
5) Kenar ifadeleri (düğümler arasında bağlantılar verir) 
6) Talimatları kapatın `}")`  

### Basit örnekler {.unnumbered} 

Aşağıda iki basit örnek verilmiştir

Çok minimal bir örnek:  

```{r out.width='50%'}
# Minimal bir grafik
DiagrammeR::grViz("digraph {
  
graph[layout = dot, rankdir = LR]

a
b
c

a -> b -> c
}")
```

Biraz daha uygulamalı halk sağlığı bağlamına sahip bir örnek: 

```{r out.width='50%'}
grViz("                           # Tüm talimatlar büyük bir karakter dizisi içindedir
digraph surveillance_diagram {    # digraph', 'yönlü grafik' anlamına gelir, ardından grafik adı
  
  # grafik ifadesi
  #################
  graph [layout = dot,
         rankdir = TB,
         overlap = true,
         fontsize = 10]
  
  # düğümler
  #######
  node [shape = circle,           # shape = circle
       fixedsize = true
       width = 1.3]               # width of circles
  
  Primary                         # names of nodes
  Secondary
  Tertiary

  # kenarlar
  #######
  Primary   -> Secondary [label = ' case transfer']
  Secondary -> Tertiary [label = ' case transfer']
}
")
```

### Sözdizimi  {.unnumbered}

**Temel sözdizimi**  

Düğüm adları veya kenar ifadeleri boşluk, noktalı virgül veya yeni satırlarla ayrılabilir.  

**Sıra yönü**  

Grafik ifadesi içindeki `rankdir` argümanı ayarlanarak bir çizim soldan sağa hareket edecek şekilde yeniden yönlendirilebilir. Varsayılan değer TB'dir (yukarıdan aşağıya), ancak LR (soldan sağa), RL (sağdan sola) veya BT (aşağıdan yukarıya) olabilir.

**Düğüm adları**  

Düğüm adları, yukarıdaki basit örnekte olduğu gibi tek kelime olabilir. Çok kelimeli adları veya özel karakterleri (örneğin parantezler, tireler) kullanmak için düğüm adını tek tırnak  (’ ’) içine koyun. Kısa bir düğüm adına sahip olmak ve aşağıda köşeli parantez  [ ] içinde gösterildiği gibi bir *etiket* atamak daha kolay olabilir. Düğümün adında yeni bir satır olmasını istiyorsanız, bunu bir etiket aracılığıyla yapmalısınız - aşağıda gösterildiği gibi düğüm etiketinde tek tırnak içinde `\n` kullanmalısınız.

**Alt gruplar**  
Kenar ifadeleri içinde, küme parantezleri ({ }) ile kenarın her iki tarafında alt gruplar oluşturulabilir. Kenar daha sonra parantez içindeki tüm düğümlere uygulanır - bu bir kısa gösterimdir.


**Düzenler**  

* dot (`rankdir` argümanını TB, LR, RL, BT seçeneklerinden biri olarak belirleyin)
* neato  
* twopi  
* circo  


**Düğümler - düzenlenebilir nitelikler**  

* `label` (metin, çok kelimeli ise tek tırnak içinde)  
* `fillcolor` (birçok olası renk)  
* `fontcolor`  
* `alpha` (şeffaflık 0-1)  
* `shape` (elips, oval, elmas, yumurta, düz metin, nokta, kare, üçgen)  
* `style`  
* `sides`  
* `peripheries`  
* `fixedsize` (h x w)  
* `height`  
* `width`  
* `distortion`  
* `penwidth` (şekil kenarlığının genişliği)  
* `x` (sola/sağa yer değiştirme)  
* `y` (yukarı/aşağı yer değiştirme)  
* `fontname`  
* `fontsize`  
* `icon`  


**Kenarlar - düzenlenebilir nitelikler**  

* `arrowsize`  
* `arrowhead` (normal, kutu, karga, eğri, elmas, nokta, inv, yok, tee, vee)  
* `arrowtail`  
* `dir` (yön, )  
* `style` (kesik çizgili, ...)  
* `color`  
* `alpha`  
* `headport` (ok başının önündeki metin)  
* `tailport` (ok kuyruğunun arkasındaki metin)  
* `fontname`  
* `fontsize`  
* `fontcolor`  
* `penwidth` (ok genişliği)  
* `minlen` (minimum uzunluk)

**Renk adları**: onaltılık değerler veya 'X11' renk adları, X11 ayrıntıları için [buraya bakabilirsiniz.](http://rich-iannone.github.io/DiagrammeR/graphviz_and_mermaid.html) 


### Karmaşık örnekler  {.unnumbered}

Aşağıdaki örnek, gsurveillance_diagram genişleterek karmaşık düğüm adları, gruplandırılmış kenarlar, renkler ve stil ekler


```
DiagrammeR::grViz("               # Tüm talimatlar büyük bir karakter dizisi
digraph surveillance_diagram {    # digraph', 'yönlü grafik' anlamına gelir, ardından grafik adı
  
  # grafik ifadesi
  #################
  graph [layout = dot,
         rankdir = TB,            # yukarıdan aşağıya düzen
         fontsize = 10]
  

  # düğümler (daireler)
  #################
  node [shape = circle,           # shape = daire
       fixedsize = true
       width = 1.3]                      
  
  Primary   [label = 'Primary\nFacility'] 
  Secondary [label = 'Secondary\nFacility'] 
  Tertiary  [label = 'Tertiary\nFacility'] 
  SC        [label = 'Surveillance\nCoordination',
             fontcolor = darkgreen] 
  
  # kenarlar
  #######
  Primary   -> Secondary [label = ' case transfer',
                          fontcolor = red,
                          color = red]
  Secondary -> Tertiary [label = ' case transfer',
                          fontcolor = red,
                          color = red]
  
  # gruplanmış kenar
  {Primary Secondary Tertiary} -> SC [label = 'case reporting',
                                      fontcolor = darkgreen,
                                      color = darkgreen,
                                      style = dashed]
}
")
```


```{r out.width='50%', echo=F}
DiagrammeR::grViz("               # Tüm talimatlar büyük bir karakter dizisi
digraph surveillance_diagram {    # digraph', 'yönlü grafik' anlamına gelir, ardından grafik adı
  
  # grafik ifadesi
  #################
  graph [layout = dot,
         rankdir = TB,            # yukarıdan aşağıya düzen
         fontsize = 10]
  

  # düğümler (daireler)
  #################
  node [shape = circle,           # shape = daire
       fixedsize = true
       width = 1.3]                      
  
  Primary   [label = 'Primary\nFacility'] 
  Secondary [label = 'Secondary\nFacility'] 
  Tertiary  [label = 'Tertiary\nFacility'] 
  SC        [label = 'Surveillance\nCoordination',
             fontcolor = darkgreen] 
  
  # kenarlar
  #######
  Primary   -> Secondary [label = ' case transfer',
                          fontcolor = red,
                          color = red]
  Secondary -> Tertiary [label = ' case transfer',
                          fontcolor = red,
                          color = red]
  
  # gruplanmış kenar
  {Primary Secondary Tertiary} -> SC [label = 'case reporting',
                                      fontcolor = darkgreen,
                                      color = darkgreen,
                                      style = dashed]
}
")
```

**Alt grafik kümeleri**  

Düğümleri kutulu kümeler halinde gruplamak için, onları aynı adlandırılmış alt grafik (`subgraph name {}`) içine koyun. Her bir alt grafiğin bir sınırlayıcı kutu içinde tanımlanmasını sağlamak için, aşağıdaki 4 kutu ile gösterildiği gibi alt grafiğin adına "küme" ile başlayın.

```
DiagrammeR::grViz("             # Tüm talimatlar büyük bir karakter dizisi içindedir
digraph surveillance_diagram {  # 'digraph', 'yönlü grafik' anlamına gelir, ardından grafik adı
  
  # grafik ifadesi
  #################
  graph [layout = dot,
         rankdir = TB,            
         overlap = true,
         fontsize = 10]
  

  # düğümler (daireler)
  #################
  node [shape = circle,                  # shape = daire
       fixedsize = true
       width = 1.3]                      # dairelerin genişliği
  
  subgraph cluster_passive {
    Primary   [label = 'Primary\nFacility'] 
    Secondary [label = 'Secondary\nFacility'] 
    Tertiary  [label = 'Tertiary\nFacility'] 
    SC        [label = 'Surveillance\nCoordination',
               fontcolor = darkgreen] 
  }
  
  # düğümler (kutular)
  ###############
  node [shape = box,                     # düğüm şekli
        fontname = Helvetica]            # düğümdeki metin yazı tipi
  
  subgraph cluster_active {
    Active [label = 'Active\nSurveillance'] 
    HCF_active [label = 'HCF\nActive Search']
  }
  
  subgraph cluster_EBD {
    EBS [label = 'Event-Based\nSurveillance (EBS)'] 
    'Social Media'
    Radio
  }
  
  subgraph cluster_CBS {
    CBS [label = 'Community-Based\nSurveillance (CBS)']
    RECOs
  }

  
  # kenarlar
  #######
  {Primary Secondary Tertiary} -> SC [label = 'case reporting']

  Primary   -> Secondary [label = 'case transfer',
                          fontcolor = red]
  Secondary -> Tertiary [label = 'case transfer',
                          fontcolor = red]
  
  HCF_active -> Active
  
  {'Social Media' Radio} -> EBS
  
  RECOs -> CBS
}
")

```


```{r out.width='120%', echo=F}
DiagrammeR::grViz("             # Tüm talimatlar büyük bir karakter dizisi içindedir
digraph surveillance_diagram {  # 'digraph', 'yönlü grafik' anlamına gelir, ardından grafik adı
  
  # grafik ifadesi
  #################
  graph [layout = dot,
         rankdir = TB,            
         overlap = true,
         fontsize = 10]
  

  # düğümler (daireler)
  #################
  node [shape = circle,                  # shape = daire
       fixedsize = true
       width = 1.3]                      # dairelerin genişliği
  
  subgraph cluster_passive {
    Primary   [label = 'Primary\nFacility'] 
    Secondary [label = 'Secondary\nFacility'] 
    Tertiary  [label = 'Tertiary\nFacility'] 
    SC        [label = 'Surveillance\nCoordination',
               fontcolor = darkgreen] 
  }
  
  # düğümler (kutular)
  ###############
  node [shape = box,                     # düğüm şekli
        fontname = Helvetica]            # düğümdeki metin yazı tipi
  
  subgraph cluster_active {
    Active [label = 'Active\nSurveillance'] 
    HCF_active [label = 'HCF\nActive Search']
  }
  
  subgraph cluster_EBD {
    EBS [label = 'Event-Based\nSurveillance (EBS)'] 
    'Social Media'
    Radio
  }
  
  subgraph cluster_CBS {
    CBS [label = 'Community-Based\nSurveillance (CBS)']
    RECOs
  }

  
  # kenarlar
  #######
  {Primary Secondary Tertiary} -> SC [label = 'case reporting']

  Primary   -> Secondary [label = 'case transfer',
                          fontcolor = red]
  Secondary -> Tertiary [label = 'case transfer',
                          fontcolor = red]
  
  HCF_active -> Active
  
  {'Social Media' Radio} -> EBS
  
  RECOs -> CBS
}
")

```


**Düğüm şekilleri**  

[Linkteki rehberden](http://rich-iannone.github.io/DiagrammeR/) alınan aşağıdaki örnek, uygulanan düğüm şekillerini ve seri kenar bağlantıları için bir kısayol gösterir.

```{r out.width='75%'}
DiagrammeR::grViz("digraph {

graph [layout = dot, rankdir = LR]

# düğümlerin global stillerini tanımlar. İstersek bunları kutuda geçersiz kılabiliriz
node [shape = rectangle, style = filled, fillcolor = Linen]

data1 [label = 'Dataset 1', shape = folder, fillcolor = Beige]
data2 [label = 'Dataset 2', shape = folder, fillcolor = Beige]
process [label =  'Process \n Data']
statistical [label = 'Statistical \n Analysis']
results [label= 'Results']

# düğüm kimlikleri ile kenar tanımları
{data1 data2}  -> process -> statistical -> results
}")
```


### Çıktılar  {.unnumbered}

Çıktılar nasıl işlenir ve kaydedilir: 

* Çıktılar, varsayılan olarak Dosyalar, Grafikler, Paketler ve Yardım'ın yanında sağ altta RStudio'nun Görüntüleyici bölmesinde görünecektir.  
* Dışa aktarmak için Görüntüleyiciden “Görüntü olarak kaydet” veya “Panoya kopyala” yapabilirsiniz. Grafik belirtilen boyuta ayarlanacaktır.


### Parametreli şekiller {.unnumbered} 

Size önerebileceğimiz güzel bir rehberden bir alıntı ile başlamak istiyoruz: https://mikeyharper.uk/flowcharts-in-r-using-diagrammer/

"Parametreli şekiller: Rakamları R içinde tasarlamanın büyük bir yararı, R değerlerini doğrudan akış şemalarımıza okuyarak rakamları doğrudan analizimizle bağlayabilmemizdir. Örneğin, bir işlemin her aşamasından sonra değerleri kaldıran bir filtreleme işlemi oluşturduğunuzu varsayalım, işleminizin her aşamasından sonra veri kümesinde kalan değerlerin sayısını gösteren bir şekle sahip olabilirsiniz. Bunu yapmak için, @@X sembolünü doğrudan şeklin içinde kullanabilir, ardından grafiğin alt bilgisinde [X]: kullanarak buna başvurabilirsiniz, burada X benzersiz bir sayısal dizindir."

Parametrelendirme ilgilendiğiniz bir şeyse, bu rehberi incelemenizi öneririz.


<!-- And below is some example code from this tutorial. -->

<!-- ```{r, eval=F} -->
<!-- # Define some sample data -->
<!-- data <- list(a=1000, b=800, c=600, d=400) -->


<!-- DiagrammeR::grViz(" -->
<!-- digraph graph2 { -->

<!-- graph [layout = dot] -->

<!-- # node definitions with substituted label text -->
<!-- node [shape = rectangle, width = 4, fillcolor = Biege] -->
<!-- a [label = '@@1'] -->
<!-- b [label = '@@2'] -->
<!-- c [label = '@@3'] -->
<!-- d [label = '@@4'] -->

<!-- a -> b -> c -> d -->

<!-- } -->

<!-- [1]:  paste0('Raw Data (n = ', data$a, ')') -->
<!-- [2]: paste0('Remove Errors (n = ', data$b, ')') -->
<!-- [3]: paste0('Identify Potential Customers (n = ', data$c, ')') -->
<!-- [4]: paste0('Select Top Priorities (n = ', data$d, ')') -->
<!-- ") -->

<!-- ``` -->



<!-- ### CONSORT diagram  {.unnumbered} -->

<!-- THIS SECTION IS UNDER CONSTRUCTION   -->

<!-- https://scriptsandstatistics.wordpress.com/2017/12/22/how-to-draw-a-consort-flow-diagram-using-r-and-graphviz/ -->

<!-- Note above is out of date via DiagrammeR -->


<!-- ======================================================= -->
## Alluvial/Sankey Diyagramları { }

### Paketleri yükleme {.unnumbered}  

Bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen **pacman** paketinin `p_load()` işlevini vurguluyoruz. Ayrıca, R tabanından `library()` ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R temelleri sayfasına bakabilirsiniz.

Diyagramı oluşturmak için **networkD3** paketini ve ayrıca veri hazırlama adımları için **tidyverse**'i yüklüyoruz.

```{r}
pacman::p_load(
  networkD3,
  tidyverse)
```

### Veri kümesinden grafik yapma {.unnumbered} 

Bağlantıları bir veri kümesinde çizme. Aşağıda bu paketi vaka satırı listesinde kullanmayı gösteriyoruz. [Çevrimiçi bir eğitime ulaşmak için bu linke tıklayabilirsiniz.](https://www.r-graph-gallery.com/321-introduction-to-interactive-sankey-diagram-2.html).    

Her benzersiz yaş kategorisi ve hastane kombinasyonu için vaka sayılarını alarak başlıyoruz. Anlaşılır olması için yaş kategorisine ait eksik değerleri kaldırdık. Ayrıca `hospital` ve `age_cat` sütunlarını sırasıyla `source` ve `target` olarak yeniden etiketliyoruz. Bunlar alluvial diyagramının iki yüzü olacaktır.

```{r}
# hastane ve yaş kategorisine göre sayımlar
links <- linelist %>% 
  drop_na(age_cat) %>% 
  select(hospital, age_cat) %>%
  count(hospital, age_cat) %>% 
  rename(source = hospital,
         target = age_cat)
```

Veri kümesi şimdi şöyle görünmektedir: 

```{r message=FALSE, echo=F}
DT::datatable(links, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

Şimdi `sütun adı` altında tüm diyagram düğümlerinin bir veri çerçevesini oluşturuyoruz. Bu, `hospital` ve `age_cat`'e ait bütün değerlerden oluşmaktadır. Birleştirmeden önce hepsinin karakter sınıfı olduğundan emin olmalı ve kimlik sütunlarını etiketler yerine sayı olacak şekilde ayarlamalıyız:

```{r}
# Benzersiz düğüm adları
nodes <- data.frame(
  name=c(as.character(links$source), as.character(links$target)) %>% 
    unique()
  )

nodes  # yazdır
```

Yukarıda oluşturduğumuz link veri çerçevesini `count()` ile düzenliyoruz. Düğümler arasındaki bağlantıları gerçekten yansıtacak/oluşturacak iki sayısal sütun `IDsource` ve `IDtarget` ekliyoruz. Bu sütunlar, kaynak ve hedef düğümlerin satır numaralarını (konumunu) tutacaktır. 1 çıkarılır, böylece bu konum numaraları 0'dan başlar (1 değil).

```{r}
# isimlerle değil sayılarla eşleştirir
links$IDsource <- match(links$source, nodes$name)-1 
links$IDtarget <- match(links$target, nodes$name)-1
```

Bağlantı veri kümesi şimdi şöyle görünür: 

```{r message=FALSE, echo=F}
DT::datatable(links, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

Şimdi Sankey diyagramını `sankeyNetwork()` ile çizebiliriz. Konsolda `?sankeyNetwork` komutunu çalıştırarak her bir bağımsız değişkeni hakkında daha fazla bilgi edinebilirsiniz. `iterations = 0` olarak ayarlamadığınız sürece düğümlerinizin sırasının beklendiği gibi olmayabileceğini unutmayın.

```{r}

# grafik
######
p <- sankeyNetwork(
  Links = links,
  Nodes = nodes,
  Source = "IDsource",
  Target = "IDtarget",
  Value = "n",
  NodeID = "name",
  units = "TWh",
  fontSize = 12,
  nodeWidth = 30,
  iterations = 0)        # düğüm sırasının verilerdeki gibi olduğundan emin olun
p
```

Burada hasta çıktısının da dahil edildiği bir örnek verilmiştir. Veri hazırlama adımında, yaş ile hastane arasındaki ve hastane ile sonuç arasındaki vaka sayılarını ayrı ayrı hesaplamamız gerektiğine ve ardından tüm bu sayıları `bind_rows()` ile birbirine bağlamamız gerektiğine dikkat etmelisiniz.

```{r}
# hastane ve yaş kategorisine göre sayımlar
age_hosp_links <- linelist %>% 
  drop_na(age_cat) %>% 
  select(hospital, age_cat) %>%
  count(hospital, age_cat) %>% 
  rename(source = age_cat,          # yeniden adlandır
         target = hospital)

hosp_out_links <- linelist %>% 
    drop_na(age_cat) %>% 
    select(hospital, outcome) %>% 
    count(hospital, outcome) %>% 
    rename(source = hospital,       # yeniden adlandır
           target = outcome)

# bağlantıları birleştir
links <- bind_rows(age_hosp_links, hosp_out_links)

# Benzersiz düğüm adları
nodes <- data.frame(
  name=c(as.character(links$source), as.character(links$target)) %>% 
    unique()
  )

# Kimlik numaraları oluştur
links$IDsource <- match(links$source, nodes$name)-1 
links$IDtarget <- match(links$target, nodes$name)-1

# grafik
######
p <- sankeyNetwork(Links = links,
                   Nodes = nodes,
                   Source = "IDsource",
                   Target = "IDtarget",
                   Value = "n",
                   NodeID = "name",
                   units = "TWh",
                   fontSize = 12,
                   nodeWidth = 30,
                   iterations = 0)
p

```


https://www.displayr.com/sankey-diagrams-r/



<!-- ======================================================= -->
## Etkinlik zaman çizelgeleri { }

Belirli olayları gösteren bir zaman çizelgesi oluşturmak için `vistime` paketini kullanabilirsiniz.

[Linkteki bu gösterimi inceleyebilirsiniz](https://cran.r-project.org/web/packages/vistime/vignettes/vistime-vignette.html#ex.-2-project-planning)

```{r}
# paketi yükle
pacman::p_load(vistime,  # zaman çizelgesini hazırla
               plotly    # etkileşimli görselleştirme için
               )
```

```{r, echo=F}
# referans: https://cran.r-project.org/web/packages/vistime/vignettes/vistime-vignette.html#ex.-2-project-planning

data <- read.csv(text="event, group, start, end, color
                       Event 1, Group A,2020-01-22,2020-01-22, #90caf9
                       Event 1, Group B,2020-01-23,2020-01-23, #90caf9
                       Event 1, Group C,2020-01-23,2020-01-23, #1565c0
                       Event 1, Group D,2020-01-25,2020-01-25, #f44336
                       Event 1, Group E,2020-01-25,2020-01-25, #90caf9
                       Event 1, Group F,2020-01-26,2020-01-26, #8d6e63
                       Event 1, Group G,2020-01-27,2020-01-27, #1565c0
                       Event 1, Group H,2020-01-27,2020-01-27, #90caf9
                       Event 1, Group I,2020-01-27,2020-01-27,#90a4ae
                       Event 2, Group A,2020-01-28,2020-01-28,#fc8d62
                       Event 2, Group C,2020-01-28,2020-01-28, #6a3d9a
                       Event 2, Group J,2020-01-28,2020-01-28, #90caf9
                       Event 2, Group J,2020-01-28,2020-01-28, #fc8d62
                       Event 2, Group J,2020-01-28,2020-01-28, #1565c0
")
```

İşte kodladığımız olaylar veri seti:

```{r message=FALSE, echo=F}
DT::datatable(data, rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```



```{r}
p <- vistime(data)    # vistime'ı uygula

library(plotly)

# 1. adım: bir listeye dönüştür
pp <- plotly_build(p)

# 2. adım: İşaretleyici boyutu
for(i in 1:length(pp$x$data)){
  if(pp$x$data[[i]]$mode == "markers") pp$x$data[[i]]$marker$size <- 10
}

# 3. adım: metin boyutu
for(i in 1:length(pp$x$data)){
  if(pp$x$data[[i]]$mode == "text") pp$x$data[[i]]$textfont$size <- 10
}


# 4. adım: metin konumu
for(i in 1:length(pp$x$data)){
  if(pp$x$data[[i]]$mode == "text") pp$x$data[[i]]$textposition <- "right"
}

#yazdır
pp

```


<!-- ======================================================= -->
## DAG'ler { }

Yukarıda açıklandığı gibi **DiagammeR** paketini ve DOT dilini kullanarak manuel olarak bir DAG oluşturabilirsiniz.

Alternatif olarak, **ggdag** ve **dagitty** gibi paketler de var.

[DAG'lere giriş ggdag gösterimi](https://cran.r-project.org/web/packages/ggdag/vignettes/intro-to-dags.html)   

[R'deki dag’lere nedensellik](https://www.r-bloggers.com/2019/08/causal-inference-with-dags-in-r/#:~:text=In%20a%20DAG%20all%20the,for%20drawing%20and%20analyzing%20DAGs.)  


<!-- ======================================================= -->
## Kaynaklar { }

[DOT diliyle ilgili yukarıdakilerin çoğu bu sitedeki öğreticiden uyarlanmıştır.](https://mikeyharper.uk/flowcharts-in-r-using-diagrammer/)  

[DiagammeR hakkında daha ayrıntılı bir eğitim daha ](http://rich-iannone.github.io/DiagrammeR/)

[Sankey diagramları hakkında bu sayfa](https://www.displayr.com/sankey-diagrams-r/)  
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/diagrams.Rmd-->


# Kombinasyon analizi { }  

```{r echo=F, out.width= "75%", warning=F, message=F}
pacman::p_load(tidyverse,
               UpSetR,
               ggupset)

# Rastgele "evet" veya "hayır" değerleriyle satır listesine yeni belirti değişkenleri ekler
linelist_sym <- linelist %>% 
  mutate(fever  = sample(c("yes", "no"), nrow(linelist), replace = T, prob = c(0.80, 0.20)),
         chills = sample(c("yes", "no"), nrow(linelist), replace = T, prob = c(0.20, 0.80)),
         cough  = sample(c("yes", "no"), nrow(linelist), replace = T, prob = c(0.9, 0.15)),
         aches  = sample(c("yes", "no"), nrow(linelist), replace = T, prob = c(0.10, 0.90)),
         vomit = sample(c("yes", "no"), nrow(linelist), replace = T))

linelist_sym_2 <- linelist_sym %>% 
     
  #mutate(fever = ifelse(fever == "yes", colnames(linelist)[which(colnames(linelist) == "fever")]))
   mutate(across(.cols = c(fever, chills, cough, aches, vomit),
                 .fns = ~+(.x == "yes")))   

# Grafiği çizim
UpSetR::upset(
  select(linelist_sym_2, fever, chills, cough, aches, vomit),
  sets = c("fever", "chills", "cough", "aches", "vomit"),
  order.by = "freq",
  sets.bar.color = c("blue", "red", "yellow", "darkgreen", "orange"), # seçenekli renkler
  empty.intersections = "on",
  # nsets = 3,
  number.angles = 0,
  point.size = 3.5,
  line.size = 2, 
  mainbar.y.label = "Symptoms Combinations",
  sets.x.label = "Patients with Symptom")

```



Bu analiz grafikleri, değerlerin/yanıtların farklı **kombinasyonlarının** sıklığını gösterir. Bu örnekte, vakaların çeşitli semptom kombinasyonları sergilediği sıklığı çiziyoruz.

Bu analize genellikle şu ad verilir:

* **"Çoklu yanıt analizi"**
* **"Küme analizi"**
* **"Kombinasyon analizi"**

Yukarıdaki örnek çizimde, beş belirti gösterilmektedir. Her dikey çubuğun altında, yukarıdaki çubuk tarafından yansıtılan semptomların kombinasyonunu gösteren bir çizgi ve noktalar bulunur. Sağda, yatay çubuklar her bir semptomun sıklığını yansıtır.

Gösterdiğimiz ilk yöntem **ggupset** paketini, ikincisi ise **UpSetR** paketini kullanmaktadır.

## Hazırlık {  }

### Paketleri yükleyin {.unnumbered}

Bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran *ve* kullanım için yükleyen **pacman**'dan `p_load()` vurgusu yapıyoruz. R **tabanı**ndan `library()` ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakabilirsiniz.

```{r, warning=F, message=F}
pacman::p_load(
  tidyverse,     # veri yönetimi ve görselleştirme
  UpSetR,        # kombinasyon grafikleri için özel paket
  ggupset)       # kombinasyon grafikleri için özel paket
```

<!-- ======================================================= -->
### Verileri içe aktar {.unnumbered}


Başlamak için, simüle edilmiş bir Ebola salgınından temizlenmiş vaka listesini içe aktarıyoruz. Takip etmek isterseniz, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>"clean" dosyasını indirmek için tıklayın. </a> (.rds dosyası olarak). **rio** paketinden `import()` fonksiyonuyla verileri içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe aktarma ve dışa aktarma] sayfasına bakın).


```{r, echo=F}
# Satırlistesini R içine aktarın
linelist_sym <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# Vaka satırlistesini içe aktarın
linelist_sym <- import("linelist_cleaned.rds")
```


Bu satır listesi, bildirilen semptomlarla ilgili beş "evet/hayır" değişkeni içerir. Grafiğimizi oluşturmak için **ggupset** paketini kullanmak için bu değişkenleri biraz dönüştürmemiz gerekecek. Verileri görüntüleyin (semptom değişkenlerini görmek için sağa kaydırın).

```{r, message=FALSE, echo=F}
# satırlistesi verisini tabloda gösterin
DT::datatable(head(linelist_sym, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```



<!-- ======================================================= -->
### Değerleri yeniden biçimlendir {.unnumbered}

**ggupset** tarafından beklenen formata uyum sağlamak için **dplyr**'den `case_while()` kullanarak gerçek semptom adını "evet" ve "hayır"a dönüştürürüz. "Hayır" ise, değeri boş olarak ayarlarız, bu nedenle değerler "NA" veya semptomdur. 
 

```{r, warning=F, message=F}
# noktalı virgülle ayrılmış olarak adlandırılmış belirtilerle sütun oluşturun
linelist_sym_1 <- linelist_sym %>% 
  
  # "evet" ve "hayır" değerlerini semptom adının kendisine dönüştürün
  mutate(fever = ifelse(fever == "yes", "fever", NA), 
       chills = ifelse(chills == "yes", "chills", NA),
       cough = ifelse(cough == "yes", "cough", NA),
       aches = ifelse(aches == "yes", "aches", NA),
       vomit = ifelse(vomit == "yes", "vomit", NA))
```

Şimdi iki son sütun yapıyoruz:

1. Hastanın tüm semptomlarını birleştirmek (birbirine yapıştırmak) (bir karakter sütunu)
2. Yukarıdaki sütunu *list* sınıfına dönüştürmek, böylece grafik yapmak için **ggupset** tarafından kabul edilebilir.

**stringr**'den `unite()` fonksiyonu hakkında daha fazla bilgi edinmek için [Karakterler ve dizeler] hakkındaki sayfaya bakabilirsiniz.

```{r, warning=F, message=F}
linelist_sym_1 <- linelist_sym_1 %>% 
  unite(col = "all_symptoms",
        c(fever, chills, cough, aches, vomit), 
        sep = "; ",
        remove = TRUE,
        na.rm = TRUE) %>% 
  mutate(
    # all_symptoms sütununun, "list" sınıfının (bir sonraki adımda ggupset() kullanmak için gereklidir) bir kopyasını yapın
    all_symptoms_list = as.list(strsplit(all_symptoms, "; "))
    )
```

Yeni verileri görüntüleyin. Sağ uca doğru iki sütuna dikkat edin - yapıştırılan birleştirilmiş değerler ve liste

```{r, echo=F, , warning=F, message=F}
DT::datatable(head(linelist_sym_1,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```


<!-- ======================================================= -->
## **ggupset** {  }

Paketi yükleme 

```{r}
pacman::p_load(ggupset)
```


Grafik oluşturun. Bir `ggplot()` ve `geom_bar()` ile başlıyoruz, ancak sonra **ggupset**'ten `scale_x_upset()` özel fonksiyonunu ekliyoruz. 

```{r, warning=F, message=F}
ggplot(
  data = linelist_sym_1,
  mapping = aes(x = all_symptoms_list)) +
geom_bar() +
scale_x_upset(
  reverse = FALSE,
  n_intersections = 10,
  sets = c("fever", "chills", "cough", "aches", "vomit"))+
labs(
  title = "Signs & symptoms",
  subtitle = "10 most frequent combinations of signs and symptoms",
  caption = "Caption here.",
  x = "Symptom combination",
  y = "Frequency in dataset")

```
  
**ggupset** hakkında daha fazla bilgiyi [çevrimiçi](https://rdrr.io/cran/ggupset/man/scale_x_upset.html) veya çevrimdışı olarak RStudio Yardım sekmeniz `?ggupset` içindeki paket belgelerinde bulabilirsiniz.


<!-- ============================================ ========= -->
## `UpSetR` { }

**UpSetR** paketi grafiğin daha fazla özelleştirilmesine izin verir, ancak yürütülmesi daha zor olabilir:


**Paketi yüklemek**

```{r}
pacman::p_load(UpSetR)
```

**Veri temizliği**  

'satırlistesi' semptom değerlerini 1 / 0'a çevirmeliyiz.

```{r}
# upSetR kullanarak yapın

linelist_sym_2 <- linelist_sym %>% 
  
  # "evet" ve "hayır" değerlerini semptom adının kendisine dönüştürün
     mutate(fever = ifelse(fever == "yes", 1, 0), 
            chills = ifelse(chills == "yes", 1, 0),
            cough = ifelse(cough == "yes", 1, 0),
            aches = ifelse(aches == "yes", 1, 0),
            vomit = ifelse(vomit == "yes", 1, 0))
```

Daha verimli bir komutla ilgileniyorsanız, mantıksal bir ifadeye dayalı olarak 1'lere ve 0'lara dönüştüren `+()` işlevinden yararlanabilirsiniz. Bu komut, aynı anda birden fazla sütunu değiştirmek için `across()` fonksiyonunu kullanır (daha fazla bilgi için [Veri temizleme ve temel fonksiyonlar](#clean_across)).  


```{r, eval=F, echo=T}
# Efficiently convert "yes" to 1 and 0
linelist_sym_2 <- linelist_sym %>% 
  
  # convert the "yes" and "no" values into 1s and 0s
  mutate(across(c(fever, chills, cough, aches, vomit), .fns = ~+(.x == "yes")))
```


Şimdi 'upset()' özel fonksiyonunu kullanarak grafiği yapın - yalnızca belirtiler sütunlarını kullanarak. Hangi "kümelerin" karşılaştırılacağını belirlemelisiniz (semptom sütunlarının adları). Alternatif olarak, yalnızca en iyi X kombinasyonlarını göstermek için `nsets = ` ve `order.by = "freq"` kullanın.

```{r, warning=F, message=F}

# Grafiği çizin
linelist_sym_2 %>% 
     UpSetR::upset(
       sets = c("fever", "chills", "cough", "aches", "vomit"),
       order.by = "freq",
       sets.bar.color = c("blue", "red", "yellow", "darkgreen", "orange"), # optional colors
       empty.intersections = "on",
       # nsets = 3,
       number.angles = 0,
       point.size = 3.5,
       line.size = 2, 
       mainbar.y.label = "Symptoms Combinations",
       sets.x.label = "Patients with Symptom")

```


<!-- ======================================================= -->
## Kaynaklar {  }

[UpSetR üzerine github sayfası](https://github.com/hms-dbmi/UpSetR)  

[A Shiny uygulama versiyonu - kendi verinizi yükleyebilirsiniz](https://gehlenborglab.shinyapps.io/upsetr/)  

[*belgeler - yorumlanması zor](https://cran.r-project.org/web/packages/UpSetR/UpSetR.pdf)  


```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/combination_analysis.Rmd-->


# İletim Zincirleri { }


<!-- ======================================================= -->
## Genel Bakış {  }

İletim zincirlerini ve temas izleme verilerini işlemek, analiz etmek ve görselleştirmek için birincil araç, RECON tarafından geliştirilen epicontacts paketidir. Daha fazla bilgi için imleci nodların üzerine getirerek, taşımak için sürükleyerek ve aşağı akış durumlarını vurgulamak için üzerlerine tıklayarak aşağıdaki etkileşimli grafiği deneyin

```{r out.width=c('25%', '25%'), fig.show='hold', echo=F}

## epicontacts'ın geliştirme sürümünü yükleyin
if(
  !"epicontacts" %in% rownames(installed.packages()) |
  packageVersion("epicontacts") != "1.2.0"
) remotes::install_github("reconhub/epicontacts@timeline")

## paketleri yükleyin ve kurun
pacman::p_load(tidyverse,
               #epicontacts,
               magrittr, here, webshot, visNetwork)

library(epicontacts)

## satır listesini yükleyin
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds")) %>%
  filter(!duplicated(case_id))

## kişileri oluşturun
contacts <- linelist %>%
  transmute(
    from = infector,
    to = case_id,
    location = sample(c("Community", "Nosocomial"), n(), TRUE),
    duration = sample.int(10, n(), TRUE)
  ) %>%
  drop_na(from)

## epicontacts oluşturun
epic <- epicontacts::make_epicontacts(
  linelist = linelist,
  contacts = contacts, 
  directed = TRUE
)

## alt küme nesnesi
epic %<>% subset(
  node_attribute = list(date_onset = c(as.Date(c("2014-06-01", "2014-07-01"))))
) %>%
  thin("contacts")

## x ekseni olarak başlangıç tarihi ile grafik çiz
plot(
  epic,
  x_axis = "date_onset",
  label = FALSE,
  node_color = "outcome",
  col_pal = c(Death = "firebrick", Recover = "green"),
  node_shape = "gender",
  shapes = c(f = "female", m = "male"),
  unlinked_pos = "bottom",
  date_labels = "%b %d %Y",
  node_size = 35,
  font_size = 20,
  arrow_size = 0.5,
  height = 800,
  width = 700,
  edge_linetype = "location",
  legend_width = 0.15,
  highlight_downstream = TRUE,
  selector = FALSE
)

```

<!-- ======================================================= -->
## Hazırlık {  }

### Paketlerin yüklenmesi {.unnumbered}  

Önce verilerin içe aktarılması ve işlenmesi için gereken standart paketleri yükleyin. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman'ın 'p_load()' fonksiyonunu vurguluyoruz. Ayrıca  R tabanı'ndan 'library()' ile paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R’ın temelleri[R Basics] sayfasına bakın.
 
	
```{r transmission_chains_packages, eval = FALSE}
pacman::p_load(
   rio,          # Dosyanın içe aktarımı 
   here,         # Dosyanın konumlandırılması 
   tidyverse,    # Veri yönetimi + ggplot2 grafikleri
   remotes       # github’dan paketlerin kurulumu  
)
```
	
Pacman'ın p_install_github() fonksiyonu kullanılarak github'dan yüklenebilen epicontacts’ın geliştirme sürümüne ihtiyacınız olacak. Aşağıdaki komutu yalnızca bir kez çalıştırmanız gerekir, paketi her kullandığınızda değil (bundan sonra her zamanki gibi p_load() kullanabilirsiniz).

```{r transmission_chains_epicontacts_install, eval = FALSE}
pacman::p_install_gh("reconhub/epicontacts@timeline")
```


### Verinin içeri aktarımı {.unnumbered}

Simüle edilmiş bir Ebola salgını vakalarından oluşan veri setini içe aktarıyoruz. Adım adım verileri indirmek istiyorsanız, el kitabı ve verilerin indirilmesi sayfasındaki talimatlara [Download handbook and data] bakın. Veri seti, rio paketinden import() fonkisyonu kullanılarak içe aktarılır. Verileri içe aktarmanın çeşitli yolları için İçe ve dışa aktarma sayfasına [Import and export] bakın.

```{r, echo=F}
# satır listesini R içine aktarın
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# satır listesini içe aktarın
linelist <- import("linelist_cleaned.xlsx")
```

Çizgi listesinin ilk 50 satırı aşağıda gösterilmiştir. Özellikle ilgi çekici olan sütunlar : 'case_id', 'generation', 'infector' ve 'source'.

```{r, message=FALSE, echo=F}
# satır listesi verisini tabloda gösterin
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


### Epicontacts nesnesi oluşturma  {.unnumbered}

Daha sonra iki tür veri gerektiren bir epicontacts nesnesi oluşturmamız gerekiyor:
• Sütunların değişken olduğu ve satırların benzersiz durumlara karşılık geldiği bir satır listesi
• Benzersiz kimliklerle vakalar arasındaki bağlantıları tanımlayan kenarların bir listesi (bunlar kişiler, aktarım olayları vb. olabilir)

Halihazırda bir satır listemiz olduğundan, vakalar arasında, daha spesifik olarak kimlikleri arasında bir kenar listesi oluşturmamız gerekiyor. Enfektör sütununu 'case_id' sütununa bağlayarak satır listesinden iletim bağlantılarını çıkarabiliriz. Bu noktada, vakaların kendilerini değil, iki durum arasındaki bağlantıyı tanımlayan herhangi bir değişkeni gösterdiğimiz kenar özelliklerini (edge properties) de ekleyebiliriz. Örnek olarak, iletim olayının konumunu tanımlayan bir konum değişkeni ve gün cinsinden temasın süresini tanımlayan bir süre değişkeni ekleyeceğiz.

Aşağıdaki kodda, dplyr fonksiyonu transmut'e, yalnızca fonksiyon içinde belirttiğimiz sütunları tutması dışında mutate’e benzer. drop_na fonksiyonu, belirtilen sütunlarda bir NA değeri olan tüm satırları filtreleyecektir; bu durumda, yalnızca bulaştırıcının bilindiği satırları tutmak istiyoruz.


```{r transmission_chains_create_contacts,}
## kişileri oluştur
contacts <- linelist %>%
  transmute(
    infector = infector,
    case_id = case_id,
    location = sample(c("Community", "Nosocomial"), n(), TRUE),
    duration = sample.int(10, n(), TRUE)
  ) %>%
  drop_na(infector)
```

Artık 'make_epicontacts' fonksiyonunu kullanarak epicontacts nesnesini oluşturabiliriz. Satır listesindeki hangi sütunun benzersiz vaka tanımlayıcısına işaret ettiğini ve ayrıca ilgili kişilerdeki hangi sütunların bağlantıda yer alan vakaların benzersiz tanımlayıcılarına işaret ettiğini belirtmemiz gerekir. Bu bağlantılar, enfeksiyonun bulaştırıcıdan vakaya gittiği yöndedir, bu nedenle başlangıç ve sonuç değişkenlerini belirtmemiz gerekir. Bu sebeple, gelecekteki işlemleri etkileyecek olan yönlendirilmiş (directed) değişkenini TRUE olarak ayarladık.

```{r transmission_chains_create_epicontacts,}
## epicontacts nesnesi oluştur 
epic <- make_epicontacts(
  linelist = linelist,
  contacts = contacts,
  id = "case_id",
  from = "infector",
  to = "case_id",
  directed = TRUE
)
```

Epicontacts nesnelerini inceledikten sonra, satır listesindeki case_id sütununun id olarak yeniden adlandırıldığını ve temaslılardaki case_id ve infector sütunlarının from (-den) ve to (-e) olarak yeniden adlandırıldığını görebiliriz. Bu adım, sonraki işleme, görselleştirme ve analiz işlemlerinde tutarlılık sağlar.

```{r transmission_chains_view_epicontacts,}
##  epicontacts nesnesini göster
epic
```

<!-- ======================================================= -->
## İdare {  }

### Altkümeleme {.unnumbered}

epicontacts nesneleri için subset() yöntemi, diğer nesnelerin yanı sıra, satır listesinin ("düğüm(nod) öznitelikleri") ve kişiler veritabanının ("kenar öznitelikleri") özelliklerine dayalı olarak ağların filtrelenmesine olanak tanır. Bu değerler, ilgili bağımsız değişkene adlandırılmış listeler olarak iletilmelidir. Örneğin, aşağıdaki kodda sadece Nisan-Temmuz 2014 arasında enfeksiyonu olan (tarihler aralık olarak belirtilmiştir) erkek vakaları ve hastanede meydana gelen bulaşma bağlantılarını satır listesinde tutuyoruz.


```{r transmission_chains_subset_nodes,}
sub_attributes <- subset(
  epic,
  node_attribute = list(
    gender = "m",
    date_infection = as.Date(c("2014-04-01", "2014-07-01"))
  ), 
  edge_attribute = list(location = "Nosocomial")
)
sub_attributes
```

thin fonksiyonunu, 'what = "linelist"' değişkeniyle temaslılarda bulunan vakaları dahil etmek için satır listesini filtrelemek veya 'what = "contacts”' değişkeniyle satır listesinde bulunan vakaları dahil etmek için kullanabiliriz. Aşağıdaki kodda, yukarıda filtrelediğimiz Nisan ve Temmuz ayları arasında enfekte olan erkek vakaları içeren iletim bağlantılarını tutmak için epicontacts nesnesini ayrıca filtreliyoruz. Sadece iki bilinen iletim bağlantısının bu filtreye uyduğunu görebiliriz.

```{r transmission_chains_thin,}
sub_attributes <- thin(sub_attributes, what = "contacts")
nrow(sub_attributes$contacts)
```

Nod ve kenar özniteliklerine göre alt kümelemeye ek olarak, ağlar yalnızca belirli nodlara bağlı bileşenleri içerecek şekilde budanabilir. 'Cluster_id' değişkeni, vaka kimliklerinin bir vektörünü alır ve doğrudan veya dolaylı olarak bu kimliklere bağlı bireylerin satır listesini getirir. Aşağıdaki kodda, '2ae019' ve '71577a' içeren kümelerde toplam 13 satır listesi vakasının yer aldığını görebiliriz.


```{r}
sub_id <- subset(epic, cluster_id = c("2ae019","71577a"))
nrow(sub_id$linelist)
```

epicontacts nesneleri için subset() yöntemi ayrıca cs, cs_min ve cs_max değişkenlerini kullanarak küme boyutuna göre filtrelemeye izin verir. Aşağıdaki kodda, yalnızca 10 vaka veya daha büyük kümelere dahil olan vakaları tutuyoruz ve bu kümelerde 271 satır listesi vakasının yer aldığını görebiliriz.

    
```{r}   
sub_cs <- subset(epic, cs_min = 10)
nrow(sub_cs$linelist)
```

### ID'lere ulaşmak {.unnumbered}

get_id() fonksiyonu, veri setindeki vaka kimlikleri hakkında bilgi toplar ve aşağıdaki gibi parametrelenebilir:
• **linelist**: satır listesi verilerindeki kimlikler
• **contacts**: temaslı veri setindeki kimlikler (“from-kimden” ve “to-kime” birleşik)
• **from**: temaslı veri setinin "kimden" sütunundaki kimlikler
• **to**: temaslı veri setinin "to" sütunundaki kimliklere
• **all**: Her iki veri kümesinde de herhangi bir yerde görünen kimlikler
• **common**: Hem temaslı veri setinde hem de satır listesinde görünen kimlikler

Örneğin,  veri kümesindeki ilk on kimlik nedir?

```{r transmission_chains_get_ids,}
contacts_ids <- get_id(epic, "contacts")
head(contacts_ids, n = 10)
```

Hem satır listesinde hem de temaslılarda kaç kimlik var?

```{r transmission_chains_get_both,}
length(get_id(epic, "common"))
```

<!-- ======================================================= -->
## Görselleştirme {  }

### Temel grafik oluşturma {.unnumbered}

Epicontacts nesnelerinin tüm görselleştirmeleri, plot fonksiyonu tarafından gerçekleşitirilr. İlk önce epicontacts nesnesini subset fonksiyonunu kullanarak yalnızca Haziran 2014 başlangıç tarihine sahip vakaları içerecek şekilde filtreleyeceğiz ve thin fonksiyonu kullanarak bu vakalarla bağlantılı kişileri dahil edeceğiz.

```{r transmission_chains_basic_plot_sub,}
## epicontacts nesnesi alt kümesi 
sub <- epic %>%
  subset(
    node_attribute = list(date_onset = c(as.Date(c("2014-06-30", "2014-06-01"))))
  ) %>%
 thin("contacts")
```

Daha sonra basit bir etkileşimli grafiği aşağıdaki gibi kolay şekilde oluşturabiliriz:

```{r transmission_chains_basic_plot,}
## epicontacts nesne grafiği
plot(
  sub,
  width = 700,
  height = 700
)
```

Bu grafiği daha da değiştirmek için çok sayıda değişken bulunur. Esas olanları burada ele alacağız, ancak fonksiyonun tam bir açıklamasını elde etmek için ?vis_epicontacts (bir epicontacts nesnesi üzerinde çizim kullanılırken çağrılan fonksiyon) aracılığıyla belgelere bakın.
	 
####Nod özelliklerinin görselleştirilmesi {.unnumbered}

Nod rengi, şekli ve boyutu, node_color, node_shape ve node_size bağımsız değişkenleri kullanılarak satır listesindeki belirli bir sütuna eşlenebilir. Bu, ggplot2'den tanıyabileceğiniz aes sözdizimine benzer.

Nodların belirli renkleri, şekilleri ve boyutları aşağıdaki gibi belirlenebilir:
• Col_pal değişkeni aracılığıyla, aşağıda yapıldığı gibi her rengin manuel olarak belirtilmesi için bir ad listesi yazarak ya da colorRampPalette(c("siyah", "kırmızı", "turuncu") gibi bir renk paleti fonksiyonu ile sağlayarak), belirtilenler arasında bir renk gradyanı oluşturulabilir.
• Shapes (Şekiller) adlandırılmış bir liste ileterek, node_shape  tarafından belirtilen satır listesi sütunundaki her benzersiz öğe için bir şekil belirtilebilir. Kullanılabilir şekiller için codeawesome'a bakın.
• Size_range nodların boyut aralığını ileterek boyutlandırma.
Rengin sonucu, cinsiyetin şekli ve yaşın ise boyutu temsil ettiği bir örnek:



```{r transmission_chains_node_attribute,}
plot(
  sub, 
  node_color = "outcome",
  node_shape = "gender",
  node_size = 'age',
  col_pal = c(Death = "firebrick", Recover = "green"),
  shapes = c(f = "female", m = "male"),
  size_range = c(40, 60),
  height = 700,
  width = 700
)
```

#### Kenar özelliklerinin görselleştirilmesi  {.unnumbered}

Kenar rengi, genişliği ve çizgi tipi, edge_color, edge_width ve edge_linetype değişkenleri kullanılarak temasların veri çerçevesindeki belirli bir sütuna eşlenebilir. Kenarların belirli renkleri ve genişlikleri aşağıdaki gibi belirtilebilir:

• Col_pal için kullanılanla aynı şekilde edge_col_pal aracılığıyla renkler.
• Genişlik_aralığı argümanına nodların boyut aralığını ileterek genişlik belirlenir 

İşte bir örnek: 


```{r transmission_chains_edge_attribute,}

plot(
  sub, 
  node_color = "outcome",
  node_shape = "gender",
  node_size = 'age',
  col_pal = c(Death = "firebrick", Recover = "green"),
  shapes = c(f = "female", m = "male"),
  size_range = c(40, 60),
  edge_color = 'location',
  edge_linetype = 'location',
  edge_width = 'duration',
  edge_col_pal = c(Community = "orange", Nosocomial = "purple"),
  width_range = c(1, 3),
  height = 700,
  width = 700
)

```

### Temporal eksen {.unnumbered}

x_axis değişkeni satır listesindeki bir sütuna eşleyerek ağı zamansal bir eksen boyunca görselleştirebiliriz. Aşağıdaki örnekte, x ekseni, semptom başlangıç tarihini temsil eder. Ayrıca okların çok büyük olmamasını sağlamak için arrow_size (ok boyutu) değişkenini belirledik ve şekli daha az karmaşık hale getirmek için label değişkenini = YANLIŞ olarak ayarladık.

```{r transmission_chains_x_axis,}
plot(
  sub,
  x_axis = "date_onset",
  node_color = "outcome",
  col_pal = c(Death = "firebrick", Recover = "green"),
  arrow_size = 0.5,
  node_size = 13,
  label = FALSE,
  height = 700,
  width = 700
)
```

Bu ağın zamansal bir eksen boyunca nasıl görselleştirildiğini daha ayrıntılı olarak göstermek için çok sayıda ek argüman vardır; bunları ?vis_temporal_interactive (bir epicontacts nesnesi üzerinde çizimi x_axis üzerinden belirtilen şekilde göstermek çağrılan fonkisyon) aracılığıyla inceleyebilirsiniz. Aşağıda bazılarını gözden geçireceğiz.

#### İletim ağacı şeklinin belirlenmesi {.unnumbered}

Network_shape değişkeni kullanılarak belirtilen, iletim ağacının alabileceği iki ana şekil vardır. Birincisi, düz bir kenarın herhangi iki düğümü birleştirdiği, yukarıda gösterildiği gibi bir dallanma şeklidir. Bu en iyi anlaşılan temsildir, ancak yoğun bir şekilde bağlantılar içeren bir ağda üst üste binen kenarlara neden olabilir. İkinci şekil, bir filogenik ağaca benzeyen bir ağaç oluşturan dikdörtgendir. Örneğin:

```{r transmission_chains_rectangle,}
plot(
  sub,
  x_axis = "date_onset",
  network_shape = "rectangle",
  node_color = "outcome",
  col_pal = c(Death = "firebrick", Recover = "green"),
  arrow_size = 0.5,
  node_size = 13,
  label = FALSE,
  height = 700,
  width = 700
)
```

Her durum nodunda, position_dodge değişkeni değiştirilerek benzersiz bir dikey konum atanabilir. Bağlantısız vakaların konumu (yani, bildirilen herhangi bir kişi olmadan), unlinked_pos değişkeni kullanılarak belirtilir. 

```{r transmission_chains_dodge,}
plot(
  sub,
  x_axis = "date_onset",
  network_shape = "rectangle",
  node_color = "outcome",
  col_pal = c(Death = "firebrick", Recover = "green"),
  position_dodge = TRUE,
  unlinked_pos = "bottom",
  arrow_size = 0.5,
  node_size = 13,
  label = FALSE,
  height = 700,
  width = 700
)
```

Üst nodun alt nodlara göre konumu, 'parent_pos' değişkeni kullanılarak belirlenebilir. Varsayılan seçenek, üst nodu ortaya yerleştirmektir, ancak altta (parent_pos = 'alt') veya üstte (parent_pos = 'üst') yerleştirilebilir. 


```{r transmission_chains_parent_pos,}
plot(
  sub,
  x_axis = "date_onset",
  network_shape = "rectangle",
  node_color = "outcome",
  col_pal = c(Death = "firebrick", Recover = "green"),
  parent_pos = "top",
  arrow_size = 0.5,
  node_size = 13,
  label = FALSE,
  height = 700,
  width = 700
)
```

#### Şekil ve grafiklerin kaydedilmesi  {.unnumbered}

**VisNetwork** paketindeki 'visSave' fonksiyonuyla bir grafiği etkileşimli, bağımsız bir html dosyası olarak kaydedebilirsiniz:

```{r transmission_chains_save, eval=F}

plot(
  sub,
  x_axis = "date_onset",
  network_shape = "rectangle",
  node_color = "outcome",
  col_pal = c(Death = "firebrick", Recover = "green"),
  parent_pos = "top",
  arrow_size = 0.5,
  node_size = 13,
""  label = FALSE,
  height = 700,
  width = 700
) %>%
  visNetwork::visSave("network.html")

```

Bu ağ çıktılarını bir görüntü olarak kaydetmek ne yazık ki zordur ve dosyayı bir html olarak kaydetmenizi ve ardından 'webshot' paketini kullanarak bu dosyanın ekran görüntüsünü almanızı gerektirir. Aşağıdaki kodda, yukarıda kaydedilen html dosyasını PNG'ye dönüştürüyoruz:

```{r transmission_chains_webshot, eval=F}
webshot(url = "network.html", file = "network.png")
```

### Zaman Çizelgeleri {.unnumbered}

Ayrıca, her bir vakanın x ekseninde temsil edildiği zaman çizelgeleri de verebilirsiniz. Zaman çizergeleri, vaka konumlarını veya sonuca ulaşma zamanını görselleştirmek için kullanılabilir. Bir zaman çizelgesi oluşturmak için, vaka kimliğini, "olay"ın başlangıç tarihini ve "olay"ın bitiş tarihini gösteren en az üç sütundan oluşan bir veri çerçevesi oluşturmamız gerekiyor. Ayrıca, zaman çizelgesinin nod ve kenar özelliklerine eşlenebilecek başka bir sütun da ekleyebilirsiniz. Aşağıdaki kodda, semptom başlangıcından sonuç tarihine kadar bir zaman çizelgesi oluşturuyoruz ve nod şeklini ve rengini tanımlamak için kullandığımız sonuç ve hastane değişkenlerini veri tabanımızda tutuyoruz. Örneğin, bir vaka birden fazla hastane arasında sevk ediliyorsa, vaka başına birden fazla zaman çizelgesi satırına/olayına sahip olabileceğinizi unutmayın.

```{r transmission_chains_create_timeline,}

## zaman çizelgesini oluştur
timeline <- linelist %>%
  transmute(
    id = case_id,
    start = date_onset,
    end = date_outcome,
    outcome = outcome,
    hospital = hospital
  )

```

Daha sonra zaman çizelgesi öğesini 'timeline' değişkenine iletiriz. Zaman çizelgesi özniteliklerini zaman çizelgesi nod renklerine, şekillerine ve boyutlarına önceki bölümlerde tanımlandığı şekilde eşleyebiliriz, ancak iki nodumuz vardır: Bir zaman çizelgesinin ayrı ayrı değişkenleri olan başlangıç ve bitiş nodları. Örneğin, 'tl_start_node_color', hangi zaman çizelgesi sütununun başlangıç nodunun rengiyle eşlendiğini tanımlarken 'tl_end_node_shape', hangi zaman çizelgesi sütununun bitiş nodunun şekliyle eşlendiğini tanımlar. Ayrıca 'tl_edge_*' değişkenleri aracılığıyla renk, genişlik, çizgi tipi ve etiketleri zaman çizelgesi kenarına eşleyebiliriz.

Değişkenlerle ilgili ayrıntılı belgeler için '?vis_temporal_interactive' e (bir epicontacts nesnesi çizilirken çağrılan fonksiyon) bakın. Her değişken aşağıdaki kodda da açıklanmıştır:


```{r transmission_chains_vis_timeline,}

## şekilleri tanımla
shapes <- c(
  f = "female",
  m = "male",
  Death = "user-times",
  Recover = "heartbeat",
  "NA" = "question-circle"
)

## renkleri tanımla
colours <- c(
  Death = "firebrick",
  Recover = "green",
  "NA" = "grey"
)

## grafiği oluştur
plot(
  sub,
  ## başlangıç tarihi için maksimum x koordinatı 
  x_axis = "date_onset",
  ## dikdörtgen ağ şeklini kullan 
  network_shape = "rectangle",
  ## nod şekillerini cinsiyet sütununa göre şekillendir 
  node_shape = "gender",
  ## nod rengini herhangi bir sütun ile eşleştirmiyoruz çünkü varsayılan değeri id sütunudur bu da renk şemamızı bozar
  node_color = NULL,
  ## nod büyüklüğünü 30’a ayarla (nod büyüklüğü herhangi bir karakter değildir, herhangi bir sütuna eşleştirilmez, doğrudan nod büyüklüğü belirtilir
  node_size = 30,
  ## iletim bağlantısı kalınlığını 4’e ayarla (bu kalınlık bir karakter ile eşleşmemiştir) 
  edge_width = 4,
  ## zaman çizelgesi nesnesi sağla 
  timeline = timeline,
  ## bitiş nodunun şeklini zaman çizelgesi nesnesindeki sonuç sütununa eşle
  tl_end_node_shape = "outcome",
  ## son nodun boyutunu 15'e ayarla (bir karakter olmadığından, bu argüman bir sütuna eşlenmez, bunun yerine gerçek nod boyutu olarak yorumlanır)
  tl_end_node_size = 15,
  ## zaman çizelgesi kenarının rengini hastane sütununa eşle
  tl_edge_color = "hospital",
  ## zaman çizelgesi kenarının genişliğini 2'ye ayarla (bu bir karakter olmadığından, bu değişken bir sütuna eşlenmez, bunun yerine gerçek kenar genişliği olarak yorumlanır)
  tl_edge_width = 2,
  ## kenar etiketlerini hastane değişkenine eşleyin
  tl_edge_label = "hospital",
  ## nod şeklini belirt (yukarıda tanımlanmıştır)
  shapes = shapes,
  ## renk paletini belirt (yukarıda tanımlanmıştır)
  col_pal = colours,
  ## ok büyüklüğünü 0.5’e ayarla 
  arrow_size = 0.5,
  ## lejantta iki sütun olsun 
  legend_ncol = 2,
  ## font büyüklüğünü ayarla 
  font_size = 15,
  ## tarih formatı ayarla 
  date_labels = c("%d %b %Y"),
  ## nodların altında ID etiketini grafik olarak gösterme
  label = FALSE,
  ## yüksekliği belirt 
  height = 1000,
  ## genişliği belirt
  width = 1200,
  ## her vaka nodunun benzersiz bir y koordinatına sahip olduğundan emin olun - zaman çizelgelerini kullanırken bu çok önemlidir, aksi takdirde farklı vakalarda çakışan zaman çizelgeleriniz olur 
  position_dodge = TRUE
)

```

<!-- ======================================================= -->
## Analiz {  }

### Özetleme {.unnumbered}

'summary' fonkisyonunu kullanarak bazı ağ özelliklerine genel bir bakış elde edebiliriz.

```{r transmission_chains_summarise_epicontacts,}
## epicontacts nesnesini özetle 
summary(epic)
```

Örneğin, temaslıların yalnızca %57'sinin satır listesinde her iki vakaya da sahip olduğunu görebiliriz. Bu iletim zincirlerine dahil olan önemli sayıda vaka hakkında linelist veriye sahip olmadığımız anlamına gelir. 

### Çift Özellikleri {.unnumbered}

'get_pairwise()' fonkisyonu, temaslı veri kümesindeki her bir çifte göre satır listesindeki değişken(ler)in işlenmesine izin verir. Aşağıdaki örnekte, her bir çift için hastalık başlangıç tarihi arasındaki farkı hesaplamak için, hastalık başlangıç tarihi satır listesinden çıkarılır. Bu karşılaştırmadan üretilen değer, seri aralığını (serial interval-si) temsil eder.

```{r transmission_chains_pairwise,}
si <- get_pairwise(epic, "date_onset")   
summary(si)
tibble(si = si) %>%
  ggplot(aes(si)) +
  geom_histogram() +
  labs(
    x = "Serial interval",
    y = "Frequency"
  )
```

'get_pairwise()', karşılaştırma için kullanılan sütunun sınıfını yorumlayacak ve buna göre değerleri karşılaştırma yöntemini ayarlayacaktır. Sayılar ve tarihler için (yukarıdaki *si* örneğinde olduğu gibi) fonksiyon, değerleri çıkaracaktır. Karakter içeren veya kategorik sütunlara uygulandığında, get_pairwise() fonksiyonu değerleri birbirine yapıştırır. Fonksiyon aynı zamanda keyfi işlemeye de izin verdiğinden (bkz. “f” değişkeni), bu ayrık kombinasyonlar kolayca tablo haline getirilebilir ve analiz edilebilir.
    
```{r transmission_chains_pairwise_2,}
head(get_pairwise(epic, "gender"), n = 10)
get_pairwise(epic, "gender", f = table)
fisher.test(get_pairwise(epic, "gender", f = table))
```

Burada, iletim bağlantıları ve cinsiyet arasında önemli bir ilişki görüyoruz. 

### Kümelerin tanımlanması  {.unnumbered}

get_clusters() fonksiyonu, bir epicontacts nesnesindeki bağlı bileşenleri tanımlamak için kullanılabilir. İlk olarak, küme bilgisini içeren bir veri çerçevesi elde etmek için kullanırız:

```{r transmission_chains_cluster,}
clust <- get_clusters(epic, output = "data.frame")
table(clust$cluster_size)
ggplot(clust, aes(cluster_size)) +
  geom_bar() +
  labs(
    x = "Cluster size",
    y = "Frequency"
  )
```

En büyük kümelere bakalım. Bunun için epicontacts nesnesine küme bilgisi ekliyoruz ve ardından yalnızca en büyük kümeleri içerecek şekilde alt kümelerini oluşturuyoruz:

```{r transmission_chains_cluster_2,}
epic <- get_clusters(epic)
max_size <- max(epic$linelist$cluster_size)
plot(subset(epic, cs = max_size))
```

### Derecelerin hesaplanması  {.unnumbered}

Bir nodun derecesi, kenar sayısına veya diğer nodlarla olan bağlantılarına karşılık gelir. 'get_degree()', epicontacts ağları için bu değeri hesaplamakta kolay bir yöntem sağlar. Bu bağlamda yüksek bir derece, başkalarıyla temas halinde olan bir kişiyi gösterir. 'type' değişkeni hem dereceyi hem de dereceyi saymak istediğimizi belirtir, 'only_linelist' değişkeni sadece satır listesindeki vakalar için dereceyi hesaplamak istediğimizi belirtir.

```{r transmission_chains_degree,}
deg_both <- get_degree(epic, type = "both", only_linelist = TRUE)
```

Hangi kişiler en fazla on temasa sahip?

```{r}
head(sort(deg_both, decreasing = TRUE), 10)
```

Ortalama temaslı sayısı nedir?

```{r}
mean(deg_both)
```

<!-- ======================================================= -->
## Kaynaklar {  }

[epicontacts page](https://www.repidemicsconsortium.org/epicontacts/index.html)
Epicontacts sayfası, paket fonksiyonlarına genel bir bakış sağlar ve bazı daha ayrıntılı gösterimler içerir.

[github page](http://github.com/reconhub/epicontacts) 
Github sayfası, sorunları dile getirmek ve yeni özellikler talep etmek için kullanılabilir.
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/transmission_chains.Rmd-->


# Filogenetik ağaçlar {}  


<!-- ======================================================= -->

## Genel Bakış {}


Filogenetik ağaçlar, organizmaların genetik kodlarının sekansına göre akrabalıklarını ve evrimlerini görselleştirmek ve tanımlamak için kullanılır.
Uzaklığa dayalı yöntemler (komşu birleştirme yöntemi gibi) veya karakter tabanlı yöntemler (maksimum olabilirlik ve Bayesian Markov Zinciri Monte Carlo yöntemi gibi) kullanılarak genetik sekanslardan oluşturulabilirler. Yeni nesil sekanslama (NGS) daha uygun fiyatlı hale gelerek bulaşıcı hastalıklara neden olan patojenleri tanımlamak için halk sağlığında daha yaygın olarak kullanılmaya başlandı. Taşınabilir sekanslama cihazları, bekleme süresini azaltır ve verileri gerçek zamanlı olarak salgın araştırmasını desteklemek için kullanılabilir hale getirir. NGS verileri, bir salgın suşunun kökenini, kaynağını ve yayılımını belirlemek ve ayrıca antimikrobiyal direnç genlerinin varlığını göstermek için kullanılabilir. Örnekler arasındaki genetik ilişkiyi görselleştirmek için bir filogenetik ağaç oluşturulur.
Bu sayfada, filogenetik ağaçların bir veri çerçevesiyle birleştirilmiş halde görselleştirilmesine izin veren **ggtree** paketinin nasıl kullanılacağını öğreneceğiz. Bu, motifleri gözlemlememizi ve salgın dinamiğinin anlaşılmasını geliştirmemizi sağlayacaktır.


```{r, phylogenetic_trees_overview_graph, out.width=c('80%'), fig.align='center', fig.show='hold', echo = FALSE}

pacman::p_load(here, ggplot2, dplyr, ape, ggtree, treeio, ggnewscale)

tree <- ape::read.tree(here::here("data", "phylo", "Shigella_tree.txt"))

sample_data <- read.csv(here::here("data","phylo", "sample_data_Shigella_tree.csv"),sep=",", na.strings=c("NA"), head = TRUE, stringsAsFactors=F)


ggtree(tree, layout="circular", branch.length='none') %<+% sample_data + # %<+%, örnek verilerle veri çerçevenizi ağaca eklemek için kullanılır
  aes(color=I(Belgium))+ # dalları veri çerçevenizdeki bir değişkene göre renklendirin
  scale_color_manual(name = "Sample Origin", # renk düzeninizin adı (lejantta bu şekilde görünecektir)
                    breaks = c("Yes", "No"), # değişkeninizdeki farklı seçenekler
                   labels = c("NRCSS Belgium", "Other"), # lejandınızda adı geçen farklı seçenekler nasıl istediğinizi biçimlendirmenize olanak sağlar
                 values= c("blue", "black"), # değişkene atamak istediğiniz renk
                 na.value = "black") + # renkli NA değerleri de siyahtır
  new_scale_color()+ # başka bir değişken için ek bir renk şeması eklemeye izin verir
     geom_tippoint(aes(color=Continent), size=1.5)+ # uç noktasını kıtaya göre renklendirin, "shape =" ekleyerek şekli değiştirebilirsiniz
scale_color_brewer(name = "Continent",  # renk düzeninizin adı (lejantta bu şekilde görünecektir)
                       palette="Set1", # renk paketiyle birlikte gelen bir dizi renk seçiyoruz
                   na.value="grey")+ # NA değerleri için gri rengi seçiyoruz
  theme(legend.position= "bottom")

```

<!-- ======================================================= -->

## Hazırlık {}

### Paketlerin yüklenmesi {.unnumbered}  

Bu kod parçası, gerekli paketlerin yüklenmesini göstermektedir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman'ın p_load() fonksiyonunu vurguluyoruz. Ayrıca, temel R'dan library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R’ın temelleri sayfasına bakın.

```{r, phylogenetic_trees_loading_packages}
pacman::p_load(
  rio,             # içe/dışa aktarım 
  here,            # ilişkili dosya yolları
  tidyverse,       # genel veri yönetimi ve görselleştirme
  ape,             # filogenetik dosyaları içe ve dışa aktarmak için
  ggtree,          # filogenetik dosyaları görselleştirmek için
  treeio,          # filogenetik dosyaları görselleştirmek için
  ggnewscale)      # ek renk şema katmanları eklemek için

```

### Verilerin içe aktarımı {.unnumbered}  

Bu sayfadaki veriler, El kitabı ve verilerin indirilmesi sayfasındaki talimatlarla indirilebilir.

Bir filogenetik ağacın saklanabileceği birkaç farklı format vardır (örn. Newick, NEXUS, Phylip). Yaygın olanlardan biri, ağaçların bilgisayar tarafından okunabilir biçimde gösterimi için standart olan Newic dosya biçimidir (.nwk).

Bu, tüm ağacın “((t2:0.04,t1:0.34):0.89,(t5:0.37,(t4:0.03,t3:0.67):0.9):0.59);” gibi bir dize biçiminde ifade edilebileceği anlamına gelir. Bu dize tüm nodları ve uçları ve bunların birbirleriyle olan ilişkilerini (dal uzunluğu) listeler.

Not: Filogenetik ağaç dosyasının kendi içinde sekans verileri içermediğini, yalnızca sekanslar arasındaki genetik mesafelerin bir sonucu olduğunu anlamak önemlidir. Bu nedenle, bir ağaç dosyasından sekanslama verilerini çıkaramıyoruz.

İlk olarak, bir Newick filogenetik ağaç dosyasını .txt formatında içe aktarmak için ape paketinden read.tree() fonksiyonunu kullanırız ve “phylo” sınıfı bir liste nesnesinde saklarız. Gerekirse, ilgili dosya yolunu belirtmek için here paketindeki here() fonksiyonunu kullanın.

Not: Bu durumda newick ağacı, Github'dan daha kolay kullanım ve indirme için bir .txt dosyası olarak kaydedilir. 



```{r, echo=F}
tree <- ape::read.tree(here::here("data", "phylo", "Shigella_tree.txt"))
```


```{r, echo=T, eval=F}
tree <- ape::read.tree("Shigella_tree.txt")
```

Ağaç nesnemizi inceliyoruz ve 299 uç (veya örnek) ve 236 nod içerdiğini görüyoruz.

```{r}
tree
```

İkinci olarak, rio paketindeki import() fonksiyonunu kullanarak cinsiyet, menşe ülke ve antimikrobiyal direnç özellikleri gibi her numune için ek bilgiler içeren bir .csv dosyası olarak saklanan tabloyu içe aktarırız:

```{r, echo=F}
sample_data <- import(here("data", "phylo", "sample_data_Shigella_tree.csv"))
```

```{r, echo=T, eval=F}
sample_data <- import("sample_data_Shigella_tree.csv")
```

Aşağıda verilerin ilk 50 satırı verilmiştir: 

```{r message=FALSE, echo=F}
DT::datatable(head(sample_data,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Temizleme ve inceleme  {.unnumbered}  

Verilerimizi temizler ve inceleriz: Filogenetik ağaca doğru örnek verilerini atamak için, sample_data veri çerçevesindeki Sample_ID sütunundaki değerlerin ağaç dosyasındaki tip.labels değerleriyle eşleşmesi gerekir:

Ağaç dosyasındaki tip.labels formatını, R tabanından head() ile ilk 6 girişe bakarak kontrol ederiz.

```{r, phylogenetic_trees_inspect_sampledata}
head(tree$tip.label) 
```

Ayrıca sample_data veri çerçevemizdeki ilk sütunun Sample_ID olduğundan emin oluruz. Temel R'dan colnames() kullanarak veri çerçevemizin sütun adlarına bakarız.

```{r}
colnames(sample_data)   
```

Biçimlendirmenin tip.label'dekiyle aynı olduğundan emin olmak için veri çerçevesindeki Sample_ID'lere bakarız (örneğin, harflerin tümü büyük harf olması, harfler ve sayılar arasında fazladan alt çizgi olmaması, vb.)

```{r}
head(sample_data$Sample_ID) # we again inspect only the first 6 using head()
```

Ayrıca tüm örneklerin ağaç dosyasında bulunup bulunmadığını, eşleşip eşleşmedikleri bir DOĞRU veya YANLIŞ mantıksal vektörü oluşturarak karşılaştırabiliriz. (Basitleştirmek için burada gösterilmemiştir).

```{r, eval=F}
sample_data$Sample_ID %in% tree$tip.label

tree$tip.label %in% sample_data$Sample_ID
```

Bu vektörleri ağaçta olmayan herhangi bir örnek kimliğini göstermek için kullanabiliriz (hiçbiri yoktur). 

```{r}
sample_data$Sample_ID[!tree$tip.label %in% sample_data$Sample_ID]
```

İnceleme sonucu, veri çerçevesindeki Sample_ID formatının tip.labels'deki örnek isimlerine karşılık geldiğini görebiliriz. Bunların eşleşmesi için aynı sırada sıralanması gerekmez.

Devam etmeye hazırız!






<!-- ======================================================= -->

## Temel ağaç görselleştirmesi   {}


### Farklı ağaç düzenlemeleri {.unnumbered}  

ggtree birçok farklı düzen formatı sunar ve bazıları özel amacınız için diğerlerinden daha uygun olabilir. Aşağıda birkaç gösterim  var. Diğer seçenekler için bu [çevrimiçi kitaba](http://yulab-smu.top/treedata-book/chapter4.html) bakabilirsiniz.

İşte bazı örnek ağaç düzenleri:

```{r, phylogenetic_trees_example_formats, out.width=c('50%'), fig.show='hold'}

ggtree(tree)                                            # basit doğrusal ağaç
ggtree(tree, branch.length = "none")                    # uçların hizalandığı basit doğrusal ağaç 
ggtree(tree, layout="circular")                         # basit dairesel ağaç
ggtree(tree, layout="circular", branch.length = "none") # uçların hizalandığı basit dairesel ağaç 

```

### Örnek veriyi içeren basit ağaç  {.unnumbered}  

%<+% operatörü, sample_data veri çerçevesini ağaç dosyasına bağlamak için kullanılır. Ağacınızın en basit gösterimi, uçlara örnek isimlerin eklenmesi, ayrıca uç noktalarının ve istenirse dalların renklendirilmesidir:

İşte dairesel bir ağaç örneği:
 
```{r, phylogenetic_trees_adding_sampledata, fig.align='center', warning=F, message=F}
ggtree(tree, layout = "circular", branch.length = 'none') %<+% sample_data + #%<+%, ağaca örnek verilerle veri çerçevesi ekler
  aes(color = I(Belgium))+                       # dalları veri çerçevenizdeki bir değişkene göre renklendirin
  scale_color_manual(
    name = "Sample Origin",                      # renk düzeninizin adı (lejantta bu şekilde görünecektir)
    breaks = c("Yes", "No"),                     # değişkeninizdeki farklı seçenekler
    labels = c("NRCSS Belgium", "Other"),        # lejandınızda adı geçen farklı seçenekleri biçimlendirmenize olanak sağlar
    values = c("blue", "black"),                  # değişkene atamak istediğiniz renk
    na.value = "black") +                        # renkli NA değerleri siyahtır
  new_scale_color()+                             # başka bir değişken için ek bir renk şeması eklemeye izin verir
  geom_tippoint(
      mapping = aes(color = Continent),          # kıtaya göre uç rengi. "shape =" ekleyerek şekli değiştirebilirsiniz.
      size = 1.5)+                               # uçtaki noktanın boyutunu tanımlayın
  scale_color_brewer(
    name = "Continent",                    # renk şemanızın adı (lejantta bu şekilde görünecektir)
    palette = "Set1",                      # brewer paketiyle birlikte gelen bir dizi renk seçiyoruz
    na.value = "grey") +                    # NA değerleri için gri rengi seçiyoruz
  geom_tiplab2(                             # dalının ucuna numunenin adını ekler
    color = 'black',                       # (+ ile istediğiniz kadar metin satırı ekleyin, ancak bunları yan yana yerleştirmek için ofset değerini ayarlamanız gerekebilir)
    offset = 1,
    size = 1,
    geom = "text",
    #align = TRUE
    )+    
  ggtitle("Phylogenetic tree of Shigella sonnei")+       # grafiğinizin başlığı
  theme(
    axis.title.x = element_blank(), # x ekseni başlığını kaldırır
    axis.title.y = element_blank(), # y ekseni başlığını kaldırır
    legend.title = element_text(    # açıklama başlığının yazı tipi boyutunu ve biçimini tanımlar
      face = "bold",
      size = 12),   
    legend.text=element_text(       # gösterge metninin yazı tipi boyutunu ve biçimini tanımlar
      face = "bold",
      size = 10),  
    plot.title = element_text(      # grafik başlığının yazı tipi boyutunu ve biçimini tanımlar
      size = 12,
      face = "bold"),  
    legend.position = "bottom",     # lejant yerleşimini tanımlar
    legend.box = "vertical",        # lejant yerleşimini tanımlar
    legend.margin = margin())   
```

Diğer herhangi bir ggplot nesnesinde yaptığınız gibi, ağaç grafiğinizi ggsave() ile dışa aktarabilirsiniz. Bu şekilde yazıldığında, ggsave(), üretilen son grafiği belirttiğiniz dosya yoluna kaydeder. Alt klasörlere vb. kolayca kaydetmek için here() ve ilgili dosya yollarını kullanabileceğinizi unutmayın.

```{r, eval=F}
ggsave("example_tree_circular_1.png", width = 12, height = 14)

```


<!-- ======================================================= -->

## Ağacın Manipülasyonu {}

Bazen çok büyük bir filogenetik ağacınız olabilir ve ağacın sadece bir kısmıyla ilgilenirsiniz. Örneğin, veri kümenizin büyük resimde nereye sığabileceğine dair geniş bir genel bakış elde etmek için tarihsel veya uluslararası örnekler içeren bir ağaç oluşturup daha sonra verilerinize daha yakından bakmak için daha büyük olan ağacın yalnızca o ilgilendiğiniz kısmını incelemek istersiniz.

Filogenetik ağaç dosyası yalnızca sekanslama veri analizinin çıktısı olduğundan, dosyanın kendisindeki nodların ve dalların sırasını değiştiremeyiz. Bunlar, ham NGS verilerinden önceki analizlerde zaten belirlenmiştir. Yine de parçaları yakınlaştırabiliyor, parçaları gizleyebiliyor ve hatta ağacın parçalarını alt kümelere ayırabiliyoruz.

### Yakınlaştırmak {.unnumbered}  

Ağacınızı "kesmek" istemiyorsanız ve sadece bir kısmını daha yakından incelemek istiyorsanız, belirli bir kısmı görüntülemek için yakınlaştırabilirsiniz.

İlk olarak, tüm ağacı doğrusal biçimde çiziyoruz ve ağaçtaki her bir noda sayısal etiketler ekliyoruz.

```{r, phylogenetic_trees_zoom_in, out.width=c('50%'), fig.show='hold', fig.align='center'}

p <- ggtree(tree,) %<+% sample_data +
  geom_tiplab(size = 1.5) +                # ağaç dosyasındaki örnek adıyla tüm dalların uçlarını etiketler
  geom_text2(
    mapping = aes(subset = !isTip,
                  label = node),
    size = 5,
    color = "darkred",
    hjust = 1,
    vjust = 1)                            # ağaçtaki tüm nodları etiketler

p  # çıktı alın

```

Belirli bir dalı yakınlaştırmak için (sağa doğru uzanarak),  ggtree p nesnesinde viewClade() fonkisyonunu kullanın ve daha yakından bakmak için nod numarasını sağlayın:

```{r phylogenetic_trees_zoom_in_452, out.width=c('50%'), fig.show='hold', fig.align='center'}

viewClade(p, node = 452)

```

### Daralan dallar  {.unnumbered} 

Ancak, bu dalı yok saymak isteyebiliriz ve aynı noddaki (nod nr. 452) collapse() fonksiyonunu kullanarak dalı daraltabiliriz. Bu ağaç p_collapsed olarak tanımlanır.

```{r phylogenetic_trees_collapse_452, out.width=c('50%'), fig.show='hold', fig.align='center'}

p_collapsed <- collapse(p, node = 452)
p_collapsed
```

Anlaşılır olması için, p_collapsed’ı yazdırdığımızda, daraltılmış dalın noduna geom_point2() ile mavi elmas şekli ekleriz.

```{r}
p_collapsed + 
geom_point2(aes(subset = (node == 452)),  # we assign a symbol to the collapsed node
            size = 5,                     # define the size of the symbol
            shape = 23,                   # define the shape of the symbol
            fill = "steelblue")           # define the color of the symbol
```

### Ağacın alt kümelere ayrılması  {.unnumbered} 

Daha kalıcı bir değişiklik yapmak ya da çalışma için yeni ve küçültülmüş bir ağaç oluşturmak istiyorsak, ağacın bir kısmının tree_subset() ile alt kümesini alabiliriz. Ardından bu alt kümeyi yeni bir newick ağaç dosyası veya .txt dosyası olarak kaydedebilirsiniz.

İlk olarak, neyin altküme olacağına karar vermek için ağaç nodlarını ve uç etiketlerini inceleriz.


```{r, phylogenetic_trees_subsetting, out.width=c('50%'), fig.show='hold', fig.align='center'}
ggtree(
  tree,
  branch.length = 'none',
  layout = 'circular') %<+% sample_data +               # %<+% operatörünü kullanarak örnek verileri ekliyoruz
  geom_tiplab(size = 1)+                                # ağaç dosyasında örnek adıyla tüm dalların uçlarını etiketliyoruz 
  geom_text2(
    mapping = aes(subset = !isTip, label = node),
    size = 3,
    color = "darkred") +                                # ağaçtaki tüm nodları etiketler
 theme(
   legend.position = "none",                            # lejantı uzaklaştırır
   axis.title.x = element_blank(),
   axis.title.y = element_blank(),
   plot.title = element_text(size = 12, face="bold"))
```

Şimdi, ağacın  528 numaralı nodundan alt küme oluşturmaya karar verdiğimizi varsayalım (sadece bu dalda 528 nodundan sonraki uçlarını tutalım) ve onu yeni bir sub_tree1 nesnesi olarak kaydedelim: 
 

```{r}
sub_tree1 <- tree_subset(
  tree,
  node = 528)                                            # ağacın 528 nodundan alt kümesini oluşturuyoruz
```

1 numaralı alt küme ağacına bir göz atalım:

```{r}
ggtree(sub_tree1) +
  geom_tiplab(size = 3) +
  ggtitle("Subset tree 1")
```

Ayrıca, "geriye" kaç tane nod eklemek istediğinizi belirterek belirli bir örneğe dayalı olarak alt kümeler oluşturabilirsiniz. Ağacın aynı kısmını bir örneğe dayanarak alt kümelendirelim, bu durumda S17BD07692 için 9 nod geriye giderek ve onu yeni bir sub_tree2 nesnesi olarak kaydedelim:

```{r}
sub_tree2 <- tree_subset(
  tree,
  "S17BD07692",
  levels_back = 9) # geri seviye sayısı, örnek ucundan geriye kaç nod gideceğinizi tanımlar.
```

Şimdi alt küme ağacına bir göz atalım:

```{r}
ggtree(sub_tree2) +
  geom_tiplab(size =3)  +
  ggtitle("Subset tree 2")

```

Yeni ağacınızı, ape paketindeki write.tree() fonksiyonunu kullanarak bir Newick formatında veya hatta bir metin dosyası olarak da kaydedebilirsiniz 

```{r, eval=F, phylogenetic_trees_write_tree}
# .nwk formatında kaydetmek için
ape::write.tree(sub_tree2, file='data/phylo/Shigella_subtree_2.nwk')

# .txt formatında kaydetmek için
ape::write.tree(sub_tree2, file='data/phylo/Shigella_subtree_2.txt')

```

### Ağaçtaki nodları döndürmek  {.unnumbered} 


Daha önce de belirtildiği gibi, ağaçtaki uçların veya nodların sırasını değiştiremeyiz, çünkü bu onların genetik akrabalıklarına dayanır ve görsel manipülasyona izin yoktur. Ancak, görselleştirmemizi kolaylaştıracaksa, dalları nodların etrafında döndürebiliriz.

İlk olarak, işlemek istediğimiz nodu seçmek için yeni alt küme ağacımızı (alt küme 2) nod etiketleriyle çizeriz ve bir ggtree çizim nesnesi 'p' olarak saklarız.


```{r, phylogenetic_trees_rotating_1, out.width=c('50%'), fig.show='hold', fig.align='center'}

p <- ggtree(sub_tree2) +  
  geom_tiplab(size = 4) +
  geom_text2(aes(subset=!isTip, label=node), # ağaçtaki tüm nodları etiketler
             size = 5,
             color = "darkred", 
             hjust = 1, 
             vjust = 1) 
p
```

Ardından, ggtree::rotate() veya ggtree::flip() fonksiyonlarını uygulayarak nodları değiştirebiliriz: Not: Hangi nodları manuple ettiğimizi göstermek için, ilgilendiğimiz noddaki örnekleri vurgulamak için önce ggtree'den geom_hilight() fonksiyonunu uygularız. ggtree çizim nesnesini yeni bir nesne olarak (p1) saklayın.

```{r, phylogenetic_trees_rotating_2, out.width=c('50%'), fig.show='hold', fig.align='center'}

p1 <- p + geom_hilight(  # nod 39'u mavi olarak vurgular, "extend =" renk bloğunun uzunluğunu tanımlamamızı sağlar
  node = 39,
  fill = "steelblue",
  extend = 0.0017) +  
geom_hilight(            # 37 numaralı düğümü sarı renkle vurgular
  node = 37,
  fill = "yellow",
  extend = 0.0017) +               
ggtitle("Original tree")


p1 # çıktı alın
```

Şimdi p1 nesnesindeki nod 37'yi döndürebiliriz, böylece nod 38'deki örnekler en üste hareket eder. Döndürülen ağacı yeni bir p2 nesnesi olarak saklıyoruz. 

```{r}
p2 <- ggtree::rotate(p1, 37) + 
      ggtitle("Rotated Node 37")


p2   # çıktı alın
```

Ya da p1 nesnesindeki 36 nolu nodu döndürmek ve 37 nolu nodu yukarı ve 39 nolu nodu aşağıya çevirmek için flip (çevirme= komutunu kullanabiliriz. Ters çevrilmiş ağacı yeni bir p3 nesnesi olarak saklıyoruz.

```{r}

p3 <-  flip(p1, 39, 37) +
      ggtitle("Rotated Node 36")


p3   # çıktı alın
```

### Numune verilerini içeren açıklamalı örnek alt ağaç {.unnumbered} 

2017 ve 2018'de alt ağacımızda 39. nodda meydana gelen klonal genişlemeli vaka kümesini araştırdığımızı varsayalım. Yakın ilişkili diğer suşların kökenini görmek için suş izolasyonunun yanı sıra ülkeye göre seyahat geçmişi ve rengi de ekliyoruz:

```{r, phylogenetic_trees_inspect_subset_example, out.width=c('80%'), fig.show='hold', fig.align='center', warning=F, message=F}

ggtree(sub_tree2) %<+% sample_data +     # sample_data'ya bağlanmak için %<+% operatörünü kullanırız
  geom_tiplab(                          # ağaç dosyasındaki numune adıyla tüm dalların uçlarını etiketler
    size = 2.5,
    offset = 0.001,
    #align = TRUE
    ) + 
  theme_tree2()+
  xlim(0, 0.015)+                       # ağacımızın x ekseni sınırlarını ayarlar
  geom_tippoint(aes(color=Country),     # uç noktasını kıtaya göre renklendir
                size = 1.5)+ 
  scale_color_brewer(
    name = "Country", 
    palette = "Set1", 
    na.value = "grey")+
  geom_tiplab(                          # uçlara bir metin etiketi olarak izolasyon yılı ekleyin
    aes(label = Year),
    color = 'blue',
    offset = 0.0045,
    size = 3,
    linetype = "blank" ,
    geom = "text",
    #align = TRUE
    )+ 
  geom_tiplab(                          # uçlara kırmızı renkte bir metin etiketi olarak seyahat geçmişi ekleyin
    aes(label = Travel_history),
    color = 'red',
    offset = 0.006,
    size = 3,
    linetype = "blank",
    geom = "text",
    #align = TRUE
    )+ 
  ggtitle("Phylogenetic tree of Belgian S. sonnei strains with travel history")+  # grafik başlığı ekle
  xlab("genetic distance (0.001 = 4 nucleotides difference)")+                    # x eksenine bir etiket ekleyin
  theme(
    axis.title.x = element_text(size = 10),
    axis.title.y = element_blank(),
    legend.title = element_text(face = "bold", size = 12),
    legend.text = element_text(face = "bold", size = 10),
    plot.title = element_text(size = 12, face = "bold"))

```

Gözlemimiz, yıllar içinde Belçika'da dolaşan ve en son salgınımıza neden olan Asya'dan kaynaklanan suşa işaret ediyor.


<!-- ======================================================= -->

## Daha karmaşık ağaçlar: Örnek verilerin ısı haritalarını ekleme  {.unnumbered}


ggtree::gheatmap() fonksiyonunu kullanarak bir ısı haritası biçiminde antimikrobiyal direnç genlerinin kategorik olarak varlığı ve antimikrobiyallere karşı ölçülen direnç için sayısal değerler gibi daha karmaşık bilgiler de ekleyebiliriz.

İlk önce ağacımızı çizmemiz gerekiyor (bu doğrusal veya dairesel olabilir) ve ağacı yeni bir ggtree çizim nesnesi p'de saklamamız gerekiyor: Bölüm 3'teki sub_tree'yi kullanacağız.)

```{r, phylogenetic_trees_sampledata_heatmap, out.width=c('60%'), fig.align='center', fig.show='hold'}

p <- ggtree(sub_tree2, branch.length='none', layout='circular') %<+% sample_data +
 geom_tiplab(size =3) + 
 theme(
   legend.position = "none",
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    plot.title = element_text(
      size = 12,
      face = "bold",
      hjust = 0.5,
      vjust = -15))
p

```

İkinci olarak verilerimizi hazırlıyoruz. Farklı değişkenleri yeni renk şemaları ile görselleştirmek için veri çerçevemizi istenen değişkene göre alt gruplara ayırıyoruz. Sample_ID'yi satır adları olarak eklemek önemlidir, aksi takdirde verileri ağaç tip.labels ile eşleştiremez:

Örneğimizde Shigella enfeksiyonlarını tedavi etmek için kullanılan önemli bir birinci basamak antibiyotik olan siprofloksasine direnç kazandırabilecek mutasyonlara ve cinsiyete bakmak istiyoruz.

Cinsiyet için bir veri çerçevesi oluşturuyoruz:


```{r, phylogenetic_trees_sampledata_heatmap_data}
gender <- data.frame("gender" = sample_data[,c("Gender")])
rownames(gender) <- sample_data$Sample_ID
```

Siprofloksasin direncine nede olan gyrA genindeki mutasyonlar için bir veri çerçevesi oluşturuyoruz: 

```{r}
cipR <- data.frame("cipR" = sample_data[,c("gyrA_mutations")])
rownames(cipR) <- sample_data$Sample_ID

```

Siprofloksasin için ölçülen minimum inhibitör konsantrasyonu (MIC) için bir veri çerçevesi oluşturuyoruz:

```{r}
MIC_Cip <- data.frame("mic_cip" = sample_data[,c("MIC_CIP")])
rownames(MIC_Cip) <- sample_data$Sample_ID
```

Filogenetik ağaca cinsiyet için ikili bir ısı haritası ekleyen ve onu yeni bir ggtree grafi nesnesi h1'de saklayan bir ilk grafik oluşturuyoruz:

```{r, phylogenetic_trees_sampledata_heatmap_gender, out.width=c('70%'), fig.show='hold', fig.align='center'}

h1 <-  gheatmap(p, gender,                                 # ağaç grafiğimize cinsiyet veri çerçevesinin ısı haritası katmanını ekliyoruz
                offset = 10,                               # ofset, ısı haritasını sağa kaydırır,
                width = 0.10,                              # genişlik, ısı haritası sütununun genişliğini tanımlar,
                color = NULL,                              # renk, ısı haritası sütunlarının kenarlığını tanımlar
         colnames = FALSE) +                               # ısı haritası için sütun adlarını gizler
  scale_fill_manual(name = "Gender",                       # cinsiyet için renklendirme şemasını ve lejandı tanımlayın
                    values = c("#00d1b1", "purple"),
                    breaks = c("Male", "Female"),
                    labels = c("Male", "Female")) +
   theme(legend.position = "bottom",
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 10),
        legend.box = "vertical", legend.margin = margin())
h1

```

Ardından, gyrA genindeki siprofloksasine direnç sağlayan mutasyonlar hakkında bilgi ekliyoruz:

Not: WGS verilerinde kromozomal nokta mutasyonlarının varlığı, Zankari ve arkadaşları tarafından geliştirilen PointFinder aracı kullanılarak önceden belirlenmiştir. (referanslar bölümündeki referansa bakın)

İlk olarak, mevcut çizim nesnemiz h1'e yeni bir renk şeması atarız ve onu nesne h2'de saklarız. Bu, ısı haritasındaki ikinci değişkenimizin renklerini tanımlamamızı ve değiştirmemizi sağlar.

```{r}
h2 <- h1 + new_scale_fill() 
```

Ardından ikinci ısı haritası katmanını h2'ye ekler ve birleştirilmiş grafikleri yeni bir nesne h3'te saklarız:

```{r, phylogenetic_trees_sampledata_heatmap_cip_genes, out.width=c('80%'), fig.show='hold', fig.align='center'}

h3 <- gheatmap(h2, cipR,         # Siprofloksasine direnç mutasyonlarını tanımlayan ikinci ısı haritası satırını ekler
               offset = 12, 
               width = 0.10, 
               colnames = FALSE) +
  scale_fill_manual(name = "Ciprofloxacin resistance \n conferring mutation",
                    values = c("#fe9698","#ea0c92"),
                    breaks = c( "gyrA D87Y", "gyrA S83L"),
                    labels = c( "gyrA d87y", "gyrA s83l")) +
   theme(legend.position = "bottom",
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 10),
        legend.box = "vertical", legend.margin = margin())+
  guides(fill = guide_legend(nrow = 2,byrow = TRUE))
h3
```

İlk önce mevcut nesne h3'e yeni bir renk ölçeği katmanı ekleyerek ve ardından nihai nesne h5'i üretmek için elde edilen h4 nesnesine her suş için siprofloksasin için minimum inhibitör konsantrasyonu (MIC) verilerini ekleyerek yukarıdaki işlemi tekrarlıyoruz. :

```{r, phylogenetic_trees_sampledata_heatmap_cip_MIC, out.width=c('90%'), fig.show='hold', fig.align='center'}
# İlk önce yeni renklendirme şemasını ekliyoruz:
h4 <- h3 + new_scale_fill()

# sonra ikisini yeni bir grafikte birleştiriyoruz:
h5 <- gheatmap(h4, MIC_Cip,  
               offset = 14, 
               width = 0.10,
                colnames = FALSE)+
  scale_fill_continuous(name = "MIC for Ciprofloxacin",  # burada MIC'in sürekli değişkeni için bir gradyan renk şeması tanımlıyoruz
                      low = "yellow", high = "red",
                      breaks = c(0, 0.50, 1.00),
                      na.value = "white") +
   guides(fill = guide_colourbar(barwidth = 5, barheight = 1))+
   theme(legend.position = "bottom",
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 10),
        legend.box = "vertical", legend.margin = margin())
h5

```

Aynı alıştırmayı doğrusal bir ağaç için de yapabiliriz:

```{r, phylogenetic_trees_sampledata_heatmap_linear_1, out.width=c('80%'), fig.show='hold', fig.align='center'}

p <- ggtree(sub_tree2) %<+% sample_data +
  geom_tiplab(size = 3) + # labels the tips
  theme_tree2()+
  xlab("genetic distance (0.001 = 4 nucleotides difference)")+
  xlim(0, 0.015)+
 theme(legend.position = "none",
      axis.title.y = element_blank(),
      plot.title = element_text(size = 12, 
                                face = "bold",
                                hjust = 0.5,
                                vjust = -15))
p
```

Öncelikle cinsiyeti giriyoruz

```{r, phylogenetic_trees_sampledata_heatmap_linear_2, out.width=c('80%'), fig.show='hold', fig.align='center'}

h1 <-  gheatmap(p, gender, 
                offset = 0.003,
                width = 0.1, 
                color="black", 
         colnames = FALSE)+
  scale_fill_manual(name = "Gender",
                    values = c("#00d1b1", "purple"),
                    breaks = c("Male", "Female"),
                    labels = c("Male", "Female"))+
   theme(legend.position = "bottom",
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 10),
        legend.box = "vertical", legend.margin = margin())
h1
```


Ardından, başka bir renk şeması katmanı ekledikten sonra siprofloksasine direnç mutasyonlarını ekliyoruz:

```{r, phylogenetic_trees_sampledata_heatmap_linear_3, out.width=c('80%'), fig.show='hold', fig.align='center'}

h2 <- h1 + new_scale_fill()
h3 <- gheatmap(h2, cipR,   
               offset = 0.004, 
               width = 0.1,
               color = "black",
                colnames = FALSE)+
  scale_fill_manual(name = "Ciprofloxacin resistance \n conferring mutation",
                    values = c("#fe9698","#ea0c92"),
                    breaks = c( "gyrA D87Y", "gyrA S83L"),
                    labels = c( "gyrA d87y", "gyrA s83l"))+
   theme(legend.position = "bottom",
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 10),
        legend.box = "vertical", legend.margin = margin())+
  guides(fill = guide_legend(nrow = 2,byrow = TRUE))
 h3
```

Ardından laboratuvar tarafından belirlenen minimum engelleyici konsantrasyonu (MIC) ekliyoruz:

```{r, phylogenetic_trees_sampledata_heatmap_linear_4, out.width=c('80%'), fig.show='hold', fig.align='center'}

h4 <- h3 + new_scale_fill()
h5 <- gheatmap(h4, MIC_Cip, 
               offset = 0.005,  
               width = 0.1,
               color = "black", 
                colnames = FALSE)+
  scale_fill_continuous(name = "MIC for Ciprofloxacin",
                      low = "yellow", high = "red",
                      breaks = c(0,0.50,1.00),
                      na.value = "white")+
   guides(fill = guide_colourbar(barwidth = 5, barheight = 1))+
   theme(legend.position = "bottom",
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 8),
        legend.box = "horizontal", legend.margin = margin())+
  guides(shape = guide_legend(override.aes = list(size = 2)))
h5

```


<!-- ======================================================= -->
## Kaynaklar {}

http://hydrodictyon.eeb.uconn.edu/eebedia/index.php/Ggtree# Clade_Colors
https://bioconductor.riken.jp/packages/3.2/bioc/vignettes/ggtree/inst/doc/treeManipulation.html
https://guangchuangyu.github.io/ggtree-book/chapter-ggtree.html
https://bioconductor.riken.jp/packages/3.8/bioc/vignettes/ggtree/inst/doc/treeManipulation.html

Ea Zankari, Rosa Allesøe, Katrine G Joensen, Lina M Cavaco, Ole Lund, Frank M Aarestrup, PointFinder: a novel web tool for WGS-based detection of antimicrobial resistance associated with chromosomal point mutations in bacterial pathogens, Journal of Antimicrobial Chemotherapy, Volume 72, Issue 10, October 2017, Pages 2764–2768, https://doi.org/10.1093/jac/dkx217


```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/phylogenetic_trees.Rmd-->


# Interactive plots { }  

Data visualisation is increasingly required to be interrogable by the audience. Consequently, is is becoming common to create interactive plots. There are several ways to include these but the two most common are **plotly** and **shiny**. 

In this page we will focus on converting an existing `ggplot()` plot into an interactive plot with **plotly**. You can read more about **shiny** in the [Dashboards with Shiny] page. What is worth mentioning is that interactive plots are only useable in HTML format R markdown documents, not PDF or Word documents.

Below is a basic epicurve that has been transformed to be interactive using the integration of **ggplot2** and **plotly** (hover your mouse over the plot, zoom in, or click items in the legend). 

```{r plotly_demo, out.width=c('75%'), out.height=c('500px'), echo=F, warning=F, message=F}
pacman::p_load(plotly, rio, here, ggplot2, dplyr, lubridate)
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

## these buttons are superfluous/distracting
plotly_buttons_remove <- list('zoom2d','pan2d','lasso2d', 'select2d','zoomIn2d',
                              'zoomOut2d','autoScale2d','hoverClosestCartesian',
                              'toggleSpikelines','hoverCompareCartesian')

p <- linelist %>% 
  mutate(outcome = if_else(is.na(outcome), "Unknown", outcome),
         date_earliest = if_else(is.na(date_infection), date_onset, date_infection),
         week_earliest = floor_date(date_earliest, unit = "week",week_start = 1))%>% 
  count(week_earliest, outcome) %>% 
  ggplot()+
  geom_col(aes(week_earliest, n, fill = outcome))+
  xlab("Week of infection/onset") + ylab("Cases per week")+
  theme_minimal()

p %>% 
  ggplotly() %>% 
  partial_bundle() %>% 
  config(displaylogo = FALSE, modeBarButtonsToRemove = plotly_buttons_remove)

```

<!-- ======================================================= -->
## Preparation {  }

### Load packages {.unnumbered}  

This code chunk shows the loading of packages required for the analyses. In this handbook we emphasize `p_load()` from **pacman**, which installs the package if necessary *and* loads it for use. You can also load installed packages with  `library()` from **base** R. See the page on [R basics] for more information on R packages.  


```{r}
pacman::p_load(
  rio,       # import/export
  here,      # filepaths
  lubridate, # working with dates
  plotly,    # interactive plots
  scales,    # quick percents
  tidyverse  # data management and visualization
  ) 
```

### Start with a `ggplot()` {.unnumbered}  

In this page we assume that you are beginning with a `ggplot()` plot that you want to convert to be interactive. We will build several of these plots in this page, using the case `linelist` used in many pages of this handbook.  


### Import data {.unnumbered}

To begin, we import the cleaned linelist of cases from a simulated Ebola epidemic. If you want to follow along, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>click to download the "clean" linelist</a> (as .rds file). Import data with the `import()` function from the **rio** package (it handles many file types like .xlsx, .csv, .rds - see the [Import and export] page for details).  

```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# import case linelist 
linelist <- import("linelist_cleaned.rds")
```

The first 50 rows of the linelist are displayed below.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```






  
<!-- ======================================================= -->
## Plot with `ggplotly()` {  }

The function `ggplotly()` from the **plotly** package makes it easy to convert a `ggplot()` to be interactive. Simply save your `ggplot()` and then pipe it to the `ggplotly()` function.  


Below, we plot a simple line representing the proportion of cases who died in a given week:  

We begin by creating a summary dataset of each epidemiological week, and the percent of cases with a known outcome that died.  

```{r}
weekly_deaths <- linelist %>%
  group_by(epiweek = floor_date(date_onset, "week")) %>%  # create and group data by epiweek column
  summarise(                                              # create new summary data frame:
    n_known_outcome = sum(!is.na(outcome), na.rm=T),      # number of cases per group with known outcome
    n_death  = sum(outcome == "Death", na.rm=T),          # number of cases per group who died
    pct_death = 100*(n_death / n_known_outcome)           # percent of cases with known outcome who died
  )
```
Here is the first 50 rows of the `weekly_deaths` dataset.  

```{r message=FALSE, echo=F}
DT::datatable(head(weekly_deaths, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```
Then we create the plot with **ggplot2**, using `geom_line()`.  

```{r, warning=F, message=F}
deaths_plot <- ggplot(data = weekly_deaths)+            # begin with weekly deaths data
  geom_line(mapping = aes(x = epiweek, y = pct_death))  # make line 

deaths_plot   # print
```


We can make this interactive by simply passing this plot to `ggplotly()`, as below. Hover your mouse over the line to show the x and y values. You can zoom in on the plot, and drag it around. You can also see icons in the upper-right of the plot. In order, they allow you to:  

* Download the current view as a PNG image  
* Zoom in with a select box  
* "Pan", or move across the plot by clicking and dragging the plot  
* Zoom in, zoom out, or return to default zoom  
* Reset axes to defaults  
* Toggle on/off "spike lines" which are dotted lines from the interactive point extending to the x and y axes  
* Adjustments to whether data show when you are not hovering on the line  


```{r}
deaths_plot %>% plotly::ggplotly()
```

Grouped data work with `ggplotly()` as well. Below, a weekly epicurve is made, grouped by outcome. The stacked bars are interactive. Try clicking on the different items in the legend (they will appear/disappear).  


```{r plot_show, eval=F}
# Make epidemic curve with incidence2 pacakge
p <- incidence2::incidence(
  linelist,
  date_index = date_onset,
  interval = "weeks",
  groups = outcome) %>% plot(fill = outcome)
```

```{r, echo=T, eval=F}
# Plot interactively  
p %>% plotly::ggplotly()
```
  
```{r, warning = F, message = F, , out.width=c('95%'), out.height=c('500px'), echo=FALSE}
p %>% 
  ggplotly() %>% 
  partial_bundle() 
```
  
<!-- ======================================================= -->
## Modifications {  }

### File size {.unnumbered}  

When exporting in an R Markdown generated HTML (like this book!) you want to make the plot as small data size as possible (with no negative side effects in most cases). For this, just pipe the interactive plot to `partial_bundle()`, also from **plotly**.  

```{r plot_tidyshow, eval=F}
p <- p %>% 
  plotly::ggplotly() %>%
  plotly::partial_bundle()
```

### Buttons {.unnumbered}  

Some of the buttons on a standard plotly are superfluous and can be distracting, so you can remove them. You can do this simply by piping the output into `config()` from **plotly** and specifying which buttons to remove. In the below example we specify in advance the names of the buttons to remove, and provide them to the argument `modeBarButtonsToRemove = `. We also set `displaylogo = FALSE` to remove the plotly logo.  

```{r plot_tidyshow2, eval=F}
## these buttons are distracting and we want to remove them
plotly_buttons_remove <- list('zoom2d','pan2d','lasso2d', 'select2d','zoomIn2d',
                              'zoomOut2d','autoScale2d','hoverClosestCartesian',
                              'toggleSpikelines','hoverCompareCartesian')

p <- p %>%          # re-define interactive plot without these buttons
  plotly::config(displaylogo = FALSE, modeBarButtonsToRemove = plotly_buttons_remove)
```



<!-- ======================================================= -->
## Heat tiles {  }

You can make almost any `ggplot()` plot interactive, including heat tiles. In the page on [Heat plots] you can read about how to make the below plot, which displays the proportion of days per week that certain facilities reported data to their province.  

Here is the code, although we will not describe it in depth here.  

```{r  message=F, warning=F}
# import data
facility_count_data <- rio::import(here::here("data", "malaria_facility_count_data.rds"))

# aggregate data into Weeks for Spring district
agg_weeks <- facility_count_data %>% 
  filter(District == "Spring",
         data_date < as.Date("2020-08-01")) %>% 
  mutate(week = aweek::date2week(
    data_date,
    start_date = "Monday",
    floor_day = TRUE,
    factor = TRUE)) %>% 
  group_by(location_name, week, .drop = F) %>%
  summarise(
    n_days          = 7,
    n_reports       = n(),
    malaria_tot     = sum(malaria_tot, na.rm = T),
    n_days_reported = length(unique(data_date)),
    p_days_reported = round(100*(n_days_reported / n_days))) %>% 
  ungroup(location_name, week) %>% 
  right_join(tidyr::expand(., week, location_name)) %>% 
  mutate(week = aweek::week2date(week))

# create plot
metrics_plot <- ggplot(agg_weeks,
       aes(x = week,
           y = location_name,
           fill = p_days_reported))+
  geom_tile(colour="white")+
  scale_fill_gradient(low = "orange", high = "darkgreen", na.value = "grey80")+
  scale_x_date(expand = c(0,0),
               date_breaks = "2 weeks",
               date_labels = "%d\n%b")+
  theme_minimal()+ 
  theme(
    legend.title = element_text(size=12, face="bold"),
    legend.text  = element_text(size=10, face="bold"),
    legend.key.height = grid::unit(1,"cm"),
    legend.key.width  = grid::unit(0.6,"cm"),
    axis.text.x = element_text(size=12),
    axis.text.y = element_text(vjust=0.2),
    axis.ticks = element_line(size=0.4),
    axis.title = element_text(size=12, face="bold"),
    plot.title = element_text(hjust=0,size=14,face="bold"),
    plot.caption = element_text(hjust = 0, face = "italic")
    )+
  labs(x = "Week",
       y = "Facility name",
       fill = "Reporting\nperformance (%)",
       title = "Percent of days per week that facility reported data",
       subtitle = "District health facilities, April-May 2019",
       caption = "7-day weeks beginning on Mondays.")

metrics_plot # print
```

Below, we make it interactive and modify it for simple buttons and file size.  

```{r,  out.width=c('95%'), out.height=c('500px')}
metrics_plot %>% 
  plotly::ggplotly() %>% 
  plotly::partial_bundle() %>% 
  plotly::config(displaylogo = FALSE, modeBarButtonsToRemove = plotly_buttons_remove)
```

<!-- ## Maps {.unnumbered}   -->

<!-- You can also make `ggplot()` GIS maps interactive, although it makes a bit more care.  -->

<!-- THIS SECTION IS UNDER CONSTRUCTION  -->

<!-- Although **plotly** works well with `ggplot2::geom_sf` in RStudio, when you try to include its outputs in R Markdown HTML files (like this book), it doesn't work well.   -->

<!-- So instead you can use {**plotly**}'s own mapping tools which can be tricky but are easy when you know how. Read on...   -->

<!-- We're going to use Covid-19 incidence across African countries for this example. The data used can be found on the [World Health Organisation website](https://covid19.who.int/table).   -->

<!-- You'll also need a new type of file, a GeoJSON, which is sort of similar to a shp file for those familiar with GIS. For this book, we used one from [here](https://geojson-maps.ash.ms).   -->

<!-- GeoJSON files are stored in R as complex lists and you'll need to maipulate them a little. -->

<!-- ```{r, echo=T,} -->
<!-- ## You need two new packages: {rjson} and {purrr} -->
<!-- pacman::p_load(plotly, rjson, purrr) -->

<!-- ## This is a simplified version of the WHO data -->
<!-- df <- rio::import(here::here("data", "gis", "covid_incidence.csv")) -->

<!-- ## Load your geojson file -->
<!-- geoJSON <- rjson::fromJSON(file=here::here("data", "gis", "africa_countries.geo.json")) -->

<!-- ## Here are some of the properties for each element of the object -->
<!-- head(geoJSON$features[[1]]$properties) -->

<!-- ``` -->


<!-- This is the tricky part. For {**plotly**} to match your incidence data to GeoJSON, the countries in the geoJSON need an id in a specific place in the list of lists. For this we need to build a basic function: -->
<!-- ```{r} -->
<!-- ## The property column we need to choose here is "sovereignt" as it is the names for each country -->
<!-- give_id <- function(x){ -->

<!--   x$id <- x$properties$sovereignt  ## Take sovereignt from properties and set it as the id -->

<!--   return(x) -->
<!-- } -->

<!-- ## Use {purrr} to apply this function to every element of the features list of the geoJSON object -->
<!-- geoJSON$features <- purrr::map(.x = geoJSON$features, give_id) -->
<!-- ``` -->

<!-- <!-- ======================================================= --> -->
<!-- ### Maps - plot {  } -->

<!-- UNDER CONSTRUCTION -->

<!-- ```{r, echo=FALSE, eval=FALSE, out.width=c('95%'), out.height=c('500px'),warning=F} -->
<!-- plotly::plot_ly() %>%  -->
<!--   plotly::add_trace(                    #The main plot mapping functionn -->
<!--     type="choropleth", -->
<!--     geojson=geoJSON, -->
<!--     locations=df$Name,          #The column with the names (must match id) -->
<!--     z=df$Cumulative_incidence,  #The column with the incidence values -->
<!--     zmin=0, -->
<!--     zmax=57008, -->
<!--     colorscale="Viridis", -->
<!--     marker=list(line=list(width=0)) -->
<!--   ) %>% -->
<!--   colorbar(title = "Cases per million") %>% -->
<!--   layout(title = "Covid-19 cumulative incidence", -->
<!--                  geo = list(scope = 'africa')) %>%  -->
<!--   config(displaylogo = FALSE, modeBarButtonsToRemove = plotly_buttons_remove) -->
<!-- ``` -->

<!-- ======================================================= -->
## Resources {  }

Plotly is not just for R, but also works well with Python (and really any data science language as it's built in JavaScript). You can read more about it on the [plotly website](https://plotly.com/r/)


```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/interactive_plots.Rmd-->

# (PART) Reports and dashboards {.unnumbered}
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/cat_reports_dashboards.Rmd-->


# R Markdown ile Raporlar { }  

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/rmarkdown_overview.png"))
```

R Markdown, raporlar gibi otomatik, tekrarlanabilir ve paylaşılabilir çıktılar oluşturmak için yaygın olarak kullanılan bir araçtır. Word, pdf, html, powerpoint ve diğer formatlarda statik veya etkileşimli çıktılar üretebilir.

Bir R Markdown betiği, R kodunu metnin arasına serpiştirir, böylece betik aslında çıktı belgeniz olur. Anlatım metni (verilerinize göre dinamik olarak değişebilir), tablolar, şekiller, madde işaretleri/sayılar, bibliyografyalar vb. dahil olmak üzere biçimlendirilmiş bir belgenin tamamını oluşturabilirsiniz.
Bu tür belgeler, rutin güncelleme (örneğin, günlük gözetim raporları) ve/veya veri alt kümeleri (örneğin, yargı raporları) üzerinde çalışmak amacıyla üretilebilir.

Bu el kitabındaki diğer sayfalarda bu konu detaylı olarak anlatılmaktadır:
• Rutin raporları organize etme sayfası, otomatik oluşturulan zaman damgalı klasörlerle rapor üretiminizin nasıl otomatik hale getirileceğini gösterir.
• R Markdown içeren Panolar sayfası, bir R Markdown raporunun pano olarak nasıl biçimlendirileceğini açıklar.

Not : R4Epis projesi, MSF proje lokasyonlarında karşılaşılan yaygın salgın ve çalışma senaryoları için şablon olan R Markdown komut dosyaları geliştirmiştir.



<!-- ======================================================= -->
## Hazırlık {  }

**R Markdown arkaplanı**

İlgili bazı kavram ve paketleri açıklamak için:
•	**Markdown**, html ve diğer formatlara dönüştürülebilen, düz metin kullanarak bir belge yazmanıza izin veren bir “dildir”. R'ye özgü değildir. Markdown'da yazılan dosyalar '.md' uzantısına sahiptir.
•	**R Markdown**, R'ye özgü bir markdown varyasyonudur - metin üretmek, R kodunu gömmek ve çıktılarını görüntülemek için markdown kullanarak belge yazmanızı sağlar. R Markdown dosyaları “.Rmd” uzantısına sahiptir.
•	**rmarkdown - paketi**: Bu, R tarafından .Rmd dosyasını istenen çıktıya dönüştürmek için kullanılır. Odak noktası, dosyayı markdown (metin) sözdizimini dönüştürmektir. 
•	**knitr**: Bu R paketi kod parçalarını okur, yürütür ve belgeye geri "örer". Tablolar ve grafikler bu şekilde metnin yanına eklenir.
•	**Pandoc**: Son olarak, pandoc çıktıyı word/pdf/powerpoint vb.'ye dönüştürür. R'den ayrı bir yazılımdır ancak RStudio ile otomatik olarak yüklenir.
• Özetle, arka planda gerçekleşen süreç (tüm bu adımları bilmenize gerek yoktur!), .Rmd dosyasının knitr'yi beslemesini içerir. Bu paket R kodu parçalarını yürütür ve yeni bir .md (markdown) dosyası oluşturur. R kodu ve işlenmiş çıktısı. .md dosyası daha sonra bitmiş ürünü oluşturmak için pandoc tarafından işlenir: bir Microsoft Word belgesi, HTML dosyası, powerpoint belgesi, pdf, vb. oluşturulur



```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/0_rmd.png"))
```

(kaynak: https://rmarkdown.rstudio.com/authoring_quick_tour.html):

**Yükleme**

Bir R Markdown çıktısı oluşturmak için aşağıdakilerin kurulu olması gerekir:

• rmarkdown paketi (knitr ayrıca otomatik olarak kurulacaktır)
• RStudio ile birlikte gelmesi gereken Pandoc. RStudio kullanmıyorsanız, Pandoc'u buradan indirebilirsiniz: http://pandoc.org.
• PDF çıktısı oluşturmak istiyorsanız (biraz daha zor), LaTeX'i kurmanız gerekecek. Daha önce LaTeX yüklememiş olan R Markdown kullanıcıları için TinyTeX'i (https://yihui.name/tinytex/) yüklemenizi öneririz. Aşağıdaki komutları kullanabilirsiniz:

```{r, eval=F}
pacman::p_load(tinytex)     # tinytex paketini yükleyin 
tinytex::install_tinytex()  # TinyTeX yazılımını yüklemek için R komutu 
```

<!-- ======================================================= -->
## Başlangıç {  }

### rmarkdown R paketini yükleme   {.unnumbered}

rmarkdown R paketini kurun. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman'ın p_load() işlevini vurguluyoruz. Ayrıca, temel R'dan library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R temelleri ile ilgili sayfaya bakın.   

```{r, eval=F}
pacman::p_load(rmarkdown)
```

### Yeni bir Rmd dosyası başlatmak {.unnumbered}

RStudio'da, 'Dosya', ardından 'Yeni dosya' ve ardından 'R markdown…' ile başlayan yeni bir R markdown dosyası açın.

```{r out.width = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/1_gettingstarted.png"))
```

R Studio size bazı çıktı seçenekleri sunacaktır. Aşağıdaki örnekte bir html belgesi oluşturmak istediğimiz için “HTML”yi seçiyoruz. Başlık ve yazar isimleri önemli değildir. İstediğiniz çıktı belgesi türü bunlardan biri değilse endişelenmeyin - herhangi birini seçip daha sonra komut dosyasında değiştirebilirsiniz.

```{r out.width = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/1_gettingstartedB.png"))
```

Bu, yeni bir .Rmd betiği açacaktır. 

### Bilinmesi önemli noktalar {.unnumbered}
 
**Çalışma dizini**

Bir markdown dosyasının çalışma dizini, Rmd dosyasının kendisinin kaydedildiği yerdir. Örneğin, R projesi '~/Documents/projectX' içindeyse ve Rmd dosyasının kendisi '~/Documents/projectX/markdownfiles/markdown.Rmd' alt klasöründeyse, markdown içindeki read.csv(“data.csv”) kodu projelerdeki komut dosyalarının normalde otomatik olarak bakacağı kök proje klasöründe değil, ‘markdownfiles’ klasöründe bir csv dosyası arayacaktır.

Başka bir yerde dosyalara başvurmak için ya tam dosya dizinini kullanmanız ya da buradaki paketi kullanmanız gerekecektir. Buradaki paket, çalışma dizinini R projesinin kök klasörü olarak ayarlar. Bu işlem el kitabının R projeleri ve içe ve dışa aktarma sayfalarında ayrıntılı olarak açıklanmıştır. Örneğin, projeX klasöründen “data.csv” adlı bir dosyayı içe aktarmak için kod import(here(“data.csv”) olacaktır).

R Markdown komut dosyalarında 'setwd()' fonksiyonunun kullanımının önerilmediğini unutmayın - yalnızca yazıldığı kod parçası için geçerlidir. 

**Bilgisayarınızda bir sürücü üzerinde çalışmak**

R Markdown, paylaşılan bir ağ sürücüsünde çalışırken pandoc sorunlarıyla karşılaşabileceğinden, klasörünüzün yerel makinenizde olması önerilir, örn. 'Belgelerim' içindeki bir projede. Git kullanıyorsanız (çok tavsiye edilir!), size tanıdık gelecektir. Daha fazla ayrıntı için, ağ sürücülerinde R'deki el kitabı sayfalarına ve [Hatalar ve yardım]'a bakın.  


<!-- ======================================================= -->
## R Markdown bileşenleri {  }

Bir R Markdown belgesi, standart bir R betiği gibi RStudio'da düzenlenebilir. Yeni bir R Markdown komut dosyası başlattığınızda, RStudio, R Markdown komut dosyasının farklı bölümlerini açıklayan bir şablon göstererek destek sağlar.

Aşağıdaki, bir html çıktısı oluşturmayı amaçlayan yeni bir Rmd betiğinin başlatıldığında izlenen bileşenler görülmektedir. (önceki bölüme göre). 
 

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/2_defaultRMD.png"))
```

Gördüğünüz gibi, bir Rmd dosyasının üç temel bileşeni vardır: YAML, Markdown metni ve R kodu parçaları.

Bunlar, belge çıktınızı oluşturacaktır. Aşağıdaki şemaya bakın:


```{r out.width = "100%", out.height="150%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/rmarkdown_translation.png"))
```



### YAML metadatası {.unnumbered}

"YAML meta verileri" veya yalnızca "YAML" olarak anılan bu bileşen, R Markdown belgesinin en üstündedir. Komut dosyasının bu bölümü, Rmd dosyanız için ne tür bir çıktı üretileceğini, biçimlendirme tercihlerini ve belge başlığı, yazar ve tarih gibi diğer meta verileri gösterecektir. Burada belirtilmeyen başka kullanımlar da vardır (Çıktı oluşturma' bölümünde anlatılmaktadır). Girintilerin önemli olduğunu unutmayın; sekmeler kabul edilmez ancak boşluklar kabul edilir.

Bu bölüm yalnızca üç tire (---) içeren bir satırla başlamalı ve yalnızca üç tire içeren bir satırla kapatılmalıdır. YAML parametreleri anahtar:değer (key:value) çiftleri halinde kodlanır. YAML'de iki nokta üst üste işareti (:) yerleşimi önemlidir - anahtar:değer çiftleri iki nokta üst üste işareti ile ayrılır (eşittir işaretleriyle değil!).

YAML, belge için meta verilerle başlamalıdır. Bu birincil YAML parametrelerinin (girintisiz) sırası önemli değildir. Örneğin:


```yaml
title: "My document"
author: "Me"
date: "`r Sys.Date()`"
```
R kodunu YAML değerleri içinde satır içi kod olarak (ters tikler içinde, r önce gelir) veya tırnak işaretleri içinde yazarak kullanabilirsiniz (tarih için yukarıdaki örneğe bakın:).

Yukarıdaki resimde, varsayılan çıktımızın bir html dosyası olacağını seçtiğimiz için, YAML'nin çıktı: html_document olarak kodlandığını görebiliriz. Ancak bunu powerpoint_presentation veya word_document veya hatta pdf_document olarak değiştirebiliriz.

### Metin {.unnumbered}

Metin, başlıklar da dahil olmak üzere belgenizin anlatımıdır. Birçok farklı yazılımda kullanılan “markdown” dilinde yazılmıştır. 

Aşağıda bu metni yazmanın temel yolları bulunmaktadır. RStudio web sitesindeki R Markdown “cheatsheet”te bulunan daha kapsamlı belgelere bakın.
[RStudio website](https://rstudio.com/resources/cheatsheets/).  

#### Yeni Satırlar {.unnumbered}  

Benzersiz bir şekilde R Markdown'da yeni bir satır başlatmak için önceki satırın sonuna *iki boşluk** girin ve ardından Enter/Return  uygulayın  



#### Metin Karakteri {.unnumbered}  

Çıktıda nasıl görüneceğini değiştirmek için normal metninizi bu karakterlerle çevreleyin.

• İtalik yapmak için alt çizgi (_metin_) veya tek bir yıldız (*metin*)
• Kalın metin için çift yıldız (**metin**)
• Metni kod olarak görüntülemek için ters tik (metin)

Yazı tipinin gerçek görünümü, belirli şablonlar kullanılarak ayarlanabilir (YAML meta verilerinde belirtilir; örnek sekmelere bakın). 


#### Renk {.unnumbered}  

R Markdown'da metnin rengini değiştirmek için basit bir mekanizma yoktur. Çıktınız bir HTML dosyasıysa, geçici bir çözüm, işaretleme metnine bir HTML satırı eklemektir. Aşağıdaki HTML kodu, kalın kırmızı renkte bir metin satırı yazdıracaktır. 

```md
<span style="color: red;">**_DANGER:_** This is a warning.</span>  
```

<span style="color: red;">**__TEHLİKE:_** Bu bir uyarıdır.</span>  


#### Başlıklar {.unnumbered}  

Bir R Markdown betiğinin metin bölümündeki hash (#) sembolü, bir başlık oluşturur. Bu, normal bir R betiğinde olduğu gibi, bir hash sembolünün yorum yapma/açıklama ekleme/devre dışı bırakma mekanizması olduğu komut dosyasındaki bir R kodundan farklıdır.

Yeni bir satırın başlangıcında farklı sayıda hash sembolü ile farklı başlık seviyeleri oluşturulur. Bir hash sembolü, bir başlık veya birincil başlıktır. İki hash sembol, ikinci düzey bir başlıktır. Üçüncü ve dördüncü seviye başlıklar, art arda daha fazla hash sembolü ile yapılabilir.


```md
# Birinci düzey başlık / Genel başlık

## İkinci seviye başlık

### Üçüncü seviye başlık 

```


#### Madde İşaretleri ve Numaralandırma {.unnumbered}  

Bir madde işareti listesi oluşturmak için yıldız işaretlerini (*) kullanın. Önceki cümleyi bitirin, iki boşluk bırakın, iki kez Enter/Return yapın ve ardından madde işaretlerinizi başlatın. Yıldız işareti ile madde işareti ile metniniz arasına bir boşluk ekleyin. Her madde işaretinden sonra iki boşluk girin ve ardından Enter/Return yapın. Alt madde işaretleri aynı şekilde çalışır ancak girintilidir. Sayılar aynı şekilde çalışır, ancak yıldız işareti yerine 1), 2) vb. yazın. Aşağıda R Markdown komut dosyası metninizin nasıl görünebileceği açıklanmıştır.


```md
Madde işaretlerim (bu kolondan sonra iki boşluk var):

* Madde 1 (ardından iki boşluk ve Enter/Return)
* Madde 2 (ardından iki boşluk ve Enter/Return)
   * Alt madde işareti 1 (ardından iki boşluk ve Enter/Return)
   * Alt madde 2 (ardından iki boşluk ve Enter/Return)
 
  
```


#### Metne yorum yapılması {.unnumbered}

Tıpkı bir R parçasındaki bir R kodu satırını yorumlamak için “#” kullanabildiğiniz gibi, R İşaretleme metnini “yorumlayabilirsiniz”. Metni seçip ve Ctrl+Shift+c (Mac için Cmd+Shift+c) tuşlarına basın. Metin oklarla çevrelenecek ve yeşil renk alacaktır. Çıktınızda görünmeyecektir.  


```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/rmarkdown_hide_text.png"))
```


### Kod parçaları {.unnumbered}

Komut dosyasının R kodunu çalıştırmaya ayrılmış bölümlerine “parçalar” denir. Bu parçalar, paketleri yükleyebileceğiniz, verileri içe aktarabileceğiniz ve veri yönetimi ve görselleştirmesini gerçekleştirebileceğiniz yerlerdir. Çok sayıda kod parçası olabilir ve bu parçalar R kodunuzu metne serpiştirerek parçalar halinde organize etmenize yardımcı olabilir. Not: Bu "parçalar", belgenin anlatım kısmından farklı bir arka plan rengine sahiptir. 
Her parça, üç ters tik ile başlayan bir satır ve parça için parametreleri içeren küme parantezleri ({ }) ile açılır. Parça üç tane daha geri tik ile sona erer.

 “Ctrl + Alt + i” (veya Mac'te Cmd + Shift + r) klavye kısa yollarını kullanarak veya komut dosyası düzenleyicinizin en üstünde 'yeni bir kod parçası ekle' simgesini tıklayarak yeni bir parça oluşturabilirsiniz.
{ } küme parantezlerinin içeriği hakkında bazı notlar:

• Parça içindeki kodlama dilinin R olduğunu belirtmek için 'r' ile başlarlar.
• r'den sonra isteğe bağlı olarak bir kod parçası “adı” yazabilirsiniz – bu ad gerekli değildir ancak işinizi organize etmenize yardımcı olabilir. Parçalarınızı adlandırırsanız, HER ZAMAN benzersiz adlar kullanmanız gerektiğini unutmayın, aksi takdirde R, oluşturmayı denediğinizde hata verir.

• Kıvrımlı parantezler, etiket=değer olarak yazılan diğer seçenekleri de içerebilir, örneğin:
  • eval = FALSE R kodunu çalıştırmamak için
  • echo = FALSE parçayı R kaynak kodunu çıktı belgesine yazdırmamak için
  • warning =FALSE  R kodu tarafından üretilen uyarıları yazdırmamak için 
  • message = FALSE R kodu tarafından üretilen hiçbir mesajı yazdırmamak için 
  • include = TRU/FALSE, parça çıktılarının (ör. grafikler) belgeye dahil edilip edilmeyeceği
  • out.width = ve out.height = … tarzında oluşturma için out.width = "%75"
  • fig.align = "center" şeklin sayfa boyunca nasıl hizalanacağını ayarlar
  • fig.show='hold' parçanız birden fazla şekil yazdırıyorsa ve bunların yan yana yazdırılmasını istiyorsanız (out.width = c("%33", "%67") ile eşleştirin. Fig.show ='asis',  kendilerini oluşturan kodun altında şekilleri göstermek için, 'hide' gizlemek için veya 'animate'.bir animasyonda birden çok şekli birleştirmek için 
• Bir satırda bir parça başlığı yazılmalıdır
• Noktalardan, alt çizgilerden ve boşluklardan kaçınmaya çalışın. Ayırıcıya ihtiyacınız varsa bunun yerine kısa çizgi (hyphens) ( - ) kullanın.
Buradan knitr özellikleri hakkında daha fazla bilgi edinin.
 
Yukarıdaki seçeneklerden bazıları, parçanın sağ üst köşesindeki ayar düğmeleri yapılandırılabilir. Burada, işlenen belgenin kodu, çıktıları ve uyarıları içermesini istediğiniz parçalarını belirtebilirsiniz. Bu, küme parantezleri içinde yazılı tercihler olarak görünecektir, örn. echo=FALSE 'Yalnızca çıktıyı göster' istediğinizi belirtir.



```{r out.width = "80%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/3_chunk.png"))
```

Ayrıca her parçanın sağ üst tarafında, kodu bir parça içinde veya tüm kodu önceki parçalarda çalıştırmak için yararlı olan iki ok vardır. Ne yaptıklarını görmek için üzerinde gezinin.

Komut dosyasındaki tüm parçalara uygulanacak genel seçenekleri komut dosyasındaki ilk R kodu parçasında ayarlayabilirsiniz. Örneğin, her kod parçası için yalnızca çıktıların gösterilmesi ve kodun kendisinin gösterilmemesi için, bu komutu R kod parçasına dahil edebilirsiniz:


```{r, eval=F}
knitr::opts_chunk$set(echo = FALSE) 
```



#### Metin İçinde R Kodu {.unnumbered}  

Geri tiklere minimum R kodunu da dahil edebilirsiniz. Geri tikler içinde, koda "r" ve bir boşluk ile başlayın, böylece RStudio, kodu R kodu olarak değerlendireceğini bilir. Aşağıdaki örneğe bakın.

Aşağıdaki örnek, birden çok seviyedeki başlıkları ve madde işaretlerini gösterir, geçerli tarihi çıktı olarak kullanmak için (Sys.Date()) için R kodunu kullanır.


```{r out.width = "80%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/2_text.png"))
```

Yukarıdaki örnek basittir (geçerli tarihi gösterir), ancak aynı sintaksı kullanarak daha karmaşık R kodu tarafından üretilen değerleri görüntüleyebilirsiniz (örneğin, bir sütunun min, medyan, maks. değerini hesaplamak gibi). Ayrıca, komut dosyasına daha önce R kodu parçalarında oluşturulmuş R nesnelerini veya değerlerini de entegre edebilirsiniz.

Örnek olarak, aşağıdaki komut dosyası, 18 yaşından küçük vakaların oranını tidyverse işlevlerini kullanarak hesaplar ve 18altı (less18), toplam (total) ve 18altıoran (less18prop) nesnelerini oluşturur. Bu dinamik değer sonraki metne eklenir. Bir word belgesine nasıl çıktı alındığını (örüldüğünü) görüyoruz.


```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/3_chunktext.png"))
```


### Görseller {.unnumbered}  

Görüntüleri R Markdown'ınıza iki yoldan biriyle dahil edebilirsiniz:

```{r, eval=F}
![]("path/to/image.png")  
```

Yukarıdakiler işe yaramazsa, knitr::include_graphics() kullanmayı deneyin.

```{r, eval=F}
knitr::include_graphics("path/to/image.png")
```

(unutmayın, dosya yolunuz buradaki paket kullanılarak yazılabilir)

```{r, eval=F}
knitr::include_graphics(here::here("path", "to", "image.png"))
```


### Tablolar {.unnumbered}  

Kısa çizgi ( - ) ve çubuklar ( | ) kullanarak bir tablo oluşturun. Çubukların önündeki/arasındaki kısa çizgi sayısı, metin yazılmaya başlamadan önceki boş karakter sayısını belirtir.  


```md
Column 1 |Column  2 |Column 3
---------|----------|--------
Cell A   |Cell B    |Cell C
Cell D   |Cell E    |Cell F
```

Yukarıdaki kod aşağıdaki tabloyu oluşturur:

Column 1 |Column  2 |Column 3
---------|----------|--------
Cell A   |Cell B    |Cell C
Cell D   |Cell E    |Cell F


### Sekmeli Bölümler {.unnumbered}  

HTML çıktılarında bölümleri “sekmeler” halinde düzenleyebilirsiniz. Bunun için bir başlıktan sonra gelen küme parantezleri { } içine .tabset'i eklemeniz yeterlidir. Bu başlığın altındaki herhangi bir alt başlık (aynı seviyedeki başka bir başlığa kadar), kullanıcının tıklayabileceği sekmeler olarak görünecektir. Daha fazlasını [buradan](https://bookdown.org/yihui/rmarkdown-cookbook/html-tabs.html) okuyabilirsiniz.  



```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/tabbed_script.png"))
knitr::include_graphics(here::here("images", "markdown/tabbed_view.gif"))

```


Sekmelere kendilerine özgü bir görünüm vermek için .tabset'ten sonra ek olarak '.tabset-pills' seçeneği ekleyebilirsiniz. Sekmeli HTML çıktısını görüntülerken, Ctrl+f arama işlevinin gizli sekmeleri değil, yalnızca "etkin" sekmeleri arayacağını unutmayın. 





<!-- ======================================================= -->
## Dosya yapısı {}

R Markdown'unuzu ve ilişkili R komut dosyalarını yapılandırmanın birkaç yolu vardır. Her birinin avantajları ve dezavantajları vardır:

• Kendine yeten R Markdown - rapor için gereken her şey R Markdown içinde içe aktarılır veya oluşturulur
  • Diğer dosyaları kaynak olarak kullanma - source() komutuyla harici R komut dosyalarını çalıştırabilir ve çıktılarını Rmd'de kullanabilirsiniz.
  • Alt komut dosyaları - source() için alternatif bir mekanizma
• Bir "runfile" kullanın - R Markdown'ı oluşturmadan önce komutları bir R betiğinde çalıştırın



### Kendine yeten Rmd {.unnumbered}  

Nispeten basit bir rapor için, R Markdown komut dosyanızı "kendi kendine yeterli" olacak ve herhangi bir harici komut dosyası içermeyecek şekilde düzenlemeyi seçebilirsiniz.

R markdown’ı çalıştırmak için ihtiyacınız olan her şey, tüm kod parçaları ve paket yüklenmesi dahil olmak üzere, Rmd dosyası içinde gerçekleşir. Bu "kendi kendine yeten" yaklaşım, çok fazla veri işleme yapmanız gerekmediğinde (örneğin, temiz veya yarı temiz bir veri dosyası getirdiğinde) uygundur ve R Markdown'ın oluşturulması çok uzun sürmez.

Bu senaryoda, R Markdown betiğinin bir mantıksal organizasyonu şöyle olabilir:
1. Küresel knitr seçeneklerini ayarlayın
2. Paketleri yükleyin
3. Verileri içe aktarın
4. Veriyi işleyin
5. Çıktılar (tablolar, grafikler, vb.)
6. Varsa çıktıları kaydedin (.csv, .png, vb.) 

#### Diğer dosyaları kaynak olarak kullanma {.unnumbered}

"Kendi kendine yeterli" yaklaşımın bir varyasyonu, R Markdown kod parçalarının diğer R komut dosyalarını "kaynak" olarak kullanmasıdır (çalıştırma-run). Bu yaklaşım R Markdown betiğinizi daha az karmaşık, daha basit ve organize edilmesi daha kolay hale getirebilir. Son çıktıları raporun başında görüntülemek isterseniz de bu yaklaşım yardımcı olabilir. Bu yaklaşımda, son R Markdown betiği, önceden işlenmiş çıktıları bir belgede birleştirir.

Bunu yapmanın yolu, temel R 'source()' fonksiyonuna R komut dosyalarını (dosya yolu ve uzantılı ad) sağlamaktır.


```{r, eval=F}
source("your-script.R", local = knitr::knit_global())
# or sys.source("your-script.R", envir = knitr::knit_global())
```

R Markdown içinde source() kullanılırken, Rmd dosyanızın oluşturulması sırasında harici dosyaların çalışmaya devam edeceğini unutmayın. Bu nedenle, raporu her oluşturduğunuzda komut dosyası çalıştırılır. Bu nedenle, bu source() komutlarının R Markdown içinde olması çalışma sürenizi hızlandırmaz ve hata ayıklamaya büyük ölçüde yardımcı olmaz, çünkü üretilen hata R Markdown üretilirken yazdırılmaya devam eder.  

Bir alternatif, child = knitr seçeneğini kullanmaktır. 

Farklı R ortamlarının farkında olmalısınız. Bir ortamda oluşturulan nesneler, R Markdown tarafından kullanılan ortamda bulunmayabilir. 
 

### Runfile {.unnumbered}  

Bu yaklaşım, R markdown ile beslenen nesneleri önceden işlemek için render() komutlarını içeren R betiğinin kullanılmasını içerir.

Bu yaklaşımla, paketleri yükleyebilir, verileri yükleyebilir ve temizleyebilir ve hatta render()'dan önce ilgilendiğiniz grafikleri oluşturabilirsiniz. Bu adımlar, R komut dosyasında veya kaynaklı diğer komut dosyalarında ortaya çıkabilir. Bu komutlar aynı RStudio oturumunda gerçekleştiği ve nesneler ortama kaydedildiği sürece, nesneler daha sonra Rmd içeriği içinde çağrılabilir. Ardından, R markdown tüm önceden işlenmiş nesnelerle çıktı üretmek için yalnızca son adım için kullanılacaktır. Bu yöntemde bir şeyler ters giderse hata ayıklamak için çok daha kolaydır. 

Bu yaklaşım aşağıdaki nedenlerle yararlıdır:
• Daha bilgilendirici hata mesajları - bu mesajlar R Markdown'dan değil, R betiğinden oluşturulacaktır. R markdown hataları, hangi parçada sorun olduğunu söyleme eğilimindedir, ancak hangi satırda olduğunu söylemez.
• Uygunsa, uzun işleme adımlarını render() komutundan önce çalıştırabilirsiniz (yalnızca bir kez çalışır).

Aşağıdaki örnekte, bir veri nesnesini R ortamında önceden işlediğimiz ve ardından render() kullanarak “create_output.Rmd”yi oluşturduğumuz ayrı bir R betiğine sahibiz.

```{r, eval=F}
data <- import("datafile.csv") %>%       # veriyi yükle ve ortama kaydet 
  select(age, hospital, weight)          # kısıtlı sütunları seç 

rmarkdown::render(input = "create_output.Rmd")   # Rmd dosyası oluştur
```





### Dosya yapısı {.unnumbered}  

İş akışı, oluşturulan belgeler ve şekiller için bir "çıktı" klasörüne ve temizlenmiş veriler için "veri" veya "girişler" klasörlerini içeren genel klasör yapısıyla da ilgilidir. Burada daha fazla ayrıntıya girmiyoruz, ancak Rutin raporların düzenlenmesi sayfasına göz atın. 




## Belgenin oluşturulması

Belgeyi aşağıdaki şekillerde oluşturabilirsiniz:
• RStudio komut dosyası düzenleyicisinin üst kısmındaki “Knit” düğmesine manuel olarak basarak (hızlı ve kolay)
• render() komutunu çalıştırın (R Markdown betiğinin dışında yürütülür) 



### Seçenek 1: "Knit" butonu {.unnumbered}  

Rmd dosyasını açtığınızda, dosyanın üstündeki 'Knit' simgesine/düğmesine basın.

R Studio, ilerlemeyi R konsolunuzun yakınındaki 'R markdown sekmesinde gösterecektir. Belge tamamlandığında otomatik olarak açılır.

Belge, R işaretleme betiğinizle aynı klasöre ve aynı dosya adıyla (uzantı dışında) kaydedilecektir. Bu yaklaşım sürüm kontrolü için ideal değildir (manuel olarak taşınmadıkça her dosya oluşturmada var olan dosyanın üzerine yazılır), çünkü daha sonra dosyayı kendiniz yeniden adlandırmanız gerekebilir (örneğin dosya ismine bir tarih ekleyin).

Bu, rmarkdown'dan render() işlevi için RStudio'nun kısayol düğmesidir. Bu yaklaşım, yalnızca gerekli tüm bileşenlerin bulunduğu veya dosya içinden kaynaklandığı kendi kendine yeten bir R markdown ile uyumludur.


```{r out.width = "90%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/4_progress.png"))
```



### Seçenek 2: `render()` komutu {.unnumbered}

R Markdown çıktınızı üretmenin başka bir yolu da render() işlevini çalıştırmaktır (rmarkdown paketinden). Bu komutu R Markdown betiğinin dışında yürütmelisiniz - yani ya ayrı bir R betiğinde (genellikle "run dosyası" olarak adlandırılır) ya da R Konsolunda bağımsız bir komut olarak.

```{r, eval=F}
rmarkdown::render(input = "my_report.Rmd")
```

"knit" ile olduğu gibi, varsayılan ayarlar Rmd çıktısını aynı dosya adıyla (dosya uzantısı dışında) Rmd komut dosyasıyla aynı klasöre kaydeder. Örneğin “my_report.Rmd” örüldüğünde bir word belgesine örüyorsanız “my_report.docx” dosyasını oluşturacaktır. Ancak render() kullanarak farklı ayarlar kullanma seçeneğiniz vardır. render() aşağıdaki argümanları kabul eder:

• output_format = Bu, dönüştürülecek çıktı biçimidir (ör. "html_document", "pdf_document", "word_document" veya "all"). Bunu, R Markdown betiği içindeki YAML'de de belirtebilirsiniz.
• output_file = Bu, çıktı dosyasının (ve dosya yolunun) adıdır. Bu, aşağıda gösterildiği gibi here() veya str_glue() gibi R işlevleri aracılığıyla oluşturulabilir.
• output_dir = Bu, dosyayı kaydetmek için bir çıktı dizinidir (klasör). Bu, Rmd dosyasının kaydedildiği dizinden başka bir alternatif seçmenize olanak tanır.
• output_options = YAML komut dosyasındakileri geçersiz kılacak bir seçenekler listesi elde edebilirsiniz (ör. )
• output_yaml = YAML özelliklerini içeren bir .yml dosyasının yolağını sağlayabilirsiniz
• params = Aşağıdaki parametrelerle ilgili bölüme bakın
• Tam listeye buradan bakın

Bir örnek olarak, sürüm kontrolünü iyileştirmek için aşağıdaki komut, çıktı dosyasını dosya adı ve geçerli tarihle birlikte bir "çıktılar" alt klasörüne kaydeder. Dosya adını oluşturmak için, stringr paketindeki str_glue() fonkisyonu, statik dizelerle (açıkça yazılır) dinamik R kodunu (kıvrımlı parantezler içinde yazılır) birbirine 'yapıştırmak' için kullanılır. Örneğin 10 Nisan 2021 ise dosya adı “Report_2021-04-10.docx” olacaktır. str_glue() hakkında daha fazla ayrıntı için Karakterler ve dizeler sayfasına bakın.


```{r, eval=F}
rmarkdown::render(
  input = "create_output.Rmd",
  output_file = stringr::str_glue("outputs/Report_{Sys.Date()}.docx")) 
```

Dosya işlenirken, RStudio Konsolu size %100'e kadar işlemeninm ilerlemesini ve işlemenin tamamlandığını belirten son bir mesaj gösterecektir. 



###  Seçenek 3: **reportfactory**  paketi {.unnumbered}  

R reportfactory paketi, raporları rutin olarak çalıştırdığınız senaryolara göre (örneğin günlük, haftalık…) R Markdown raporlarını düzenlemek ve derlemek için alternatif bir yöntem sunar. Birden çok R Markdown dosyasının derlenmesini ve çıktılarının organizasyonunu kolaylaştırır. Özünde, R Markdown raporlarını çalıştırabileceğiniz, çıktılar için otomatik olarak tarih ve zaman damgalı klasörler oluşturabileceğiniz ve "hafif" sürüm kontrolüne sahip olabileceğiniz bir "fabrika" sağlar.

Rutin raporları organize etme sayfasında bu iş akışı hakkında daha fazla bilgi edinebilirsiniz. 



<!-- ======================================================= -->
## Parametreli Raporlar {  }

Belirli bir ayarla (örneğin belirli bir tarih veya yer veya belirli örgü seçenekleriyle) çalıştırılabilmesi için bir raporu dinamik hale getirmek için parametreleştirmeyi kullanabilirsiniz. Aşağıda, temel bilgilere odaklanıyoruz, ancak parametreli raporlar hakkında çevrimiçi olarak daha fazla bilgi bulabilirsiniz.

Ebola vaka listesini örnek olarak kullanarak, her hastane için her gün standart bir gözetim raporu oluşturmak istediğimizi varsayalım. Bunun parametreleri kullanarak nasıl yapılabileceğini gösteriyoruz.

*Önemli: Bitişik bir R komut dosyasında basit R nesneleri kullanarak resmi parametre yapısı (params) olmadan da dinamik raporlar oluşturmak mümkündür. Bu durum, bu bölümün sonunda açıklanmıştır.*




### Parametrelerin ayarlanması {.unnumbered}

R Markdown çıktınız için parametre değerleri belirlemek için birkaç seçeneğiniz vardır.

#### Seçenek 1: YAML içinde parametrelerin ayarlanması  {.unnumbered}

Tanımlamak istediğiniz her parametre için girintili ifadeler içeren bir params: seçeneği eklemek için YAML'yi düzenleyin. Bu örnekte, değerlerini belirttiğimiz tarih ve hastane parametrelerini oluşturuyoruz. Bu değerler, rapor her çalıştırıldığında değişebilir. Çıktıyı üretmek için “Knit” düğmesini kullanırsanız, parametreler bu varsayılan değerlere sahip olacaktır. Benzer şekilde, render() komutunu kullanırsanız, render() komutunda aksi belirtilmedikçe parametreler bu varsayılan değerlere sahip olacaktır. 


```yaml
---
title: Surveillance report
output: html_document
params:
 date: 2021-04-10
 hospital: Central Hospital
---
```

Arka planda, bu parametre değerleri, params adı verilen salt okunur bir listede bulunur. Böylece, ortamınızdaki başka bir R nesnesi/değeri gibi parametre değerlerini R koduna ekleyebilirsiniz. Params$ yazıp ardından parametre adını yazmanız yeterlidir. Örneğin, hastane adını temsil etmek için params$hospital (varsayılan olarak “Merkez Hastane- Central Hospital”).

Parametrelerin doğru veya yanlış değerleri de tutabileceğini ve bu nedenle bunların bir R kod parçası için knitr seçeneklerinize dahil edilebileceğini unutmayın. Örneğin, {r, eval=FALSE} yerine {r, eval=params$run} ayarını yapabilirsiniz, bu durumda kod parçasının çalışıp çalışmaması parametre çalıştırma: değerine bağlıdır.

Tarih olan parametrelerin bir dize olarak girileceğini unutmayın. Bu nedenle, params$date'in R kodunda yorumlanması için muhtemelen Date sınıfına dönüştürmek için as.Date() veya benzer bir fonksiyonla sarılması gerekir.




#### Seçenek 2: Parametrelerin `render()` ile ayarlanması {.unnumbered}  

Yukarıda bahsedildiği gibi, çıktı üretmek için “Ör-Knit” düğmesine basmaya alternatif olarak, ayrı bir komut dosyasından render() fonksiyonunu yürütmektir. Bu durumda, bu fonksiyonda kullanılacak parametreleri render()'ın params = argümanında belirtebilirsiniz.

Burada sağlanan herhangi bir parametre değerinin, YAML içinde yazılan varsayılan değerlerin üzerine yazılacağını unutmayın. Değerleri tırnak içinde yazıyoruz çünkü karakter/string değerleri olarak tanımlanmaları gerekiyor. 

Aşağıdaki komut, “surveillance_report.Rmd” dosyasını işler; dinamik bir çıktı dosyası adı ve klasörü belirtir. Ayrıca params = argümanına iki parametre sağlayan bir list() içerir.


```{r, eval=F}
rmarkdown::render(
  input = "surveillance_report.Rmd",  
  output_file = stringr::str_glue("outputs/Report_{Sys.Date()}.docx"),
  params = list(date = "2021-04-10", hospital  = "Central Hospital"))
```


#### Seçenek 3: Bir Görsel Kullanıcı Arayüzü kullanarak parametreleri ayarlayın {.unnumbered}  

Daha iyi etkileşim için, parametreler için değerleri manuel olarak seçebildiğiniz Grafik Kullanıcı Arayüzü'nü (GUI) da kullanabilirsiniz. Bunu yapmak için 'Ör-Knit' düğmesinin yanındaki açılır menüyü tıklayıp 'Parametrelerle ör- Knit with parameters'i seçebiliriz.

Belgenin YAML'sinde oluşturulan parametreler için değerleri yazmanıza izin veren bir açılır pencere görünecektir.

```{r out.width = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/5_parametersGUI.png"))
```

Aynı sonucu, aşağıda gösterildiği gibi params = "ask" argümanını belirterek bir render() komutuyla da elde edebilirsiniz.

```{r, eval=F}
rmarkdown::render(
  input = "surveillance_report.Rmd",  
  output_file = stringr::str_glue("outputs/Report_{Sys.Date()}.docx"),
  params = “ask”)
```


Ancak bu açılır pencereye değerlerin girilmesi hata ve yazım hatalarına tabidir. Açılır menülerden girilebilecek değerlere kısıtlamalar eklemeyi tercih edebilirsiniz. Bunu, her bir parametre için YAML'ye birkaç belirtim ekleyerek yapabilirsiniz params: entry 

 
* label: söz konusu açılır menünün başlığı 
*	value: varsayılan (başlangıç) değerdir
*	input: açılır menü için select şekilde ayarlayın
*	choices: Açılır menüden uygun değerleri verin


Aşağıda hastane parametresi için bu özellikler yazılmıştır. 

```yaml
---
title: Surveillance report
output: html_document
params:
 date: 2021-04-10
 hospital: 
  label: “Town:”
  value: Central Hospital
  input: select
  choices: [Central Hospital, Military Hospital, Port Hospital, St. Mark's Maternity Hospital (SMMH)]
---
```

Örürken ('parametrelerle ör(Knit)' düğmesi aracılığıyla veya render() yoluyla), açılır pencerede seçim yapabileceğiniz seçenekler bulunur. 

```{r out.width = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/5_parametersGUIB.png"))
```




### Parametreli örnek {.unnumbered} 

Aşağıdaki kod, R Markdown'da sırasıyla params$date ve params$hospital olarak kullanılan tarih ve hastane için parametreler oluşturur.

Ortaya çıkan rapor çıktısında, verilerin belirli bir hastaneye nasıl filtrelendiğini ve grafik başlığının doğru hastane ve tarihi ifade ettiğini görün. Burada “linelist_cleaned.rds” dosyasını kullanıyoruz, ancak satır listesinin parametreli tarihle uyumlu olması için bir tarih damgası olması uygun olacaktır.


```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/6_Rmdexample.png"))
```

Örme işlemi sonrası, varsayılan yazı tipi ve düzen ile son çıktı üretilir.

```{r out.width = "80%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/6_RmdexampleB.png"))
```


### `params` olmadan parametreli hale getirme {.unnumbered}

Ayrı bir komut dosyasından render() ile bir R Markdown dosyası oluşturuyorsanız, params: kullanmadan parametreleştirmenin etkisini yaratabilirsiniz.

Örneğin, render() komutunu içeren R betiğinde, render() komutundan önce hastane ve tarihi iki R nesnesi (değeri) olarak basitçe tanımlayabilirsiniz. R Markdown'da, YAML'de bir params: bölümüne sahip olmanız gerekmez ve params$date yerine tarih nesnesine ve params$hospital yerine hastaneye başvururuz.


```{r, eval=F}
# Bu, R Markdown'dan ayrı bir R betiğidir.

# R nesnelerini tanımlayın
hospital <- "Central Hospital"
date <- "2021-04-10"

# R markdown oluşturun
rmarkdown::render(input = "create_output.Rmd") 
```

Bu yaklaşımı takip etmek, "parametrelerle öremeyeceğiniz", GUI'yi kullanamayacağınız veya parametreler içinde örgü seçeneklerini ekleyemeyeceğiniz anlamına gelir. Bununla birlikte, avantajlı olabilecek daha basit koda izin verir. 

<!-- ======================================================= -->

## Döngülü raporlar  {  }

Her yetki alanı/birim için bir rapor üretmek için girdi parametrelerini değiştirerek bir raporu birden çok kez çalıştırmak isteyebiliriz. Bu, yineleme, döngü ve listeler sayfasında ayrıntılı olarak açıklanan yineleme araçları kullanılarak yapılabilir. Seçenekler, *purrr* paketini veya aşağıda açıklandığı gibi bir for döngüsünün kullanımını içerir.

Aşağıda, ilgili tüm hastaneler için bir gözetim raporu oluşturmak için basit bir for döngüsü kullanıyoruz. Bu, tek bir komutla yapılır (hastane parametresini hastaneler için birer birer manuel olarak değiştirmek yerine). Raporları işleme komutu, Rmd raporunun dışında ayrı bir komut dosyasında bulunmalıdır. Bu komut dosyası aynı zamanda "dönüştürülecek" tanımlanmış nesneleri - bugünün tarihini ve döngünün uygulanacağı hastane adları vektörünü içerecektir.



```{r, eval=F}
hospitals <- c("Central Hospital",
                "Military Hospital", 
                "Port Hospital",
                "St. Mark's Maternity Hospital (SMMH)") 
```

Daha sonra, hastane vektöründeki her değer için komut çalıştıran bir döngü kullanarak bu değerlere render() fonksiyonunu uygularız. i harfi, yinelemede kullanılmakta olan hastanenin dizin konumunu (1 ila 4) temsil eder, öyle ki hospital_list[1]  “Merkez Hastane” olur. Bu bilgi, render() komutunda iki yerde sağlanır:

1. Dosya adında. 10 Nisan 2021'de oluşturulan ilk yinelemenin dosya adı, çalışma dizininin 'çıktı' alt klasörüne kaydedilen “Report_Central Hospital_2021-04-10.docx” olacak şekilde belirlenmiştir.

2. params = argümanına.  Rmd, params$hospital değeri çağrıldığında dahili olarak hastane adını kullanır (veri setini yalnızca belirli bir hastaneye filtrelemek amacıyla). Bu örnekte, her hastane için bir tane olmak üzere dört dosya oluşturulacaktır.


```{r, eval=F}
for(i in 1:length(hospitals)){
  rmarkdown::render(
    input = "surveillance_report.Rmd",
    output_file = str_glue("output/Report_{hospitals[i]}_{Sys.Date()}.docx"),
    params = list(hospital  = hospitals[i]))
}       
```



<!-- In the scenario where you are f not using this strict form of parameterisation but saving objects to the environment, as discussed at the end of the parameterisation section, the render function would look like this: -->

<!-- ```md -->
<!-- for(i in 1:length(hospital_list)){ -->
<!-- rmarkdown::render("surveillance_report.Rmd", -->
<!--                   output_file = paste0("output/Report_", hospital_list[i], refdate, ".docx") -->
<!-- }        -->
<!-- ``` -->
<!-- The text within the markdown would then need to refer to `hospital_list[i]` and `refdate`.  -->






<!-- ======================================================= -->
## Şablonlar  

İstediğiniz biçimlendirmeyi içeren bir şablon belge kullanarak, Rmd çıktısının nasıl görüneceğinin estetiğini ayarlayabilirsiniz. Örneğin, istenen boyutlara, filigranlara (watermark), arka planlara ve yazı tiplerine sahip sayfaları/slaytları içeren bir MS Word veya Powerpoint dosyası oluşturabilirsiniz.

### Word belgeleri {.unnumbered}

Bir şablon oluşturmak için, yeni bir kelime word başlatın (veya size uygun formatta mevcut bir çıktıyı kullanın) ve stilleri tanımlayarak yazı tiplerini düzenleyin. Stillerde, Başlık 1, 2 ve 3 çeşitli markdown başlık seviyelerine atıfta bulunur (sırasıyla # Başlık 1, ## Başlık 2 ve ### Başlık 3). Paragrafın yanı sıra yazı tipi biçimlendirmesini de değiştirmek için stile sağ tıklayın ve 'değiştir'e tıklayın (örneğin, boşluk bırakmaya yardımcı olabilecek belirli stillerden önce sayfa ayrımları ekleyebilirsiniz). Kenar boşlukları, sayfa boyutu, başlıklar vb. gibi Word belgesinin diğer ayarları, üzerinde çalıştığınız normal bir kelime belgesi gibi doğrudan değiştirilebilir.

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/7_template.png"))
```

### Powerpoint belgeleri {.unnumbered}

Yukarıdaki gibi, yeni bir slayt seti oluşturun veya istenen formatta mevcut bir powerpoint dosyasını kullanın. Daha fazla düzenleme için, 'Görünüm' ve 'Asıl Slaytın’ üzerine tıklayın. Buradan, metin kutularındaki metin biçimlendirmesini ve ayrıca genel sayfa için arka plan/sayfa boyutlarını düzenleyerek "ana" slayt görünümünü değiştirebilirsiniz.    

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/8_ppttemplate.png"))
```

Ne yazık ki, powerpoint dosyalarını düzenlemek biraz daha az esnektir:
• Birinci düzey başlık (# Başlık 1) otomatik olarak yeni bir slaydın başlığı olur,
• Bir ## Başlık 2 metni altyazı olarak değil, slaydın ana metin kutusundaki metin olarak görünecektir (Ana görünümü değiştirmenin bir yolunu bulamazsanız).
• Çıktı alınan grafikler ve tablolar otomatik olarak yeni slaytlara geçecektir. Bunları birleştirmeniz gerekecektir, örneğin ggplot'ları birleştirmek için patchwork fonksiyonu, aynı sayfada görünmelerini sağlar. Birden çok görüntüyü tek bir slayta yerleştirmek için patchwork paketini kullanma hakkında [blog post] (https://mattherman.info/blog/ppt-patchwork/) gönderisine bakın.
Powerpoint sunumlarıyla daha derinlemesine çalışacak bir araç için officer paketine [**officer** package](https://davidgohel.github.io/officer/) bakın. 



### Şablonların YAML’e entegrasyonu  {.unnumbered}

Bir şablon hazırlandıktan sonra, ilgili detaylar Rmd'nin YAML'sine 'çıktı' satırının altına ve belge tipinin belirtildiği yerin altına (ayrı bir satır olarak) eklenebilir. Not referans_doc, powerpoint slayt şablonları için kullanılabilir.

Şablonu Rmd dosyasının bulunduğu klasöre (aşağıdaki örnekte olduğu gibi) veya içindeki bir alt klasöre kaydetmek en kolay yoldur.



```yaml
---
title: Surveillance report
output: 
 word_document:
  reference_docx: "template.docx"
params:
 date: 2021-04-10
 hospital: Central Hospital
template:
 
---
```

### HTML dosyalarının formatlanması {.unnumbered}

HTML dosyaları şablon kullanmaz, ancak YAML içinde yapılandırılmış stiller içerebilir. HTML'ler etkileşimli ve esnek belgelerdir. Burada bazı temel seçenekleri ele alıyoruz.

• Table of contents-İçindekiler): Aşağıda toc: true ile bir içindekiler tablosu ekleyebilir ve ayrıca toc_float: true ile siz kaydırdıkça görüntülenebilir formda olmasını ("kayan-floats") belirtebiliriz.

• Themes-Temalar: Bootswatch tema kitaplığından gelen önceden hazırlanmış bazı temalara başvurabiliriz. Aşağıdaki örnekte cerulean kullanıyoruz. Diğer seçenekler şunlardır: ournal, flatly, darkly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex ve yeti.

• Highlight-Vurgula: Bu seçeneği yapılandırmak, vurgulanan metnin görünümünü değiştirir (örneğin, kod parçaları). Desteklenen stiller arasında default, tango, pygments, kate, monochrome, espresso, zenburn, haddock, breezedark ve textmate. bulunur.

Yukarıdaki seçeneklerin YAML'ye nasıl entegre edileceğine dair bir örnek.


```yaml
---
title: "HTML example"
output:
  html_document:
    toc: true
    toc_float: true
    theme: cerulean
    highlight: kate
    
---
```

Aşağıda, her ikisi de kayan formda içindekiler tablolarına sahip, ancak farklı tema ve vurgulama stilleri seçilen iki HTML çıktısı örneği verilmiştir:

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/9_html.png"))
```


## Dinamik içerik  

Bir HTML çıktısında, rapor içeriğiniz dinamik olabilir. Aşağıda bazı örnekler verilmiştir:  

### Tablolar {.unnumbered}  

Bir HTML raporunda, içeriğin dinamik olması için filtreler ve kaydırma çubukları ile veri çerçevesi / tibble yazdırabilirsiniz. Bu özelliği sunan birkaç paket mevcuttur.

Bunu DT paketiyle yapmak için, bu el kitabında kullanıldığı gibi, şöyle bir kod parçası ekleyebilirsiniz:


```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/10_dynamictable.png"))
```

datatable() fonksiyonu, sağlanan veri çerçevesini okuyucu için dinamik bir tablo olarak yazdıracaktır. Tablonun en sol tarafını basitleştirmek için satır adları için rownames = argümanını FALSE-YANLIŞ olarak ayarlayabilirsiniz. filter = "top", her sütun üzerinde bir filtre sağlar. option() fonksiyonunun argümanlar kısmına diğer özelliklerin bir listesini girin. Aşağıda iki tane argüman yer almaktadır: pageLength = 5, görünen satır sayısını 5 olarak ayarlar (kalan satırlar oklar arasında gezinerek görüntülenebilir) ve scrollX=TRUE tablonun altında bir kaydırma çubuğu etkinleştirir (sağa çok fazla uzanan sütunlar için).

Veri setiniz çok büyükse, veri çerçevesini head() içine sararak yalnızca en üstteki X sayıdaki satırları görüntülemeyi düşünün.
  


### HTML araçları {.unnumbered}

[HTML widgets for R](http://www.htmlwidgets.org/) R için HTML widget'ları, JavaScript kitaplıklarını kullanarak artırılmış etkileşim sağlayan özel bir R paketleri sınıfıdır. Bu paketleri HTML R Markdown çıktılarına gömebilirsiniz.

Bu widget'ların bazı yaygın örnekleri şunları içerir:

• Plotly (bu el kitabı sayfasında ve [İnteraktif grafikler] sayfasında kullanılır)
• visNetwork (bu el kitabının İletim Zincirleri sayfasında kullanılır)
• Leaflet (bu el kitabının GIS Temelleri sayfasında kullanılır)
• dygraphs (zaman serisi verilerini etkileşimli olarak göstermek için kullanılır)
• DT (datatable()) (filtre, sıralama vb. ile dinamik tabloları göstermek için kullanılır)

Plotly'den ggplotly() fonksiyonunun kullanımı özellikle kolaydır. Etkileşimli grafikler sayfasına bakın. 



## Kaynaklar {  }

Daha fazla bilgi şuralarda bulunabilir:

* https://bookdown.org/yihui/rmarkdown/
* https://rmarkdown.rstudio.com/articles_intro.html

•	Markdown vs knitr vs R markdown'ın için iyi bir açıklama:  https://stackoverflow.com/questions/40563479/relationship-between-r-markdown-knitr-pandoc-and-bookdown


```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/rmarkdown.Rmd-->


# Rutin raporların düzenlenmesi { }

Bu sayfa, raporlar için R Markdown kullanımına eşlik eden **reportfactory** paketini kapsamaktadır.

Raporları rutin olarak çalıştırdığınız senaryolarda (günlük, haftalık vb.), birden çok R Markdown dosyasının derlenmesini ve çıktılarının organizasyonunu kolaylaştırır. Özünde, R Markdown raporlarını çalıştırabileceğiniz, çıktılar için otomatik olarak tarih ve zaman damgalı klasörler alabileceğiniz ve "hafif" sürüm kontrolüne sahip olabileceğiniz bir "fabrika" sağlar.

**reportfactory**, RECON (R Epidemics Consortium) tarafından geliştirilen paketlerden biridir. İşte onların [web sitesi](https://www.repidemicsconsortium.org/) ve [Github](https://github.com/reconverse).


## Hazırlık

### Paketleri yüklemek {.unnumbered}

RStudio içinden, Github'dan **reportfactory** paketinin en son sürümünü yükleyin.

Bunu, Github'dan en son sürümün yüklenmesini zorlayacak olan `p_load_current_gh()` ile **pacman** paketi aracılığıyla yapabilirsiniz. Github organizasyonunu (reconverse) ve veri havuzunu (rapor fabrikası) belirten "reconverse/reportfactory" karakter dizisini sağlayın. Alternatif olarak **remotes** paketinden `install_github()` da kullanabilirsiniz.

```{r, eval=FALSE}
# Paketin en son sürümünü Github'dan yükleyin ve kurun
pacman::p_load_current_gh("reconverse/reportfactory")
# remotes::install_github("reconverse/reportfactory") # alternatif yöntem
```


## Yeni fabrika

Yeni bir fabrika oluşturmak için `new_factory()` fonksiyonunu çalıştırın. Bu, yeni bir bağımsız R proje klasörü oluşturacaktır. Varsayılan olarak:

* Fabrika çalışma dizininize eklenecektir.
* Fabrika R projesinin adı "new_factory.Rproj" olarak adlandırılacaktır.
* RStudio oturumunuz bu R projesine "taşınacak"tır

```{r, eval=F}
# Bu, fabrikayı çalışma dizininde yaratacaktır.
new_factory()
```

Fabrikanın içine baktığınızda, alt klasörlerin ve bazı dosyaların otomatik olarak oluşturulduğunu görebilirsiniz.

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "factory_new2.png"))
```

* *report_sources* klasörü, raporlarınızı oluşturan R Markdown komut dosyalarınızı tutacaktır.
* *outputs* klasörü, rapor çıktılarını tutmak için(ör. HTML, Word, PDF, vb.)
* *scripts* klasörü, diğer R komut dosyalarını depolamak için kullanılabilir (örneğin, Rmd komut dosyalarınız tarafından sağlananlar)
* *data* klasörü verilerinizi tutmak için kullanılabilir ("ham" ve "temiz" alt klasörler dahildir)
* Bir *.here* dosyası, böylece alt klasörlerdeki dosyaları bu kök klasörle ilişkilerine göre çağırmak için **here** paketini kullanabilirsiniz (ayrıntılar için [R projeleri] sayfasına bakabilirsiniz)
* Bu R projesini bir Github deposuna bağlamanız durumunda bir *gitignore* dosyası oluşturulur (bkz. [Sürüm kontrolü ve Github ile işbirliği])
* Github deposu kullanıyorsanız, boş bir BENİOKU dosyası oluşur.


<span style="color: orange;">**_UYARI:_** bilgisayarınızın ayarına bağlı olarak, ".here" gibi dosyalar var olabilir ancak görünmez olabilir.</span>

Varsayılan ayarlardan, 'new_factory()' komutuyla ayarlamak isteyebileceğiniz birkaç tanesi aşağıdadır:

* `factory = ` - Fabrika klasörü için bir ad girin (varsayılan "new_factory")
* `path = ` - Yeni fabrika için bir dosya yolu belirleyin (varsayılan çalışma dizinidir)
* `report_sources = ` R Markdown komut dosyalarını içeren alt klasör için alternatif bir ad sağlayın (varsayılan "report_sources")
* `outputs = ` Rapor çıktılarını tutan klasör için alternatif bir ad sağlayın (varsayılan "outputs")

Değişkenlerin tam listesi için "?new_factory" konusuna bakabilirsiniz.


Yeni fabrika oluşturduğunuzda, R oturumunuz yeni R projesine aktarılır, bu nedenle **reportfactory** paketini tekrar yüklemelisiniz.

```{r, eval=FALSE}
pacman::p_load(reportfactory)
```

Artık fabrikadaki iç yapıyı (tüm klasörler ve dosyalar) görmek için `factory_overview()` komutunu çalıştırabilirsiniz.

```{r, eval=F}
factory_overview()            # fabrikaya genel bakışı konsola yazdır
```

Fabrika klasörlerinin ve dosyalarının aşağıdaki "ağacı" R konsoluna yazdırılır. "Veri" klasöründe "ham" ve "temiz" veriler ve örnek CSV verileri için alt klasörler bulunduğunu unutmayın. Ayrıca "report_sources" klasöründe "example_report.Rmd" vardır.

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "factory_overview.png"))
```


## Bir rapor oluşturun

Fabrika R projesinin içinden, normalde yaptığınız gibi bir R Markdown raporu oluşturun ve bunu "report_sources" klasörüne kaydedin. Talimatlar için [R Markdown][R Markdown ile Raporlar] sayfasına bakabilirsiniz. Örnek olması açısından, fabrikaya aşağıdakileri ekledik:

* "report_sources" klasörüne kaydedilen "daily_sitrep.Rmd" başlıklı yeni bir R işaretleme komut dosyası
* Rapor ("linelist_cleaned.rds") verileri, "data" klasörü içindeki "clean" alt klasörüne kaydedilir

`factory_overview()` kullanarak "report_sources" klasöründeki R Markdown'ımızı ve "clean" veri klasöründeki (vurgulanan) veri dosyasını görebiliriz:

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "factory_overview2.png"))
```

Aşağıda, R Markdown "daily_sitrep.Rmd" başlangıcının bir ekran görüntüsü bulunmaktadır. YAML başlığı "output: html_document" aracılığıyla çıktı biçiminin HTML olarak ayarlandığını görebilirsiniz. 

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "factory_new_rmd.png"))
```

Bu basit komut dosyasında şu komutlar vardır:

* Gerekli paketleri yükleyin
* **here** paketindeki bir dosya yolunu kullanarak satır listesi verilerini içe aktarın (daha fazlasını [İçe aktarma ve dışa aktarma] sayfasından okuyun)

```{r, eval=F}
linelist <- import(here("data", "clean", "linelist_cleaned.rds"))
```

* Vakaların bir özet tablosunu yazdırın ve bunu bir .csv dosyası olarak `export()` ile dışa aktarın
* Bir salgın eğrisi yazdırın ve `ggsave()` ile .png dosyası olarak dışa aktarın


Bu komutla "report_sources" klasöründeki yalnızca R Markdown raporlarının listesini inceleyebilirsiniz:

```{r, eval=F}
list_reports()
```



## Derlemek (Compile)

Bir rapor fabrikasında, bir R Markdown raporunu "derlemek", .Rmd komut dosyasının çalıştırılacağı ve çıktının üretileceği anlamına gelir (YAML komut dosyasında belirtildiği gibi, örneğin HTML, Word, PDF, vb. olarak).

*Fabrika, "outputs" klasöründeki çıktılar için otomatik olarak tarih ve zaman damgalı bir klasör oluşturacaktır.*

Raporun kendisi ve komut dosyası tarafından üretilen tüm dışa aktarılan dosyalar (örn. csv, png, xlsx) bu klasöre kaydedilecektir. Ek olarak, Rmd betiğinin kendisi bu klasöre kaydedilecektir, böylece betiğin o sürümünün bir kaydı olur.

Bu, çıktıları Rmd komut dosyasının konumuna kaydeden "örülmüş" bir R Markdown'ın normal davranışıyla çelişir. Bu varsayılan davranış, kalabalık, dağınık klasörlere neden olabilir. Fabrika, sık sık rapor çalıştırması gerektiğinde organizasyonu iyileştirmeyi amaçlar.

###  Adına göre derleyin {.unnumbered}

Belirli bir raporu 'compile_reports()' çalıştırarak ve Rmd komut dosyası adını (.Rmd uzantısı olmadan) 'reports = ' olarak sağlayarak derleyebilirsiniz. Basit olması için, `reports =` kısmını atlayabilir ve R Markdown adını aşağıdaki gibi tırnak işaretleri içinde yazabilirsiniz. 

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "factory_compile1.png"))
```


Bu komut, yalnızca "daily_sitrep.Rmd" raporunu derleyerek, HTML raporunu ve .csv tablosunu ve .png epicurve dışa aktarmalarını, "outputs" klasörü içinde, rapora özel tarih ve zaman damgalı bir alt klasöre kaydeder.

.Rmd uzantısını sağlamayı seçerseniz, uzantıyı dosya adına kaydedilirken doğru şekilde yazmanız gerektiğini unutmayın (.rmd ve .Rmd).

Ayrıca, derlerken, "report_sources" klasöründe geçici olarak birkaç dosyanın görünebileceğini unutmayın - ancak doğru "outputs" klasörüne aktarıldıkları için kısa sürede kaybolacaklardır.

###  Numarasına göre derleyin {.unnumbered}

Ayrıca, `reports =` için bir sayı veya sayı vektörü sağlayarak derlenecek Rmd betiğini de belirtebilirsiniz. Rakamlar, `list_reports()` çalıştırdığınızda raporların göründüğü sıraya göre hizalanmalıdır.

```{r, eval=F}
# İkinci ve dördüncü Rmds'yi "report_sources" klasöründe derleyin
compile_reports(reports = c(2, 4))
```



### Tümünü Derleyin {.unnumbered}

"report_sources" klasöründeki *tüm* R Markdown raporlarını, `reports = ` değişkenini TRUE olarak ayarlayarak derleyebilirsiniz.  

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "factory_compile_all.png"))
```


###  Alt klasöründen derleyin {.unnumbered} 

"report_sources" klasörüne alt klasörler ekleyebilirsiniz. Bir alt klasörden R Markdown raporu çalıştırmak için, klasörün adını `subfolder = ` olarak sağlamanız yeterlidir. Aşağıda, "report_sources" alt_klasöründe yaşayan bir Rmd raporunu derlemek için bir kod örneği verilmiştir.

```{r, eval=F}
compile_reports(
     reports = "summary_for_partners.Rmd",
     subfolder = "for_partners")
```

Aşağıdaki gibi sonunda bir eğik çizgi ile `reports = ` alt klasör adını sağlayarak bir alt klasör içindeki tüm Rmd raporlarını derleyebilirsiniz.

```{r, eval=F}
compile_reports(reports = "for_partners/")
```


### Parametrelendirme {.unnumbered}

[R Markdown ile Raporlar] sayfasında belirtildiği gibi, belirtilen parametrelerle raporlar çalıştırabilirsiniz. Bu parametreleri, 'params = ' değişkeni aracılığıyla 'compile_reports()' öğesine bir liste olarak iletebilirsiniz. Örneğin, bu kurgusal raporda, R Markdown raporlarına sağlanan üç parametre vardır.

```{r, eval=F}
compile_reports(
  reports = "daily_sitrep.Rmd",
  params = list(most_recent_data = TRUE,
                region = "NORTHERN",
                rates_denominator = 10000),
  subfolder = "regional"
)
```


### "Çalışma dosyası" kullanma {.unnumbered}

Çalıştırılacak birden fazla raporunuz varsa, tüm 'compile_reports()' komutlarını içeren bir R betiği oluşturmayı düşünün. Bir kullanıcı bu R betiğindeki tüm komutları basitçe çalıştırabilir ve tüm raporlar derlenecektir. Bu "run-file" dosyasını "scripts" klasörüne kaydedebilirsiniz.



## Çıktılar

Raporları birkaç kez derledikten sonra, "outputs" klasörü şöyle görünebilir (açıklık için vurgular eklendi):

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "factory_overview_all.png"))
```


* "Outputs" içerisinde her bir Rmd raporu için alt klasörler oluşturulmuştur.
* Bunların içinde, her benzersiz derleme için başka alt klasörler oluşturulmuştur.
   * Bunlar tarih ve zaman damgalıdır ("2021-04-23_T11-07-36", 23 Nisan 2021, 11:07:36 anlamına gelir)
   * Tarih/zaman damgası biçimini düzenleyebilirsiniz. `?compile_reports` konusuna bakabilirsiniz.
* Her bir tarih/saat derlenmiş klasöründe, rapor çıktısı (ör. HTML, PDF, Word) Rmd betiği (sürüm kontrolü!) ve dışa aktarılan diğer dosyalar (ör. table.csv, epidemi_curve.png) ile birlikte depolanır.

"daily_sitrep" raporu için tarih/saat damgalı klasörlerden birinin içindeki bir görünüm buradadır. Dosya yolu, vurgu için sarı renkle vurgulanmıştır.  

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "factory_compile_folder.png"))
```


Son olarak, aşağıda HTML rapor çıktısının bir ekran görüntüsü bulunmaktadır.

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "factory_html.png"))
```

Çıktıların listesini gözden geçirmek için `list_outputs()` kullanabilirsiniz.



## Muhtelif İçerikler  

### Knit {.unnumbered} 

İsterseniz "knit" düğmesine basarak R Markdown raporlarınızdan birini hala "örebilirsiniz". Bunu yaparsanız, varsayılan olarak, çıktılar Rmd'nin kaydedildiği klasörde - "report_sources" klasöründe görünecektir. **reportfactory**'nin önceki sürümlerinde, "report_sources" içinde Rmd olmayan dosyaların bulunması derlemeyi engellerdi, ancak artık durum böyle değil. `compile_reports()` komutunu çalıştırabilirsiniz ve herhangi bir hata oluşmaz.

### Betikler {.unnumbered}  

.Rmd komut dosyalarınız tarafından sağlanan "runfiles" veya .R komut dosyalarını depolamak için "scripts" klasörünü kullanmanızı öneririz. Kodunuzu birkaç dosyada nasıl yapılandıracağınıza ilişkin ipuçları için [R Markdown][R Markdown ile Raporlar] hakkındaki sayfaya bakabilirsiniz.


### Ekstralar {.unnumbered}

* **reportfactory** ile, tüm fabrikadaki tüm raporlarda gerekli tüm paketleri listelemek için 'list_deps()' fonksiyonunu kullanabilirsiniz.

* Geliştirme aşamasında, raporların oluşturulmasında size yardımcı olacak daha fazla yardımcı fonksiyon sunan **rfextras** adlı bir paket vardır, örneğin:
   * `load_scripts()` - belirli bir klasördeki tüm .R komut dosyalarını kaynaklar/yükler (varsayılan olarak "scripts" klasörü)
   * `find_latest()` - bir dosyanın en son sürümünü bulur (örneğin, en son veri kümesi)



<!-- ======================================================= -->
## Kaynaklar {  }

 **reportfactory** paketleri [Github sayfası](https://github.com/reconverse/reportfactory)

 **rfextras** paketleri [Github sayfası](https://github.com/reconhub/rfextras)  

```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/reportfactory.Rmd-->


# R Markdown ile gösterge panelleri { }

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_output.png"))
```

Bu sayfa, **flexdashboard** paketinin temel kullanımını kapsayacaktır. Bu paket, R Markdown çıktısını paneller ve sayfalar içeren bir pano olarak kolayca biçimlendirmenize olanak tanır. Pano içeriği metin, istatistik şekiller/tablolar veya etkileşimli grafikler olabilir.

Flexdashboard'un avantajları:
• Minimum düzeyde standart dışı R kodlaması gerektirir - çok az pratikle hızlı bir şekilde bir gösterge paneli oluşturabilirsiniz
• Kontrol panelini genellikle bağımsız bir HTML dosyası olarak e-postayla gönderilebilirsiniz - sunucu gerekmez
• Etkileşim eklemek için flexdashboard'u shiny, ggplotly ve diğer "html widget'ları" ile birleştirebilirsiniz

Flexdashboard'un dezavantajları:
• Bir gösterge paneli oluşturmak için tek başına shiny kullanmaya kıyasla daha az özelleştirme

Bu sayfadaki bilgilerin esas kaynağı olan, esnek panel kullanımına ilişkin çok kapsamlı bilgileri kaynaklar bölümünde bulunabilir. Aşağıda, paketin temel özelliklerini açıklıyoruz ve vaka satır listesi verilerini kullanarak salgını araştırmak için bir gösterge paneli oluşturmaya ilişkin bir örnek veriyoruz. 



## Hazırlık

### Paketlerin yüklenmesi {.unnumbered}  

Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman'ın p_load() fonksiyonunu vurguluyoruz. Ayrıca, temel R'dan library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R’ın temelleri sayfasına bakın.

```{r}
pacman::p_load(
  rio,             # verinin içe / dışa aktarımı   
  here,            # dosyaları bul
  tidyverse,       # veri yönetimi ve görselleştirme
  flexdashboard,   # R Markdown raporlarının panel sürümleri
  shiny,           # interaktif figürler
  plotly           # interaktif figürler
)
```

### Verileri içe aktarın {.unnumbered}  

Simüle edilmiş bir Ebola salgını vakalarının veri setini içe aktarıyoruz. Devam etmek istiyorsanız, “temiz” satır listesini (.rds dosyası olarak) indirmek için tıklayın. Verileri rio paketinden import() fonksiyonuyla içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için İçe Aktarma ve Dışa Aktarma sayfasına bakabilirsiniz).<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>click to download the "clean" linelist</a> 

```{r, echo=F}
# satır listesini R'a aktar
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# satır listesini içe aktarma
linelist <- import("linelist_cleaned.rds")
```

Satır listesinin ilk 50 satırı aşağıda gösterilmiştir. 

```{r, message=FALSE, echo=F}
# satır listesini tablo olarak gösterin
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


## Yeni bir R Markdown oluştur 

Paketi kurduktan sonra, Dosya > Yeni dosya > R Markdown yolunu kullanarak yeni bir R Markdown dosyası oluşturun.

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_new1.png"))
```


Açılan pencerede “From Template-Şablondan”ı seçin ve “Flex Dashboard” şablonunu seçin. Daha sonra belgeyi adlandırmanız istenecektir. Bu sayfanın örneğinde, R Markdown'ımızı “outbreak_dashboard.Rmd” olarak adlandıracağız.
  

```{r out.width = "100%", out.height="75%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_new2.png"))
```



## Komutlar  

Komut dosyası bir R Markdown komut dosyasıdır ve bu nedenle R Markdown ile Raporlar sayfasında açıklananla aynı bileşenlere ve organizasyona sahiptir. Bunları kısaca yeniden inceleyeceğiz ve diğer R Markdown çıktı biçimlerinden farklılıklarını vurgulayacağız.


### YAML {.unnumbered}  

Komut dosyasının en üstünde “YAML” başlığı bulunur. Bu kısım, üç tire ile başlamalı --- ve üç tire ile kapatılmalıdır ---. YAML parametreleri anahtar:değer çiftleri halinde gelir. YAML'de iki nokta üst üste işaretinin girintisi ve yerleşimi önemlidir - anahtar:değer çiftleri iki nokta üst üste ile ayrılır (eşittir işaretleri değil!).

YAML, belge için meta verilerle başlamalıdır. Bu birincil YAML parametrelerinin (girintisiz) sırası önemli değildir. Örneğin:


```{r, eval=F}
title: "My document"
author: "Me"
date: "`r Sys.Date()`"
```

YAML değerlerinde R kodunu, satır içi kod gibi (backticks içinde r'den önce gelir) veya tırnak işaretleri içine koyarak (Tarih için yukarıya bakın) kullanabilirsiniz. Üretilecek dosyanın türünü bir YAML parametresi çıktısı belirtir. (ör. html_document, pdf_document, word_document veya powerpoint_presentation). 

Flexdashboard için bu parametre değeri biraz kafa karıştırıcıdır - output:flexdashboard::flex_dashboard olarak ayarlanmalıdır.  Tek ve çift sayıda iki nokta üst üste ve alt çizgiye noktalama işaretlerine dikkat edin. Bu YAML çıktı parametresini genellikle ek bir iki nokta üst üste ve girintili alt parametreler izler (aşağıdaki orientation:-oryantasyon: ve vertical_layout: -dikey_düzen: parametrelere bakın).

```{r, eval=F}
title: "My dashboard"
author: "Me"
date: "`r Sys.Date()`"
output:
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: scroll
```

Yukarıda gösterildiği gibi, alt parametreler için girintiler (2 boşluk) kullanılır. Bu durumda, birincilden sonra anahtar:değer: gibi ek bir iki nokta üst üste koymayı unutmayın.Uygunsa, mantık değerleri YAML'de küçük harfle (true, false, null) verilmelidir. İki nokta üst üste karakteri değerinizin bir parçasıysa (örneğin başlıkta), değeri tırnak içine alın. Aşağıdaki bölümlerdeki örneklere bakın. 



### Kod parçaları {.unnumbered}  

Bir R Markdown komut dosyası birden çok kod "parçası" içerebilir - bunlar komut dosyasının çok satırlı R kodu yazabileceğiniz alanlarıdır ve tıpkı mini R komut dosyaları gibi çalışırlar.

Kod parçaları, içinde küçük bir "r" harfi bulunan üç ters tik işareti ve küme parantezleri ile oluşturulur. Kod parçası, üç ters tik ile kapatılır. Kendiniz yazarak, “Ctrl + Alt + i” (veya Mac'te Cmd + Shift + r) klavye kısayolunu kullanarak veya komut dosyası düzenleyicinizin en üstünde 'yeni bir kod parçası ekle' simgesini tıklayarak yeni bir kod parçası oluşturabilirsiniz.. Aşağıda birçok örnek verilmiştir.  


### Anlatı metni {.unnumbered}  

Bir R kodu "parçası" dışında, anlatı metni de yazabilirsiniz. R Markdown ile Raporlar sayfasında açıklandığı gibi, metni bir yıldız işaretiyle (*) çevreleyerek italik veya iki yıldız işaretiyle (**) çevreleyerek kalın yazabilirsiniz. Madde işaretleri ve numaralandırma düzenlerinin yeni satırlara, girintilere ve iki boşlukla bir satırı bitirmeye duyarlı olduğunu hatırlayın.

Ayrıca satır içi R kodunu, R Markdown ile Raporlar sayfasında açıklandığı gibi, kodu ters tiklerle çevreleyerek ve komutu “r”: ` 1+1` ile başlatarak metne ekleyebilirsiniz (yukarıdaki tarih içeren örneğe bakın). 




### Başlıklar {.unnumbered}  

R Markdown ile Raporlar sayfasında açıklandığı gibi, farklı sayıda hash sembolü ile farklı başlık seviyeleri oluşturulur.

Flexdashboard'da, birincil başlık (#) gösterge tablosunun bir "sayfasını" oluşturur. İkinci düzey başlıklar (##), oryantasyonunuza bağlı olarak bir sütun veya satır oluşturur: Parametre (aşağıdaki ayrıntılara bakın). Üçüncü düzey başlıklar (###) çizimler, çizelgeler, tablolar, metin vb. için paneller oluşturur.


```md
# Birinci düzey başlık (sayfa)

## İkinci düzey başlık (satır veya sütun)

### Üçüncü düzey başlık (çizim, çizelge vb. için bölme) 

```


## Bölüm Özellikleri  

Normal bir R Markdown dosyasında olduğu gibi, bir başlıktan sonra, küme parantezleri { } içinde anahtar=değer seçeneklerini ekleyerek gösterge tablonuzun bölümlerine uygulanacak özellikleri belirleyebilirsiniz. Örneğin, tipik bir HTML R Markdown raporunda, ## Başlığım {.tabset} ile alt başlıkları sekmeler halinde düzenleyebilirsiniz. Bu niteliklerin, komut dosyasının metin bölümünde bir başlıktan sonra yazıldığını unutmayın. Bunlar, out.height = gibi R kodu parçalarının üstüne eklenen knitr seçeneklerinden farklıdır. 

Flexdashboard'a özgü bölüm özellikleri şunları içerir:
• {data-orientation=} Satırlara veya sütunlara göre ayarlama. Gösterge panelinizde birden fazla sayfa varsa, oryantasyonu belirtmek için bu özelliği her sayfaya ekleyin (düzen bölümünde daha ayrıntılı açıklanmıştır).
• {data-width=} ve {data-height=}, aynı boyutta (yatay veya dikey) düzenlenen grafiklerin, sütunların, satırların göreli boyutunu ayarlar. Flexbox motoru sayesinde mutlak boyutlar, herhangi bir görüntüleme cihazındaki alanı en iyi şekilde dolduracak şekilde ayarlanır.
• Grafiklerin yüksekliği, YAML parametresini vertical_layout: fill (dolgu) olarak mı yoksa vertical_layout: scroll (kaydırma) olarak mı ayarladığınıza da bağlıdır. Kaydırılacak şekilde ayarlanırsa, şekil yüksekliği, R kodu öbeğindeki geleneksel fig.height = seçeneğini yansıtacaktır.
• flexdashboard web sitesindeki tam boyut belgelerine bakın
• {.hidden} Belirli bir sayfayı gezinme çubuğundan hariç tutmak için bunu kullanın
• {data-navbar=} Bunu, bir gezinme çubuğu açılır menüsü içine yerleştirmek için sayfa düzeyinde bir başlıkta kullanın. Açılır menünün adını (tırnak içinde) belirtin. Aşağıdaki örneğe bakın. 



## Yerleşim Düzeni {#layout}  

Kontrol panelinizin düzenini aşağıdaki şekillerde ayarlayın:
• R Markdown başlıklarına sahip sayfalar, sütunlar/satırlar ve grafikler ekleyin (ör. #, ## veya ###)
• YAML parametre yönünü ayarlayın: Satırlara veya sütunlara
• Düzenin tarayıcıyı dolduracağını ya da kaydırmaya mı izin vereceğini belirtin
• Belirli bir bölüm başlığına sekmeler ekleyin



### Sayfalar {.unnumbered}  

R Markdown'daki birinci düzey başlıklar (#), gösterge tablosunun "sayfalarını" temsil edecektir. 
Varsayılan olarak sayfalar, gösterge tablosunun üst kısmındaki bir gezinme çubuğunda görünür.


```{r, out.height = c('100%'), out.width = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_pages_top_script.png"))
```


```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_pages_top_view.png"))
```


Sayfa başlığına {data-navmenu=} özelliğini ekleyerek sayfaları üst gezinme çubuğunda bir "menü" halinde gruplayabilirsiniz. Dikkatli olun - eşittir işaretinin etrafına boşluk eklemeyin, aksi takdirde çalışmaz!


```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_navmenu_script.png"))
```


İşte betiğin ürettiği:

```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_navmenu_view.png"))
```

{.sidebar} özelliği ekleyerek, bir sayfayı veya sütunu kontrol panelinin sol tarafında bir "kenar çubuğuna" da dönüştürebilirsiniz. Metni (herhangi bir sayfadan görüntülenebilir) veya entegre shiny etkileşiminiz varsa, kaydırıcılar veya açılır menüler gibi kullanıcı giriş kontrollerini eklemek faydalı olabilir.


```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_sidebar_script.png"))
```

İşte betiğin ürettiği:

```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_sidebar_view.png"))
```


### Oryantasyon {.unnumbered}  

İkinci düzey (##) R Markdown başlıklarınızın nasıl yorumlanması gerektiğini belirtmek için oryantasyon: yaml parametresini ayarlayın - oryantasyon: sütunlar (orientation: columns) veya oryantasyon: satırlar (orientation: rows) olarak. 

İkinci düzey başlıklar (##), bu yönlendirme ayarına göre yeni sütunlar veya satırlar olarak yorumlanacaktır. 

Oryantasyon: sütunlar (orientation: columns) olarak ayarlarsanız, ikinci düzey başlıklar gösterge tablosunda yeni sütunlar oluşturur. Aşağıdaki gösterge paneli, toplam üç panel içeren iki sütun içeren bir sayfaya sahiptir. Sütunların göreli genişliğini aşağıda gösterildiği gibi {data-width=} ile ayarlayabilirsiniz.

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_columns_script.png"))
```

İşte betiğin ürettiği:

```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_columns_view.png"))
```

Oryantasyon: satırlar  (orientation: rows)olarak ayarlarsanız, ikinci düzey başlıklar sütunlar yerine yeni satırlar oluşturur. Aşağıda, yukarıdakiyle aynı komut dosyası vardır, ancak oryantasyon: satırlar olarak ayarlanmıştır, böylece ikinci düzey başlıklar sütunlar yerine satırlar oluşturur. {data-height=} ile satırların göreli yüksekliğini aşağıda gösterildiği gibi ayarlayabilirsiniz.

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_rows_script.png"))
```

İşte betiğin ürettiği:

```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_rows_view.png"))
```

Kontrol panelinizde birden fazla sayfa varsa, her sayfanın başlığına {data-orientation=} özniteliğini ekleyerek (tırnak işaretleri olmadan satırları veya sütunları belirtin) seçili sayfanın yönünü belirleyebilirsiniz.  

### Sekmeler {.unnumbered} 

Diğer HTML R Markdown çıktılarında olduğu gibi içeriği {.tabset} özniteliği ile sekmelere bölebilirsiniz.

Bu özelliği istediğiniz başlıktan sonra eklemeniz yeterlidir. Bu başlığın altındaki alt başlıklar sekmeler halinde görüntülenecektir. Örneğin, aşağıdaki örnek komut dosyasında sağdaki 2. sütun (##), salgın eğrisi ve tablo bölmeleri (###) sekmelerde görüntülenecek şekilde değiştirilir.

Oryantasyonunuz satırlarsa, aynısını satırlarla da yapabilirsiniz.
 

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_tabs_script.png"))
```

İşte betiğin ürettiği: 

```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_tabs_view.png"))
```


## İçerik Ekleme  

Bir kontrol paneli oluşturmaya başlayalım. Basit panomuz 1 sayfa, 2 sütun ve 4 panelden oluşacaktır. Gösteri için panelleri parça parça inşa edeceğiz.

Metin, ggplot'lar ve tablolar gibi standart R çıktılarını kolayca dahil edebilirsiniz (Sunum için Tablolar sayfasına bakın). Bunları, diğer herhangi bir R Markdown betiğinde yaptığınız gibi, bir R kod parçası içinde kodlayın.

Not: Tamamlanmış Rmd komut dosyasını ve HTML gösterge tablosu çıktısını indirebilirsiniz - El kitabı ve verilerin indirilmesi sayfasına bakın. 



### Metin {.unnumbered}  

Markdown metnini yazabilir ve diğer herhangi bir R Markdown çıktısında olduğu gibi satır içi kod ekleyebilirsiniz. Ayrıntılar için R Markdown ile Raporlar sayfasına bakın.

Bu panele, en son hastaneye yatış tarihini ve salgında bildirilen vaka sayısını gösteren dinamik metin içeren bir özet metin paneli ekledik. 


### Tablo {.unnumbered}  

Tablolar gibi çıktıları yazdıran R kodu parçalarını dahil edebilirsiniz. Ancak, tablolarınızı görüntülemek için knitr'den kable() fonksiyonunu kullanırsanız, çıktı en iyi şekilde görünecek ve pencere boyutuna yanıt verecektir. Flextable fonksiyonları, kısaltılmış/kesilmiş tablolar üretebilir.
Örneğin, hastaneye göre vakaların özet bir tablosunu oluşturmak için aşağıda linelist()'i bir count() komutuyla besliyoruz. Sonuç olarak, tablo knitr::kable()'a yönlendirilir ve sağ tarafında bir kaydırma çubuğu bulunur. Panelinizi kable() ve kableExtra ile özelleştirme hakkında daha fazla bilgiyi burada bulabilirsiniz. [buradan](https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html).  

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_tables_script.png"))
```

İşte betiğin ürettiği:

```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_tables_view.png"))
```

Kullanıcının veri çerçevesinin "sayfalarını" filtrelemesine, sıralamasına ve/veya tıklamasına izin veren dinamik bir tablo oluşturmak istiyorsanız, aşağıdaki kodda olduğu gibi DT paketini ve onun datatable() fonksiyonunu kullanın.

Aşağıdaki örnek kod, veri çerçevesi satır listesi yazdırılır. Yatay alanı korumak için rownames = FALSE ve her sütunun üstünde filtreler olması için filter = "top" argümanını ayarlayabilirsiniz. options =  argümanı diğer özelliklerin bir listesi verebilir. Aşağıda, 5 satır görünecek şekilde pageLength = argümanını ve kullanıcının yatay olarak kaydırmak için alttaki kaydırma çubuğunu kullanabilmesi için scrollX = argümanını ayarladık. class = 'white-space: nowrap' argümanı, her satırın yalnızca bir satır (birden çok satır değil) içermesini sağlar. Diğer olası argümanlar ve değerler hakkında [buradan](https://rstudio.github.io/DT/?_ga=2.2810736.1321860763.1619286819-369061888.1601594705) veya ?datatable komutunu girerek bilgi edinebilirsiniz.


```{r, eval=F}
DT::datatable(linelist, 
              rownames = FALSE, 
              options = list(pageLength = 5, scrollX = TRUE), 
              class = 'white-space: nowrap' )
```

### Grafikler {.unnumbered}  

Grafikleri, bir R komut dosyasında olduğu gibi bir panel bölmesine yazdırabilirsiniz. Örneğimizde, iki basit komutla yaş grubuna göre bir “salgın eğrisi” oluşturmak için incidence2 paketini kullanıyoruz (bkz. Salgın eğriler sayfası). Ancak, ggplot()'u kullanabilir ve aynı şekilde bir grafik oluşturabilirsiniz.  

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_plots_script.png"))
```

İşte betiğin ürettiği:

```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_plots_view.png"))
```


### İnteraktif grafikler  {.unnumbered}  

Ayrıca standart bir ggplot veya başka bir grafik nesnesini plotly paketinden ggplotly() fonksiyonuna iletebilirsiniz (İnteraktif grafikler sayfasına bakabilirsiniz). Bu, grafiğinizi interaktif hale getirecek, okuyucunun "yaklaştırmasına" ve her veri noktasının değerinin (bu senaryoda eğrideki haftalık vaka sayısı ve yaş grubu) üzerinde fareyle gezinerek göstermesine izin verecektir. 

```{r, eval=F}
age_outbreak <- incidence(linelist, date_onset, "week", groups = age_cat)
plot(age_outbreak, fill = age_cat, col_pal = muted, title = "") %>% 
  plotly::ggplotly()
```

Gösterge panelinde bunun nasıl göründüğü aşağıda açıklanmıştır(gif). Bu interaktif fonksiyon, paneli statik bir dosya olarak e-posta olarak gönderseniz bile (bir sunucuda çevrimiçi değil) çalışmaya devam edecektir.   

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_ggplotly.gif"))
```

### HTML Araçları {.unnumbered}

[R için HTML widget'ları](http://www.htmlwidgets.org/), JavaScript kitaplıklarını kullanarak etkileşimi artıran özel bir R paketi sınıfıdır. Bunları R Markdown çıktılarına (bir flexdashboard gibi) ve shiny panolara gömebilirsiniz.

Bu widget'ların bazı yaygın örnekleri şunları içerir:

• Plotly (Bu el kitabı sayfasında ve [İnteraktif grafikler] sayfasında kullanılır)
• visNetwork (Bu el kitabının İletim Zincirleri sayfasında kullanılır)
• Leaflet (Bu el kitabının GIS Temelleri sayfasında kullanılır)
• dygraphs (Zaman serisi verilerini etkileşimli olarak göstermek için kullanışlıdır)
• DT (datatable()) (filtre, sıralama vb. ile dinamik tabloları göstermek için kullanılır)

Aşağıda, gösterge paneline visNetwork kullanan bir salgın iletim zinciri eklemeyi gösteriyoruz. Komut dosyası, yalnızca R Markdown komut dosyasının “Sütun 2” bölümüne eklenen yeni kodu gösterir. Kodu, bu el kitabının İletim zincirleri sayfasında bulabilirsiniz.


```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_chain_script.png"))
```

İşte betiğin ürettiği:

```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_chain.gif"))
```



## Kodun düzenlenmesi

Tüm kodun R Markdown flexdashboard komut dosyası içinde olmasını seçebilirsiniz. Alternatif olarak, daha temiz ve yoğun bir pano komut dosyasına sahip olmak için, harici R komut dosyalarında bulunan veya oluşturulan kod/şekilleri çağırmayı seçebilirsiniz. [R Markdown ile Raporlar] sayfasında daha ayrıntılı olarak açıklanmaktadır.  


## Shiny  

Shiny R paketini entegre etmek, gösterge panellerini kullanıcı girdilerine karşı daha da reaktif hale getirebilir. Örneğin, kullanıcının bir yetki alanı veya bir tarih aralığı seçmesini ve panellerin seçimlerine tepki vermesini sağlayabilirsiniz (örneğin, görüntülenen verileri filtreleme). Shiny’nin reaktif özelliklerini flexdashboard'a gömmek için, flexdashboard R Markdown betiğinizde sadece birkaç değişiklik yapmanız yeterlidir. 

flexdashboard olmadan da uygulamalar/gösterge panoları oluşturmak için shiny’i kullanabilirsiniz. Shiny ile gösterge panelleri sayfası, shiny sintaksı, uygulama dosyası yapısı ve paylaşım/yayınlama seçenekleri (ücretsiz sunucu seçenekleri dahil) ile ilgili temel bilgiler dahil olmak üzere bu yaklaşıma genel bir bakış sunar. Bu sintaks ve genel ipuçları, flexdashboard bağlamında da düşünülebilir.

Ancak, flexdashboard'a shiny’i yerleştirmek, flexdashboard'unuz için temel bir değişikliktir. Artık e-posta ile gönderebileceğiniz ve herkesin açıp görüntüleyebileceği bir HTML çıktısı üretmeyecektir. Bunun yerine, bir “uygulama” olacaktır. Komut dosyasının üstündeki "Knit-Ör" düğmesinin yerini, etkileşimli panelin bir örneğini bilgisayarınızda yerel olarak açacak olan bir " Run document- Belgeyi çalıştır" simgesi alacaktır.

Kontrol panelinizi paylaşmak artık şunları yapmanızı gerektirecek:

• Rmd komut dosyasını görüntüleyiciye gönderin, bilgisayarlarınızda R'da açın ve uygulamayı çalıştırın veya
• Uygulama/pano, izleyicinin erişebileceği bir sunucuda saklanmalıdır


Bu nedenle, shiny entegrasyonun faydaları vardır, aynı zamanda komplikasyonları da vardır. E-posta ile kolay paylaşım bir öncelikse ve shiny’nin reaktif özelliklerine ihtiyacınız yoksa, yukarıda gösterildiği gibi ggplotly() tarafından sunulan azaltılmış etkileşimli versiyonu düşünün.  

Aşağıda, yukarıdakiyle aynı “outbreak_dashboard.Rmd”yi kullanarak çok basit bir örnek veriyoruz. Shiny'yi flexdashboard'a entegre etmeye ilişkin kapsamlı belgeleri [buradan](https://rmarkdown.rstudio.com/flexdashboard/shiny.html) çevrimiçi olarak okuyabilirsiniz.  



### Ayarlar {.unnumbered}  

Aşağıdaki gibi çıktı (output:) ile aynı girinti düzeyinde YAML parametresi ekleyerek (runtime: shiny) flexdashboard‘da shiny özelliğini etkinleştirin:

```md
---
title: "Outbreak dashboard (Shiny demo)"
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: fill
runtime: shiny
---

```

Kullanıcıdan bilgi toplayacak shiny giriş widget'larını tutmak için bir "kenar çubuğunu-side bar" etkinleştirmek de uygundur. Yukarıda açıklandığı gibi, bir sütun oluşturun ve sol tarafta bir kenar çubuğu oluşturmak için {.sidebar} seçeneğini belirtin. Bu sütuna shiny giriş komutlarını içeren metin ve R parçaları ekleyebilirsiniz.

Uygulamanız/gösterge tablonuz bir sunucudaysa ve aynı anda birden çok kullanıcıya sahipse, ilk R kodu parçasına “global” adını verin. Verilerinizi içe aktarmak/yüklemek için bu kod parçasına gereken komutları ekleyin. Bu özel adlandırılmış kod parçası farklı şekilde ele alınır ve içine aktarılan veriler yalnızca bir kez içe aktarılır (sürekli değil) ve tüm kullanıcılar tarafından kullanılabilir. Bu, uygulamanın başlatma hızını artırır.  

### Üzerinde çalışılmış örnek {.unnumbered}  

Burada, “outbreak_dashboard.Rmd” flexdashboard komut dosyasını shiny’i içerecek şekilde uyarlıyoruz. Kullanıcıya açılır menüden bir hastane seçme yeteneği ekleyeceğiz ve salgın eğrisinin dinamik bir grafik başlığı ile yalnızca o hastaneden vakaları yansıtmasını sağlayacağız. Aşağıdakileri yapıyoruz:

* •	YAML ‘e runtime: shiny ekleyin 
•	Kurulum yığınını global şeklinde yeniden adlandırın
•	Bir kenar çubuğu oluşturun 
•	Benzersiz hastane adlarından oluşan vektörü oluşturmak için kod
•	Hastane isimleri seçimi ile bir selectInput() komutu (shiny açılır menüsü). Seçim, daha sonraki kodda input$hospital_choice olarak başvurulabilecek olan hospital_choice olarak kaydedilir.
•	Salgın eğrisi kodu (sütun 2) renderPlot({ })ile sarılmıştır ve bunları içerir:  
•	Hastane sütununu input$hospital_choice'in geçerli değeriyle sınırlayan veri kümesindeki bir filtre
•	input$hospital_choice içeren dinamik bir grafik başlığı

  
Bir input$ değerine başvuran herhangi bir kodun (reaktif olması için) render({}) fonkisyonu içinde olması gerektiğini unutmayın.

YAML, global kod parçası ve kenar çubuğu da dahil olmak üzere betiğin üst kısmı:




```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_shiny_script1.png"))
```
  
Reaktif eğri grafiğiyle birlikte 2. Sütun:

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_shiny_script2.png"))
```

Ve işte kontrol paneli:

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_shiny_view.gif"))
```




### Diğer Örnekler {.unnumbered}  

Shiny etkileşimi ve broşür haritalama widget'ını kullanan bir Shiny-flexdashboard'un sağlıkla ilgili bir örneğini incelemek için  [Geospatial Health Data: R-INLA ve Shiny ile Modelleme ve Görselleştirme çevrimiçi kitabının bu bölümüne](https://www.paulamoraga.com/book-geospatial/sec-dashboardswithshiny.html)  bakabilirsiniz.  




## Paylaşım  

Shiny öğeleri içermeyen panolar, boyutu izin veriyorsa e-postayla gönderilebilecek bir HTML dosyası (.html) verir. “Gösterge paneli” raporunu gönderebildiğiniz için ve bir web sitesi olarak saklamak için bir sunucu kurmanız gerekmediği için bu yararlıdır.

Shiny öğelerini yerleştirdiyseniz, e-posta ile çıktı gönderemezsiniz, ancak komut dosyasının kendisini bir R kullanıcısına gönderebilir veya yukarıda açıklandığı gibi gösterge panelini bir sunucuda saklayabilirsiniz. 



## Kaynaklar   

Bu sayfanın referans aldığı mükemmel eğitimleri aşağıda bulunabilir. Bunları gözden geçirirseniz, büyük olasılıkla bir saat içinde kendi gösterge tablonuzu hazırlayabilirsiniz.

https://bookdown.org/yihui/rmarkdown/dashboards.html

https://rmarkdown.rstudio.com/flexdashboard/

https://rmarkdown.rstudio.com/flexdashboard/using.html

https://rmarkdown.rstudio.com/flexdashboard/examples.html
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/flexdashboard.Rmd-->


# Shiny ile Gösterge Panelleri { }  

Gösterge paneli, genellikle analizlerden elde edilen sonuçları başkalarıyla paylaşmanın iyi bir yoludur. Kaliteli bir gösterge paneli üretmek, nispeten ileri düzeyde R dili bilgisi gerektirir, ancak inanılmaz özelleştirme seçenekleri sunar. 

<!-- One of the largest drawbacks of `R` is its usability for people who are new to or have no experience with programming languages. While these skills are very valuable, most people will find that this represents a barrier to sharing analyses, especially in multidisciplinary environments. It requires some work to maintain an `R` installation, and not everyone will be comfortable running shared code, even if it's well documented and easy to read. This is *especially* true when users have to change parameters of code!  -->

<!-- R based dashboards are also advantageous in that they centralise how code is run - when the same code is run on different machines, often people will have to deal with differing file paths, different R versions, and different package installations. For this reason, dashboards are a great way to share code with others in a user friendly way! -->

Shiny ile gösterge tablolarını öğrenen birinin, veri dönüştürme ve görselleştirme konusunda iyi bilgiye sahip olması ve kod hatalarını ayıklama ve kod işlevleri konularında bilgili olması önerilir. Gösterge panelleriyle çalışmak, başladığınızda sezgisel değildir ve bazen anlaşılması zordur, ancak öğrenmesi harika bir beceridir ve pratikle çok daha kolay hale gelir!

Bu sayfa, shiny ve uzantıları olan panellerin nasıl oluşturulacağına dair kısa bir genel bakış sağlayacaktır. Panelleri daha hızlı, daha kolay, ancak daha az özelleştirilebilir hale getirmenin alternatif bir yöntemi için, flextable [R Markdown ile gösterge panelleri] sayfasına bakabilirsiniz. 




## Hazırlık  


### Paketleri yükleme {.unnumbered}  

Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman'ın p_load() fonkisyonunu vurguluyoruz. Ayrıca, temel R'dan library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R temelleri sayfasına bakın.

**shiny** R paketini kurarak başlıyoruz: 

```{r, eval = FALSE}
pacman::p_load("shiny")
```


### Verileri içe aktarma {.unnumbered}  


Bu sayfayı takip etmek isterseniz, [el kitabının ve verilerin indirilmesi](#data_shiny) bölümüne bakabilirsiniz. Güncel Shiny uygulamasını oluşturan R komut dosyalarını ve veri dosyalarını indirmek için bağlantılar burada mevcuttur.Uygulamayı bu dosyaları kullanarak yeniden oluşturmaya çalışırsanız, lütfen kurs için  oluşturulan R projesi klasör yapısının (örneğin, "veri" ve "işlevler" için klasörler) farkında olun.


<!-- ======================================================= -->
## Shiny uygulamasının yapısı  {  }

### Temel dosya yapıları  {.unnumbered}  

Shiny’yi anlamak için önce uygulamanın dosya yapısının nasıl çalıştığını anlamamız gerekir! Başlamadan önce yepyeni bir dizin oluşturmalıyız. Bu aslında _Rstudio'da_ _yeni projeden_ _Shiny Web Application_ seçilerek daha kolay hale getirilebilir. Bu, sizin için shiny uygulamasının temel yapısını oluşturacaktır.

Bu projeyi açarken, zaten _app.R_ adında bir .R dosyası olduğunu fark edeceksiniz. İki temel dosya yapısından birine sahip olmamız önemlidir:

1. _app.R_ adında bir dosya veya
2. Biri _ui.R_ ve diğeri _server.R_ olarak adlandırılan iki dosya

Bu sayfada, _app.R_ adında bir dosyaya sahip olduğunuz ilk yaklaşımı kullanacağız. İşte örnek bir komut dosyası: 
 

```{r, eval = FALSE}
#  app.R örneği

library(shiny)

ui <- fluidPage(

    # Uygulama başlığı
    titlePanel("My app"),

    # Kaydırıcı giriş araçlı kenar çubuğu
    sidebarLayout(
        sidebarPanel(
            sliderInput("input_1")
        ),

        # Grafiği göster   
        mainPanel(
           plotOutput("my_plot")
        )
    )
)

# Bir histogram çizmek için gereken sunucu mantığını tanımlayın
server <- function(input, output) {
     
     plot_1 <- reactive({
          plot_func(param = input_1)
     })
     
    output$my_plot <- renderPlot({
       plot_1()
    })
}


# Uygulamayı çalıştırın
shinyApp(ui = ui, server = server)


```


Bu dosyayı açarsanız, biri kullanıcı arayüzü ve diğeri sunucu olarak adlandırılan iki nesnenin tanımlandığını fark edeceksiniz. Bu nesneler shiny uygulamasında tanımlanmalıdır ve uygulamanın kendi yapısının merkezinde yer alırlar! Aslında, yukarıda açıklanan iki dosya yapısı arasındaki tek fark, yapı 1'de hem kullanıcı arayüzünün hem de sunucunun tek bir dosyada tanımlanması, yapı 2'de ise ayrı dosyalarda tanımlanmalarıdır. Not: Ayrıca, uygulamamızda source() fonksiyonunu uygulayabileceğimiz başka .R dosyalarına da sahip olabiliriz (Daha büyük bir uygulamamız varsa bu şekilde yapmalıyız).



### Sunucu ve kullanıcı arayüzü (ui) {.unnumbered}

Daha sonra sunucu ve 'ui' nesnelerinin gerçekte ne yaptığını anlamamız gerekiyor. Basitçe söylemek gerekirse, bunlar, kullanıcı shiny uygulamasıyla etkileşime girdiğinde birbirleriyle etkileşime giren iki nesnedir.

Shiny bir uygulamasının UI öğesi, temel düzeyde bir HTML arayüzü oluşturan R kodudur. Bu, bir uygulamanın kullanıcı arayüzünde görüntülenen her şey anlamına gelir. Bu genellikle şunları içerir:

• "Widget'lar" - kullanıcı tarafından etkileşime geçilebilecek açılır menüler, onay kutuları, kaydırıcılar vb.
• Grafikler, tablolar, vb - R koduyla oluşturulan çıktılar
• Bir uygulamanın gezinme yönleri - sekmeler, bölmeler, vb.
• Genel metin, köprüler vb.
• HTML ve CSS öğeleri (daha sonra ele alınacaktır)


UI hakkında anlaşılması gereken en önemli şey, kullanıcıdan girdi alması ve sunucudan kaynaklanan çıktıları göstermesidir. Kullanıcı arabiriminde herhangi bir zamanda çalışan aktif kod yoktur - kullanıcı arabiriminde görülen tüm değişiklikler (az ya da çok) sunucudan geçirilir. Bu yüzden grafiklerimizi, dosya indirmelerimizi vb. sunucuda gerçekleştirmeliyiz.

Shiny uygulamasının sunucusu, uygulama başlatıldığında tüm kodun çalıştırıldığı yerdir. Sunucunun çalışma şekli biraz kafa karıştırıcı. Sunucu işlevi, kullanıcı arayüzüyle etkileşen kullanıcıya etkin bir şekilde tepki verir ve yanıt olarak kod parçalarını çalıştırır. Sunucuda bir şeyler değişirse, bunlar değişikliklerin görülebileceği kullanıcı arayüzüne geri iletilecektir. Daha da önemlisi, sunucudaki kod ardışık olmayan bir şekilde yürütülecektir (veya bu şekilde düşünmek en iyisidir). Temel olarak, kullanıcı arayüzünden veri girişi sunucudaki bir kod parçasını etkilediğinde, otomatik olarak çalışır ve bu çıktı üretilir ve görüntülenir.

Bunların hepsi muhtemelen şimdilik çok soyut geliyor, bu yüzden bunun gerçekte nasıl çalıştığına dair net bir fikir edinmek için bazı örnekler üzerinden anlatacağız.



### Bir uygulama oluşturmadan önce  {.unnumbered}

Bir uygulama oluşturmaya başlamadan önce, ne oluşturmak istediğinizi bilmek son derece yararlıdır. Kullanıcı arayüzünüz kodla yazılacağından, ne inşa ettiğinizi görselleştiremezsiniz önemlidir. Bu nedenle, neler yapabileceğiniz hakkında bir fikir edinmek için önceden shiny uygulama örneklerine bakmak son derece yararlıdır - bu uygulamaların arkasındaki kaynak koduna bakabilirseniz daha da iyi olur! Bunun için bazı harika kaynaklar şunlardır:

* [Rstudio uygulama galerisi](https://shiny.rstudio.com/gallery/)  

Neyin mümkün olduğuna dair bir fikir edindikten sonra, sizinkinin nasıl görünmesini istediğinizi haritalamak da yararlıdır - bunu kağıt üzerinde veya herhangi bir çizim yazılımında (PowerPoint, MS paint, vb.) yapabilirsiniz. İlk uygulamanız için basit bir başlangıç yapmanız faydalı olacaktır! Ayrıca internette bulduğunuz güzel bir uygulamanın kodunu işiniz için şablon olarak kullanmaktan çekinmeyin- sıfırdan uygulama oluşturmaktan çok daha kolaydır!



## Kullanıcı Arayüzü (IU) Oluşturmak

Uygulamamızı oluştururken, ne yaptığımızı görebilmemiz ve herhangi bir sunucu hatası nedeniyle uygulamanın başarısız olma riskini almamamız için önce kullanıcı arayüzü üzerinde çalışmak daha kolaydır. Daha önce de belirtildiği gibi, kullanıcı arayüzü üzerinde çalışırken bir şablon kullanmak genellikle iyidir. Temel shiny paketinde bulunan ve shiny ile kullanılabilecek bir dizi standart şablon vardır, ancak shinydashboard gibi bir dizi paket uzantısının da bulunduğunu belirtmekte fayda var. Başlangıç için temel shiny’den bir örnek kullanacağız.

Shiny kullanıcı arayüzü genellikle aşağıdaki sırayla bir dizi iç içe fonksiyon olarak tanımlanır.

1. Genel düzeni tanımlayan bir fonkisyon (en temel olanı fluidPage()'dir, ancak daha fazlası mevcuttur)
2. Şablon içindeki paneller, örneğin:
• bir kenar çubuğu (sidebarPanel())
• bir "ana" panel (mainPanel())
• bir sekme (tabPanel())
• genel bir "sütun" (sütun())
3. Widget'lar ve çıktılar - bunlar sunucuya girdiler (widget'lar) veya sunucudan çıktılar (çıkışlar) verebilir
• Widget'lar genellikle xxxInput() olarak biçimlendirilir, ör. selectInput()
• Çıktılar genellikle xxxOutput() olarak biçimlendirilir, ör. plotÇıkış()


Bu yapıların soyut bir şekilde kolayca anlaşılmayacağını bir kez daha belirtmekte fayda var, bu yüzden bir örneğe bakmak en iyisi! Bölgeye göre sıtmayla savaş dispanseri sayım verilerini görselleştiren basit bir uygulama yapmayı düşünelim. Bu verinin birçok farklı parametresi vardır, bu nedenle son kullanıcının verileri uygun gördükleri şekilde yaş grubuna/bölgeye göre tabaklamak için bazı filtreler uygulayabilmesi harika olur! Başlangıç için çok basit bir shiny şablonu kullanabiliriz: Bir kenar çubuğu şablonu. Bu şablon, widget'ların soldaki bir kenar çubuğuna yerleştirildiği ve grafiğin sağ tarafa yerleştirildiği bir şablondur.

Uygulamamızı planlayalım - verileri görselleştirmek istediğimiz bölgeyi seçmemize izin veren bir seçiciyle ve ilgilendiğimiz yaş grubunu görselleştirmemize izin veren bir seçiciyle başlayabiliriz. Bu filtreleri bir salgın eğrisi (epicurve) çizmek için kullanacağız. Bunun için: 

1. İstediğimiz bölgeyi ve ilgilendiğimiz yaş grubunu seçmemizi sağlayan iki açılır menü.
2. Ortaya çıkan salgın eğrimizi gösterebileceğimiz bir alan.


Bu şöyle görünebilir:

```{r, eval = FALSE}

library(shiny)

ui <- fluidPage(

  titlePanel("Malaria facility visualisation app"),

  sidebarLayout(

    sidebarPanel(
         # selector for district
         selectInput(
              inputId = "select_district",
              label = "Select district",
              choices = c(
                   "All",
                   "Spring",
                   "Bolo",
                   "Dingo",
                   "Barnard"
              ),
              selected = "All",
              multiple = TRUE
         ),
         # selector for age group
         selectInput(
              inputId = "select_agegroup",
              label = "Select age group",
              choices = c(
                   "All ages" = "malaria_tot",
                   "0-4 yrs" = "malaria_rdt_0-4",
                   "5-14 yrs" = "malaria_rdt_5-14",
                   "15+ yrs" = "malaria_rdt_15"
              ), 
              selected = "All",
              multiple = FALSE
         )

    ),

    mainPanel(
      # epicurve goes here
      plotOutput("malaria_epicurve")
    )
    
  )
)


```


app.R yukarıdaki UI koduyla çalıştırıldığında (app.R'nin sunucu kısmında aktif kod olmadan) düzen şöyle görünür - Bir sunucu yoksa hiçbir çizim oluşturulmayacağını unutmayın, ancak girişlerimiz düzgün çalışmaktadır!

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "shiny", "simple_UI_view.png"))
```

Bu örnek, widget'ların nasıl çalıştığını tartışmak için iyi bir fırsattır - her widget'ın bir inputId, bir etiket ve widget türüne özgü bir dizi başka seçeneği kabul ettiğini unutmayın. Bu inputId son derece önemlidir - bunlar, kullanıcı arabiriminden sunucuya bilgi aktarmak için kullanılan kimliklerdir. Bu nedenle benzersiz olmaları gerekir. Daha büyük uygulamalar söz konusu olduğunda, inputIDlere mantıklı ve etkileşime girdikleri yapılara özgü bir ad vermek için çaba göstermelisiniz. 

Bu widget'ların her birinin ne yaptığıyla ilgili tüm ayrıntılar için belgeleri dikkatlice okumalısınız. Widget'lar, widget türüne bağlı olarak belirli veri türlerini sunucuya iletir ve bunun tam olarak anlaşılması gerekir. Örneğin, selectInput() sunucuya bir karakter tipi iletir:

• Buradaki ilk widget için Spring'i seçersek, "Spring" karakter nesnesini sunucuya iletecektir.
• Açılır menüden iki öğe seçersek, bunlar bir karakter vektörü olarak gelirler (örn. c("Spring", "Bolo")).

Diğer widget'lar, sunucuya farklı nesne türleri iletecektir! Örneğin:
• numericInput(), sunucuya sayısal türde bir nesne iletir
• checkboxInput(), sunucuya mantık nesnesi iletir (DOĞRU veya YANLIŞ)


Burada yaş verileri için kullandığımız adlandırılmış vektörü de belirtmekte fayda var. Birçok pencere öğesi için, seçenekler olarak adlandırılmış bir vektörün kullanılması, vektörün adlarının seçenekler olarak görüntülenmesini sağlar, ancak sadece seçilen değeri vektörden sunucuya iletir. Yani burada birisi açılır menüden “15+” öğesini seçebilir ve kullanıcı arayüzü sunucuya "malaria_rdt_15" iletir - bu, ilgilendiğimiz sütunun adıdır!

Uygulamanızla birçok eylem yapmak için kullanabileceğiniz çok sayıda widget vardır. Widget'lar ayrıca uygulamanıza dosya yüklemenize ve çıktıları indirmenize olanak tanır. Ayrıca, temel shiny’den daha fazla widget'a erişmenizi sağlayan mükemmel shiny uzantılar da vardır - shinyWidgets paketi buna harika bir örnektir. Bazı örneklere bakmak için aşağıdaki bağlantılara bakabilirsiniz:

- [temel shiny widget galerisi](https://shiny.rstudio.com/gallery/widget-gallery.html)
- [shinyWidgets galerisi](https://github.com/dreamRs/shinyWidgets)



## Verinin uygulamamıza yüklenmesi  

Uygulama geliştirmemizdeki bir sonraki adım, sunucuyu çalışır duruma getirmektir. Ancak bunu yapmak için uygulamamıza bazı veriler aktarmamız ve yapacağımız tüm hesaplamaları bulmamız gerekiyor. Shiny uygulamasının hatalarını ayıklamak kolay değildir, çünkü hataların nereden geldiği genellikle net değildir, bu nedenle sunucunun kendisini yapmaya başlamadan önce tüm veri işleme ve görselleştirme kodumuzu çalışır duruma getirmek idealdir.

Kullanıcı girdisine göre değişen salgın eğrileri gösteren bir uygulama yapmak istediğimize göre, bunu normal bir R betiğinde çalıştırmak için hangi koda ihtiyacımız olacağını düşünmeliyiz. Şunlara ihtiyacımız olacak:
1. Paketlerimizi yükleyin
2. Verilerimizi yükleyin
3. Verilerimizi dönüştürün
4. Kullanıcı girdilerine dayalı olarak verilerimizi görselleştirmek için bir fonksiyon geliştirin


Bu liste oldukça basittir ve yapılması çok zor olmamalıdır. Artık bu sürecin hangi bölümlerinin yalnızca bir kez yapılması gerektiğini ve hangi bölümlerin kullanıcı girdilerine yanıt olarak çalıştırılması gerektiğini düşünmek önemlidir. Bunun nedeni, shiny uygulamalarının genellikle kullanımdan önce yalnızca bir kez çalıştırılan bazı kodları çalıştırmasıdır. Kodumuzun çoğu bu bölüme taşınabilirse, uygulamamızın performansına yardımcı olacaktır. Bu örnek için, sadece verilerimizi/paketlerimizi yüklememiz ve temel dönüşümleri bir kez yapmamız gerekiyor, böylece kodu sunucunun dışına yerleştirebiliriz. Bu, sunucuda ihtiyacımız olan tek kodun verilerimizi görselleştirecek kod olduğu anlamına gelir. Önce tüm bu bileşenleri bir komut dosyasında geliştirelim. Ancak verilerimizi bir fonksiyon ile görselleştirdiğimiz için, fonksiyonun kodunu sunucunun dışına da koyabiliriz, böylece uygulama çalıştığında fonksiyonumuz ortamda olur!

Önce verilerimizi yükleyelim. Yeni bir proje ile çalıştığımız ve temizlemek istediğimiz için data adında yeni bir dizin oluşturabilir ve sıtma verilerimizi oraya ekleyebiliriz. Aşağıdaki kodu, uygulamamızın yapısını temizlediğimizde sileceğimiz bir test komut dosyasında çalıştırabiliriz.


```{r, echo = TRUE}
pacman::p_load("tidyverse", "lubridate")

# veriyi oku
malaria_data <- rio::import(here::here("data", "malaria_facility_count_data.rds")) %>% 
  as_tibble()

print(malaria_data)


```


Tidy (düzenli) veri standartları kullanırsak bu verilerle çalışmak daha kolay olacaktır, bu nedenle yaş grubunun bir sütun olduğu ve vakaların başka bir sütun olduğu uzun bir veri formatına da pivotlamalıyız. Verilerin pivotlanması sayfasında öğrendiklerimizi kullanarak bunu kolayca yapabiliriz. 


```{r, echo = TRUE}

malaria_data <- malaria_data %>%
  select(-newid) %>%
  pivot_longer(cols = starts_with("malaria_"), names_to = "age_group", values_to = "cases_reported")

print(malaria_data)

```

Bu şeklide verilerimizi hazırlamayı bitirdik! Bu iş paketi, "R komut dosyasını test etme" için geliştirilecek şeyler listemizdeki 1, 2 ve 3 numaralı maddeleri kapsar. Son ve en zor görev, kullanıcı tanımlı parametrelere dayalı bir salgın eğrisi üretmek için bir fonksiyon oluşturmak olacaktır. Daha önce de belirtildiği gibi, shiny öğrenen herkesin, çalışma prensiplerini anlamak için önce fonksiyonel programlama (fonkisyonların yazılması) bölümünü incelemesi şiddetle tavsiye edilir!

Fonksiyonumuzu tanımlarken, hangi parametreleri dahil etmek istediğimizi planlamak zor olabilir. Shiny ile fonksiyonel programlama için, ilgili her parametrenin genellikle kendisiyle ilişkilendirilmiş bir widget'ı olacaktır, bu nedenle bunu planlamak genellikle oldukça kolaydır! Örneğin mevcut uygulamamızda, bölgeye göre filtreleme yapabilmek ve bunun için bir widget'ımız olmasını istiyoruz, bunun için bir bölge parametresini ekleyebiliriz. Tesise göre filtrelemek için herhangi bir uygulama işlevimiz şimdilik olmadığı için bu nedenle bunu bir parametre olarak eklememize gerek yoktur. Üç parametreli bir fonksiyon yazarak başlayalım:

1. Çekirdek veri seti
2. Seçim bölgesi
3. Tercih edilen yaş grubu


```{r}

plot_epicurve <- function(data, district = "All", agegroup = "malaria_tot") {
  
  if (!("All" %in% district)) {
    data <- data %>%
      filter(District %in% district)
    
    plot_title_district <- stringr::str_glue("{paste0(district, collapse = ', ')} districts")
    
  } else {
    
    plot_title_district <- "all districts"
    
  }
  
  # kalan veri yoksa, NULL getir
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  data <- data %>%
    filter(age_group == agegroup)
  
  
  # kalan veri yoksa, NULL getir
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  if (agegroup == "malaria_tot") {
      agegroup_title <- "All ages"
  } else {
    agegroup_title <- stringr::str_glue("{str_remove(agegroup, 'malaria_rdt')} years")
  }
  
  
  ggplot(data, aes(x = data_date, y = cases_reported)) +
    geom_col(width = 1, fill = "darkred") +
    theme_minimal() +
    labs(
      x = "date",
      y = "number of cases",
      title = stringr::str_glue("Malaria cases - {plot_title_district}"),
      subtitle = agegroup_title
    )
  
  
  
}

```


Nasıl çalıştığı nispeten basit olduğu için bu fonksiyon hakkında çok fazla ayrıntıya girmeyeceğiz. Bununla birlikte, not edilmesi gereken bir nota, hata vereceği zamanlarda NULL elde ederek hataları ayıklamamızdır. Bunun nedeni, shiny’de sunucu bir çizim nesnesi yerine bir NULL nesnesi ürettiğinde, kullanıcı arayüzünde hiçbir şey gösterilmeyecek olmasıdır! Bu önemlidir, aksi takdirde hatalar genellikle uygulamanızın çalışmayı durdurmasına neden olur.

Dikkat edilmesi gereken bir diğer nokta da, bölge girdisini değerlendirirken %in% operatörünün kullanılmasıdır. Yukarıda bahsedildiği gibi bu operatör birden çok değere sahip bir karakter vektörü olarak kullanılabilir ,bu nedenle %in% operatörünü kullanmak, == operatöründen daha esnektir.

Fonksiyonumuzu test edelim!


```{r, echo = TRUE, warning = FALSE}

plot_epicurve(malaria_data, district = "Bolo", agegroup = "malaria_rdt_0-4")

```

Fonksiyonumuz çalışırken, tüm bunların shiny uygulamamıza nasıl sığacağını anlamamız gerekiyor. Başlangıç kodu kavramından daha önce bahsetmiştik, ancak şimdi bunu uygulamamızın yapısına nasıl dahil edebileceğimize bakalım. Bunu yapabilmemizin iki yolu var!

1. Bu kodu _app.R_ dosyanıza komut dosyasının başına (kullanıcı arayüzünün üstüne) koyun veya
2. Uygulamanızın _global.R_ adlı dizininde yeni bir dosya oluşturun ve başlangıç kodunu bu dosyaya yerleştirin.

Bu noktada, dosya yapınızı basit bir şekilde ayırmanıza izin verdiği için, özellikle daha büyük uygulamalarda, ikinci seçenekteki dosya yapısını kullanmanın genellikle daha kolay olduğunu belirtmekte fayda var. Şimdi bu global.R betiğini tamamen geliştirelim. Böyle görünebilir:



```{r, eval = F}
# global.R betiği

pacman::p_load("tidyverse", "lubridate", "shiny")

# veriyi oku
malaria_data <- rio::import(here::here("data", "malaria_facility_count_data.rds")) %>% 
  as_tibble()

# veriyi temizle ve uzun pivotla
malaria_data <- malaria_data %>%
  select(-newid) %>%
  pivot_longer(cols = starts_with("malaria_"), names_to = "age_group", values_to = "cases_reported")


# grafik fonksiyonunu tanımla
plot_epicurve <- function(data, district = "All", agegroup = "malaria_tot") {
  
  # grafik başlığı oluştur
  if (!("All" %in% district)) {            
    data <- data %>%
      filter(District %in% district)
    
    plot_title_district <- stringr::str_glue("{paste0(district, collapse = ', ')} districts")
    
  } else {
    
    plot_title_district <- "all districts"
    
  }
  
  # kalan veri yoksa, NULL sonucunu getir  
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  # yaş grubuna filtrele
  data <- data %>%
    filter(age_group == agegroup)
  
  
  # kalan veri yoksa, NULL sonucunu getir  
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  if (agegroup == "malaria_tot") {
      agegroup_title <- "All ages"
  } else {
    agegroup_title <- stringr::str_glue("{str_remove(agegroup, 'malaria_rdt')} years")
  }
  
  
  ggplot(data, aes(x = data_date, y = cases_reported)) +
    geom_col(width = 1, fill = "darkred") +
    theme_minimal() +
    labs(
      x = "date",
      y = "number of cases",
      title = stringr::str_glue("Malaria cases - {plot_title_district}"),
      subtitle = agegroup_title
    )
  
  
  
}



```


Bright'ın harika bir özelliği, app.R, server.R, ui.R ve global.R adlı dosyaların ne için olduğunu anlamasıdır, bu nedenle herhangi bir kod aracılığıyla bunları birbirine bağlamaya gerek yoktur. Bu yüzden sadece global.R'deki bu kodu dizinde bulundurmak uygulamamızı başlatmadan önce çalışması için yeterlidir!

Ayrıca, çizim işlevini kendi dosyasına taşımamızın uygulamamızın organizasyonunu iyileştireceğini de unutmamalıyız – bu eylem özellikle uygulamalar büyüdükçe yararlı olacaktır. Bunu yapmak için funcs adında başka bir dizin oluşturabilir ve bu işlevi plot_epicurve.R adlı bir dosyaya yerleştirebiliriz. Daha sonra bu işlevi global.R'de aşağıdaki komutla okuyabiliriz:


```{r, eval = F}

source(here("funcs", "plot_epicurve.R"), local = TRUE)

```

Uygulama bir sunucuda yayınlandığında kaynak bulmayı etkileyeceğinden, shiny uygulamalarında her zaman local argümanını 'local= TRUE' belirtmeniz gerektiğini unutmayın. 

## Bir uygulama sunucusu geliştirme

Artık kodumuzun çoğunu yazdığımıza göre, sadece sunucumuzu geliştirmemiz gerekiyor. Bu, uygulamamızın son parçasıdır ve muhtemelen anlaşılması en zor olanıdır. Sunucu büyük bir R işlevidir, ancak onu bir dizi daha küçük işlev veya uygulamanın gerçekleştirebileceği görevler olarak düşünmek yararlıdır. Bu işlevlerin doğrusal bir sırada yürütülmediğini anlamak önemlidir. Onlara verilen bir emir vardır ancak shiny’de başlangıç seviyesinde bu süreci tam olarak anlamak gerekli değildir. Çok temel düzeyde, bu görevler veya işlevler, geliştirici farklı davranacak şekilde ayarlamadıkça, sadece kullanıcı girdilerinde kendilerini etkileyen bir değişiklik olduğunda etkinleşir. Yine, bunların hepsi oldukça soyut kavramlardır. Ama önce üç temel shiny nesne türünü inceleyelim.

1. Reaktif kaynaklar - bu, kullanıcı girdileri için başka bir terimdir. Shiny sunucusu, programladığımız widget'lar aracılığıyla UI'den (kullanıcı arayüzünden) gelen çıktılara erişebilir. Değerleri her değiştirildiğinde, bu bilgi sunucuya iletilir.

2. Reaktif iletkenler - bunlar yalnızca shiny sunucusunun içinde bulunan nesnelerdir. Bunlara aslında basit uygulamalar için ihtiyacımız yoktur, yalnızca sunucu içinde görülebilen ve diğer işlemlerde kullanılabilen nesneler üretirler. Genellikle reaktif kaynaklara bağlıdırlar.

3. Son noktalar - bunlar sunucudan kullanıcı arayüzüne iletilen çıktılardır. Örneğimizde, ürettiğimiz salgın eğrisi bu olacaktır.

Bunu akılda tutarak, sunucumuzu adım adım oluşturalım. Burada sadece referans olması için UI kodumuzu tekrar göstereceğiz: 


```{r, eval = FALSE}

ui <- fluidPage(

  titlePanel("Malaria facility visualisation app"),

  sidebarLayout(

    sidebarPanel(
         # bölge için seçici
         selectInput(
              inputId = "select_district",
              label = "Select district",
              choices = c(
                   "All",
                   "Spring",
                   "Bolo",
                   "Dingo",
                   "Barnard"
              ),
              selected = "All",
              multiple = TRUE
         ),
         # yaş grubu için seçici
         selectInput(
              inputId = "select_agegroup",
              label = "Select age group",
              choices = c(
                   "All ages" = "malaria_tot",
                   "0-4 yrs" = "malaria_rdt_0-4",
                   "5-14 yrs" = "malaria_rdt_5-14",
                   "15+ yrs" = "malaria_rdt_15"
              ), 
              selected = "All",
              multiple = FALSE
         )

    ),

    mainPanel(
      # salgın eğrisi burada bulunur
      plotOutput("malaria_epicurve")
    )
    
  )
)


```

Bu kod kullanıcı arayüzünden elimize:
• İki giriş ulaşır: 
• Bölge seçicisi(bir select_district giriş kimliğiyle)
• Yaş grubu seçicisi (inputId'si select_agegroup olan)

• Bir çıktı:
• Salgın eğrisi (sıtma_epicurve çıkış kimliği ile)

Daha önce de belirtildiği gibi, girdi ve çıktılarımıza atadığımız bu benzersiz isimler çok önemlidir. Benzersiz olmalıdırlar ve kullanıcı arayüzü ile sunucu arasında bilgi iletmek için kullanılırlar. Sunucumuzda girdilerimize 'input$inputID' ve output sintaksı aracılığıyla erişiyoruz ve 'output$output_name' sintaksı aracılığıyla kullanıcı arayüzüne iletiyoruz. Şimdi bir örneğe bakalım, çünkü bunu başka türlü anlaşılması güçtür. 


```{r, eval = FALSE}

server <- function(input, output, session) {
  
  output$malaria_epicurve <- renderPlot(
    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)
  )
  
}


```

Bunun gibi basit bir uygulamanın sunucusu aslında oldukça basittir! Sunucunun üç parametreli bir fonksiyon olduğunu fark edeceksiniz - giriş, çıkış ve oturum - bunu anlamak bu basamakta o kadar önemli değildir , ancak bu kuruluma bağlı kalmak önemlidir! Sunucumuzda sadece bir görevimiz mevcuttur – bu da daha önce oluşturduğumuz fonksiyonumuza ve sunucudan gelen girdilere dayalı bir grafik oluşturmaktır. Giriş ve çıkış nesnelerinin adlarının, kullanıcı arabirimindekilere tam olarak nasıl karşılık geldiğine dikkat edin.

Sunucunun kullanıcı girdilerine nasıl tepki verdiğinin temellerini anlamak için, girdiler değiştiğinde çıktının (altta yatan paket aracılığıyla) da değişeceğin ve her değişimle bir grafik oluşturmak için bu fonksiyonu yeniden çalıştıracağını unutmamalısınız. Burada renderPlot() fonksiyonunu da kullandığımızı unutmayın – bu fonksiyon, nesneleri bir kullanıcı arabirimi çıktısına ileten sınıfa özgü fonkisyonlar ailesindendir. Benzer şekilde davranan birkaç fonksiyon vardır, ancak kullanılan fonksiyonun kullanıcı arayüzüne ilettiğiniz nesnenin sınıfıyla eşleştiğinden emin olmanız gerekir! Örneğin:


- `renderText()` - kullanıcı arayüzüne metin gönderir
- `renderDataTable` - kullanıcı arayüzüne etkileşimli bir tablo gönderir.

Bunların da kullanıcı arayüzünde kullanılan çıktı işleviyle eşleşmesi gerektiğini unutmayın - bu nedenle renderPlot(), plotOutput() ile eşleştirilir ve renderText(), textOutput() ile eşleştirilir.

Sonunda çalışan bir uygulama yaptık! Bunu Rstudio'da komut dosyası penceresinin sağ üst kısmındaki Uygulamayı Çalıştır düğmesine basarak çalıştırabiliriz. Uygulamanızı, diğer kullanıcılar için uygulamanın nasıl görüneceğini daha doğru bir şekilde yansıtacak olan varsayılan tarayıcınızda (Rstudio yerine) çalıştırmayı seçebileceğinizi unutmayın.


```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "shiny", "app_simple_view.gif"))
```


Uygulamanın R konsolunda "dinlediğini" fark  etmek eğlencelidir! Reaktivite hakkında konuşun!

```{r, echo=F}
knitr::include_graphics(here::here("images", "shiny", "listening.png"))
```


<!-- TO DO: *ADD SOMETHING ON DOWNLOADING A ZIP FILE OF THE APP?*  -->



## Daha fazla işlevsellik eklemek

Bu noktada nihayet çalışan bir uygulamamız var, ancak işlevsellik düzeyi düşüktür. Ayrıca, shine paketiyle yapabileceklerin henüz çok az kısımını gördük, bu yüzden öğrenecek daha çok şey var! Bazı ekstra özellikler ekleyerek mevcut uygulamamızı oluşturmaya devam edelim. Eklemenin uygun olacağı  bazı seçenekler şunlar olabilir:

1. Açıklayıcı metinler
2. Grafikler için bir indirme düğmesi - bu, kullanıcının uygulamada oluşturdukları görüntünün yüksek kaliteli bir sürümünü elde etmesini sağlar
3. Belirli tesisler için bir seçici
4. Başka bir gösterge paneli sayfası - bu, verilerimizin bir tablosunu gösterebilir.

Bu şekilde eklenebilecek çok şey vardır, bu şekilde bir sürü farklı shiny özelliği hakkında bilgi edinebiliriz. Shiny hakkında öğrenilecek çok şey var (çok gelişmiş olabilir, ancak umarız ki kullanıcılar shiny’yi nasıl kullanacakları konusunda daha iyi bir fikre sahip olduklarında, harici öğrenme kaynaklarını kullanarak da daha rahat olabilirler).




### Statik metin eklemek {.unnumbered}  

Önce shiny uygulamamıza statik metin eklemeyi tartışalım. İşin temellerini bildikten sonra, uygulamamıza metin eklemek son derece kolaydır. Shiny uygulamasında statik metin değişmediğinden (Değişmesini isterseniz, sunucudaki metin oluşturma fonkisyonlarını kullanabilirsiniz!), shiny’nin tüm statik metinleri genellikle uygulamanın kullanıcı arayüzüne eklenir. Bunu çok ayrıntılı olarak ele almayacağız, ancak R'ı HTML ve css ile arayüz olarak kullanarak; kullanıcı arayüzünüze (ve hatta özelleştirilmiş olanlara) bir dizi farklı öğe ekleyebilirsiniz.

HTML ve css, kullanıcı arayüzü tasarımında açıkça yer alan dillerdir. Bunları çok iyi anlamamıza gerek yok, ancak HTML, UI'de nesneler oluşturur (metin kutusu veya tablo gibi) ve css genellikle bu nesnelerin stilini ve estetiğini değiştirmek için kullanılır. Shiny'nin çok sayıda HTML etiketine erişimi vardır – bunların arasında başlıklar, metin paragrafları, satır sonları, tablolar vb. gibi belirli bir şekilde davranan nesneler için bulunur. Bu örneklerden bazılarını şu şekilde kullanabiliriz:


- `h1()` - bu, ekteki metni otomatik olarak büyütecek ve yazı tipi yüzü, rengi vb. ile ilgili varsayılanları değiştirecek bir başlık etiketidir (uygulamanızın ana temasına bağlı olarak). h2() ile h6()'ya kadar daha küçük ve daha küçük alt başlıklara da erişebilirsiniz. Kullanım şuna benzer:
  * `h1("my header - section 1")`

- `p()` - bu, içine alınmış metni bir metin gövdesindeki metne benzer hale getiren bir paragraf etiketidir. Bu metin otomatik olarak sarılır ve nispeten küçük bir boyutta olur (örneğin alt bilgiler daha küçük olabilir.) Bunu bir word belgesinin metin gövdesi olarak düşünün. Kullanım şuna benzer:

  * `p("Bu, uygulamamın işlevini açıkladığım daha büyük bir metindir")`
  
- `tags$b()` ve `tags$i()` - bunlar kalın etiketler tags$b() ve italik etiketler tags$i() oluşturmak için kullanılır.

- `tags$ul()`, `tags$ol()` ve `tags$li()` - bunlar, listelerin oluşturulmasında kullanılan etiketlerdir. Bunların tümü aşağıdaki sintaks içinde kullanılır ve kullanıcının sıralı bir liste (tags$ol(); yani numaralandırılmış) veya sırasız liste (tags$ul(), yani madde işareti noktaları) oluşturmasına izin verir. Tags$li(), kullanılan liste türünden bağımsız olarak listedeki öğeleri belirtmek için kullanılır. Örneğin.:


```{r, eval = F}

tags$ol(
  
  tags$li("Item 1"),
  
  tags$li("Item 2"),
  
  tags$li("Item 3")
  
)

```

- `br()` ve `hr()` - bu etiketler sırasıyla satır sonu ve yatay satır (satır sonu ile) oluşturur. Uygulamanızı ve metninizi bölümlerini ayırmak için bunları kullanın! Bu etiketlere herhangi bir öğe iletmeye gerek yoktur (parantezler boş kalabilir).


- `div()` - bu etiket her şeyi içerebilen ve herhangi bir adla adlandırılabilen genel bir etikettir. Kullanıcı arayüzü tasarımında ilerlediğinizde, bunları kullanıcı arayüzünüzü bölümlere ayırmak, belirli bölümlere belirli stiller vermek ve sunucu ile kullanıcı arabirimi öğeleri arasında etkileşimler oluşturmak için kullanabilirsiniz. Bunlara ayrıntılı olarak girmeyeceğiz, ancak bu etiketin farkında olmak önemlidir!

Bu nesnelerin her birine, `tags$...` aracılığıyla veya bazıları için de yalnızca fonksiyon aracılığıyla erişilebileceğini unutmayın. Bunlar eş anlamlıdır, ancak daha açık olmayı ve yanlışlıkla fonksiyonların üzerine yazmamayı tercih ederseniz, `tags$...` stili etiketleri kullanmak yardımcı olabilir. Bu aynı zamanda mevcut etiketlerin kapsamlı bir listesi değildir. Tüm etiketlerin tam listesi [burada](https://shiny.rstudio.com/articles/tag-glossary.html) shiny olarak mevcuttur ve daha da fazlası HTML'yi doğrudan kullanıcı arayüzünüze ekleyerek kullanılabilir!


Kendinize güveniyorsanız, herhangi birindeki stil argümanı ile HTML etiketlerinize herhangi bir **css stil öğesi** de ekleyebilirsiniz. Bunun nasıl çalıştığına ayrıntılı olarak girmeyeceğiz, ancak bir kullanıcı arayüzündeki estetik değişiklikleri test etmek için, chrome’da (tarayıcıda çalıştırdığınız shiny uygulamanızın) HTML denetçi modunu kullanmak ve nesnelerin stilini kendiniz düzenleyebilirsiniz!

Uygulamamıza biraz metin ekleyelim


```{r, eval = F}

ui <- fluidPage(

  titlePanel("Malaria facility visualisation app"),

  sidebarLayout(

    sidebarPanel(
         h4("Options"),
         # selector for district
         selectInput(
              inputId = "select_district",
              label = "Select district",
              choices = c(
                   "All",
                   "Spring",
                   "Bolo",
                   "Dingo",
                   "Barnard"
              ),
              selected = "All",
              multiple = TRUE
         ),
         # selector for age group
         selectInput(
              inputId = "select_agegroup",
              label = "Select age group",
              choices = c(
                   "All ages" = "malaria_tot",
                   "0-4 yrs" = "malaria_rdt_0-4",
                   "5-14 yrs" = "malaria_rdt_5-14",
                   "15+ yrs" = "malaria_rdt_15"
              ), 
              selected = "All",
              multiple = FALSE
         ),
    ),

    mainPanel(
      # salgın eğrisi burada bulunur
      plotOutput("malaria_epicurve"),
      br(),
      hr(),
      p("Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:"),
    tags$ul(
      tags$li(tags$b("location_name"), " - the facility that the data were collected at"),
      tags$li(tags$b("data_date"), " - the date the data were collected at"),
      tags$li(tags$b("submitted_daate"), " - the date the data were submitted at"),
      tags$li(tags$b("Province"), " - the province the data were collected at (all 'North' for this dataset)"),
      tags$li(tags$b("District"), " - the district the data were collected at"),
      tags$li(tags$b("age_group"), " - the age group the data were collected for (0-5, 5-14, 15+, and all ages)"),
      tags$li(tags$b("cases_reported"), " - the number of cases reported for the facility/age group on the given date")
    )
    
  )
)
)



```

```{r, echo=F}
knitr::include_graphics(here::here("images", "shiny", "app_text_view.png"))
```


### Bir link (köprü) eklemek {.unnumbered}

Bir web sitesine link eklemek için, bağlantıyla birlikte tags$a() kullanın ve metni aşağıda gösterildiği gibi görüntüleyin. Bağımsız bir paragrafa için metni p() içine koyun. Bir cümlenin sadece birkaç kelimesini linke bağlamak için, cümleyi parçalara ayırın ve köprülü kısım için tag$a() kullanın. Bağlantının yeni bir tarayıcı penceresinde açılmasını sağlamak için argüman olarak target = "_blank" ekleyin.

```{r, eval=F}
tags$a(href = "www.epiRhandbook.com", "Visit our website!")
```



### İndirme düğmesi eklemek {.unnumbered}

Üç özellikten ikincisine geçelim. İndirme düğmesini uygulamaya eklemek oldukça yaygındır ve yapılması oldukça kolaydır. Kullanıcı arayüzümüze başka bir widget eklememiz gerekiyor ve bunun için sunucumuza başka bir çıktı eklememiz gerekiyor. Bu örnekte reaktif iletkenleri de tanıtabiliriz!

Önce kullanıcı arabirimimizi güncelleyelim - bu kolay çünkü shiny, downloadButton() adlı bir widget ile birlikte gelir - ona bir inputId ve bir etiket verelim.


```{r, eval = FALSE}

ui <- fluidPage(

  titlePanel("Malaria facility visualisation app"),

  sidebarLayout(

    sidebarPanel(
         # selector for district
         selectInput(
              inputId = "select_district",
              label = "Select district",
              choices = c(
                   "All",
                   "Spring",
                   "Bolo",
                   "Dingo",
                   "Barnard"
              ),
              selected = "All",
              multiple = FALSE
         ),
         # yaş grubu için seçici
         selectInput(
              inputId = "select_agegroup",
              label = "Select age group",
              choices = c(
                   "All ages" = "malaria_tot",
                   "0-4 yrs" = "malaria_rdt_0-4",
                   "5-14 yrs" = "malaria_rdt_5-14",
                   "15+ yrs" = "malaria_rdt_15"
              ), 
              selected = "All",
              multiple = FALSE
         ),
         # dikey hat
         hr(),
         downloadButton(
           outputId = "download_epicurve",
           label = "Download plot"
         )

    ),

    mainPanel(
      # salgon eğrisi buradadır
      plotOutput("malaria_epicurve"),
      br(),
      hr(),
      p("Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:"),
      tags$ul(
        tags$li(tags$b("location_name"), " - the facility that the data were collected at"),
        tags$li(tags$b("data_date"), " - the date the data were collected at"),
        tags$li(tags$b("submitted_daate"), " - the date the data were submitted at"),
        tags$li(tags$b("Province"), " - the province the data were collected at (all 'North' for this dataset)"),
        tags$li(tags$b("District"), " - the district the data were collected at"),
        tags$li(tags$b("age_group"), " - the age group the data were collected for (0-5, 5-14, 15+, and all ages)"),
        tags$li(tags$b("cases_reported"), " - the number of cases reported for the facility/age group on the given date")
      )
      
    )
    
  )
)


```
 
Burada ek olarak bir hr() etiketi eklediğimizi unutmayın - bu, kontrol widgetlarımızı indirme widgetlarımızdan ayıran yatay bir çizgi ekler. Bu, daha önce tartıştığımız HTML etiketlerinden bir diğeridir.

Artık kullanıcı arayüzümüz hazır olduğuna göre, sunucu bileşenini eklememiz gerekiyor. İndirmeler, downloadHandler() fonksiyonuyla sunucuda yapılır. Grafiğimize benzer şekilde, indirme düğmesiyle aynı inputId'ye sahip bir çıktıya eklememiz gerekiyor. Bu fonkisyonun iki argümanı vardır - dosya adı ve içerik - bunların ikisi de işlevdir. Tahmin edebileceğiniz gibi, dosya adı indirilen dosyanın adını belirtmek için, içerik ise neyin indirileceğini belirtmek için kullanılır. İçerik, verileri yerel olarak kaydetmek için kullanacağınız bir fonkisyon içerir - bu nedenle, bir csv dosyası indiriyorsanız rio::export() fonksiyonunu kullanabilirsiniz. Bir grafik indirdiğimiz için ggplot2::ggsave() kullanacağız. Bunu nasıl programlayacağımıza bakalım (henüz sunucuya eklemeyeceğiz). 

```{r, eval = FALSE}

server <- function(input, output, session) {
  
  output$malaria_epicurve <- renderPlot(
    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)
  )
  
  output$download_epicurve <- downloadHandler(
    filename = function() {
      stringr::str_glue("malaria_epicurve_{input$select_district}.png")
    },
    
    content = function(file) {
      ggsave(file, 
             plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup),
             width = 8, height = 5, dpi = 300)
    }
    
  )
  
}


```


İçerik fonksiyonunun her zaman çıktı dosyası adının belirtildiği bir dosya argümanına ihtiyacı olduğunu unutmayın. Burada kodu tekrarladığımızı da fark edebilirsiniz - bu sunucuda bir kez indirme için ve bir kez de uygulamada görüntülenen grafik için olmak üzere plot_epicurve() fonksiyonumuzu iki kez kullanıyoruz. Bu, performansı büyük ölçüde etkilemeyecek olsa da,  , kullanıcı bölge ve yaş grubunu belirten widgetları değiştirdiğinde ve grafiği indirmek istediğinde grafiği oluşturacak kodun çalıştırılması gerektiği anlamına gelir. Daha büyük uygulamalarda, bunun gibi optimal olmayan kararlar işleri daha da yavaşlatacaktır, bu nedenle uygulamamızı bu anlamda nasıl daha verimli hale getireceğimizi öğrenmek gerekir. Daha mantıklı olan, bölgeler/yaş grupları değiştiğinde epicurve kodunu çalıştırmanın bir yolu olması ve bunun renderPlot() ve downloadHandler() fonksiyonları tarafından kullanılmasına izin verilmesidir. Burada reaktif iletkenler devreye girer!
 
Reaktif iletkenler, shiny sunucusunda reaktif bir şekilde oluşturulan, ancak çıktısı alınmayan nesnelerdir - yalnızca sunucunun diğer bölümleri tarafından kullanılabilirler. Birkaç farklı türde reaktif iletken vardır, ancak temel ikisini inceleyeceğiz.

1.reactive() - bu en temel reaktif iletkendir - içinde kullanılan herhangi bir girdi değiştiğinde tepki verir (bu durumda bölge/yaş grubu widget'larımız)

2. eventReactive()- bu rektif iletken, kullanıcının hangi girişlerin tekrar çalışmasına neden olduğunu belirleyebilmesi dışında, reaktif() ile aynı şekilde çalışır. Bu, reaktif iletkeninizin işlenmesi uzun zaman alıyorsa yararlıdır, ancak reaktif iletken daha sonra açıklanacaktır.

İki örneğe bakalım:


```{r, eval = FALSE}

malaria_plot_r <- reactive({
  
  plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)
  
})


# sadece bölge seçici değiştiğinde çalışır!
malaria_plot_er <- eventReactive(input$select_district, {
  
  plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)
  
})



```

eventReactive() kurulumunu kullandığımızda, bu kod parçasının çalışmasına hangi girdilerin neden olduğunu belirleyebiliriz - bu şu anda bizim için pek kullanışlı değil, bu yüzden şimdilik bırakabiliriz. c() ile birden çok giriş ekleyebileceğinizi unutmayın.

Bunu sunucu kodumuza nasıl entegre edebileceğimize bakalım:


```{r, eval = FALSE}

server <- function(input, output, session) {
  
  malaria_plot <- reactive({
    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)
  })
  
  
  
  output$malaria_epicurve <- renderPlot(
    malaria_plot()
  )
  
  output$download_epicurve <- downloadHandler(
    
    filename = function() {
      stringr::str_glue("malaria_epicurve_{input$select_district}.png")
    },
    
    content = function(file) {
      ggsave(file, 
             malaria_plot(),
             width = 8, height = 5, dpi = 300)
    }
    
  )
  
}


```

Hem indirme hem de grafik oluşturma işlevlerimizde tanımladığımız reaktif iletkenimizin çıktısını çağırdığımızı görebilirsiniz. Reaktiflerin çıktılarını fonksiyon gibi kullanmanız gerekir - bu nedenle sonlarına boş parantezler eklemelisiniz (yani, malaria_plot() doğrudur ve malaria_plot değil). Artık bu çözümü de eklediğimize göre, salgın eğrisi fonksiyonunu çalıştıran tüm kodlarımız tek bir yerde olduğundan uygulamamız daha düzenli (tidy), ve hızlıdır, değiştirilmesi de daha kolay.


```{r, echo=F}
knitr::include_graphics(here::here("images", "shiny", "download_button_view.png"))
```


### Tesis seçici eklemek {.unnumbered}  

Bir sonraki özelliğimize geçelim - belirli tesisler için bir seçici. Fonksiyonumuza kodumuzdan bir argüman olarak iletebileceğimiz başka bir parametre uygulayacağız. İlk önce bunu yapmaya odaklanalım. – Yeni parametre diğer parametrelerle aynı ilkelere göre çalışır. Fonksiyonumuzu güncelleyip test edelim.


```{r, echo = TRUE}

plot_epicurve <- function(data, district = "All", agegroup = "malaria_tot", facility = "All") {
  
  if (!("All" %in% district)) {
    data <- data %>%
      filter(District %in% district)
    
    plot_title_district <- stringr::str_glue("{paste0(district, collapse = ', ')} districts")
    
  } else {
    
    plot_title_district <- "all districts"
    
  }
  
  # kalan veri yoksa, NULL getir
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  data <- data %>%
    filter(age_group == agegroup)
  
  
  # kalan veri yoksa, NULL getir
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  if (agegroup == "malaria_tot") {
      agegroup_title <- "All ages"
  } else {
    agegroup_title <- stringr::str_glue("{str_remove(agegroup, 'malaria_rdt')} years")
  }
  
    if (!("All" %in% facility)) {
    data <- data %>%
      filter(location_name == facility)
    
    plot_title_facility <- facility
    
  } else {
    
    plot_title_facility <- "all facilities"
    
  }
  
  # kalan veri yoksa, NULL getir
  if (nrow(data) == 0) {
    
    return(NULL)
  }

  
  
  ggplot(data, aes(x = data_date, y = cases_reported)) +
    geom_col(width = 1, fill = "darkred") +
    theme_minimal() +
    labs(
      x = "date",
      y = "number of cases",
      title = stringr::str_glue("Malaria cases - {plot_title_district}; {plot_title_facility}"),
      subtitle = agegroup_title
    )
  
  
  
}
```

Haydi deneyelim:  

```{r, warning=F, message=F}

plot_epicurve(malaria_data, district = "Spring", agegroup = "malaria_rdt_0-4", facility = "Facility 1")

```


Verilerimizdeki tüm tesisler için hangi tesislerin hangi bölgelere karşılık geldiği çok net değildir - ve son kullanıcı da bu bilgiye erişemeyecektir. Bu, uygulamayı kullanmayı oldukça zor hale getirebilir. Bu nedenle, kullanıcı bölgeyi değiştirdikçe UI'deki tesis seçeneklerini dinamik olarak değiştirmeliyiz - biri diğerini filtrelemelidir! Seçeneklerde kullandığımız çok fazla değişken olduğundan, global.R dosyamızdaki kullanıcı arayüzü için bazı ayarlarımızı verilerimizden oluşturmak isteyebiliriz. Örneğin, verilerimizi okuduktan sonra bu kod parçasını global.R'ye ekleyebiliriz:



```{r, , message =  FALSE}

all_districts <- c("All", unique(malaria_data$District))

# bölgeye göre konum adlarının veri çerçevesi
facility_list <- malaria_data %>%
  group_by(location_name, District) %>%
  summarise() %>% 
  ungroup()

```

Bölgelere bakalım 

```{r}
all_districts
```


```{r}
facility_list
```


Bu yeni değişkenler, hem sunucu hem de kullanıcı arabirimi tarafından global olarak görünür olduklarından, herhangi bir sorun olmadan kullanıcı arabirimine geçirebiliriz! Arayüzümüzü güncelleyelim:

```{r, eval = FALSE}


ui <- fluidPage(

  titlePanel("Malaria facility visualisation app"),

  sidebarLayout(

    sidebarPanel(
         # bölge için seçici
         selectInput(
              inputId = "select_district",
              label = "Select district",
              choices = all_districts,
              selected = "All",
              multiple = FALSE
         ),
         # yaş grubu için seçici
         selectInput(
              inputId = "select_agegroup",
              label = "Select age group",
              choices = c(
                   "All ages" = "malaria_tot",
                   "0-4 yrs" = "malaria_rdt_0-4",
                   "5-14 yrs" = "malaria_rdt_5-14",
                   "15+ yrs" = "malaria_rdt_15"
              ), 
              selected = "All",
              multiple = FALSE
         ),
         # kurum için seçici
         selectInput(
           inputId = "select_facility",
           label = "Select Facility",
           choices = c("All", facility_list$location_name),
           selected = "All"
         ),
         
         # dikey çizgi
         hr(),
         downloadButton(
           outputId = "download_epicurve",
           label = "Download plot"
         )

    ),

    mainPanel(
      # salgın eğrisi buradadır
      plotOutput("malaria_epicurve"),
      br(),
      hr(),
      p("Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:"),
      tags$ul(
        tags$li(tags$b("location_name"), " - the facility that the data were collected at"),
        tags$li(tags$b("data_date"), " - the date the data were collected at"),
        tags$li(tags$b("submitted_daate"), " - the date the data were submitted at"),
        tags$li(tags$b("Province"), " - the province the data were collected at (all 'North' for this dataset)"),
        tags$li(tags$b("District"), " - the district the data were collected at"),
        tags$li(tags$b("age_group"), " - the age group the data were collected for (0-5, 5-14, 15+, and all ages)"),
        tags$li(tags$b("cases_reported"), " - the number of cases reported for the facility/age group on the given date")
      )
      
    )
    
  )
)


```


Artık seçimlerimiz için değişkenleri kullanıcı arayüzünde kodlamak yerine nasıl ilettiğimize dikkat edin! Bu, kodumuzu da daha kompakt hale getirebilir! Son olarak, sunucuyu güncellememiz gerekecek. Yeni girdimizi dahil etmek için fonksiyonumuzu güncellemek kolay olacaktır (sadece yeni parametremize bir argüman olarak iletmemiz gerekiyor), ancak kullanıcı seçilen bölgeyi değiştirdiğinde kullanıcı arayüzünün dinamik olarak güncellenmesini istediğimizi hatırlamalıyız. Uygulama çalışırken widget'ların parametrelerini ve davranışını değiştirebileceğimizi burada anlamak önemlidir, ancak bunun sunucuda yapılması gerekir. Bunun nasıl yapılacağını öğrenmek için sunucuya çıktı almanın yeni bir yolunu anlamamız gerekiyor. 

Bunu gerçekleştiren fonksiyonlar, gözlemci fonksiyonlar olarak bilinir ve davranışları reaktif fonksiyonlara benzer. Yine de önemli bir farkları var:
• Reaktif fonksiyonlar, çıktıları doğrudan etkilemez ve sunucudaki diğer konumlarda görülebilen nesneler üretir. 
• Gözlemci fonksiyonlar, sunucu çıktılarını etkileyebilir, ancak bunu diğer fonksiyonların fonksiyonlar yan etkileri yoluyla yapar. (Başka şeyler de yapabilirler, ancak pratikte bu onların ana işlevidir)

Reaktif fonksiyonlara benzer şekilde, gözlemci fonksiyonların iki çeşidi vardır ve bunlar reaktif fonksiyonlarla aynı mantıkla sınıflandırılırlar: 

1. observe() - bu fonksiyon,  kullanılan herhangi bir girdi değiştiğinde çalışır
2. observeEvent() - bu fonksiyon, kullanıcı tarafından belirlenen bir girdi değiştiğinde çalışır

Ayrıca, widget'ları güncelleyen shiny fonksiyonlarını da anlamamız gerekir. Bunların çalıştırılması oldukça basittir - önce sunucu fonkisyonundan oturum nesnesini alırlar (bunun şimdilik anlaşılması gerekmez), ardından değiştirilecek fonksiyonun inputId'sini alırlar. Ardından, selectInput() tarafından seçilmiş olan tüm parametrelerin yeni sürümleri iletilir - bunlar widget’ta otomatik olarak güncellenecektir.

Bunu sunucumuzda nasıl kullanabileceğimize dair izole bir örneğe bakalım. Kullanıcı bölgeyi değiştirdiğinde, tesis gruplarımızı bölgeye göre filtrelemek ve seçenekleri yalnızca o bölgede mevcut olanları) yansıtacak (ve tüm tesisler için bir seçenek oluşturacak şekilde güncellemek istiyoruz. 
 


```{r, eval = FALSE}

observe({
  
  if (input$select_district == "All") {
    new_choices <- facility_list$location_name
  } else {
    new_choices <- facility_list %>%
      filter(District == input$select_district) %>%
      pull(location_name)
  }
  
  new_choices <- c("All", new_choices)
  
  updateSelectInput(session, inputId = "select_facility",
                    choices = new_choices)
  
})


```

Ve bu kadar! Bunu sunucumuza ekleyebiliriz ve bu davranış şimdi işe yarayacaktır. Yeni sunucumuz şöyle görünmelidir:

```{r, eval = FALSE}
server <- function(input, output, session) {
  
  malaria_plot <- reactive({
    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup, facility = input$select_facility)
  })
  
  
  
  observe({
    
    if (input$select_district == "All") {
      new_choices <- facility_list$location_name
    } else {
      new_choices <- facility_list %>%
        filter(District == input$select_district) %>%
        pull(location_name)
    }
    
    new_choices <- c("All", new_choices)
    
    updateSelectInput(session, inputId = "select_facility",
                      choices = new_choices)
    
  })
  
  
  output$malaria_epicurve <- renderPlot(
    malaria_plot()
  )
  
  output$download_epicurve <- downloadHandler(
    
    filename = function() {
      stringr::str_glue("malaria_epicurve_{input$select_district}.png")
    },
    
    content = function(file) {
      ggsave(file, 
             malaria_plot(),
             width = 8, height = 5, dpi = 300)
    }
    
  )
  
  
  
}

```


```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "shiny", "app_menu_view.gif"))
```







### Tabloya yeni bir sekme eklemek  {.unnumbered}

Şimdi uygulamamıza eklemek istediğimiz son bileşene geçeceğiz. Kullanıcı arayüzünü iki sekmeye ayırmak isteyeceğiz, bunlardan biri, kullanıcının salgın eğrisini oluşturdukları verileri görebileceği etkileşimli bir tabloya sahip olacak. Bunu yapmak için, sekmelerle ilgili shiny ile birlikte gelen paket dahili kullanıcı arabirimi öğelerini kullanabiliriz. Temel düzeyde, ana panelimizin çoğunu bu genel yapıya dahil edebiliriz:

```{r, eval = FALSE}


# ... kullanıcı arayüzünden geri kalan

mainPanel(
  
  tabsetPanel(
    type = "tabs",
    tabPanel(
      "Epidemic Curves",
      ...
    ),
    tabPanel(
      "Data",
      ...
    )
  )
)


```

Bunu kullanıcı arayüzümüze uygulayalım. Ayrıca burada DT paketini kullanmak isteyeceğiz - bu, önceden var olan verilerden etkileşimli tablolar oluşturmak için harika bir pakettir. Bu örnekte DT::datatableOutput() fonksiyonunun kullanıldığını görebiliriz.

```{r, echo = FALSE}
library(DT)
```

```{r, eval = FALSE}
ui <- fluidPage(
     
     titlePanel("Malaria facility visualisation app"),
     
     sidebarLayout(
          
          sidebarPanel(
               # bölge için seçici
               selectInput(
                    inputId = "select_district",
                    label = "Select district",
                    choices = all_districts,
                    selected = "All",
                    multiple = FALSE
               ),
               # yaş grubu için seçici
               selectInput(
                    inputId = "select_agegroup",
                    label = "Select age group",
                    choices = c(
                         "All ages" = "malaria_tot",
                         "0-4 yrs" = "malaria_rdt_0-4",
                         "5-14 yrs" = "malaria_rdt_5-14",
                         "15+ yrs" = "malaria_rdt_15"
                    ), 
                    selected = "All",
                    multiple = FALSE
               ),
               # kurum için seçici
               selectInput(
                    inputId = "select_facility",
                    label = "Select Facility",
                    choices = c("All", facility_list$location_name),
                    selected = "All"
               ),
               
               # dikey çizgi
               hr(),
               downloadButton(
                    outputId = "download_epicurve",
                    label = "Download plot"
               )
               
          ),
          
          mainPanel(
               tabsetPanel(
                    type = "tabs",
                    tabPanel(
                         "Epidemic Curves",
                         plotOutput("malaria_epicurve")
                    ),
                    tabPanel(
                         "Data",
                         DT::dataTableOutput("raw_data")
                    )
               ),
               br(),
               hr(),
               p("Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:"),
               tags$ul(
                    tags$li(tags$b("location_name"), " - the facility that the data were collected at"),
                    tags$li(tags$b("data_date"), " - the date the data were collected at"),
                    tags$li(tags$b("submitted_daate"), " - the date the data were submitted at"),
                    tags$li(tags$b("Province"), " - the province the data were collected at (all 'North' for this dataset)"),
                    tags$li(tags$b("District"), " - the district the data were collected at"),
                    tags$li(tags$b("age_group"), " - the age group the data were collected for (0-5, 5-14, 15+, and all ages)"),
                    tags$li(tags$b("cases_reported"), " - the number of cases reported for the facility/age group on the given date")
               )
               
               
          )
     )
)


```

Artık uygulamamız sekmeler halinde düzenlenmiştir! Sunucuda da gerekli düzenlemeleri yapalım. Veri setimizi oluşturmadan önce değiştirmemiz gerekmediğinden, sadece malaria_data veri setini DT::renderDT() aracılığıyla kullanıcı arayüzüne dönüştürüyoruz! 


```{r, eval = FALSE}
server <- function(input, output, session) {
  
  malaria_plot <- reactive({
    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup, facility = input$select_facility)
  })
  
  
  
  observe({
    
    if (input$select_district == "All") {
      new_choices <- facility_list$location_name
    } else {
      new_choices <- facility_list %>%
        filter(District == input$select_district) %>%
        pull(location_name)
    }
    
    new_choices <- c("All", new_choices)
    
    updateSelectInput(session, inputId = "select_facility",
                      choices = new_choices)
    
  })
  
  
  output$malaria_epicurve <- renderPlot(
    malaria_plot()
  )
  
  output$download_epicurve <- downloadHandler(
    
    filename = function() {
      stringr::str_glue("malaria_epicurve_{input$select_district}.png")
    },
    
    content = function(file) {
      ggsave(file, 
             malaria_plot(),
             width = 8, height = 5, dpi = 300)
    }
    
  )
  
  
  output$raw_data <- DT::renderDT(
    malaria_data
  )
  
  
}


```


```{r, out.width=c('100%', '100%'), fig.show='hold', echo = F, fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "shiny", "app_table_view.gif"))
```


## Shiny Uygulamalarının Paylaşılması 

Artık uygulamanızı geliştirdiğinize göre, muhtemelen başkalarıyla paylaşmak istersiniz - bu, ne de olsa shiny’nin esas avantajıdır! Paylaşımı doğrudan kodu paylaşarak yapabiliriz veya bir sunucuda yayınlayabiliriz. Kodu paylaşırsak, başkaları ne yaptığınızı görebilir ve üzerine inşa edebilir, ancak bu, shiny’nin esas avantajlarından birini ortadan kaldıracaktır - son kullanıcıların bir R yükleme zorunluluğunu ortadan kaldırabilir. Bu nedenle, uygulamanızı R kullanmayan kullanıcılarla paylaşıyorsanız, sunucuda yayınlanan bir uygulamayı paylaşmak çok daha kolaydır.

Kodu paylaşmayı tercih ederseniz, uygulamanın bir .zip dosyası oluşturabilir veya daha iyisi uygulamanızı github'da yayınlayabilir ve ortak çalışanlar ekleyebilirsiniz. Daha fazla bilgi için burada github ile ilgili bölüme başvurabilirsiniz.

Ancak, uygulamayı çevrimiçi yayınlıyorsak, biraz daha çalışmamız gerekiyor. Sonuç olarak, başkalarının hızlı ve kolay bir şekilde erişebilmesi için uygulamanıza bir web URL'si aracılığıyla erişilebilmesini istiyoruz. Ne yazık ki, uygulamanızı bir sunucuda yayınlamak için, bir sunucuya erişiminiz olması gerekir! Bu söz konusu olduğunda bir dizi barındırma seçeneği vardır:

• brightapps.io: Bu seçenekte shiny uygulamalarını yayınlamak için yapılandırma iş yükü düşüktür ve kısmen ücretsizdir, (ancak sınırlı lisanslara sahiptir) bu nedenle, shiny uygulamaları yayınlamak için en kolay yerdir.
• RStudio Connect: Bu seçenek, shiny uygulamalarını yayınlamak dahil birçok işlemi gerçekleştirebilen bir R sunucusunun güçlü bir sürümüdür. Bununla birlikte, kullanımı daha zordur ve ilk kez kullananlar için daha az tavsiye edilir.

Bu metnin amaçları doğrultusunda, ilk kez kullananlar için daha kolay olduğu için brightapps.io'yu kullanacağız. Başlamak için buradan ücretsiz bir hesap oluşturabilirsiniz - gerekirse sunucu lisansları için farklı fiyat seçenekleri de vardır. Ne kadar çok kullanıcıya sahip olmayı planlıyorsunuz, fiyat planınız o kadar pahalı olabilir, bu yüzden bunu göz önünde bulundurun. Küçük bir grup kişinin kullanması için bir uygulama oluşturmak istiyorsanız, ücretsiz bir lisans tamamen uygun olabilir, ancak halka açık bir uygulama daha fazla lisansa ihtiyaç duyabilir.

Öncelikle uygulamamızın bir sunucuda yayınlanmaya uygun olduğundan emin olmalıyız. Uygulamanızda, R oturumunuzu yeniden başlatmalı ve herhangi bir ekstra kod çalıştırmadan çalıştığından emin olmalısınız. Bu önemlidir, çünkü paket yükleme gerektiren bir uygulama veya uygulama kodunuzda tanımlanmayan veri olması durumunda sunucuda çalışmayacaktır. Ayrıca, uygulamanızda herhangi bir açık dosya yoluna sahip olamayacağınızı unutmayın - bunlar sunucu ayarında geçersiz olacaktır - buradaki paketi kullanmak bu sorunu çok iyi çözer. Son olarak, kuruluşunuzun sunucuları gibi kullanıcı kimlik doğrulaması gerektiren bir kaynaktan veri okuyorsanız, bu genellikle bir sunucuda çalışmaz. Shiny sunucusunu beyaz listeye nasıl ekleyeceğinizi öğrenmek için bilgi işlem departmanınızla bağlantı kurmanız gerekecek.

Hesabınızı aldıktan sonra, Hesaplar altındaki belirteçler (tokens) sayfasına gidebilirsiniz. Burada yeni bir belirteç eklemek isteyeceksiniz – bu belirteç, uygulamanızı dağıtmak için kullanılacaktır.
Buradan, hesabınızın url'sinin uygulamanızın adını yansıtacağını unutmamalısınız - bu nedenle uygulamanızın adı my_app ise, url xxx.io/my_app/ olarak eklenecektir. Uygulamanızın adını akıllıca seçin! Artık hazır olduğunuza göre, dağıt'a (deploy) tıklayın - başarılı olursa, bu uygulamanızı seçtiğiniz web url'sinde çalıştıracaktır!

*belgelerde uygulama yapma konusunda ek bir şey var mı?*

## İleri okuma

Şimdiye kadar, shiny’nin birçok yönünü ele aldık ancak tüm bilgiler göz önünde bulundurulursa shiny’yi ancak yüzeyel olarak gözden geçirdik. Bu kılavuz bir giriş niteliğinde olsa da, shiny’yi tam olarak anlamak için öğrenilecek daha çok şey var. Uygulamalar oluşturmaya başlamalı ve giderek daha fazla işlevsellik eklemelisiniz. 

## Önerilen shiny uzantıları

Aşağıdakiler, shiny’den çok daha fazlasını elde etmenize yardımcı olabilecek yüksek kalitede shiny uzantıların bir seçimini temsil etmektedir. Bu uzantılar belirli bir sırada değildir: 

• brightWidgets - bu paket size uygulamanızda kullanabileceğiniz çok daha fazla widget sunar. Bu pakette mevcut widgetların bir seçimini görmek için shinyWidgets::shinyWidgetsGallery()'yi çalıştırın. [buradaki](https://github.com/dreamRs/shinyWidgets) örneklere bakabilirsiniz. 


• shinyjs – bu uzantı, kullanıcıya bir dizi javascript aracılığıyla shiny’ye büyük ölçüde genişletme yeteneği veren mükemmel bir pakettir. Bu paketin uygulamaları çok basitten son derece gelişmişe kadar değişir, ancak ilk önce kullanıcı arabirimini öğeleri gizleme/gösterme veya düğmeleri etkinleştirme/devre dışı bırakma gibi basit yollarla değiştirmek için kullanmak isteyebilirsiniz. Daha fazlasını buradan öğrenin:


• shinydashboard - bu paket, shiny’de kullanılabilecek mevcut kullanıcı arayüzünü büyük ölçüde genişletir ve özellikle kullanıcının çeşitli karmaşık düzenlerle karmaşık bir panel oluşturmasına izin verir. Burada daha fazlasını görün:


• shinydashboardPlus - shinydashboard çerçevesinden daha da fazla özellik elde edin! Burada daha fazlasını görün:

• shinythemes - çok çeşitli önceden ayarlanmış şablonlarla shiny uygulamanız için varsayılan css temasını değiştirin! Burada daha fazlasını görün:

Shiny uyumlu etkileşimli çıktılar oluşturmak için kullanılabilecek bir dizi paket de vardır.
• DT, temel shiny’ye yarı entegredir, ancak etkileşimli tablolar oluşturmak için harika bir dizi fonksiyon sağlar.
• plotly, kullanıcının uygulamada değiştirebileceği etkileşimli grafikler oluşturmaya yönelik bir pakettir. Ayrıca plotly::ggplotly() yoluyla grafiğinizi etkileşimli sürümlere dönüştürebilirsiniz! Alternatif olarak, dygraphs ve highcharter da mükemmeldir. 

- **shinyWidgets** - this package gives you many many more widgets that can be used in your app. Run `shinyWidgets::shinyWidgetsGallery()` to see a selection of available widgets with this package. See examples   

- **shinyjs** - bu uzantı, kullanıcıya bir dizi javascript aracılığıyla shiny’ye büyük ölçüde genişletme yeteneği veren mükemmel bir pakettir. Bu paketin uygulamaları çok basitten son derece gelişmişe kadar değişir, ancak ilk önce kullanıcı arabirimini öğeleri gizleme/gösterme veya düğmeleri etkinleştirme/devre dışı bırakma gibi basit yollarla değiştirmek için kullanmak isteyebilirsiniz. Daha fazlasını [buradan](https://deanattali.com/shinyjs/basic) öğrenin.

- **shinydashboard** - bu paket, shiny’de kullanılabilecek mevcut kullanıcı arayüzünü büyük ölçüde genişletir ve özellikle kullanıcının çeşitli karmaşık düzenlerle karmaşık bir panel oluşturmasına izin verir. [Burada](https://rstudio.github.io/shinydashboard/) daha fazlasını görün

- **shinydashboardPlus** - shinydashboard çerçevesinden daha da fazla özellik elde edin! [Burada](https://rinterface.github.io/shinydashboardPlus/articles/shinydashboardPlus.html) daha fazlasını görün.

- **shinythemes** - çok çeşitli önceden ayarlanmış şablonlarla shiny uygulamanız için varsayılan css temasını değiştirin! [Burada](https://rstudio.github.io/shinythemes/) daha fazlasını görün.



Shiny uyumlu etkileşimli çıktılar oluşturmak için kullanılabilecek bir dizi paket de vardır.
• **DT**, temel shiny’ye yarı entegredir, ancak etkileşimli tablolar oluşturmak için harika bir dizi fonksiyon sağlar.
• **plotly**, kullanıcının uygulamada değiştirebileceği etkileşimli grafikler oluşturmaya yönelik bir pakettir. Ayrıca plotly::ggplotly() yoluyla grafiğinizi etkileşimli sürümlere dönüştürebilirsiniz! Alternatif olarak, **dygraphs** ve **highcharter** da mükemmeldir. 




```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/shiny_basics.Rmd-->

# (PART) Miscellaneous {.unnumbered}
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/cat_misc.Rmd-->

# Yazma fonksiyonları

## Hazırlık

### Paketleri yüklemek {.unnumbered}

Bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran *ve* kullanım için yükleyen **pacman**'dan `p_load()` vurgusu yapıyoruz. R **tabanı**ndan `library()` ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakabilirsiniz.

```{r, echo=F, warning=F, message=F}
pacman::p_load(
  rio,          # Dosyayı içe aktar
  here,         # Dosyayı konumla
  skimr,        # veriye genel bakış
  tidyverse,    # veri yönetimi + ggplot2 grafikleri 
  gtsummary,    # özet istatistikler ve testler
  janitor,      # toplamları ve yüzdeleri tabloya ekleme
  scales,       # oranları kolaylıkla yüzdeye çevirme 
  flextable,    # tabloları HTML'ye çevirme
  purrr,        # fonksiyonel programlamayı kolaylaştırır
  readr,        # csv dosyalarını okumak için
  highcharter   # highchart nesnesi oluşturmak ve belirli bir grafiği çizmek için

  )
```

### Verileri içe aktar {.unnumbered}

Simüle edilmiş bir Ebola salgınından vakaların veri setini içe aktarıyoruz. Adım adım izlenecek verileri indirmek istiyorsanız, [Kitap ve verileri indir] sayfasındaki talimatlara bakın. Veri kümesi, **rio** paketinden `import()` fonksiyonuyla kullanılarak içe aktarılır. Verileri içe aktarmanın çeşitli yolları için [İçe ve dışa aktar] hakkındaki sayfaya bakabilirsiniz.

Ayrıca bu sayfanın son bölümünde 2013'ten itibaren H7N9 gribiyle ilgili bazı verileri kullanacağız.

```{r, echo=F}
# satırlistesini R içine aktar
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

flu_china <- rio::import(here::here("data", "case_linelists", "fluH7N9_China_2013.csv"))

```

## Fonksiyonlar

Fonksiyonlar, kodların daha kolay anlaşılmasını, bir şekilde daha kısa olmasını ve hataya daha az meyilli olmasını sağladıklarından (fonksiyonun kendisinde herhangi bir hata olmadığı göz önüne alındığında) programlamada faydalıdır.

Bu el kitabında bu kadar ileri gittiyseniz, R'da her işlem bir fonksiyon çağrısı olduğundan sonsuz fonksiyonlarla karşılaşmışsınız demektir. `+, for, if, [, $, { …`. Örneğin, "x + y", "+"(x, y)" ile aynıdır

R, fonksiyonlarla en fazla çalışma olanağı sunan ve kullanıcıya bunları kolayca yazabilmesi için yeterli araçları sağlayan dillerden biridir. Fonksiyonları programlama zincirinin en üstünde veya sonunda sabit olarak düşünmemeliyiz, R onları vektörlermiş gibi kullanma ve hatta başka fonksiyonlar, listeler vb. içinde kullanma imkanı sunar.

Fonksiyonel programlama üzerine çok sayıda gelişmiş kaynak mevcuttur ve biz burada yalnızca kısa pratik örneklerle fonksiyonel programlamaya başlamanıza yardımcı olacak bir fikir vereceğiz. Daha sonra bu konuda daha fazla okumak için referanslardaki bağlantıları ziyaret etmeniz önerilir.

## Neden bir fonksiyon kullanırsın?

Bu soruyu yanıtlamadan önce, bu el kitabının [Yineleme, döngüler ve listeler] sayfasındaki ilk R fonksiyonunuzu yazmak için ipuçlarına zaten sahip olduğunuzu belirtmek önemlidir. Aslında, "if/else" ve döngülerin kullanımı, genellikle birden fazla koşula izin vererek kodumuzun uygulamasını genişletmeye veya görevleri tekrarlamak için kodları yinelemeye kolayca yardımcı olduklarından, çoğu fonksiyonumuzun temel bir parçasıdır.

-   Farklı bir değişkene veya verilere uygulamak için aynı kod bloğunu birden çok kez mi tekrarlıyorum?

-   Ondan kurtulmak, genel kodumu önemli ölçüde kısaltır ve daha hızlı çalışmasını sağlar mı?

-   Yazdığım kodun tekrar kullanılması ancak kodun birçok yerinde farklı bir değerle kullanılması mümkün müdür?

Önceki sorulardan birinin cevabı "EVET" ise, muhtemelen bir fonksiyon yazmanız gerekir.

## R, fonksiyonları nasıl oluşturur?

R'daki fonksiyonların üç ana bileşeni vardır:

-   fonksiyonu nasıl çağırabileceğimizi kontrol eden değişkenlerin listesi olan `formals()`

-   fonksiyonun içindeki kod olan `body()`, yani nasıl yazdığımıza bağlı olarak parantez içinde veya devamında

ve,

-   fonksiyonun değişkenlerini bulmaya yardımcı olacak ve fonksiyonun nasıl değer bulacağını belirleyen `environment()`.

Fonksiyonunuzu oluşturduktan sonra, ilişkili fonksiyonu çağırarak bu bileşenlerin her birini doğrulayabilirsiniz.

## Temel sözdizimi ve yapı

-   Bir fonksiyonun adını okuduğumuz anda işinin kolayca anlaşılması için düzgün bir şekilde adlandırılması gerekir. Aslında bu, temel R mimarisinin çoğunda zaten böyledir. 'mean()', 'print()', 'summary()' gibi fonksiyonların çok basit adları vardır.

-   Bir fonksiyon, üzerinde çalışılacak veriler ve diğer seçenekler arasında statik değerler olabilen diğer nesneler gibi bağımsız değişkenlere ihtiyaç duyacaktır.

-   Ve son olarak bir fonksiyon, temel görevine ve kendisine verilen değişkenlere dayalı olarak bir çıktı verecektir. Genellikle çıktıyı üretmek için yerleşik fonksiyonları `print()`, `return()`... olarak kullanırız. Çıktı, mantıksal bir değer, bir sayı, bir karakter, bir veri çerçevesi... kısacası herhangi bir R nesnesi olabilir.

Temel olarak bu, bir fonksiyonun bileşimidir:

```{r, eval=FALSE}

function_name <- function(argument_1, argument_2, argument_3){
  
           function_task
  
           return(output)
}


```

`contain_covid19()` olarak adlandırılacak ilk fonksiyonumuzu oluşturabiliriz.

```{r}

contain_covid19 <- function(barrier_gest, wear_mask, get_vaccine){
  
                            if(barrier_gest == "yes" & wear_mask == "yes" & get_vaccine == "yes" ) 
       
                            return("success")
  
  else("please make sure all are yes, this pandemic has to end!")
}


```

Daha sonra yeni oluşturulan fonksiyonumuzun bileşenlerini doğrulayabiliriz.

```{r}

formals(contain_covid19)
body(contain_covid19)
environment(contain_covid19)

```

Şimdi fonksiyonumuzu test edeceğiz. Yazılı fonksiyonumuzu çağırmak için, onu tüm R fonksiyonlarını kullandığınız gibi, yani fonksiyon adını yazıp gerekli değişkenleri ekleyerek kullanabilirsiniz.

```{r}

contain_covid19(barrier_gest = "yes", wear_mask = "yes", get_vaccine = "yes")

```

Önlem amaçlı olarak her bir değişkenin adını tekrar yazabiliriz. Ancak bunları belirtmeden kod çalışmalıdır çünkü R bellekte her değişkenin konumu vardır. Değişkenlerin değerlerini doğru sıraya koyduğun sürece, fonksiyonları çağırırken değişken isimlerini yazmayı atlayabilirsiniz.

```{r}

contain_covid19("yes", "yes", "yes")

```

O zaman değerlerden biri `"hayır"` veya `"evet"` **değil** ise ne olduğuna bakalım.

```{r}

contain_covid19(barrier_gest = "yes", wear_mask = "yes", get_vaccine = "no")
```

Tanınmayan bir değişken sağlarsak bir hata alırız:

```{r, eval=F}
contain_covid19(barrier_gest = "sometimes", wear_mask = "yes", get_vaccine = "no")
```

`Error in contain_covid19(barrier_gest = "sometimes", wear_mask = "yes",  :    "contain_covid19"` fonksiyonu bulunamadı

[***NOT:*** Bazı fonksiyonlar(çoğu zaman çok kısa ve anlaşılır) bir ada ihtiyaç duymayabilir ve hızlı görev yapmak için doğrudan bir kod satırında veya başka bir fonksiyonun içinde kullanılabilir. Bunlara **anonim fonksiyonlar** denir.]{style="color: black;"}

Örneğin, aşağıdaki veri kümesinde yalnızca karakter değişkenlerini tutan ilk anonim fonksiyondur.

```{r, eval=F}
linelist %>% 
  dplyr::slice_head(n=10) %>%  #R tabanı "head" fonksiyonuna eşdeğerdir ve bu, veri kümesinin ilk n gözlemini döndürür
  select(function(x) is.character(x)) 
```

```{r, echo=F}
linelist %>% 
  dplyr::slice_head(n=10) %>%  #R tabanı "head" fonksiyonuna eşdeğerdir ve bu, veri kümesinin ilk n gözlemini döndürür
  select(function(x) is.character(x)) %>%  
DT::datatable(rownames = FALSE, filter="top", options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )
```

Daha sonra, veri setimizin her ikinci gözlemini seçen başka bir fonksiyon (örneğin, tarihe veya ziyarete göre sıralandıktan sonra hasta başına çok sayıda kayıt içeren boylamsal verilerimiz olduğunda alakalı olabilir). Bu durumda, dplyr dışına yazan uygun fonksiyon, tüm satır numaralarını içeren vektöre uygulanacak `function (x) (x%%2 == 0)` olacaktır.

```{r, eval=F}
linelist %>%   
   slice_head(n=20) %>% 
   tibble::rownames_to_column() %>% # son seçimi net bir şekilde görmek için her bir gözlemin indekslerini satır isimleri olarak ekleyin
   filter(row_number() %%2 == 0)
```

```{r, echo=F}
linelist %>%   
   slice_head(n=20) %>% 
   tibble::rownames_to_column() %>%    # son seçimi net bir şekilde görmek için her bir gözlemin indekslerini satır isimleri olarak ekleyin
   filter(row_number() %%2 == 0) %>% 
DT::datatable(rownames = FALSE, filter="top", options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )

```

Aynı görev için olası bir temel R kodu şöyle olacaktır:

```{r, eval = F}

linelist_firstobs <- head(linelist, 20)

linelist_firstobs[base::Filter(function(x) (x%%2 == 0), seq(nrow(linelist_firstobs))),]
```

```{r, echo=F}

linelist_firstobs <- head(linelist, 20)

linelist_firstobs[base::Filter(function(x) (x%%2 == 0), seq(nrow(linelist_firstobs))),] %>% 
DT::datatable(rownames = FALSE, filter="top", options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )

```

[***UYARI:*** Fonksiyonları kullanmanın kodumuzda bize yardımcı olabileceği doğru olsa da, bazı fonksiyonları yazmak, iyice düşünülmemiş, yeterince yazılmamış ve sonuç olarak hatalar döndürüyorsa, o fonksiyonu düzeltmek zaman alıcı olabilir. Bu nedenle genellikle önce R kodunun yazılması, yapmak istediğimizi yaptığından emin olunması ve ardından yukarıda listelendiği gibi üç ana bileşeni ile bir fonksiyona dönüştürülmesi önerilir.]{style="color: orange;"}

## Örnekler

### Birkaç sütun için orantı tablolarını döndürmek {.unnumbered}

Evet, zaten birçok pakette bilgileri çok kolay ve güzel bir şekilde özetlememizi sağlayan güzel fonksiyonlarımız var. Ama yine de yazma fonksiyonlarına alışmak için ilk adımlarımızda kendimizinkini yapmaya çalışacağız.

Bu örnekte, basit bir fonksiyon yazmanın, aynı kodu defalarca kopyalayıp yapıştırmanızı nasıl önleyeceğini göstermek istiyoruz.

```{r}

proptab_multiple <- function(my_data, var_to_tab){
  
  #tablolamayı yapmadan önce ilgilenilen her değişkenin adını yazdırın
  print(var_to_tab)

  with(my_data,
       rbind( #aşağıdaki iki fonksiyonun sonuçlarını satıra bağla
        #ilgilenilen değişkeni tablo haline getirin: sadece sayıları verir
          table(my_data[[var_to_tab]], useNA = "no"),
          #ilgilenilen her değişken için oranları hesaplayın ve değeri 2 ondalık basamağa yuvarlayın
         round(prop.table(table(my_data[[var_to_tab]]))*100,2)
         )
       )
}


proptab_multiple(linelist, "gender")

proptab_multiple(linelist, "age_cat")

proptab_multiple(linelist, "outcome")


```

[***İPUCU:*** Yukarıda gösterildiği gibi, genel programlama için yaptığınız fonksiyonlarınızı yorumlamanız çok önemlidir. Bir fonksiyonun amacının bir kodu okunmaya hazır, daha kısa ve daha verimli hale getirmek olduğunu unutmayın. O zaman sadece adını okuyarak fonksiyonun ne yaptığını anlayabilmeli ve yorumları okuyarak daha fazla ayrıntıya sahip olmalıyız.]{style="color: darkgreen;"}

İkinci bir seçenek, işlemi bir kerede yapmak için bu fonksiyonu bir döngü aracılığıyla başka bir fonksiyonda kullanmaktır:

```{r}


for(var_to_tab in c("gender","age_cat",  "outcome")){
  
  print(proptab_multiple(linelist, var_to_tab))
  
}

```

Daha basit bir yol, aşağıda ifade edildiği gibi "for loop" yerine R "apply" tabanını kullanmak olabilir:

```{r, include= FALSE, eval=FALSE}

base::lapply(linelist[,c("gender","age_cat", "outcome")], table)

```

[***İPUCU:***R genellikle işlevsel bir programlama dili olarak tanımlanır ve neredeyse her zaman bir kod satırı çalıştırdığınızda bazı yerleşik fonksiyonları kullanırsınız. Yazma fonksiyonları konusunda daha rahat olmak için iyi bir alışkanlık, günlük olarak kullandığınız temel fonksiyonların nasıl oluşturulduğunu sık sık içsel olarak incelemektir. Bunu yapmanın kısayolu, fonksiyonun adını seçmek ve ardından `Ctrl+F2` veya `fn+F2` veya `Cmd+F2` (bilgisayarınıza bağlı olarak) üzerine tıklamaktır.]{style="color: darkgreen;"}

## **purrr** kullanımı: yinelemeli olarak uygulanabilen yazma fonksiyonları

### Bir veri kümesindeki birden çok sütunun sınıfını değiştirin {.unnumbered}

Orijinal 'satır listesi' verilerindeki birçok karakter değişkeninin analiz ve çizim amaçları için "faktör" olarak değiştirilmesi gerektiğini varsayalım. Adımı birkaç kez tekrarlamak yerine, ilgili tüm değişkenlerin dönüşümünü tek bir kod satırında yapmak için sadece `lapply()` kullanabiliriz.

[***UYARI:*** `lapply()` bir liste döndürür, bu nedenle kullanımı son adım olarak ek bir değişiklik gerektirebilir.]{style="color: orange;"}

```{r, include=FALSE}

linelist_factor1 <- linelist %>%
      lapply(
          function(x) if(is.character(x)) as.factor(x) else x) %>%
      as.data.frame() %>% 
      glimpse()

```

Aynı adım, **purrr** paketindeki `map_if()` fonksiyonu kullanılarak da yapılabilir.

```{r}

linelist_factor2 <- linelist %>%
  purrr::map_if(is.character, as.factor)


linelist_factor2 %>%
        glimpse()

```

### Değişkeninin farklı seviyeleri için yinelemeli olarak grafikler üretin {.unnumbered}

Her eyalet için H7N9 salgını sırasında Çin'de hastaların sonucunun dağılımına bakmak için burada pasta grafiği üreteceğiz. Her biri için kodu tekrarlamak yerine sadece oluşturacağımız bir fonksiyonu uygulayacağız.

```{r}

#highchart kullanımı için kusursuz seçenekler
options(highcharter.theme =   highcharter::hc_theme_smpl(tooltip = list(valueDecimals = 2)))


#"chart_outcome_province" adında, veri kümesini ve sonucun dağılımını çizeceği ilin adını değişken olarak alan bir fonksiyon oluşturun.

chart_outcome_province <- function(data_used, prov){
  
  tab_prov <- data_used %>% 
    filter(province == prov,
           !is.na(outcome))%>% 
    group_by(outcome) %>% 
    count() %>%
    adorn_totals(where = "row") %>% 
    adorn_percentages(denominator = "col", )%>%
    mutate(
        perc_outcome= round(n*100,2))
  
  
  tab_prov %>%
    filter(outcome != "Total") %>% 
  highcharter::hchart(
    "pie", hcaes(x = outcome, y = perc_outcome),
    name = paste0("Distibution of the outcome in:", prov)
    )
  
}

chart_outcome_province(flu_china, "Shanghai")
chart_outcome_province(flu_china,"Zhejiang")
chart_outcome_province(flu_china,"Jiangsu")


```

### Bir değişkenin farklı seviyeleri için yinelemeli olarak tablolar üretin {.unnumbered}

Burada bir tablo halinde özetlemek için üç gösterge oluşturacağız ve bu tabloyu her il için üretmek istiyoruz. Göstergelerimiz, başlangıç ile hastaneye yatış arasındaki gecikme, iyileşme yüzdesi ve vakaların medyan yaşıdır.

```{r}


indic_1 <- flu_china %>% 
  group_by(province) %>% 
  mutate(
    date_hosp= strptime(date_of_hospitalisation, format = "%m/%d/%Y"),
    date_ons= strptime(date_of_onset, format = "%m/%d/%Y"), 
    delay_onset_hosp= as.numeric(date_hosp - date_ons)/86400,
    mean_delay_onset_hosp = round(mean(delay_onset_hosp, na.rm=TRUE ), 0)) %>%
  select(province, mean_delay_onset_hosp)  %>% 
  distinct()
     

indic_2 <-  flu_china %>% 
            filter(!is.na(outcome)) %>% 
            group_by(province, outcome) %>% 
            count() %>%
            pivot_wider(names_from = outcome, values_from = n) %>% 
    adorn_totals(where = "col") %>% 
    mutate(
        perc_recovery= round((Recover/Total)*100,2))%>% 
  select(province, perc_recovery)
    
    
    
indic_3 <-  flu_china %>% 
            group_by(province) %>% 
            mutate(
                    median_age_cases = median(as.numeric(age), na.rm = TRUE)
            ) %>% 
  select(province, median_age_cases)  %>% 
  distinct()

#üç gösterge veri kümesine katılın

table_indic_all <- indic_1 %>% 
  dplyr::left_join(indic_2, by = "province") %>% 
        left_join(indic_3, by = "province")


#göstergeleri esnek bir tabloda yazdırın


print_indic_prov <-  function(table_used, prov){
  
  #önce yazdırma kolaylığı için veri çerçevesini biraz dönüştürün
  indic_prov <- table_used %>%
    filter(province==prov) %>%
    pivot_longer(names_to = "Indicateurs", cols = 2:4) %>% 
   mutate( indic_label = factor(Indicateurs,
   levels= c("mean_delay_onset_hosp","perc_recovery","median_age_cases"),
   labels=c("Mean delay onset-hosp","Percentage of recovery", "Median age of the cases"))
   ) %>% 
    ungroup(province) %>% 
    select(indic_label, value)
  

    tab_print <- flextable(indic_prov)  %>%
    theme_vanilla() %>% 
    flextable::fontsize(part = "body", size = 10) 
    
    
     tab_print <- tab_print %>% 
                  autofit()   %>%
                  set_header_labels( 
                indic_label= "Indicateurs", value= "Estimation") %>%
    flextable::bg( bg = "darkblue", part = "header") %>%
    flextable::bold(part = "header") %>%
    flextable::color(color = "white", part = "header") %>% 
    add_header_lines(values = paste0("Indicateurs pour la province de: ", prov)) %>% 
bold(part = "header")
 
 tab_print <- set_formatter_type(tab_print,
   fmt_double = "%.2f",
   na_str = "-")

tab_print 
    
}




print_indic_prov(table_indic_all, "Shanghai")
print_indic_prov(table_indic_all, "Jiangsu")


```

## İyi işleyen fonksiyonlar için ipuçları ve en iyi Uygulamalar

Fonksiyonel programlama, kodu kolaylaştırmak içindir ve okunmasını kolaylaştırır. Aşağıdaki ipuçları, temiz bir koda ve okunması kolay bir koda sahip olmanıza yardımcı olacaktır.

### Adlandırma ve sözdizimi {.unnumbered}

-   Ortamınızda zaten mevcut olan diğer fonksiyonlar tarafından kolayca alınmış olabilecek karakterleri kullanmaktan kaçının

-   Fonksiyon adının başka bir okuyucu için kısa ve anlaşılır olması önerilir.

-   Fonksiyon adı olarak fiiller, değişken adları için isimler kullanılması tercih edilir.

### Sütun adları ve düzenli değerlendirme {.unnumbered}

Değişken olarak kodunuza sağlanan *sütun adlarına* nasıl başvuracağınızı öğrenmek istiyorsanız, bu [tidyverse programlama kılavuzunu](https://dplyr.tidyverse.org/articles/programming.html) okuyabilirsiniz. Kapsanan konular arasında *tidy evaluation* ve *embrace* `{{ }}` "çift ayraç" kullanımı yer alır.

Örneğin, hemen yukarıda bahsedilen sayfa eğitiminden hızlı bir iskelet şablon kodu:

```{r, eval=F}

var_summary <- function(data, var) {
  data %>%
    summarise(n = n(), min = min({{ var }}), max = max({{ var }}))
}
mtcars %>% 
  group_by(cyl) %>% 
  var_summary(mpg)

```

### Test ve Hata işleme {.unnumbered}

Bir fonksiyonun görevi ne kadar karmaşıksa, hata olasılığı da o kadar yüksek olur. Bu nedenle, bazen hatanın nereden geldiğini hızlı bir şekilde anlamaya ve düzeltmenin bir yolunu bulmaya yardımcı olmak için fonksiyona bazı doğrulamalar eklemek gerekir.

-   `eksik(değişken)` kullanarak bir değişkenin eksikliğini kontrol etmek şiddetle tavsiye edilmektedir. Bu basit kontrol, "DOĞRU" veya "YANLIŞ" değerini döndürebilir.

```{r , error=TRUE}

contain_covid19_missing <- function(barrier_gest, wear_mask, get_vaccine){
  
  if (missing(barrier_gest)) (print("please provide arg1"))
  if (missing(wear_mask)) print("please provide arg2")
  if (missing(get_vaccine)) print("please provide arg3")


  if (!barrier_gest == "yes" | wear_mask =="yes" | get_vaccine == "yes" ) 
       
       return ("you can do better")
  
  else("please make sure all are yes, this pandemic has to end!")
}


contain_covid19_missing(get_vaccine = "yes")

```

-   Daha fazla algılanabilir hata için `stop()` kullanın.

```{r, error=TRUE}

contain_covid19_stop <- function(barrier_gest, wear_mask, get_vaccine){
  
  if(!is.character(barrier_gest)) (stop("arg1 should be a character, please enter the value with `yes`, `no` or `sometimes"))
  
  if (barrier_gest == "yes" & wear_mask =="yes" & get_vaccine == "yes" ) 
       
       return ("success")
  
  else("please make sure all are yes, this pandemic has to end!")
}


contain_covid19_stop(barrier_gest=1, wear_mask="yes", get_vaccine = "no")

```

-   Yerleşik fonksiyonların çoğunu çalıştırdığımızda gördüğümüz gibi, belirli koşullarda açılabilen mesajlar ve uyarılar vardır. Bunları yazılı fonksiyonlarımıza `message()` ve `warning()` fonksiyonlarını kullanarak entegre edebiliriz.

-   Bir fonksiyonu değişken olarak alan ve onu güvenli bir şekilde yürüten `safely()` kullanarak da hataları halledebiliriz. Aslında, bir hatayla karşılaşırsa fonksiyon durmadan yürütülür. `safely()` çıktı olarak, sonuçlar ve "atladığı" hata olan iki nesne içeren bir **liste** döndürür.

Önce `mean()` fonksiyonunu fonksiyon olarak çalıştırıp sonra `safely()` ile çalıştırarak doğrulayabiliriz.

```{r, warning=FALSE}

map(linelist, mean)
```

```{r, warning=FALSE}
safe_mean <- safely(mean)
linelist %>% 
  map(safe_mean)

```

Daha önce de belirtildiği gibi, kodlarımızı iyi yorumlamak, çalışmalarımızda dokümantasyona sahip olmak için zaten iyi bir yoldur.

<!-- ======================================================= -->

## Kaynaklar

[Veri Bilimi için R](https://r4ds.had.co.nz/functions.html)

[İleri R Programlama Pratik Kılavuzu](https://www.rstudio.com/wp-content/uploads/2016/02/advancedR.pdf)

[purr Paket Pratik Kılavuzu](https://purrr.tidyverse.org/)

[Hadley Wickham'dan Video-ACM konuşması: Fonksiyonel programlamanın keyfi (map_dbl nasıl çalışır?)](https://youtube.videoken.com/embed/bzUmK0Y07ck)
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/writing_functions.Rmd-->


# Dizin etkileşimleri { }

Bu sayfada, dizinler (klasörler) oluşturduğunuz, etkileşimde bulunduğunuz, kaydettiğiniz ve içe aktardığınız genel senaryoları ele alıyoruz.


## Hazırlık

### **fs** paketi {.unnumbered}

**fs** paketi, dizin etkileşimlerini kolaylaştıran ve bazı R **tabanı** fonksiyonlarını geliştiren bir **tidyverse** paketidir. Aşağıdaki bölümlerde genellikle **fs**'den gelen fonksiyonları kullanacağız.

```{r}
pacman::p_load(
  fs,             # dosya/dizin etkileşimleri
  rio,            # içe aktar/dışa aktar
  here,           # göreceli dosya yolakları
  tidyverse)      # veri yönetimi ve görselleştirme
```


### Dizini bir dendrogram ağacı olarak yazdır {.unnumbered}

**fs**'den `dir_tree()` fonksiyonunu kullanın.

Klasör dosya yolunu `path =` olarak sağlayın ve yalnızca bir seviyeyi mi (`recurse = FALSE`) yoksa tüm alt seviyelerdeki tüm dosyaları mı (`recurse = TRUE`) göstermek istediğinize karar verin. Aşağıda, R projesi için kısayol olarak `here()` kullanıyoruz ve bu R el kitabı için kullanılan tüm verileri içeren alt klasör "verilerini" belirledik. "veri" ve alt klasörlerindeki (örneğin "önbellek", "salgın modelleri", "nüfus", "shp" ve "hava durumu") içindeki tüm dosyaları gösterecek şekilde ayarladık.


```{r}
fs::dir_tree(path = here("data"), recurse = TRUE)
```


## Bir dizindeki dosyaları listeleyin

Bir dizindeki yalnızca dosya adlarını listelemek için R **tabanı**ndan `dir()` kullanabilirsiniz. Örneğin, bu komut, içindeki "data" klasörünün "population" alt klasöründeki dosyaların adlarını listeler. Göreli dosya yolu, 'here()' kullanılarak sağlanır (bunun hakkında daha fazla bilgiyi [İçe aktarma ve dışa aktarma] sayfasında okuyabilirsiniz).

```{r}
# dosya adları
dir(here("data", "gis", "population"))
```

Dizin dosyalarının tam dosya yollarını listelemek için **fs**'den `dir_ls()` kullanabilirsiniz. Bir diğer R alternatifi "list.files()"dir.

```{r}
# dosya yolları
dir_ls(here("data", "gis", "population"))
```

Bir dizindeki her dosyayla ilgili tüm meta veri bilgilerini almak için (ör. yol, değişiklik tarihi vb.), **fs**'den `dir_info()` kullanabilirsiniz.

Bu, örneğin dosyanın en son sürümünü içe aktarmak istediğinizde, dosyanın son değişiklik zamanını çıkarmak istiyorsanız özellikle yararlı olabilir. Bunun bir örneği için [İçe ve dışa aktar] sayfasına bakın.   

```{r, eval=F}
# dosya bilgisi
dir_info(here("data", "gis", "population"))
```

İşte döndürülen veri çerçevesi. Tüm sütunları görmek için sağa kaydırın.

```{r, echo=F}
DT::datatable(dir_info(here("data", "gis", "population")), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

## Dosya bilgisi

Belirli bir dosya hakkında meta veri bilgilerini çıkarmak için, **fs**'den `file_info()` (veya R **tabanı**ndan `file.info()`) kullanabilirsiniz.  

```{r, eval=F}
file_info(here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, echo=F}
DT::datatable(file_info(here("data", "case_linelists", "linelist_cleaned.rds")), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Burada sonucu dizine eklemek ve yalnızca "modification_time" değerini döndürmek için `$` kullanıyoruz.

```{r}
file_info(here("data", "case_linelists", "linelist_cleaned.rds"))$modification_time
```



## Var olup olmadığını kontrol edin

### R nesneleri {.unnumbered}

Bir R nesnesinin * R içinde * olup olmadığını kontrol etmek için  'exists()' kullanabilirsiniz (nesne adını tırnak içinde sağlayın).  

```{r}
exists("linelist")
```

Bazı R **tabanı** paketlerinin, sahne arkasında "data" gibi genel nesne adları kullandığını ve "inherit= YANLIŞ" belirtilmediği sürece DOĞRU olarak görüneceğini unutmayın. Bu, veri kümenizi "data" olarak adlandırmamanın bir nedenidir.

```{r}
exists("data")
exists("data", inherit = FALSE)
```

Bir fonksiyon yazıyorsanız, bir değişken olup olmadığını kontrol etmek için 'exists()' yerine 'missing()' kullanmalısınız.

### Dizinler {.unnumbered}

Bir dizinin var olup olmadığını kontrol etmek için, **fs**'den `is_dir()` dizinine dosya yolunu (ve dosya adını) sağlayın. "TRUE" yazısının yazdırıldığını görmek için sağa kaydırın.

```{r}
is_dir(here("data"))
```

Alternatif olarak `file.exists()` kullanılabilir.


### Dosyalar {.unnumbered}

Belirli bir dosyanın var olup olmadığını kontrol etmek için **fs**'den `is_file()` kullanın. "TRUE" yazısının yazdırıldığını görmek için sağa kaydırın.

```{r}
is_file(here("data", "case_linelists", "linelist_cleaned.rds"))
```

Alternatif olarak `file.exists()` kullanılabilir.



## Oluşturmak

### Dizinler {.unnumbered}

Yeni bir dizin (klasör) oluşturmak için **fs**'den `dir_create()` kullanabilirsiniz. Dizin zaten mevcutsa, üzerine yazılmaz ve hiçbir hata döndürülmez.

```{r, eval=F}
dir_create(here("data", "test"))
```

Bir alternatif, dizin zaten mevcutsa bir hata gösterecek olan `dir.create()`dir. Buna karşılık, bu senaryoda `dir_create()` sessiz olacaktır.

### Dosyalar {.unnumbered}

**fs**'den `file_create()` ile (boş) bir dosya oluşturabilirsiniz. Dosya zaten mevcutsa, üzerine yazılmaz veya değiştirilmez.

```{r, eval=F}
file_create(here("data", "test.rds"))
```

Alternatifi `file.create()`. Ancak dosya zaten mevcutsa, bu seçenek dosyayı kesecektir. `file_create()` kullanırsanız, dosya değişmeden kalacaktır.


### Yoksa oluştur {.unnumbered}

YAPIM AŞAMASINDA...


## Silmek

### R nesneleri {.unnumbered}

Bir R nesnesini kaldırmak için 'rm()' kullanın.

### Dizinler {.unnumbered}

**fs**'den `dir_delete()` kullanın.


### Dosyalar {.unnumbered}

Dosyaları **fs** içinden `file_delete()` ile silebilirsiniz.



## Diğer dosyaları çalıştırma

### `source()` {.unnumbered}

Bir R betiğini başka bir R betiğinden çalıştırmak için `source()` komutunu kullanabilirsiniz (R **tabanı**ndan).

```{r, eval=F}
source(here("scripts", "cleaning_scripts", "clean_testing_data.R"))
```

Bu, yukarıdaki R komut dosyasını görüntülemeye ve komut dosyasının sağ üst köşesindeki "Kaynak" düğmesine tıklamaya eşdeğerdir. Bu, betiği çalıştıracak, ancak özellikle istenmedikçe sessizce yapacak (R konsoluna çıktı yok). Soru-cevap modunda R konsolu aracılığıyla bir kullanıcıyla etkileşim kurmak için "source()" kullanma örnekleri için [Etkileşimli konsol] sayfasındaki sayfaya bakabilirsiniz.

```{r, fig.align = "center", out.height = '300%', echo=F}
knitr::include_graphics(here::here("images", "source_button.png"))
```


### `render()` {.unnumbered}

"render()", en sık R işaretleme komut dosyaları için kullanılan "source()"un bir varyasyonudur. R işaretleme dosyası olan `input = ` ve ayrıca `output_format =` (tipik olarak "html_document", "pdf_document", "word_document", "") sağlamaktadır.

Daha fazla ayrıntı için [R Markdown ile Raporlar] hakkındaki sayfaya bakabilirsiniz. Ayrıca "render()" belgelerine [buradan](https://rmarkdown.rstudio.com/docs/reference/render.html) veya "?render" girerek bakabilirsiniz.

### Dosyaları dizinde çalıştırın {.unnumbered}

Bir *for loop* oluşturabilir ve bunu 'dir()' ile tanımlanan bir dizindeki her dosyayı 'source()' için kullanabilirsiniz.

```{r, eval=F}
for(script in dir(here("scripts"), pattern = ".R$")) {   # R Project'in "scripts" klasöründeki her bir komut dosyası adı için (.R uzantılı)
  source(here("scripts", script))                        # dosyayı, komut dosyaları klasöründe bulunan eşleşen adla kaynaklayın
}
```

Yalnızca belirli komut dosyalarını çalıştırmak istiyorsanız, bunları şu şekilde adlarıyla tanımlayabilirsiniz:

```{r, eval=F}

scripts_to_run <- c(
     "epicurves.R",
     "demographic_tables.R",
     "survival_curves.R"
)

for(script in scripts_to_run) {
  source(here("scripts", script))
}

```



**fs** ve R **tabanı** fonksiyonlarının [karşılaştırması](https://cran.r-project.org/web/packages/fs/vignettes/function-comparisons.html)

### Dosyaları dizine aktarın {.unnumbered} 

Tek tek dosyaları içe ve dışa aktarmak için [İçe ve dışa aktarma] hakkındaki sayfaya bakabilirsiniz.

Ayrıca dosya meta verilerine bakarak *veya* dosya adındaki bir tarihe dayalı olarak en son dosyayı otomatik olarak içe aktarma yöntemleri için [İçe ve dışa aktar] sayfasına bakabilirsiniz.

**purrr** paketinin aşağıdakileri gösterdiği bir örnek için [Yineleme, döngüler ve listeler] hakkındaki sayfaya bakabilirsiniz:

* Bir veri çerçevesini bölme ve birden çok CSV dosyası olarak kaydetme
* Bir veri çerçevesini bölme ve her bir parçayı tek bir Excel çalışma kitabında ayrı bir sayfa olarak kaydetme
* Birden fazla CSV dosyasını içe aktarma ve bunları tek bir veri çerçevesinde birleştirme
* Birden çok sayfa içeren bir Excel çalışma kitabını içe aktarma ve bunları tek bir veri çerçevesinde birleştirme




##  R **tabanı**

Belirtilen bir dizindeki dosyaları listelemekle aynı işlemi gerçekleştiren `list.files()` ve `dir()` fonksiyonlarına aşağıda bakın. "ignore.case =" veya aranacak belirli bir desen belirtebilirsiniz.

```{r, eval=F}
list.files(path = here("data"))

list.files(path = here("data"), pattern = ".csv")
# dir(path = here("data"), pattern = ".csv")

list.files(path = here("data"), pattern = "evd", ignore.case = TRUE)

```

Bir dosya şu anda "açık" ise, klasörünüzde "~$hospital_linelists.xlsx" gibi bir yaklaşık işareti olacak şekilde görüntülenir. 


<!-- ======================================================= -->
## Kaynaklar {  }

https://cran.r-project.org/web/packages/fs/vignettes/function-comparisons.html



```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/directories.Rmd-->


# Git ve Github ile sürüm kontrolü ve işbirliği

Bu bölüm, Git'i başkalarıyla işbirliği yapmak için kullanmaya genel bir bakış sunar. Daha kapsamlı öğreticiler, Kaynaklar bölümünün alt kısmında bulunabilir.

## Git nedir?

Git, bir klasördeki değişiklikleri izlemeye izin veren bir **sürüm kontrol** yazılımıdır. Word, LibreOffice veya Google belgelerindeki "değişikliği izle" seçeneği gibi kullanılabilir. Sürüm kontrolü için en güçlü ve en çok kullanılan seçeneklerden biridir.

**Neden hiç duymadım? ** 
Geliştirici geçmişine sahip kişiler rutin olarak sürüm kontrol yazılımlarını (Git, Mercurial, Subversion veya diğerleri) kullanmayı öğrenirken, nicel disiplinlerden pek azımıza bu beceriler öğretilir. Sonuç olarak, çoğu epidemiyolog, çalışmaları sırasında bunu asla duymaz ve iş sırasında öğrenmek zorundadır.

**Bekle, Github'ı duydum, aynı mı?** 
Tam olarak değil, ancak bunları sıklıkla birlikte kullanıyorsunuz ve size nasıl yapılacağını göstereceğiz. Kısacası:
**Git**, bir yazılım parçası olan sürüm kontrol sistemidir. Bilgisayarınızda yerel olarak veya bir klasörü ana bilgisayar **web sitesi** ile senkronize etmek için kullanabilirsiniz. Varsayılan olarak, komut satırında Git talimatlarını vermek için bir terminal kullanılır.

Komut satırından kaçınmak ve aynı eylemleri gerçekleştirmek için bir **Git istemcisi/arayüz** kullanabilirsiniz (en azından basit, çok yaygın olanlar için).

Klasörünüzü başkalarıyla işbirliği yapmak için bir **ana web sitesinde** depolamak istiyorsanız, Github, Gitlab, Bitbucket veya diğerlerinde bir hesap oluşturabilirsiniz.

Böylece, dosyalarınızı hem yerel olarak bilgisayarınızda hem de bir **Github** sunucusunda uzaktan yönetmek için arka planda **Git** kullanan **Github Desktop** istemcisini/arayüzünü kullanabilirsiniz.

## Neden Git ve Github kombinasyonunu kullanmalısınız?

**Git** kullanımı şunları kolaylaştırır:

1) Herhangi bir önceki duruma kolayca geri dönebilmeniz için belgelenmiş sürümleri artımlı değişikliklerle arşivleme
2) Paralel *dallara* sahip olmak, yani gözden geçirmeden sonra değişiklikleri entegre etmek için yapılandırılmış yollarla geliştirilen/"çalışan" sürümler

Bu, başkalarıyla işbirliği yapmasanız bile bilgisayarınızda yerel olarak yapılabilir. Sen hiç:

- bir kod bölümünü sildiğiniz için pişmanlık duydunuz, ancak iki ay sonra gerçekten ihtiyacınız olduğunu fark ettiniz mi?


- duraklatılmış bir projeye geri dönün ve modellerden birinde bu zor değişikliği yapıp yapmadığınızı hatırlamaya çalıştınız mı?

- denemek için bir *model_1.R* dosyası ve başka bir *model_1\_test.R* dosyası ve bir *model_1\_not_working.R* dosyası mı vardı?

- bir *report.Rmd* dosyası, bir *report_full.Rmd* dosyası, bir *report_true_final.Rmd* dosyası, bir *report_final_20210304.Rmd* dosyası, bir *report_final_20210402.Rmd* dosyası vardı ve arşivleme becerilerinize lanet mi okudunuz?

Git tüm bunlara yardımcı olacak ve sadece bunun için öğrenmeye değer.

Ancak, **işbirlikçi projeleri** desteklemek için Github gibi bir çevrimiçi depo ile kullanıldığında daha da güçlü hale gelir. Bu şunları kolaylaştırır:

- İşbirliği: diğerleri değişiklikleri inceleyebilir, yorumlayabilir ve değişiklikleri kabul edebilir/reddetebilir

- Kodunuzu, verilerinizi ve çıktılarınızı paylaşmak ve halktan (veya ekibinizle özel olarak) geri bildirim davet etmek ve şunlardan kaçınmak:

- "Hata, son sürümü göndermeyi unuttum ve şimdi bu yeni dosya üzerinde iki günlük çalışmayı yeniden yapmanız gerekiyor"

- Mina, Henry ve Oumar aynı anda tek bir komut dosyası üzerinde çalıştı ve değişikliklerini manuel olarak birleştirmeleri gerekiyor

- Dropbox ve Sharepoint üzerinde iki kişi aynı dosyayı değiştirmeye çalışıyor ve bu bir senkronizasyon hatası yaratıyor.

### Kulağa karmaşık geliyor, ben programcı değilim {-}

Olabilir. Gelişmiş kullanım örnekleri oldukça korkutucu olabilir. Ancak, R'ye ve hatta Excel'e çok benzer şekilde, aracın avantajlarından yararlanmak için uzman olmanıza gerek yoktur. *Az sayıda işlev ve kavram* öğrenmek, değişikliklerinizi izlemenize, dosyalarınızı çevrimiçi bir havuzda senkronize etmenize ve çok kısa bir süre içinde iş arkadaşlarınızla işbirliği yapmanıza olanak tanır.

Öğrenme eğrisi nedeniyle, acil durum bağlamı bu araçları öğrenmek için en iyi zaman olmayabilir. Ancak öğrenme adım adım gerçekleştirilebilir. Birkaç kavram edindikten sonra, iş akışınız oldukça verimli ve hızlı olabilir.

Git aracılığıyla insanlarla işbirliği yapmanın bir zorunluluk olduğu bir proje üzerinde çalışmıyorsanız, ortak çalışmaya dalmadan önce **onu solo olarak kullanmaktan emin olmak için iyi bir zamandır**.

## Kurmak

### Git'i yükleyin {.unnumbered}

*Git*, bilgisayarınızda değişiklikleri, dalları (sürümleri), birleştirmeleri ve geri dönmeyi izleyen perde arkasındaki motordur. **Önce yapmanız gerekir
<https://git-scm.com/downloads> adresinden *Git*'i yükleyin.**

### Bir arayüz kurun (isteğe bağlı ancak önerilir) {.unnumbered}

Git'in komut satırı terminaline yazılabilen kendi komut dili vardır. Bununla birlikte, birçok istemci/arayüz vardır ve geliştirici olmayanlar olarak, günlük kullanımınızda Git ile doğrudan etkileşime nadiren _ihtiyacınız olur ve arayüz genellikle dosya değişiklikleri veya dalları için güzel görselleştirme araçları sağlar.

Yeni başlayanlardan daha karmaşık olanlara kadar tüm işletim sistemlerinde birçok seçenek mevcuttur. Yeni başlayanlar için iyi seçenekler arasında RStudio Git bölmesi ve
[Github Desktop](https://desktop.github.com/), ki bu bölümde durum nasıl olacak.

Orta (daha güçlü, ancak daha karmaşık) seçenekler arasında Source Tree, Gitkracken, Smart Git ve diğerleri bulunur.

[Git istemcileri](-%09https:/happygitwithr.com/git-client.html#git-client) hakkında hızlı açıklama.

*Not: Arabirimlerin tümü Git'i dahili olarak kullandığından, bunlardan birkaçını deneyebilir, belirli bir projede birinden diğerine geçebilir, konsolu arabiriminizin desteklemediği bir eylem için zamanında kullanabilir ve hatta üzerinde herhangi bir sayıda çevrimiçi eylem gerçekleştirebilirsiniz. Github.*

Aşağıda belirtildiği gibi, zaman zaman Git komutlarını RStudio terminal bölmesi (R Konsoluna bitişik bir sekme) veya Git Bash terminali gibi bir terminale yazmanız gerekebilir.

### Github hesabı {.unnumbered}

[github.com](github.com) adresinde ücretsiz bir hesap için kaydolun.

Bir uygulama ile iki faktörlü kimlik doğrulamayı ayarlamanız istenebilir.
Telefonunuz. Github [yardım belgelerinde](https://docs.github.com/en/github/authenticating-to-github/securing-your-account-with-two-factor-authentication-2fa) daha fazlasını okuyun.

Github Desktop kullanıyorsanız, kurulumdan sonra bu [adımları](https://docs.github.com/en/desktop/installing-and-configuring-github-desktop/authenticating-to-github) izleyerek Gitub kimlik bilgilerinizi girebilirsiniz. .
Bunu bilmiyorsanız, daha sonra yapmaya çalıştığınızda kimlik bilgileri sorulacaktır.
Github'dan bir projeyi klonlayın.

## Kelime bilgisi, kavramlar ve temel işlevler

R öğrenirken olduğu gibi Git'i anlamak için hatırlamanız gereken biraz kelime hazinesi vardır. İşte [başlamanıza yardımcı olacak temel bilgiler](https://www.freecodecamp.org/news/an-introduction-to-git-for-absolute-beginners-86fa1d32ff71/)/ [etkileşimli öğretici](learngitbranching.js. kuruluş). Sonraki bölümlerde, arayüzlerin nasıl kullanılacağını göstereceğiz, ancak zihinsel modelinizi oluşturmak için kelime dağarcığı ve kavramları aklınızda bulundurmak iyidir ve arayüzleri kullanırken bunlara ihtiyacınız olacaktır.

### Depo {.unnumbered}

Git *repo* ("*repo*"), projeniz için tüm alt klasörleri ve dosyaları (veriler, kodlar, resimler vb.) ve bunların revizyon geçmişlerini içeren bir klasördür. Depodaki değişiklikleri onunla izlemeye başladığınızda Git, tüm izleme bilgilerini içeren gizli bir klasör oluşturacaktır. Tipik bir Git deposu, *R Project* klasörünüzdür ([R projeleri] hakkındaki el kitabı sayfasına bakın).

Github, Github Desktop veya Rstudio'dan bir Git deposunun nasıl oluşturulacağını (_initialize_) sonraki bölümlerde göstereceğiz.

### Taahhütler {.unnumbered}

*taahhüt*, projenin belirli bir zamanda **anlık görüntüsüdür**. Projede bir değişiklik yaptığınızda, dosyalarınızda yapılan değişiklikleri (delta) izlemek için yeni bir taahhütte bulunacaksınız. Örneğin, bazı kod satırlarını düzenlemiş ve ilgili bir veri kümesini güncellemiş olabilirsiniz. Değişiklikleriniz kaydedildikten sonra, bu değişiklikleri tek bir "taahhüt" altında toplayabilirsiniz.
Her işlemin benzersiz bir kimliği vardır (bir *karma*). Sürüm kontrolü amacıyla, taahhütlere dayalı olarak projenizi zamanında geri alabilirsiniz, bu nedenle onları nispeten küçük ve tutarlı tutmak en iyisidir. Ayrıca, "taahhüt mesajı" adı verilen değişikliklerin kısa bir açıklamasını da ekleyeceksiniz.

*Aşamalı değişiklikler*? Değişiklikleri aşamaya geçirmek, bir sonraki işleme hazırlanmak için bunları *hazırlama alanına* eklemektir. Buradaki fikir, belirli bir taahhütte hangi değişikliklerin dahil edileceğine ince bir şekilde karar verebilmenizdir. Örneğin, bir komut dosyasında model belirtimi üzerinde çalıştıysanız ve daha sonra başka bir komut dosyasındaki bir şekil üzerinde çalıştıysanız, iki farklı kesinliğe sahip olmak mantıklı olacaktır (şekildeki değişiklikleri geri almak isteyip modeli).

### Şubeler {.unnumbered}

Dal, deponuzdaki *bağımsız bir değişiklik satırını*, proje dosyalarınızın paralel, alternatif bir sürümünü temsil eder.

Dallar, değişiklikleri genellikle projenizin birincil/son/"canlı" versiyonu olan *ana* dalına dahil edilmeden önce test etmek için kullanışlıdır. Bir dal üzerinde denemeyi bitirdiğinizde, değişiklikleri *birleştirerek* *ana* dalınıza getirebilir veya değişiklikler o kadar başarılı olmazsa silebilirsiniz.

*Not: Şubeleri kullanmak için başka kişilerle işbirliği yapmanız veya uzak bir çevrimiçi veri havuzuna sahip olmanız gerekmez.*


### Yerel ve uzak depolar {.unnumbered}

*Klonlamak*, Git deposunun bir kopyasını başka bir yerde oluşturmaktır.

Örneğin, Github'dan bilgisayarınızda yerel olarak bir çevrimiçi depoyu *klonlayabilirsiniz* veya yerel bir depoyla başlayabilir ve onu çevrimiçi olarak Github'a kopyalayabilirsiniz.

Bir havuzu klonladığınızda, proje dosyaları iki yerde bulunur:

- fiziksel bilgisayarınızdaki *YEREL* veri havuzu. Dosyalarda/kodda asıl değişiklikleri yaptığınız yer burasıdır.

- *UZAK*, çevrimiçi depo: Github deposundaki (veya başka herhangi bir web barındırıcısındaki) proje dosyalarınızın sürümleri.

Bu depoları senkronize etmek için daha fazla fonksiyon kullanacağız. Gerçekten de, Sharepoint, Dropbox veya diğer senkronizasyon yazılımlarından farklı olarak Git, yerel deponuzu veya çevrimiçi olanı temel alarak veya tam tersi şekilde otomatik olarak güncellemez. Ne zaman ve nasıl senkronize edeceğinizi siz seçersiniz.

- `git fetch` uzak depodaki yeni değişiklikleri indirir ancak yerel deponuzu değiştirmez. Bunu uzak deponun durumunu kontrol etmek olarak düşünün.

- `git pull` uzak depolardaki yeni değişiklikleri indirir ve yerel deponuzu günceller.

- Yerel olarak bir veya birkaç taahhütte bulunduğunuzda, taahhütleri uzak depoya `git push` edebilirsiniz. Bu, değişikliklerinizi Github'a gönderir, böylece diğer insanlar isterlerse onları görebilir ve çekebilir.


## Başlayın: yeni bir depo oluşturun

Yeni depolar oluşturmanın birçok yolu vardır. Bunu konsoldan, Github'dan bir arayüzden yapabilirsiniz.

Kurulum için iki genel yaklaşım şunlardır:


- Mevcut veya yeni bir Github deposundan yeni bir R Projesi oluşturun (*yeni başlayanlar için tercih edilir*) veya
- Mevcut bir R projesi için bir Github deposu oluşturun


### Başlangıç dosyaları {.unnumbered}

Yeni bir havuz oluşturduğunuzda, isteğe bağlı olarak aşağıdaki dosyaların tümünü oluşturabilir veya daha sonraki bir aşamada havuzunuza ekleyebilirsiniz. Genellikle havuzun "kök" klasöründe yaşarlar.

- *README* dosyası, projenizin neden var olduğunu ve onu kullanmak için başka neleri bilmeleri gerektiğini anlamak için birinin okuyabileceği bir dosyadır. İlk başta boş olacak, ancak daha sonra tamamlamanız gerekir.

- Bir *.gitignore* dosyası, her satırın Git'in yok sayması gereken (değişiklikleri izlememesi) klasörleri veya dosyaları içerdiği bir metin dosyasıdır. Bununla ilgili daha fazla bilgi edinin ve örneklere bakın[buradan](https://www.freecodecamp.org/news/gitignore-what-is-it-and-how-to-add-to-repo/).

- Çalışmanız için bir *lisans* seçebilirsiniz, böylece diğer insanlar çalışmanızı hangi koşullar altında kullanabileceklerini veya çoğaltabileceklerini bilsinler. Daha fazla bilgi için bkz. [Creative Commons lisansları] https://creativecommons.org/licenses/).

### Github'da yeni bir depo oluşturun {.unnumbered}

Yeni bir depo oluşturmak için Github'da oturum açın ve yeni bir depo oluşturmak için yeşil düğmeyi arayın. Artık boş olan bu depo bilgisayarınıza yerel olarak klonlanabilir (bir sonraki bölüme bakın).

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_new.png"))
```

Deponuzun **genel** (internetteki herkes tarafından görülebilir) veya **özel** (yalnızca izne sahip olanlar tarafından görülebilir) olmasını seçmelisiniz. Verileriniz hassassa, bunun önemli etkileri vardır. Deponuz özelse, kodunuzu bulutta otomatik olarak çalıştırmak için Github *actions* kullanıyorsanız, örneğin gelişmiş özel durumlarda bazı kotalarla karşılaşırsınız.
 
### Github deposundan klonlama {.unnumbered}

Bilgisayarınızda yeni bir yerel R projesi oluşturmak için mevcut bir Github deposunu *klonlayabilirsiniz*.

Github deposu, zaten var olan ve içerik içeren bir depo olabilir veya az önce oluşturduğunuz boş bir depo olabilir. Bu ikinci durumda, esasen Github deposunu ve yerel R projesini aynı anda yaratıyorsunuz (yukarıdaki talimatlara bakın).

_Not_: Bir Github deposunda katkıda bulunma hakkınız yoksa, önce depoyu profilinize _fork_ yapmak ve ardından diğer işlemlere geçmek mümkündür. Çatallanma bu bölümün sonunda açıklanmıştır, ancak önce diğer bölümleri okumanızı öneririz.

Adım 1: Github'da depoya gidin, yeşil "**Kod**" düğmesine tıklayın ve **HTTPS klon URL'sini** kopyalayın (aşağıdaki resme bakın)

```{r echo=F, out.width = '100%', out.height='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_clone.png"))
```

Bir sonraki adım herhangi bir arayüzde gerçekleştirilebilir. Rstudio ve Github masaüstü ile örneklendireceğiz.

#### Rstudio'da {.unnumbered}

RStudio'da *Dosya \> Yeni Proje \>Sürüm Kontrolü \> Git*'e tıklayarak yeni bir R projesi başlatın.

- "Depo URL'si" istendiğinde, HTTPS URL'sini Github\'dan yapıştırın
- R projesine kısa, bilgilendirici bir ad verin\
- Yeni R Projesinin yerel olarak nereye kaydedileceğini seçin\
- "Yeni oturumda aç" seçeneğini işaretleyin ve "Proje oluştur" u tıklayın


Artık Github deposunun bir klonu olan yeni, yerel bir RStudio projesindesiniz. Bu yerel proje ve Github deposu artık
bağlantılı.

#### Github Desktop'ta {.unnumbered}

- *Dosya \> Bir depoyu klonla* üzerine tıklayın

- URL sekmesini seçin

- Github'dan HTTPS URL'sini ilk kutuya yapıştırın

- Yerel deponuzun olmasını istediğiniz klasörü seçin

- "KLON" u tıklayın

```{r echo=F, out.width = '100%', out.height='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_clone_desktop.png"))
```

### Mevcut R projesinden yeni Github deposu {.unnumbered}

Alternatif bir kurulum senaryosu, içeriği olan mevcut bir R projeniz olması ve bunun için bir Github deposu oluşturmak istemenizdir.

1) Proje için yeni, boş bir Github deposu oluşturun (yukarıdaki talimatlara bakın)\
2) Bu depoyu yerel olarak klonlayın (yukarıdaki HTTPS talimatlarına bakın)\
3) Önceden var olan R projenizdeki tüm içeriği (kodlar, veriler, vb.) bu yeni boş, yerel depoya kopyalayın (örn. kopyala ve yapıştır kullanın).\
4) Yeni projenizi RStudio'da açın ve Git bölmesine gidin. Yeni dosyalar, artık Git tarafından izlenen dosya değişiklikleri olarak kaydedilmelidir. Bu nedenle, bu değişiklikleri bir *taahhüt* olarak paketleyebilir ve Github'a *gönderebilirsiniz*. Bir kez *basıldığında*, Github'daki depo tüm dosyaları yansıtacaktır.
   
Bu işlemle ilgili ayrıntılar için aşağıdaki Github iş akışı bölümüne bakın.

### Şimdi nasıl görünüyor? {.unnumbered}

#### RStudio'da {-}

Bir Github deposunu yeni bir R projesine klonladığınızda, artık RStudio'da bir "Git" sekmesi görürsünüz. Bu sekme, R Ortamınız ile aynı RStudio bölmesinde görünür:

```{r echo=F, out.width = "75%", out.height="75%", fig.align = "center"}
knitr::include_graphics(here::here("images", "Git_console.png"))
```

Lütfen yukarıdaki resimde daire içine alınmış butonlara dikkat edin, çünkü bunlar
daha sonra atıfta bulunuldu (soldan sağa):

- Kaydedilen dosya değişikliklerini yerel şubede *kabul etme* düğmesi (bu, yeni bir pencere açar)
- *Çekmek* için mavi ok (dalın uzak/Github sürümünde yapılan değişikliklerle şubenin yerel sürümünüzü güncelleyin)
- *Push* için yeşil ok (dalın yerel sürümünüz için tüm taahhütleri/değişiklikleri o dalın uzak/Github sürümüne gönderin)
- RStudio'daki Git sekmesi
- Sağda taban olarak gösterilen yerel şubeyi kullanarak YENİ bir şube oluşturma düğmesi. *Neredeyse her zaman ana daldan ayrılmak istersiniz (ana dalı güncellemek için ilk kez çektikten sonra)*
- Şu anda çalıştığınız şube
- Kodda veya diğer dosyalarda yaptığınız değişiklikler aşağıda görünecektir

#### Github Masaüstünde {-}

Github Desktop, tüm depolarınızı yönetmenize izin veren bağımsız bir uygulamadır. Açtığınızda, arayüz üzerinde çalışmak istediğiniz depoyu seçmenize ve ardından oradan temel Git eylemlerini gerçekleştirmenize olanak tanır.

```{r echo=F, out.width = "75%", out.height="75%", fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_interface.png"))
```


## Git + Github iş akışı

### Sürece genel bakış {.unnumbered}

Kurulumu tamamladığınızda (yukarıda açıklanmıştır), yerel bir R projesine bağlı (*klonlanmış*) bir Github deposuna sahip olacaksınız. *main* dalı (varsayılan olarak oluşturulur), *tüm* dosyaların sözde "canlı" versiyonudur. Değişiklik yapmak istediğinizde, *ana* daldan *yeni bir dal* oluşturmak ("Kopya Oluştur" gibi) iyi bir uygulamadır. Dal oluşturmak kolay ve hızlı olduğu için bu Git'teki tipik bir iş akışıdır.


Tipik bir iş akışı aşağıdaki gibidir:

1. Yerel deponuzun güncel olduğundan emin olun, değilse güncelleyin

2. Daha önce çalıştığınız şubeye gidin veya bazı şeyleri denemek için yeni bir şube oluşturun.

3. Bilgisayarınızda yerel olarak dosyalar üzerinde çalışın, bu şubeye bir veya birkaç taahhütte bulunun

4. Şubenin uzak sürümünü değişikliklerinizle güncelleyin (push)

5. Şubenizden memnun kaldığınızda, değişiklikleri aktarmak için çalışan şubenin çevrimiçi sürümünü çevrimiçi "ana" şubeye birleştirebilirsiniz.

Diğer ekip üyeleri de aynı şeyi kendi şubeleriyle yapıyor olabilir veya belki de sizin çalışma şubenize taahhütlere katkıda bulunuyor olabilir.

Yukarıdaki süreci aşağıda daha ayrıntılı olarak adım adım inceliyoruz. İşte geliştirdiğimiz bir şema - iki yönlü bir tablo biçiminde olduğundan epidemiyologların anlamasına yardımcı olmalıdır.

```{r echo=F, out.height='150%', out.width='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_table.png"))
```

İşte [başka bir şema](https://build5nines.com/introduction-to-git-version-control-workflow/).

*Not: Yakın zamana kadar "master" dal terimi kullanılıyordu, ancak şimdi "main" dal olarak anılıyor.*

```{r echo=F, out.width = '100%', out.height='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "GitHub-Flow.png"))
```

Görüntü [source](https://build5nines.com/introduction-to-git-version-control-workflow/)

## Yeni bir dal oluştur

Üzerinde çalışmak için bir dal seçtiğinizde **Git, çalışma dizininizi bu dalda en son bulunduğunuz zamanki gibi sıfırlar**.

### Rstudio Git bölmesinde {.unnumbered}

"Ana" dalda olduğunuzdan emin olun ve ardından yeni bir dal oluşturmak için mor simgeye tıklayın (yukarıdaki resme bakın).

- Şubenize tek kelimelik açıklayıcı bir ad vermeniz istenecektir (gerekirse alt çizgi kullanabilirsiniz).
- Yerel olarak hala aynı R projesinde olduğunuzu ancak artık "ana" dal üzerinde çalışmadığınızı göreceksiniz.
- Yeni şube oluşturulduktan sonra Github web sitesinde şube olarak da görünecektir.
    
"Geçmiş" e tıkladıktan sonra Rstudio'daki Git Bölmesi'ndeki dalları görselleştirebilirsiniz.

```{r echo=F, out.width = '100%', out.height='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_rstudio_branchs.png"))
```

### Masaüstünde Github {.unnumbered}

İşlem çok benzer, dalınıza bir isim vermeniz isteniyor. Ardından, yeni şubenin uzak depoda da görünmesini sağlamak için "Dalınızı Github'da yayınla" denilmelidir.


```{r echo=F, out.width = '100%', out.height='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_new_branch.png"))
```

### Konsol Kullanırken {.unnumbered}

Perde arkasında gerçekte olan şey, "git dalı" ile yeni bir şube oluşturmanız ve ardından "git checkout" ile dala gitmenizdir (_Örneğin_ Git'e sonraki taahhütlerinizin orada gerçekleşeceğini söyleyin).
Git deponuzdan:

```{bash, eval = FALSE}
git branch my-new-branch  # Yeni bir dal oluşturun
git checkout my-new-branch # Oluşturulan dala gidin
git checkout -b my-new-branch # İkisi aynı anda (Kısayol)
```


Konsolu kullanma hakkında daha fazla bilgi için sondaki Git komutlarına bakınız.

## Değişiklikleri Uygula (Commit Changes)

Artık kodu düzenleyebilir, yeni dosyalar ekleyebilir, veri kümelerini güncelleyebilirsiniz.

Değişikliklerinizin her biri *ilgili dosya kaydedildikten sonra* izlenir. Değiştirilen dosyalar RStudio Git sekmesinde, Github Desktop'ta veya terminalde 'git status' komutu kullanılarak görünecektir (aşağıya bakın).

Önemli değişiklikler yaptığınızda (örneğin, bir kod bölümü ekleme veya güncelleme), bu değişiklikleri duraklatın ve *kabul edin*. Bir taahhüdü, ortak bir amaçla ilgili değişikliklerin bir "topluluğu" olarak düşünün. Üzerinde değişiklik yaptıktan sonra bir dosyayı her zaman revize etmeye devam edebilirsiniz.

*Uygulamayla ilgili tavsiye*: genel olarak, bir sorun ortaya çıktığında kolayca geri alınabilecek küçük uygulamalar yapmak, ortak bir amaç ile ilgili değişiklikleri birlikte yapmak daha iyidir. Bunu başarmak için *sık sık uygulamalarda bulunmanız gerektiğini* göreceksiniz. Başlangıçta, muhtemelen sık sık uygulamada bulunmayı unutacaksınız, ancak daha sonra alışkanlık halini almaktadır.

### Rstudio'da {.unnumbered}

Aşağıdaki örnek, son işlemden bu yana, "collaboration.Rmd" R Markdown komut dosyasının değiştiğini ve birkaç PNG görüntüsünün eklendiğini göstermektedir.

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_tracking2.png"))
```

Dosya adlarının yanındaki sarı, mavi, yeşil ve kırmızı karelerin neyi temsil ettiğini merak ediyor olabilirsiniz. İşte [RStudio kolay kullanım sayfasından](https://www.rstudio.com/wp-content/uploads/2016/01/rstudio-IDE-cheatsheet.pdf) anlamlarını açıklayan bir anlık görüntü. Değişikliklerin sarı "?" ile işaretlendiğine, halen görüntülenebilir, işlenebilir ve gönderilebilir(push) olduğuna dikkat edin.

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_tracking.png"))
```
- Git sekmesindeki "Commit" düğmesine basın, yeni bir
     pencere açılacaktır(aşağıda gösterilmiştir)

- Sol üstteki kutuda bir dosya adına tıklayın

- Bu dosyada yaptığınız değişiklikleri gözden geçirin (aşağıda yeşil veya kırmızı renkle vurgulanmıştır)

- Gönderirken bu değişiklikleri içerecek olan dosyayı "stage" yapın. Bunu dosya adının yanındaki kutuyu işaretleyerek yapabilirsiniz. Alternatif olarak, birden fazla dosya adını vurgulayabilir ve ardından "Stage(Aşama)" yı tıklayabilir.

- Kısa ama açıklayıcı bir Commit mesajı yazın (gereklidir)

- "Commit" düğmesine basın. Başarıyı gösteren bir açılır kutu veya bir hata mesajı görünecektir.

Artık istediğiniz kadar değişiklikte bulunabilir ve commit edebilirsiniz.

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_commit.png"))
```

### Masaüstünde Github {.unnumbered}

Solda değiştirilen dosyaların listesini görebilirsiniz. Eğer
bir metin dosyası seçerseniz, yapılan değişikliklerin bir özetini görürsünüz.
sağ bölmede (görünüm .docs veya .xlsx gibi daha karmaşık dosyalarda çalışmaz).

Değişiklikleri düzenlemek için dosya adlarının yanındaki küçük kutuyu işaretlemeniz yeterlidir. Ne zaman bu uygulamaları eklemek istediğiniz dosyaları seçerseniz commit edebilirsiniz. Bir isim verip, isteğe bağlı olarak bir açıklama yazmanın ardından commit edilebilir.

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_commit.png"))
```

### Konsolda {.unnumbered}

Sahne arkasında kullanılan iki fonksiyon, seçme/sahneleme için "git add" fonksiyonudur.
dosyalar ve 'git commit'  commit etmek içindir.

```{bash, eval = FALSE}
git status # değişiklikleri izle 

git add new_pages/collaboration.Rmd  # commit edilecek dosyaları seçin (= değişiklikleri yapın)

git commit -m "Describe commit from Github Desktop" # değişiklikleri bir mesajla commit et

git log  # geçmiş commitlerle ilgili bilgileri görüntüle
```


### Önceki bir commit'i değiştirin {.unnumbered}

Bazı değişiklikler yaparsanız, çalışmaya devam ederseniz ve geçmiş commit'e "ait" olması gereken değişiklikler yaptığınızı fark ederseniz ne olur (sizce). Korkmayın! Bu değişiklikleri önceki gönderinize ekleyebilirsiniz.

Rstudio'da, COMMIT düğmesiyle aynı satırda bir "Önceki commit'i değiştir" kutusu olduğu için oldukça açıktır.

Belirsiz bir nedenle, işlevsellik Github Desktop'ta olduğu gibi uygulanmamıştır, ancak (kavramsal olarak garip ama kolay) bir yol vardır. Henüz değişikliklerinizi commit etmiş **ancak push etmediyseniz**, COMMIT düğmesinin hemen altında bir "GERİ AL" düğmesi görünür. Üzerine tıklayın geri alacaktır (ancak aşamalı dosyalarınızı ve commit mesajınızı saklayın). Değişikliklerinizi kaydedin, gerekirse commit'e yeni dosyalar ekleyin ve tekrar commit edin.

Konsolda:

```{bash, eval = FALSE}
git add [YOUR FILES] # Yeni değişikliklerinizi aşamalandırın

git commit --amend  # Önceki commit'i değiştir

git commit --amend -m "An updated commit message"  # Önceki commitlerini değiştirin VE mesajını güncelleyin
```


_Not: Zaten herkese açık olan ve ortak çalışanlarınızla paylaşılan commitleri değiştirmeden önce düşünün_.

## Değişiklikleri Github'a kadar çekin ve iletin

"Önce PULL (çekin), sonra PUSH(iletin)"

Projeniz üzerinde çalışmaya başlamadan önce *fetch(getirmek)* ve *pull(çekmek)*, yerel bilgisayarınızdaki dalın sürümünü uzak/Github sürümünde yapılan değişikliklerle güncellemek iyi bir uygulamadır.

sık sık ÇEKİN. tereddüt etmeyin. *İtmeden önce daima çekin*. Değişiklikleriniz yapıldığında ve commit edildiğinde ve projenizin durumundan memnun olduğunuzda, gönderilerinizi dalınızın uzak/Github sürümüne *iletebilirsiniz*.

Depo üzerinde çalışırken tekrarlayın.

**Not:** Commit edilen ancak gönderilmeyen (yani hala yerel olan) değişiklikleri geri almak, uzak depoya gönderilen (ve belki de zaten başka biri tarafından çekilmiş) değişiklikleri geri almaktan çok daha kolaydır, bu nedenle üzerinde çalıştığınız görevde değişiklik yapmayı bitirdiğinizde commit etmek daha iyidir.

#### Rstudio'da {.unnumbered}

*PULL* - İlk olarak, "Çek" simgesine (aşağı ok) tıklayın.

*PUSH* - Yeşil "Çek" simgesine (yukarı ok) tıklayın. Github kullanıcı adınızı ve şifrenizi girmeniz istenebilir. İlk sorulduğunda, *Terminal*'e Git komut satırını girmeniz gerekebilir:

- **git config --global user.email "[siz\@example.com (mailto:siz@example.com){.email}"** (Github e-posta adresiniz) ve\
- **git config --global user.name "Github kullanıcı adınız"**

Bu komutların nasıl girileceği hakkında daha fazla bilgi edinmek için aşağıdaki Git komutları bölümüne bakın.

***İPUCU:*** Parolanızı çok sık mı istedi? Havuza bağlanmak için bu [eğiticinin (https://happygitwithr.com/credential-caching.html#credential-caching) 10. ve 11. bölümlerine bakın.

#### Github Desktop'ta {.unnumbered}

Uzak depoda yeni commitler olup olmadığını kontrol etmek için "Fetch Origin" düğmesine tıklayın.

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_fetch_button.png"))
```

Git, uzak depoda yeni taahhütler bulursa, düğme bir "Çek" düğmesine dönüşür. İtme ve çekme için aynı düğme kullanıldığından, daha önce çekmediyseniz değişikliklerinizi itemezsiniz.

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_pull_button.png"))
```

Tüm commitleri (sizin ve diğerleri) görmek için "Geçmiş" sekmesine ("Değişiklikler" sekmesinin yanında) gidebilirsiniz. Bu, işbirlikçilerinizin yaptıkları hakkında bilgi edinmenin güzel bir yoludur. Commit mesajını, varsa açıklamasını okuyabilir ve *diff* bölmesini kullanarak iki dosyanın kodunu karşılaştırabilirsiniz.

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_history.png"))
```

Tüm uzaktan değişiklikler çekildikten ve en az bir yerel değişiklik yapıldıktan sonra, aynı düğmeye tıklayarak basabilirsiniz.

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_push_button.png"))
```

#### Konsol {.unnumbered}

Şaşırtıcı olmayan bir şekilde, komutlar *getir(fetch)*, *çek(pull)* ve *ittir(push)* şeklindedir.

```{bash, eval = FALSE}
git fetch  # uzak dizinde yeni commitler var mı?
git pull   # Uzak commitleri yerel dalınıza getirin
git push   # Bu dalın yerel commitlerini uzak dala aktarın
```


### Çekmek istiyorum ama yerel işim var {.unnumbered}

Bu bazen olabilir: yerel deponuzda bazı değişiklikler yaptınız, ancak uzak depo sizin çekmediğinizi commit etti.

Git, değişikliklerinizin üzerine yazabileceği için çekmeyi reddedecek. Değişikliklerinizi korumak için [Happy Git with R (https://happygitwithr.com/pull-tricky.html) bölümünde iyi açıklanan birkaç strateji vardır.
- değişikliklerinizi gerçekleştirin, uzaktan değişiklikleri alın, bunları çekin, gerekirse çakışmaları çözün (aşağıdaki bölüme bakın) ve her şeyi çevrimiçine gönderin
- Değişikliklerinizi 'saklayın', bu tür onları bir kenara depolar, çeker, geri yükler ve ardından commit eder, herhangi bir çakışmayı çözer ve iter.

Uzak değişikliklerle ilgili dosyalar ve yerel değişikliklerinizle ilgili dosyalar çakışmıyorsa Git, çakışmaları otomatik olarak çözebilir.

Github Desktop'ta bu, düğmelerle yapılabilir. Saklamak için _Branch>Tüm değişiklikleri sakla_ seçeneğine gidin.

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_stash.png"))
```



## Dalını Ana Gövde ile birleştir

Değişiklik yapmayı bitirdiyseniz, bu değişiklikleri ana dalda birleştirme işlemine başlayabilirsiniz. Durumunuza bağlı olarak bu hızlı olabilir veya ekip arkadaşlarınızı içeren kasıtlı inceleme ve onay adımlarını atmış olabilirsiniz.

### Yerel olarak Github Desktop'ta {.unnumbered}

Github Desktop kullanarak dalları yerel olarak birleştirebilirsiniz. İlk olarak, commitlerin alıcısı olacak dallara, yani güncellemek istediğiniz dala gidin. Ardından *Dal\> Geçerli gövdeye birleştir* menüsüne gidin ve tıklayın. Bir kutu, içe aktarmak istediğiniz dalı seçmenize olanak tanır.

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_merge.png"))
```

### Konsolda {.unnumbered}

İlk önce değişikliklerin alıcısı olacak dala geri dönün.
Bu genellikle *master* şeklindedir, ancak başka bir dal da olabilir. Sonra master içine çalışma dalınızı birleştirin.

```{bash, eval = FALSE}
git checkout master  # Master'a (veya taşımak istediğiniz dala) geri dönün
git merge this_fancy_new_branch
```

[Bu sayfa](https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging) daha gelişmiş bir dallanma örneği gösterir ve perde arkasında neler olduğunu biraz açıklar .

### Github'da: çekme istekleri gönderme {.unnumbered}

İki dalı yerel olarak veya kimseye haber vermeden birleştirmek tamamen mümkün olmakla birlikte, bir birleşme ana gövdeye entegre edilmeden önce birkaç kişi tarafından tartışılabilir veya araştırılabilir. Sürece yardımcı olmak için Github, birleştirme ile ilgili bazı tartışma özellikleri sunar: **çekme isteği**.

Bir çekme isteği (bir "PR"), bir dalı diğeriyle birleştirme isteğidir (başka bir deyişle, _çalışan dalınızın "ana" dala çekilmesine yönelik bir istek_).

Bir çekme isteği, genellikle birden çok commit içerir. Bir çekme isteği, genellikle kabul edilmeden ve dal birleştirilmeden önce bir konuşma ve inceleme sürecini başlatır. Örneğin, [dplyr's github] (https://github.com/tidyverse/dplyr/pulls) üzerinden çekme isteği tartışmalarını okuyabilirsiniz.

Doğrudan web sitesinden (aşağıda gösterildiği gibi) veya Github Desktop'tan bir çekme isteği (PR) gönderebilirsiniz.

- Github deposuna gidin (çevrimiçi)
- "Çekme İstekleri" sekmesini görüntüleyin ve "Yeni çekme isteği" düğmesini tıklayın
- Dalınızı ana gövde ile birleştirmek için açılır menüden seçin
- Ayrıntılı bir Çekme Talebi yorumu yazın ve "Çekme Talebi Oluştur" u tıklayın.

Aşağıdaki resimde, "ormanlar" dalı "ana" ile birleştirilmek üzere seçilmiştir:

```{r echo=F, out.width = '100%', out.height='150%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_pull_request2.png"))
```

Şimdi çekme isteğini görebilmelisiniz (aşağıdaki örnek resim):

- Dal birleştirilirse "ana" dalın nasıl değişeceğini görmek için "Dosyalar değişti" sekmesini inceleyin.\
- Sağ tarafta, Github ID'lerini etiketleyerek ekibinizin üyelerinden inceleme talep edebilirsiniz. İsterseniz, ana ile birleştirmek için havuz ayarlarını bir onay incelemesi gerektirecek şekilde ayarlayabilirsiniz.\
- Çekme talebi onaylandıktan sonra,
     "Birleştirme çekme isteği" aktif hale gelecektir. Buna tıklayın.\
- Tamamlandıktan sonra dalınızı aşağıda açıklandığı gibi silin.

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_pull_request.png"))
```

### Çakışmaları çözme {.unnumbered}

İki kişi aynı satırları aynı anda değiştirdiğinde, birleştirme çatışması ortaya çıkar. Aslında Git, hangi sürümün tutulacağına karar vermeyi reddeder, ancak çatışmanın nerede olduğunu bulmanıza yardımcı olur. **PANİK YAPMA**. Çoğu zaman, çözmek oldukça basittir.

Örneğin, Github'da:

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_conflict2.png"))
```

Birleştirme bir çakışma yarattıktan sonra, dosyayı favori düzenleyicinizde açın.
Çatışma bir dizi karakterle belirtilecektir:

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_conflict3.png"))
```

*\<\<\<\<\<\<\< HEAD* ve *=======* arasındaki metin yerel deponuzdan gelir ve *=======* ile arasındaki metin *\>\>\>\>\>\>\>* diğer daldan (orijin, master veya seçtiğiniz herhangi bir dal olabilir).

Kodun hangi sürümünü tercih ettiğinize karar vermeniz (veya uygunsa her iki taraftaki değişiklikler de dahil olmak üzere üçüncü bir tane yazmanız), gerisini silmeniz ve Git'in eklediği tüm işaretleri kaldırmanız gerekir *(\<\<\<\<\< \<\< HEAD, =======,\>\>\>\>\>\>\> Origin/master/your_branch_name*).

Ardından, dosyayı kaydedin, düzenleyin ve commit edin: bu, birleştirilmiş sürümü "resmi" yapan committir. Daha sonra itmeyi unutmayın.

Siz ve işbirlikçileriniz ne kadar sık ​​​​çekip iterseniz, çatışmalar o kadar küçük olur.

*Not: Konsolla kendinizi rahat hissediyorsanız, daha fazla [gelişmiş
birleştirme seçenekleri](https://git-scm.com/book/en/v2/Git-Tools-Advanced-Merging) (ör. boşlukları yok sayma, ortak çalışana öncelik verme vb.).*

### Dalınızı silin {.unnumbered}

Bir dal ana dalla birleştirildiğinde ve artık gerekli olmadığında, onu silebilirsiniz.

#### Github + Rstudio

Github'daki depoya gidin ve tüm dalları görüntülemek için düğmeye tıklayın (dalları seçmek için açılır menünün yanında). Şimdi dalınızı bulun ve yanındaki çöp kutusu simgesine tıklayın. Dal silmeyle ilgili daha fazla ayrıntıyı [buradan](https://docs.github.com/en/free-pro-team@latest/github/collaborating-with-issues-and-pull-requests/creating-and-deleting) okuyun -deponuzdaki-dallar#dal silme).

Dalı bilgisayarınızdan yerel olarak da sildiğinizden emin olun. Bu otomatik olarak olmayacak.

- RStudio'dan Ana gövdede olduğunuzdan emin olun.
- RStudio "Terminal"de (R konsolunun bitişiğindeki sekme) Git komutlarını yazmaya geçin ve şunu yazın: **git branch -d branch_name**, burada "branch_name" silinecek dalınızın adıdır
- Git sekmenizi yenileyin, dal gitmiş olmalı


#### Github Masaüstünde

Silmek istediğiniz dalı kontrol edin ve menüye gidin
*Dal\> Sil*.


### Çatallama {.unnumbered}

Bir projeye katkıda bulunmak istiyorsanız, ancak bunu yapma hakkına sahip değilseniz veya sadece kişisel kullanımınız için değiştirmek istiyorsanız, bir projeyi çatallayabilirsiniz. Çatallamanın kısa bir açıklaması [burada](https://guides.github.com/activities/forking/) bulunabilir.

Github'da "Çatal" düğmesine tıklayın:

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_fork_1.png"))
```

Bu, orijinal depoyu klonlayacaktır, ancak kendi profilinizde. Şimdi, Github'da deponun iki sürümü var: değiştiremeyeceğiniz orijinal sürüm ve profilinizdeki klonlanmış sürüm.

Ardından, önceki bölümlerde açıklanan yöntemlerden herhangi birini kullanarak çevrimiçi depo sürümünüzü yerel olarak bilgisayarınızda klonlamaya devam edebilirsiniz. Ardından, yeni bir dal oluşturabilir, değişiklik yapabilir, commit edebilir ve bunları _uzak deponuza_ gönderebilirsiniz.

Sonuçtan memnun kaldığınızda, orijinal deponun sahipleri/koruyucuları ile konuşmaya başlamak için Github veya Github Desktop'tan bir Çekme Talebi oluşturabilirsiniz.

**Ya resmi depodan bazı yeni commitlere ihtiyacınız olursa?**

Birinin, klonlanmış sürümünüze dahil etmek istediğiniz resmi depoda kritik bir değişiklik yaptığını hayal edin. Fork'unuzu resmi depo ile senkronize etmek mümkündür. Terminalin kullanılmasını içerir, ancak çok karmaşık değildir. Çoğunlukla şunu hatırlamanız gerekir:
- _upstream_ = değiştiremeyeceğiniz resmi depo
- _origin_ = Github profilinizdeki depo sürümünüz

[Bu öğreticiyi (https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/syncing-a-fork) okuyabilir veya aşağıdakileri takip edebilirsiniz:

İlk önce Git terminalinizi yazın (deponuzun içine):

```{bash, eval = FALSE}
git remote -v
```
 
Yukarı akış deposunu henüz yapılandırmadıysanız, _Origin_ ile başlayan iki satır görmelisiniz. "fetch" ve "push"un işaret ettiği uzak depoyu gösterirler. Unutmayın, _Origin_, Github'daki deponun kendi sürümünüz için geleneksel takma addır. Örneğin:  

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_fork_2.png"))
```

Şimdi yeni bir uzak depo ekleyin:

```{bash, eval = FALSE}
git remote add upstream https://github.com/appliedepi/epirhandbook_eng.git
```
 
Burada adres, bir depoyu klonladığınızda Github'un ürettiği adrestir (klonlama ile ilgili bölüme bakın). Şimdi dört uzak işaretçiniz olacak:

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_fork_3.png"))
```

Artık kurulum tamamlandığında, değişiklikleri orijinal (_upstream_) deposundan almak istediğinizde, güncellemek istediğiniz dala(_checkout_) gitmeniz ve şunu yazmanız yeterlidir:

```{bash, eval = FALSE}
git fetch upstream # Uzak depodan yeni commitleri alın
git checkout the_branch_you_want_to_update
git merge upstream/the_branch_you_want_to_update  # Yukarı akış dalını kendi dalınızla birleştirin.
git push # Uzak deponun kendi sürümünüzü güncelleyin
```

Çakışmalar varsa, bunları Çakışmaları çözme bölümünde açıklandığı gibi çözmeniz gerekecektir.


**Özet**: çatallama klonlanıyor, ancak Github sunucu tarafında.
Eylemlerin geri kalanı, tipik işbirliği iş akışı eylemleridir.
(klonlama, itme, çekme, commit etme, birleştirme, çekme isteklerini gönderme...).

_Not: forking bir Git komutu değildir bir kavram olsa da, [Bitbucket] https://www.atlassian.com/git/tutorials/comparing-workflows/forking-workflow gibi diğer Web ana bilgisayarlarında da bulunur)._


```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_fork_4.png"))
```


## Öğrendiklerimiz

Şunları nasıl yapacağınızı öğrendiniz:

- Git'i klasörlerinizdeki değişiklikleri takip edecek şekilde ayarlayın,
- yerel deponuzu uzak bir çevrimiçi depoya bağlayın,
- değişiklikleri commit edin,
- yerel ve uzak depolarınızı senkronize edin.

Bütün bunlar sizi harekete geçirmeli ve epidemiyologlar olarak ihtiyaçlarınızın çoğu için yeterli olmalıdır. Genellikle geliştiriciler kadar gelişmiş kullanıma sahip değiliz.

Ancak, daha ileri gitmek isterseniz (veya buna ihtiyaç duyarsanız) Git'in commit geçmişlerini basitleştirmek, bir veya birkaç işlemi geri almak, kesin bir işlem yapmak vb. için daha fazla güç sunduğunu bilin. Bazıları tam bir sihirbazlık gibi gelebilir, ancak şimdi temellere sahipseniz, üzerine inşa etmek daha kolaydır.

Rstudio ve Github Desktop'taki Git bölmesi, çalışma alanımızda yeni başlayanlar / günlük kullanım için iyi olsa da, bazı orta / gelişmiş Git işlevleri için bir arayüz sunmadıklarını unutmayın. Bazı daha eksiksiz arayüzler, işaretle ve tıkla (genellikle daha karmaşık bir düzen pahasına) ile daha fazlasını yapmanıza olanak tanır.

Deponuzu izlemek için herhangi bir noktada herhangi bir aracı kullanabildiğiniz için, bazen denemek veya ara sıra daha az yaygın karmaşık görevleri gerçekleştirmek için bir arabirimi çok kolay bir şekilde kurabileceğinizi ve geri kalan zaman için basitleştirilmiş bir arabirimi tercih edebileceğinizi unutmayın ( örneğin çoğu zaman Github Desktop'ı kullanmak ve bazı özel görevler için SourceTree veya Gitbash'a geçmek).


## Git komutları {#git}


### Önerilen öğrenim {.unnumbered}

Etkileşimli bir eğiticide Git komutlarını öğrenmek için [bu web sitesine](https://learngitbranching.js.org/) bakabilirsiniz.

### Komutların girileceği yer {.unnumbered}

Git kabuğuna komutlar girersiniz.

*Seçenek 1* RStudio'da yeni bir Terminal açabilirsiniz. Bu sekmenin yanında R Konsolu. İçine herhangi bir metin yazamıyorsanız, "Terminal"in altındaki açılır menüye tıklayın ve "Yeni terminal"i seçin. Komutları, dolar işareti "\$" önündeki yanıp sönen boşluğa yazın.

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_terminal.png"))
```

*Seçenek 2* Git sekmesinde (RStudio Ortamı yakınında) mavi "dişliler" simgesine tıklayarak bir *kabuk* (komut girmek için bir terminal) de açabilirsiniz. Açılır menüden "Kabuk" öğesini seçin. "\$" dolar işaretinden sonra komutları yazabileceğiniz yeni bir pencere açılacaktır.

*Seçenek 3* Aynı tür terminali açacak olan "Git Bash burada"yı açmak için sağ tıklayın veya uygulama listenizden *Git Bash*'i açın [Git Bash hakkında daha fazla başlangıç seviyesi bilgisi (https://happygitwithr.com/shell.html), nasıl bulunur ve ihtiyacınız olacak bazı bash komutları.

### Örnek komutlar {.unnumbered}

Aşağıda birkaç yaygın git komutu sunuyoruz. Bunları kullandığınızda, eylemi değiştireceğinden, hangi dalın aktif olduğunu (check-out) aklınızda bulundurun!

Aşağıdaki komutlarda, <name> bir dal adını temsil eder <commit_hash>, belirli bir commitin karma kimliğini temsil eder. <num> bir sayıyı temsil eder. \< veya \> sembollerini yazmayın.

| Git komutları            | Eylem                                                                    |
|--------------------------|--------------------------------------------------------------------------|
| `git branch <name>`      | <name> adıyla yeni bir dal oluşturun                                 |
| `git checkout <name>`    | Geçerli dalı <name> olarak değiştir                                          |
| `git checkout -b <name>` | Yeni dal oluşturmak için kısayol * ve * ona geçiş yapın                         |
| `git status`             | İzlenmeyen değişiklikleri görün                                                    |
| `git add <file>`         | Dosyayı aşamalandırma                                                            |
| `git commit -m <message>`| Şu anda aşamalı değişiklikleri mevcut dalda mesajla commit et |
| `git fetch`              | Uzak depodan değişiklikleri getir                                     |
| `git pull`               | Geçerli daldaki uzak depodan değişiklikleri çekin                   |
| `git push`               | Yerel değişiklikleri uzak dizine itin                          |
| `git switch`             | Git'te aşamalı olarak kullanılan "git checkout"a bir alternatif |
| `git merge <name>`       | <name> dalını geçerli dal ile birleştir                         |
| `git rebase <name>`      | Geçerli daldan değişiklikleri <name> şubesine ekle          |



<!-- ======================================================= -->

## Kaynaklar

Bu sayfanın çoğu, Jenny Bryan'ın [bu "Happy Git with R" web sitesi](https://happygitwithr.com/) çalışmasından faydalanılarak hazırlanmıştır. Bu web sitesinin yaygın Git sorunlarını gidermenize yardımcı olan bölümü ve R ile ilgili hatalara çok yardımcı çözümleri mevcuttur.

[Github.com belgeleri ve başlangıç ​​kılavuzu](https://docs.github.com/en/github).

RStudio ile Git hakkında ipuçları içeren RStudio ["IDE" yardım sayfası](https://www.rstudio.com/wp-content/uploads/2016/01/rstudio-IDE-cheatsheet.pdf).

<https://ohi-science.org/news/github-coming-back-in-time>

**Yeni başlayanlar için Git komutları**

Öğrenmek için bir [etkileşimli öğretici](learngitbranching.js.org)

<https://www.freecodecamp.org/news/an-introduction-to-git-for-absolute-beginners-86fa1d32ff71/>: Kendi bilgisayarınızdaki bir klasördeki değişiklikleri izlemek için mutlak temel bilgileri öğrenmek için iyi.

Dalları anlamak için güzel şemalar: https://speakerdeck.com/alicebartlett/git-for-humans>


**Hem temel hem de ileri düzey konuları kapsayan eğitimler**

<https://tutorialzine.com/2016/06/learn-git-in-30-dakika>

<https://dzone.com/articles/git-tutorial-commands-and-operations-in-git> <https://swcarpentry.github.io/git-novice/> (kısa kurs <https://rsjakob .gitbooks.io/git/content/chapter1.html>

[Pro Git kitabı](https://git-scm.com/book/en/v2) resmi bir referans olarak kabul edilir. Bazı bölümler iyi olsa da, genellikle biraz _teknik_. Git'i biraz kullandıktan ve ne olduğunu ve nasıl daha ileri gidileceğini biraz daha kesin olarak öğrenmek istediğinizde muhtemelen iyi bir kaynaktır.
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/collaboration.Rmd-->


# Yaygın hatalar

Bu sayfa, sık karşılaşılan hataların bir listesini içerir ve bunları gidermek için çözümler önerir.


## Hata mesajlarını yorumlama

R hataları bazen şifreli olabilir, bu nedenle Google sizin arkadaşınızdır. Hata mesajını "R" ile arayın ve [StackExchange.com](StackExchange.com), [stackoverflow.com](stackoverflow.com), [community.rstudio.com](community.rstudio.com)  twitter (#rstats) ve programcılar tarafından soru ve cevapları dosyalamak için kullanılan diğer forumlar içindeki son gönderileri arayın. Benzer sorunları çözen son gönderileri bulmaya çalışın.

Çok fazla arama yaptıktan sonra sorununuza bir yanıt bulamıyorsanız, *tekrarlanabilir bir örnek* ("reprex") oluşturmayı ve soruyu kendiniz göndermeyi düşünün. Tekrarlanabilir bir örneğin nasıl oluşturulacağı ve forumlara nasıl gönderileceğiyle ilgili ipuçları için [Yardım alma] hakkındaki sayfaya bakabilirsiniz.


## Yaygın hatalar

Aşağıda, bazı yaygın hataları ve olası açıklamaları/çözümleri listeliyoruz. Bunlardan bazıları, Stack Overflow'ta R hata mesajları hakkında en yaygın forum gönderilerini analiz eden Noam Ross'tan ödünç alınmıştır (analiz için [buraya](https://github.com/noamross/zero-dependency-problems/blob/master/misc) bakın /stack-overflow-common-r-errors.md))


### Yazım hataları {.unnumbered}

```
Error: unexpected symbol in:
"  geom_histogram(stat = "identity")+
  tidyquant::geom_ma(n=7, size = 2, color = "red" lty"
```
"Beklenmeyen simge" görürseniz, eksik virgül olup olmadığını kontrol edin



### Paket hataları {.unnumbered}  

```
could not find function "x"...
```
Bu muhtemelen fonksiyon adını yanlış yazdığınız veya bir paketi yüklemeyi unuttuğunuz anlamına gelir.

```
Error in select(data, var) : unused argument (var)
```
'dplyr::select()' kullandığınızı düşünüyorsunuz, ancak 'select()' fonksiyonu 'MASS::select()',   'dplyr::' belirten veya dplyr için paketinizi yeniden sipariş eden tarafından maskelenmiştir.

Diğer yaygın maskeleme hataları şunlardan kaynaklanır: "plyr::summarise()" ve "stats::filter()". [**Çatışmalı** paketi](https://www.tidyverse.org/blog/2018/06/conflicted/) kullanmayı düşünün.




```
Error in install.packages : ERROR: failed to lock directory ‘C:\Users\Name\Documents\R\win-library\4.0’ for modifying
Try removing ‘C:\Users\Name\Documents\R\win-library\4.0/00LOCK’
```

Bir "00LOCK" dosyasını kaldırmanız gerektiğini söyleyen bir hata alırsanız, bilgisayar dizininizdeki "R" kitaplığınıza gidin (örn. R/win-library/) ve "00LOCK" adlı bir klasör arayın. Bunu manuel olarak silin ve paketi yeniden yüklemeyi deneyin. Daha önceki bir yükleme işlemi muhtemelen kesintiye uğramıştır ve bu duruma yol açmıştır.




### Nesne hataları {.unnumbered}

```
No such file or directory:
```
Dışa veya içe aktarmaya çalıştığınızda böyle bir hata görürseniz: Dosyanın ve dosya yolunun yazımını kontrol edin ve yol eğik çizgi içeriyorsa bunların ileri `/` olduğundan ve geriye doğru değil `\` olduğundan emin olun. Ayrıca doğru dosya uzantısını (ör. .csv, .xlsx) kullandığınızdan emin olun.


```
object 'x' not found 
```
Bu, başvurduğunuz bir nesnenin mevcut olmadığı anlamına gelir. Belki yukarıdaki kod düzgün çalışmamıştır?  


```
Error in 'x': subscript out of bounds
```
Bu, orada olmayan bir şeye (bir vektörün veya bir listenin öğesi) erişmeye çalıştığınız anlamına gelir.



### Fonksiyon sözdizimi hataları {.unnumbered}

```
# mutate(x = recode(x, OLD= NEW) içindeki x değişkenini yeniden belirtmek için kodu tekrarlayın
Error: Problem with `mutate()` input `hospital`.
x argument ".x" is missing, with no default
i Input `hospital` is `recode(...)`.
```
Sütunun adını ilk değişken olarak sağlamanızı beklediği yerde "recode()" veya "replace_na()" gibi bir fonksiyon sağlıyorsanız, yukarıdaki bu hata ("değişken .x eksik, varsayılan yok") "mutate()"de yaygındır. Bunu unutmak kolaydır.



### Mantık hataları {.unnumbered}
```
Error in if
```

Bu, muhtemelen DOĞRU veya YANLIŞ olmayan bir şeye bir "if" ifadesinin uygulandığı anlamına gelir.


### Faktör hataları {.unnumbered}  

```
#Bir faktöre bir değer ("Eksik") eklemeye çalışın (bir faktör üzerinde çalışan replace_na ile)
'age_cat' girişi 'mutate()' ile ilgili sorun olur.
i invalid factor level, NA generated
i Input `age_cat` is `replace_na(age_cat, "Missing")`.invalid factor level, NA generated
```
Geçersiz faktör seviyeleri hakkında bu hatayı görüyorsanız, muhtemelen bir sınıf Faktör sütununuz (önceden tanımlanmış seviyeleri içeren) var ve ona yeni bir değer eklemeye çalışıyorsunuz. Yeni bir değer eklemeden önce onu Karakter sınıfına dönüştürün.


### Çizim hataları {.unnumbered}

`Error: Insufficient values in manual scale. 3 needed but only 2 provided.`
ggplot() scale_fill_manual() değerleri = c("turuncu", "mor") ... faktör düzeyi sayısı için yetersiz ... NA'nın artık bir faktör düzeyi olup olmadığını düşünün...

```
Can't add x object
```
Muhtemelen silmeniz gereken bir ggplot komutunun sonunda fazladan bir "+" işaretiniz vardır.


### R Markdown hataları {.unnumbered}

Hata mesajı şöyle bir şey içeriyorsa `Error in options[[sprintf("fig.%s", i)]]`, her bir parçanın üstündeki knitr seçeneklerinizin doğru şekilde kullanıldığını kontrol edin. `out.width = ` veya `out.height = ` ve *not* `fig.width=` ve `fig.height=`.

### Çeşitli Konular {.unnumbered}

Tünellenmiş **dplyr** fiillerini yeniden düzenlediğinizi ve ortadaki bir tüneli değiştirmediğinizi veya yeniden düzenledikten sonra tüneli sondan çıkarmadığınızı düşünün.

<!-- ============================================= ========= -->
## Kaynaklar { }

Bu bölüm, [yeni başlayanların karşılaştığı yaygın R programlama hatalarını] listeleyen başka bir blog gönderisidir(https://www.r-bloggers.com/2016/06/common-r-programming-errors-faced-by-beginners/)
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/errors.Rmd-->


# Yardım alma

Bu sayfa, bir Github sorunu göndererek veya çevrimiçi bir foruma tekrarlanabilir bir örnek ("reprex") göndererek nasıl yardım alınacağını anlatmaktadır.

## Github sorunları

Birçok R paketi ve projesinin kodu Github.com web sitesinde barındırılmaktadır. Bir "Sorun" göndererek bu web sitesi aracılığıyla yazarlarla doğrudan iletişim kurabilirsiniz.

Çalışmanızı Github'da nasıl saklayacağınızla ilgili daha fazla bilgiyi [İşbirliği ve Github] sayfasından okuyabilirsiniz.

Github'da her proje bir *depo* içinde bulunur. Her depoda kod, veri, çıktılar, yardım belgeleri vb. bulunur. Ayrıca "Sorunlar" adı verilen yazarlarla iletişim kurmak için bir araç da vardır.

**incidence2** paketi (salgın eğrileri oluşturmak için kullanılır) için Github sayfasının altına bakın. Sarı renkle vurgulanmış "Sorunlar" sekmesini görebilirsiniz. 5 tane açık konu olduğunu görebilirsiniz.

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "errors_Github_issues.png"))
```

Sorunlar sekmesinde, açık sorunları görebilirsiniz. Sorununuzun henüz ele alınmadığından emin olmak için bunları gözden geçirin. Sağdaki yeşil butona tıklayarak yeni bir konu açabilirsiniz. Bunu yapmak için bir Github hesabına ihtiyacınız olacak. 

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "errors_Github_issues2.png"))
```

Sorununuzla ilgili olarak, minimal, tekrarlanabilir bir örnek sağlamak için aşağıdaki talimatları izleyin. Ve lütfen nazik olun! R paketleri ve projeleri geliştiren çoğu kişi boş zamanlarında bunu yapıyor (bu el kitabı gibi!).

Kendi Github deponuzdaki sorunları ele almayla ilgili daha gelişmiş materyalleri okumak için Github [Sorunlarla ilgili belgelere](https://guides.github.com/features/issues/) bakabilirsiniz.


## Tekrarlanabilir örnek

Tekrarlanabilir bir örnek ("reprex") sağlamak, bir forumda veya Github sayısında gönderi yayınlarken yardım almanın anahtarıdır. İnsanlar sana yardım etmek istiyor ama onlara kendi bilgisayarlarında çalışabilecekleri bir örnek vermelisin. Bu örnekte:

* Karşılaştığınız sorunu gösterin
* *Minimal* olun, yalnızca sorununuzu yeniden oluşturmak için gereken verileri ve kodu gönderin
* Tüm nesneler (ör. veri), paket çağrıları (ör. 'library()' veya 'p_load()') dahil edilecek şekilde *tekrarlanabilir* olsun

*Ayrıca, reprex ile herhangi bir hassas veri göndermediğinizden emin olun!* Örnek veri çerçeveleri oluşturabilir veya R'da yerleşik veri çerçevelerinden birini kullanabilirsiniz (bu veri kümelerinin bir listesini açmak için `data()` komutunu girin).


### **reprex** paketi {.unnumbered}

**reprex** paketi, tekrarlanabilir bir örnek oluşturmanıza yardımcı olur:

1) **reprex**, **tidyverse** ile kurulur, bu nedenle her iki paketi de yüklemelisiniz

```{r, eval=F}
# tidyverse kurun/yükleyin (reprex içerir)
pacman::p_load(tidyverse)
```

2) Paketleri ve verileri yüklemekten başlayarak adım adım sorununuzu oluşturan bir R betiği başlatın.

```{r, eval=F}
# paketleri yükleyin
pacman::p_load(
     tidyverse,  # veri yönetimi ve görselleştirme
     outbreaks)  # salgın veri kümelerinin örneği

# grip salgını vaka satır listesi
outbreak_raw <- outbreaks::fluH7N9_china_2013  # salgın paketinden veri kümesini al

# veri kümesini temizle
outbreak <- outbreak_raw %>% 
     mutate(across(contains("date"), as.Date))

# salgın grafiğini çiz

ggplot(data = outbreak)+
     geom_histogram(
          mapping = aes(x = date_of_onset),
          binwidth = 7
     )+
  scale_x_date(
    date_format = "%d %m"
  )

```
Tüm kodu panonuza *kopyalayın* ve aşağıdaki komutu çalıştırın:

```{r, eval=F}
reprex::reprex()
```

RStudio Görüntüleyici bölmesinde bir HTML çıktısının göründüğünü göreceksiniz. Tüm kodunuzu ve tüm uyarıları, hataları veya çizim çıktılarını içerecektir. Bu çıktı aynı zamanda panonuza da kopyalanır, böylece doğrudan bir Github sorununa veya bir forum gönderisine gönderebilirsiniz.

```{r, out.width=c('100%', '100%'), warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "errors_reprex_RStudio1.png"))
```

* 'session_info = TRUE' olarak ayarlarsanız, R paket sürümlerinize 'sessioninfo::session_info()' çıktısı dahil edilecektir.
* `wd =` için bir çalışma dizini sağlayabilirsiniz.
* Değişkenler ve olası varyasyonlar hakkında daha fazla bilgiyi [documentation]() adresinden veya `?reprex` girerek okuyabilirsiniz.

Yukarıdaki örnekte, 'ggplot()' komutu, 'date_format =' değişkeni doğru olmadığı için çalışmadı - 'date_labels = ' olmalı idi.


### Minimum veri {.unnumbered}

Yardımcıların verilerinizi kullanabilmesi gerekir - ideal olarak verileri *kodla* oluşturabilmeleri gerekir.

Minimum bir veri kümesi oluşturmak için, anonimleştirmeyi ve gözlemlerin yalnızca bir alt kümesini kullanmayı düşünün.

YAPIM AŞAMASINDA... - minimal veri kümesi oluşturmak için 'dput()' fonksiyonunu da kullanabilirsiniz.


## Bir foruma gönderme

Bol bol forum yazıları okuyun. Hangi gönderilerin iyi yazıldığını ve hangilerinin yazılmadığını anlayın.

1) İlk olarak, soruyu sorup sormamaya karar verin. Sorunuzun daha önce sorulup sorulmadığını görmek için çeşitli arama terimlerini deneyerek forum web sitesini *iyice* incelediniz mi?

2) Sorunuza bilgilendirici bir başlık verin ("Yardım! Bu çalışmıyor" değil).

3) Sorunuzu yazın:
* Durumunuzu ve probleminizi tanıtın
* Benzer sorunların gönderilerine bağlantı verin ve sorunuzu nasıl yanıtlamadıklarını açıklayın
* Çalışmanızın bağlamını bilmeyen birine yardımcı olmak için ilgili bilgileri ekleyin
* R oturum bilgilerinizle minimum tekrarlanabilir bir örnek verin
* Doğru yazım, dil bilgisi, noktalama işaretleri kullanın ve sorunuzu daha kolay okunabilmesi için paragraflara ayırın

4) Herhangi bir açıklama talebine yanıt vermek için sorunuzu yayınladıktan sonra izleyin. Nazik ve kibar olun - yanıtlayan kişiler genellikle size yardım etmek için zamanlarını gönüllü olarak harcarlar. Takip eden bir sorunuz varsa, bunun ayrı bir soru olması gerekip gerekmediğini düşünün.

5) *eğer* isteği karşılayan bir yanıt alırsanız, soruyu yanıtlandı olarak işaretlemeyi unutmayın. Bu durum, başkalarının çözümü daha sonra hızlı bulmasına yardımcı olur.

[İyi bir soru nasıl sorulur](https://stackoverflow.com/help/how-to-ask) hakkında [Stackoverflow davranış kuralları](https://stackoverflow.com/conduct) hakkındaki bu yayınları okuyun.

<!-- ============================================= ========= -->
## Kaynaklar { }

Nasıl [yardım alacağınız] hakkında Tidyverse sayfası!(https://www.tidyverse.org/help/#:~:text=When%20you%20want%20to%20make,to%20load%20the%20reprex%20package.&text=Enter%20reprex()%20in%20the,preview%20of%20your%20rendered%20reprex.)

[Minimum bir veri kümesi üretmeye](https://xiangxing98.github.io/R_Learning/R_Reproducible.nb.html#production-a-minimal-dataset) ilişkin ipuçları

[dput fonksiyonu](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/dput) için belgeler
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/help.Rmd-->


# Ağ sürücülerinde R { }

## Genel Bakış { }

R'ı ağda veya "şirket" ortak sürücülerinde kullanmak ek zorluklar ortaya çıkarabilir. Bu sayfa, bu sorunlar üzerinde çalışırken edindiğimiz deneyimlerden sorunları gidermeye yönelik yaklaşımları, yaygın hataları ve önerileri içerir. Bölüm ayrıca R Markdown'ı da içeren özellikle hassas durumlar için ipuçları içerir.

**Ağ Sürücülerinde R Kullanımı: Kapsamlı ilkeler**

1) Bilgisayarınız için yönetici erişimi almalısınız. RStudio'yu özellikle yönetici olarak çalışacak şekilde kurun.
2) Mümkün olduğunda paketleri harfli bir sürücüdeki (örneğin "C:") bir kitaplığa kaydedin. Mümkün olduğunca az yolu "\\\" ile başlayan bir paket kitaplığı kullanın.
3) **rmarkdown** paketi bir "\\\" paket kitaplığında **olmamalıdır**, çünkü bu durumda TinyTex veya Pandoc'a bağlanamaz.


## Yönetici olarak RStudio

RStudio'yu açmak için RStudio simgesine tıkladığınızda, bunu sağ tıklatarak yapın. Makinenize bağlı olarak, "Yönetici Olarak Çalıştır" seçeneğini görebilirsiniz. Aksi takdirde, Özellikler'i seçmek için bir seçenek görebilirsiniz (daha sonra "Uyumluluk" seçeneğinin olduğu bir pencere görünmelidir ve "Yönetici Olarak Çalıştır" onay kutusunu seçebilirsiniz).


## Faydalı komutlar

Aşağıda, ağ sürücülerinde R kullanarak sorunları gidermeye yarayan bazı yararlı komutlar verilmiştir.

Yolları R'ın kullandığı paket kitaplıklarına döndürebilirsiniz. Bunlar, R'ın paketleri kurmak/yüklemek/aramak için kullandığı sırayla listelenecektir. Bu nedenle, R'ın farklı bir varsayılan kitaplık kullanmasını istiyorsanız, bu yolların sırasını değiştirebilirsiniz (aşağıya bakın).

```{r, eval=F}
# kitaplığı bul
.libPaths()                   # R'ın yüklediği/aradığı sırayla listelenmiş kitaplık yollarınız.
                              # Not: tüm kitaplıklar listelenecektir, ancak bazılarına (örneğin C :) yüklemek için
                              # RStudio'yu yönetici olarak çalıştırmanız gerekebilir 
                              # (paket kitaplığı açılır menüsü yükleyin)
```

R tarafından kullanılan paket kitaplıklarının sırasını değiştirmek isteyebilirsiniz. Örneğin, R "\\\" ile başlayan ve büyük bir harfle başlayan bir kitaplık konumu alıyorsa, örn. "D:". `.libPaths()` sırasını aşağıdaki kod ile ayarlayabilirsiniz.  

````{r, eval=F}
# Kitaplıkların sırasını değiştir
# bu, R'ın bir paket bulma önceliğini etkileyebilir. Örneğin. C: kitaplığınızın önce listelenmesini isteyebilirsiniz
myPaths <- .libPaths() # yolakları al
myPaths <- c(myPaths[2], myPaths[1]) # değiştir
.libPaths(myPaths) # yeniden ata
```

Pandoc'a bağlanan R Markdown ile ilgili sorunlar yaşıyorsanız, RStudio'nun Pandoc kurulumunuzun nerede olduğunu düşündüğünü öğrenmek için bu kodla başlayın. 

```{r, eval=F}
# Pandoc'u bul
Sys.getenv("RSTUDIO_PANDOC")  # RStudio'nun Pandoc kurulumunuzun nerede olduğunu düşündüğünü bulun
```

Bir paketin hangi kütüphaneden yüklendiğini görmek istiyorsanız aşağıdaki kodu deneyin:

```{r, eval=F}
# bir paket bulun
# paketin ilk konumunu verir (kütüphanelerinizin sırasını not edin)
find.package("rmarkdown", lib.loc = NULL, quiet = FALSE, verbose = getOption("verbose")) 
```

<!-- ======================================================= -->
## Sık karşılaşılan hataları giderme { }


**"rmarkdown'da...tex derlenemedi"**

* TinyTex kurulumunu kontrol edin veya TinyTex'i C: konumuna kurun. TinyTex'in nasıl kurulacağını öğrenmek için [R temelleri] sayfasına bakabilirsiniz.

```{r, eval=F}
# tinytex'i kontrol edin/yükleyin, C: konumuna
tinytex::install_tinytex()
tinytex:::is_tinytex() #  DOĞRU döndürmelidir (üç kolonu da not alın)
```
**İnternet rutinleri yüklenemiyor**

Örneğin, `Error in tools::startDynamicHelp() : internet rutinleri yüklenemiyor`

* Araçlar/Global Seçenekler aracılığıyla RStudio'dan 32 bit sürümü seçmeyi deneyin.
   * not: Menüde 32 bit sürüm görünmüyorsa, RStudio v1.2'yi kullanmadığınızdan emin olun.
* Alternatif olarak, R'ı kaldırıp farklı bir bit sürümüyle yeniden yüklemeyi deneyin (64 yerine 32)

**C: kitaplık paketleri manuel olarak yüklemeye çalıştığımda bir seçenek olarak görünmüyor**

* RStudio'yu yönetici olarak çalıştırın, bu seçenek görünecektir.
* RStudio'yu her zaman yönetici olarak çalışacak şekilde ayarlamak için Rstudio simgesine sağ tıklayın

Aşağıdaki resim, bir paketin kurulacağı kitaplığı manuel olarak nasıl seçebileceğinizi gösterir. Bu pencere, Paketler RStudio bölmesini açtığınızda ve "Yükle" yi tıkladığınızda görünür.

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "network_install.png"))
```

**Pandoc 1 hatası**

Ağ sürücülerinde R Markdowns komut dosyalarını örerken "pandoc hatası 1" alıyorsanız:

* Birden fazla kitaplık konumundan önce harfli sürücüye sahip olanı listeleyin (yukarıdaki kodlara bakın)
* Yukarıdaki çözüm, yerel sürücüde örerken ancak ağ bağlantılı bir internet bağlantısındayken işe yaradı.
* Burada daha fazla ipucu bulabilirsiniz: https://ciser.cornell.edu/rmarkdown-knit-to-html-word-pdf/

**Pandoc Hatası 83**

Hata şuna benzer: `can't find file...rmarkdown...lua...`. Bu, bu dosyayı bulamadığı anlamına gelir.

https://stackoverflow.com/questions/58830927/rmarkdown-unable-to-locate-lua-filter-while-knitting-to-word 'e bakın

Olasılıklar:

1) Rmarkdown paketi kurulu değil
2) Rmarkdown paketi bulunamadı
3) Bir yönetici hakları sorunu.

R'ın **rmarkdown** paket dosyasını bulamaması mümkündür, bu nedenle **rmarkdown** paketinin hangi kütüphanede olduğunu kontrol edin (yukarıdaki koda bakın). Paket, erişilemeyen (örneğin, "\\\" ile başlayan) bir kitaplığa kuruluysa, onu manuel olarak C:'ye veya başka bir adlandırılmış sürücü kitaplığına taşımayı düşünün. **rmarkdown** paketinin TinyTex kurulumuna bağlanabilmesi gerektiğini, bu nedenle bir ağ sürücüsündeki bir kitaplıkta yaşayamayacağını unutmayın.


**Pandoc Hatası 61**

Örneğin: `Error: pandoc document conversion failed with error 61`  or `Could not fetch...`

* RStudio'yu yönetici olarak çalıştırmayı deneyin (simgeye sağ tıklayın, yönetici olarak çalıştır'ı seçin, yukarıdaki talimatlara bakın)
* Ayrıca ulaşılamayan belirli paketin C: kitaplığına taşınıp taşınamayacağına da bakın.

**LaTex hatası (aşağıya bakın)**

Şuna benzer bir hata: `! Package pdftex.def Error: File 'cict_qm2_2020-06-29_files/figure-latex/unnamed-chunk-5-1.png' not found: using draft setting.` or `Error: LaTeX failed to compile file_name.tex.`  

* Hata ayıklama ipuçları için https://yihui.org/tinytex/r/#debugging adresine bakın.
* Daha fazla bilgi için file_name.log'a bakın.


**Pandoc Hatası 127**

Bu bir RAM (boşluk) sorunu olabilir. R oturumunuzu yeniden başlatın ve tekrar deneyin. 


**Ağ sürücülerini eşleme**

Bir ağ sürücüsünü eşlemek riskli olabilir. Bunu denemeden önce bilgi işlem departmanınıza danışın.

Bu [forum tartışmasından] ödünç alınmış bir yorumdur: (https://stackoverflow.com/questions/48161177/r-markdown-openbinaryfile-does-not-exist-no-such-file-or-directory/55616529?noredirect=1#comment97966859_55616529): 

"Eşlenmiş bir ağ sürücüsü aracılığıyla" bir dosya nasıl açılır?

* Öncelikle, erişmeye çalıştığınız ağ konumunu bilmeniz gerekir.
* Ardından, Windows dosya yöneticisinde, sağdaki bölmede "Bu PC"ye sağ tıklamanız ve "Bir ağ sürücüsünü eşle"yi seçmeniz gerekecektir.
* Ağ konumunu daha önce harfli bir sürücü olarak tanımlamak için diyalogu gözden geçirin.
* Artık açtığınız dosyaya ulaşmanın iki yolu var. Sürücü harfi yolunu kullanmak işe yaramalıdır.


**install.packages() dosyasında hata**

Bir "kilit" dizininden bahseden bir hata alırsanız, örneğin:  `Error in install.packages : ERROR: failed to lock directory...`
Paket kitaplığınıza baktığınızda adı "00LOCK" ile başlayan bir klasör göreceksiniz. Aşağıdakileri deneyin:

* "00LOCK" klasör dizinini paket kitaplığınızdan manuel olarak silin. Paketi yeniden yüklemeyi deneyin.
* Ayrıca `pacman::p_unlock()` komutunu da deneyebilirsiniz (bu komutu proje her açıldığında çalışması için Rprofile'e de koyabilirsiniz.). Ardından paketi yeniden yüklemeyi deneyin. Birkaç deneme gerektirebilir.
* RStudio'yu Yönetici modunda çalıştırmayı deneyin ve paketleri tek tek yüklemeyi deneyin.
* Diğerleri başarısız olursa, paketi başka bir kitaplığa veya klasöre (örn. Temp) kurun ve ardından paketin klasörünü istenen kitaplığa manuel olarak kopyalayın.




```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/network_drives.Rmd-->


# Veri tablosu { }
     
El kitabı, verileri temizleme ve gruplama yöntemi olarak **dplyr** “verb” fonksiyonlarına ve **magrittr** tünel operatörü `%>%` üzerine odaklanır, ancak **data.table** paketi kullanabileceğiniz bir alternatif mevcuttur.


## Veri tablolarına giriş { }

Bir veri tablosu, karmaşık gruplama işlemlerinin gerçekleştirilmesine izin veren bir veri çerçevesi gibi 2 boyutlu bir veri yapısıdır. data.table sözdizimi, satırlar, sütunlar ve gruplar üzerinde işlemler gerçekleştirilebilecek şekilde yapılandırılmıştır.

Yapı **DT[i, j, by]** şeklindedir ve 3 parça ile ayrılmıştır; **i, j** ve **by** değişkenleri. **i** değişkeni gerekli satırların alt kümelenmesine, **j** değişkeni sütunlar üzerinde işlem yapmanıza ve **by** değişkeni sütunlar üzerinde gruplara göre işlem yapmanıza olanak tanır.
  
Bu sayfa aşağıdaki konuları ele alacaktır:

* Verileri içe aktarma ve `fread()` ve `fwrite()` kullanımı
* **i** değişkenini kullanarak satırları seçme ve filtreleme
* `%like%`, `%chin%`, `%between%` yardımcı fonksiyonlarını kullanma
* **j** değişkenini kullanarak sütunları seçme ve hesaplama
* **by** değişkenini kullanan gruplara göre hesaplama
* `:=` kullanarak veri tablolarına veri ekleme ve güncelleme

<!-- ======================================================= -->
## Paketleri yükleyin ve verileri içe aktarın { }

### Paketleri yükleyin {.unnumbered}

**pacman**'den `p_load()` fonksiyonunu kullanarak, bu analiz için gerekli paketleri yükleriz (ve gerekirse kurarız).
     
```{r}
pacman::p_load(
  rio,        # verileri içe aktarmak için
  data.table, # verileri gruplamak ve temizlemek için
  tidyverse,  # bu bölümde tünelleme (%>%) fonksiyonunun kullanılmasına izin verir
  here 
  ) 
```


### Verileri içe aktar {.unnumbered}

Bu sayfa, el kitabında atıfta bulunulan vaka satır listesini kullanarak **data.table**'ın bazı temel fonksiyonlarını keşfedecektir.

Simüle edilmiş bir Ebola salgınından vakaların veri setini içe aktarıyoruz. Adım adım izlenecek verileri indirmek istiyorsanız, [Kitap ve verileri indir] sayfasındaki talimatlara bakın. Veri kümesi, **rio** paketinden `import()` fonksiyonu kullanılarak içe aktarılır. Verileri içe aktarmanın çeşitli yolları için [İçe ve dışa aktar] hakkındaki sayfaya bakın. Buradan veri çerçevesini bir veri tablosuna dönüştürmek için `data.table()` kullanıyoruz.

```{r}
linelist <- rio::import(here("data", "linelist_cleaned.xlsx")) %>% data.table()
```

'fread()' fonksiyonu, .csv dosyaları gibi normal sınırlandırılmış dosyaları doğrudan bir veri tablosu biçimine içe aktarmak için kullanılır. Data.tables'ı düzenli sınırlandırılmış dosyalar olarak yazmak için kullanılan bu işlev ve muadili 'fwrite()', büyük veritabanları için çok hızlı ve hesaplama açısından verimli seçeneklerdir.

"linelist"in ilk 20 satırı:

```{r message=FALSE, echo=F, eval=FALSE}
DT::datatable(head(linelist,20), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Veri çerçeveleri için kullanılan 'dim()' gibi R Tabanı komutları, veri tabloları için de kullanılabilir.

```{r}
dim(linelist) #veri tablosundaki satır ve sütun sayısını verir
```

## i değişkeni: satırları seçme ve filtreleme{ }
     
**DT[i, j, by]** yapısını hatırlayarak, satır numaralarını veya mantıksal ifadeleri kullanarak satırları filtreleyebiliriz. i değişkeni ilk; bu nedenle, **DT[i]** veya **DT[i,]** sözdizimi kullanılabilir.

İlk örnek veri tablosunun ilk 5 satırını alır, ikinci örnek alt küme vakaları 18 yaş ve üzeridir ve üçüncü örnek alt kümeler 18 yaş veya üzeri ancak Merkez Hastanede teşhis edilmemiş vakaları içerir:


```{r, eval=F}
linelist[1:5] #1.ila 5. satır arasını getirir
linelist[age >= 18] #alt küme vakaları 18 yaşa eşit veya daha büyük
linelist[age >= 18 & hospital != "Central Hospital"] #18 yaşına eşit veya daha büyük ancak Merkez Hastanede teşhis edilmemiş alt kümeler

```

i bağımsız değişkeninde .N kullanılması, veri tablosundaki toplam satır sayısını temsil eder. Bu, satır numaralarını alt kümelemek için kullanılabilir: 

```{r, eval=F}
linelist[.N] #son satırı getirir
linelist[15:.N] #15. satırdan son satıra kadar getirir
```

###  Filtreleme için yardımcı fonksiyonları kullanma {.unnumbered}

Veri tablosu, alt küme satırlarını kolaylaştıran yardımcı fonksiyonları kullanır. '%like%'  bir sütundaki kalıbı eşleştirmek için kullanılır, '%chin%' belirli bir karakteri eşleştirmek için kullanılır ve '%between%' önceden belirlenmiş bir aralıktaki sayısal sütunları eşleştirmek için kullanılır.

Aşağıdaki örneklerde:
* hastane değişkeninin "Hastane" içerdiği satırları filtreleyin
* sonucun "İyileşme" veya "Ölüm" olduğu satırları filtreleyin
* 40-60 yaş aralığındaki satırları filtreleyin

```{r, eval=F}
linelist[hospital %like% "Hospital"] #hastane değişkeninin "Hastane" içerdiği satırları filtreleyin
linelist[outcome %chin% c("Recover", "Death")] #sonucun "İyileşme" veya "Ölüm" olduğu satırları filtreleyin
linelist[age %between% c(40, 60)] #40-60 yaş aralığındaki satırları filtreleyin

#%between% 2 uzunlukta bir vektör almalıdır, oysa %chin% >= 1 uzunlukta vektörler alabilir

```

## j değişkeni: sütunları seçme ve hesaplama{ }

**DT[i, j, by]** yapısını kullanarak sayıları veya isimleri kullanarak sütunları seçebiliriz. **j** değişkeni ikinci sıradadır; bu nedenle **DT[, j]** sözdizimi kullanılır. **j** değişkenindeki hesaplamaları kolaylaştırmak için, 'list()' ya da '.()' kullanılarak sütun sarılır.


### Sütunları seçme {.unnumbered}

İlk örnek, veri tablosunun birinci, üçüncü ve beşinci sütunlarını alır; ikinci örnek, boy, ağırlık ve cinsiyet sütunları dışındaki tüm sütunları seçer. Üçüncü örnek, **case_id** ve **outcome** sütunlarını seçmek için `.()` sarmasını kullanır.

```{r, eval=F}
linelist[ , c(1,3,5)]
linelist[ , -c("gender", "age", "wt_kg", "ht_cm")]
linelist[ , list(case_id, outcome)] #linelist[ , .(case_id, outcome)] aynı şekilde çalışır

```

###  Sütunlarda hesaplama {.unnumbered}

**i** ve **j** değikenlerini birleştirerek, satırları filtrelemek ve sütunlarda hesaplama yapmak mümkündür. **j** değişkeninde **.N** kullanılması ayrıca veri tablosundaki toplam satır sayısını temsil eder ve satır filtrelemeden sonra satır sayısını döndürmek için yararlı olabilir.

Aşağıdaki örneklerde:
* Hastanede 7 günden fazla kalan vaka sayısını sayın
* Askeri hastanede ölen vakaların yaş ortalamasını hesaplayın
* Merkez hastanede iyileşen vakaların standart sapma, ortanca, yaş ortalamasını hesaplayın

```{r}
linelist[days_onset_hosp > 7 , .N]
linelist[hospital %like% "Military" & outcome %chin% "Death", .(mean(age, na.rm = T))] #na.rm = T siler N/A değerleri
linelist[hospital == "Central Hospital" & outcome == "Recover", 
                 .(mean_age = mean(age, na.rm = T),
                   median_age = median(age, na.rm = T),
                   sd_age = sd(age, na.rm = T))] #bu sözdizimi yardımcı fonksiyonları kullanmaz ancak aynı şekilde çalışır
```

j değişkeninde .() sarma kullanmanın hesaplamayı kolaylaştırdığını, bir veri tablosu döndürdüğünü ve sütun adlandırmasına izin verdiğini unutmayın.

## Değişkene göre: gruplara göre hesaplama{ }

**by** değişkeni, **DT[i, j, by]** yapısındaki üçüncü değişkendir. **by** değişkeni hem bir karakter vektörünü hem de 'list()' veya '.()' sözdizimini kabul eder. **by** değişkeninde `.()` sözdizimini kullanmak, anında sütun yeniden adlandırılmasına izin verir.

Aşağıdaki örneklerde:
* vaka sayısını hastaneye göre gruplandırın
* 18 yaş ve üzeri vakalarda cinsiyete göre vakaların ortalama boy ve kilolarını, iyileşip ölmediklerini hesaplayın
* 7 günü aşan başvurularda, vaka sayısını yattığı aya ve yattığı hastaneye göre sayısını hesaplayın


````{r}
linelist[, .N, .(hospital)] #hastaneye göre vaka sayıları
linelist[age > 18, .(mean_wt = mean(wt_kg, na.rm = T),
                             mean_ht = mean(ht_cm, na.rm = T)), .(gender, outcome)] #NAs, verilerin eksik olduğu kategorileri temsil eder
linelist[days_onset_hosp > 7, .N, .(month = month(date_hospitalisation), hospital)]

```

Data.table ayrıca zincirleme ifadelere aşağıdaki gibi izin verir:

````{r}

linelist[, .N, .(hospital)][order(-N)][1:3] #1. tüm vakaları hastaneye göre seçer, 2. vakaları azalan sırayla sıralar, 3. en büyük vaka yüküne sahip 3 hastaneyi alt kümeler


```

Bu örneklerde, veri tablosundaki bir satırın yeni bir duruma eşit olduğu varsayımını izliyoruz ve bu nedenle veri tablosundaki satır sayısını temsil etmek için **.N**'yi kullanabiliriz. Benzersiz durumların sayısını temsil eden başka bir yararlı fonksiyon, belirli bir girdideki benzersiz değerlerin sayısını döndüren "uniqueN()" dir. Aşağıda gösterilmektedir:

````{r}

linelist[, .(uniqueN(gender))] #hatırlayın .() j değişkeninde bir veri tablosu döndürür

```

Cinsiyet sütunundaki benzersiz değerler m, f ve N/A olduğundan cevap 3'tür. Belirli bir girdideki tüm benzersiz değerleri döndüren temel R fonksiyonu "unique()" ile karşılaştırın:

````{r}

linelist[, .(unique(gender))]
```

Belirli bir aydaki benzersiz vakaların sayısını bulmak için aşağıdakileri yazarız:

````{r}

linelist[, .(uniqueN(case_id)), .(month = month(date_hospitalisation))]

```

## Veri tablolarına ekleme ve güncelleme { }

`:=` operatörü, bir veri tablosuna veri eklemek veya bu tabloya veri güncellemek için kullanılır. Veri tablonuza sütun eklemek aşağıdaki şekillerde yapılabilir:

````{r}

linelist[, adult := age >= 18] #bir sütun ekler
linelist[, c("child", "wt_lbs") := .(age < 18, wt_kg*2.204)] #birden çok sütun eklemek için c("") ve list() veya .() sözdizimi gerekir
linelist[, `:=` (bmi_in_range = (bmi > 16 & bmi < 40),
                         no_infector_source_data = is.na(infector) | is.na(source))] #bu yöntem :='yi fonksiyonel operatör olarak `:=` kullanır
linelist[, adult := NULL] #sütunu siler

```

Daha karmaşık toplamalar bu giriş bölümünün kapsamı dışındadır, ancak buradaki fikir, verileri gruplama ve temizleme için **dplyr**'e popüler ve uygulanabilir bir alternatif sağlamaktır. **data.table** paketi, düzgün ve okunabilir koda izin veren harika bir pakettir.


## Kaynaklar {  }

* https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html
* https://github.com/Rdatatable/data.table
* https://s3.amazonaws.com/assets.datacamp.com/img/blog/data+table+cheat+sheet.pdf
* https://www.machinelearningplus.com/data-manipulation/datatable-in-r-complete-guide/
* https://www.datacamp.com/community/tutorials/data-table-r-tutorial

Gruplandırılmış veriler üzerinde herhangi bir özet fonksiyonu gerçekleştirebilirsiniz; Daha fazla bilgi için buradaki pratik belgeye bakın:
https://s3.amazonaws.com/assets.datacamp.com/blog_assets/datatable_Cheat_Sheet_R.pdf




```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence
clean_names <- janitor::clean_names

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/data_table.Rmd-->

