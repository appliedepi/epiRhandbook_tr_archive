[{"path":"index.html","id":"section","chapter":"","heading":"","text":"","code":""},{"path":"index.html","id":"r-for-applied-epidemiology-and-public-health","chapter":"","heading":"R for applied epidemiology and public health","text":"handbook strives :Serve quick R code reference manualProvide task-centered examples addressing common epidemiological problemsAssist epidemiologists transitioning RBe accessible settings low internet-connectivity via [offline version][Download handbook data] \nWritten epidemiologists, epidemiologistsWe applied epis around world, writing spare time offer resource community. encouragement feedback welcome:Structured feedback formEmail epiRhandbook@gmail.com tweet @epiRhandbookSubmit issues Github repository","code":""},{"path":"index.html","id":"how-to-use-this-handbook","chapter":"","heading":"How to use this handbook","text":"Browse pages Table Contents, use search boxClick “copy” icons copy codeYou can follow-along [example data][Download handbook data]See “Resources” section page materialOffline versionSee instructions [Download handbook data] page.LanguagesWe want translate languages English. can help, please contact us.","code":""},{"path":"index.html","id":"acknowledgements","chapter":"","heading":"Acknowledgements","text":"handbook produced collaboration epidemiologists around world drawing upon experience organizations including local, state, provincial, national health agencies, World Health Organization (), Médecins Sans Frontières / Doctors without Borders (MSF), hospital systems, academic institutions.handbook approved product specific organization. Although strive accuracy, provide guarantee content book.","code":""},{"path":"index.html","id":"contributors","chapter":"","heading":"Contributors","text":"Editor: Neale BatraProject core team: Neale Batra, Alex Spina, Amrish Baidjoe, Pat Keating, Henry Laurenson-Schafer, Finlay CampbellAuthors: Neale Batra, Alex Spina, Paula Blomquist, Finlay Campbell, Henry Laurenson-Schafer, Isaac Florence, Natalie Fischer, Aminata Ndiaye, Liza Coyer, Jonathan Polonsky, Yurie Izawa, Chris Bailey, Daniel Molling, Isha Berry, Emma Buajitti, Mathilde Mousset, Sara Hollis, Wen LinReviewers: Pat Keating, Annick Lenglet, Margot Charette, Danielly Xavier, Esther Kukielka, Michelle Sloan, Aybüke Koyuncu, Rachel Burke, Kate Kelsey, Berhe Etsay, John Rossow, Mackenzie Zendt, James Wright, Laura Haskins, Flavio Finger, Tim Taylor, Jae Hyoung Tim Lee, Brianna Bradley, Wayne Enanoria, Manual Albela Miranda, Molly Mantus, Pattama Ulrich, Joseph Timothy, Adam Vaughan, Olivia Varsaneux, Lionel Monteiro, Joao MuiangaIllustrations: Calder Fong","code":""},{"path":"index.html","id":"funding-and-support","chapter":"","heading":"Funding and support","text":"handbook received supportive funding via COVID-19 emergency capacity-building grant TEPHINET, global network Field Epidemiology Training Programs (FETPs).Administrative support provided EPIET Alumni Network (EAN), special thanks Annika Wendland. EPIET European Programme Intervention Epidemiology Training.Special thanks Médecins Sans Frontières (MSF) Operational Centre Amsterdam (OCA) support development handbook.publication supported Cooperative Agreement number NU2GGH001873, funded Centers Disease Control Prevention TEPHINET, program Task Force Global Health. contents solely responsibility authors necessarily represent official views Centers Disease Control Prevention, Department Health Human Services, Task Force Global Health, Inc. TEPHINET.","code":""},{"path":"index.html","id":"inspiration","chapter":"","heading":"Inspiration","text":"multitude tutorials vignettes provided knowledge development handbook content credited within respective pages.generally, following sources provided inspiration handbook:“R4Epis” project (collaboration MSF RECON)R Epidemics Consortium (RECON)R Data Science book (R4DS)bookdown: Authoring Books Technical Documents R MarkdownNetlify hosts website","code":""},{"path":"index.html","id":"terms-of-use-and-contribution","chapter":"","heading":"Terms of Use and Contribution","text":"","code":""},{"path":"index.html","id":"license","chapter":"","heading":"License","text":"work licensed Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.Academic courses epidemiologist training programs welcome use handbook students. questions intended use, email epiRhandbook@gmail.com.","code":""},{"path":"index.html","id":"citation","chapter":"","heading":"Citation","text":"Batra, Neale, et al. Epidemiologist R Handbook. 2021. ","code":""},{"path":"index.html","id":"contribution","chapter":"","heading":"Contribution","text":"like make content contribution, please contact us first via Github issues email. implementing schedule updates creating contributor guide.Please note epiRhandbook project released Contributor Code Conduct. contributing project, agree abide terms.","code":""},{"path":"önyazı-ve-teknik-notlar.html","id":"önyazı-ve-teknik-notlar","chapter":"1 Önyazı ve teknik notlar","heading":"1 Önyazı ve teknik notlar","text":"Bu sayfada, el kitabının hazırlanması sırasında belirlediğimiz felsefi yaklaşıma, stile ve belirli editoryal kararlara değineceğiz.","code":""},{"path":"önyazı-ve-teknik-notlar.html","id":"yaklaşım-ve-stil","chapter":"1 Önyazı ve teknik notlar","heading":"1.1 Yaklaşım ve stil","text":"Bu kitabın potansiyel hedef kitlesinin geniş olmasını istedik. Hem R’yeni olan kişiler tarafından hem de “R’ın iyi uygulamalarını” ve “R’ın ipuçlarını” öğrenmek isteyen deneyimli kullanıcıların bu kitaptan faydalanabilmesini istedik. Kitap hem kolayca erişilebilir hem de az ve öz olmalıydı. Bu nedenle yaklaşımımızı, R’de çok yeni olan birinin kodu uygulayabileceği ve kodun ne yaptığını takip edebileceği yeterli metin açıklamasını sağlamak olarak belirledik.Bir kaç nokta daha:Nispeten kısa örneklerin eşlik ettiği bir kod referans kitabı olarak tasarlanmıştır - R , veri bilimi üzerine kapsamlı bir ders kitabı değildir.Uygulamalı epidemiyolojide kullanmanız için R el kitabı olarak kapsamı sınırlandırılmıştır - uygulamalı epidemiyoloji yöntemleri veya bilimi hakkında bir kılavuz değil.Bu el kitabının yaşayan bir belge olması amaçlanmıştır - belirli görevler için hazırlanan R paketleri sıklıkla güncellenir ve değişir. Bu kitapta hangilerine yer vermemiz gerektiğine dair öneri ve eleştirilerinizi memnuniyetle öğrenmek isteriz.","code":""},{"path":"önyazı-ve-teknik-notlar.html","id":"r-paketleri","chapter":"1 Önyazı ve teknik notlar","heading":"R paketleri","text":"Çok fazla seçenekR öğrenmenin en zorlu yönlerinden biri de hangi R paketinin kullanılacağını bilmektir. Bir işi çözmeye çalışırken “Hey, bunların hepsini tek bir komut satırında yapan bir R paketi var!” demeniz nadir bir durum olmayacaktır.Bu el kitabında, görevi tamamlamanız için size en az iki yol sunmaya çalıştık: ilki denenmiş ve doğrulanmış bir yöntem (muhtemelen base R veya tidyverse içinde) ve ikincisi o iş için özel olarak tasarlanmış bir R paketi. Belirli bir pakette sorun yaşamanız halinde birden fazla seçeneğe sahip olmanızı istiyoruz.Paketleri belirlerken, R topluluğu tarafından test edilmiş ve onaylanmış paketlere ve yaklaşımlara öncelik verdik. Rutin bir çalışma oturumunda işinize yarayacak, stabil (çok sık değişmeyen) ve görevi basit ve temiz bir şekilde yerine getirebilecek minimal sayıda paket kullandık.Bu el kitabı tidyverse’de bulunan R paket ve işlevlerine öncelik verir. Tidyverse, temel dilbilgisi ve veri yapılarını paylaşan veri bilimi için tasarlanmış bir R paketi koleksiyonudur. Tüm tidyverse paketleri, tidyverse paketi aracılığıyla kurulabilir veya yüklenebilir. Tidyverse’n web sitesinde daha fazlasını okuyabilirsiniz.Uygun yerlerde, kurulum sırasında R ile birlikte yüklenen base paket ve fonksiyonlarıyla ilişkili kod seçeneklerini de ekledik. Bunu, bu kitabın okuyucularından bazılarının ekstra paketleri indirmek için güvenilir bir internete sahip ol()mama ihtimaline karşılık yaptık.Fonksiyonları paketlerle ilişkilendirmeR eğitim ve rehberlerinde bir fonksiyona ilişkin kodun anlatılıp, kullanılan paketin hiç değinilmemesine şahit olmuşsunuzdur. Bu durum sinir bozucudur! İşte biz bunu size yaşatmaktan kaçınmaya çalıştık.Açıklama metinlerinde paket adları kalın harflerle (örn. dplyr) ve fonksiyonları mutate() şeklinde yazılır. Bir fonksiyonun hangi paketten geldiğini, ya en yakındaki metinde referanslayarak ya da kodu dplyr::mutate() şeklinde yazarak size açıklamaya çalıştık. Başta gereksiz görünebilir ancak bunu yukarıda bahsettiğimiz amaç doğrultusunda, bilerek yapıyoruz.Paketler ve fonksiyonları hakkında daha fazla bilgi edinmek için [R basics] sayfasına bakabilirsiniz.","code":""},{"path":"önyazı-ve-teknik-notlar.html","id":"kodlama-stili","chapter":"1 Önyazı ve teknik notlar","heading":"Kodlama stili","text":"El kitabında sık sık “yeni satırlar” kullanıyoruz, bu da kodumuzun “uzun” görünmesine neden olabiliyor. Bunun birkaç sebebi var:Kodun küçük parçasına bitişik # ile açıklayıcı yorumlar yazabiliriz.Genellikle daha uzun (dikey) kodun okunması daha kolaydır.Kodların dar bir ekranda okunması daha kolaydır (ekranı yana kaydırmanıza gerek kalmaz).Girintiler sayesinde hangi argümanların hangi fonksiyona ait olduğunu daha kolay anlayabilirsiniz.Sonuç olarak, aşağıdaki gibi yazılabilecek kod:…şu şekilde yazılır:R kodu genel olarak yeni satır veya girintilerden etkilenmez. Kodu yazarken, virgülden sonra yeni bir satır başlatırsanız, program yeni satıra otomatik girinti uygular.Ayrıca, okunması daha kolay olduğu için kodu yazarken birçok boşluk kullandık (örneğin, ‘n=1’ yerine ‘n = 1’). Siz de kodunuzu yazarken onu okuyabilecek insanları düşünerek yazmalısınız!","code":"\nlinelist %>% \n  group_by(hospital) %>%  # satırları hastane (hospital) olarak gruplandır\n  slice_max(date, n = 1, with_ties = F) # eğer tarih (date) ile eşleşirse ilk satırı al\nlinelist %>% \n  group_by(hospital) %>% # satırları hastane (hospital) olarak gruplandır\n  slice_max(\n    date,                # maksimum tarih değerine grubu sırala\n    n = 1,               # gruptaki satırlardan sadece ilkini al \n    with_ties = F)       # eğer tarih (date) ile eşleşirse ilk satırı al"},{"path":"önyazı-ve-teknik-notlar.html","id":"terminoloji","chapter":"1 Önyazı ve teknik notlar","heading":"Terminoloji","text":"Bu el kitabında, genellikle “değişkenler” ve “gözlemler” yerine “sütunlar” ve “satırlar”atıfta bulunuyoruz. “Tidy verileri” ile ilgili bu makalede açıklandığı gibi, epidemiyolojik istatistiksel veri setlerinin çoğu yapısal olarak satır, sütun ve değerlerden oluşur.Değişkenler aynı temel özelliği ölçen değerleri içerir (yaş grubu, çıktı veya başlangıç tarihi gibi). Gözlemler aynı birimde ölçülen tüm değerleri içerir (örneğin bir kişi, alan veya laboratuvar numunesi vb.). Dolayısıyla bu yönleri somut olarak tanımlamak daha zor olabilmektedir.“Tidy” veri kümelerinde sütun bir değişken, satır bir gözlem ve hücre de tek bir değeri ifade etmektedir. Ancak karşılaştığınız bazı veri kümeleri bu kalıba sığmaz - “geniş” biçimli bir veri kümesinin birkaç sütuna bölünebilen değişkenleri olabilir ([Pivoting data] sayfasındaki bir örneğe bakın). Benzer şekilde, gözlemler de birkaç satıra bölünebilir.Bu el kitabı çoğunlukla, verileri yönetmek ve işlemek üzerine odaklanmıştır. O nedenle satır ve sütunlarda somut verilere atıfta bulunmayı, daha soyut olan “gözlem” ve “değişkenler”e tercih ettik. Bu yaklaşımımızın istisnası, daha fazla değişken ve gözlem referansıyla karşılaşacağınız veri analizi sayfalarıdır.","code":""},{"path":"önyazı-ve-teknik-notlar.html","id":"notlar","chapter":"1 Önyazı ve teknik notlar","heading":"Notlar","text":"El kitabında karşılaşabileceğiniz türleri şunlardır:: Bu bir nottur.İPUCU: Bu bir ipucudur.DİKKAT: Bu dikkatli yaklaşmanızı tavsiye eden bir nottur.TEHLİKE: Bu bir uyarıdır.","code":""},{"path":"önyazı-ve-teknik-notlar.html","id":"editöryal-kararlar","chapter":"1 Önyazı ve teknik notlar","heading":"1.2 Editöryal Kararlar","text":"Aşağıda, paket ve işlev seçimiyle ilgili önemli editoryal kararları sizinle paylaşıyoruz. Bizimle aynı fikirde değilseniz veya değerlendirilmesi için yeni bir araç önermek isterseniz, lütfen Github sayfamıza katılın ve yeni bir sohbet başlatın.Paket, fonksiyon ve diğer editoryal kararlar tablosu","code":""},{"path":"önyazı-ve-teknik-notlar.html","id":"büyük-güncellemeler","chapter":"1 Önyazı ve teknik notlar","heading":"1.3 Büyük güncellemeler","text":"","code":""},{"path":"önyazı-ve-teknik-notlar.html","id":"oturum-bilgisi-r-rstudio-packages","chapter":"1 Önyazı ve teknik notlar","heading":"1.4 Oturum bilgisi (R, RStudio, packages)","text":"Aşağıda, bu el Kitabının hazırlanması sırasında kullanılan R, RStudio, R paketleri ve sürümlerine ilişkin bilgiler yer almaktadır.","code":"\nsessioninfo::session_info()## ─ Session info ──────────────────────────────────────────────────────────────────────────────────────────────────────\n##  setting  value\n##  version  R version 4.2.1 (2022-06-23 ucrt)\n##  os       Windows 10 x64 (build 22000)\n##  system   x86_64, mingw32\n##  ui       RStudio\n##  language (EN)\n##  collate  English_United States.utf8\n##  ctype    English_United States.utf8\n##  tz       Europe/Berlin\n##  date     2022-11-20\n##  rstudio  2022.07.1+554 Spotted Wakerobin (desktop)\n##  pandoc   2.18 @ C:/Program Files/RStudio/bin/quarto/bin/tools/ (via rmarkdown)\n## \n## ─ Packages ──────────────────────────────────────────────────────────────────────────────────────────────────────────\n##  ! package              * version    date (UTC) lib source\n##    abind                * 1.4-5      2016-07-21 [1] CRAN (R 4.2.0)\n##    ada                    2.0-5      2016-05-13 [1] CRAN (R 4.2.2)\n##    adagio                 0.8.5      2022-10-03 [1] CRAN (R 4.2.1)\n##    ade4                   1.7-20     2022-11-01 [1] CRAN (R 4.2.2)\n##    anytime                0.3.9      2020-08-27 [1] CRAN (R 4.2.1)\n##    ape                  * 5.6-2      2022-03-02 [1] CRAN (R 4.2.1)\n##    aplot                  0.1.7      2022-09-06 [1] CRAN (R 4.2.1)\n##    apyramid             * 0.1.2      2022-08-26 [1] Github (R4EPI/apyramid@c4114cc)\n##    assertive.base         0.0-9      2021-02-08 [1] CRAN (R 4.2.2)\n##    assertive.properties   0.0-5      2022-04-21 [1] CRAN (R 4.2.2)\n##    assertive.types        0.0-3      2016-12-30 [1] CRAN (R 4.2.2)\n##    assertthat             0.2.1      2019-03-21 [1] CRAN (R 4.2.1)\n##    aweek                * 1.0.2      2021-01-04 [1] CRAN (R 4.2.1)\n##    backports              1.4.1      2021-12-13 [1] CRAN (R 4.2.0)\n##    base64enc              0.1-3      2015-07-28 [1] CRAN (R 4.2.0)\n##    bayestestR           * 0.13.0     2022-09-18 [1] CRAN (R 4.2.1)\n##    bit                  * 4.0.4      2020-08-04 [1] CRAN (R 4.2.1)\n##    bit64                  4.0.5      2020-08-30 [1] CRAN (R 4.2.1)\n##    blob                   1.2.3      2022-04-10 [1] CRAN (R 4.2.1)\n##    bookdown               0.28       2022-08-09 [1] CRAN (R 4.2.1)\n##    boot                 * 1.3-28     2021-05-03 [2] CRAN (R 4.2.1)\n##    broom                * 1.0.1      2022-08-29 [1] CRAN (R 4.2.1)\n##    broom.helpers          1.9.0      2022-09-23 [1] CRAN (R 4.2.1)\n##    bslib                  0.4.0      2022-07-16 [1] CRAN (R 4.2.1)\n##    cachem                 1.0.6      2021-08-19 [1] CRAN (R 4.2.1)\n##    callr                  3.7.2      2022-08-22 [1] CRAN (R 4.2.1)\n##    car                    3.1-0      2022-06-15 [1] CRAN (R 4.2.1)\n##    carData                3.0-5      2022-01-06 [1] CRAN (R 4.2.1)\n##    cellranger             1.1.0      2016-07-27 [1] CRAN (R 4.2.1)\n##    class                  7.3-20     2022-01-16 [2] CRAN (R 4.2.1)\n##    classInt               0.4-7      2022-06-10 [1] CRAN (R 4.2.1)\n##    cli                    3.4.1      2022-09-23 [1] CRAN (R 4.2.1)\n##    clock                  0.6.1      2022-07-18 [1] CRAN (R 4.2.1)\n##    cmprsk                 2.2-11     2022-01-06 [1] CRAN (R 4.2.2)\n##    coarseDataTools        0.6-6      2021-12-09 [1] CRAN (R 4.2.1)\n##    coda                   0.19-4     2020-09-30 [1] CRAN (R 4.2.1)\n##    codetools              0.2-18     2020-11-04 [2] CRAN (R 4.2.1)\n##    colorspace             2.0-3      2022-02-21 [1] CRAN (R 4.2.1)\n##    commonmark             1.8.0      2022-03-09 [1] CRAN (R 4.2.1)\n##    correlation          * 0.8.2      2022-08-09 [1] CRAN (R 4.2.1)\n##    corrr                * 0.4.4      2022-08-16 [1] CRAN (R 4.2.1)\n##    cowplot              * 1.1.1      2020-12-30 [1] CRAN (R 4.2.1)\n##    crayon                 1.5.2      2022-09-29 [1] CRAN (R 4.2.1)\n##    crosstalk              1.2.0      2021-11-04 [1] CRAN (R 4.2.1)\n##    curl                   4.3.2      2021-06-23 [1] CRAN (R 4.2.1)\n##    data.table             1.14.2     2021-09-27 [1] CRAN (R 4.2.1)\n##    datawizard           * 0.6.1      2022-09-25 [1] CRAN (R 4.2.1)\n##    DBI                  * 1.1.3      2022-06-18 [1] CRAN (R 4.2.1)\n##    dbplyr                 2.2.1      2022-06-27 [1] CRAN (R 4.2.1)\n##    deldir                 1.0-6      2021-10-23 [1] CRAN (R 4.2.0)\n##    Deriv                  4.1.3      2021-02-24 [1] CRAN (R 4.2.1)\n##    DiagrammeR           * 1.0.9      2022-03-05 [1] CRAN (R 4.2.1)\n##    dichromat              2.0-0.1    2022-05-02 [1] CRAN (R 4.2.0)\n##    digest                 0.6.29     2021-12-01 [1] CRAN (R 4.2.1)\n##    distcrete            * 1.0.3      2017-11-23 [1] CRAN (R 4.2.1)\n##    distributional         0.3.1      2022-09-02 [1] CRAN (R 4.2.2)\n##    doBy                 * 4.6.13     2022-05-02 [1] CRAN (R 4.2.1)\n##    doParallel             1.0.17     2022-02-07 [1] CRAN (R 4.2.2)\n##    downlit                0.4.2      2022-07-05 [1] CRAN (R 4.2.1)\n##    dplyr                * 1.0.10     2022-09-01 [1] CRAN (R 4.2.1)\n##    dsr                  * 0.2.2      2019-08-23 [1] Github (cran/dsr@f5e1c3f)\n##    DT                   * 0.24       2022-08-09 [1] CRAN (R 4.2.1)\n##    e1071                  1.7-11     2022-06-07 [1] CRAN (R 4.2.1)\n##    easystats            * 0.5.2      2022-08-30 [1] CRAN (R 4.2.1)\n##    ecmwfr               * 1.4.0      2022-08-17 [1] CRAN (R 4.2.2)\n##    effectsize           * 0.7.0.5    2022-08-10 [1] CRAN (R 4.2.1)\n##    ellipsis               0.3.2      2021-04-29 [1] CRAN (R 4.2.1)\n##    Epi                  * 2.47       2022-06-26 [1] CRAN (R 4.2.2)\n##    epicontacts          * 1.2.0      2022-11-20 [1] Github (reconhub/epicontacts@c5cd648)\n##    epidict                0.0.0.9001 2022-09-29 [1] Github (R4EPI/epidict@9cf5a53)\n##    EpiEstim             * 2.2-4      2021-01-07 [1] CRAN (R 4.2.1)\n##    epikit               * 0.1.4      2022-09-29 [1] Github (R4EPI/epikit@f2f6c6c)\n##    EpiNow2              * 1.3.2      2020-12-14 [1] CRAN (R 4.2.1)\n##    epitabulate            0.0.0.9007 2022-09-29 [1] Github (R4EPI/epitabulate@fa6338c)\n##    epitrix              * 0.2.2      2019-01-15 [1] CRAN (R 4.2.1)\n##    etm                    1.1.1      2020-09-08 [1] CRAN (R 4.2.2)\n##    evaluate               0.16       2022-08-09 [1] CRAN (R 4.2.1)\n##    evd                    2.3-6.1    2022-07-04 [1] CRAN (R 4.2.2)\n##    fabletools           * 0.3.2      2021-11-29 [1] CRAN (R 4.2.2)\n##    FactoClass             1.2.7      2018-10-01 [1] CRAN (R 4.2.2)\n##    fansi                  1.0.3      2022-03-24 [1] CRAN (R 4.2.1)\n##    farver                 2.1.1      2022-07-06 [1] CRAN (R 4.2.1)\n##    fastLink             * 0.6.0      2020-04-29 [1] CRAN (R 4.2.2)\n##    fastmap                1.1.0      2021-01-25 [1] CRAN (R 4.2.1)\n##    feasts               * 0.3.0      2022-09-01 [1] CRAN (R 4.2.2)\n##    ff                   * 4.0.7      2022-05-06 [1] CRAN (R 4.2.2)\n##    fitdistrplus           1.1-8      2022-03-10 [1] CRAN (R 4.2.1)\n##    flextable            * 0.8.2      2022-09-26 [1] CRAN (R 4.2.1)\n##    forcats              * 0.5.2      2022-08-19 [1] CRAN (R 4.2.1)\n##    foreach                1.5.2      2022-02-02 [1] CRAN (R 4.2.1)\n##    forecast             * 8.18       2022-10-02 [1] CRAN (R 4.2.2)\n##    foreign                0.8-82     2022-01-16 [2] CRAN (R 4.2.1)\n##    formatR                1.12       2022-03-31 [1] CRAN (R 4.2.1)\n##    formattable          * 0.2.1      2021-01-07 [1] CRAN (R 4.2.2)\n##    Formula              * 1.2-4      2020-10-16 [1] CRAN (R 4.2.0)\n##    fracdiff               1.5-2      2022-10-31 [1] CRAN (R 4.2.2)\n##    frailtypack          * 3.5.0      2021-12-20 [1] CRAN (R 4.2.1)\n##    fs                   * 1.5.2      2021-12-08 [1] CRAN (R 4.2.1)\n##    futile.logger          1.4.3      2016-07-10 [1] CRAN (R 4.2.1)\n##    futile.options         1.0.1      2018-04-20 [1] CRAN (R 4.2.0)\n##    future                 1.28.0     2022-09-02 [1] CRAN (R 4.2.1)\n##    future.apply           1.9.1      2022-09-07 [1] CRAN (R 4.2.1)\n##    gargle                 1.2.0      2021-07-02 [1] CRAN (R 4.2.1)\n##    gdtools                0.2.4      2022-02-14 [1] CRAN (R 4.2.1)\n##    generics               0.1.3      2022-07-05 [1] CRAN (R 4.2.1)\n##    ggExtra              * 0.10.0     2022-03-23 [1] CRAN (R 4.2.1)\n##    ggforce              * 0.4.1      2022-10-04 [1] CRAN (R 4.2.2)\n##    ggfun                  0.0.7      2022-08-31 [1] CRAN (R 4.2.1)\n##    gghighlight          * 0.3.3      2022-06-06 [1] CRAN (R 4.2.1)\n##    ggnewscale           * 0.4.7      2022-03-25 [1] CRAN (R 4.2.1)\n##    ggplot2              * 3.4.0      2022-11-04 [1] CRAN (R 4.2.2)\n##    ggplotify              0.1.0      2021-09-02 [1] CRAN (R 4.2.1)\n##    ggpubr               * 0.5.0      2022-11-16 [1] CRAN (R 4.2.1)\n##    ggrepel              * 0.9.1      2021-01-15 [1] CRAN (R 4.2.1)\n##    ggsignif               0.6.4      2022-10-13 [1] CRAN (R 4.2.2)\n##    ggtext                 0.1.2      2022-09-16 [1] CRAN (R 4.2.2)\n##    ggtree               * 3.4.4      2022-09-27 [1] Bioconductor\n##    ggupset              * 0.3.0      2020-05-05 [1] CRAN (R 4.2.2)\n##    globals                0.16.1     2022-08-28 [1] CRAN (R 4.2.1)\n##    glue                   1.6.2      2022-02-24 [1] CRAN (R 4.2.1)\n##    googledrive            2.0.0      2021-07-08 [1] CRAN (R 4.2.1)\n##    googlesheets4          1.0.0      2021-07-21 [1] CRAN (R 4.2.1)\n##    grates                 0.3.0      2021-10-21 [1] CRAN (R 4.2.1)\n##    gridExtra              2.3        2017-09-09 [1] CRAN (R 4.2.1)\n##    gridGraphics           0.5-1      2020-12-13 [1] CRAN (R 4.2.1)\n##    gridtext               0.1.5      2022-09-16 [1] CRAN (R 4.2.2)\n##    gt                     0.7.0      2022-08-25 [1] CRAN (R 4.2.1)\n##    gtable                 0.3.1      2022-09-01 [1] CRAN (R 4.2.1)\n##    gtools                 3.9.3      2022-07-11 [1] CRAN (R 4.2.2)\n##    gtsummary            * 1.6.2      2022-09-30 [1] CRAN (R 4.2.2)\n##    haven                  2.5.1      2022-08-22 [1] CRAN (R 4.2.1)\n##    here                 * 1.0.1      2020-12-13 [1] CRAN (R 4.2.1)\n##    highr                  0.9        2021-04-16 [1] CRAN (R 4.2.1)\n##    hms                    1.1.2      2022-08-19 [1] CRAN (R 4.2.1)\n##    htmltools              0.5.3      2022-07-18 [1] CRAN (R 4.2.1)\n##    htmlwidgets            1.5.4      2021-09-08 [1] CRAN (R 4.2.1)\n##    httpuv                 1.6.6      2022-09-08 [1] CRAN (R 4.2.1)\n##    httr                   1.4.4      2022-08-17 [1] CRAN (R 4.2.1)\n##    i2extras             * 0.1.2      2021-07-08 [1] CRAN (R 4.2.1)\n##    igraph                 1.3.5      2022-09-22 [1] CRAN (R 4.2.1)\n##    imputeTS             * 3.3        2022-09-09 [1] CRAN (R 4.2.2)\n##    incidence              1.7.3      2020-11-04 [1] CRAN (R 4.2.1)\n##    incidence2           * 1.2.3      2021-11-07 [1] CRAN (R 4.2.1)\n##    inline                 0.3.19     2021-05-31 [1] CRAN (R 4.2.1)\n##    insight              * 0.18.4     2022-09-20 [1] CRAN (R 4.2.1)\n##    ipred                  0.9-13     2022-06-02 [1] CRAN (R 4.2.1)\n##    isoband                0.2.5      2021-07-13 [1] CRAN (R 4.2.1)\n##    iterators              1.0.14     2022-02-05 [1] CRAN (R 4.2.1)\n##    janitor              * 2.1.0      2021-01-05 [1] CRAN (R 4.2.1)\n##    jpeg                   0.1-9      2021-07-24 [1] CRAN (R 4.2.0)\n##    jquerylib              0.1.4      2021-04-26 [1] CRAN (R 4.2.1)\n##    jsonlite               1.8.0      2022-02-22 [1] CRAN (R 4.2.1)\n##    kableExtra           * 1.3.4      2021-02-20 [1] CRAN (R 4.2.1)\n##    KernSmooth             2.23-20    2021-05-03 [2] CRAN (R 4.2.1)\n##    km.ci                  0.5-6      2022-04-06 [1] CRAN (R 4.2.2)\n##    KMsurv                 0.1-5      2012-12-03 [1] CRAN (R 4.2.0)\n##    knitr                  1.40       2022-08-24 [1] CRAN (R 4.2.1)\n##    labeling               0.4.2      2020-10-20 [1] CRAN (R 4.2.0)\n##    labelled               2.10.0     2022-09-14 [1] CRAN (R 4.2.1)\n##    lambda.r               1.2.4      2019-09-18 [1] CRAN (R 4.2.1)\n##    later                  1.3.0      2021-08-18 [1] CRAN (R 4.2.1)\n##    lattice                0.20-45    2021-09-22 [2] CRAN (R 4.2.1)\n##    lava                   1.6.10     2021-09-02 [1] CRAN (R 4.2.1)\n##    lazyeval               0.2.2      2019-03-15 [1] CRAN (R 4.2.1)\n##    leafem                 0.2.0      2022-04-16 [1] CRAN (R 4.2.1)\n##    leaflet                2.1.1      2022-03-23 [1] CRAN (R 4.2.1)\n##    leaflet.providers      1.9.0      2019-11-09 [1] CRAN (R 4.2.1)\n##    leafsync               0.1.0      2019-03-05 [1] CRAN (R 4.2.1)\n##    lifecycle              1.0.3      2022-10-07 [1] CRAN (R 4.2.2)\n##    linelist             * 0.0.1      2022-05-13 [1] CRAN (R 4.2.1)\n##    listenv                0.8.0      2019-12-05 [1] CRAN (R 4.2.1)\n##    lmtest               * 0.9-40     2022-03-21 [1] CRAN (R 4.2.1)\n##    loo                    2.5.1      2022-03-24 [1] CRAN (R 4.2.1)\n##    lpSolve                5.6.17     2022-10-10 [1] CRAN (R 4.2.1)\n##    lubridate            * 1.8.0      2021-10-07 [1] CRAN (R 4.2.1)\n##    lwgeom                 0.2-9      2022-10-01 [1] CRAN (R 4.2.1)\n##    magrittr             * 2.0.3      2022-03-30 [1] CRAN (R 4.2.1)\n##    markdown               1.1        2019-08-07 [1] CRAN (R 4.2.1)\n##    MASS                 * 7.3-57     2022-04-22 [2] CRAN (R 4.2.1)\n##    matchmaker             0.1.1      2020-02-21 [1] CRAN (R 4.2.1)\n##    Matrix               * 1.5-1      2022-09-13 [1] CRAN (R 4.2.1)\n##    MatrixModels           0.5-1      2022-09-11 [1] CRAN (R 4.2.1)\n##    matrixStats            0.62.0     2022-04-19 [1] CRAN (R 4.2.1)\n##    mcmc                   0.9-7      2020-03-21 [1] CRAN (R 4.2.1)\n##    MCMCpack               1.6-3      2022-04-13 [1] CRAN (R 4.2.1)\n##    memoise                2.0.1      2021-11-26 [1] CRAN (R 4.2.1)\n##    mgcv                   1.8-40     2022-03-29 [2] CRAN (R 4.2.1)\n##    mice                 * 3.15.0     2022-11-19 [1] CRAN (R 4.2.1)\n##    microbenchmark         1.4.9      2021-11-09 [1] CRAN (R 4.2.1)\n##    mime                   0.12       2021-09-28 [1] CRAN (R 4.2.0)\n##    miniUI                 0.1.1.1    2018-05-18 [1] CRAN (R 4.2.1)\n##    mitools                2.4        2019-04-26 [1] CRAN (R 4.2.1)\n##    modelbased           * 0.8.5      2022-08-18 [1] CRAN (R 4.2.1)\n##    modelr                 0.1.8      2020-05-19 [1] CRAN (R 4.2.1)\n##    munsell                0.5.0      2018-06-12 [1] CRAN (R 4.2.1)\n##    naniar               * 0.6.1      2021-05-14 [1] CRAN (R 4.2.1)\n##    networkD3            * 0.4        2017-03-18 [1] CRAN (R 4.2.2)\n##    nlme                   3.1-157    2022-03-25 [2] CRAN (R 4.2.1)\n##    nnet                   7.3-17     2022-01-16 [2] CRAN (R 4.2.1)\n##    numDeriv               2016.8-1.1 2019-06-06 [1] CRAN (R 4.2.0)\n##    officer              * 0.4.4      2022-09-09 [1] CRAN (R 4.2.1)\n##    OpenStreetMap        * 0.3.4      2019-05-31 [1] CRAN (R 4.2.1)\n##    openxlsx               4.2.5      2021-12-14 [1] CRAN (R 4.2.1)\n##    pacman                 0.5.1      2019-03-11 [1] CRAN (R 4.2.1)\n##    parallelly             1.32.1     2022-07-21 [1] CRAN (R 4.2.1)\n##    parameters           * 0.18.2     2022-08-10 [1] CRAN (R 4.2.1)\n##    parsedate              1.3.0      2022-02-13 [1] CRAN (R 4.2.1)\n##    patchwork            * 1.1.2      2022-08-19 [1] CRAN (R 4.2.1)\n##    performance          * 0.9.2      2022-08-10 [1] CRAN (R 4.2.1)\n##    PerformanceAnalytics * 2.0.4      2020-02-06 [1] CRAN (R 4.2.2)\n##    PHEindicatormethods  * 1.4.1      2022-08-08 [1] CRAN (R 4.2.2)\n##    pillar                 1.8.1      2022-08-19 [1] CRAN (R 4.2.1)\n##    pkgbuild               1.3.1      2021-12-20 [1] CRAN (R 4.2.1)\n##    pkgconfig              2.0.3      2019-09-22 [1] CRAN (R 4.2.1)\n##    plotly               * 4.10.0     2021-10-09 [1] CRAN (R 4.2.1)\n##    plotrix                3.8-2      2021-09-08 [1] CRAN (R 4.2.0)\n##    plyr                   1.8.7      2022-03-24 [1] CRAN (R 4.2.1)\n##    png                    0.1-7      2013-12-03 [1] CRAN (R 4.2.0)\n##    polyclip               1.10-4     2022-10-20 [1] CRAN (R 4.2.1)\n##    polyCub                0.8.0      2021-01-27 [1] CRAN (R 4.2.2)\n##    prettyunits            1.1.1      2020-01-24 [1] CRAN (R 4.2.1)\n##    processx               3.7.0      2022-07-07 [1] CRAN (R 4.2.1)\n##    prodlim                2019.11.13 2019-11-17 [1] CRAN (R 4.2.1)\n##    progressr              0.11.0     2022-09-02 [1] CRAN (R 4.2.1)\n##    projections          * 0.5.4      2021-04-22 [1] CRAN (R 4.2.1)\n##    promises               1.2.0.1    2021-02-11 [1] CRAN (R 4.2.1)\n##    proxy                  0.4-27     2022-06-09 [1] CRAN (R 4.2.1)\n##    ps                     1.7.1      2022-06-18 [1] CRAN (R 4.2.1)\n##    purrr                * 0.3.4      2020-04-17 [1] CRAN (R 4.2.1)\n##    quadprog               1.5-8      2019-11-20 [1] CRAN (R 4.2.0)\n##    Quandl                 2.11.0     2021-08-11 [1] CRAN (R 4.2.2)\n##    quantmod             * 0.4.20     2022-04-29 [1] CRAN (R 4.2.2)\n##    quantreg               5.94       2022-07-20 [1] CRAN (R 4.2.1)\n##    R.methodsS3            1.8.2      2022-06-13 [1] CRAN (R 4.2.0)\n##    R.oo                   1.25.0     2022-06-12 [1] CRAN (R 4.2.0)\n##    R.utils                2.12.0     2022-06-28 [1] CRAN (R 4.2.1)\n##    R6                     2.5.1      2021-08-19 [1] CRAN (R 4.2.1)\n##    raster                 3.5-29     2022-08-14 [1] CRAN (R 4.2.1)\n##    RColorBrewer         * 1.1-3      2022-04-03 [1] CRAN (R 4.2.0)\n##    Rcpp                 * 1.0.9      2022-07-08 [1] CRAN (R 4.2.1)\n##  D RcppParallel           5.1.5      2022-01-05 [1] CRAN (R 4.2.1)\n##    readr                * 2.1.2      2022-01-30 [1] CRAN (R 4.2.1)\n##    readxl               * 1.4.1      2022-08-17 [1] CRAN (R 4.2.1)\n##    RecordLinkage        * 0.4-12.4   2022-11-08 [1] CRAN (R 4.2.2)\n##    report               * 0.5.5      2022-08-22 [1] CRAN (R 4.2.1)\n##    repr                   1.1.4      2022-01-04 [1] CRAN (R 4.2.1)\n##    reprex                 2.0.1      2021-08-05 [1] CRAN (R 4.2.1)\n##    reshape2               1.4.4      2020-04-09 [1] CRAN (R 4.2.1)\n##    rgdal                  1.5-32     2022-05-09 [1] CRAN (R 4.2.1)\n##    rio                  * 0.5.29     2021-11-22 [1] CRAN (R 4.2.1)\n##  D rJava                  1.0-6      2021-12-10 [1] CRAN (R 4.2.0)\n##    rlang                  1.0.6      2022-09-24 [1] CRAN (R 4.2.1)\n##    rmarkdown              2.16       2022-08-24 [1] CRAN (R 4.2.1)\n##    rootSolve              1.8.2.3    2021-09-29 [1] CRAN (R 4.2.0)\n##    rpart                  4.1.16     2022-01-24 [2] CRAN (R 4.2.1)\n##    rprojroot              2.0.3      2022-04-02 [1] CRAN (R 4.2.1)\n##    RSQLite              * 2.2.18     2022-10-04 [1] CRAN (R 4.2.2)\n##    rstan                  2.21.7     2022-09-08 [1] CRAN (R 4.2.1)\n##    rstatix              * 0.7.1      2022-11-09 [1] CRAN (R 4.2.2)\n##    rstudioapi             0.14       2022-08-22 [1] CRAN (R 4.2.1)\n##    runner                 0.4.2      2022-09-17 [1] CRAN (R 4.2.1)\n##    rvest                  1.0.2      2021-10-16 [1] CRAN (R 4.2.1)\n##    s2                     1.1.0      2022-07-18 [1] CRAN (R 4.2.1)\n##    sass                   0.4.2      2022-07-16 [1] CRAN (R 4.2.1)\n##    scales               * 1.2.1      2022-08-20 [1] CRAN (R 4.2.1)\n##    scatterplot3d          0.3-42     2022-09-08 [1] CRAN (R 4.2.1)\n##    see                  * 0.7.3      2022-09-20 [1] CRAN (R 4.2.1)\n##    SemiCompRisks        * 3.4        2021-02-03 [1] CRAN (R 4.2.2)\n##    sessioninfo            1.2.2      2021-12-06 [1] CRAN (R 4.2.1)\n##    sf                   * 1.0-8      2022-07-14 [1] CRAN (R 4.2.1)\n##    shiny                  1.7.2      2022-07-19 [1] CRAN (R 4.2.1)\n##    sitrep               * 0.2.3      2022-09-29 [1] Github (r4epi/sitrep@75c86a7)\n##    skimr                * 2.1.4      2022-04-15 [1] CRAN (R 4.2.1)\n##    slider               * 0.2.2      2021-07-01 [1] CRAN (R 4.2.1)\n##    snakecase              0.11.0     2019-05-25 [1] CRAN (R 4.2.1)\n##    sp                   * 1.5-0      2022-06-05 [1] CRAN (R 4.2.1)\n##    SparseM                1.81       2021-02-18 [1] CRAN (R 4.2.0)\n##    spatstat.data          3.0-0      2022-10-21 [1] CRAN (R 4.2.2)\n##    spatstat.geom          3.0-3      2022-10-25 [1] CRAN (R 4.2.2)\n##    spatstat.utils         3.0-1      2022-10-19 [1] CRAN (R 4.2.2)\n##    spData               * 2.2.0      2022-08-31 [1] CRAN (R 4.2.1)\n##    spdep                * 1.2-7      2022-10-01 [1] CRAN (R 4.2.1)\n##    srvyr                * 1.1.1      2022-02-20 [1] CRAN (R 4.2.1)\n##    StanHeaders            2.21.0-7   2020-12-17 [1] CRAN (R 4.2.1)\n##    stars                * 0.5-6      2022-07-21 [1] CRAN (R 4.2.1)\n##    statmod                1.4.37     2022-08-12 [1] CRAN (R 4.2.1)\n##    stinepack              1.4        2018-07-30 [1] CRAN (R 4.2.0)\n##    stringdist           * 0.9.10     2022-11-07 [1] CRAN (R 4.2.2)\n##    stringi                1.7.8      2022-07-11 [1] CRAN (R 4.2.1)\n##    stringr              * 1.4.1      2022-08-20 [1] CRAN (R 4.2.1)\n##    survC1               * 1.0-3      2021-02-10 [1] CRAN (R 4.2.1)\n##    surveillance         * 1.20.3     2022-11-16 [1] CRAN (R 4.2.1)\n##    survey               * 4.1-1      2021-07-19 [1] CRAN (R 4.2.1)\n##    survival             * 3.3-1      2022-03-03 [2] CRAN (R 4.2.1)\n##    survminer            * 0.4.9      2021-03-09 [1] CRAN (R 4.2.2)\n##    survMisc               0.5.6      2022-04-07 [1] CRAN (R 4.2.2)\n##    svglite                2.1.0      2022-02-03 [1] CRAN (R 4.2.1)\n##    systemfonts            1.0.4      2022-02-11 [1] CRAN (R 4.2.1)\n##    terra                  1.6-7      2022-08-07 [1] CRAN (R 4.2.1)\n##    tibble               * 3.1.8      2022-07-22 [1] CRAN (R 4.2.1)\n##    tidyquant            * 1.0.6      2022-11-16 [1] CRAN (R 4.2.1)\n##    tidyr                * 1.2.1      2022-09-08 [1] CRAN (R 4.2.1)\n##    tidyselect             1.1.2      2022-02-21 [1] CRAN (R 4.2.1)\n##    tidytree               0.4.1      2022-09-26 [1] CRAN (R 4.2.1)\n##    tidyverse            * 1.3.2      2022-07-18 [1] CRAN (R 4.2.2)\n##    timeDate               4021.106   2022-09-30 [1] CRAN (R 4.2.1)\n##    tmap                 * 3.3-3      2022-03-02 [1] CRAN (R 4.2.1)\n##    tmaptools            * 3.1-1      2021-01-19 [1] CRAN (R 4.2.1)\n##    treeio               * 1.20.2     2022-08-14 [1] Bioconductor\n##    trending             * 0.0.3      2021-04-19 [1] CRAN (R 4.2.1)\n##    truncnorm              1.0-8      2018-02-27 [1] CRAN (R 4.2.1)\n##    tseries                0.10-52    2022-10-10 [1] CRAN (R 4.2.2)\n##    tsibble              * 1.1.2      2022-08-21 [1] CRAN (R 4.2.1)\n##    TTR                  * 0.24.3     2021-12-12 [1] CRAN (R 4.2.2)\n##    tweenr                 2.0.2      2022-09-06 [1] CRAN (R 4.2.1)\n##    tzdb                   0.3.0      2022-03-28 [1] CRAN (R 4.2.1)\n##    units                * 0.8-0      2022-02-05 [1] CRAN (R 4.2.1)\n##    UpSetR               * 1.4.0      2019-05-22 [1] CRAN (R 4.2.1)\n##    urca                   1.3-3      2022-08-29 [1] CRAN (R 4.2.2)\n##    utf8                   1.2.2      2021-07-24 [1] CRAN (R 4.2.1)\n##    uuid                   1.1-0      2022-04-19 [1] CRAN (R 4.2.0)\n##    vctrs                  0.5.1      2022-11-16 [1] CRAN (R 4.2.1)\n##    viridis              * 0.6.2      2021-10-13 [1] CRAN (R 4.2.1)\n##    viridisLite          * 0.4.1      2022-08-22 [1] CRAN (R 4.2.1)\n##    visdat                 0.5.3      2019-02-15 [1] CRAN (R 4.2.1)\n##    visNetwork           * 2.1.2      2022-09-29 [1] CRAN (R 4.2.1)\n##    vistime              * 1.2.3      2022-10-16 [1] CRAN (R 4.2.2)\n##    warp                   0.2.0      2020-10-21 [1] CRAN (R 4.2.1)\n##    webshot              * 0.5.3      2022-04-14 [1] CRAN (R 4.2.1)\n##    withr                  2.5.0      2022-03-03 [1] CRAN (R 4.2.1)\n##    wk                     0.6.0      2022-01-03 [1] CRAN (R 4.2.1)\n##    writexl              * 1.4.1      2022-10-18 [1] CRAN (R 4.2.2)\n##    xfun                   0.33       2022-09-12 [1] CRAN (R 4.2.1)\n##    XML                    3.99-0.10  2022-06-09 [1] CRAN (R 4.2.1)\n##    xml2                   1.3.3      2021-11-30 [1] CRAN (R 4.2.1)\n##    xtable               * 1.8-4      2019-04-21 [1] CRAN (R 4.2.1)\n##    xts                  * 0.12.2     2022-10-16 [1] CRAN (R 4.2.2)\n##    yaml                   2.3.5      2022-02-21 [1] CRAN (R 4.2.1)\n##    yardstick            * 1.1.0      2022-09-07 [1] CRAN (R 4.2.2)\n##    yulab.utils            0.0.5      2022-06-30 [1] CRAN (R 4.2.1)\n##    zip                    2.2.1      2022-09-08 [1] CRAN (R 4.2.1)\n##    zoo                  * 1.8-11     2022-09-17 [1] CRAN (R 4.2.1)\n## \n##  [1] C:/Users/neale/AppData/Local/R/win-library/4.2\n##  [2] C:/Program Files/R/R-4.2.1/library\n## \n##  D ── DLL MD5 mismatch, broken installation.\n## \n## ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────"},{"path":"el-kitabı-ve-verileri-indirme.html","id":"el-kitabı-ve-verileri-indirme","chapter":"2 El Kitabı ve verileri indirme","heading":"2 El Kitabı ve verileri indirme","text":"","code":""},{"path":"el-kitabı-ve-verileri-indirme.html","id":"çevrimdışı-el-kitabı-indirme","chapter":"2 El Kitabı ve verileri indirme","heading":"2.1 Çevrimdışı el kitabı indirme","text":"İnternet erişiminiz olmasa bile bu el kitabını web tarayıcınızda görüntüleyebilirsiniz. Bunun için HTML dosyalarını indirmeniz gerekmektedir. Epi R El Kitabını çevrimdışı kullanmayı düşünüyorsanız, bilmeniz gereken gereken birkaç nokta mevcut:Dosyaları açtığınızda resimler ve İçindekiler’yüklenmesi bir veya iki dakika sürebilir.Çevrimdışı kitabın düzeni biraz farklıdır - solda İçindekiler Tablosu olan uzun bir alan görecekseniz. Belirli terimleri aramak için Ctrl+F (Cmd-F) tuşlarını kullanabilirsiniz.İnternet bağlantınızı kesmeden önce uygun R paketlerini kurmanıza yardımcı olması için Önerilen paketler sayfasına bakın.Tüm örnek verileri içeren R paketinizi epirhandbook kurun. (kurulum işlemi aşağıda açıklanmıştır)El Kitabını iki farklı yoldan indirebilirsiniz:","code":""},{"path":"el-kitabı-ve-verileri-indirme.html","id":"indirme-linkini-kullanarak","chapter":"2 El Kitabı ve verileri indirme","heading":"İndirme linkini kullanarak","text":"Linke hızlıca erişebilmek için, bu linki sağ fare tuşunuzla tıklayın link ve “Farklı Kaydet” seçeneğini seçin.Mac kullanıyorsanız, Cmd’ye basılı tutarak farenizle tıklayın. Cep telefonu kullanıyorsanız, bağlantıyı basılı tutun ve “Bağlantıyı kaydet”seçin. Kitap cihazınıza indirilecektir. Görseller olmadan HTML kodu içeren bir ekran görürseniz, yukarıdaki talimatları uyguladığınızdan emin olun veya ikinci seçeneği deneyin.","code":""},{"path":"el-kitabı-ve-verileri-indirme.html","id":"r-paketimizi-kullanın","chapter":"2 El Kitabı ve verileri indirme","heading":"R paketimizi kullanın","text":"Sizin için epirhandbook adında bir R paketi tasarladık. El kitabını bilgisayarınıza indirebilmek için download_book() adlı bir fonksiyon oluşturduk. Bu fonksiyonu R programınızda kullanabilirsiniz.Bu pakette ayrıca get_data() adlı bir fonksiyon da mevcuttur. Bu fonskiyonla tüm örnek verileri bilgisayarınıza indirebilirsiniz.Github sayfamızdan appliedepi epirhandbook R paketini indirmek için aşağıda verdiğimiz kodu kullanabilirsiniz. İndireceğiniz bu paket CRAN’da olmadığı için (Github’da kayıtlı) p_install_gh() özel fonksiyonunu kullanmanız gerekecektir.Şimdi, mevcut R oturumunuzda kullanmak üzere paketi yükleyin:Ardından, el kitabını bilgisayarınıza indirmek için paketin download_book() (boş parantez ile) fonksiyonunu çalıştırın. RStudio kullandığınızı varsayarsak, dosyaları kaydetmeden önce konumu seçmenize izin veren bir pencere açılacaktır.","code":"\n# Epi R El Kitabı paketinin en son sürümünü indirin\npacman::p_install_gh(\"appliedepi/epirhandbook\")\n# paketi kullanmak için yükleyin\npacman::p_load(epirhandbook)\n# çevrimdışı el kitabını bilgisayarınıza indirin\ndownload_book()"},{"path":"el-kitabı-ve-verileri-indirme.html","id":"örnek-bazlı-verileri-indirme","chapter":"2 El Kitabı ve verileri indirme","heading":"2.2 Örnek bazlı verileri indirme","text":"El kitabındaki örnekleri “takip etmek” için örnek veri ve çıktıları indirebilirsiniz.","code":""},{"path":"el-kitabı-ve-verileri-indirme.html","id":"r-paketimizi-kullanma","chapter":"2 El Kitabı ve verileri indirme","heading":"R paketimizi kullanma","text":"Tüm verileri indirmenin en kolay yolu, R paketimiz olan epirhandbook kurmaktır. Bu paket tüm örnek verileri bilgisayarınızda seçtiğiniz bir klasöre kaydeden get_data() fonksiyonunu içerir.R paketini epirhandbooku kurmak için aşağıdaki kodu çalıştırın. Paketimiz CRAN’da bulunmamaktadır. Bu yüzden kurmak için p_install_gh() fonksiyonunu kullanın. Parantez içindeki referans, Github organizasyonumuza (“appliedepi”) ve epirhandbook proje adına atıfta bulunnmaktadır.Şimdi, mevcut R oturumunuzda kullanmak üzere paketi yükleyin:Bu işlemlerin ardından, örnek verileri bilgisayarınıza indirmek için paketin get_data() fonksiyonunu kullanın. Örnek verilerin tamamını indirmek için get_data(\"\") komutunu çalıştırın veya yalnızca bir dosyayı almak için tırnak işaretleri içinde ilgili dosya adı ve uzantısını yazın.Veriler paketle birlikte indirilmiş olacaktır. Burada yapmanız gereken tek şey bilgisayarınızda indireceğiniz klasörü belirlemektir. İndirme konumunu seçmenize izin veren bir açılır pencere karşınıza çıkacaktır. Örnek veri ve çıktılar dahil yaklaşık 30 dosya olduğundan indirme konumunda yeni bir “veri” klasörü oluşturmanızı öneririz.İstediğiniz dosyayı bilgisayarınıza kaydetmek için get_data()yı kullandıktan sonra, yine de onu R’aktarmanız gerekecektir. Ayrıntılar için İçe ve dışa aktar sayfasına bakabilirsiniz.Dilerseniz bu el kitabında kullanılan tüm verileri Github sayfamızın “data” klasöründe inceleyebilirsiniz.","code":"\n# Epi R El Kitabı paketinin en son sürümünü indirin\npacman::p_install_gh(\"appliedepi/epirhandbook\")\n# paketi kullanmak için yükleyin\npacman::p_load(epirhandbook)\n# tüm örnek verileri bilgisayarınızdaki bir klasöre indirin\nget_data(\"all\")\n\n# bilgisayarınızdaki bir klasöre yalnızca belli bir satırın verilerini indirin\nget_data(file = \"linelist_cleaned.rds\")\n# belirli bir dosyayı bilgisayarınızdaki bir klasöre indirin\nget_data(\"linelist_cleaned.rds\")"},{"path":"el-kitabı-ve-verileri-indirme.html","id":"tek-tek-indirme","chapter":"2 El Kitabı ve verileri indirme","heading":"Tek tek indirme","text":"Bu seçenek, dosyaya özel bir bağlantı veya R komutu aracılığıyla Github sayfamızdan dosyaları sırasıyla indirmeyi içermektedir. Bazı dosya türleri indirme düğmesine izin verirken, diğerleri bir R komutuyla indirilebilir.","code":""},{"path":"el-kitabı-ve-verileri-indirme.html","id":"vaka-satır-listesi","chapter":"2 El Kitabı ve verileri indirme","heading":"Vaka satır listesi","text":"Aşağıdaki linkler, outbreaks paketindeki ebola_sim uygulama veri kümesinde yer alan kitabın ekibi tarafından genişletilen kurgusal bir Ebola salgına aittir.“Ham” satır listesini indirmek için tıklayın (.xlsx). “Ham” vaka satır listesi, dağınık veriler içeren bir excel tablosudur. [Verileri temizleme ve temel işlevler] sayfasını takip etmek için bunu kullanabilirsiniz.“Ham” satır listesini indirmek için tıklayın (.xlsx). “Ham” vaka satır listesi, dağınık veriler içeren bir excel tablosudur. [Verileri temizleme ve temel işlevler] sayfasını takip etmek için bunu kullanabilirsiniz.“Temiz” satır listesini indirmek için tıklayın (.rds). Bu el kitabının satır listesini kullanan diğer tüm sayfaları için bu dosyayı kullanabilirsiniz. Rds dosyası, sütun sınıflarını koruyan R’özgü bir dosya türüdür. Bu, verileri R’aktardıktan sonra temizlik yapma ihtiyacını azaltır.“Temiz” satır listesini indirmek için tıklayın (.rds). Bu el kitabının satır listesini kullanan diğer tüm sayfaları için bu dosyayı kullanabilirsiniz. Rds dosyası, sütun sınıflarını koruyan R’özgü bir dosya türüdür. Bu, verileri R’aktardıktan sonra temizlik yapma ihtiyacını azaltır.Diğer dosyalar:“Temiz” satır listesini Excel dosyası olarak indirmek için tıklayın“Temiz” satır listesini Excel dosyası olarak indirmek için tıklayınTemizleme sayfasının bir kısmı bir “temizleme sözlüğü” (.csv dosyası) kullanır. Aşağıdaki komutları çalıştırarak doğrudan R’yükleyebilirsiniz:Temizleme sayfasının bir kısmı bir “temizleme sözlüğü” (.csv dosyası) kullanır. Aşağıdaki komutları çalıştırarak doğrudan R’yükleyebilirsiniz:","code":"\npacman::p_load(rio) # rio paketini kurun/yükleyin\n\n# dosyayı doğrudan Github'dan içe aktarın\ncleaning_dict <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/cleaning_dict.csv\")"},{"path":"el-kitabı-ve-verileri-indirme.html","id":"data_malaria","chapter":"2 El Kitabı ve verileri indirme","heading":"Sıtma sayısı verileri","text":"Bu veriler, yaş grubu, tesis ve güne göre sıtma vakalarının kurgusal sayılarıdır. Rds dosyası, sütun sınıflarını koruyan R’özgü bir dosya türüdür. Bu, verileri R’aktardıktan sonra temizlik yapma ihtiyacını azaltır.\nSıtma sayılarını (.rds dosyası)\nindirmek için tıklayın.\n","code":""},{"path":"el-kitabı-ve-verileri-indirme.html","id":"likert-ölçekli-veri","chapter":"2 El Kitabı ve verileri indirme","heading":"Likert ölçekli veri","text":"Bunlar, [Demografik Piramitler ve Likert Ölçekleri] sayfasında kullanılan likert tarzı bir anketten alınan kurgusal verilerdir. Aşağıdaki komutları çalıştırarak bu verileri doğrudan R’yükleyebilirsiniz:","code":"\npacman::p_load(rio) # rio paketini kurun/yükleyin\n\n# dosyayı doğrudan Github'dan içe aktarın\nlikert_data <- import(\"https://raw.githubusercontent.com/nsbatra/Epi_R_handbook/master/data/likert_data.csv\")"},{"path":"el-kitabı-ve-verileri-indirme.html","id":"esnek-pano","chapter":"2 El Kitabı ve verileri indirme","heading":"Esnek pano","text":"Aşağıda [R Markdown ile Kontrol Panelleri]’ndeki sayfayla ilişkili dosyaya bağlantılar verilmiştir:Salgın panosu ile ilgili R Markdown’ı indirmek için linke sağ fare tuşuyla tıklayın (Mac için Cmd + tıkla) ve “Farklı Kaydet” seçeneğini seçin.HTML kontrol panelini indirmek için linke sağ fare tuşuyla tıklayın (Mac için Cmd + tıkla) ve “Farklı Kaydet” seçeneğini seçin.","code":""},{"path":"el-kitabı-ve-verileri-indirme.html","id":"temaslı-izleme","chapter":"2 El Kitabı ve verileri indirme","heading":"Temaslı İzleme","text":"Temaslı İzleme sayfası, aşağıdaki örnek verileri kullanarak kişi izleme verilerinin analizini göstermektedir. Go.Data. Sayfada kullanılan veriler aşağıdaki linklere tıklanarak .rds dosyaları olarak indirilebilir:\nVaka inceleme verilerini (.rds dosyası)\nindirmek için tıklayın.\n\nTemaslı kayıt verilerini (.rds dosyası)\nindirmek için tıklayın.\n\nTemaslı takip verilerini (.rds dosyası)\nindirmek için tıklayın.\n: Diğer yazılımlarda (örn. KoBo, DHIS2 Tracker, CommCare) yapılandırılmış temaslı izleme verileri farklı görünebilir. Bu sayfa için alternatif örnek veri veya içeriğe katkıda bulunmak isterseniz lütfen bize ulaşın.İPUCU: Go.Data kullanmak istiyorsanız ve örneklerinizin API’sine bağlanmak istiyorsanız, İçe ve Dışa Aktarma sayfasına (API bölümü) ve Go.Data Uygulama Topluluğu’na bakabilirsiniz.","code":""},{"path":"el-kitabı-ve-verileri-indirme.html","id":"gis","chapter":"2 El Kitabı ve verileri indirme","heading":"GIS","text":"Şekil dosyaları, biri farklı uzantıya sahip birçok alt bileşen dosyasına sahiptir. Bir dosya “.shp” uzantısına sahipken, bir diğeri “.dbf”, “.prj” vb. uzantıya sahip olabilir.[GIS temel bilgileri] sayfası, sıkıştırılmış şekil dosyalarını indirebileceğiniz Humanitarian Data Exchange web sitesine ait bağlantıları barındırmaktadır.Örneğin sağlık tesisi puan verileri buradan indirilebilir. “hotosm_sierra_leone_health_facilities_points_shp.zip” dosyasını indirin. Bilgisayarınıza kaydettikten sonra, klasörü “açın”. Farklı uzantılara sahip birkaç dosya göreceksiniz (örneğin “.shp”, “.prj”, “.shx”) - bunların tümü bilgisayarınızda aynı klasöre kaydedilmelidir. Ardından, R’aktarmak için “.shp” dosyasının dosya yolunu ve adını sf paketinden st_read() fonksiyonuna ekleyin ([GIS temel bilgileri] sayfasında açıklandığı gibi)Tüm örnek verileri indirmek için Seçenek 1’izlediyseniz (R paketimiz epirhandbook aracılığıyla), şekil dosyalarının tamamı içeride olacaktır.Alternatif olarak, şekil dosyalarını Github sayfamızdaki “data” klasöründen indirebilirsiniz (“gis” alt klasörüne bakın). Ancak, bir alt dosyayı ayrı ayrı bilgisayarınıza indirmeniz gerekeceğini unutmayın. Github’da bir dosyaya tek tek tıklayın ve “İndir” butonuna basarak indirin. Aşağıda örnek olarak, “sle_adm3” şekil dosyasının Github bölümünde kayıtlı birçok alt dosyadan oluştuğunu görebilirsiniz.","code":""},{"path":"el-kitabı-ve-verileri-indirme.html","id":"filogenetik-ağaçlar","chapter":"2 El Kitabı ve verileri indirme","heading":"Filogenetik ağaçlar","text":"Filogenetik ağaçlar sayfayasında, 299 Shigella sonnei örneğinin tüm genom dizilimi ve buna karşılık gelen vaka verilerinden (bir metin dosyası halinde) oluşturulan filogenetik ağacı Newick dosyası göreceksiniz. Belçika örneklerinden elde edilen veriler, ECDC EUPHEM asistanı tarafından yürütülen bir proje kapsamında üretilmiştir. Salmonella ve Shigella’dan elde edilen bu veriler Belçika NRC’si tarafından sağlanmaktadır.Bu veriler yayına dönüştürülme aşamasındadır. Kullanılan uluslararası veriler kamuya açık veri tabanlarına (ncbi) kayıtlı ve yayınlanmış verilerden elde edilmiştir.“Shigella_tree.txt” filogenetik ağaç dosyasını indirmek için linke sağ fare tuşuyla tıklayın (Mac için Cmd + tıkla) ve “Farklı Kaydet” seçeneğini seçin.örnekle ilgili ek bilgiler içeren “sample_data_Shigella_tree.csv” dosyasını indirmek için linke sağ fare tuşuyla tıklayın (Mac için Cmd + tıkla) ve “Farklı Kaydet” seçeneğini seçin.Yeni oluşturulan altküme ağacını görmek için linke sağ fare tuşuyla tıklayın (Mac için Cmd + tıkla) ve “Farklı Kaydet” seçeneğini seçin.Daha sonra sayfada açıklandığı gibi ape paketinden read.tree() ile .txt dosyalarını içe aktarabilirsiniz.","code":"\nape::read.tree(\"Shigella_tree.txt\")"},{"path":"el-kitabı-ve-verileri-indirme.html","id":"standardizasyon","chapter":"2 El Kitabı ve verileri indirme","heading":"Standardizasyon","text":"[Standartlaştırılmış oranlar] ile ilgili sayfaya bakın. Verileri doğrudan internetteki Github sayfamızdan aşağıdaki komutlarla R oturumunuza yükleyebilirsiniz:","code":"\n# rio paketini kurun/yükleyin\npacman::p_load(rio) \n\n##############\n# A Ülkesi\n##############\n# A ülkesi için demografi bilgilerini Github'dan içeri aktarın\nA_demo <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics.csv\")\n\n# A ülkesi için ölüm bilgilerini Github'dan içeri aktarın\nA_deaths <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryA.csv\")\n\n##############\n# B Ülkesi\n##############\n# B ülkesi için demografi bilgilerini Github'dan içeri aktarın\nB_demo <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics_2.csv\")\n\n# B ülkesi için ölüm bilgilerini Github'dan içeri aktarın\nB_deaths <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryB.csv\")\n\n\n###############\n# Referans\n###############\n# Referans demografik bilgileri Github'dan içeri aktarın\nstandard_pop_data <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/world_standard_population_by_sex.csv\")"},{"path":"el-kitabı-ve-verileri-indirme.html","id":"data_outbreak","chapter":"2 El Kitabı ve verileri indirme","heading":"Zaman serileri ve salgın tespiti","text":"[Zaman serisi ve salgın tespiti] sayfasında Almanya 2002-2011’de rapor edilen Campylobacter vakalarını surveillance R paketinde olduğu gibi kullanıyoruz. (ek bilgi: bu veri seti orijinalinden uyarlanmıştır, 2011’son 3 aylık verileri demo amacıyla silinmiştir)\nAlmanya Campylobacter verilerini (.xlsx)\n indirmek için tıklayın.\nKitapta ayrıca Almanya 2002-2011 iklim verilerini kullanıyoruz (santigrat derece cinsinden sıcaklık ve milimetre cinsinden yağış bilgileri mevcut). Bu veriler, ecmwfr paketi kullanılarak EU Copernicus uydu yeniden analiz veri setinden indirilmiştir. Bunların hepsini indirmeniz ve zaman serisi sayfasında açıklandığı gibi stars::read_stars() ile içe aktarmanız gerekecektir.\nAlmanya Hava Durumu 2002 verilerini(.nc dosyası)\n indirmek için tıklayın.\n\nAlmanya Hava Durumu 2003 verilerini (.nc dosyası)\n indirmek için tıklayın.\n\nAlmanya Hava Durumu 2004 verilerini (.nc dosyası)\n indirmek için tıklayın.\n\nAlmanya Hava Durumu 2005 verilerini (.nc dosyası)\n indirmek için tıklayın.\n\nAlmanya Hava Durumu 2006 verilerini (.nc dosyası)\n indirmek için tıklayın.\n\nAlmanya Hava Durumu 2007 verilerini (.nc dosyası)\n indirmek için tıklayın.\n\nAlmanya Hava Durumu 2008 verilerini (.nc dosyası)\n indirmek için tıklayın.\n\nAlmanya Hava Durumu 2009 verilerini (.nc dosyası)\n indirmek için tıklayın.\n\nAlmanya Hava Durumu 2010 verilerini (.nc dosyası)\n indirmek için tıklayın.\n\nAlmanya Hava Durumu 2011 verilerini (.nc dosyası)\n indirmek için tıklayın.\n","code":""},{"path":"el-kitabı-ve-verileri-indirme.html","id":"data_survey","chapter":"2 El Kitabı ve verileri indirme","heading":"Anket analizi","text":"Anket analizi sayfası için MSF OCA anket şablonlarına dayalı kurgusal ölüm anketi verilerini kullandık. Bu kurgusal veriler “R4Epis” projesi kapsamında oluşturulmuştur.\nKurgusal anket verilerini (.xlsx)\n indirmek için tıklayın.\n\nKurgusal anket veri sözlüğünü (.xlsx)\n indirmek için tıklayın.\n\nKurgusal anket nüfus verilerini (.xlsx)\n indirmek için tıklayın.\n","code":""},{"path":"el-kitabı-ve-verileri-indirme.html","id":"data_shiny","chapter":"2 El Kitabı ve verileri indirme","heading":"Shiny","text":"[Shiny Gösterge Tabloları] ile ilgili sayfa, sıtma verilerini görüntülemek için uygulamanın yapısını göstermektedir.Shiny uygulamasını oluşturan R dosyalarını indirmek için:Shiny uygulaması için hem kullanıcı arayüzünü hem de sunucu kodunu içeren app.R dosyasını indirmek için burayı tıklayabilirsiniz.Shiny uygulaması için sıtma verilerini içeren property_count_data.rds dosyasını indirmek için burayı tıklayabilirsiniz. () fonksiyonunun doğru çalışması için onu bir “data” klasöründe saklamayı unutmayın.Sayfada açıklandığı gibi, uygulama açılmadan önce çalışması gereken global.R dosyasını indirmek için burayı tıklayabilirsiniz. Sayfada açıklandığı gibi, uygulama açılmadan önce çalıştırmayı unutmayın.global.R tarafından sağlanan plot_epicurve.R dosyasını indirmek için burayı tıklayabilirsiniz. () fonksiyonlarının doğru çalışması için onu bir “funcs” klasöründe saklamayı unutmayın.","code":""},{"path":"bölüm-temel-bilgiler.html","id":"bölüm-temel-bilgiler","chapter":"(BÖLÜM) Temel Bilgiler","heading":"(BÖLÜM) Temel Bilgiler","text":"","code":""},{"path":"rın-temelleri.html","id":"rın-temelleri","chapter":"3 R’ın Temelleri","heading":"3 R’ın Temelleri","text":"Hoş geldiniz!Bu sayfa, R’ın temellerini gözden geçirmektedir. Kapsamlı bir eğitim olması amaçlanmamıştır. Ancak temel bilgileri sağlar ve hatırlamanız için faydalı olabilir. İleri ve daha kapsamlı eğitimler için ilgili Öğrenme kaynağı bölüme geçiş yapılabilir.Bu sayfanın bazı bölümleri R4Epis projesinden izin alınarak uyarlanmıştır.STATA, SAS veya Excel’den R’geçişle ilgili ipuçları için R’Geçiş hakkındaki sayfaya bakabilirsiniz.","code":""},{"path":"rın-temelleri.html","id":"neden-r-kullanıyoruz","chapter":"3 R’ın Temelleri","heading":"3.1 Neden R Kullanıyoruz?","text":"R proje web sitesinde belirtildiği gibi, R, istatistiksel hesaplama ve grafikler için bir programlama dili ve ortamıdır. Çok yönlü, genişletilebilir ve topluluk odaklıdır.MaliyetR’ın kullanımı ücretsizdir! Açık kaynak ve ücretsiz olması yönünde topluluğun ciddi bir etik duruşu vardır.Yeniden üretilebilirlikVeri yönetiminizi ve analizinizi bir programlama dili aracılığıyla yürütmek (Excel’e veya başka bir öncelikli tıklama/manuel araçla karşılaştırıldığında), tekrarlanabilirliği artırır, hata algılamayı kolaylaştırır ve iş yükünüzü hafifletir.ToplulukR kullanıcı topluluğu kalabalık ve işbirlikçidir. Gerçek hayattaki sorunları ele almak için yeni paketler ve araçlar günlük olarak geliştirilir ve kullanıcı topluluğu tarafından incelenir. Örnek olarak, R-Ladies, amacı R topluluğunda cinsiyet çeşitliliğini teşvik etmek olan dünya çapında bir kuruluştur ve R kullanıcılarının en büyük kuruluşlarından biridir. Muhtemelen kullanmak üzere olduğunuz bir bölümleri vardır!","code":""},{"path":"rın-temelleri.html","id":"anahtar-kelimeler","chapter":"3 R’ın Temelleri","heading":"3.2 Anahtar Kelimeler","text":"RStudio - RStudio, R’ın daha kolay kullanımı için bir Grafik Kullanıcı Arayüzüdür (GUI). Daha fazlasını RStudio bölümünde okuyabilirsiniz.Objects - R’da sakladığınız şey - veri kümeleri, değişkenler, köy adlarının bir listesi, toplam nüfus sayısı, hatta grafikler gibi çıktılar - bir isim atanan nesnelerdir ve sonraki komutlarda başvurulabilir. Daha fazlasını Nesneler bölümünde okuyabilirsiniz.Functions - Fonksiyon, girdileri kabul eden ve çıktıya dönüştüren bir kod işlemidir. Daha fazlasını Fonksiyonlar bölümünde okuyabilirsiniz.Packages - R paketi, aslında paylaşılabilir fonksiyonlar paketidir. Daha fazlasını Paketler bölümünde okuyabilirsiniz.Scripts - Komut dosyası, komutlarınızı tutan belge dosyasıdır. Daha fazlasını Komut Dosyaları bölümünde okuyabilirsiniz.","code":""},{"path":"rın-temelleri.html","id":"learning","chapter":"3 R’ın Temelleri","heading":"3.3 Öğrenme Kaynakları","text":"","code":""},{"path":"rın-temelleri.html","id":"rstudio-içindeki-kaynaklar","chapter":"3 R’ın Temelleri","heading":"RStudio İçindeki Kaynaklar","text":"Yardım dosyalarıR paketleri ve belirli fonksiyonlarla ilgili belgeler için RStudio “Yardım” sekmesini arayın. Bu, Dosyaları, Grafikleri ve Paketleri de içeren bölmenin içindedir (genellikle sağ alt bölmededir). Kısayol olarak, ilgili Yardım sayfasını açmak için bir soru işaretinden sonra R konsoluna bir paketin veya fonksiyonun adını da yazabilirsiniz. Kesme işareti eklemeyin.Örneğin: ?filter veya ?diagrammeR.Etkileşimli öğreticilerRStudio içinde etkileşimli olarak R öğrenmenin birkaç yolu vardır.RStudio’nun kendisi, learnr R paketi tarafından desteklenen bir eğitim bölmesi sunar. Basitçe bu paketi kurabilir ve sağ üst RStudio bölmesindeki (Ortam ve Geçmiş sekmelerini de içeren) yeni “Tutorial” sekmesi aracılığıyla bir öğretici açabilirsiniz.R paketi swirl, R Konsolunda etkileşimli kurslar sunar. Bu paketi kurun ve yükleyin, ardından R konsolunda swirl() (boş parantezler) komutunu çalıştırın. Konsolda istemlerin göründüğünü göreceksiniz. Konsola yazarak yanıt verin. Seçtiğiniz bir kurs boyunca size rehberlik edecektir.","code":""},{"path":"rın-temelleri.html","id":"kopya-kağıtları","chapter":"3 R’ın Temelleri","heading":"Kopya Kağıtları","text":"RStudio web sitesinde birçok PDF “kullanımı kolaylaştırıcı belge/ kopya kağıtları” bulunmaktadır, örneğin:forcats paketini içeren faktörlerlubridate paketi ile tarihler ve saatlerstringr paketi içeren dizelerpurrr paketi ile tekrarlanan işlemleriçeri_veri_aktardplyr paketi ile veri dönüştürme hile sayfasıR Markdown (PDF, Word, Powerpoint… gibi belgeler oluşturmak için)Shiny (etkileşimli web uygulamaları oluşturmak için)ggplot2 paketi ile veri görselleştirmeHaritacılık (GIS)broşür paketi (etkileşimli haritalar)R ile Python (reticulate paketi)Bu, özellikle Excel kullanıcıları için çevrimiçi bir R kaynağıdır.","code":""},{"path":"rın-temelleri.html","id":"twitter","chapter":"3 R’ın Temelleri","heading":"Twitter","text":"Bizi Takip Edin! @epiRhandbookR Function Day @rfuntionaday muazzam bir kaynakR Data Science @rstats4dsRStudio @RStudioRStudio Tips @rstudiotipsR-Bloggers @RbloggersR-ladies @RLadiesGlobalHadley Wickham @hadleywickhamAynı zamanda:#epitwitter ve #rstats","code":""},{"path":"rın-temelleri.html","id":"ücretsiz-çevrimiçi-kaynaklar","chapter":"3 R’ın Temelleri","heading":"Ücretsiz Çevrimiçi Kaynaklar","text":"Tanımlayıcı bir metin, Garrett Grolemund ve Hadley Wickham’ın Veri Bilimi için R kitabı.R4Epis\nProje web sitesi “bir MSF acil müdahale ortamında yürütülecek yaygın salgın türlerini ve nüfusa dayalı anketleri kapsayacak şekilde standartlaştırılmış veri temizleme, analiz ve raporlama araçları geliştirmeyi” amaçlamaktadır. R temel eğitim materyallerini, salgınlar ve anketlerle ilgili RMarkdown raporları için şablonları ve bunları ayarlamanıza yardımcı olacak öğreticileri bulabilirsiniz.","code":""},{"path":"rın-temelleri.html","id":"ingilizce-dışındaki-dillerde","chapter":"3 R’ın Temelleri","heading":"İngilizce dışındaki dillerde","text":"Materiales de RStudio en EspañolIntroduction à R et au tidyverse (Francais)","code":""},{"path":"rın-temelleri.html","id":"kurulum","chapter":"3 R’ın Temelleri","heading":"3.4 Kurulum","text":"","code":""},{"path":"rın-temelleri.html","id":"r-ve-rstudio","chapter":"3 R’ın Temelleri","heading":"R ve RStudio","text":"R Nasıl Kurulur?Bu web sitesini https://www.r-project.org/ ziyaret edin ve bilgisayarınıza uygun en son R sürümünü indirin.RStudio nasıl kurulur?Bu web sitesini https://rstudio.com/products/rstudio/download/ ziyaret edin ve bilgisayarınıza uygun RStudio’nun en son ücretsiz masaüstü sürümünü indirin.İzinlerR ve RStudio’yu okuma ve yazma izinlerine sahip olduğunuz bir sürücüye kurmanız gerektiğini unutmayın. Aksi takdirde, R paketlerini kurma yeteneğiniz (sık rastlanan bir durum) etkilenecektir. Sorunlarla karşılaşırsanız, simgeye sağ tıklayıp “Yönetici olarak çalıştır”ı seçerek RStudio’yu açmayı deneyin. Diğer ipuçları Ağ sürücülerinde R sayfasında bulunabilir.R ve RStudio nasıl güncellenir?R sürümünüz, başlangıçta R Konsoluna yazdırılır. Ayrıca sessionInfo() komutunu da çalıştırabilirsiniz.R’ı güncellemek için yukarıda belirtilen web sitesine gidin ve R’ı yeniden yükleyin. Alternatif olarak, installr paketini (Windows’ta) installr::updateR() çalıştırarak kullanabilirsiniz. Bu, en son R sürümünü indirmenize ve paketlerinizi yeni R sürümüne güncellemenize yardımcı olacak iletişim kutularını açacaktır. Daha fazla ayrıntıyı installr belgelerde bulabilirsiniz.Eski R sürümünün bilgisayarınızda hala var olacağını unutmayın. RStudio’da “Araçlar” -> “Global Seçenekler”e tıklayarak ve bir R sürümü seçerek R’ın daha eski bir sürümünü (eski “kurulum”) geçici olarak çalıştırabilirsiniz. Bu, R’ın en yeni sürümü üzerinde çalışacak şekilde güncellenmemiş bir paket kullanmak istiyorsanız yararlı olabilir.RStudio’yu güncellemek için yukarıdaki web sitesine gidebilir ve RStudio’yu yeniden indirebilirsiniz. Başka bir seçenek de RStudio içinde “Yardım” -> “Güncellemeleri Kontrol Et” seçeneğine tıklamaktır. Ancak bu en son güncellemeleri göstermeyebilir.Bu El Kitabı hazırlanırken hangi R, RStudio veya paket sürümlerinin kullanıldığını görmek için [Editoryal ve teknik notlar] sayfasına bakın.","code":""},{"path":"rın-temelleri.html","id":"kurulumuna-ihtiyaç-duyabileceğiniz-diğer-yazılımlar","chapter":"3 R’ın Temelleri","heading":"Kurulumuna ihtiyaç duyabileceğiniz diğer yazılımlar","text":"TinyTeX (bir RMarkdown belgesini PDF’ye derlemek için)Pandoc (RMarkdown belgelerini derlemek için)RTools (R için paketler oluşturmak için)phantomjs (iletim zincirleri gibi hareketli ağların hareketsiz görüntülerini kaydetmek için)","code":""},{"path":"rın-temelleri.html","id":"tinytex","chapter":"3 R’ın Temelleri","heading":"TinyTex","text":"TinyTex, özel bir LaTeX dağıtımıdır ve R’dan PDF’ler üretmeye çalışırken kullanışlıdır.\nDaha fazla bilgi için https://yihui.org/tinytex/ adresine bakın.TinyTex’R’dan yüklemek için:","code":"\ninstall.packages('tinytex')\ntinytex::install_tinytex()\n# TinyTeX'i kaldırmak için, run tinytex::uninstall_tinytex()"},{"path":"rın-temelleri.html","id":"pandoc","chapter":"3 R’ın Temelleri","heading":"Pandoc","text":"Pandoc, R’dan ayrı bir yazılım olan belge dönüştürücüdür. RStudio ile birlikte gelir ve indirilmesi gerekmez. Rmarkdown belgelerini .pdf gibi biçimlere dönüştürme ve karmaşık fonksiyonlar ekleme sürecine yardımcı olur.","code":""},{"path":"rın-temelleri.html","id":"rtools","chapter":"3 R’ın Temelleri","heading":"RTools","text":"RTools, R için paketler oluşturmaya yönelik bir yazılım koleksiyonudur.Bu internet sayfasından yükleyebilirsiniz: https://cran.r-project.org/bin/windows/Rtools/","code":""},{"path":"rın-temelleri.html","id":"phantomjs","chapter":"3 R’ın Temelleri","heading":"phantomjs","text":"Bu genellikle web sayfalarının “ekran görüntülerini” almak için kullanılır. Örneğin epicontacts paketi ile bir iletim zinciri yaptığınızda interaktif ve dinamik bir HTML dosyası üretilir. Statik bir görüntü istiyorsanız, bu işlemi otomatikleştirmek için webshot paketini kullanmak faydalı olabilir. Bu, harici “phantomjs” programını gerektirecektir. phantomjs’yi webshot paketi aracılığıyla webshot::install_phantomjs() komutuyla kurabilirsiniz.","code":""},{"path":"rın-temelleri.html","id":"rstudio","chapter":"3 R’ın Temelleri","heading":"3.5 RStudio","text":"","code":""},{"path":"rın-temelleri.html","id":"rstudio-yönlendirmesi","chapter":"3 R’ın Temelleri","heading":"RStudio Yönlendirmesi","text":"Öncelikle RStudio’yu açın. Simgeleri çok benzer görünebileceğinden, R’ı değil RStudio’yu açtığınızdan emin olun.RStudio’nun çalışması için bilgisayarda R’ın da kurulu olması gerekir (kurulum talimatları için yukarıya bakın).RStudio, R’ın daha kolay kullanımı için bir arayüzdür (GUI). R’ı kritik işi yapan aracın motoru ve RStudio’yu, ilerlemek için motoru gerçekten kullanmanıza yardımcı olan aracın gövdesi (koltuklar, aksesuarlar vb. ile) olarak düşünebilirsiniz! Tam RStudio kullanıcı arayüzünü kolaylaştırıcısını (PDF) buradan görebilirsiniz.İPUCU: RStudio’nuz yalnızca bir sol bölme gösteriyorsa, bunun nedeni henüz açık komut dosyanız olmamasıdır.Kaynak BölmesiVarsayılan olarak sol üstteki bu bölme, komut dosyalarınızı düzenlemek, çalıştırmak ve kaydetmek için kullanılan bir alandır. Komut dosyaları, çalıştırmak istediğiniz komutları içerir. Bu bölme, görüntüleme için veri kümelerini/çerçevelerini (datasets/data frames) de görüntüleyebilir.Stata kullanıcıları için bu bölme, -file ve Data Editor pencerelerinize benzer.R Konsol BölmesiVarsayılan olarak R Studio’daki sol veya sol alt bölme olan R Konsolu, R “motorunun” evidir. Burası komutların fiilen çalıştırıldığı ve grafik olmayan çıktıların ve hata/uyarı mesajlarının göründüğü yerdir. Komutları doğrudan R Konsoluna girebilir ve çalıştırabilirsiniz. Ancak bu komutların bir komut dosyasından komut çalıştırırken olduğu gibi kaydedilmediğine dikkat ediniz.Stata’ya aşina iseniz, R Konsolu komut penceresi “Sonuçlar” penceresi gibidir.Ortam BölmesiVarsayılan olarak sağ üstte bulunan bu bölme, çoğunlukla mevcut oturumda R Ortamındaki nesnelerin kısa özetlerini görmek için kullanılır. Bu nesneler, içe aktarılan, değiştirilen veya oluşturulan veri kümelerini, tanımladığınız parametreleri (örneğin, analiz için belirli bir epi haftası) veya analiz sırasında tanımladığınız vektörleri veya listeleri (örneğin, bölgelerin adları) içerebilir. Değişkenlerini görmek için bir veri kümesi adının yanındaki oka tıklayabilirsiniz.Stata’da, bu en çok Değişkenler Yöneticisi penceresine benzer.Bu bölme ayrıca daha önceki komutları görebileceğiniz Geçmişi içerir. Ayrıca, learnr paketini yüklediyseniz etkileşimli R eğitimlerini tamamlayabileceğiniz bir “Öğretici” sekmesine de sahiptir. Ayrıca harici bağlantılar için bir “Bağlantılar” bölmesine sahiptir ve Github ile arabirim kurmayı seçerseniz bir “Git” bölmesine sahip olabilir.Grafikler, Görüntüleyici, Paketler ve Yardım BölmesiSağ alt bölmede birkaç önemli sekme bulunur. Haritalar dahil tipik çizim grafikleri, Çizim bölmesinde görüntülenecektir. Etkileşimli veya HTML çıktıları, Görüntüleyici bölmesinde görüntülenecektir. Yardım bölmesi, belgeleri ve yardım dosyalarını görüntüleyebilir. Dosyalar bölmesi, dosyaları açmak veya silmek için kullanılabilen bir tarayıcıdır. Paketler bölmesi, R paketlerini görmenize, yüklemenize, güncellemenize, silmenize ve paketin hangi sürümüne sahip olduğunuzu görmenize olanak tanır. Paketler hakkında daha fazla bilgi edinmek için aşağıdaki paketler bölümüne bakın.Bu bölme, Plots Manager ve Project Manager pencerelerinin Stata eşdeğerlerini içerir.","code":""},{"path":"rın-temelleri.html","id":"rstudio-ayarları","chapter":"3 R’ın Temelleri","heading":"3.5.1 RStudio ayarları","text":"Tools açılır menüsünde Global Options’ı seçerek RStudio ayarlarını ve görünümünü değiştirin. Orada görünüm/arka plan rengi dahil varsayılan ayarları değiştirebilirsiniz.Tekrar başlatR’ınız donarsa, Oturum menüsüne gidip “R’ı Yeniden Başlat” ı tıklayarak R’ı yeniden başlatabilirsiniz. Bu, RStudio’yu kapatıp açma zahmetini ortadan kaldırır. Bunu yaptığınızda R ortamınızdaki şey kaldırılacaktır.","code":""},{"path":"rın-temelleri.html","id":"klavye-kısayolları","chapter":"3 R’ın Temelleri","heading":"Klavye kısayolları","text":"Bazı çok kullanışlı klavye kısayolları aşağıdadır. Bu RStudio’nun ikinci sayfasında Windows, Mac ve Linux için tüm klavye kısayollarına ulaşabilirsiniz kullanıcı arayüzü kolaylaştırıcısı.\nİPUCU: Yazarken RStudio’nun otomatik tamamlama fonksiyonunu etkinleştirmek için Sekme tuşunuzu kullanın. Bu, yazım hatalarını önleyebilir. Şu ana kadar yazdıklarınıza bağlı olarak olası fonksiyonlar ve nesnelerin bir açılır menüsünü oluşturmak için yazarken Sekme tuşuna basın.","code":""},{"path":"rın-temelleri.html","id":"functions","chapter":"3 R’ın Temelleri","heading":"3.6 Fonksiyonlar”","text":"Fonksiyonlar, R’ı kullanmanın merkezinde yer alır. Fonksiyonlar, görevleri ve işlemleri nasıl gerçekleştirdiğinizdir. Pek çok fonksiyon R ile kurulu olarak gelir, daha pek çoğu paketlerde indirilebilir (paketler bölümünde açıklanmıştır) ve hatta kendi özel Fonksiyonlarınızı bile yazabilirsiniz!Fonksiyonlarla ilgili bu temel bilgiler bölümü şunları açıklar:Fonksiyon nedir ve nasıl çalışırFonksiyonun Değişkenleri(arguments) nelerdirBir fonksiyonu anlamak için nasıl yardım alınırSözdizimi (syntax) hakkında kısa bir : Bu el kitabında, fonksiyonlar açık ve kapalı parantezler içinde kod-metin içinde şöyle yazılmıştır: filter(). Paketler bölümünde açıklandığı gibi, Fonksiyonlar paketler içinde indirilir. Bu el kitabında, paket adları dplyr gibi kalın ile yazılmıştır. Bazen örnek kodda, fonksiyon adının, bunun gibi iki adet iki nokta üst üste (::) ile açıkça paketinin adıyla bağlantılı olduğunu görebilirsiniz: dplyr::filter(). Bu bağlantının amacı paketler bölümünde açıklanmıştır.","code":""},{"path":"rın-temelleri.html","id":"basit-fonksiyonlar","chapter":"3 R’ın Temelleri","heading":"Basit Fonksiyonlar","text":"Bir fonksiyon, girdileri alan, bu girdilerle bazı işlemler yapan ve bir çıktı üreten makine gibidir. Çıktının ne olduğu fonksiyona bağlıdır.Fonksiyonlar genellikle fonksiyonun parantezleri içine yerleştirilmiş bazı nesneler üzerinde çalışır. Örneğin, sqrt() fonksiyonu bir sayının karekökünü hesaplar:Bir fonksiyona sağlanan nesne ayrıca veri kümesindeki bir sütun olabilir (tüm nesne türleri hakkında ayrıntılı bilgi için Nesneler bölümüne bakın). R, birden çok veri kümesini depolayabildiğinden, hem veri kümesini hem de sütunu belirtmeniz gerekecektir. Bunu yapmanın bir yolu, veri kümesinin adını ve sütunun adını (“veri kümesi\\(sütun\") bağlamak için \"\\)” gösterimini kullanmaktır. Aşağıdaki örnekte, “summary()” fonksiyonu, “linelist” veri kümesindeki “age” sayısal sütununa uygulanır ve çıktı, sütunun sayısal ve eksik değerlerinin bir özetidir.: Perde arkasında, bir fonksiyon, kullanıcı için tek bir kolay komuta sarılmış karmaşık ek kodu temsil eder.","code":"\nsqrt(49)## [1] 7\n# 'linelist' veri kümesindeki 'age' sütununun özet istatistiklerini yazdır\nsummary(linelist$age)##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n##    0.00    6.00   13.00   16.07   23.00   84.00      86"},{"path":"rın-temelleri.html","id":"birden-çok-bağımsız-değişkene-sahip-fonksiyonlar","chapter":"3 R’ın Temelleri","heading":"Birden çok bağımsız değişkene sahip fonksiyonlar","text":"Fonksiyonlar genellikle,parantezleri içinde yer alan ve virgülle ayrılmış olan değişkenler adı verilen birkaç girdi ister.Fonksiyonun doğru çalışması için bazı değişkenler gereklidir, bazıları isteğe bağlıdırİsteğe bağlı bağımsız değişkenlerin varsayılan ayarları vardırDeğişkenler karakter, sayısal, mantıksal (DOĞRU/YANLIŞ) ve diğer girdi değerlerini alabilirTipik bir fonksiyona örnek olarak, ‘oven_bake()’ adlı eğlenceli bir kurgusal fonksiyonu burada bulabilirsiniz. Bir girdi nesnesi (örneğin, bir veri kümesi veya bu örnekte “hamur”) alır ve üzerinde ek bağımsız değişkenler (‘dakikalar =’ ve ‘sıcaklık =’) tarafından belirtildiği gibi işlemler gerçekleştirir. Çıktı konsola yazdırılabilir veya “<-” atama operatörü kullanılarak bir nesne olarak kaydedilebilir.Daha gerçekçi bir örnekte, aşağıdaki “age_pyramid()” komutu, tanımlanmış yaş gruplarına ve “cinsiyet” gibi ikili bir bölme sütununa dayalı bir yaş piramidi grafiği oluşturur. Fonksiyona, parantez içinde virgülle ayrılmış üç değişken verilir. Değişkenlere sağlanan değerler, kullanılacak veri çerçevesi olarak “satır listesi”ni, sayılacak sütun olarak “age_cat5”ve piramidi renge göre bölmek için kullanılacak ikili sütun olarak “gender”belirler.Yukarıdaki komut, değişken için yeni bir satırla daha uzun bir tarzda aşağıdaki gibi eşdeğer olarak yazılabilir. Bu stilin okunması daha kolay olabilir ve bölümü açıklamak için “#” ile “yorum” yazmak daha kolay olabilir (kapsamlı yorum yapmak iyi bir uygulamadır!). Bu daha uzun komutu çalıştırmak için tüm komutu vurgulayabilir ve “Çalıştır”tıklayabilir veya imlecinizi ilk satıra getirip ardından Ctrl ve Enter tuşlarına aynı anda basabilirsiniz.Bir bağımsız değişken atamasının ilk yarısının (örneğin, “veri =”), bağımsız değişkenler belirli bir sırada (fonksiyonun belgelerinde belirtilen) yazılmışsa belirtilmesi gerekmez. Aşağıdaki kod, yukarıdakiyle tam olarak aynı piramidi üretir, çünkü fonksiyon değişken sırasını kabul eder: satır listesi, “yaş_grubu” değişkeni, “bölme_göre” değişkeni.Daha karmaşık bir “age_pyramid()” komutu, aşağıdakilere yönelik isteğe bağlı değişkenleri içerebilir:Sayılar yerine oranları göster (varsayılan “YANLIŞ” olduğunda “orantılı = DOĞRU” olarak ayarlayın)Kullanılacak iki rengi belirtin (pal =, “palet”kısaltmasıdır ve iki renk adından oluşan bir vektörle sağlanır. ““c()” fonksiyonunun nasıl vektör oluşturduğunu öğrenmek için nesneler sayfasına bakın): İki taraflı belirtilecek değişkenler için (ör. orantılı = DOĞRU) değişkenlerin sıraları önemsizdir.","code":"\n# Bir yaş piramidi oluştur\nage_pyramid(data = linelist, age_group = \"age_cat5\", split_by = \"gender\")\n# Bir yaş piramidi oluştur\nage_pyramid(\n  data = linelist,        # Satır listesini kullan\n  age_group = \"age_cat5\", # Yaş grubu sütununu kullan\n  split_by = \"gender\"     # Piramidin iki tarafı için cinsiyet sütununu kullan\n  )\n# Bu komut yukarıdaki ile aynı grafiği üretecektir.\nage_pyramid(linelist, \"age_cat5\", \"gender\")\nage_pyramid(\n  linelist,                    # Satır listesini kullan\n  \"age_cat5\",                  # Yaş grubu sütununu kullan\n  \"gender\",                    # Cinsiyete göre ayır\n  proportional = TRUE,         # sayı yerine yüzdelik kullan\n  pal = c(\"orange\", \"purple\")  # renkleri turuncu ve mor\n  )"},{"path":"rın-temelleri.html","id":"fonksiyon-yazma","chapter":"3 R’ın Temelleri","heading":"Fonksiyon Yazma","text":"R, fonksiyonlara yönelik bir dildir, bu nedenle kendi fonksiyonlarınızı yazmak için yetkilendirilmiş hissetmeniz gerekir. Fonskiyonlar oluşturmak çeşitli avantajlar sağlar:Modüler programlamayı kolaylaştırmak için - kodun bağımsız ve yönetilebilir parçalara ayrılmasıHataya açık olabilen tekrarlayan kopyala ve yapıştır işlemlerinin değiştirilmesiKod parçalarına akılda kalıcı isimler verilmesiBir fonksiyonun nasıl yazılacağı Fonksiyon Yazma sayfasında derinlemesine ele alınmıştır.","code":""},{"path":"rın-temelleri.html","id":"packages","chapter":"3 R’ın Temelleri","heading":"3.7 Paketler","text":"Paketler fonksiyonları içerir.Bir R paketi, önceden tanımlanmış fonksiyonları içeren, paylaşılabilir bir kod ve belge paketidir. R topluluğundaki kullanıcılar, zaman belirli sorunlara yönelik paketler geliştirir, muhtemelen size yardımcı olabilecek bir tanesi mevcuttur! R kullanımınızda yüzlerce paket kuracak ve kullanacaksınız.Kurulum sırasında R, yaygın kullanılan görevleri gerçekleştiren “temel” paketleri ve fonksiyonları içerir. Ancak birçok R kullanıcısı, R topluluğu tarafından doğrulanan ve kendi kullanımınız için bir paket olarak indirebileceğiniz özel fonksiyonlar oluşturur. Bu el kitabında paket adları kalın ile yazılmıştır. R’ın daha zorlu yönlerinden biri, belirli bir görevi tamamlamak için seçilebilecek çok sayıda farklı fonksiyon veya paketin olmasıdır.","code":""},{"path":"rın-temelleri.html","id":"kurulum-ve-yükleme","chapter":"3 R’ın Temelleri","heading":"Kurulum ve Yükleme","text":"Fonksiyonlar, internetten bilgisayarınıza indirebileceğiniz (“kurulu”) paketler içerisinde yer almaktadır. Bir paket indirildiğinde, “kütüphanenizde” saklanır. Ardından, paketi “yükleyerek” mevcut R oturumunuz sırasında içerdiği fonksiyonlara erişebilirsiniz.R’ı kişisel kitaplığınız olarak düşünün: Bir paket indirdiğinizde, kütüphaneniz yeni bir fonksiyon kitabı kazanır, ancak o kitaptaki bir fonksiyonu kullanmak istediğinizde, kütüphanenizden o kitabı ödünç almanız (“yüklemeniz”) gerekir.Özetle: bir R paketinde bulunan fonksiyonları kullanmak için 2 adım uygulanmalıdır:Paket (bir defaya mahsus) kurulmalı, vePaket (R oturumu sırasında) yüklenmeli","code":""},{"path":"rın-temelleri.html","id":"senin-kütüphanen","chapter":"3 R’ın Temelleri","heading":"Senin Kütüphanen","text":"“Senin kütüphanen” aslında bilgisayarınızda kurulu olan paket için içerisinde farklı bir dosya oluşturulan bir klasördür. Bilgisayarınızda R’ın nerede kurulu olduğunu bulun ve “win-library” adlı bir klasör arayın. Örneğin: R\\win-library\\4.0 (4.0, R sürümüdür - indirdiğiniz R sürümü için farklı bir kitaplığınız olacaktır)..libPaths() (boş parantezler) girerek kitaplığınızın dosya yolunu yazdırabilirsiniz. Ağ sürücülerinde R ile çalışırken bu özellikle önemlidir.","code":""},{"path":"rın-temelleri.html","id":"cran-dan-kurulum","chapter":"3 R’ın Temelleri","heading":"CRAN ’dan Kurulum","text":"Çoğu zaman, R kullanıcıları paketleri CRAN’dan indirir. CRAN (Comprehensive R Archive Network - Kapsamlı R Arşiv Ağı), topluluk üyeleri tarafından yayınlanan R paketlerinin çevrimiçi genel deposudur.CRAN’dan bir paket indirirken virüsler ve güvenlik konusunda endişeleniyor musunuz? Konuyla ilgili bu makaleyi okuyabilirsiniz.","code":""},{"path":"rın-temelleri.html","id":"nasıl-kurulum-yapar-ve-yüklerim","chapter":"3 R’ın Temelleri","heading":"Nasıl kurulum yapar ve yüklerim?","text":"Bu el kitabında, pacman paketini (“paket yöneticisi” kısaltması) kullanmanızı öneririz. Gerekirse bir paketi kuracak ve mevcut R oturumunda kullanmak üzere yükleyecek uygun bir p_load() fonksiyonu sunar.Sözdizimi oldukça basit. Paketlerin adlarını ‘p_load()’ parantezleri içinde virgülle ayırarak listeleyin. Bu komut, henüz kurulmamışlarsa rio, tidyverse ve paketlerini kuracak ve bunları kullanım için yükleyecektir. Bu, komut dosyalarını başkalarıyla paylaşırken p_load() yaklaşımını kullanışlı ve özlü hale getirir. Paket adlarının büyük/küçük harfe duyarlı olduğunu unutmayın.Paket adını (pacman) fonksiyon adından (p_load()) önce açıkça yazan pacman::p_load() sözdizimini kullandığımızı ve iki adet iki nokta üst üste :: ile bağlandığını unutmayın. Bu sözdizimi, pacman paketini de yüklediği için kullanışlıdır (zaten kurulu olduğu varsayılarak).Sıklıkla göreceğiniz alternatif temel R fonksiyonları vardır. Bir paketi kurmak için temel R fonksiyonu install.packages() fonksiyonudur. Kurulacak paketin adı parantez içinde tırnak içinde belirtilmelidir. Bir komutta birden çok paket kurmak istiyorsanız, bunlar bir c() karakter vektörü içinde listelenmelidir.: Bu komut bir paketi kurar, ancak geçerli oturumda kullanmak için yüklemez.Kurulum ayrıca, RStudio “Paketler” bölmesine gidip istenen paket adını arayarak “Kur” seçeneğine tıklanarak da gerçekleştirilebilir.Bir paketi kullanmak üzere (kurulduktan sonra) yüklemek için temel R fonksiyonu ’library()’dir. Bir seferde yalnızca bir paket yükleyebilir (p_load() kullanmanın başka bir nedeni). Paket adını tırnak işaretleri ile veya tırnak işaretleri olmadan sağlayabilirsiniz.Bir paketin kurulu ve/veya yüklenmiş olup olmadığını kontrol etmek için RStudio’da Paketler bölmesini görüntüleyebilirsiniz. Paket kurulu ise sürüm numarası ile orada gösterilir. Kutusu işaretliyse, geçerli oturum için yüklenir.Github’dan KurulumBazen, henüz CRAN’da bulunmayan bir paketi yüklemeniz gerekir. Veya belki de paket CRAN’da mevcuttur, ancak daha kararlı yayınlanan CRAN sürümünde henüz sunulmayan yeni özelliklere sahip geliştirme sürümünü istiyorsunuzdur. Bunlar genellikle github.com web sitesinde ücretsiz, halka açık bir kod “deposu” içinde barındırılır. Git ve Github ile sürüm kontrolü ve işbirliği El kitabı sayfasından Github hakkında daha fazla bilgi edinebilirsiniz.Github’dan R paketlerini indirmek için, gerekirse paketi kuracak ve mevcut R oturumunuzda kullanmak üzere yükleyecek olan pacman’dan p_load_gh() fonksiyonunu kullanabilirsiniz. Kurulum alternatifleri arasında remotes veya devtools paketlerinin kullanılması yer alır. Paket belgelerinde tüm pacman fonksiyonları hakkında daha fazla bilgi edinin.Github’dan yüklemek için daha fazla bilgi sağlamanız gerekir. Şunları sağlamalısın:Depo sahibinin Github kimliğiPaketi içeren havuzun adı(isteğe bağlı) İndirmek istediğiniz “dalın” (özel geliştirme sürümü) adıAşağıdaki örneklerde, tırnak içindeki ilk kelime depo sahibinin Github ID’sidir, eğik çizgiden sonra deponun adı (paketin adı) olur.Ana dal dışında bir “daldan” (sürüm) kurulum yapmak istiyorsanız, dal adını depo adından sonra şu ifade ile birlikte “@” ekleyin.Github sürümü ile bilgisayarınızdaki sürüm arasında herhangi bir fark yoksa herhangi bir işlem yapılmayacaktır. “update = TRUE” değişkeni yerine “p_load_current_gh()” komutu kullanarak yeniden yüklemeyi “zorlayabilirsiniz” (force). Bu [çevrimiçi gösterimde] http://trinker.github.io/pacman/vignettes/Introduction_to_pacman.html adresinde pacman hakkında daha fazla bilgi edinin)ZIP veya TAR’dan yüklemePaketi bir URL’den yükleyebilirsiniz:Veya sıkıştırılmış bir dosyada bilgisayarınıza indirin:Seçenek 1: remotes paketinden install_local() kullanmakSeçenek 2: base R’dan install.packages() komutunu kullanarak, ZIP dosyasının dosya yolunu sağlayarak ve type = \"source ve repos = NULL ayarını yaparak.","code":"\n# Paketleri kurup yükleyebilirsiniz.(Gerekli görürseniz)\npacman::p_load(rio, tidyverse, here)\n# Temel R için bir paketin kurulumu\ninstall.packages(\"tidyverse\")\n\n# Temel R için çoklu paketlerin kurulumu\ninstall.packages(c(\"tidyverse\", \"rio\", \"here\"))\n# Temel R için paket yüklenmesi\nlibrary(tidyverse)\nlibrary(rio)\nlibrary(here)\n# Github deposundan epicontacts paketini kur ve yükle.\np_load_gh(\"reconhub/epicontacts\")\n# Github'dan epicontacts paketinin \"zaman çizelgesi\" dalını kurun\np_load_gh(\"reconhub/epicontacts@timeline\")\npackageurl <- \"https://cran.r-project.org/src/contrib/Archive/dsr/dsr_0.2.2.tar.gz\"\ninstall.packages(packageurl, repos=NULL, type=\"source\")\nremotes::install_local(\"~/Downloads/dplyr-master.zip\")\ninstall.packages(\"~/Downloads/dplyr-master.zip\", repos=NULL, type=\"source\")"},{"path":"rın-temelleri.html","id":"kod-sözdizimi","chapter":"3 R’ın Temelleri","heading":"Kod sözdizimi","text":"Bu el kitabındaki netlik için, fonksiyonlar önüne bazen aşağıdaki şekilde :: sembolü kullanılarak paketlerinin adı gelir: package_name::function_name()Bir oturum için bir paket yüklendiğinde, belirgin stil gerekli değildir. Sadece function_name() kullanılabilir. Bununla birlikte, bir fonksiyon adı yaygın olduğunda ve birden çok pakette bulunabileceğinde paket adını yazmak yararlıdır (örneğin, plot()). Paket adının yazılması, henüz yüklenmemişse paketi de yükleyecektir.","code":"\n# Bu komut, bir veri kümesini içe aktarmak için \"rio\" paketini ve \"import()\" fonksiyonunu kullanır.\nlinelist <- rio::import(\"linelist.xlsx\", which = \"Sheet1\")"},{"path":"rın-temelleri.html","id":"fonksiyon-yardımı","chapter":"3 R’ın Temelleri","heading":"Fonksiyon yardımı","text":"Bir fonksiyon hakkında daha fazlasını okumak için, sağ alt RStudio’nun Yardım sekmesinde onu arayabilirsiniz. Ayrıca ?fonksiyonadı (fonksiyonun adını bir soru işaretinden sonra koyun) gibi bir komut çalıştırabilirsiniz ve Yardım bölmesinde Yardım sayfası görünecektir. Son olarak, kaynakları çevrimiçi olarak aramayı deneyin.","code":""},{"path":"rın-temelleri.html","id":"paketleri-güncelleyin","chapter":"3 R’ın Temelleri","heading":"Paketleri güncelleyin","text":"Paketleri yeniden yükleyerek güncelleyebilirsiniz. Hangi paketlerin kurulacak yeni sürümleri olduğunu görmek için RStudio Paketleri bölmenizdeki yeşil “Güncelle” düğmesini de tıklayabilirsiniz. Bir fonksiyonun nasıl çalıştığına dair büyük bir revizyon varsa, eski kodunuzun güncellenmesi gerekebileceğini unutmayın!","code":""},{"path":"rın-temelleri.html","id":"paketleri-sil","chapter":"3 R’ın Temelleri","heading":"Paketleri sil","text":"pacman’den p_delete() veya base R’dan remove.packages() komutlarını kullanabilirsiniz. Alternatif olarak, kitaplığınızı içeren klasörü bulup manuel olarak silebilirsiniz.","code":""},{"path":"rın-temelleri.html","id":"bağlılıklar","chapter":"3 R’ın Temelleri","heading":"Bağlılıklar","text":"Paketler genellikle çalışmak için diğer paketlere bağlıdır. Bunlara bağlılıklar (dependencies)denir. Bir bağlılık yüklenemezse, buna bağlı olan paket de yüklenemeyebilir.p_depends() ile bir paketin bağlılıklarını görün ve p_depends_reverse() ile hangi paketlerin ona bağlı olduğunu görün","code":""},{"path":"rın-temelleri.html","id":"maskelenmiş-fonksiyonlar","chapter":"3 R’ın Temelleri","heading":"3.7.1 Maskelenmiş fonksiyonlar","text":"İki veya daha fazla paketin aynı fonksiyon adını içermesi nadir değildir. Örneğin, dplyr paketinin bir “filter()” fonksiyonu vardır, ancak stats paketinin de fonksiyonu vardır. Varsayılan ‘filter()’ fonksiyonu, bu paketlerin R oturumunda ilk yüklendiği sıraya bağlıdır - sonraki, ‘filter()’ komutu için varsayılan olacaktır.Sırayı R Studio’nun Ortam bölmesinde kontrol edebilirsiniz - “Global Ortam” açılır menüsünü tıklayın ve paketlerin sırasını görün. Bu açılır listedeki alt paketlerdeki fonksiyonlar, açılır listede daha yukarıda görünen paketlerdeki aynı ada sahip fonksiyonları maskeleyecektir. Bir paketi ilk yüklerken, maskeleme meydana gelirse R sizi konsolda uyarır, ancak bunu gözden kaçırmak kolay olabilir.Maskelemeyi düzeltmenin yolları şunlardır:Komutta paket adını belirtin. Örneğin, dplyr::filter() kodunu kullanınPaketlerin yüklenme sırasını yeniden düzenleyin (ör. p_load() içinde) ve yeni bir R oturumu başlatın","code":""},{"path":"rın-temelleri.html","id":"ayır-kaldır","chapter":"3 R’ın Temelleri","heading":"Ayır / kaldır","text":"Bir paketi ayırmak (kaldırmak) için, bu komutu doğru paket adı ve yalnızca bir iki nokta üst üste ile kullanın. Bunun maskelemeyi çözmeyebileceğini unutmayın.","code":"\ndetach(package:PACKAGE_NAME_HERE, unload=TRUE)"},{"path":"rın-temelleri.html","id":"eski-sürümü-yükleyin","chapter":"3 R’ın Temelleri","heading":"Eski sürümü yükleyin","text":"Belirli bir paketin daha eski bir sürümünü yüklemek için bu kılavuza bakabilirsiniz.","code":""},{"path":"rın-temelleri.html","id":"önerilen-paketler","chapter":"3 R’ın Temelleri","heading":"Önerilen paketler","text":"Günlük epidemiyoloji için önerdiğimiz paketlerin listesi için Önerilen paketler sayfasına bakabilirsiniz.","code":""},{"path":"rın-temelleri.html","id":"scripts","chapter":"3 R’ın Temelleri","heading":"3.8 Komut Dosyaları","text":"Komut dosyaları, programlamanın temel bir parçasıdır. Komutlarınızı tutan belgelerdir (örneğin, veri kümeleri oluşturma ve değiştirme fonksiyonları, baskı görselleştirmeleri vb.). Bir komut dosyasını kaydedebilir ve daha sonra yeniden çalıştırabilirsiniz. Komutlarınızı bir komut dosyasında saklamanın ve çalıştırmanın (komutları tek tek R konsolu “komut satırına” yazmaya kıyasla) birçok avantajı vardır:Taşınabilirlik - çalışmalarınızı komut dosyalarınızı göndererek başkalarıyla paylaşabilirsinizTekrarlanabilirlik - böylece siz ve diğerleri tam olarak ne yaptığınızı bilirSürüm kontrolü - böylece kendiniz veya meslektaşlarınız tarafından yapılan değişiklikleri takip edebilirsinizYorumlama/açıklama - meslektaşlarınıza ne yaptığınızı açıklamak için kullanabilirsiniz","code":""},{"path":"rın-temelleri.html","id":"yorum-yapma","chapter":"3 R’ın Temelleri","heading":"Yorum yapma","text":"Bir komut dosyasında, R kodunuzun etrafına açıklama da (“yorum”) yapabilirsiniz. Yorum yapmak, kendinize ve diğer okuyuculara ne yaptığınızı açıklamanıza yardımcı olur. Hashtag sembolünü (#) yazıp ardından yorumunuzu yazarak yorum ekleyebilirsiniz. Yorum yapılan metin, R kodundan farklı bir renkte görünecektir.#’dan sonra yazılan hiçbir kod çalıştırılmayacaktır. Bu nedenle, kodun önüne bir # koymak, silmek istemiyorsanız bir kod satırını geçici olarak engellemenin (“yorum yapma”) da yararlı bir yoludur. Ctrl+Shift+c (Mac’te Cmd+Shift+c) tuşlarına basarak aynı anda birden fazla satırda yorum yapabilir ve vurgular oluşturabilirsiniz.Ne yaptığınız hakkında ve neden yaptığınız hakkında yorum yapın.Kodunuzu mantıksal bölümlere ayırınYaptığınız işin adım adım açıklamasını içeren bir metinle kodunuza eşlik edin (ör. numaralandırılmış adımlar)","code":"\n# Bir yorum tek başına bir satırda olabilir\n# verileri içe aktar\nlinelist <- import(\"linelist_raw.xlsx\") %>%   # Bir yorum aynı zamanda kodun ardından gelebilir\n# filtre(yaş > 50)                # Bir kod satırını devre dışı bırakmak/kaldırmak için de kullanılabilir\n  count()"},{"path":"rın-temelleri.html","id":"stil","chapter":"3 R’ın Temelleri","heading":"3.8.1 Stil","text":"Özellikle bir ekip üzerinde çalışıyorsanız, kodlama stilinizin bilincinde olmak önemlidir. Biz tidyverse stil rehberini öneriyoruz. Bu stile uyum sağlamanıza yardımcı olan styler ve lintr gibi paketler de vardır.Kodunuzu başkaları tarafından okunabilir kılmak için birkaç temel nokta:\n* Nesneleri adlandırırken yalnızca küçük harf, sayı ve alt çizgi “_” kullanın, ör. benim_verilerim\n* Sık boşluklar kullanın, ör. “n = 1” ve “age_new <- age_old + 3”","code":""},{"path":"rın-temelleri.html","id":"örnek-komut-dosyası","chapter":"3 R’ın Temelleri","heading":"Örnek Komut Dosyası","text":"Aşağıda kısa bir R komut dosyası örneği verilmiştir. Unutmayın, kodunuzu yorumlarda ne kadar kısa ve öz bir şekilde açıklarsanız, iş arkadaşlarınız sizi o kadar çok sevecektir!","code":""},{"path":"rın-temelleri.html","id":"r-işaretleme-r-markdown","chapter":"3 R’ın Temelleri","heading":"R işaretleme (R Markdown)","text":"Bir R işaretleme komut dosyası, betiğin kendisinin bir çıktı belgesi (PDF, Word, HTML, Powerpoint, vb.) olduğu türüdür. Bunlar, genellikle dinamik ve otomatik raporlar oluşturmak için kullanılan inanılmaz derecede kullanışlı ve çok yönlü araçlardır. Bu web sitesi ve el kitabı bile R işaretleme komut dosyaları ile üretilmiştir!Yeni başlayan R kullanıcılarının da R Markdown’ı kullanabileceğini belirtmekte fayda var - gözünüz korkmasın! Daha fazla bilgi edinmek için, R Markdown ile Raporlar belgelerindeki el kitabı sayfasına bakabilirsiniz.","code":""},{"path":"rın-temelleri.html","id":"r-not-defterleri","chapter":"3 R’ın Temelleri","heading":"R not defterleri","text":"Rmarkdown ile R defterine yazmak arasında hiçbir fark yoktur. Ancak belgenin işlenmesi biraz farklıdır. Daha fazla ayrıntı için bu siteye bakabilirsiniz.","code":""},{"path":"rın-temelleri.html","id":"parlak","chapter":"3 R’ın Temelleri","heading":"Parlak","text":"Parlak uygulamalar/web siteleri, “app.R” olarak adlandırılması gereken tek bir komut dosyası içinde bulunur. Bu dosyanın üç bileşeni vardır:Bir kullanıcı arayüzü (user inteface(ui))Bir sunucu fonksiyonu“shinyApp” fonksiyonuna bir çağrı[Shiny ile Panolar]’daki el kitabı sayfasına veya bu çevrimiçi eğiticiye bakabilirsiniz: Parlak öğreticiÖnceleri yukarıdaki dosya iki dosyaya bölünmüş olarak mevcuttu. (ui.R ve server.R)","code":""},{"path":"rın-temelleri.html","id":"kod-katlama","chapter":"3 R’ın Temelleri","heading":"Kod katlama","text":"Komut dosyanızın okunmasını kolaylaştırmak için kod bölümlerini daraltabilirsiniz.Bunu yapmak için, # ile bir metin başlığı oluşturun, başlığınızı yazın ve ardından tire (-), kare (#) veya eşittir (=)’den birini en az 4 kez kullanın. Bunu yaptığınızda, soldaki “oluk”ta (satır numarasına göre) küçük bir ok belirecektir. Bu oku ve aşağıdaki kodu, bir sonraki başlık bitimine ve yerinde bir çift ok simgesi görünene kadar tıklayabilirsiniz.Kodu genişletmek için, ya cilt payındaki oku ya da çift ok simgesini tıklayın. Bu sayfanın RStudio bölümünde açıklandığı gibi klavye kısayolları da mevcuttur.# ile başlıklar oluşturarak, komut dosyanızın altında (aşağıya bakın) komut dosyanızda gezinmek için kullanabileceğiniz İçindekiler Tablosunu da etkinleştirirsiniz. Daha fazla # sembolü ekleyerek alt başlıklar oluşturabilirsiniz, örneğin birincil için #, ikincil için ## ve üçüncül başlıklar için ###.Aşağıda örnek bir komut dosyasının iki versiyonu bulunmaktadır. Solda, yorumlanmış başlıkları olan orijinaldir. Sağ tarafta, başlıktan sonra daraltılabilir hale getiren dört çizgi yazılmıştır. Bunlardan ikisi daraltılmıştır ve alttaki İçindekiler’artık bölümü gösterdiğini görebilirsiniz.Otomatik olarak katlama için uygun olan diğer kod alanları, fonksiyon tanımları veya koşullu bloklar (else ifadeleri) gibi “{ }” köşeli parantezli “köşeli” bölgeleri içerir. RStudio sitesinde kod katlama hakkında daha fazla bilgi edinebilirsiniz.","code":""},{"path":"rın-temelleri.html","id":"çalışma-dizini","chapter":"3 R’ın Temelleri","heading":"3.9 Çalışma dizini","text":"Çalışma dizini, R tarafından işiniz için kullanılan kök klasör konumudur - burada R, varsayılan olarak dosyaları arar ve kaydeder. Varsayılan olarak, yeni dosyaları ve çıktıları bu konuma kaydedecek ve içe aktarılacak dosyaları (örneğin veri kümeleri) burada da arayacaktır.Çalışma dizini, RStudio Konsol bölmesinin üst kısmında gri metin olarak görünür. Geçerli çalışma dizinini getwd() komutunu çalıştırarak da yazdırabilirsiniz (parantezleri boş bırakın).Yakın zamana kadar, R öğrenen birçok kişiye komut dosyalarına setwd() komutuyla başlamaları öğretiliyordu. Bunun yerine lütfen R projesi odaklı bir iş akışı kullanmayı düşünün ve setwd() kullanmama nedenleriniz için okuyunuz. Kısacası, işiniz bilgisayarınıza özel hale gelir, dosyaları içe ve dışa aktarmak için kullanılan dosya yolları “kırılgan” hale gelir ve bu, işbirliğini ve kodunuzun başka herhangi bir bilgisayarda kullanılmasını ciddi şekilde engeller. Kolay alternatifler var!Yukarıda belirtildiği gibi, çoğu durumda bu yaklaşımı önermesek de, setwd() komutunu alıntılarda istediğiniz klasör dosya yolu ile kullanabilirsiniz, örneğin:TEHLİKE: setwd() ile bir çalışma dizini ayarlamak dosya yolu bir bilgisayara özelse “kırılgan” olabilir. Bunun yerine, bir R Project kök dizinine göre dosya yollarını kullanın (burada paketiyle).","code":"\nknitr::include_graphics(here::here(\"images\", \"working_directory_1.png\"))\nsetwd(\"C:/Documents/R Files/My analysis\")"},{"path":"rın-temelleri.html","id":"manuel-olarak-ayarla","chapter":"3 R’ın Temelleri","heading":"Manuel olarak ayarla","text":"Çalışma dizinini manuel olarak ayarlamak için (’setwd()’nin tıklamakla eşdeğeri), Oturum açılır menüsünü tıklayın ve “Çalışma Dizinini Ayarla”ya ve ardından “Dizin Seç”e gidin. Bu, o belirli R oturumu için çalışma dizinini ayarlayacaktır. : Bu yaklaşımı kullanıyorsanız, RStudio’yu açtığınızda bunu manuel olarak yapmanız gerekecektir.","code":""},{"path":"rın-temelleri.html","id":"bir-r-projesi-içinde","chapter":"3 R’ın Temelleri","heading":"Bir R projesi içinde","text":"Bir R projesi kullanıyorsanız, çalışma dizini varsayılan olarak “.rproj” dosyasını içeren R projesi kök klasörü olacaktır. Bu, RStudio’yu R Project’(“.rproj” uzantılı dosya) tıklayarak açarsanız geçerli olacaktır.","code":""},{"path":"rın-temelleri.html","id":"r-markdown-için-çalışma-dizini","chapter":"3 R’ın Temelleri","heading":"R markdown için çalışma dizini","text":"Bir R markdown komut dosyasında, varsayılan çalışma dizini, Rmarkdown dosyasının (.Rmd) içinde kaydedildiği klasördür. Bir R projesi ve paketi kullanılıyorsa, bu geçerli değildir ve çalışma dizini R projeleri sayfasında açıklandığı gibi ‘()’ olacaktır.Tek başına bir R markdown çalışma dizinini değiştirmek istiyorsanız (bir R projesinde değil), ‘setwd()’ kullanırsanız, bu yalnızca o belirli kod yığını için geçerli olacaktır. Bir R işaretlemesindeki tüm kod parçalarında değişiklik yapmak için, aşağıdaki gibi “root.dir =” parametresini eklemek için kurulum öbeğini düzenlemelisiniz:Bir R projesinde sadece R işaretlemesini kullanmak ve paketini kullanmak çok daha kolaydır.","code":"\nknitr::opts_knit$set(root.dir = 'desired/directorypath')"},{"path":"rın-temelleri.html","id":"dosya-yolları-sağlama","chapter":"3 R’ın Temelleri","heading":"Dosya yolları sağlama","text":"Yeni başlayanlar için (en azından bir Windows makinesinde) belki de en yaygın hayal kırıklığı kaynağı, verileri içe veya dışa aktarmak için bir dosya yoluna yazmaktır. İçe ve dışa aktar sayfasında dosya yollarının en iyi nasıl girileceğine dair kapsamlı bir açıklama vardır, ancak burada birkaç önemli nokta vardır:Bozuk yollarAşağıda bir “mutlak” veya “tam adres” dosya yolu örneği verilmiştir. Bunlar başka bir bilgisayar tarafından kullanılırsa büyük olasılıkla kırılacaktır. Bir istisna, paylaşılan/ağ sürücüsü kullanmanızdır.** Eğik yön**Bir dosya yolu yazıyorsanız, eğik çizgilerin yönüne dikkat edin. Bileşenleri ayırmak için eğik çizgi (/) kullanın (“data/provincial.csv”). Windows kullanıcıları için, dosya yollarının varsayılan görüntülenme şekli ters eğik çizgi (\\) iledir - bu nedenle eğik çizginin yönünü değiştirmeniz gerekecektir. paketini R projeleri sayfasında açıklandığı gibi kullanırsanız, eğik çizgi bir sorun olmaz.Göreceli dosya yollarıBunun yerine genellikle “göreceli” dosya yolları sağlamanızı öneririz - yani, R Projenizin köküne göre olan yol. Bunu, R projeleri sayfasında açıklandığı gibi paketini kullanarak yapabilirsiniz. Göreceli bir dosya yolu şöyle görünebilir:Bir R projesinde göreli dosya yolları kullanıyor olsanız bile, R projenizin dışında verileri içe/dışa aktarmak için mutlak yolları kullanabilirsiniz.","code":"C:/Kullanıcılar/Ad/Belge/Analitik Yazılım/R/Projeler/Analiz2019/data/March2019.csv\n# Bir R projesinin veri/satır listesi/temiz/alt klasörlerinden csv satır listesini içe aktarın\nlinelist <- import(here(\"data\", \"clean\", \"linelists\", \"marin_country.csv\"))"},{"path":"rın-temelleri.html","id":"objects","chapter":"3 R’ın Temelleri","heading":"3.10 Nesneler","text":"R’daki şey bir nesnedir ve R, “nesne yönelimli” bir dildir. Bu bölümler şunları açıklayacaktır:Nesneler nasıl oluşturulur (<-)Nesne türleri (örn. veri çerçeveleri, vektörler..)Nesnelerin alt bölümlerine nasıl erişilir (ör. bir veri kümesindeki değişkenler)Nesne sınıfları (örn. sayısal, mantıksal, tamsayı, çift, karakter, faktör)","code":""},{"path":"rın-temelleri.html","id":"her-şey-bir-nesnedir","chapter":"3 R’ın Temelleri","heading":"Her şey bir nesnedir","text":"Bu bölüm R4Epis projesinden uyarlanmıştır.\nR’da sakladığınız şey - veri kümeleri, değişkenler, köy isimleri listesi, toplam nüfus sayısı, hatta grafikler gibi çıktılar - atanmış bir adla ve alıntılanabilen nesnelerdir.Bir nesneye bir değer atadığınızda var olur (aşağıdaki atama bölümüne bakın). Bir değer atandığında, nesne Ortamda görünür (RStudio’nun sağ üst bölmesine bakın). Daha sonra çalıştırılabilir, manipüle edilebilir, değiştirilebilir ve yeniden tanımlanabilir.","code":""},{"path":"rın-temelleri.html","id":"nesneleri-tanımlama--","chapter":"3 R’ın Temelleri","heading":"Nesneleri tanımlama (<-)","text":"<- operatörüyle nesnelere bir değer atayarak nesneler oluşturun.\n“<-” atama operatörü olarak tanımlanır. Atama komutları genellikle standart bir sıra izler:nesne_adı <- değer (veya bir değer üreten süreç/hesaplama)Örneğin, mevcut epidemiyolojik raporlama haftasını daha sonraki kodda referans için bir nesne olarak kaydetmek isteyebilirsiniz. Bu örnekte, “current_week” nesnesi “2018-W10”’ değeri atandığında oluşturulur (tırnak işaretleri bunu bir karakter değeri yapar). ‘current_week’ nesnesi daha sonra RStudio Ortam bölmesinde (sağ üst) görünecek ve sonraki komutlarda başvurulabilecektir.Aşağıdaki kutularda R komutlarına ve çıktılarına bakabilirsiniz.: R konsol çıktısındaki [1] sadece çıktının ilk öğesini görüntülediğinizi belirtirDİKKAT: Bir nesnenin değerinin üzerine yeniden tanımlamak için bir atama komutu herhangi bir zamanda yazılabilir Bu nedenle, çalışan komutların sırası çok önemlidir.Aşağıdaki komut, “current_week” değerini yeniden tanımlayacaktır:Eşittir işaretleri =Ayrıca R kodunda eşittir işaretleri göreceksiniz:İki nesne veya değer arasındaki bir çift eşittir işareti == mantıksal bir soru sorar: “buna eşit mi?”.Ayrıca, fonskiyonların değişkenlerinin değerlerini belirtmek için kullanılan eşittir işaretlerini de göreceksiniz (bunlar hakkında aşağıdaki bölümlerde okuyun), örneğin max(age, na.rm = TRUE).Nesneleri oluşturmak ve tanımlamak için <- yerine tek bir eşittir işareti = kullanabilirsiniz, ancak bu önerilmez. Bunun neden önerilmediğini buradan okuyabilirsiniz.Veri kümeleri (Datasets)Veri kümeleri de nesnelerdir (tipik olarak “veri çerçeveleri”) ve içe aktarıldıklarında adlarının atanması gerekir. Aşağıdaki kodda, ‘linelist’ nesnesi oluşturulur ve rio paketi ve ‘import()’ fonksiyonu ile içe aktarılan bir CSV dosyasının değeri atanır.[İçe aktarma ve dışa aktarma] bölümünden veri kümelerini içe ve dışa aktarma hakkında daha fazla bilgi edinebilirsiniz.DİKKAT: Nesnelerin adlandırılmasıyla ilgili kısa bir :Nesne adları boşluk içermemelidir, ancak boşluk yerine alt çizgi (_) veya nokta (.) kullanabilirsiniz.Nesne adları büyük/küçük harfe duyarlıdır (yani Veri Kümesi_A, veri kümesi_A’dan farklıdır).Nesne adları bir harfle başlamalıdır (1, 2 veya 3 gibi bir sayı ile başlayamaz).ÇıktılarTablolar ve çizimler gibi çıktılar, çıktıların nesneler olarak nasıl kaydedilebileceğine veya kaydedilmeden nasıl yazdırılabileceğine dair bir örnek sağlar. Temel R fonksiyonu “table()” kullanılarak cinsiyet ve kazanç tablosu doğrudan R konsoluna yazdırılabilir (kaydedilmeden).Ancak aynı tablo adlandırılmış bir nesne olarak kaydedilebilir. Daha sonra isteğe bağlı olarak yazdırılabilir.SütunlarBir veri kümesindeki sütunlar da nesnelerdir ve aşağıda Sütunlar bölümünde açıklandığı gibi tanımlanabilir, üzerine yazılabilir ve oluşturulabilirdir.Yeni bir sütun oluşturmak için temel R’dan atama operatörünü kullanabilirsiniz. Aşağıda, yeni sütun “bmi” (Vücut Kitle İndeksi) oluşturulur ve satır için yeni değer, satırın “wt_kg” ve “ht_cm” sütunlarındaki değeri üzerindeki matematiksel bir işlemin sonucudur.Bununla birlikte, bu el kitabında, dplyr paketindeki mutate() fonksiyonunu ve tünel operatörüyle (%>%) piping fonksiyonunu kullanan sütunları tanımlamaya yönelik farklı bir yaklaşımı vurguluyoruz. Sözdiziminin okunması daha kolaydır ve [Temizleme verileri ve temel fonksiyonlar] sayfasında açıklanan başka avantajları da vardır. tünelleme hakkında daha fazla bilgiyi aşağıdaki Tünelleme bölümünde okuyabilirsiniz.<!PİPİNG OLAYINI HİÇ ANLAMADIM– ======================================================= –>","code":"\ncurrent_week <- \"2018-W10\"   # bu komut, bir değer atayarak current_week nesnesini yaratır.\ncurrent_week                 # bu komut, geçerli_hafta nesnesinin geçerli değerini konsolda yazdırır## [1] \"2018-W10\"\ncurrent_week <- \"2018-W51\"   # current_week nesnesine YENİ bir değer atar\ncurrent_week                 # bu yeni değeri konsolda yazdırır## [1] \"2018-W51\"\n# satır listesi oluşturulur ve içe aktarılan CSV dosyasının değeri atanır\nlinelist <- import(\"my_linelist.csv\")\n# yalnızca R konsoluna yazdırılır\ntable(linelist$gender, linelist$outcome)##    \n##     Death Recover\n##   f  1227     953\n##   m  1228     950\n# kayıt\ngen_out_table <- table(linelist$gender, linelist$outcome)\n\n#  yazdırma\ngen_out_table##    \n##     Death Recover\n##   f  1227     953\n##   m  1228     950\n# temel R sözdizimini kullanarak yeni \"bmi\" sütunu oluşturun\nlinelist$bmi <- linelist$wt_kg / (linelist$ht_cm/100)^2\n# dplyr sözdizimini kullanarak yeni \"bmi\" sütunu oluşturun\nlinelist <- linelist %>% \n  mutate(bmi = wt_kg / (ht_cm/100)^2)"},{"path":"rın-temelleri.html","id":"nesne-yapısı","chapter":"3 R’ın Temelleri","heading":"Nesne yapısı","text":"Nesneler tek bir veri parçası olabilir (ör. “my_number <- 24”) veya yapılandırılmış verilerden oluşabilir.Aşağıdaki grafik bu çevrimiçi R eğitiminden ödünç alınmıştır. Bazı yaygın veri yapılarını ve adlarını gösterir. [GIS temelleri] sayfasında tartışılan uzamsal veriler bu görüntüye dahil değildir.Epidemiyolojide (ve özellikle saha epidemiyolojisinde), en yaygın olarak veri çerçeveleri ve vektörlerle karşılaşacaksınız:Hepsi aynı sınıftan (ör. sayısal, karakter) tekil nesneler dizisi için bir kapsayıcı. | **Veri çHepsi aynı sayıda satıra sahip olan birbirine bağlı vektörler (örneğin sütunlar). | `s“Tek başına” (bir veri çerçevesinin parçası olmayan) bir vektör oluşturmak için “c()” fonksiyonunun farklı öğeleri birleştirmek için kullanıldığını unutmayın. Örneğin, bir renk vektörü oluşturuyorsanız, grafiğin renk skalası: vector_of_colors <- c(\"blue\", \"red2\", \"orange\", \"grey\")","code":""},{"path":"rın-temelleri.html","id":"nesne-sınıfları","chapter":"3 R’ın Temelleri","heading":"Nesne sınıfları","text":"R’da depolanan tüm nesnelerin, R’nesneyi nasıl kullanacağını söyleyen bir sınıfı vardır. Birçok olası sınıf vardır, ancak ortak olanlar şunları içerir:Yalnızca tam olan sayılar (virgülden sonra ondalığı yok)Liste vektör gibidir, ancak diğer nesneler farklı sınıflara ait olabilir. | Bir listBir nesnenin sınıfını, adını class() fonksiyonuna vererek test edebilirsiniz. : Veri kümesinin adını ve sütunun adını ayırmak için “$” gösterimini kullanarak bir veri kümesi içindeki belirli bir sütuna başvurabilirsiniz.Bazen bir sütun R tarafından otomatik olarak farklı bir sınıfa dönüştürülür. Buna dikkat edin! Örneğin, bir vektörünüz veya sayı sütununuz varsa, ancak bir karakter değeri eklenirse… sütunun tamamı sınıf karakterine dönüşür.Bunun yaygın bir örneği, bir tablo yazdırmak için bir veri çerçevesini manipüle etmektir - toplam bir satır yaparsanız ve sayılarla aynı hücredeki yüzdeleri yapıştırmaya çalışırsanız (örneğin ‘23 (%40)’), yukarıdaki sayısal sütunun tamamı karaktere dönüştürülecek ve artık matematiksel hesaplamalar için kullanılamayacak.Bazen nesneleri veya sütunları başka bir sınıfa dönüştürmeniz gerekebilir.Benzer şekilde, belirli bir sınıfa ait bir nesnenin olup olmadığını kontrol etmek için temel R fonksiyonları vardır. Örneğin “.numeric()”, “.character()”, “.double()”, “.factor(),.integer()`R’daki sınıflar ve veri yapıları hakkında daha fazla çevrimiçi materyal.","code":"        | -5, 14, veya 2000                   | DOĞRU veya YANLIŞ\nclass(linelist) # sınıfı bir veri çerçevesi veya tibble olmalıdır## [1] \"data.frame\"\nclass(linelist$age) # sınıfı sayısal olmalıdır## [1] \"numeric\"\nclass(linelist$gender) # sınıfı karakter olmalı## [1] \"character\"\nnum_vector <- c(1,2,3,4,5)       # vektörü tüm sayılar olarak tanımla\nclass(num_vector)                # vektör sayısal bir sınıftır## [1] \"numeric\"\nnum_vector[3] <- \"üç\"            # üçüncü elemanı bir karaktere çevir\nclass(num_vector)                # vektör artık karakter sınıfıdır## [1] \"character\""},{"path":"rın-temelleri.html","id":"sütunlardeğişkenler","chapter":"3 R’ın Temelleri","heading":"Sütunlar/Değişkenler ($)","text":"Veri çerçevesindeki bir sütun teknik olarak bir “vektördür” (yukarıdaki tabloya bakın) - tümü aynı sınıfta olması gereken bir dizi değer (karakter, sayısal, mantıksal vb.).Bir vektör, bir veri çerçevesinden bağımsız olarak var olabilir. Örneğin, bir modelde açıklayıcı değişkenler olarak dahil etmek istediğiniz sütun adlarından oluşan bir vektör. “Bağımsız” bir vektör oluşturmak için aşağıdaki gibi c() fonksiyonunu kullanın:Bir veri çerçevesindeki sütunlar da vektörlerdir ve çağrılabilir, referans alınabilir, ayıklanabilir veya $ sembolü kullanılarak oluşturulabilir. $ sembolü, sütunun adını veri çerçevesinin adına bağlar. Bu el kitabında “değişken” yerine “sütun” kelimesini kullanmaya çalışıyoruz.Veri çerçevesinin adının ardından `$’ yazarak, veri çerçevesindeki tüm sütunların bir açılır menüsünü de göreceksiniz. Ok tuşunuzu kullanarak aralarında gezinebilir, Enter tuşu ile birini seçebilir ve yazım hatalarından kaçınabilirsiniz!GELİŞMİŞ İPUCU: Bazı daha karmaşık nesnelerin (örneğin bir liste veya bir “epicontacts” nesnesi) birden çok dolar işaretiyle erişilebilen birden çok düzeyi olabilir. Örneğin, epicontacts$linelist$date_onset","code":"\n# karakter değerlerinin bağımsız vektörünü tanımlayın\nexplanatory_vars <- c(\"gender\", \"fever\", \"chills\", \"cough\", \"aches\", \"vomit\")\n\n# bu adlandırılmış vektördeki değerleri yazdır\nexplanatory_vars## [1] \"gender\" \"fever\"  \"chills\" \"cough\"  \"aches\"  \"vomit\"\n# age_years vektörünün uzunluğunu alın\nlength(linelist$age) # (yaş, satır listesi veri çerçevesindeki bir sütundur)"},{"path":"rın-temelleri.html","id":"köşeli-ayraçlarla-erişimdizin","chapter":"3 R’ın Temelleri","heading":"Köşeli ayraçlarla erişim/dizin ([ ])","text":"Genellikle “[ ]” köşeli parantezleri kullanılarak yapılan, “indeksleme” olarak da adlandırılan nesnelerin parçalarını görüntülemeniz gerekebilir. Bir sütuna erişmek için bir veri çerçevesinde $ kullanmak da bir indeksleme türüdür.Köşeli parantezler ayrıca, bir “summary()” fonksiyonunun çıktısı gibi, döndürülen çıktının belirli bölümlerini döndürmek için de çalışır:Parantezler ayrıca belirli satırları ve sütunları görüntülemek için veri çerçeveleri üzerinde de çalışır. Bunu, dataframe[rows, column] sözdizimini kullanarak yapabilirsiniz:dplyr sözdizimini (satırlar için ‘filter()’ ve sütunlar için ‘select()’ fonksiyonları) kullanarak veri çerçeveleri ve tibbles üzerinde yukarıdaki satır/sütun indekslemeyi de gerçekleştirebileceğinizi unutmayın. [Temizleme verileri ve temel fonksiyonlar] sayfasında bu temel fonksiyonlar hakkında daha fazla bilgi edinin.“Satır numarasına” göre filtrelemek için, mantıksal bir filtreleme ifadesinin parçası olarak açık parantezlerle dplyr row_number() fonksiyonunu kullanabilirsiniz. Aşağıda gösterildiği gibi, genellikle bu mantıksal ifadenin bir parçası olarak “%%” operatörünü ve bir dizi sayıyı kullanacaksınız. ilk N satırı görmek için, özel dplyr fonksiyonu head() de kullanabilirsiniz.list sınıfının bir nesnesini indekslerken, yalnızca tek bir nesne döndürülse bile, tek parantezler zaman sınıf listesiyle birlikte döner. Ancak çift parantezler, tek bir öğeye erişmek ve listeden farklı bir sınıf döndürmek için kullanılabilir.\nParantezler ayrıca aşağıda gösterildiği gibi birbiri ardına yazılabilir.Bu liste indekslemenin tuzlukla görsel açıklaması komik ve faydalıdır.Konsola yazdırıldığında listenin nasıl göründüğü aşağıda açıklanmıştır. Nasıl adlandırılmış iki öğe olduğunu görün:“hospitals”, bir karakter vektörü“addresses”, adreslerin bir veri çerçevesiŞimdi çeşitli yöntemler kullanarak ayıklıyoruz:","code":"\nmy_vector <- c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\")  # Vektörün tanımlanması\nmy_vector[5]                                  # 5. ögenin yazdırılması## [1] \"e\"\n# Özetin tamamı\nsummary(linelist$age)##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n##    0.00    6.00   13.00   16.07   23.00   84.00      86\n# Özetin yalnızca ikinci ögesi, adıyla (yalnızca tek parantez kullanarak)\nsummary(linelist$age)[2]## 1st Qu. \n##       6\n# Sadece ikinci öge, isimsiz (çift parantez kullanarak)\nsummary(linelist$age)[[2]]## [1] 6\n# Bir öğeyi, adını göstermeden adıyla ayıklayın\nsummary(linelist$age)[[\"Median\"]]## [1] 13\n# Tüm sütunlarla birlikte veri kümesinden belirli bir satırı (2) görüntüleyin (virgül unutmayın!)\nlinelist[2,]\n\n# Tüm satırları görüntüleyin, ancak yalnızca bir sütun\nlinelist[, \"date_onset\"]\n\n# 2. satırdaki ve 5 ile 10 arasındaki sütunlardaki değerleri görüntüleyin\nlinelist[2, 5:10] \n\n# 2. satırdaki ve 5. ila 10. ve 18. sütunlardaki değerleri görüntüleyin\nlinelist[2, c(5:10, 18)] \n\n# 2'den 20'ye kadar olan satırları ve belirli sütunları görüntüleyin\nlinelist[2:20, c(\"date_onset\", \"outcome\", \"age\")]\n\n# Ölçüte göre satırları ve sütunları görüntüleyin\n# *** Veri çerçevesinin kriterlerde hala adlandırılması gerektiğine dikkat edin!\nlinelist[linelist$age > 25 , c(\"date_onset\", \"outcome\", \"age\")]\n\n# RStudio Viewer bölmesindeki çıktıları görmek için View()'i kullanın (okunması daha kolay)\n# *** View() fonksiyonunda büyük \"V\" harfini not edin\nView(linelist[2:20, \"date_onset\"])\n\n# Yeni bir nesne olarak kaydet\nnew_table <- linelist[2:20, c(\"date_onset\")] \n# İlk 100 satırı görüntüle\nlinelist %>% head(100)\n\n# Sadece 5. satırı görüntüke\nlinelist %>% filter(row_number() == 5)\n\n# 2'den 20'ye kadar olan satırları ve üç özel sütunu görüntüleyin (sütun adlarında tırnak işareti gerekmediğini unutmayın)\nlinelist %>% filter(row_number() %in% 2:20) %>% select(date_onset, outcome, age)\n# demo listesini tanımla\nmy_list <- list(\n  # Listedeki ilk öge karakter vektörü\n  hospitals = c(\"Central\", \"Empire\", \"Santa Anna\"),\n  \n  # Listedeki ikinci öge adreslerin veri çerçevesi\n  addresses   = data.frame(\n    street = c(\"145 Medical Way\", \"1048 Brown Ave\", \"999 El Camino\"),\n    city   = c(\"Andover\", \"Hamilton\", \"El Paso\")\n    )\n  )\nmy_list## $hospitals\n## [1] \"Central\"    \"Empire\"     \"Santa Anna\"\n## \n## $addresses\n##            street     city\n## 1 145 Medical Way  Andover\n## 2  1048 Brown Ave Hamilton\n## 3   999 El Camino  El Paso\nmy_list[1] # bu, \"list\" sınıfındaki öğeyi döndürür - öğe adı hala görüntüleniyor## $hospitals\n## [1] \"Central\"    \"Empire\"     \"Santa Anna\"\nmy_list[[1]] # bu yalnızca (adsız) karakter vektörünü döndürür## [1] \"Central\"    \"Empire\"     \"Santa Anna\"\nmy_list[[\"hospitals\"]] # ayrıca liste öğesinin adına göre dizin oluşturabilirsiniz## [1] \"Central\"    \"Empire\"     \"Santa Anna\"\nmy_list[[1]][3] # \"hastaneler\" karakter vektörünün üçüncü öğesini döndürür## [1] \"Santa Anna\"\nmy_list[[2]][1] # Bu, adres veri çerçevesinin ilk sütununu (\"sokak\") döndürür##            street\n## 1 145 Medical Way\n## 2  1048 Brown Ave\n## 3   999 El Camino"},{"path":"rın-temelleri.html","id":"nesneleri-kaldırma","chapter":"3 R’ın Temelleri","heading":"Nesneleri kaldırma","text":"‘rm()’ fonksiyonu ile (tırnak işaretleri olmadan) R ortamınızdan tek tek nesneleri kaldırabilirsiniz:Aşağıdakileri çalıştırarak tüm nesneleri kaldırabilirsiniz (çalışma alanınızı temizleyin):","code":"\nrm(object_name)\nrm(list = ls(all = TRUE))"},{"path":"rın-temelleri.html","id":"tünelleme","chapter":"3 R’ın Temelleri","heading":"3.11 Tünelleme (%>%)","text":"Nesnelerle çalışmaya yönelik iki genel yaklaşım şunlardır:Tüneller/tidyverse - tüneller nesneyi bir fonksiyondan diğerine gönderir - vurgu nesne değil eylem üzerindedirAra nesneleri tanımlayın - bir nesne tekrar tekrar tanımlanır - vurgu nesne üzerindedir","code":""},{"path":"rın-temelleri.html","id":"tüneller","chapter":"3 R’ın Temelleri","heading":"Tüneller","text":"Basitçe açıklandığı gibi, tünel operatörü (%>%) bir fonksiyondan diğerine bir ara çıktı iletir.\nBunu “sonrasında” demek gibi düşünebilirsiniz. Birçok fonksiyon %>% ile birbirine bağlanabilir.Tünelleme, eylemlerin gerçekleştirildiği nesneyi değil, bir dizi eylemi vurgularTüneller, bir nesne üzerinde bir dizi eylem gerçekleştirilmesi gerektiğinde en iyisidirTüneller, otomatik olarak dplyr ve tidyverse paketlerine dahil edilen magrittr paketinden gelirTüneller, kodu daha temiz ve okunması daha kolay, daha sezgisel hale getirebilirBu yaklaşımla ilgili daha fazla bilgiyi tidyverse [stil kılavuzunda] (https://style.tidyverse.org/pipes.html) okuyabilirsiniz.İşte “kek pişirmek” için kurgusal fonksiyonları kullanan karşılaştırma için sahte bir örnek. İlk olarak, tünel yöntemi:İşte tünellerin kullanımını açıklayan başka bir bağlantı.Tünelleme bir temel fonksiyon değildir. Tünelleri kullanmak için magrittr paketi kurulmalı ve yüklenmelidir (bu genellikle, onu içeren tidyverse veya dplyr paketi yüklenerek yapılır). magrittr belgelerinde tünelleme hakkında daha fazla bilgi edinebilirsiniz.Diğer R komutlarında olduğu gibi, tünellerin yalnızca sonucu görüntülemek veya “<-” atama operatörünün dahil olup olmadığına bağlı olarak bir nesneyi kaydetmek/yeniden kaydetmek için kullanılabileceğini unutmayın. ikisine de bakın:%<>%\nBu, magrittr paketinden bir “atama tüneli”dir ve bu, bir nesneyi ileriye taşır ve aynı zamanda nesneyi yeniden tanımlar*. Zincirdeki ilk tünel operatörü olmalıdır. Kısa yol. Aşağıdaki iki komut eşdeğerdir:","code":"\n# Tünel sözdizimi kullanarak kek pişirmenin sahte bir örneği\n\ncake <- flour %>%       # Kek pişirmek için önce undan başlanır, sonrasında...\n  add(eggs) %>%   # yumurtaları ekle\n  add(oil) %>%    # yağı ekle\n  add(water) %>%  # suyu ekle\n  mix_together(         # birlikte karıştır\n    utensil = spoon,\n    minutes = 2) %>%    \n  bake(degrees = 350,   # pişir\n       system = \"fahrenheit\",\n       minutes = 35) %>%  \n  let_cool()            # soğumaya bırak\n# Yaş kategorisine göre toplam sayım olarak tanımlayarak nesne oluşturun veya üzerine yazın (yazdırılmaz)\nlinelist_summary <- linelist %>% \n  count(age_cat)\n# Konsoldaki sayım tablosunu yazdırın, ancak kaydetmeyin\nlinelist %>% \n  count(age_cat)##   age_cat    n\n## 1     0-4 1095\n## 2     5-9 1095\n## 3   10-14  941\n## 4   15-19  743\n## 5   20-29 1073\n## 6   30-49  754\n## 7   50-69   95\n## 8     70+    6\n## 9    <NA>   86\nlinelist <- linelist %>%\n  filter(age > 50)\n\nlinelist %<>% filter(age > 50)"},{"path":"rın-temelleri.html","id":"ara-nesneleri-tanımlayın","chapter":"3 R’ın Temelleri","heading":"Ara nesneleri tanımlayın","text":"Nesneleri/veri çerçevelerini değiştirmeye yönelik bu yaklaşım, aşağıdaki durumlarda daha iyi olabilir:Birden çok nesneyi manipüle etmeniz gerekirseAnlamlı olan ve ayrı nesne adlarını hak eden ara adımlar varsaRiskler:adım için yeni nesneler oluşturmak, çok sayıda nesne oluşturmak anlamına gelir. Eğer yanlış olanı kullanırsan, bunu fark etmeyebilirsin!Tüm nesneleri adlandırmak kafa karıştırıcı olabilirHatalar kolayca tespit edilemeyebilirHer bir ara nesneyi adlandırın veya orijinalin üzerine yazın veya tüm fonksiyonları bir araya getirin. Hepsi kendi riskleriyle birlikte gelir.Aşağıda, yukarıdakiyle aynı sahte “kek” örneği verilmiştir, ancak bu stili kullanarak:Tüm fonksiyonları bir araya getirin - bunu okumak zordur:","code":"\n# bu yöntemi kullanarak kek pişirmenin sahte bir örneği (ara nesneleri tanımlama)\nbatter_1 <- left_join(flour, eggs)\nbatter_2 <- left_join(batter_1, oil)\nbatter_3 <- left_join(batter_2, water)\n\nbatter_4 <- mix_together(object = batter_3, utensil = spoon, minutes = 2)\n\ncake <- bake(batter_4, degrees = 350, system = \"fahrenheit\", minutes = 35)\n\ncake <- let_cool(cake)\n# birden çok fonksiyonu bir araya getirme/iç içe yerleştirme örneği - okunması zordur\ncake <- let_cool(bake(mix_together(batter_3, utensil = spoon, minutes = 2), degrees = 350, system = \"fahrenheit\", minutes = 35))"},{"path":"rın-temelleri.html","id":"operators","chapter":"3 R’ın Temelleri","heading":"3.12 Anahtar operatörler ve fonksiyonlar","text":"Bu bölüm, R’daki operatörleri detaylandırır, örneğin:Tanımsal operatörlerİlişkisel operatörler (küçüktür, eşittir çok ..)Mantıksal operatörler (ve, veya…)Eksik değerlerin işlenmesiMatematiksel operatörler ve fonksiyonlar (+/-, >, toplam(), medyan(), …)%% operatörü","code":""},{"path":"rın-temelleri.html","id":"atama-operatörleri","chapter":"3 R’ın Temelleri","heading":"Atama operatörleri","text":"<-R’daki temel atama operatörü <- şeklindedir. Öyle ki nesne_adı <- değer.\nBu atama operatörü = şeklinde de yazılabilir. Genel R kullanımı için <- kullanılmasını tavsiye ederiz.\nOkunabilirlik için bu tür operatörleri boşluklarla çevrelemenizi de öneririz.<<-[Yazma fonksiyonlarını] veya R’ı kaynaklı komut dosyalarıyla etkileşimli bir şekilde kullanıyorsanız, bu atama operatörünü <<- (base R’dan) kullanmanız gerekebilir. Bu operatör, daha yüksek bir ‘ana’ R Ortamında bir nesneyi tanımlamak için kullanılır. Bu çevrimiçi referansa bakabilirsiniz.%<>%Bu, bir nesneyi ileriye yönlendiren ve aynı zamanda nesneyi yeniden tanımlayan magrittr paketinden bir “atama tünelidir”. Zincirdeki ilk tünel operatörü olmalıdır. Aşağıda iki eşdeğer örnekte gösterildiği gibi kısa yoldur:Yukarıdaki aşağıdakine eşdeğerdir.%<+%Bu, ggtree paketi ile filogenetik ağaçlara veri eklemek için kullanılır. Filogenetik ağaçlar sayfasına veya bu çevrimiçi kaynak kitap sayfasına bakabilirsiniz.","code":"\nlinelist <- linelist %>% \n  mutate(age_months = age_years * 12)\nlinelist %<>% mutate(age_months = age_years * 12)"},{"path":"rın-temelleri.html","id":"ilişkisel-ve-mantıksal-operatörler","chapter":"3 R’ın Temelleri","heading":"İlişkisel ve mantıksal operatörler","text":"İlişkisel operatörler değerleri karşılaştırır ve genellikle yeni değişkenleri ve veri kümelerinin alt kümelerini tanımlarken kullanılır. R’daki ortak ilişkisel operatörler şunlardır:!=2 != 0TRUEAND ve gibi mantıksal operatörler, genellikle ilişkisel operatörleri bağlamak ve daha karmaşık kriterler oluşturmak için kullanılır. Karmaşık ifadeler, gruplama ve uygulama sırası için parantez ( ) gerektirebilir.| (dikey çizgi)Örneğin, aşağıda vaka tanımımızı oluşturmak için kullanmak istediğimiz iki değişkenli bir satır listemiz var, hep_e_rdt, bir test sonucu ve hanede başka vakalar olup olmadığını bize bildirecek other_cases_in_hh. Aşağıdaki komut, yeni “case_def” değişkenini yaratmak için “case_when()” fonksiyonunu kullanır:NA (eksik)“Muhtemel”R’ın büyük/küçük harf duyarlı olduğuna dikkat edin, bu nedenle “Pozitif”, “pozitif”ten farklıdır…","code":"\nlinelist_cleaned <- linelist %>%\n  mutate(case_def = case_when(\n    is.na(rdt_result) & is.na(other_case_in_home)            ~ NA_character_,\n    rdt_result == \"Positive\"                                 ~ \"Confirmed\",\n    rdt_result != \"Positive\" & other_cases_in_home == \"Yes\"  ~ \"Probable\",\n    TRUE                                                     ~ \"Suspected\"\n  ))"},{"path":"rın-temelleri.html","id":"eksik-değerler","chapter":"3 R’ın Temelleri","heading":"Eksik değerler","text":"R’da, eksik değerler “NA” (“ayrılmış” bir değer) özel değeriyle temsil edilir (büyük harfler N ve - tırnak içinde değil). Eksik verileri başka bir şekilde kaydeden verileri içe aktarırsanız (ör. 99, “Eksik” veya .), bu değerleri “NA” olarak yeniden kodlamak isteyebilirsiniz. Bunun nasıl yapılacağı İçe ve dışa aktar sayfasında ele alınmaktadır.Bir değerin “NA” olup olmadığını test etmek için “DOĞRU” veya “YANLIŞ” döndüren özel “.na()” fonksiyonunu kullanın.Eksik veri sayfasındaki eksik, sonsuz, “NULL” ve imkansız değerler hakkında daha fazla bilgi edinin. İçe ve dışa aktar sayfasındaki verileri içe aktarırken eksik değerleri nasıl dönüştüreceğinizi öğrenin.","code":"\nrdt_result <- c(\"Positive\", \"Suspected\", \"Positive\", NA)   # biri şüpheli, biri bilinmeyen iki pozitif vaka\nis.na(rdt_result)  # rdt_result değerinin NA olup olmadığını test eder## [1] FALSE FALSE FALSE  TRUE"},{"path":"rın-temelleri.html","id":"matematik-ve-istatistik","chapter":"3 R’ın Temelleri","heading":"Matematik ve istatistik","text":"Bu sayfadaki tüm operatörler ve fonksiyonlar, base R kullanılarak otomatik olarak kullanılabilir.","code":""},{"path":"rın-temelleri.html","id":"matematiksel-operatörler","chapter":"3 R’ın Temelleri","heading":"Matematiksel operatörler","text":"Bunlar genellikle toplama, bölme, yeni sütunlar vb. oluşturmak için kullanılır. Aşağıda R’daki yaygın matematiksel operatörler verilmiştir. Operatörlerin etrafına boşluk koyup koymamanız önemli değildir.","code":""},{"path":"rın-temelleri.html","id":"matematiksel-fonksiyonlar","chapter":"3 R’ın Temelleri","heading":"Matematiksel fonksiyonlar","text":": “round()” için “digits =”, yerleştirilen ondalık sayıyı belirtir. Bir dizi anlamlı rakama yuvarlamak için signif() kullanın.","code":""},{"path":"rın-temelleri.html","id":"bilimsel-gösterim","chapter":"3 R’ın Temelleri","heading":"Bilimsel gösterim","text":"Bilimsel gösterimin kullanılma olasılığı, “scipen” seçeneğinin değerine bağlıdır.?options belgesinden: scipen, sayısal değerleri sabit veya üstel gösterimde yazdırmaya karar verirken uygulanacak bir cezadır. Pozitif değerler sabite ve negatif değerler bilimsel gösterime eğilimlidir: ‘scipen’ basamaklarından daha geniş olmadığı sürece sabit gösterim tercih edilecektir.Düşük bir sayıya (örneğin 0) ayarlanırsa, zaman “açık” olacaktır. R oturumunuzda bilimsel gösterimi “kapatmak” için çok yüksek bir sayıya ayarlayın, örneğin:","code":"\n# bilimsel gösterimi kapat\noptions(scipen=999)"},{"path":"rın-temelleri.html","id":"yuvarlama","chapter":"3 R’ın Temelleri","heading":"Yuvarlama","text":"TEHLİKE: ‘round()’, yalnızca üst sayı çift ise 0,5’ten yuvarlayan “banker yuvarlaması”nı kullanır. Yarımları tutarlı bir şekilde en yakın tam sayıya yuvarlamak için janitor ‘dan ’round_half_up()’ kullanın. [Bu açıklamaya] bakabilirsiniz(https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html#explore-records--duplicated-values--spec-combinations--variables- -get_dupes)","code":"\n# işiniz için uygun yuvarlama fonksiyonunu kullanın\nround(c(2.5, 3.5))## [1] 2 4\njanitor::round_half_up(c(2.5, 3.5))## [1] 3 4"},{"path":"rın-temelleri.html","id":"istatistiksel-fonksiyonlar","chapter":"3 R’ın Temelleri","heading":"İstatistiksel fonksiyonlar","text":"DİKKAT: Aşağıdaki fonksiyonlar varsayılan olarak hesaplamalarda eksik değerleri içerecektir. “na.rm = TRUE” bağımsız değişkeni belirtilmedikçe, eksik değerler “YOK” çıktısıyla sonuçlanır. Bu, kısaca na.rm = T şeklinde yazılabilir.Notlar:“*quantile()“:”x” incelenecek sayısal vektördür ve “prob =” olasılıkları 0 ile 1.0 arasında olan sayısal bir vektördür, ör. “c(0.5, 0.8, 0.85)”**summary(): ortalama, medyan ve ortak yüzdelikler dahil olmak üzere sayısal bir vektörün özetini verirTEHLİKE: Yukarıdaki fonksiyonlardan birine bir sayı vektörü sağlıyorsanız, sayıları c() içine sardığınızdan emin olun.","code":"\n# Bir fonksiyona ham sayılar veriliyorsa, bunları c() içine sarın\nmean(1, 6, 12, 10, 5, 0)    # !!! YANLIŞ !!!  ## [1] 1\nmean(c(1, 6, 12, 10, 5, 0)) # DOĞRU## [1] 5.666667"},{"path":"rın-temelleri.html","id":"diğer-kullanışlı-fonksiyonlar","chapter":"3 R’ın Temelleri","heading":"Diğer kullanışlı fonksiyonlar","text":"    | `cut(linelist$age, 5)`","code":"    | `cut(linelist$age, 5)`"},{"path":"rın-temelleri.html","id":"in","chapter":"3 R’ın Temelleri","heading":"%in%","text":"Değerleri eşleştirmek ve bir değerin bir vektör veya veri çerçevesi içinde olup olmadığını hızlı bir şekilde değerlendirmek için çok kullanışlı bir operatör.Bir vektörün %%’inde olup olmadığını sormak için mantık ifadesinin önüne** bir ünlem işareti (!) koyun:“%%”, dplyr fonksiyonu “case_while()” kullanılırken çok kullanışlıdır. Bir vektörü önceden tanımlayabilir ve daha sonra ona başvurabilirsiniz. Örneğin:: Belki stringr’den str_detect() kullanarak kısmi bir dize algılamak istiyorsanız, c(\"1\", \"Yes\", \"yes\", \"y\" gibi bir karakter vektörünü kabul etmeyecektir. \"). Bunun yerine, “1|Yes|yes|y” gibi VEYA çubukları olan bir yoğunlaştırılmış dize normal ifade verilmelidir. Örneğin, str_detect(hospitalized, \"1|Yes|yes|y\"). Daha fazla bilgi için Karakterler ve dizeler hakkındaki sayfaya bakın.Bu komutla bir karakter vektörünü adlandırılmış bir normal ifadeye dönüştürebilirsiniz:","code":"\nmy_vector <- c(\"a\", \"b\", \"c\", \"d\")\n\"a\" %in% my_vector## [1] TRUE\n\"h\" %in% my_vector## [1] FALSE\n# inkar etmek, önüne ünlem işareti koymak\n!\"a\" %in% my_vector## [1] FALSE\n!\"h\" %in% my_vector## [1] TRUE\naffirmative <- c(\"1\", \"Yes\", \"YES\", \"yes\", \"y\", \"Y\", \"oui\", \"Oui\", \"Si\")\n\nlinelist <- linelist %>% \n  mutate(child_hospitaled = case_when(\n    hospitalized %in% affirmative & age < 18 ~ \"Hospitalized Child\",\n    TRUE                                      ~ \"Not\"))\naffirmative <- c(\"1\", \"Yes\", \"YES\", \"yes\", \"y\", \"Y\", \"oui\", \"Oui\", \"Si\")\naffirmative## [1] \"1\"   \"Yes\" \"YES\" \"yes\" \"y\"   \"Y\"   \"oui\" \"Oui\" \"Si\"\n# condense to \naffirmative_str_search <- paste0(affirmative, collapse = \"|\")  # Temel R ile yapılması seçeneği\naffirmative_str_search <- str_c(affirmative, collapse = \"|\")   # stringr paketi seçeneği\n\naffirmative_str_search## [1] \"1|Yes|YES|yes|y|Y|oui|Oui|Si\""},{"path":"rın-temelleri.html","id":"hatalar-ve-uyarılar","chapter":"3 R’ın Temelleri","heading":"3.13 Hatalar ve uyarılar","text":"Bu bölüm şunları açıklar:Hatalar ve uyarılar arasındaki farkR kodu yazmak için genel sözdizimi ipuçlarıKod yardımcılarıGenel hatalar, uyarılar ve sorun giderme ipuçları [Hatalar ve yardım] sayfasında bulunabilir.","code":""},{"path":"rın-temelleri.html","id":"hata-vs.-uyarı","chapter":"3 R’ın Temelleri","heading":"Hata VS. Uyarı","text":"Bir komut çalıştırıldığında, R Konsolu size kırmızı metinle uyarı veya hata mesajları gösterebilir.Bir uyarı, R’ın komutunuzu tamamladığı, ancak farkında olmanız gereken ek adımlar atması veya olağandışı çıktılar üretmesi gerektiği anlamına gelir.Bir uyarı, R’ın komutunuzu tamamladığı, ancak farkında olmanız gereken ek adımlar atması veya olağandışı çıktılar üretmesi gerektiği anlamına gelir.Bir hata, R’ın komutunuzu tamamlayamadığı anlamına gelir.Bir hata, R’ın komutunuzu tamamlayamadığı anlamına gelir.İpuçlarını ara:Hata/uyarı mesajı genellikle sorun için bir satır numarası içerir.Hata/uyarı mesajı genellikle sorun için bir satır numarası içerir.Bir nesne “bilinmiyorsa” veya “bulunamadıysa”, yanlış yazmış olabilirsiniz, library() ile bir paketi çağırmayı unutmuş veya değişiklik yaptıktan sonra betiğinizi yeniden çalıştırmayı unutmuş olabilirsiniz.Bir nesne “bilinmiyorsa” veya “bulunamadıysa”, yanlış yazmış olabilirsiniz, library() ile bir paketi çağırmayı unutmuş veya değişiklik yaptıktan sonra betiğinizi yeniden çalıştırmayı unutmuş olabilirsiniz.şey başarısız olursa, bazı anahtar terimlerle birlikte hata mesajını Google’kopyalayın - büyük olasılıkla başka biri bunun üzerinde çalışmıştır!","code":""},{"path":"rın-temelleri.html","id":"genel-sözdizimi-ipuçları","chapter":"3 R’ın Temelleri","heading":"Genel sözdizimi ipuçları","text":"Hataları ve uyarıları önlemek için R’da komut yazarken hatırlamanız gereken birkaç şey:Parantezleri zaman kapatın - ipucu: kod öbeği için “(” ve kapanış parantezleri “)” sayısını sayınSütun ve nesne adlarında boşluklardan kaçının. Bunun yerine alt çizgi ( _ ) veya nokta ( . ) kullanınBir fonksiyonun değişkenlerini virgülle ayırmayı unutmayın ve takip edinR büyük/küçük harf duyarlıdır, yani “Değişken_A”, “değişken_A”dan farklıdır","code":""},{"path":"rın-temelleri.html","id":"kod-yardımı","chapter":"3 R’ın Temelleri","heading":"Kod yardımı","text":"Herhangi bir komut dosyası (RMarkdown veya başka türlü), bir hata yaptığınızda ipucu verecektir. Örneğin, gereken yere virgül yazmayı veya bir parantez kapatmayı unuttuysanız, RStudio sizi uyarmak için betiğin sağ tarafında o satırda bir bayrak kaldıracaktır.","code":""},{"path":"ra-geçiş.html","id":"ra-geçiş","chapter":"4 R’a geçiş","heading":"4 R’a geçiş","text":"Aşağıda, R’geçiş yapmanız adına bazı tavsiyeler ve kaynaklar sunuyoruz.R, 1990’ların sonlarında ortaya çıktı ve o zamandan beri ciddi bir ölçüde büyüdü. O kadar gelişmiş ve geniş bir kapasiteye ulaştı ki ticari alternatifleri rekabeti koruyabilmek için R’ın gelişmelerine ayak uydurmaya çalıştılar! (R, SPSS, SAS, STATA ve Python’u karşılaştıran bu makaleyi okuyabilirsiniz).Tüm bunlarla birlikte R’ı öğrenmek 10 yıl öncesine göre artık çok daha kolay. Daha önceleri, R, yeni başlayanlar için zor olarak kabul edilirdi. RStudio gibi kullanıcı dostu arayüzler, tidyverse gibi sezgisel kodlar ve birçok eğitim kaynakları ile R kullanımı kolaylaştırıldı.Korkmayın - gelin R dünyasını keşfedin!","code":""},{"path":"ra-geçiş.html","id":"excelden-geçiş","chapter":"4 R’a geçiş","heading":"4.1 Excel’den geçiş","text":"Excel’den doğrudan R’geçiş yapmak artık çok daha ulaşılabilir bir hedeftir. Göz korkutucu görünebilir, ancak yapabilirsiniz!Güçlü Excel becerilerine sahip birinin tek başına Excel’de çok gelişmiş analizler yapabileceği doğrudur. Hatta VBA gibi komut araçlarını kullanarak yapılabilecek faaliyetler daha da artabilecektir. Excel tüm dünyada kullanılmaktadır ve bir epidemiyolog için önemli bir araçtır. Bununla birlikte, onu R ile tamamlamak, iş akışlarınızı önemli ölçüde iyileştirip genişletebilir.","code":""},{"path":"ra-geçiş.html","id":"faydaları","chapter":"4 R’a geçiş","heading":"Faydaları","text":"R’ın zamandan tasarruf, daha tutarlı ve doğru analiz, tekrarlanabilirlik, paylaşılabilirlik ve daha hızlı hata düzeltme açısından muazzam faydalar sunduğunu göreceksiniz. yeni yazılım gibi, ona aşina olmak için emek vermeniz gereken bir öğrenme “eğrisi” vardır. Birbirinden farklı kütüphaneleriyle R size yeni olasılıkların muazzam kapısını açacaktır.Excel, “seç ve tıkla” özelliği ile basit analizler ve görselleştirmeler oluşturmak için yeni başlayanlar tarafından kolayca kullanılabilen ve iyi bilinen bir yazılımdır. R’baktığınızda, fonksiyonlarına ve arayüzüne aşina olabilmeniz birkaç hafta sürebilir. Bununla birlikte, R, son yıllarda yeni başlayanlar için çok daha kolay hale gelmek adına önemli adımlar atmıştır.Birçok Excel iş akışı hafıza ve tekrarlamaya dayanır. Bu nedenle hata olasılığı çoktur. Ayrıca, genellikle veri temizleme, analiz metodolojisi ve kullanılan denklemler görünümden gizlenir. Yeni bir iş arkadaşının bir Excel çalışma kitabının ne yaptığını ve olası hataların nasıl giderileceğini öğrenmesi için önemli ölçüde bir zamana ihtiyaç duyabilir. R ile tüm adımlar komut dosyasına açıkça yazılır ve kolayca görüntülenebilir, düzenlenebilir, düzeltilebilir ve diğer veri kümelerine uygulanabilir.Excel’den R’geçişinize başlamak için zihniyetinizi birkaç önemli yaklaşımla düzenlemeniz gerekir:","code":""},{"path":"ra-geçiş.html","id":"düzenli-veri","chapter":"4 R’a geçiş","heading":"Düzenli veri","text":"Dağınık “insan tarafından okunabilen” veriler yerine makine tarafından okunabilen “düzenli” verileri kullanın. R’deki “düzenli” veriler konusunda açıklandığı gibi, “düzenli” veriler için üç ana şart vardır:değişkenin kendi sütunu olmalıdırHer gözlemin kendi satırı olmalıdırHer değerin kendi hücresi olmalıdırExcel kullanıcıları bu şartları Excel “tablolarının” verileri standartlaştırma ve daha tahmin edilebilir bir formata uyarlamada oynadığı rol gibi değerlendirebilir.“Düzenli” verilere bir örnek, bu el kitabında kullanılan durum satır listesi olabilir. değişken bir sütunda yer alır, gözlemin (bir vaka) kendine ait satırı vardır ve değer yalnızca bir hücrededir. Aşağıda, linelistin ilk 50 satırını görüntüleyebilirsiniz:Düzenli olmayan verilerle karşılaşmamızın ana nedeni, birçok Excel tablosunun makineler/yazılımlar tarafından değil, insanlar tarafından kolay okumaya öncelik verecek şekilde tasarlanmış olmasıdır.Farkı görmenize yardımcı olmak için, aşağıda insan-okunabilirliğe öncelik veren düzensiz verilere ilişkin bazı kurgusal örnekler verilmiştir.:Sorunlar: Yukarıdaki tabloda, R tarafından kolayca anlaşılamayacak olan birleştirilmiş hücreler mevcuttur. Hangi satırın “başlık” olarak kabul edilmesi gerektiği açık değildir. Renk tabanlı bir sözlük sağ taraftadır ve hücre değerleri renklerle temsil edilir - bu da R tarafından kolayca yorumlanamaz (ayrıca renk körlüğü olan insanlar tarafından da!). Ayrıca, farklı bilgi parçaları tek bir hücrede birleştirmiştir (bir alanda çalışan birden fazla ortak kuruluş gibi).Sorunlar: Yukarıdaki tabloda, veri kümesi içinde çok sayıda fazladan boş satır ve sütun vardır - bu, R’de temizlik sorunlarına neden olur. Ayrıca, belirli bir tedavi merkezi için GPS koordinatları iki satıra yayılmaktadır. Bir yan olarak - GPS koordinatları iki farklı biçimdedir!“Düzenli” veri kümeleri insan gözüyle rahatça okunabilir olmayabilir, fakat veri temizleme ve analiz süreçlerini çok daha kolay hale getirirler! Düzenli veriler çeşitli biçimlerde saklanabilir, örneğin “uzun” veya “geniş”“(bkz.[Pivot verileri]). Ancak yukarıdaki ilkeler hala gözetilmektedir.","code":""},{"path":"ra-geçiş.html","id":"fonksiyonlar","chapter":"4 R’a geçiş","heading":"Fonksiyonlar","text":"R terimi olan “fonksiyon” size yeni gelebilir, fakat bu kavram Excel’de formüller olarak mevcuttur. Excel’deki formüller ayrıca kesin sözdizimi gerektirir (örneğin, noktalı virgül ve parantez yerleştirilmesi). Tek yapmanız gereken birkaç yeni fonksiyonu ve bunların R’da nasıl birlikte çalıştıklarını öğrenmek.","code":""},{"path":"ra-geçiş.html","id":"kodlar","chapter":"4 R’a geçiş","heading":"Kodlar","text":"Düğmelere tıklayıp hücreleri sürüklemek yerine adımı ve prosedürü bir “komut dosyasına” yazacaksınız.\nExcel kullanıcıları, aynı zamanda bir komut dosyası oluşturma yaklaşımı kullanan “VBA makrolarına” aşina olabilir.R komut dosyası adım adım talimatlardan oluşur. Bu, herhangi bir iş arkadaşınızın komut dosyasını okumasını ve attığınız adımları kolayca görmesini sağlar. Bu aynı zamanda hataların veya hatalı hesaplamaların giderilmesine de yardımcı olur. Örnekler için komut dosyalarıyla ilgili [R temelleri] bölümüne bakabilirsiniz.İşte bir R kodu örneği:","code":""},{"path":"ra-geçiş.html","id":"excelden-ra-geçiş-kaynakları","chapter":"4 R’a geçiş","heading":"Excel’den R’a geçiş kaynakları","text":"Excel’den R’ye geçiş yapmanıza yardımcı olacak rehberlere yönelik bazı bağlantılar:R vs. ExcelExcel kullanıcıları için R’de RStudio kursu","code":""},{"path":"ra-geçiş.html","id":"r-excel-etkileşimi","chapter":"4 R’a geçiş","heading":"R-Excel etkileşimi","text":"R, Excel çalışma kitaplarını içe aktarmak, verilerle çalışmak, Excel dosyalarını dışa aktarmak/kaydetmek ve Excel sayfalarının nüanslarıyla çalışmak adına güçlü fonksiyonlara sahiptir.Estetik bazı Excel biçimlendirmelerinin çeviri sırasında kaybolabileceği doğrudur (örneğin, italik, yan metin, vb.). İş akışınız, orijinal Excel biçimlendirmesini korurken belgeleri R ve Excel arasında ileri geri aktarmayı gerektiriyorsa, openxlsx gibi paketleri deneyebilirsiniz.","code":""},{"path":"ra-geçiş.html","id":"statadan-geçiş","chapter":"4 R’a geçiş","heading":"4.2 Stata’dan geçiş","text":"Stata’dan R’gelmekİlk olarak Stata’yı kullanmayı öğrenen birçok epidemiyolog için R’geçmek göz korkutucu görünebilir. Ancak, iyi bir Stata kullanıcısıysanız, R’geçiş kesinlikle düşündüğünüzden daha kolay süreç olacaktır. Stata ve R arasında verilerin nasıl oluşturulabileceği, değiştirilebileceği ve ayrıca analizlerin nasıl yapılacağı konusunda bazı temel farklılıklar olsa bile bu temel farklılıkları öğrendikten sonra Stata becerilerinizi burada da kullabilirsiniz.Aşağıda, bu kılavuzu incelerken kullanışlı olabilecek, Stata ve R arasındaki bazı önemli akışları bulabilirsiniz.Genel notlarÇalışma diziniVerinin içe aktarılması ve görüntülenmesiBasit veri manipülasyonuTanımlayıcı analizBu liste, Stata komutlarını R’çevirmenin temelleri hakkında bir genel bakış sunmakla birlikte ayrıntılı değildir. R’geçiş yapan Stata kullanıcıları için ilgi çekici olabilecek başka birçok harika kaynak mevcuttur:https://dss.princeton.edu/training/RStata.pdfhttps://clanfear.github.io/Stata_R_Equivalency/docs/r_stata_commands.htmlhttp://r4stats.com/books/r4stata/","code":""},{"path":"ra-geçiş.html","id":"sasdan-geçiş","chapter":"4 R’a geçiş","heading":"4.3 SAS’dan geçiş","text":"SAS’dan R’gelmekSAS, halk sağlığı kurumlarında ve akademik araştırma alanlarında yaygın olarak kullanılmaktadır. Yeni bir dile geçiş nadiren basit bir süreç olsa da, SAS ve R arasındaki temel farkları anlamak, ana dilinizde edindiğiniz tecrübeleri yeni dile aktarmakta yardımcı olabilir.Aşağıda, SAS ve R arasındaki veri yönetimi ve tanımlayıcı analizdeki temel farklılıklar özetlenmektedir.Genel notlarÇalışma diziniVerinin içe aktarılması ve görüntülenmesiBasit veri manipülasyonuTanımlayıcı analizTanımlayıcı tablolar ile ilgili sayfaya bakınız. Seçenekler arasında base R’den ‘table()’ ve janitor paketinden ‘tabyl()’ bulunmaktadır. R birden fazla veri kümesi içerdiği için veri kümesi ve sütun adının belirtilmesi gerekmektedir.\n2x2’lik bir tabloda iki değişkenin çapraz tablosu proc freq data=Dataset; Tables rowvar*colvar; Run; komutuyla oluşturulabilir. | table(), tabyl() veya Tanımlayıcı tablolar sayfasında açıklandığı gibi diğer seçenekler kullanabilir.Birkaç değerli kaynak:R SAS SPSS Users (2011)SAS R, Second Edition (2014)","code":""},{"path":"ra-geçiş.html","id":"veri-formatları","chapter":"4 R’a geçiş","heading":"4.4 Veri formatları","text":"R rio paketinin, STATA .dta dosyaları, SAS .xpt ve.sas7bdat dosyaları, SPSS .por ve.sav dosyaları gibi dosyaları gibi pek çok dosyanın nasıl içe ve dışa aktarabileceğiyle ilgili ayrıntılar için İçe ve dışa aktar sayfasına bakınız.","code":""},{"path":"önerilen-paketler-1.html","id":"önerilen-paketler-1","chapter":"5 Önerilen paketler","heading":"5 Önerilen paketler","text":"Aşağıda R ile yapılan epidemiyolojik çalışmalarda yaygın olarak önerilen paketlerin uzun bir listesi bulunmaktadır. Aşağıdaki kodu kopyalayabilir ve çalıştırabilirsiniz. Bu paketlerin tümü CRAN’dan mevcut R oturumunda kullanılmak üzere indirilecektir. Paket zaten kuruluysa, yalnızca oturumda kullanılması için yüklenecektir.İstemediğiniz paketleri çıkarmak için kodu # sembolleri ile değiştirebilirsiniz.Ek :Aşağıdaki kodu çalıştırmadan önce pacman paketini kurmalısınız. Bunu install.packages(\"pacman\") ile yapabilirsiniz. Bu el kitabında, gerekirse paketi kuran mevcut R oturumunda kullanmak üzere yükleyen pacman’dan p_load()vurgu yapmaktayız. Ayrıca base R’dan library() ile önceden kurulmuş paketleri de yükleyebilirsiniz.Aşağıdaki kodda, yüklenen paketlerin bağımlı olduğu diğer paketler bir girinti ve hash ile belirtilmiştir. Örnek olarak, ggplot2’nin tidyverse altında nasıl listelendiği inceleyebilirsiniz.Yüklenen birden çok paket aynı adda fonksiyonlara sahipse, en son yüklenen paketten gelen fonksiyonun önceliklendirildiği masking ortaya çıkabilmektedir. [R temelleri] sayfasında daha fazlasını bulabilirsiniz. Bu tür çakışmaları yönetmek için conflicted paketini kullanabilirsiniz.pacman ve maskeleme hakkında daha fazla bilgi için paketlerle ilgili [R temelleri] bölümüne bakınız.Bu el kitabının hazırlanması sırasında kullanılan R, RStudio ve R paketlerinin sürümlerini görmek için [Yazı ve teknik notlar] sayfasına bakınız.","code":""},{"path":"önerilen-paketler-1.html","id":"packages-from-cran","chapter":"5 Önerilen paketler","heading":"5.1 Packages from CRAN","text":"","code":"\n##########################################\n# Önemli epidemiyoloji R paketlerinin listesi #\n##########################################\n\n# Bu komut dosyası, pacman R paketindeki p_load() işlevini kullanır, \n# paket yoksa indirilir ve zaten kuruluysa kullanım için yüklenir\n\n\n# \"pacman\" paketinin kurulu olduğundan emin olur\nif (!require(\"pacman\")) install.packages(\"pacman\")\n\n\n# Packages available from CRAN\n##############################\npacman::p_load(\n     \n     # R'ı öğrenmek\n     ############\n     learnr,   # RStudio Eğitimi bölmesinde etkileşimli rehberler\n     swirl,    # R konsolunda etkileşimli rehberler\n        \n     # proje ve dosya yönetimi\n     #############################\n     here,     # R proje ana klasörüne göre dosya yönetimi\n     rio,      # birçok veri türünün içe/dışa aktarımı\n     openxlsx, # çok sayfalı Excel çalışma kitaplarını içe/dışa aktarma\n     \n     # paket kurulumu ve yönetimi\n     ################################\n     pacman,   # paket indirme/yükleme\n     renv,     # ekiple çalışırken paket sürümlerini yönetme\n     remotes,  # Github'dan indirme\n     \n     # Genel veri yönetimi\n     #########################\n     tidyverse,    # düzenli veri analizi ve sunumu için birçok paket içerir\n          #dplyr,      # data yönetimi\n          #tidyr,      # data yönetimi\n          #ggplot2,    # data gösterimi\n          #stringr,    # dizeler ve karakterlerle çalışma\n          #forcats,    # faktörlerle çalışma\n          #lubridate,  # tarihlerle çalışma\n          #purrr       # yineleme ve listelerle çalışma\n     linelist,     # satır listesini temizleme\n     naniar,       # eksik verilerin değerlendirilmesi\n     \n     # İstatistik  \n     ############\n     janitor,      # tablolar ve veri temizleme\n     gtsummary,    # tanımlayıcı ve istatistiksel tablolar hazırlama\n     rstatix,      # istatistiksel testleri ve özetleri hızla çalıştırma\n     broom,        # regresyonlardan elde edilen sonuçları düzenleme\n     lmtest,       # likelihood-ratio testleri\n     easystats,\n          # parameters, # regresyonlardan elde edilen sonuçları alternatif düzenleme\n          # see,        # forest plot'ları alternatif görseleştirme \n     \n     # epidemic modelleme\n     ###################\n     epicontacts,  # Transmisyon networklarını analiz etme\n     EpiNow2,      # Rt tahmini\n     EpiEstim,     # Rt tahmini\n     projections,  # İnsidans projeksiyonları\n     incidence2,   # Epidemiyolojik eğrileri yapma ve insidans verilerini işleme\n     i2extras,     # İnsidans2 paketi için ekstra fonksiyonlar\n     epitrix,      # Faydalı epidemiyoloji fonksiyonları\n     distcrete,    # Ayrık dağılımlar\n     \n     \n     # plots - genel\n     #################\n     #ggplot2,         # tidyverse içinde bulunmaktadır\n     cowplot,          # plotları birleştirme  \n     # patchwork,      # plotları birleştirme   (alternatif)     \n     RColorBrewer,     # renk skalaları\n     ggnewscale,       # ek renk katmanları ekleme\n\n     \n     # plots - özel türler\n     ########################\n     DiagrammeR,       # DOT dilini kullanan diyagramlar\n     incidence2,       # epidemic eğriler\n     gghighlight,      # bir alt kümeyi vurgulama\n     ggrepel,          # akıllı etiketler\n     plotly,           # interaktif grafikler\n     gganimate,        # animasyonlu grafikler \n\n     \n     # gis\n     ######\n     sf,               # Basit Özellik formatı kullanarak uzamsal verileri yönetme\n     tmap,             # Basit haritalar üretme (Hem etkileşimli hem de statik haritalar oluşturulabilir)\n     OpenStreetMap,    # ggplot haritasına OSM temel haritası ekleme\n     spdep,            # geografik istatistikler\n     \n     # rutin raporlar\n     #################\n     rmarkdown,        # PDF, Word, Powerpoint ve HTML dosyaları üretme\n     reportfactory,    # R Markdown çıktılarının otomatik organizasyonu\n     officer,          # powerpoint\n     \n     # kontrol paneli\n     ############\n     flexdashboard,    # R Markdown komut dosyasını bir gösterge panosuna dönüştürme\n     shiny,            # etkileşimli web uygulamaları\n     \n     # sunum için tablolar\n     #########################\n     knitr,            # R Markdown raporu oluşturma ve html tabloları\n     flextable,        # HTML tablolar\n     #DT,              # HTML tablolar (alternatif)\n     #gt,              # HTML tablolar (alternatif)\n     #huxtable,        # HTML tablolar (alternatif) \n     \n     # filogenetik\n     ###############\n     ggtree,           # ağaçların görselleştirilmesi ve açıklanması\n     ape,              # filogenetik ve evrim analizi\n     treeio            # filogenetik dosyaları görselleştirme\n \n)"},{"path":"önerilen-paketler-1.html","id":"github-paketleri","chapter":"5 Önerilen paketler","heading":"5.2 Github paketleri","text":"Aşağıda, iki paketi doğrudan Github sunucularından indirmek için gerekli komutlar verilmiştir.epicontacts’ın geliştirme sürümü, zamansal bir x ekseni ile transmisyon ağaçları oluşturma özelliğini içermektedir.epirhandbook paketi bu el kitabı için tüm örnek verileri içermektedir. Bunun dışında el kitabının çevrimdışı sürümünü indirmek için kullanılabilir.","code":"\n# Github'dan indirilecek paketler (CRAN'da mevcut değildir)\n##########################################################\n\n# Epicontacts geliştirme versiyonu (x ekseni zamanına sahip transmisyon zincirleri icin)\npacman::p_install_gh(\"reconhub/epicontacts@timeline\")\n\n# Tüm örnek verileri de içeren bu el kitabının paketi\npacman::p_install_gh(\"appliedepi/epirhandbook\")"},{"path":"r-projeleri.html","id":"r-projeleri","chapter":"6 R projeleri","heading":"6 R projeleri","text":"Bir R projesi, çalışmanızın taşınabilir, bağımsız bir klasörde paketlenmesini sağlar. Proje klasörü içinde, ilgili tüm komutlar, veri dosyaları, şekiller/çıktılar ve geçmiş kayıtları alt klasörlerde saklanır. Çalışma dizini projenin ana klasörüdür.","code":""},{"path":"r-projeleri.html","id":"önerilen-kullanım","chapter":"6 R projeleri","heading":"6.1 Önerilen kullanım","text":"R’ı kullanmanın yaygın, verimli ve sorunsuz bir yolu bu 3 unsuru birleştirmektir. Herbir proje, bir R klasörü içinde barındırılmaktadır. İlgili başlıklar aşağıdaki bölümlerde açıklanmıştır.Bir R projesi\nVeriler, komut dosyaları, çıktılar vb. için ilgili klasörlerden oluşan bağımsız bir çalışma ortamı.\nVeriler, komut dosyaları, çıktılar vb. için ilgili klasörlerden oluşan bağımsız bir çalışma ortamı.Alternatif dosya yolakları için paketi\nDosya yolakları, R projesinin ana klasörüne göre yazılır - daha fazla bilgi için İçe ve dışa aktar bölümüne bakınız.\nDosya yolakları, R projesinin ana klasörüne göre yazılır - daha fazla bilgi için İçe ve dışa aktar bölümüne bakınız.İçe/dışa aktarma için rio paketi\nimport() ve export(), herhangi bir dosya türünü uzantısına göre işler (ör. .csv, .xlsx, .png)\nimport() ve export(), herhangi bir dosya türünü uzantısına göre işler (ör. .csv, .xlsx, .png)","code":""},{"path":"r-projeleri.html","id":"bir-r-projesi-yaratma","chapter":"6 R projeleri","heading":"6.2 Bir R projesi yaratma","text":"Bir R projesi oluşturmak için Dosya menüsünden “Yeni Proje” seçeneğini seçiniz.Proje için yeni bir klasör oluşturmak istiyorsanız, “Yeni dizin”seçin ve projenizin nerede oluşturulmasını istediğinizi belirtiniz.Projeyi mevcut bir klasör içinde oluşturmak istiyorsanız, “Mevcut dizin” seçeneğine tıklayıp ve klasörü belirtiniz.Bir Github deposunu klonlamak istiyorsanız, üçüncü seçenek olan “Versiyon Kontrolü”nü seçip ve ardından “Git”seçiniz. Daha fazla ayrıntı için [Versiyon kontrolü, Git ve Github ile işbirliği] hakkındaki sayfaya bakınız.R projesi, .Rproj dosyası içeren bir klasör şeklinde oluşturulacaktır. Bu dosya bir kısayoldur ve projenizi açmanın birincil yoludur. Dosya menüsünden “Projeyi Aç”ı seçerek de bir projeyi açabilirsiniz. Alternatif olarak, RStudio’nun en sağ üst tarafında bir R projesi simgesi ve mevcut R projelerinin açılır menüsünü göreceksiniz.Bir R projesinden çıkmak için ya yeni bir proje açın ya da açık olan projeyi kapatınız (Dosya - Projeyi Kapat).","code":""},{"path":"r-projeleri.html","id":"projeler-arasında-geçiş-yapma","chapter":"6 R projeleri","heading":"Projeler arasında geçiş yapma","text":"Projeler arasında geçiş yapmak için, RStudio’nun sağ üst köşesindeki R projesi simgesini ve açılır menüyü tıklayınız. “Projeyi Kapat”, “Projeyi Aç” seçeneklerini ve son projelerin bir listesini göreceksiniz.","code":""},{"path":"r-projeleri.html","id":"ayarlar","chapter":"6 R projeleri","heading":"Ayarlar","text":"Genellikle RStudio’yu seferinde “temiz bir sayfa” ile başlatmanız önerilmektedir - yani, çalışma alanınız önceki oturumunuzdan korunmamış olarak. Bu, nesnelerinizin ve çıktılarınızın oturumdan oturuma devam etmeyeceği anlamına gelir (komut dosyalarınızı çalıştırarak bunları yeniden oluşturmanız gerekmektedir). Bu iyi bir durumdur, çünkü sizi daha iyi komutlar yazmaya ve uzun vadede hatalardan kaçınmaya zorlayacaktır.RStudio’yu açılışta “temiz bir sayfaya” sahip olacak şekilde ayarlamak için:Araçlar menüsünden “Proje Seçenekleri”ni seçiniz.“Genel” sekmesinde, RStudio’yu başlangıçta .RData’yı çalışma alanına geri yüklemeyecek ve çıkışta çalışma alanını .RData’ya kaydetmeyecek şekilde ayarlayınız.","code":""},{"path":"r-projeleri.html","id":"organizasyon","chapter":"6 R projeleri","heading":"Organizasyon","text":"Projenizde alt klasörlerin olması yaygın bir durumdur. “Veri”, “komut dosyaları”, “şekiller”, “sunular” gibi klasörleri oluşturabilirsiniz. Bilgisayarınız için yeni bir klasör eklediğiniz gibi proje alt klasörlerini ekleyebilirsiniz. Alternatif olarak, R komutlarıyla yeni klasörlerin nasıl oluşturulacağını öğrenmek için Dizin etkileşimleri hakkındaki sayfaya bakınız.","code":""},{"path":"r-projeleri.html","id":"versiyon-kontrolü","chapter":"6 R projeleri","heading":"Versiyon kontrolü","text":"Projelerinizde zaman bir versiyon kontrol sistemi düşünmelisiniz. Komut dosyalarının adlarında (örneğin, “transmission_analysis_2020-10-03.R”) ve bir “arşiv” klasöründe tarihlerin eklenmesi gibi basit bir yöntemi kullanabilirsiniz. Ayrıca açıklama, etiketler, yazarlar ve değişiklik günlüğü ile komut dosyasının üst kısmında yorumlar da ekleyebilirsiniz.Daha karmaşık bir yöntem, sürüm kontrolü için Github veya benzer bir platform kullanmayı içermektedir. [Versiyon kontrolü, Git ve Github ile işbirliği] hakkındaki sayfaya bakınız.Bir ipucu olarak, “Dosyalarda Bul” aracını (Düzenle menüsü) kullanarak tüm projede veya klasörde arama yapabilmenizdir. Birden çok dosyada istediğiniz kelime/dizeleri arayabilir ve hatta değiştirebilirsiniz.","code":""},{"path":"r-projeleri.html","id":"örnekler","chapter":"6 R projeleri","heading":"6.3 Örnekler","text":"Aşağıda, bir R projesi içinden () fonksiyonunu kullanarak bazı içe/dışa aktarma/kaydetme örnekleri verilmiştir. İçe ve dışa aktar sayfasında paketinin kullanımı hakkında daha fazla bilgi edinebilirsiniz.R projenizdeki “data” klasöründen linelist_raw.xlsx dosyasını içe aktarınR projenizdeki “data” klasörü içindeki “clean” klasörüne, R nesnesi ’linelist’, “my_linelist.rds” olarak dışa aktarın.En son yazdırılan grafiği, R projenizdeki “outputs” klasöründeki “epicurves” klasörüne “epicurve_2021-02-15.png” olarak kaydedin.","code":"\nlinelist <- import(here(\"data\", \"linelist_raw.xlsx\"))\nexport(linelist, here(\"data\",\"clean\", \"my_linelist.rds\"))\nggsave(here(\"outputs\", \"epicurves\", \"epicurve_2021-02-15.png\"))"},{"path":"r-projeleri.html","id":"kaynaklar","chapter":"6 R projeleri","heading":"6.4 Kaynaklar","text":"RStudio web sayfası - R projelerini kullanma","code":""},{"path":"içe-ve-dışa-aktar.html","id":"içe-ve-dışa-aktar","chapter":"7 İçe ve dışa aktar","heading":"7 İçe ve dışa aktar","text":"Bu sayfada dosyaları bulmanın, içe aktarmanın ve dışa aktarmanın yollarını açıklıyoruz:Birçok dosya türünü esnek bir şekilde import() ve export() işlemi için rio paketinin kullanımınıBir R proje köküyle ilişkili dosyaları bulmak için paketinin kullanılması - bir bilgisayara özgü dosya yollarından kaynaklanan komplikasyonları önlemek içinAşağıdakiler gibi belirli içe aktarma senaryoları:\nSpesifik Excel sayfaları\nDağınık başlıklar ve satır atlama\nGoogle sayfalarından\nWeb sitelerine gönderilen verilerden\nAPI’ler ile\nEn son dosyayı içe aktarma\nSpesifik Excel sayfalarıDağınık başlıklar ve satır atlamaGoogle sayfalarındanWeb sitelerine gönderilen verilerdenAPI’ler ileEn son dosyayı içe aktarmaManuel veri girişiRDS ve RData gibi R’özgü dosya türleriDosyaları ve grafikleri dışa aktarma/kaydetme","code":""},{"path":"içe-ve-dışa-aktar.html","id":"genel-bakış","chapter":"7 İçe ve dışa aktar","heading":"7.1 Genel Bakış","text":"Bir “veri kümesini” R’ı içe aktardığınızda, genellikle R ortamınızda yeni bir veri çerçevesi nesnesi yaratır ve onu klasör dizinlerinizde bulunan içe aktarılmış bir dosya (örn. Excel, CSV, TSV, RDS) olarak belirli bir dosya yolu/adresini tanımlamış olursunuz.Diğer istatistiksel programlar (SAS, STATA, SPSS) tarafından oluşturulanlar da dahil olmak üzere birçok dosya türünü içe/dışa aktarabilirsiniz. Ayrıca ilişkisel veritabanlarına da bağlanabilirsiniz.R’ın kendi veri biçimleri bile vardır:Bir RDS dosyası (.rds), veri çerçevesi gibi tek bir R nesnesini depolar. Bunlar, R sütun sınıflarını korudukları için temizlenmiş verileri depolamak için kullanışlıdır. Bu bölümde daha fazlasını okuyabilirsiniz.Bir RData dosyası (.Rdata), birden çok nesneyi veya hatta eksiksiz bir R çalışma alanını depolamak için kullanılabilir. Bu bölümde daha fazlasını okuyabilirsiniz.","code":""},{"path":"içe-ve-dışa-aktar.html","id":"rio-paketi","chapter":"7 İçe ve dışa aktar","heading":"7.2 rio paketi","text":"Önerdiğimiz R paketi: rio. “Rio” adı, “R /O” (girdi-input/çıktı-output) ifadesinin kısaltmasıdır.import() ve export() fonksiyonları birçok farklı dosya türünü (örneğin .xlsx, .csv, .rds, .tsv) işleyebilir. Bu fonksiyonlardan herhangi birine (“.csv” gibi dosya uzantısı dahil) bir dosya yolu sağladığınızda, rio uzantıyı okuyacak ve dosyayı içe veya dışa aktarmak için doğru aracı kullanacaktır.rio kullanmanın alternatifi, biri bir dosya türüne özgü olan diğer birçok paketin fonksiyonunu kullanmaktır. Örneğin, ‘read.csv()’ (base R), ‘read.xlsx()’ (openxlsx paketi) ve ‘write_csv()’ (readr paketi), vb. Bu alternatifleri hatırlamak zor olabilir, oysa rio’dan import() ve export() kullanmak kolaydır.rio’nun import() ve export() fonksiyonları, dosya uzantısına bağlı olarak belirli bir dosya için uygun paketi ve fonksiyonu kullanır. rio’nun arka planda kullandığı paketlerin/fonksiyonların tam bir tablosu için bu sayfanın sonuna bakabilirsiiniz. Düzinelerce başka dosya türü arasından STATA, SAS ve SPSS dosyalarını içe aktarmak için de kullanılabilir.Şekil dosyalarının içe/dışa aktarımı, [GIS temelleri] sayfasında ayrıntılı olarak açıklandığı gibi başka paketler gerektirir.","code":""},{"path":"içe-ve-dışa-aktar.html","id":"here","chapter":"7 İçe ve dışa aktar","heading":"7.3 here paketi","text":"paketi ve ‘()’ fonksiyonu, R’dosyalarınızı nerede bulacağını ve kaydedeceğini söylemeyi kolaylaştırır - özünde, dosya yolları oluşturur.Bir R projesiyle birlikte kullanıldığında , R projenizdeki dosyaların konumunu R projesinin kök dizini (en üst düzey klasör) ile ilişkili olarak tanımlamanıza olanak tanır. Bu, R projesinin birden fazla kişi/bilgisayar tarafından paylaşılabildiği veya erişilebildiği durumlarda kullanışlıdır. Dosya yolunu tüm kullanıcılar için ortak bir yerde (R proje kökü) “başlatarak”, farklı bilgisayarlardaki benzersiz dosya yollarından (ör. “C:/Users/Laura/Documents…”) kaynaklanan komplikasyonları önler.Bir R projesinde “()” şu şekilde çalışır:paketi R projesine ilk yüklendiğinde, “.” adlı küçük bir dosyayı R projenizin kök klasörüne “benchmark” veya “anchor” olarak yerleştirir.Komut dosyalarınızda, R projesinin alt klasörlerindeki bir dosyaya referans vermek için, dosya yolunu oluşturmak için ‘()’ fonksiyonunu kullanırsınız bu bağlantıya göreDosya yolunu oluşturmak için, klasör adlarını kökün ötesinde, tırnak işaretleri içinde, virgülle ayırarak ve son olarak aşağıda gösterildiği gibi dosya adı ve dosya uzantısı ile bitecek şekilde yazın.() dosya yolları hem içe hem dışa aktarma için kullanılabilirÖrneğin, aşağıda, “import()” fonksiyonuna “()” ile oluşturulmuş bir dosya yolu sağlanmaktadır.(\"data\", \"linelists\", \"ebola_linelist.xlsx\") komutu aslında kullanıcının bilgisayarına özgü olan tam dosya yolunu sağlar*:İşin güzel yanı, ‘()’ kullanan R komutunun, R projesine erişen herhangi bir bilgisayarda başarılı bir şekilde çalıştırılabilmesidir.TIP: “.” kökünün nereye ayarlandığından emin değilseniz, boş parantezlerle ‘()’ fonksiyonunu çalıştırın.paketi hakkında bu bağlantıdan daha fazlasını okuyabilirsiniz.","code":"\nlinelist <- import(here(\"data\", \"linelists\", \"ebola_linelist.xlsx\"))\"C:/Users/Laura/Documents/my_R_project/data/linelists/ebola_linelist.xlsx\""},{"path":"içe-ve-dışa-aktar.html","id":"dosya-yolları","chapter":"7 İçe ve dışa aktar","heading":"7.4 Dosya yolları","text":"Verileri içe veya dışa aktarırken bir dosya yolu sağlamanız gerekir. Bunu üç yoldan biriyle yapabilirsiniz:Önerilen: paketiyle “ilişkili” bir dosya yolu sağlayın“tam” / “mutlak” dosya yolunu sağlayınManuel dosya seçimi","code":""},{"path":"içe-ve-dışa-aktar.html","id":"ilişkili-dosya-yolları","chapter":"7 İçe ve dışa aktar","heading":"“İlişkili” dosya yolları","text":"R’da, “ilişkili” dosya yolları, bir R projesinin köküne ilişkili olan dosya yolundan oluşur. Farklı bilgisayarlarda çalışabilen daha basit dosya yollarına izin verirler (örneğin, R projesi paylaşılan bir sürücüdeyse veya e-postayla gönderiliyorsa). Yukarıda açıklandığı gibi, göreli dosya yolları paketi kullanılarak kolaylaştırılır.‘()’ ile oluşturulmuş ilişkili bir dosya yolu örneği aşağıdadır. Çalışmanın, bir “veri” alt klasörü içeren bir R projesinde olduğunu ve bunun içinde, .xlsx dosyasının bulunduğu bir “çizgi listeleri” alt klasöründe olduğunu varsayıyoruz.","code":"\nlinelist <- import(here(\"data\", \"linelists\", \"ebola_linelist.xlsx\"))"},{"path":"içe-ve-dışa-aktar.html","id":"mutlak-dosya-yolları","chapter":"7 İçe ve dışa aktar","heading":"“Mutlak” dosya yolları","text":"import() gibi fonksiyonlar için mutlak veya “tam” dosya yolları sağlanabilir, ancak bunlar kullanıcının özel bilgisayarına özgü olduğundan “kırılgandır” ve bu nedenle önerilmez.Aşağıda, Laura’nın bilgisayarında bir “analiz” klasörü, bir “veri” alt klasörü ve bunun içinde, ilgilenilen .xlsx dosyasının bulunduğu bir alt klasör “satır listeleri” bulunan bir mutlak dosya yolu örneği verilmiştir. .Mutlak dosya yolları hakkında dikkat edilmesi gereken birkaç nokta:Mutlak dosya yollarını kullanmaktan kaçının çünkü komut dosyası farklı bir bilgisayarda çalıştırılırsa bozulurlarYukarıdaki örnekte olduğu gibi ileri eğik çizgi (/) kullanın (: bu, Windows dosya yolları için varsayılan DEĞİLDİR)Çift eğik çizgiyle başlayan dosya yolları (ör. “//…”) büyük olasılıkla R tarafından tanınmayacak ve bir hata üretecektir. Çalışmanızı bir harfle başlayan “adlandırılmış” veya “harfli” bir sürücüye taşımayı düşünün (ör. “J:” veya “C:”). Bu sorunla ilgili daha fazla ayrıntı için Dizin etkileşimleri hakkındaki sayfaya bakabilirsiniz.Mutlak dosya yollarının uygun olabileceği bir senaryo, tüm kullanıcılar için aynı tam dosya yoluna sahip bir paylaşılan sürücüden bir dosyayı içe aktarmak istediğiniz zamandır.İPUCU: Tüm \\ işaretlerini / biçimine hızlı bir şekilde dönüştürmek için ilgili kodu vurgulayın, Ctrl+f (Windows’ta) kullanın, “selection” seçenek kutusunu işaretleyin ve ardından bunları dönüştürmek için değiştirme fonksiyonunu kullanın.","code":"\nlinelist <- import(\"C:/Users/Laura/Documents/analysis/data/linelists/ebola_linelist.xlsx\")"},{"path":"içe-ve-dışa-aktar.html","id":"dosyayı-manuel-olarak-seçin","chapter":"7 İçe ve dışa aktar","heading":"Dosyayı manuel olarak seçin","text":"Aşağıdaki yöntemlerden birini kullanarak verileri manuel olarak içe aktarabilirsiniz:Ortam RStudio Bölmesi, “Veri Kümesini İçe Aktar”tıklayın ve veri türünü seçinDosya / Veri Kümesini İçe Aktar / (veri türünü seçin) öğesine tıklayın.Manuel seçimi sabit kodlamak amacıyla, kullanıcının manuel olarak bilgisayarından dosya seçmesine izin veren bir açılır pencere görünümünü tetiklemek için temel R file.choose() komutunu (parantezleri boş bırakarak) kullanın. Örneğin:İPUCU: Açılır pencere RStudio pencerenizin ARDINDA görünebilir.","code":"\n# Bir dosyanın manuel seçimi. Bu komut çalıştırıldığında bir POP-UP penceresi görünecektir.\n# Seçilen dosya yolu import() komutunu sağlayacaktır.\n\nmy_data <- import(file.choose())"},{"path":"içe-ve-dışa-aktar.html","id":"verileri-içe-aktar","chapter":"7 İçe ve dışa aktar","heading":"7.5 Verileri içe aktar","text":"Bir veri kümesini içe aktarmak için import() kullanmak oldukça basittir. Dosyanın yolunu (dosya adı ve dosya uzantısı dahil) tırnak içinde belirtmeniz yeterlidir. Dosya yolunu oluşturmak için “()” kullanılıyorsa, yukarıdaki talimatları izleyebilirsiniz. Aşağıda birkaç örnek verilmiştir:“Çalışma dizininizde” veya R projesi kök klasöründe bulunan bir csv dosyasını içe aktarma:R projesinin (() kullanılarak oluşturulan dosya yolu) “veri” ve “çizgi listeleri” alt klasörlerinde bulunan bir Excel çalışma kitabının ilk sayfasını içe aktarma:Mutlak bir dosya yolu kullanarak bir veri çerçevesini (bir .rds dosyası) içe aktarma:","code":"\nlinelist <- import(\"linelist_cleaned.csv\")\nlinelist <- import(here(\"data\", \"linelists\", \"linelist_cleaned.xlsx\"))\nlinelist <- import(\"C:/Users/Laura/Documents/tuberculosis/data/linelists/linelist_cleaned.rds\")"},{"path":"içe-ve-dışa-aktar.html","id":"belirli-excel-sayfaları","chapter":"7 İçe ve dışa aktar","heading":"Belirli Excel sayfaları","text":"Varsayılan olarak, import() dosyasına bir Excel çalışma kitabı (.xlsx) sağlarsanız, çalışma kitabının ilk sayfası içe aktarılacaktır. Belirli bir sayfayı içe aktarmak istiyorsanız, sayfa adını = değişkenine ekleyin. Örneğin:“import()” ile ilişkili bir yol sağlamak için “()” yöntemini kullanıyorsanız, “()” fonksiyonunu kapanış parantezlerinden sonra “=” değişkenine ekleyerek belirli bir sayfayı yine de belirtebilirsiniz.Bir veri çerçevesini R’dan belirli bir Excel sayfasına dışa aktarmak ve Excel çalışma kitabının geri kalanının değişmeden kalmasını sağlamak için, bu amaca yönelik openxlsx gibi alternatif bir paketle içe aktarmanız, düzenlemeniz ve dışa aktarmanız gerekir. . Dizin etkileşimleri sayfasındaki veya bu github sayfasındaki daha fazla bilgiye bakabilirsiniz.Excel çalışma kitabınız .xlsb (ikili biçimli Excel çalışma kitabı) ise rio kullanarak içe aktaramayabilirsiniz. .xlsx olarak yeniden kaydetmeyi veya [bu amaç için] oluşturulmuş readxlsb gibi bir paket kullanmayı düşünebilirsiniz(https://cran.r-project.org/web/packages/readxlsb/vignettes/read- xlsb-workbook.html).","code":"\nmy_data <- import(\"my_excel_file.xlsx\", which = \"Sheetname\")# Gösteri: 'here' paketiyle ilgili yolları kullanırken belirli bir Excel sayfasını içe aktarma\nlinelist_raw <- import(here(\"data\", \"linelist.xlsx\"), which = \"Sheet1\")`  "},{"path":"içe-ve-dışa-aktar.html","id":"import_missing","chapter":"7 İçe ve dışa aktar","heading":"Eksik değerler","text":"Veri kümenizdeki hangi değer(ler)eksik olarak kabul edilmesi gerektiğini belirlemek isteyebilirsiniz. Eksik veri sayfasında açıklandığı gibi, R’daki eksik veriler için değer `NA’dır, ancak belki de içe aktarmak istediğiniz veri kümesi bunun yerine 99, “Eksik” veya yalnızca boş karakter alanı “” kullanır.‘import()’ için ‘na =’ bağımsız değişkenini kullanın ve değer(ler)tırnak işaretleri içinde sağlayın (sayı olsalar bile). Aşağıda gösterildiği gibi c() kullanarak bunları bir vektöre dahil ederek birden çok değer belirtebilirsiniz.Burada, içe aktarılan veri kümesindeki “99” değeri eksik olarak kabul edilir ve R’da “NA”ya dönüştürülür.Burada, içe aktarılan veri kümesindeki “Eksik”, “” (boş hücre) veya ” ” (tek boşluk) değerlerinden herhangi biri R’da “NA”ya dönüştürülür.","code":"\nlinelist <- import(here(\"data\", \"my_linelist.xlsx\"), na = \"99\")\nlinelist <- import(here(\"data\", \"my_linelist.csv\"), na = c(\"Missing\", \"\", \" \"))"},{"path":"içe-ve-dışa-aktar.html","id":"satırları-atla","chapter":"7 İçe ve dışa aktar","heading":"Satırları atla","text":"Bazen bir veri satırını içe aktarmaktan kaçınmak isteyebilirsiniz. Bir .xlsx veya .csv dosyasında rio’dan import() kullanıyorsanız bunu skip = değişkeniyle yapabilirsiniz. Atlamak istediğiniz satır sayısını belirtin.Ne yazık ki skip= yalnızca bir tamsayı değeri kabul eder, bir aralık kabul etmez (ör. “2:10” çalışmaz). Üstten ardışık olmayan belirli satırların içe aktarımını atlamak için, birden çok kez içe aktarmayı ve dplyr’den bind_rows() kullanmayı düşünün. Yalnızca 2. satırı atlamayla ilgili aşağıdaki örneğe bakın.","code":"\nlinelist_raw <- import(\"linelist_raw.xlsx\", skip = 1)  # does not import header row"},{"path":"içe-ve-dışa-aktar.html","id":"ikinci-bir-başlık-satırını-yönetin","chapter":"7 İçe ve dışa aktar","heading":"İkinci bir başlık satırını yönetin","text":"Bazen, aşağıda gösterildiği gibi bir “veri sözlüğü” satırıysa verileriniz bir saniye satırı olabilir. Bu durum sorunlu olabilir, çünkü tüm sütunların “karakter” sınıfı olarak içe aktarılmasına neden olabilir.Aşağıda bu tür bir veri kümesi örneği verilmiştir (ilk satır veri sözlüğüdür).","code":""},{"path":"içe-ve-dışa-aktar.html","id":"ikinci-başlık-satırını-kaldırın","chapter":"7 İçe ve dışa aktar","heading":"İkinci başlık satırını kaldırın","text":"İkinci başlık satırını bırakmak için büyük olasılıkla verileri iki kez içe aktarmanız gerekecektir.Doğru sütun adlarını saklamak için verileri içe aktarınİlk iki satırı (başlık ve ikinci satır) atlayarak verileri tekrar içe aktarınDoğru adları azaltılmış veri çerçevesine bağlayınDoğru sütun adlarını bağlamak için kullanılan tam bağımsız değişken, veri dosyasının türüne (.csv, .tsv, .xlsx, vb.) bağlıdır. Bunun nedeni, rio’nun farklı dosya türleri için farklı bir fonksiyon kullanmasıdır (yukarıdaki tabloya bakın).Excel dosyaları için: (col_names =)CSV dosyaları için: (col.names =)Yedekleme seçeneği - sütun adlarını ayrı bir komut olarak değiştirme","code":"\n# ilk kez içe aktarma; sütun adlarını sakla\nlinelist_raw_names <- import(\"linelist_raw.xlsx\") %>% names()  # gerçek sütun adlarını kaydet\n\n# ikinci kez içe aktar; 2. satırı atlayın ve sütun adlarını col_names = değişkenine atayın\nlinelist_raw <- import(\"linelist_raw.xlsx\",\n                       skip = 2,\n                       col_names = linelist_raw_names\n                       ) \n# ilk kez içe aktarma; sütun adlarını depola\nlinelist_raw_names <- import(\"linelist_raw.csv\") %>% names() # gerçek sütun adlarını kaydet\n\n# csv dosyaları için not değişkeni 'col.names =' şeklindedir\nlinelist_raw <- import(\"linelist_raw.csv\",\n                       skip = 2,\n                       col.names = linelist_raw_names\n                       ) \n# temel 'colnames()' fonksiyonunu kullanarak başlıkları ata/üzerine yaz\ncolnames(linelist_raw) <- linelist_raw_names"},{"path":"içe-ve-dışa-aktar.html","id":"veri-sözlüğü-oluşturun","chapter":"7 İçe ve dışa aktar","heading":"Veri sözlüğü oluşturun","text":"Bonus! Veri sözlüğü olan ikinci bir satırınız varsa, ondan kolayca uygun bir veri sözlüğü oluşturabilirsiniz. Bu ipucu bu post’dan uyarlanmıştır.","code":"\ndict <- linelist_2headers %>%             # başla: ilk satır olarak sözlük içeren satır listesi\n  head(1) %>%                             # yalnızca sütun adlarını ve ilk sözlük satırını tut                \n  pivot_longer(cols = everything(),       # tüm sütunları uzun biçime döndür\n               names_to = \"Column\",       # yeni sütun adları atayın\n               values_to = \"Description\")"},{"path":"içe-ve-dışa-aktar.html","id":"iki-başlık-satırını-birleştirin","chapter":"7 İçe ve dışa aktar","heading":"İki başlık satırını birleştirin","text":"Bazı durumlarda, ham veri kümenizde iki başlık satırı varsa (veya daha spesifik olarak, 2. veri satırı ikincil bir başlıktır), bunları “birleştirmek” veya ikinci başlık satırındaki değerleri ilk başlığa eklemek isteyebilirsiniz.Aşağıdaki komut, veri çerçevesinin sütun adlarını, hemen altındaki (ilk satırdaki) değerle ilk (doğru) başlıkların birleşimi (birlikte yapıştırarak) olarak tanımlayacaktır.","code":"\nnames(my_data) <- paste(names(my_data), my_data[1, ], sep = \"_\")"},{"path":"içe-ve-dışa-aktar.html","id":"google-sayfaları","chapter":"7 İçe ve dışa aktar","heading":"Google sayfaları","text":"googlesheet4 paketiyle ve e-tabloya erişiminizi doğrulayarak çevrimiçi bir Google e-tablosundan veri aktarabilirsiniz.Aşağıda, bir demo Google sayfası içe aktarılır ve kaydedilir. Bu komut, Google hesabınızın kimlik doğrulamasının onaylanmasını isteyebilir. Tidyverse API paketlerine Google Drive’da e-tablolarınızı düzenleme, oluşturma ve silme izinleri vermek için internet tarayıcınızdaki istemleri ve açılır pencereleri izleyin.Aşağıdaki sayfa “bağlantıya sahip olan herkes tarafından görüntülenebilir” ve onu içe aktarmayı deneyebilirsiniz.Sayfa, yalnızca URL’nin daha kısa bir parçası olan sayfa kimliği kullanılarak da içe aktarılabilir:Başka bir paket olan googledrive, Google sayfalarını yazmak, düzenlemek ve silmek için kullanışlı fonksiyonlar sunar. Örneğin, bu pakette bulunan gs4_create() ve sheet_write() fonksiyonları kullanılabilir.İşte diğer bazı yararlı çevrimiçi eğitimler:\ntemel Google sayfaları içe aktarma öğreticisi\ndaha ayrıntılı eğitim\ngooglesheets4 ve tidyverse arasındaki etkileşim","code":"\npacman::p_load(\"googlesheets4\")\nGsheets_demo <- read_sheet(\"https://docs.google.com/spreadsheets/d/1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY/edit#gid=0\")\nGsheets_demo <- read_sheet(\"1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY\")"},{"path":"içe-ve-dışa-aktar.html","id":"birden-çok-dosya---içe-aktarma-dışa-aktarma-bölme-birleştirme","chapter":"7 İçe ve dışa aktar","heading":"7.6 Birden çok dosya - içe aktarma, dışa aktarma, bölme, birleştirme","text":"Birden çok dosyanın veya birden çok Excel çalışma kitabı dosyasının nasıl içe aktarılacağına ve birleştirileceğine ilişkin örnekler için Yineleme, döngüler ve listeler hakkındaki sayfaya bakın. Bu sayfada ayrıca bir veri çerçevesinin parçalara nasıl bölüneceği ve birinin ayrı ayrı veya bir Excel çalışma kitabında adlandırılmış sayfalar olarak nasıl dışa aktarılacağına ilişkin örnekler de vardır.","code":""},{"path":"içe-ve-dışa-aktar.html","id":"import_github","chapter":"7 İçe ve dışa aktar","heading":"7.7 Github’dan içe aktar","text":"Verileri doğrudan Github’dan R’aktarmak çok kolay olabilir veya dosya türüne bağlı olarak birkaç adım gerektirebilir. Aşağıda bazı yaklaşımlar yer almaktadır:","code":""},{"path":"içe-ve-dışa-aktar.html","id":"csv-dosyaları","chapter":"7 İçe ve dışa aktar","heading":"CSV dosyaları","text":"Bir .csv dosyasını bir R komutuyla doğrudan Github’dan R’aktarmak kolay olabilir.Github deposuna gidin, ilgilendiğiniz dosyayı bulun ve üzerine tıklayın.“Raw” düğmesine tıklayın (daha sonra aşağıda gösterildiği gibi “ham” csv verilerini göreceksiniz)URL’yi kopyalayın (web adresi)URL’yi import() R komutu içinde tırnak içine alın","code":""},{"path":"içe-ve-dışa-aktar.html","id":"xlsx-dosyaları","chapter":"7 İçe ve dışa aktar","heading":"XLSX dosyaları","text":"Bazı dosyalar için “Ham” verileri görüntüleyemeyebilirsiniz (ör. .xlsx, .rds, .nwk, .shp)Github deposuna gidin, ilgilendiğiniz dosyayı bulun ve üzerine tıklayın.Aşağıda gösterildiği gibi “İndir” düğmesini tıklayınDosyayı bilgisayarınıza kaydedin ve R’alın","code":""},{"path":"içe-ve-dışa-aktar.html","id":"şekil-dosyaları-shapefiles","chapter":"7 İçe ve dışa aktar","heading":"Şekil dosyaları (Shapefiles)","text":"Şekil dosyaları, biri farklı bir dosya uzantısına sahip birçok alt bileşen dosyasına sahiptir. Bir dosya “.shp” uzantısına sahip olacaktır, ancak diğerleri “.dbf”, “.prj” vb. uzantılara sahip olabilir. Github’dan bir şekil dosyası indirmek için, alt bileşen dosyalarının birini ayrı ayrı indirmeniz ve kaydetmeniz gerekir. bunları bilgisayarınızdaki aynı klasöre yerleştirin. Github’da dosyaya tek tek tıklayın ve “İndir” butonuna tıklayarak indirin.Bilgisayarınıza kaydettikten sonra, sf paketinden st_read() kullanarak şekil dosyasını [GIS temel bilgileri] sayfasında gösterildiği gibi içe aktarabilirsiniz. Diğer ilgili dosyalar bilgisayarınızda aynı klasörde olduğu sürece yalnızca “.shp” dosyasının dosya yolunu ve adını sağlamanız gerekir.Aşağıda, “sle_adm3” şekil dosyasının biri Github’dan indirilmesi gereken birçok dosyadan nasıl oluştuğunu görebilirsiniz.","code":""},{"path":"içe-ve-dışa-aktar.html","id":"manuel-veri-girişi","chapter":"7 İçe ve dışa aktar","heading":"7.8 Manuel veri girişi","text":"","code":""},{"path":"içe-ve-dışa-aktar.html","id":"satırlara-göre-giriş","chapter":"7 İçe ve dışa aktar","heading":"Satırlara göre giriş","text":"tidyverse’deki tibble paketindeki ‘tribble’ fonksiyonunu kullanın (çevrimiçi tibble referansı).Sütun başlıklarının nasıl tilde (~) ile başladığına dikkat edin. Ayrıca sütunun yalnızca bir veri sınıfı (karakter, sayısal vb.) içermesi gerektiğini unutmayın. Veri girişini daha sezgisel ve okunabilir hale getirmek için sekmeleri, boşlukları ve yeni satırları kullanabilirsiniz. Değerler arasında boşluklar önemli değildir, ancak satır yeni bir kod satırı ile temsil edilir. Örneğin:Ve şimdi yeni veri setini görüntülüyoruz:","code":"\n# veri kümesini satıra göre manuel olarak oluşturun\nmanual_entry_rows <- tibble::tribble(\n  ~colA, ~colB,\n  \"a\",   1,\n  \"b\",   2,\n  \"c\",   3\n  )"},{"path":"içe-ve-dışa-aktar.html","id":"sütunlara-göre-giriş","chapter":"7 İçe ve dışa aktar","heading":"Sütunlara göre giriş","text":"Bir veri çerçevesi vektörlerden (dikey sütunlardan) oluştuğu için, R’da manuel veri çerçevesi oluşturmaya yönelik temel yaklaşım, sütunu tanımlamanızı ve ardından bunları birbirine bağlamanızı bekler. Bu, genellikle verilerimizi satırlar halinde düşündüğümüzden (yukarıdaki gibi) epidemiyolojide mantıksız olabilir.UYARI: Tüm vektörler aynı uzunlukta olmalıdır (aynı sayıda değer).Vektörler daha sonra “data.frame()” fonksiyonu kullanılarak birbirine bağlanabilir:Ve şimdi yeni veri setini görüntülüyoruz.","code":"\n# her vektörü (dikey sütun) ayrı ayrı tanımlayın, her biri kendi adıyla\nPatientID <- c(235, 452, 778, 111)\nTreatment <- c(\"Yes\", \"No\", \"Yes\", \"Yes\")\nDeath     <- c(1, 0, 1, 0)\n# vektör adlarına başvurarak sütunları bir veri çerçevesinde birleştirin\nmanual_entry_cols <- data.frame(PatientID, Treatment, Death)"},{"path":"içe-ve-dışa-aktar.html","id":"panodan-yapıştırma","chapter":"7 İçe ve dışa aktar","heading":"Panodan yapıştırma","text":"Verileri başka bir yerden kopyalar ve panonuzda bulundurursanız, aşağıdaki iki yoldan birini deneyebilirsiniz:clipr paketinden, veri çerçevesi olarak içe aktarmak için ‘read_clip_tbl()’ veya bir karakter vektörü olarak içe aktarmak için sadece ‘read_clip()’ kullanabilirsiniz. iki durumda da parantezleri boş bırakın.Ayrıca clipr ile sisteminizin panosuna kolayca aktarabilirsiniz. Aşağıdaki dışa aktarma bölümüne bakın.Alternatif olarak, veri çerçevesi olarak içe aktarmak için base R’dan file = \"clipboard\") read.table() fonksiyonunu kullanabilirsiniz:","code":"\nlinelist <- clipr::read_clip_tbl()  # mevcut panoyu veri çerçevesi olarak içe aktarır\nlinelist <- clipr::read_clip()      # karakter vektörü olarak içe aktar\ndf_from_clipboard <- read.table(\n  file = \"clipboard\",  # bunu \"pano\" olarak belirtin\n  sep = \"t\",           # ayırıcı sekme veya virgül vb. olabilir.\n  header=TRUE)         # bir başlık satırı varsa"},{"path":"içe-ve-dışa-aktar.html","id":"en-son-dosyayı-içe-aktar","chapter":"7 İçe ve dışa aktar","heading":"7.9 En son dosyayı içe aktar","text":"Genellikle veri kümeleriniz için günlük güncellemeler alabilirsiniz. Bu durumda, en son dosyayı içe aktaran bir kod yazmak isteyeceksiniz. Aşağıda buna yaklaşmanın iki yolunu sunuyoruz:Dosya adındaki tarihe göre dosya seçimiDosya meta verilerine göre dosya seçimi (son değişiklik)","code":""},{"path":"içe-ve-dışa-aktar.html","id":"dosya-adındaki-tarihler","chapter":"7 İçe ve dışa aktar","heading":"Dosya adındaki tarihler","text":"Bu yaklaşım üç öncüle bağlıdır:Dosya adlarındaki tarihlere güveniyorsunuzTarihler sayısaldır ve genellikle aynı biçimde görünür (ör. yıl sonra ay sonra gün)Dosya adında başka numara yokHer adımı açıklayacağız ve sonunda size bunların birleştirilmiş halini göstereceğiz.İlk olarak, ilgilenilen klasördeki dosya için yalnızca dosya adlarını çıkarmak için base R’dan dir() kullanın. ‘dir()’ hakkında daha fazla ayrıntı için Dizin etkileşimleri sayfasına bakın. Bu örnekte, ilgilenilen klasör, R projesi içindeki “data” içindeki “example” klasörü içindeki “linelists” klasörüdür.Bu ad vektörüne sahip olduğunuzda, bu normal ifadeyi kullanarak stringr’den str_extract() uygulayarak tarihleri çıkarabilirsiniz. Dosya adındaki herhangi bir sayıyı çıkarır (ortadaki tire veya eğik çizgi gibi diğer karakterler dahil). [Dizeler ve karakterler] sayfasında stringr hakkında daha fazla bilgi edinebilirsiniz.Tarihlerin genellikle aynı tarih formatında yazıldığını (örneğin Yıl sonra Ay sonra Gün) ve yılların 4 basamaklı olduğunu varsayarsak, lubridate’nin esnek dönüştürme fonksiyonlarını (ymd(), dmy() kullanabilirsiniz. ) veya mdy()) tarihlere dönüştürmek için. Bu fonksiyonlar için tireler, boşluklar veya eğik çizgiler önemli değildir, yalnızca sayıların sırası önemlidir. Tarihlerle çalışma sayfasında daha fazlasını okuyun.base R fonksiyonu .max() daha sonra maksimum tarih değerinin dizin konumunu (ör. 1., 2., 3., …) döndürmek için kullanılabilir. En son dosya, 6. dosya olarak doğru bir şekilde tanımlandı - “case_linelist_2020-10-08.xlsx”.Tüm bu komutları yoğunlaştırırsak, kodun tamamı aşağıdaki gibi görünebilir. Son satırdaki . öğesinin, tünel dizisindeki o noktada tünellenen nesne için bir yer tutucu olduğuna dikkat edin. Bu noktada değer basitçe 6 sayısıdır. Bu, ‘dir()’ tarafından üretilen dosya adları vektörünün 6. öğesini çıkarmak için çift parantez içine yerleştirilir.Artık bu adı, ilişkili dosya yolunu “()” ile bitirmek için kullanabilirsiniz:Ve şimdi en son dosyayı içe aktarabilirsiniz:","code":"\nlinelist_filenames <- dir(here(\"data\", \"example\", \"linelists\")) # klasörden dosya isimlerini al\nlinelist_filenames                                              # yazdır## [1] \"20201007linelist.csv\"          \"case_linelist_2020-10-02.csv\"  \"case_linelist_2020-10-03.csv\" \n## [4] \"case_linelist_2020-10-04.csv\"  \"case_linelist_2020-10-05.csv\"  \"case_linelist_2020-10-08.xlsx\"\n## [7] \"case_linelist20201006.csv\"\nlinelist_dates_raw <- stringr::str_extract(linelist_filenames, \"[0-9].*[0-9]\") # sayıları ve aradaki karakterleri ayıklayın\nlinelist_dates_raw  # yazdır## [1] \"20201007\"   \"2020-10-02\" \"2020-10-03\" \"2020-10-04\" \"2020-10-05\" \"2020-10-08\" \"20201006\"\nlinelist_dates_clean <- lubridate::ymd(linelist_dates_raw)\nlinelist_dates_clean## [1] \"2020-10-07\" \"2020-10-02\" \"2020-10-03\" \"2020-10-04\" \"2020-10-05\" \"2020-10-08\" \"2020-10-06\"\nindex_latest_file <- which.max(linelist_dates_clean)\nindex_latest_file## [1] 6\n# paketleri yükle\npacman::p_load(\n  tidyverse,         # veri yönetimi\n  stringr,           # dizeler/karakterlerle çalışmak\n  lubridate,         # tarihlerle çalışmak\n  rio,               # içe aktar / dışa aktar\n  here,              # ilişkili dosya yolları\n  fs)                # dizin etkileşimleri\n\n# en son dosyanın dosya adını çıkar\nlatest_file <- dir(here(\"data\", \"example\", \"linelists\")) %>%  # \"linelists\" alt klasöründeki dosya adları         \n  str_extract(\"[0-9].*[0-9]\") %>%                  # tarihleri çıkar (sayılar)\n  ymd() %>%                                        # sayıları tarihlere dönüştür (yıl-ay-gün biçimini varsayarak)\n  which.max() %>%                                  # maksimum tarihin dizinini al (en son dosya)\n  dir(here(\"data\", \"example\", \"linelists\"))[[.]]              # en son satır listesinin dosya adını döndür\n\nlatest_file  # en son dosyanın adını yazdır## [1] \"case_linelist_2020-10-08.xlsx\"\nhere(\"data\", \"example\", \"linelists\", latest_file) \n# import\nimport(here(\"data\", \"example\", \"linelists\", latest_file)) # içe aktar "},{"path":"içe-ve-dışa-aktar.html","id":"dosya-bilgisini-kullanın","chapter":"7 İçe ve dışa aktar","heading":"Dosya bilgisini kullanın","text":"Dosyalarınızın adlarında tarih yoksa (veya bu tarihlere güvenmiyorsanız), dosya meta verilerinden son değişiklik tarihini çıkarmayı deneyebilirsiniz. dosya için son değişiklik zamanını ve dosya yolunu içeren meta veri bilgilerini incelemek için fs paketindeki fonksiyonları kullanın.Aşağıda, fs’nin dir_info() dosyasının ilgilendiği klasörü sunuyoruz. Bu durumda, ilgilenilen klasör “data” klasöründeki R projesinde, “example” alt klasöründe ve alt klasörü “linelists”tedir. Sonuç, dosya başına bir satır ve “modification_time”, “path” vb. için sütunlar içeren bir veri çerçevesidir. Bunun görsel bir örneğini Dizin etkileşimleri sayfasında görebilirsiniz.Dosyaların bu veri çerçevesini ‘modification_time’ sütununa göre sıralayabiliriz ve ardından base R’ın ‘head()’ ile yalnızca en üstteki/en son satırı (dosyayı) tutabiliriz. Daha sonra bu en son dosyanın dosya yolunu sadece ‘path’ sütunundaki dplyr fonksiyonu ‘pull()’ ile ayıklayabiliriz. Sonunda bu dosya yolunu import()geçirebiliriz. İçe aktarılan dosya “latest_file” olarak kaydedilir.","code":"\nlatest_file <- dir_info(here(\"data\", \"example\", \"linelists\")) %>%  # dizindeki tüm dosyalarda dosya bilgilerini topla\n  arrange(desc(modification_time)) %>%      # değişiklik zamanına göre sırala\n  head(1) %>%                               # sadece en üstteki (en son) dosyayı tut\n  pull(path) %>%                            # yalnızca dosya yolunu çıkar\n  import()                                  # dosyayı içe aktar"},{"path":"içe-ve-dışa-aktar.html","id":"import_api","chapter":"7 İçe ve dışa aktar","heading":"7.10 API’ler","text":"Bir web sitesinden doğrudan veri istemek için bir “Otomatik Programlama Arayüzü” (API) kullanılabilir. API’ler, bir yazılım uygulamasının diğeriyle etkileşime girmesine izin veren bir dizi kuraldır. İstemci (siz) bir “istek” gönderir ve içerik içeren bir “yanıt” alır. httr ve jsonlite R paketleri bu süreci kolaylaştırabilir.API’nin etkin olduğu web sitesi, aşina olmak için kendi belgelerine ve özelliklerine sahip olacaktır. Bazı siteler herkese açıktır ve herkes tarafından erişilebilir. Kullanıcı kimliklerine ve kimlik bilgilerine sahip platformlar gibi diğerleri, verilerine erişmek için kimlik doğrulama gerektirir.API aracılığıyla verileri içe aktarmak için internet bağlantınızın olması gerektiğini söylemeye gerek yok. Verileri içe aktarmak için API’lerin kullanımına ilişkin örnekler vereceğiz ve sizi daha fazla kaynağa bağlayacağız.: Verilerin API içermeyen bir web sitesinde yayınlanabileceğini* ve bunun alınmasının daha kolay olabileceğini unutmayın. Örneğin, yayınlanan bir CSV dosyasına, Github’dan içe aktarma bölümünde açıklandığı gibi site URL’sini “import()”sağlayarak kolayca erişilebilir.*","code":""},{"path":"içe-ve-dışa-aktar.html","id":"http-isteği","chapter":"7 İçe ve dışa aktar","heading":"HTTP isteği","text":"API değişimi en yaygın olarak bir HTTP isteği aracılığıyla yapılır. HTTP, Köprü Metni Aktarım Protokolüdür ve bir istemci ile bir sunucu arasındaki bir istek/yanıtın temel biçimidir. Tam girdi ve çıktı, API türüne bağlı olarak değişebilir, ancak süreç aynıdır - genellikle bir sorgu içeren, kullanıcıdan gelen bir “Talep” (genellikle HTTP İsteği), ardından durum bilgilerini içeren bir “Yanıt”.İşte bir HTTP isteğinin birkaç bileşeni:API uç noktasının URL’si“Yöntem” (veya “Fiil”)BaşlıklarVücutHTTP isteği “yöntemi”, gerçekleştirmek istediğiniz eylemdir. En yaygın iki HTTP yöntemi ‘GET’ ve ‘POST’tur, ancak diğerleri ’PUT’, ‘DELETE’, ‘PATCH’ vb. içerebilir. Verileri R’aktarırken büyük olasılıkla ‘GET’ kullanacaksınız.İsteğinizden sonra bilgisayarınız, URL, HTTP durumu (İstediğiniz Durum 200’dür!), dosya türü, boyutu ve istenen içerik dahil olmak üzere gönderdiğinize benzer bir biçimde bir “yanıt” alacaktır. Daha sonra bu yanıtı ayrıştırmanız ve R ortamınızda uygulanabilir bir veri çerçevesine dönüştürmeniz gerekecektir.","code":""},{"path":"içe-ve-dışa-aktar.html","id":"paketler","chapter":"7 İçe ve dışa aktar","heading":"Paketler","text":"httr paketi, R’da HTTP isteklerini işlemek için iyi çalışır. Web API’leri hakkında çok az ön bilgi gerektirir ve yazılım geliştirme terminolojisine daha az aşina olan kişiler tarafından kullanılabilir. Ayrıca, HTTP yanıtı .json ise yanıtı ayrıştırmak için jsonlite kullanabilirsiniz.","code":"\n# paketleri yüklemek\npacman::p_load(httr, jsonlite, tidyverse)"},{"path":"içe-ve-dışa-aktar.html","id":"herkese-açık-veriler","chapter":"7 İçe ve dışa aktar","heading":"Herkese açık veriler","text":"Aşağıda, Trafford Data Lab bir eğiticiden ödünç alınan bir HTTP isteği örneği verilmiştir. Bu sitede öğrenilecek başka kaynaklar ve API alıştırmaları var.Senaryo: İngiltere’nin Trafford şehrinde bulunan fast food satış noktalarının bir listesini içe aktarmak istiyoruz. Verilere, Birleşik Krallık için gıda hijyeni derecelendirme verileri sağlayan Gıda Standartları Ajansı API’sinden erişilebilir.İşte talebimiz için parametreler:HTTP fiili: GETAPI uç noktası URL’si: http://api.ratings.food.gov.uk/EstablishmentsSeçilen parametreler: ad, adres, boylam, enlem, businessTypeId, ratingKey, localAuthorityIdBaşlıklar: “x-api-version”, 2Veri biçimleri: JSON, XMLBelgeler: http://api.ratings.food.gov.uk/helpR kodu aşağıdaki gibi olacaktır:Artık fast food tesisi için bir satır içeren “yanıt” veri çerçevesini temizleyebilir ve kullanabilirsiniz.","code":"\n# talebi hazırlamak\npath <- \"http://api.ratings.food.gov.uk/Establishments\"\nrequest <- GET(url = path,\n             query = list(\n               localAuthorityId = 188,\n               BusinessTypeId = 7844,\n               pageNumber = 1,\n               pageSize = 5000),\n             add_headers(\"x-api-version\" = \"2\"))\n\n# herhangi bir sunucu hatası olup olmadığını kontrol edin (\"200\" iyidir!)\nrequest$status_code\n\n# isteği gönderin, yanıtı ayrıştırın ve bir veri çerçevesine dönüştürün\nresponse <- content(request, as = \"text\", encoding = \"UTF-8\") %>%\n  fromJSON(flatten = TRUE) %>%\n  pluck(\"establishments\") %>%\n  as_tibble()"},{"path":"içe-ve-dışa-aktar.html","id":"kimlik-doğrulama-gerekli","chapter":"7 İçe ve dışa aktar","heading":"Kimlik doğrulama gerekli","text":"Bazı API’ler kimlik doğrulaması gerektirir - kim olduğunuzu kanıtlamanız halinde kısıtlı verilere erişebilirsiniz. Bu verileri içe aktarmak için önce bir kullanıcı adı, parola veya kod sağlamak üzere bir POST yöntemi kullanmanız gerekebilir. Bu, istenen verileri almak için sonraki GET yöntemi istekleri için kullanılabilecek bir erişim belirteci döndürür.Aşağıda, bir salgın araştırma aracı olan Go.Data’dan veri sorgulama örneği verilmiştir. Go.Data, veri toplama için kullanılan web ön uç ve akıllı telefon uygulamaları arasındaki tüm etkileşimler için bir API kullanır. Go.Data tüm dünyada kullanılmaktadır. Salgın verileri hassas olduğundan ve yalnızca salgınınız için verilere erişebilmeniz gerektiğinden, kimlik doğrulama gereklidir.Aşağıda, salgınınızdan kişi takibine ilişkin verileri içe aktarmak için Go.Data API’sine bağlanmak için httr ve jsonlite kullanan bazı örnek R kodları verilmiştir.UYARI: Kimlik doğrulama gerektiren bir API’den büyük miktarda veri içe aktarıyorsanız, zaman aşımına uğrayabilir. Bunu önlemek için, API GET isteğinden önce access_token’tekrar alın ve sorguda filtreleri veya sınırları kullanmayı deneyin. İPUCU: jsonlite paketindeki fromJSON() fonksiyonu, ilk çalıştırıldığında yuvayı tamamen açmaz, bu nedenle muhtemelen yine de sonuçta ortaya çıkan tibble’ınızda liste öğeleri vardır. .json dosyanızın ne kadar iç içe olduğuna bağlı olarak belirli değişkenler için daha fazla yuva açmanız gerekecektir. Bununla ilgili daha fazla bilgi görüntülemek için, flatten() fonksiyonu gibi jsonlite paketinin belgelerine bakabilirsiniz. Daha fazla ayrıntı için LoopBack Explorer, [Kişi İzleme] sayfası veya Go.Data Github deposundaki API ipuçları hakkındaki belgeleri görüntüleyin.httr paketi hakkında daha fazla bilgiyi buradan okuyabilirsiniz.Bu bölümde ayrıca bu ders ve bu ders metinlerinden de yararlanıldı.","code":"\n# yetkilendirme için kimlik bilgilerini ayarla\nurl <- \"https://godatasampleURL.int/\"           # geçerli Go.Data url örneği\nusername <- \"username\"                          # geçerli Go.Data kullanıcı adı \npassword <- \"password\"                          # geçerli Go.Data parolası \noutbreak_id <- \"xxxxxx-xxxx-xxxx-xxxx-xxxxxxx\"  # geçerli Go.Data salgın kimliği\n\n# erişim izni almak\nurl_request <- paste0(url,\"api/oauth/token?access_token=123\") # temel url isteğini tanımla\n\n# istek hazırlamak\nresponse <- POST(\n  url = url_request,  \n  body = list(\n    username = username,    # yetkilendirmek için yukarıdan kaydedilmiş kullanıcı adını/şifreyi kullanın                           \n    password = password),                                       \n    encode = \"json\")\n\n# isteği yürüt ve yanıtı ayrıştır\ncontent <-\n  content(response, as = \"text\") %>%\n  fromJSON(flatten = TRUE) %>%          # düzleştirilmiş iç içe JSON\n  glimpse()\n\n# Yanıttan erişim belirtecini kaydet\naccess_token <- content$access_token    # aşağıdaki API çağrılarına izin vermek için erişim belirtecini kaydedin\n\n# Salgın temaslılarını içe aktar\n# Erişim belirtecini kullanın\nresponse_contacts <- GET(\n  paste0(url,\"api/outbreaks/\",outbreak_id,\"/contacts\"),          # GET talebi\n  add_headers(\n    Authorization = paste(\"Bearer\", access_token, sep = \" \")))\n\njson_contacts <- content(response_contacts, as = \"text\")         # Metni JSON'a dönüştür\n\ncontacts <- as_tibble(fromJSON(json_contacts, flatten = TRUE))   # JSON'u tibble için düzleştirin "},{"path":"içe-ve-dışa-aktar.html","id":"dışa-aktarma","chapter":"7 İçe ve dışa aktar","heading":"7.11 Dışa aktarma","text":"","code":""},{"path":"içe-ve-dışa-aktar.html","id":"rio-paketiyle","chapter":"7 İçe ve dışa aktar","heading":"rio paketiyle","text":"rio ile, ‘export()’ fonksiyonunu ‘import()’ fonksiyonuna çok benzer bir şekilde kullanabilirsiniz. Önce kaydetmek istediğiniz R nesnesinin adını verin (örn. Örneğin:Bu, “linelist” veri çerçevesini bir Excel çalışma kitabı olarak çalışma dizini/R proje kök klasörüne kaydeder:Uzantıyı değiştirerek aynı veri çerçevesini bir csv dosyası olarak kaydedebilirsiniz. Örneğin, onu “()” ile oluşturulmuş bir dosya yoluna da kaydederiz:","code":"\nexport(linelist, \"my_linelist.xlsx\") # çalışma dizinine kaydedecekexport(linelist, here(\"data\",\"clean\", \"my_linelist.csv\")"},{"path":"içe-ve-dışa-aktar.html","id":"panoya","chapter":"7 İçe ve dışa aktar","heading":"Panoya","text":"Bir veri çerçevesini bilgisayarınızın “panosuna” aktarmak için (daha sonra Excel, Google E-Tablolar, vb. gibi başka bir yazılıma yapıştırmak için) clipr paketinden write_clip() kullanabilirsiniz.","code":"\n# satır listesi veri çerçevesini sisteminizin panosuna aktarın\nclipr::write_clip(linelist)"},{"path":"içe-ve-dışa-aktar.html","id":"import_rds","chapter":"7 İçe ve dışa aktar","heading":"7.12 RDS dosyaları","text":".csv, .xlsx vb. ile birlikte R veri çerçevelerini .rds dosyaları olarak dışa aktarabilir/kaydedebilirsiniz. Bu, R’özgü bir dosya biçimidir ve dışa aktarılan verilerle tekrar R’da çalışacağınızı biliyorsanız çok kullanışlıdır.Sütun sınıfları depolanır, bu nedenle içe aktarıldığında tekrar temizlemeniz gerekmez (bir Excel veya hatta bir CSV dosyası ile bu bir baş ağrısı olabilir!). Ayrıca, veri kümeniz büyükse dışa ve içe aktarma için kullanışlı olan daha küçük bir dosya üzerinden işlemi yapar.Örneğin, bir Epidemiyoloji ekibinde çalışıyorsanız ve haritalama için bir CBS ekibine dosya göndermeniz gerekiyorsa ve onlar da R kullanıyorsa, onlara .rds dosyasını göndermeniz yeterlidir! Daha sonra tüm sütun sınıfları korunur ve yapacak daha az işleri olur.","code":"export(linelist, here(\"data\",\"clean\", \"my_linelist.rds\")"},{"path":"içe-ve-dışa-aktar.html","id":"import_rdata","chapter":"7 İçe ve dışa aktar","heading":"7.13 Rdata dosyaları ve listeleri","text":"‘.Rdata’ dosyaları birden çok R nesnesini depolayabilir - örneğin birden çok veri çerçevesi, model sonuçları, listeler, vb. Bu, belirli bir proje için çok sayıda verinizi birleştirmek veya paylaşmak için çok yararlı olabilir.Aşağıdaki örnekte, dışa aktarılan “my_objects.Rdata” dosyasında birden çok R nesnesi depolanır:: Bir listeyi içe aktarmaya çalışıyorsanız, tam orijinal yapı ve içerikle içe aktarmak için rio’dan import_list() kullanın.","code":"\nrio::export(my_list, my_dataframe, my_vector, \"my_objects.Rdata\")\nrio::import_list(\"my_list.Rdata\")"},{"path":"içe-ve-dışa-aktar.html","id":"grafikleri-kaydetme","chapter":"7 İçe ve dışa aktar","heading":"7.14 Grafikleri kaydetme","text":"“ggplot()” tarafından oluşturulanlar gibi grafiklerin nasıl kaydedileceğine ilişkin talimatlar ggplot temelleri sayfasında ayrıntılı olarak tartışılmaktadır.Özetle, grafiğinizi yazdırdıktan sonra ggsave(\"my_plot_filepath_and_name.png\") komutunu çalıştırın. plot = değişkenine kaydedilmiş bir çizim nesnesi sağlayabilir veya en son görüntülenen grafiği kaydetmek için yalnızca hedef dosya yolunu (dosya uzantısıyla) belirtebilirsiniz. Ayrıca ‘width =’, ‘height =’, ‘units =’ ve ‘dpi =’ değerlerini de kontrol edebilirsiniz.İletim ağacı gibi bir ağ grafiğinin nasıl kaydedileceği İletim zincirleri sayfasında açıklanmıştır.","code":""},{"path":"içe-ve-dışa-aktar.html","id":"kaynaklar-1","chapter":"7 İçe ve dışa aktar","heading":"7.15 Kaynaklar","text":"R Verilerini İçe/Dışa Aktarma Kılavuzu\nVeri içe aktarma hakkında R 4 Veri Bilimi bölümü\nggsave() belgeleriAşağıda rio çevrimiçi vinyet’den alınmış bir tablo bulunmaktadır. Gösterilen veri türü için: beklenen dosya uzantısı, rio paketinin verileri içe veya dışa aktarmak için kullandığı ve bu fonksiyonun rio’nun varsayılan yüklü sürümüne dahil edilip edilmediğini gösterir.","code":""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"veri-temizliği-ve-temel-fonksiyonlar","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"8 Veri temizliği ve temel fonksiyonlar","text":"Bu sayfa, bir veritabanını “temizleme” sürecinde kullanılan genel adımları gösterir ve ayrıca birçok temel R veri yönetimi fonksiyonunun kullanımını açıklamaktadır.Bu sayfada veri temizliğinin gösterimi için ilk olarak ham satır listesi formunda bir veritabanı içe aktarılacaktır (import). Daha sonra adım adım veri temizliği basamakları uygulanacaktır.R kod dilinde bu süreç “tünel” zinciri olarak adlandırılır. Tünel (pipe) operatörü %>% bir veritabanını bir operasyondan diğerine aktarır.","code":""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"temel-fonksiyonlar","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Temel fonksiyonlar","text":"Bu el kitabı R paketlerinden tidyverse ailesi fonksiyonlarının kullanımını vurgulamaktadır. tidyverse Bu sayfada gösterilen temel R fonksiyonları aşağıda listelenmiştir.Bu fonksiyonların çoğu dplyr R paketine aittir. Bu R paketi veri manipülasyonu problemlerini çözmek için gerekli “eylem” fonksiyonlarını içerir. ( dplyr ismi veri çerçevesi katlayıcı – data frame plier kelimelerine referans olarak verilmiştir). dplyr dplyr , tidyverse R paketi ailesinin bir parçasıdır. Bu aile ggplot2, tidyr, stringr, tibble, purrr, magrittr ve forcats gibi birçok önemli paketi kapsar.Bu komutların Stata ya da SAS komutları ile karşılaştırılmasını görmek için R’geçiş sayfasını inceleyin.\nAlternatif bir veri yönetim çerçevesi olarak data.table R paketi := gibi operatörler ve sıkça köşeli parantezler [ ] kullanır. Bu yaklaşım ve sintaksı kısaca Veri Tablosu sayfasında anlatılmıştır.","code":""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"isimlendirme","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"İsimlendirme","text":"Bu el kitabında, değişken ve gözlem yerine sütun ve satır terimleri kullanılacaktır. Tidy Data sayfasında anlatıldığı gibi epidemiyolojik istatistik veritabanları; satır, sütun ve değerlerden oluşur. “tidy data”Değişkenler, aynı temel özelliği ölçen değerleri içerir (yaş grubu, sonuç veya başlangıç tarihi gibi). Gözlemler, aynı birimde ölçülen tüm değerleri içerir (örneğin, bir kişi, bir bölge veya laboratuvar numunesi). Dolayısıyla bu özellikleri somut olarak tanımlamak zor olabilir.“Tidy” (düzenli) veritabanlarında sütun bir değişken, satır bir gözlem ve hücre tek bir değerdir. Ancak karşılaştığınız bazı veritabanları bu kalıba uymaz - “geniş” formdaki veritabanlarının birkaç sütuna bölünebilen değişkenleri olabilir (Pivoting data sayfasındaki örneğe bakın). Benzer şekilde, gözlemler birkaç satıra bölünebilir.Bu el kitabının büyük bölümü, verileri yönetmek ve dönüştürmekle ilgilidir, bu nedenle somut veri yapıları olan satır ve sütunlara atıfta bulunmak, daha soyut özellikteki gözlemler ve değişkenlerden daha önemlidir. Veri analizi sayfalarında istisna olarak değişkenlere ve gözlemlere daha fazla değinilecektir.","code":""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"tünel-hattını-temizlemek","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"8.1 Tünel hattını temizlemek","text":"Bu sayfada tipik veri temizleme basamakları ve bu basamakların tünel hattına eklenmesi gözden geçirilecektir.Epidemiyolojik analiz ve veri işlemede, temizleme adımları genellikle birbiri ile bağlantılı olarak sırayla gerçekleştirilir. R’da, bu genellikle ham veri kümesinin bir temizleme adımından diğerine geçirildiği veya “tünellandığı” bir temizleme “tünel hattı” olarak kendini gösterir.Bu tür zincirler, dplyr “eylem” fonksiyonları ve magrittr tünel operatörü %>%’yi kullanır. Bu kanal, “ham” verilerle (“linelist_raw.xlsx”) başlar ve kullanılabilen, kaydedilebilen, dışa aktarılabilen vb. “temiz” bir R veri çerçevesi (linelist) ile biter.Bir temizleme tünel hattında adımların sırası önemlidir. Temizleme adımları şunları içerebilir:\n• Verilerin içe aktarılması\n• Sütun adlarının temizlenmesi veya değiştirilmesi\n• Tekilleştirme (de-duplikasyon)\n• Sütun oluşturma ve dönüştürme (örn. değerleri yeniden kodlama veya standartlaştırma)\n• Filtrelenen veya eklenen satırlar","code":""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"paketlerin-yüklenmesi","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"8.2 Paketlerin yüklenmesi","text":"Bu kod kümesi, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gereken durumlarda paket kuran ve kullanım için yükleyen pacman’ın p_load() fonksiyonu vurgulanmaktadır. Alternatif olarak, base (temel) R’den library() komutu ile kurulu paketler yüklenebilir. R paketleri hakkında daha fazla bilgi için R’ın temelleri sayfasına bakın.","code":"\npacman::p_load(\n  rio,        # verileri içe aktarma\n  here,       # göreli dosya yolları\n  janitor,    # veri temizleme ve tablolar\n  lubridate,  # tarihlerle çalışma\n  epikit,     # age_categories() fonksiyonu\n  tidyverse   # veri yönetimi ve görselleştirme\n)"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"verileri-içe-aktar-1","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"8.3 Verileri içe aktar","text":"","code":""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"içe-aktarma","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"İçe aktarma","text":"Burada, rio paketinden import() fonksiyonunu kullanarak “ham” vaka satır listesi formundaki Excel dosyasını içe aktarıyoruz. rio paketi birçok dosya türünü esnek bir şekilde işler (örn. .xlsx, .csv, .tsv, .rds. Satırları atlama, eksik değerleri ayarlama, Google sayfalarını içe aktarma gibi diğer durumlar hakkında daha fazla bilgi ve ipucu için İçe Aktarma ve Dışa Aktarma sayfasına bakın.Eşlik etmek isterseniz, ham satır listesini indirmek için tıklayınız (.xlsx dosyası olarak).Veri tabanınız büyükse ve içe aktarılması uzun sürüyorsa, içe aktarma komutunun tünel zincirinden ayrı olması ve ham verinin ayrı bir dosya olarak kaydedilmesi yararlı olabilir. Bu aynı zamanda orijinal ve temizlenmiş sürümler arasında kolay karşılaştırma sağlar.Aşağıda, ham Excel dosyasını içe aktarıyoruz ve onu linelist_raw veri çerçevesi olarak kaydediyoruz. Dosyanın çalışma dizininizde veya R proje kök dizininde bulunduğunu ve bu nedenle dosya yolunda hiçbir alt klasör belirtilmediğini varsayıyoruz.Aşağıda veri çerçevesinin ilk 50 satırını görüntüleyebilirsiniz. : temel R fonksiyonu head (n), R konsolundaki ilk n satırı görüntülemenize olanak tanır.","code":"\nlinelist_raw <- import(\"linelist_raw.xlsx\")"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"gözden-geçirme","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Gözden geçirme","text":"Tüm veri çerçevesine genel bir bakış elde etmek için skimr paketindeki skim() fonksiyonunu kullanabilirsiniz (daha fazla bilgi için Tanımlayıcı tablolar sayfasına bakın). Sütunlar karakter, sayısal gibi sınıflara göre özetlenir. : “POSIXct” bir tür ham tarih sınıfıdır (bkz. Tarihlerle çalışma)\nTable 8.1: Data summary\nVariable type: characterVariable type: numericVariable type: POSIXct","code":"\nskimr::skim(linelist_raw)"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"sütun-isimleri","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"8.4 Sütun isimleri","text":"R’de sütun adları, bir sütunun “başlık” veya “üst” değeridir. Koddaki sütunlara atıfta bulunmak için kullanılırlar ve şekillerde varsayılan bir etiket görevi görürler.SAS ve STATA gibi diğer istatistiksel yazılımlar, daha kısa sütun adlarının daha uzun basılı sürümleri olarak birlikte oldukları “etiketler” kullanır. R, verilere sütun etiketleri ekleme olanağı sunarken, uygulamada çoğu zaman bu vurgulanmamaktadır. Şekiller için sütun adlarını “yazıcı dostu” yapmak için, çıktı oluşturan çizim komutları içinde sütun adı gösterimleri uygun şekilde ayarlanabilir (Örneğin, bir grafiğin eksen veya gösterge (legend) başlıkları veya basılı bir tablodaki sütun başlıkları – ggplot için ipuçları ölçekler bölümü ve [sunum sayfaları için tablolar] sayfalarına bakabilirsiniz). Veride sütun etiketleri atamak istiyorsanız,[buradan] (https://cran.r-project.org/web/packages/expss/vignettes/labels-support.html) ve buradan çevrimiçi olarak daha fazlasını okuyabilirsiniz.R sütun adları çok sık kullanıldığından, “temiz” sintaksa sahip olmalıdır. Aşağıdakileri öneriyoruz:• Kısa isimler\n• Boşluk kullanmayın (bunun yerine alt çizgi _ kullanın )\n• Beklenmedik karakter kullanmayın (&, #, <, >, …)\n• Benzer stilde adlandırmalar (örneğin tüm tarih sütunları tarih_başlangıç, tarih_rapor, tarih_ölüm… gibi aynı tarzda adlandırılmalı)linelist_raw sütun adları, aşağıda temel R names() fonksiyonunu kullanılarak yazdırılır. Başlangıçta şunu görebiliriz:\n• Bazı isimler boşluk içerir (e.g. infection date)\n• Tarihler için farklı adlandırma kalıpları kullanılmıştır (date onset vs. infection date)\n• .xlsx dosyasındaki son iki sütunda birleştirilmiş bir başlık bulunmalıdır. Bunu biliyoruz, çünkü birleştirilmiş iki sütunun adı (“merged_header”) R tarafından ilk sütuna atanmıştır ve ikinci sütuna “…28” yer tutucu adı atanmıştır (boş olan 28. sütun).: Boşluk içeren bir sütun adı için, adı ters tik işaretleriyle çevreleyin, örneğin: linelist$\\x60infection date\\x60. . Klavyenizdeki geri tik işaretinin (`) tek tırnak işaretinden (’) farklı olduğunu unutmayın..","code":"\nnames(linelist_raw)##  [1] \"case_id\"         \"generation\"      \"infection date\"  \"date onset\"      \"hosp date\"       \"date_of_outcome\"\n##  [7] \"outcome\"         \"gender\"          \"hospital\"        \"lon\"             \"lat\"             \"infector\"       \n## [13] \"source\"          \"age\"             \"age_unit\"        \"row_num\"         \"wt_kg\"           \"ht_cm\"          \n## [19] \"ct_blood\"        \"fever\"           \"chills\"          \"cough\"           \"aches\"           \"vomit\"          \n## [25] \"temp\"            \"time_admission\"  \"merged_header\"   \"...28\""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"etiketler","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Etiketler","text":"SAS gibi bazı diğer istatistiksel yazılımların değişken etiketleri vardır.","code":""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"otomatik-temizleme","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Otomatik Temizleme","text":"janitor paketindeki clean_names() fonksiyonu, sütun adlarını standartlaştırır ve aşağıdakileri yaparak bunları benzersiz kılar:\n• Tüm adları yalnızca alt çizgi, sayı ve harflerden oluşacak şekilde dönüştürür\n• Vurgulu karakterler ASCII’ye dönüştürülür (örneğin, ö “o” olur, İspanyolca “enye” “n” olur)\n• Yeni sütun adları için büyük harf kullanımı tercihi case = argümanı kullanılarak belirtilebilir (“snake” varsayılandır, alternatifler arasında “sentence” (cümle) , “title” (başlık) , “small_camel”… bulunur)\n• İşte bir çevrimiçi gösterimAşağıda, temizleme tünel hattı, ham satır listesinde clean_names() kullanılarak başlar.: Son sütun adı “…28” “x28” olarak değiştirilmiştir.","code":"\n# ham veri kümesini clean_names() fonksiyonu aracılığıyla aktarın, sonucu \"linelist\" olarak atayın\nlinelist <- linelist_raw %>% \n  janitor::clean_names()\n\n# yeni sütun adlarını görün\nnames(linelist)##  [1] \"case_id\"         \"generation\"      \"infection_date\"  \"date_onset\"      \"hosp_date\"       \"date_of_outcome\"\n##  [7] \"outcome\"         \"gender\"          \"hospital\"        \"lon\"             \"lat\"             \"infector\"       \n## [13] \"source\"          \"age\"             \"age_unit\"        \"row_num\"         \"wt_kg\"           \"ht_cm\"          \n## [19] \"ct_blood\"        \"fever\"           \"chills\"          \"cough\"           \"aches\"           \"vomit\"          \n## [25] \"temp\"            \"time_admission\"  \"merged_header\"   \"x28\""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"manuel-isim-temizliği","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Manuel isim temizliği","text":"Sütunları manuel olarak yeniden adlandırmak, yukarıdaki standardizasyon adımından sonra bile genellikle gereklidir. Aşağıda, bir tünel zincirinin parçası olarak dplyr paketindeki rename() fonksiyonu kullanılarak yeniden adlandırma gerçekleştirilir. rename() YENİ = ESKİ stilini kullanır - yeni sütun adı eski sütun adından önce verilir.Aşağıda, temizleme hattına bir yeniden adlandırma komutu eklenmiştir. Kodu daha kolay okumak için hizalama amacıyla boşluklar eklenmiştir.Artık sütun adlarının değiştirildiğini görebilirsiniz:","code":"\n# TEMİZLİK 'TÜNEL' ZİNCİRİ (ham verilerle başlar ve temizleme adımları boyunca iletir)\n##################################################################################\nlinelist <- linelist_raw %>%\n    \n    # sütun adı sintaksını standartlaştırın\n    janitor::clean_names() %>% \n    \n    # sütunları manuel olarak yeniden adlandır\n           # YENİ isim             # ESKİ isim\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome)##  [1] \"case_id\"              \"generation\"           \"date_infection\"       \"date_onset\"           \"date_hospitalisation\"\n##  [6] \"date_outcome\"         \"outcome\"              \"gender\"               \"hospital\"             \"lon\"                 \n## [11] \"lat\"                  \"infector\"             \"source\"               \"age\"                  \"age_unit\"            \n## [16] \"row_num\"              \"wt_kg\"                \"ht_cm\"                \"ct_blood\"             \"fever\"               \n## [21] \"chills\"               \"cough\"                \"aches\"                \"vomit\"                \"temp\"                \n## [26] \"time_admission\"       \"merged_header\"        \"x28\""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"sütun-konumuna-göre-yeniden-adlandırma","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Sütun konumuna göre yeniden adlandırma","text":"Sütun adı yerine sütun konumuna göre de yeniden adlandırabilirsiniz, örneğin:","code":"\nrename(newNameForFirstColumn  = 1,\n       newNameForSecondColumn = 2)"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"select-ve-summarise-ile-yeniden-adlandırma","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"select() ve summarise() ile yeniden adlandırma","text":"Kısa yol olarak, dplyr select() ve summarise() fonksiyonları ile sütunları yeniden adlandırabilirsiniz. select() yalnızca belirli sütunları tutmak için kullanılır (ve bu sayfanın ilerleyen kısımlarında ele alınacaktır). summarise(),[Verilerin gruplanması] ve Tanımlayıcı tablolar sayfalarında ele alınmıştır. Bu fonksiyonlar da yeni_adı = eski_adı biçimini kullanır. İşte bir örnek:","code":"\nlinelist_raw %>% \n  select(# YENİ isim             # ESKİ isim\n         date_infection       = `infection date`,    # yeniden adlandır ve SADECE BU KOLONLARI TUT.\n         date_hospitalisation = `hosp date`)"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"diğer-sorunlar","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Diğer sorunlar","text":"","code":""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"boş-excel-sütun-isimleri","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Boş excel sütun isimleri","text":"R, sütun adları (başlıklar) olmayan veri kümesi sütunlarına izin vermez. Bu nedenle, veriler içeren ancak sütun başlıkları olmayan bir Excel veri kümesini içe aktarırsanız, başlıklar “…1” veya “…2” gibi adlarla doldurulacaktır. Sayı, sütun numarasını temsil eder (örneğin, veri kümesindeki 4. sütunun başlığı yoksa, R buna “…4” adını verir).Bu adları, konum numaralarına (yukarıdaki örneğe bakın) veya atanmış adlarına (linelist_raw$…1) başvurarak manuel olarak temizleyebilirsiniz.","code":""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"birleştirilmiş-excel-sütun-adları-ve-hücreleri","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Birleştirilmiş Excel sütun adları ve hücreleri","text":"Bir Excel dosyasındaki birleştirilmiş hücreler, veri alırken sık karşılaşılan bir durumdur. R’Geçiş bölümünde açıklandığı gibi, birleştirilmiş hücreler verinin insan tarafından okunması için iyi olabilir, ancak “düzenli-tidy veri” değildir ve verilerin makine tarafından okunması için birçok soruna neden olur. R, birleştirilmiş hücreleri barındıramaz.Veri girişi yapan kişilere, insan tarafından okunabilen verilerin makine tarafından okunabilen verilerle aynı olmadığını hatırlatın. Kullanıcıları düzenli veri tidy data ilkeleri konusunda eğitmeye çalışın. Mümkünse, verilerin birleştirilmiş hücreler olmadan düzenli bir biçimde aktarımı için prosedürleri değiştirmeye çalışın.• değişkenin kendi sütunu olmalıdır.\n• gözlemin kendi satırı olmalıdır.\n• değerin kendi hücresi olmalıdır.rio’nun import() fonksiyonunu kullanırken, birleştirilmiş hücredeki değer ilk hücreye atanacak ve sonraki hücreler boş kalacaktır.Birleştirilmiş hücrelerle başa çıkmak için bir çözüm, verileri openxlsx paketinden readWorkbook() fonksiyonuyla içe aktarmaktır. fillMergedCells = TRUE değişkeni ayarlanmalıdır. Bu, birleştirilmiş hücredeki değeri, birleştirme aralığındaki tüm hücrelere verir.TEHLİKE: Sütun adları readWorkbook() ile birleştirilirse, el ile düzeltmeniz gereken yinelenen sütun adları elde edersiniz - R, tekrarlayan sütun adlarıyla iyi çalışmaz! Manuel sütun adı temizleme bölümünde açıklandığı gibi, sütunların konumlarına atıfta bulunarak (örneğin sütun 5) sütunları yeniden adlandırabilirsiniz.","code":"\nlinelist_raw <- openxlsx::readWorkbook(\"linelist_raw.xlsx\", fillMergedCells = TRUE)"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"sütunların-seçimi-ve-yeniden-düzenlenmesi","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"8.5 Sütunların seçimi ve yeniden düzenlenmesi","text":"Tutmak istediğiniz sütunları seçmek ve veri çerçevesindeki sıralarını belirtmek için dplyr’dan select()’kullanın.UYARI: Aşağıdaki örneklerde, satır listesi veri çerçevesi select() ile değiştirilip görüntülenmektedir, ancak kaydedilmemektedir. Bu örnek gösterim amaçlıdır. Değiştirilen sütun adları, veri çerçevesinin names () fonksiyonuna bağlanmasıyla yazdırılır.Temizleme tünel hattının bu noktasında satır listesindeki TÜM sütun adları şunlardır:","code":"\nnames(linelist)##  [1] \"case_id\"              \"generation\"           \"date_infection\"       \"date_onset\"           \"date_hospitalisation\"\n##  [6] \"date_outcome\"         \"outcome\"              \"gender\"               \"hospital\"             \"lon\"                 \n## [11] \"lat\"                  \"infector\"             \"source\"               \"age\"                  \"age_unit\"            \n## [16] \"row_num\"              \"wt_kg\"                \"ht_cm\"                \"ct_blood\"             \"fever\"               \n## [21] \"chills\"               \"cough\"                \"aches\"                \"vomit\"                \"temp\"                \n## [26] \"time_admission\"       \"merged_header\"        \"x28\""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"sütunları-koru","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Sütunları koru","text":"Yalnızca kalmasını istediğiniz sütunları seçinSütun adlarını tırnak işareti olmadan select() komutuna koyun. Sütunlar veri çerçevesinde istediğiniz sırayla görünürler. Var olmayan bir sütun eklerseniz, R’nin hata vereceğini unutmayın (bu durumda herhangi bir hata istemiyorsanız, aşağıdaki any_of() kullanımına bakın).","code":"\n# linelist veri tabanı, select() komutu aracılığıyla iletilir ve name() yalnızca sütun adlarını yazdırır\nlinelist %>% \n  select(case_id, date_onset, date_hospitalisation, fever) %>% \n  names()  # sütun isimlerini göster## [1] \"case_id\"              \"date_onset\"           \"date_hospitalisation\" \"fever\""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"clean_tidyselect","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"“tidyselect” yardımcı fonksiyonları","text":"Bu yardımcı fonksiyonlar, tutulacak, atılacak veya dönüştürülecek sütunları belirlemeyi kolaylaştırmak için oluşturulmuştur. Bu fonksiyonlar, tidyverse’de bulunan ve dplyr fonksiyonlarında sütunların nasıl seçildiğinin gösteren tidyselect paketindendir.Örneğin, sütunları yeniden sıralamak istiyorsanız, everything() “henüz belirtilmeyen tüm sütunları” göstermek için kullanışlı bir fonksiyondur. Aşağıdaki komutlar, date_onset ve date_hospitalisation sütunlarını veritabanının başına (soluna) taşır, ancak diğer tüm sütunları tutar. everything()’boş parantezlerle yazıldığını unutmayın:Burada dplyr fonksiyonları içinde çalışan select(), across() ve summarise() gibi diğer “tidyselect” yardımcı fonksiyonları yer almaktadır:everything() - belirtilmemiş tüm diğer sütunlarlast_col() - son sütunwhere() - tüm sütunlara bir fonksiyon uygular ve DOĞRU (TRUE) olanları seçercontains() - karakter dizisi (string) içeren sütunlar\nörnek: select(contains(\"time\"))\nörnek: select(contains(\"time\"))starts_with() - belirli bir ön-ekle eşleşme\nörnek: select(starts_with(\"date_\"))\nörnek: select(starts_with(\"date_\"))ends_with() - - belirli bir son-ekle eşleşme\nörnek: select(ends_with(\"_post\"))\nörnek: select(ends_with(\"_post\"))matches() - normal bir ifadenin (regex) uygulanması için\nörnek: select(matches(\"[pt]al\"))\nörnek: select(matches(\"[pt]al\"))num_range() - sayısal aralık x01, x02, x03 gibiany_of() - sütunuyla eşleşir ancak bulunamazsa hata vermez\nörnek: select(any_of(date_onset, date_death, cardiac_arrest))\nörnek: select(any_of(date_onset, date_death, cardiac_arrest))Ek olarak, birkaç sütunun listelenmesi için c() gibi normal operatörler kullanılır, : ardışık sütunlar için, ! zıtlar için, & (VE) için , | (YA DA) için kullanılır.Sütunlar için mantıksal kriterler belirtmek için () kullanın. () içinde bir fonksiyon kullanıyorsanız, fonksiyonun boş parantezlerini dahil etmeyin. Aşağıdaki komut, sayısal özellikteki sütunları seçer.Yalnızca sütun adının belirtilen bir karakter dizesini (string) içeren sütunları seçmek için include() kullanın. end_with() ve start_with() daha fazla detay sağlar.Match() fonksiyonu, include() fonksiyonuna benzer şekilde çalışır, ancak bu fonksiyon ile parantez içinde (VEYA) çubuklarıyla (|) ayrılmış birden çok dize (string) gibi bir normal ifadeler sağlanabilir. (Karakterler ve dizeler sayfasına bakın):UYARI: Verdiğiniz sütun adlarından biri verilerde yoksa, R hata verebilir ve kodunuzu durdurabilir. Özellikle negatif seçimlerde (kaldır), var olan (ya da olmayan) sütunları seçmek için any_of() kullanmak faydalıdır.Bu sütunlardan yalnızca biri var, ancak herhangi bir hata üretilmiyor ve kod, temizleme zincirinizi durdurmadan devam ediyor.","code":"\n# date_onset ve date_hospitalisation'ı başlangıca taşıyın\nlinelist %>% \n  select(date_onset, date_hospitalisation, everything()) %>% \n  names()##  [1] \"date_onset\"           \"date_hospitalisation\" \"case_id\"              \"generation\"           \"date_infection\"      \n##  [6] \"date_outcome\"         \"outcome\"              \"gender\"               \"hospital\"             \"lon\"                 \n## [11] \"lat\"                  \"infector\"             \"source\"               \"age\"                  \"age_unit\"            \n## [16] \"row_num\"              \"wt_kg\"                \"ht_cm\"                \"ct_blood\"             \"fever\"               \n## [21] \"chills\"               \"cough\"                \"aches\"                \"vomit\"                \"temp\"                \n## [26] \"time_admission\"       \"merged_header\"        \"x28\"\n# Sayısal sınıfı olan sütunları seçin\nlinelist %>% \n  select(where(is.numeric)) %>% \n  names()## [1] \"generation\" \"lon\"        \"lat\"        \"row_num\"    \"wt_kg\"      \"ht_cm\"      \"ct_blood\"   \"temp\"\n# belirli karakterleri içeren sütunları seçin\nlinelist %>% \n  select(contains(\"date\")) %>% \n  names()## [1] \"date_infection\"       \"date_onset\"           \"date_hospitalisation\" \"date_outcome\"\n# birden fazla karakter eşleşmesi arandı\nlinelist %>% \n  select(matches(\"onset|hosp|fev\")) %>%   # VEYA sembolüne dikkat edin \"|\"\n  names()## [1] \"date_onset\"           \"date_hospitalisation\" \"hospital\"             \"fever\"\nlinelist %>% \n  select(any_of(c(\"date_onset\", \"village_origin\", \"village_detection\", \"village_residence\", \"village_travel\"))) %>% \n  names()## [1] \"date_onset\""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"sütunları-kaldır","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Sütunları kaldır","text":"Sütun adının önüne bir eksi “-” sembolü (örn. select(-outcome)) veya sütun adları vektörü (aşağıdaki gibi) belirterek hangi sütunların kaldırılacağını belirtin. Diğer tüm sütunlar korunacaktır.Bir sütunu R tabanı sözdizimini kullanarak, onu ‘NULL’ olarak tanımlayarak da kaldırabilirsiniz. Örneğin:","code":"\nlinelist %>% \n  select(-c(date_onset, fever:vomit)) %>% # date_onset ve tüm sütunları ateşten kusmaya kadar kaldırın\n  names()##  [1] \"case_id\"              \"generation\"           \"date_infection\"       \"date_hospitalisation\" \"date_outcome\"        \n##  [6] \"outcome\"              \"gender\"               \"hospital\"             \"lon\"                  \"lat\"                 \n## [11] \"infector\"             \"source\"               \"age\"                  \"age_unit\"             \"row_num\"             \n## [16] \"wt_kg\"                \"ht_cm\"                \"ct_blood\"             \"temp\"                 \"time_admission\"      \n## [21] \"merged_header\"        \"x28\"\nlinelist$date_onset <- NULL   # R tabanı sözdizimine sahip sütunu siler"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"bağımsız-standalone","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Bağımsız (Standalone)","text":"select() tüneldan bağımsız bağımsız bir komut olarak da kullanılabilir. Bu durumda, ilk argüman, üzerinde çalışılacak orijinal veri çerçevesidir.","code":"\n# id ve yaşla ilgili sütunlarla yeni bir satır listesi oluşturun\nlinelist_age <- select(linelist, case_id, contains(\"age\"))\n\n# Sütun adlarını göster\nnames(linelist_age)## [1] \"case_id\"  \"age\"      \"age_unit\""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"tünel-zincirine-ekleme","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Tünel zincirine ekleme","text":"linelist_raw’da ihtiyacımız olmayan birkaç sütun var: row_num, merged_header ve x28. Bunları temizleme tünel zincirinde bir select() komutuyla kaldırıyoruz:","code":"\n# TEMİZLİK 'BORU' ZİNCİRİ (ham verilerle başlar ve temizleme adımları boyunca iletir)\n##################################################################################\n\n# tünel zincirini temizlemeye başla\n###########################\nlinelist <- linelist_raw %>%\n    \n    # sütun adı sintaksını standartlaştır\n    janitor::clean_names() %>% \n    \n    # sütunları manuel olarak yeniden adlandır\n           # YENİ isim           # ESKİ isim\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # YUKARIDAKİ TEMİZLİK ADIMLARI ZATEN TARTIŞILMIŞTIR\n    #####################################################\n\n    # satırı sil\n    select(-c(row_num, merged_header, x28))"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"tekilleştirme","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"8.6 Tekilleştirme","text":"Verilerin tekilleştirilmesinin nasıl yapılacağına ilişkin kapsamlı seçenekler için el kitabı Tekilleştirme sayfasına bakın. Burada yalnızca çok basit bir satır tekilleştirme örneği sunulmuştur.dplyr paketi, distinct() fonksiyonunu içerir. Bu fonksiyon, satırı inceler ve veri çerçevesini yalnızca benzersiz satırlara indirger. Yani %100 tekrarlayan satırları kaldırır.Yinelenen satırları değerlendirirken, bir dizi sütun dikkate alınır (varsayılan ayar olarak tüm sütunlar dikkate alınır). Tekilleştirme sayfasında gösterildiği gibi, sütun aralığı, yalnızca belirli sütunlara göre satır benzersizliği değerlendirilecek şekilde ayarlanabilir.Bu basit örnekte, tünel zincirine sadece distinct () boş komutunu ekliyoruz. Bu, diğer satırların %100 kopyası olan hiçbir satır olmamasını sağlar (burada tüm sütunlarda değerlendirilir).Linelist’te nrow(linelist) satırları ile başlıyoruz.Tekilleştirmeden sonra nrow(linelist) satırları kalır. Kaldırılan herhangi bir satır, diğer satırların %100 kopyasıdır.Aşağıda, temizleme tünel zincirine distinct() komutu eklenir:","code":"\nlinelist <- linelist %>% \n  distinct()\n# TEMİZLİK 'BORU' ZİNCİRİ (ham verilerle başlar ve temizleme adımları boyunca iletir)\n##################################################################################\n\n# tünel zincirini temizlemeye başla\n###########################\nlinelist <- linelist_raw %>%\n    \n    # sütun adı sintaksını standartlaştır\n    janitor::clean_names() %>% \n    \n    # sütunları manuel olarak yeniden adlandır\n           # YENİ isim           # ESKİ isim\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # sütunu sil\n    select(-c(row_num, merged_header, x28)) %>% \n  \n    # YUKARIDAKİ TEMİZLİK ADIMLARI ZATEN TARTIŞILMIŞTIR\n    #####################################################\n    \n    # tekilleştirme\n    distinct()"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"sütun-oluşturma-ve-dönüştürme","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"8.7 Sütun oluşturma ve dönüştürme","text":"Yeni bir sütun eklemek veya mevcut bir sütunu değiştirmek için dplyr mutate() fonksiyonunu kullanmanızı öneririz.Aşağıda, mutate() ile yeni bir sütun oluşturmaya bir örnek verilmiştir. Sintaksı: mutate(new_column_name = value transformation)Bu Stata’da, generate komutuna benzer, ancak R’ın mutate() fonksiyonu de mevcut bir sütunu değiştirmek için kullanılabilir.","code":""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"yeni-sütunlar","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Yeni sütunlar","text":"Yeni bir sütun oluşturmak için en temel mutate() komutu aşağıdaki gibdir görünebilir. satırdaki değerin 10 olduğu yeni bir new_col sütunu oluşturur.Hesaplamalar için diğer sütunlardaki değerlere de başvurabilirsiniz. Aşağıda, vaka için Vücut Kitle İndeksi’ni (VKİ) hesaplamak için yeni bir BMI sütunu oluşturulmuştur - VKİ = kg/m^2 formülü kullanılarak, ht_cm sütunu ve wt_kg sütunu kullanılarak hesaplanmıştır.Birden çok yeni sütun oluşturuyorsanız, birini bir virgül ve yeni bir satırla ayırın. Aşağıda, stringr paketinden str_glue() kullanılarak birleştirilen diğer sütunlardan gelen değerlerden oluşanlar da dahil olmak üzere yeni sütun örnekleri verilmiştir (Karakterler ve dizeler sayfasına bakın.)Yeni sütunları inceleyin. Gösterim amacıyla, yalnızca yeni sütunlar ve bunları oluşturmak için kullanılan sütunlar sunulmuştur.İPUCU: : mutate() üzerindeki varyasyonlar için transmute() fonksiyonu kullanılır. Bu fonksiyon, mutate() gibi yeni bir sütun ekler, ancak parantez içinde bahsetmediğiniz diğer tüm sütunları da bırakır/kaldırır.","code":"\nlinelist <- linelist %>% \n  mutate(new_col = 10)\nlinelist <- linelist %>% \n  mutate(bmi = wt_kg / (ht_cm/100)^2)\nnew_col_demo <- linelist %>%                       \n  mutate(\n    new_var_dup    = case_id,             # yeni sütun = mevcut başka bir sütunu çoğalt/kopyala\n    new_var_static = 7,                   # yeni sütun = tüm değerler aynı\n    new_var_static = new_var_static + 5,  # bir sütunun üzerine yazabilirsiniz ve bu, diğer değişkenleri kullanan bir hesaplama olabilir\n    new_var_paste  = stringr::str_glue(\"{hospital} on ({date_hospitalisation})\") # yeni sütun = diğer sütunlardaki değerleri birbirine yapıştırma\n    ) %>% \n  select(case_id, hospital, date_hospitalisation, contains(\"new\"))        # tanıtım amacıyla yalnızca yeni sütunları göster\n# yukarıda oluşturulan yeni demo sütunlarını kaldırır\n# linelist <- linelist %>% \n#   select(-contains(\"new_var\"))"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"sütun-sınıfının-dönüşümü","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Sütun sınıfının dönüşümü","text":"Tarihler, sayılar veya mantıksal değerler (DOĞRU/YANLIŞ) içeren sütunlar, yalnızca doğru şekilde sınıflandırıldıklarında beklendiği gibi davranacaktır. Sınıf tipi “2” ile sayısal 2 arasında fark vardır!İçe aktarma komutları sırasında sütun sınıfını ayarlamanın yolları vardır, ancak bu genellikle zahmetlidir.\nNesnelerin ve sütunların sınıfını dönüştürme hakkında daha fazla bilgi edinmek için nesne sınıflarıyla ilgili R Temelleri bölümüne bakın.İlk olarak, önemli sütunların doğru sınıf olup olmadıklarını görmek için bazı kontroller yapalım. Bunu başlangıçta skim() komutunu çalıştırdığımızda da görmüştük.Şu anda, yaş sütununun sınıfı karakterdir. Nicel analizler yapmak için bu sayıların sayısal olarak tanınmasına ihtiyacımız var!date_onset sütununun sınıfı da karakterdir! Analiz yapabilmek için bu tarihlerin tarih olarak kabul edilmesi gerekir!Bunu çözmek için, dönüştürülmüş bir sütunu yeniden tanımlamak için mutate() fonksiyonunu kullanın. Sütunu kendisi olarak tanımlıyoruz, ancak farklı bir sınıfa dönüştürüyoruz. age sütununun sayısal sınıfta olmasını sağlayan veya dönüştüren temel bir örnek:Benzer şekilde, .character() ve .logical() kullanabilirsiniz. Faktör sınıfına dönüştürmek için, temel R’den factor() veya forcats’tan as_factor() kullanabilirsiniz. Faktörler sayfasında bu konuyla ilgili daha fazla bilgi edinebilirsiniz.Tarih sınıfına geçerken dikkatli olmalısınız. Tarihlerle çalışma sayfasında çeşitli yöntemler açıklanmıştır. Tipik olarak, dönüştürmenin doğru çalışması için ham tarih değerlerinin tümü aynı biçimde olmalıdır (ör. “AA/GG/YYYY” veya “GG AA YYYY”). Tarih sınıfına dönüştürdükten sonra, bir değerin doğru şekilde dönüştürüldüğünü doğrulamak için verilerinizi kontrol edin.","code":"\nclass(linelist$age)## [1] \"character\"\nclass(linelist$date_onset)## [1] \"character\"\nlinelist <- linelist %>% \n  mutate(age = as.numeric(age))"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"gruplandırılmış-veri","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Gruplandırılmış veri","text":"Veri çerçeveniz zaten gruplanmışsa (verileri gruplama ile ilgili sayfaya bakın), mutate() veri çerçevesinin gruplanmamasındaki gruba göre farklı davranabilir. Ortalama(), medyan(), max(), vb. gibi herhangi bir özetleme fonksiyonu, tüm satırlara göre değil, gruba göre hesaplayacaktır.Tidyverse mutate belgelerinden gruplanmış veri çerçevelerinde mutate () kullanma hakkında daha fazla bilgi edinebilirsiniz. tidyverse mutate dökümanları.","code":"\n# TÜM satırların ortalamasına göre normalleştirilmiş yaş\nlinelist %>% \n  mutate(age_norm = age / mean(age, na.rm=T))\n\n# hastane grubunun ortalamasına göre normalize edilmiş yaş\nlinelist %>% \n  group_by(hospital) %>% \n  mutate(age_norm = age / mean(age, na.rm=T))"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"clean_across","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Birden çok sütunu dönüştürün","text":"Genellikle kısa bir kod ile aynı dönüşümü birden çok sütuna aynı anda uygulamak amaçlanır. dplyr paketindeki (ayrıca tidyverse paketinde de bulunur) across() fonksiyonu kullanılarak aynı anda birden çok sütuna bir dönüşüm uygulanabilir. across() herhangi bir dplyr fonksiyonuyla kullanılabilir, ancak genellikle select(), mutate(), filter() veya summarise() içinde kullanılır. Tanımlayıcı tablolar sayfasındaki summarise() fonksiyonuna nasıl uygulandığını inceleyin..cols = argümanına sütunlar ve .fns = argümanına uygulanacak fonksiyonlar atanır. .fns fonksiyonuna sağlanacak herhangi bir argüman, yine across() içinde olmak üzere virgülden sonra dahil edilebilir.","code":""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"across-sütun-seçimi","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"across() sütun seçimi","text":".cols = argümanı ile sütunlarını seçin. Bunları tek tek adlandırabilir veya “tidyselect” yardımcı fonksiyonlarını kullanabilirsiniz. Fonksiyonu .fns = ile belirtin. Aşağıda gösterilen fonksiyon modunu kullanarak, fonksiyonun parantez ( ) olmadan yazıldığını unutmayın.Burada .character() dönüşümü, across() içinde tanımlanmış belirli sütunlara uygulanır.Sütunları belirlemede size yardımcı olmak için “tidyselect” yardımcı fonksiyonları mevcuttur. Yukarıda Sütunları seçme ve yeniden sıralama bölümünde ayrıntılı olarak açıklanmıştır ve şu komutları içerir:\neverything(), last_col(), (), starts_with(), ends_with(), contains(), matches(), num_range() ve any_of().Tüm sütunların karakter sınıfına nasıl değiştirileceğine dair bir örnek:Adın “tarih” dizesini içerdiği tüm sütunları karaktere dönüştürün (virgül ve parantezlerin yerleşimine dikkat edinAşağıda, POSIXct sınıfı (zaman damgalarını gösteren ham bir tarihzaman sınıfı) olan sütunları değiştirmenin bir örneği. Başka bir deyişle, burada fonksiyon .POSIXct() DOĞRU olarak değerlendirilir. Daha sonra, bu sütunları normal bir Date sınıfına dönüştürmek için bu sütunlara .Date() fonksiyonu uygulanır.• Across() içinde, .POSIXct’DOĞRU veya YANLIŞ olarak değerlendirdiği () fonksiyonunu da kullandığımızı unutmayın.\n• .POSIXct() komutunun lubridate paketinden olduğunu unutmayın. .character(), .numeric() ve .logical() gibi diğer benzer “” fonksiyonları R tabanı’ndadır.","code":"\nlinelist <- linelist %>% \n  mutate(across(.cols = c(temp, ht_cm, wt_kg), .fns = as.character))\n#tüm sütunları karakter sınıfına değiştirmek için\nlinelist <- linelist %>% \n  mutate(across(.cols = everything(), .fns = as.character))\n#tüm sütunları karakter sınıfına değiştirmek için\nlinelist <- linelist %>% \n  mutate(across(.cols = contains(\"date\"), .fns = as.character))\nlinelist <- linelist %>% \n  mutate(across(.cols = where(is.POSIXct), .fns = as.Date))"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"across-fonksiyonları","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"across() fonksiyonları","text":"across() fonksiyonlarına ilişkin ayrıntılar için ?across ile ilgili belgeleri okuyabilirsiniz. Birkaç özet nokta: Bir sütunda gerçekleştirilecek fonksiyonları belirtmenin birkaç yolu vardır ve hatta kendi fonksiyonlarınızı tanımlayabilirsiniz:\n• Yalnızca fonksiyon adını sağlayabilirsiniz (örneğin, mean veya .character)\n• Fonksiyonu purr stilinde yazabilirsinizi (örneğin ~ mean(.x, na.rm = TRUE)) ([bu sayfaya bakabilirsiniz][Iteration, loops, lists])\n* • Bir liste ile çoklu fonksiyonlar belirlenebilir (örneğin list(mean = mean, n_miss = ~ sum(.na(.x))).\n• Birden çok fonkisyon yazarsanız, giriş sütunu başına farklı adlarla col_fn biçiminde birden çok dönüştürülmüş sütun oluşturulur. Yeni sütunların .names = argümanıyla nasıl adlandırılacağını, {.col} ve {.fn}’nin giriş sütunu ve fonksiyonu için kısayol olduğu tutkal sintaksının Karakterler ve dizeler sayfasına bakınız) kullanarak ayarlayabilirsiniz.Burada across()kullanımı için online kaynaklar yer almakta: yaratıcı Hadley Wickham’ın düşünceleri","code":""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"coalesce","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"coalesce()","text":"Bu dplyr fonksiyonu, konumda eksik olmayan ilk değeri bulur. Eksik değerleri, belirttiğiniz sırayla ilk kullanılabilir değerle “doldurur”.İşte bir veri çerçevesi bağlamı dışında bir örnek: Diyelim ki, biri hastanın tespit edildiği köyü ve diğeri hastanın ikamet ettiği köyü içeren iki vektörünüz var. dizin için eksik olmayan ilk değeri seçmek için birleştirmeyi kullanabilirsiniz:Bu fonksiyon, veri çerçevesi sütunlarıyla da aynı şekilde çalışır: satır için fonksiyon, belirtilen sütunlarda (sırayla) ilk eksik olmayan değerle yeni sütun değerini atar.Bu, “satır bazında” bir işlem örneğidir. Daha karmaşık satır bazında hesaplamalar için aşağıdaki satır bazında hesaplamalar bölümüne bakın.","code":"\nvillage_detection <- c(\"a\", \"b\", NA,  NA)\nvillage_residence <- c(\"a\", \"c\", \"a\", \"d\")\n\nvillage <- coalesce(village_detection, village_residence)\nvillage    # yazdır## [1] \"a\" \"b\" \"a\" \"d\"\nlinelist <- linelist %>% \n  mutate(village = coalesce(village_detection, village_residence))"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"kümülatif-matematik","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Kümülatif Matematik","text":"Bir sütunun, bir veri çerçevesinin satırlarında o noktaya kadar değerlendirildiği kümülatif toplamı/ortalama/min/maks vb. yansıtmasını istiyorsanız, aşağıdaki fonksiyonları kullanın:cumsum() aşağıda gösterildiği gibi kümülatif toplamı verir:Bu, veri çerçevesinde yeni bir sütun oluştururken de kullanılabilir. Örneğin, bir salgında günlük kümülatif vaka sayısını hesaplamak için şöyle bir kod düşünün:Aşağıda ilk 10 satır görülmektedir:Epikurve ile kümülatif insidansın nasıl çizileceğini öğrenmek için [Epidemik eğriler] sayfasına bakın.Bunlara da bakın:\ncumsum(), cummean(), cummin(), cummax(), cumany(), cumall()","code":"\nsum(c(2,4,15,10))     # sadece bir sayı verir## [1] 31\ncumsum(c(2,4,15,10))  # her basamaktaki kümülatif toplamı verir## [1]  2  6 21 31\ncumulative_case_counts <- linelist %>%  # linelist ile başlayan vakalar\n  count(date_onset) %>%                 # 'n' sütunu olarak günlük satır sayısı   \n  mutate(cumulative_cases = cumsum(n))  # her satırdaki kümülatif toplamın yeni sütunu\nhead(cumulative_case_counts, 10)##    date_onset n cumulative_cases\n## 1  2012-04-15 1                1\n## 2  2012-05-05 1                2\n## 3  2012-05-08 1                3\n## 4  2012-05-31 1                4\n## 5  2012-06-02 1                5\n## 6  2012-06-07 1                6\n## 7  2012-06-14 1                7\n## 8  2012-06-21 1                8\n## 9  2012-06-24 1                9\n## 10 2012-06-25 1               10"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"r-tabanı-kullanımı","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"R Tabanı kullanımı","text":"Temel R’(R Tabanı) kullanarak yeni bir sütun tanımlamak (veya bir sütunu yeniden tanımlamak) için, $ ile bağlantılı veri çerçevesinin adını yeni sütuna (veya değiştirilecek sütuna) yazın. Yeni değer(ler)tanımlamak için <- atama operatörünü kullanın. Temel R’kullanırken, seferinde sütun adından önce veri çerçevesi adını belirtmeniz gerektiğini unutmayın (örn. dataframe$column). Aşağıda, temel R kullanarak bmi sütunu oluşturmaya bir örnek verilmiştir:","code":"linelist$bmi = linelist$wt_kg / (linelist$ht_cm / 100) ^ 2)"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"tünel-zincirine-ekleme-yapma","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Tünel zincirine ekleme yapma","text":"Aşağıda, tünel zincirine yeni bir sütun eklenir ve bazı sınıflar dönüştürülür.","code":"\n# TEMİZLİK 'BORU' ZİNCİRİ (ham verilerle başlar ve temizleme adımları boyunca iletir)\n##################################################################################\n\n# tünel zincirini temizlemeye başlayın\n###########################\nlinelist <- linelist_raw %>%\n    \n    # sütun adı sintaksını standartlaştır\n    janitor::clean_names() %>% \n    \n    # sütunları manuel olarak yeniden adlandır\n           # YENİ isim             # ESKİ isim\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # sütunu sil\n    select(-c(row_num, merged_header, x28)) %>% \n  \n    # tekilleştir\n    distinct() %>% \n  \n    # YUKARIDAKİ TEMİZLİK ADIMLARI ZATEN TARTIŞILMIŞTIR\n    ###################################################\n    # yeni bir sütun ekle\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %>% \n  \n    # sütun sınıfını değiştir\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) "},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"değerlerin-yeniden-kodlanması","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"8.8 Değerlerin yeniden kodlanması","text":"Değerleri yeniden kodlamanız (değiştirmeniz) gereken birkaç senaryo:• Belirli bir değeri düzenlemek için (örneğin, yanlış bir yıl veya biçime sahip bir tarih)\n• Aynı şekilde yazılmayan değerleri uzlaştırmak için\n• Yeni bir kategorik değerler sütunu oluşturmak için\n• yeni bir sayısal kategori sütunu oluşturmak için (ör. Yaş kategorileri)","code":""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"spesifik-değerler","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Spesifik değerler","text":"Değerleri manuel olarak değiştirmek için mutate() fonksiyonu içindeki recode() fonksiyonunu kullanabilirsiniz.\nVerilerde uygun olmayan bir tarih olduğunu düşünün (örneğin “2014-14-15”): tarihi ham kaynak verilerde manuel olarak düzeltebilir veya değişikliği mutate() ve recode( aracılığıyla temizleme hattına yazabilirsiniz. ).İkincisi daha şeffaftır ve analizinizi anlamak veya tekrarlamak isteyen herkes için tekrarlanabilir.Yukarıdaki mutate() satırı şu şekilde okunabilir: date_onset sütununu, yeniden kodlanan date_onset sütununa eşit olacak şekilde değiştirin, böylece ESKİ DEĞER YENİ DEĞER olarak değiştirilir”. recode() için bu kalıbın (ESKİ = YENİ) diğer R kalıplarının çoğunun (yeni = eski) tersi olduğuna dikkat edin. R geliştirme topluluğu bunu gözden geçirmek için çalışmaktadır.İşte bir sütun içinde birden çok değeri yeniden kodlayan başka bir örnek.Linelist’te “hospital” sütunundaki değerler temizlenmelidir. Birkaç farklı yazım ve birçok eksik değer var.Aşağıdaki recode() komutu, “hastane” sütununu belirtilen yeniden kodlama değişiklikleriyle geçerli “hastane” sütunu olarak yeniden tanımlar. birinden sonra virgül koymayı unutmayın!Şimdi hospital sütunundaki yazımların düzeltildiğini ve birleştiğini görüyoruz:İPUCU: Eşittir işaretinden önceki ve sonraki boşluk sayısı önemli değildir. Satırlar için = işaretini hizalayarak kodunuzun okunmasını kolaylaştırın. Ayrıca, gelecekteki okuyucular için hangi tarafın ESKİ ve hangi tarafın YENİ olduğunu netleştirmek için bir yorum satırı (#) eklemeyi düşünün. İPUCU: Bazen bir veri kümesinde boş bir karakter değeri bulunur (R tarafından eksik (NA) olarak tanınmaz). Bu değere, aralarında boşluk (““) olmadan iki tırnak işareti ile başvurabilirsiniz.","code":"\n# hatalı değerleri düzelt                   # eski değer       # yeni değer\nlinelist <- linelist %>% \n  mutate(date_onset = recode(date_onset, \"2014-14-15\" = \"2014-04-15\"))\ntable(linelist$hospital, useNA = \"always\")  # eksik olanlar dahil tüm benzersiz değerlerin tablosunu yazdır## \n##                      Central Hopital                     Central Hospital                           Hospital A \n##                                   11                                  457                                  290 \n##                           Hospital B                     Military Hopital                    Military Hospital \n##                                  289                                   32                                  798 \n##                     Mitylira Hopital                    Mitylira Hospital                                Other \n##                                    1                                   79                                  907 \n##                         Port Hopital                        Port Hospital St. Mark's Maternity Hospital (SMMH) \n##                                   48                                 1756                                  417 \n##   St. Marks Maternity Hopital (SMMH)                                 <NA> \n##                                   11                                 1512\nlinelist <- linelist %>% \n  mutate(hospital = recode(hospital,\n                     # kaynak için: ESKİ = YENİ\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      ))\ntable(linelist$hospital, useNA = \"always\")## \n##                     Central Hospital                           Hospital A                           Hospital B \n##                                  468                                  290                                  289 \n##                    Military Hospital                                Other                        Port Hospital \n##                                  910                                  907                                 1804 \n## St. Mark's Maternity Hospital (SMMH)                                 <NA> \n##                                  428                                 1512"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"mantık-kullanımı","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Mantık kullanımı","text":"Aşağıda, mantık ve koşulların kullanımıyla bir sütundaki değerlerin nasıl yeniden kodlanacağını gösteriyoruz:• Basit mantık için replace(), ifelse() ve if_else() kullanımı\n• Daha karmaşık mantık için case_while() kullanımı","code":""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"basit-mantık","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Basit mantık","text":"","code":""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"replace","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"replace()","text":"Basit mantık kriterleriyle yeniden kodlamak için mutate() içinde replace() öğesini kullanabilirsiniz. replace(), temel R’daki bir fonksiyondur. Değiştirilecek satırları belirtmek için bir mantık koşulu kullanın. Genel sintaks şöyledir:mutate(col_to_change = replace(col_to_change, criteria rows, new value)).replace() fonksiyonunun en yaygın kullanımı; benzersiz bir satır tanımlayıcısı kullanarak bir satırdaki yalnızca bir değeri değiştirmektir. Aşağıda, case_id sütununun “2195” olduğu satırda cinsiyet “Kadın” olarak değiştirilmiştir.Temel R sintaksı ve dizinleme parantezlerini [ ] kullanan eşdeğer komut aşağıdadır. “Veri çerçevesi satır listesinin gender sütun değerini (satır listesinin case_id sütununda ‘2195’ değerine sahip olduğu satır için) ‘Kadın’ olarak değiştirin” olarak okunur.","code":"\n# Örnek: belirli bir gözlemin cinsiyetini \"Female\" olarak değiştirin\nlinelist <- linelist %>% \n  mutate(gender = replace(gender, case_id == \"2195\", \"Female\"))\nlinelist$gender[linelist$case_id == \"2195\"] <- \"Female\""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"ifelse-ve-if_else","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"ifelse() ve if_else()","text":"ABasit mantık için başka bir araç ifelse() ve if_else()’dir. Bununla birlikte, çoğu durumda yeniden kodlama için case_when() kullanmak daha kolaydır (aşağıda ayrıntılı olarak açıklanmıştır). Bu “else” komutları, ve else programlama ifadelerinin basitleştirilmiş versiyonlarıdır. Genel sözdizimi şöyledir:\nifelse(condition, value return condition evaluates TRUE, value return condition evaluates FALSE)Aşağıda, source_known sütunu tanımlanmıştır. Sütun kaynağındaki satırın değeri eksik değilse, belirli bir satırdaki değeri “bilinen” olarak ayarlanır. Kaynaktaki değer eksikse, kaynak_bilinen içindeki değer “bilinmeyen” olarak ayarlanır.if_else(), tarihleri işleyen dplyr’özel bir sürümüdür. “doğru” değer bir tarihse, “yanlış” değerin de bir tarihi nitelemesi gerektiğini, dolayısıyla yalnızca NA yerine NA_real_ özel değerinin kullanması gerektiğini unutmayın.Birçok ifelse komutunu bir araya getirmekten kaçının… bunun yerine case_When() kullanın! case_When() çok daha kolay okunur ve daha az hata yaparsınız.Bir veri çerçevesi bağlamı dışında, kodunuzda kullanılan bir nesnenin değerini değiştirmesini istiyorsanız, temel R’dan switch() kullanmayı düşünün.","code":"\nlinelist <- linelist %>% \n  mutate(source_known = ifelse(!is.na(source), \"known\", \"unknown\"))\n# Hasta ölmediyse NA olan bir ölüm tarihi sütunu oluşturun.\nlinelist <- linelist %>% \n  mutate(date_death = if_else(outcome == \"Death\", date_outcome, NA_real_))"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"clean_case_when","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Karmaşık mantık","text":"Birçok yeni gruba yeniden kodlama yapıyorsanız veya değerleri yeniden kodlamak için karmaşık mantıksal ifadeler kullanmanız gerekiyorsa dplyr’case_while() fonksiyonunu kullanın. Bu fonkisyon, veri çerçevesindeki satırı değerlendirir, satırların belirtilen kriterleri karşılayıp karşılamadığını değerlendirir ve doğru yeni değeri atar.case_When() komutları, “tilde” ~ ile ayrılmış Sağ Taraf (RHS) ve Sol Taraf (LHS) içeren ifadelerden oluşur. Mantık kriterleri bir ifadenin sol tarafında ve ilgili değerler sağ tarafındadır. İfadeler virgülle ayrılır.Örneğin, burada age_years sütunu oluşturmak için age ve age_unit sütunlarını kullanıyoruz:Verilerdeki satır değerlendirilirken, kriterler case_while() ifadelerinin yazıldığı sırayla - yukarıdan aşağıya - uygulanır/değerlendirilir. Belirli bir satır için en üstteki ölçüt DOĞRU olarak değerlendirilirse, RHS değeri atanır ve kalan ölçütler o satır için test edilmez. Bu nedenle, en spesifik kriterleri önce ve en genel olanı en son yazmak en iyisidir.Bu satırlar boyunca, son ifadenizde, önceki kriterlerden herhangi birini karşılamayan satırları yakalayacak şekilde, sol tarafa DOĞRU’yu yerleştirin. Bu ifadenin sağ tarafına “kontrol et!” gibi bir değer atanabilir. veya eksik olarak değerlendirilir.TEHLİKE: Sağ taraftaki değerlerin tümü aynı sınıfta olmalıdır - sayısal, karakter, tarih, mantıksal vb. Eksik (NA) ya senaryoyu ele almadan bırakın ya da NA_character_, NA_real_ (sayısal veya POSIX) ve .Date(NA) gibi NA’nın özel varyasyonlarını kullanmanız gerekebilir. Tarihlerle çalışma bölümünden daha fazlasını okuyabilirsiniz.","code":"\nlinelist <- linelist %>% \n  mutate(age_years = case_when(\n            age_unit == \"years\"  ~ age,       # yaş yıl olarak verildiyse\n            age_unit == \"months\" ~ age/12,    # yaş ay olarak verildiyse\n            is.na(age_unit)      ~ age))      # yaş birimi eksikse, yıl varsayın\n                                              # Başka herhangi bir senaryo NA olarak atanır"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"eksik-değerler-1","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Eksik değerler","text":"Aşağıda, veri temizleme bağlamında eksik değerlerle çalışmak için özel fonksiyonlar bulunmaktadır.Eksik değerleri belirleme ve işleme konusunda daha ayrıntılı bilgi için Eksik veriler sayfasına bakın. Örneğin, eksik olup olmadığını mantıksal olarak test eden .na() fonksiyonu.replace_na()Eksik değerleri (NA), “Eksik” gibi belirli bir değerle değiştirmek için, mutate() içindeki dplyr replace_na() fonksiyonunu kullanın. Bunun yukarıdaki recode ile aynı şekilde kullanıldığını unutmayın - değişkenin adı replace_na() içinde tekrarlanmalıdır.fct_explicit_na()Bu, forcats paketinden bir fonksiyondur. forcats paketi, faktör sınıfının sütunlarını işler. Faktörler, R’nin c(“Birinci”, “İkinci”, “Üçüncü”) gibi sıralı değerleri işleme veya değerlerin (örn. hastaneler) tablolarda ve çizimlerde görünme sırasını belirleme yöntemidir. Faktörler sayfasını inceleyin.Verileriniz Faktör sınıfı ise ve replace_na() kullanarak NA’yı “Eksik”e dönüştürmeye çalışırsanız, şu hatayı alırsınız: geçersiz faktör düzeyi, NA oluşturuldu. Faktörün olası bir düzeyi olarak “Eksik” değerini bir değer olarak eklemeye çalıştığınızda reddedilirsiniz.Bunu çözmenin en kolay yolu, bir sütunu sınıf faktörüne ve NA değerlerini “(Missing)” karakterine dönüştüren forcats fonksiyonunu fct_explicit_na() kullanmaktır.Daha yavaş bir alternatif, fct_expand() kullanarak faktör düzeyini eklemek ve ardından eksik değerleri dönüştürmek olabilir.na_if()Belirli bir değeri NA’ya dönüştürmek için dplyr’na_if() fonksiyonunu kullanın. Aşağıdaki komut, replace_na() fonksiyonunun tersi işlemini gerçekleştirir. Aşağıdaki örnekte, hastane sütunundaki herhangi bir “Eksik” değeri NA’ya dönüştürülür.: na_if() mantık kriterleri için kullanılamaz (örneğin, “tüm değerler > 99”) - bunun için replace() veya case_while() kullanın:","code":"\nlinelist <- linelist %>% \n  mutate(hospital = replace_na(hospital, \"Missing\"))\nlinelist %>% \n  mutate(hospital = fct_explicit_na(hospital))\nlinelist <- linelist %>% \n  mutate(hospital = na_if(hospital, \"Missing\"))\n# 40'ın üzerindeki sıcaklıkları NA'ya dönüştürün\nlinelist <- linelist %>% \n  mutate(temp = replace(temp, temp > 40, NA))\n\n#  1 Ocak 2000'den önceki başlangıç tarihlerini eksik tarihlere dönüştürün\nlinelist <- linelist %>% \n  mutate(date_onset = replace(date_onset, date_onset > as.Date(\"2000-01-01\"), NA))"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"sözlüğün-temizlenmesi","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Sözlüğün temizlenmesi","text":"Bir veri çerçevesini bir temizleme sözlüğü ile temizlemek için R paketi satır matchmaker ve match_df() fonksiyonunu kullanın.3 sütunlu bir temizleme sözlüğü oluşturun:\n• Bir “-den” sütunu (yanlış değer)\n• Bir “-e” sütunu (doğru değer)\n• Değişikliklerin uygulanacağı sütunu belirten bir sütun (veya tüm sütunlara uygulanacak “.global”): .global sözlük girişleri, sütuna özel sözlük girişleri tarafından geçersiz kılınacaktır.Sözlük dosyasını R’aktarın. Bu örnek, [El kitabı ve veri indirme] sayfasındaki talimatlar aracılığıyla indirilebilir.Ham satır listesini, dictionary = temizleme sözlüğü veri çerçevesini belirterek match_df() öğesine iletin. = argümanı “eski” değerleri içeren sözlük sütununun adı olmalıdır, = argümanı karşılık gelen “yeni” değerleri içeren sözlük sütunu olmalıdır ve üçüncü sütun değişikliğin yapılacağı sütunu listeler. Bir değişikliği tüm sütunlara uygulamak için = sütununda .global kullanın. Dördüncü bir sözlük sütunu olan order yeni değerlerin faktör sırasını belirtmek için kullanılabilir. Bu fonksiyonun çalışmasının uzun zaman alabileceğini unutmayın.Daha fazla ayrıntıyı ?match_df komutunu çalıştırarak paket dokümantasyonu adresinden okuyabilirsiniz.Şimdi değerlerin nasıl değiştiğini görmek için sağa kaydırın - özellikle cinsiyet (küçük harften büyük harfe) ve tüm semptom sütunları evet/hayır’dan 1/0’dönüştürülmüşür.Temizleme sözlüğündeki sütun adlarınızın, temizleme komut dosyanızın bu noktasındaki adlara karşılık gelmesi gerektiğini unutmayın.","code":"\ncleaning_dict <- import(\"cleaning_dict.csv\")\nlinelist <- linelist %>%               # veri setinizi sağlayın veya borulayın\n     matchmaker::match_df(\n          dictionary = cleaning_dict,  # sözlüğünüzün adı\n          from = \"from\",               # değiştirilecek değerlerin bulunduğu sütun (varsayılan değer col 1'dir)\n          to = \"to\",                   # nihai değerleri içeren sütun (varsayılan değer 2. sütundur)\n          by = \"col\"                   # sütun adları ile sütun (varsayılan col 3'tür)\n  )"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"tünel-zincirine-ekleme-1","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Tünel zincirine ekleme","text":"Aşağıda, tünel zincirine bazı yeni sütunlar ve sütun dönüşümleri eklenmiştir.","code":"\n# TEMİZLİK 'BORU' ZİNCİRİ (ham verilerle başlar ve temizleme adımları boyunca iletir\n##################################################################################\n\n# tünel zincirini temizlemeye başla\n###########################\nlinelist <- linelist_raw %>%\n    \n    # sütun adı sintaksını standartlaştır\n    janitor::clean_names() %>% \n    \n    # sütunları manuel olarak yeniden adlandır\n           # YENİ isim             # ESKİ isim\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # sütunu sil\n    select(-c(row_num, merged_header, x28)) %>% \n  \n    # tekilleştir\n    distinct() %>% \n  \n    # sütun ekle\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     \n\n    # sütun sınıfını değiştir\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %>% \n    \n    # sütun ekleme: hastaneye yatışta gecikme\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% \n    \n   # YUKARIDAKİ TEMİZLİK ADIMLARI ZATEN TARTIŞILMIŞTIR\n   ###################################################\n\n    # hastane sütununun temiz değerleri\n    mutate(hospital = recode(hospital,\n                      # ESKİ = YENİ\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %>% \n    \n    mutate(hospital = replace_na(hospital, \"Missing\")) %>% \n\n    # age_years sütunu oluştur (age ve age_unit sütunlarından)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age))"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"num_cats","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"8.9 Sayısal kategoriler","text":"Burada sayısal sütunlardan kategoriler oluşturmaya yönelik bazı özel yaklaşımları açıklıyoruz. Yaygın örnekler arasında yaş kategorileri, laboratuvar değerleri grupları vb. bulunur. Burada şunları tartışacağız:• epikit paketinden age_categories()\n• temel R’dan cut()\n• case_When()\n• quantile() ve ntile() ile nicel sonlanmalar","code":""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"dağılımın-gözden-geçirilmesi","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Dağılımın gözden geçirilmesi","text":"Bu örnek için age_years sütununu kullanarak bir age_cat sütunu oluşturacağız.İlk olarak, uygun kesme noktaları yapmak için verilerinizin dağılımını inceleyin. ggplot temelleri ile ilgili sayfaya bakabilirsiniz.UYARI: Bazen sayısal değişkenler “karakter” sınıfı olarak içe aktarılır. Bu durum, bazı değerlerde sayısal olmayan karakterler varsa, örneğin yaş için “2 ay” girişi veya (yerel ayarlarınıza bağlı olarak) ondalık basamakta virgül kullanılmışsa (örn. 5” dört buçuk yıl anlamına gelir) karşınıza çıkar.","code":"\n#linelist değişken yaşının sınıfını kontrol edin\nclass(linelist$age_years)## [1] \"numeric\"\n# dağılımın incelenmesi\nhist(linelist$age_years)\nsummary(linelist$age_years, na.rm=T)##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n##    0.00    6.00   13.00   16.04   23.00   84.00     107"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"age_categories","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"age_categories()","text":"Epikit paketiyle, sayısal sütunları kolayca kategorilere ayırmak ve etiketlemek için age_categories() fonksiyonunu kullanabilirsiniz (: bu fonksiyon, yaş dışı sayısal değişkenlere de uygulanabilir). Bir bonus olarak, fonkisyonun oluşturduğu çıktı sütunu otomatik olarak sıralı bir faktör özelliğinde gelir.Gerekli girdiler:\n• Sayısal bir vektör (sütun)\n• Kesiciler = argüman - yeni gruplar için sayısal bir kesim noktası vektörü sağlarİlk olarak, en basit örnek:Belirttiğiniz kesme değerleri varsayılan olarak alt sınırlardır - yani “üst” gruba dahil edilirler / gruplar alt/sol tarafta “açıktır”. Aşağıda gösterildiği gibi, üstte/sağda açık olan gruplara ulaşmak için bir ara değerine 1 ekleyebilirsiniz.Ayırıcı = ile etiketlerin nasıl görüntüleneceğini ayarlayabilirsiniz. Varsayılan “-”Ceiling = değişkeni ile en üstteki sayıların nasıl kullanılacağını ayarlayabilirsiniz. Daha yukarı seviyede eşik değeri ayarlamak için ceiling = DOĞRU. Bu kullanımda sağlanan en yüksek kesim değeri bir “tavan”dır ve “XX+” kategorisi oluşturulmaz. En yüksek kırılma değerinin üzerindeki (veya tanımlanmışsa upper =) değerler NA olarak kategorize edilir. Aşağıda ceiling = DOĞRU olan bir örnek verilmiştir, bu örnekte XX+ kategorisi yoktur ve 70’üzerindeki değerler (en yüksek kesmi değeri) NA olarak atanır.Alternatif olarak, ayırıcılar = yerine, tüm lower =, upper = ve = değerlerini verebilirsiniz:• lower = Dikkate alınmasını istediğiniz en düşük sayı - varsayılan 0’dır\n• upper = dikkate alınmasını istediğiniz en yüksek sayı\n• = Gruplar arasındaki yıl sayısıDaha fazla ayrıntı için Yardım sayfasına bakın (R konsolunda ?age_categories).","code":"\n# basit örnek\n################\npacman::p_load(epikit)                    # paket yükleme\n\nlinelist <- linelist %>% \n  mutate(\n    age_cat = age_categories(             # yeni sütun ekleme\n      age_years,                          # grupların oluşturulacağı ssayısal sütun \n      breakers = c(0, 5, 10, 15, 20,      # kesim noktaları \n\n                   30, 40, 50, 60, 70)))\n\n# tabloyu göster\ntable(linelist$age_cat, useNA = \"always\")## \n##   0-4   5-9 10-14 15-19 20-29 30-39 40-49 50-59 60-69   70+  <NA> \n##  1227  1223  1048   827  1216   597   251    78    27     7   107\n# Aynı kategoriler için üst uçları dahil et\n############################################\nlinelist <- linelist %>% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      breakers = c(0, 6, 11, 16, 21, 31, 41, 51, 61, 71)))\n\n# tabloyu göster\ntable(linelist$age_cat, useNA = \"always\")## \n##   0-5  6-10 11-15 16-20 21-30 31-40 41-50 51-60 61-70   71+  <NA> \n##  1469  1195  1040   770  1149   547   231    70    24     6   107\n# Tavan DOĞRU olarak ayarlandığında\n##########################\nlinelist <- linelist %>% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      breakers = c(0, 5, 10, 15, 20, 30, 40, 50, 60, 70),\n      ceiling = TRUE)) # 70 tavandır, her şey NA olur\n\n# tabloyu göster\ntable(linelist$age_cat, useNA = \"always\")## \n##   0-4   5-9 10-14 15-19 20-29 30-39 40-49 50-59 60-70  <NA> \n##  1227  1223  1048   827  1216   597   251    78    28   113\nlinelist <- linelist %>% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      lower = 0,\n      upper = 100,\n      by = 10))\n\n# tabloyu göster\ntable(linelist$age_cat, useNA = \"always\")## \n##   0-9 10-19 20-29 30-39 40-49 50-59 60-69 70-79 80-89 90-99  100+  <NA> \n##  2450  1875  1216   597   251    78    27     6     1     0     0   107"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"cut","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"cut()","text":"cut(), age_categories()’e alternatif bir temel R fonksiyonudur, Bu işlemin basitleştirilmesi için age_categories()’geliştirilmiştir. age_categories()’den bazı dikkate değer farklılıkları şunlardır:• Başka bir paket kurmanız/yüklemeniz gerekmez• Sağda/solda grupların açık/kapalı olup olmadığını belirleyebilirsiniz.• Doğru etiketleri kendiniz sağlamalısınız• En alt gruba 0’ın dahil edilmesini istiyorsanız, bunu belirtmelisiniz.cut() içindeki temel sintaksta, önce kesilecek sayısal sütun (age_years) ve ardından kesme noktalarının sayısal vektörü olan break argümanı yazılmalıdır. cut() kullanılarak elde edilen sütun sıralı bir faktördür.Varsayılan olarak, sınıflandırma sağ/üst taraf “açık” ve kapsayıcı (ve sol/alt taraf “kapalı” veya özel) olacak şekilde gerçekleşir. Bu, age_categories() fonksiyonunun tersi davranıştır. Varsayılan etiketler, “(, B]” notasyonunu kullanır, bu, ’nın dahil edilmediği, ancak B’nin dahil olduğu anlamına gelir. right = DOĞRU argümanını sağlayarak bu davranışı tersine çevirin.Bu nedenle, varsayılan olarak “0” değerleri en düşük gruptan çıkarılır ve NA olarak sınıflandırılır! “0” değerleri 0 yaş olarak kodlanmış bebekler olabilir, bu yüzden dikkatli olun! Bunu değiştirmek için, include.lowest = DOĞRU argümanını ekleyin, böylece herhangi bir “0” değeri en düşük gruba dahil edilecektir. En düşük kategori için otomatik olarak oluşturulan etiket “[],B]” olacaktır. include.lowest = DOĞRU argümanını ve right = DOĞRU’yu eklerseniz, aşırı değerleri dahil etmenin artık en düşük değil, en yüksek kesme noktası değeri ve kategorisi için geçerli olacağını unutmayın.Etiketler = bağımsız değişkenini kullanarak bir özelleştirilmiş etiket vektörü sağlayabilirsiniz. Bunlar elle yazıldığından, doğru olduklarından emin olmak için çok dikkatli olun! Aşağıda açıklandığı gibi çapraz tablolama kullanarak çalışmanızı kontrol edin.Yeni age_cat değişkenini yapmak için age_years’uygulanan bir cut() örneği aşağıdadır:İşini kontrol et!!! Sayısal ve kategori sütunlarını çapraz tablolayarak yaş değerinin doğru kategoriye atandığını doğrulayın. Sınır değerlerinin atanmasını inceleyin (örneğin komşu kategoriler 10-15 ve 16-20 ise 15).NA değerlerinin yeniden etiketlenmesi NA değerlerine “Eksik” gibi bir etiket atamak isteyebilirsiniz. Yeni sütun faktör sınıfından (kısıtlı değerler) olduğundan replace_na() ile değiştiremezsiniz. Bunun yerine, Faktörler sayfasında açıklandığı gibi forcat’lerden fct_explicit_na() kullanın.Hızlı şekilde kesim noktaları ve etiket oluşturma Kesim noktası oluşturma ve vektörleri etiketlemenin hızlı bir yolu için aşağıdaki yöntemi kullanın. seq() ve rep() ile ilgili referanslar için [R temelleri] sayfasına bakınız.R konsoluna ?cut yazarak cut() hakkında daha fazla bilgi edinin.","code":"\n# Sayısal yaş değişkenini keserek yeni değişken oluşturun\n# alt kesim hariç tutulmuştur, ancak her kategoride üst kesim dahil edilmiştir\n\nlinelist <- linelist %>% \n  mutate(\n    age_cat = cut(\n      age_years,\n      breaks = c(0, 5, 10, 15, 20,\n                 30, 50, 70, 100),\n      include.lowest = TRUE         # 0'ı en düşük gruba dahil et\n      ))\n\n# grup başına gözlem sayısını tablo haline getirin\ntable(linelist$age_cat, useNA = \"always\")## \n##    [0,5]   (5,10]  (10,15]  (15,20]  (20,30]  (30,50]  (50,70] (70,100]     <NA> \n##     1469     1195     1040      770     1149      778       94        6      107\n# Sayısal ve kategori sütunlarının çapraz tablosu.  \ntable(\"Numeric Values\" = linelist$age_years,   # netlik için tabloda belirtilen isimler.\n      \"Categories\"     = linelist$age_cat,\n      useNA = \"always\")                        # NA değerlerini incelemeyi unutmayın##                     Categories\n## Numeric Values       [0,5] (5,10] (10,15] (15,20] (20,30] (30,50] (50,70] (70,100] <NA>\n##   0                    136      0       0       0       0       0       0        0    0\n##   0.0833333333333333     1      0       0       0       0       0       0        0    0\n##   0.25                   2      0       0       0       0       0       0        0    0\n##   0.333333333333333      6      0       0       0       0       0       0        0    0\n##   0.416666666666667      1      0       0       0       0       0       0        0    0\n##   0.5                    6      0       0       0       0       0       0        0    0\n##   0.583333333333333      3      0       0       0       0       0       0        0    0\n##   0.666666666666667      3      0       0       0       0       0       0        0    0\n##   0.75                   3      0       0       0       0       0       0        0    0\n##   0.833333333333333      1      0       0       0       0       0       0        0    0\n##   0.916666666666667      1      0       0       0       0       0       0        0    0\n##   1                    275      0       0       0       0       0       0        0    0\n##   1.5                    2      0       0       0       0       0       0        0    0\n##   2                    308      0       0       0       0       0       0        0    0\n##   3                    246      0       0       0       0       0       0        0    0\n##   4                    233      0       0       0       0       0       0        0    0\n##   5                    242      0       0       0       0       0       0        0    0\n##   6                      0    241       0       0       0       0       0        0    0\n##   7                      0    256       0       0       0       0       0        0    0\n##   8                      0    239       0       0       0       0       0        0    0\n##   9                      0    245       0       0       0       0       0        0    0\n##   10                     0    214       0       0       0       0       0        0    0\n##   11                     0      0     220       0       0       0       0        0    0\n##   12                     0      0     224       0       0       0       0        0    0\n##   13                     0      0     191       0       0       0       0        0    0\n##   14                     0      0     199       0       0       0       0        0    0\n##   15                     0      0     206       0       0       0       0        0    0\n##   16                     0      0       0     186       0       0       0        0    0\n##   17                     0      0       0     164       0       0       0        0    0\n##   18                     0      0       0     141       0       0       0        0    0\n##   19                     0      0       0     130       0       0       0        0    0\n##   20                     0      0       0     149       0       0       0        0    0\n##   21                     0      0       0       0     158       0       0        0    0\n##   22                     0      0       0       0     149       0       0        0    0\n##   23                     0      0       0       0     125       0       0        0    0\n##   24                     0      0       0       0     144       0       0        0    0\n##   25                     0      0       0       0     107       0       0        0    0\n##   26                     0      0       0       0     100       0       0        0    0\n##   27                     0      0       0       0     117       0       0        0    0\n##   28                     0      0       0       0      85       0       0        0    0\n##   29                     0      0       0       0      82       0       0        0    0\n##   30                     0      0       0       0      82       0       0        0    0\n##   31                     0      0       0       0       0      68       0        0    0\n##   32                     0      0       0       0       0      84       0        0    0\n##   33                     0      0       0       0       0      78       0        0    0\n##   34                     0      0       0       0       0      58       0        0    0\n##   35                     0      0       0       0       0      58       0        0    0\n##   36                     0      0       0       0       0      33       0        0    0\n##   37                     0      0       0       0       0      46       0        0    0\n##   38                     0      0       0       0       0      45       0        0    0\n##   39                     0      0       0       0       0      45       0        0    0\n##   40                     0      0       0       0       0      32       0        0    0\n##   41                     0      0       0       0       0      34       0        0    0\n##   42                     0      0       0       0       0      26       0        0    0\n##   43                     0      0       0       0       0      31       0        0    0\n##   44                     0      0       0       0       0      24       0        0    0\n##   45                     0      0       0       0       0      27       0        0    0\n##   46                     0      0       0       0       0      25       0        0    0\n##   47                     0      0       0       0       0      16       0        0    0\n##   48                     0      0       0       0       0      21       0        0    0\n##   49                     0      0       0       0       0      15       0        0    0\n##   50                     0      0       0       0       0      12       0        0    0\n##   51                     0      0       0       0       0       0      13        0    0\n##   52                     0      0       0       0       0       0       7        0    0\n##   53                     0      0       0       0       0       0       4        0    0\n##   54                     0      0       0       0       0       0       6        0    0\n##   55                     0      0       0       0       0       0       9        0    0\n##   56                     0      0       0       0       0       0       7        0    0\n##   57                     0      0       0       0       0       0       9        0    0\n##   58                     0      0       0       0       0       0       6        0    0\n##   59                     0      0       0       0       0       0       5        0    0\n##   60                     0      0       0       0       0       0       4        0    0\n##   61                     0      0       0       0       0       0       2        0    0\n##   62                     0      0       0       0       0       0       1        0    0\n##   63                     0      0       0       0       0       0       5        0    0\n##   64                     0      0       0       0       0       0       1        0    0\n##   65                     0      0       0       0       0       0       5        0    0\n##   66                     0      0       0       0       0       0       3        0    0\n##   67                     0      0       0       0       0       0       2        0    0\n##   68                     0      0       0       0       0       0       1        0    0\n##   69                     0      0       0       0       0       0       3        0    0\n##   70                     0      0       0       0       0       0       1        0    0\n##   72                     0      0       0       0       0       0       0        1    0\n##   73                     0      0       0       0       0       0       0        3    0\n##   76                     0      0       0       0       0       0       0        1    0\n##   84                     0      0       0       0       0       0       0        1    0\n##   <NA>                   0      0       0       0       0       0       0        0  107\nlinelist <- linelist %>% \n  \n  # cut()age_cat oluşturur, otomatik olarak faktör sınıfı özelliğindedir.     \n  mutate(age_cat = cut(\n    age_years,\n    breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),          \n    right = FALSE,\n    include.lowest = TRUE,        \n    labels = c(\"0-4\", \"5-9\", \"10-14\", \"15-19\", \"20-29\", \"30-49\", \"50-69\", \"70-100\")),\n         \n    # eksik değerleri açık hale getirmek\n    age_cat = fct_explicit_na(\n      age_cat,\n      na_level = \"Missing age\")  # you can specify the label\n  )    \n\n# sayıları görüntülemek için tablo\ntable(linelist$age_cat, useNA = \"always\")## \n##         0-4         5-9       10-14       15-19       20-29       30-49       50-69      70-100 Missing age \n##        1227        1223        1048         827        1216         848         105           7         107 \n##        <NA> \n##           0\n# 0'dan 90'a 5'erli kesim noktaları yapın\nage_seq = seq(from = 0, to = 90, by = 5)\nage_seq\n\n# Varsayılan cut() ayarlarına göre yukarıdaki kategoriler için etiketler yapın\nage_labels = paste0(age_seq + 1, \"-\", age_seq + 5)\nage_labels\n\n# her iki vektörün de aynı uzunlukta olduğunu kontrol edin\nlength(age_seq) == length(age_labels)"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"yüzdelik-kesim-noktaları","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Yüzdelik kesim noktaları","text":"Genel olarak, “yüzdelik dilimler”, değerlerin bir kısmının altına düştüğü bir değeri ifade eder. Örneğin, satır listesindeki yaşların 95. yüzdelik dilimi, yaşın %95’inin altına düştüğü yaş olacaktır.Bununla birlikte, konuşmada, “çeyreklikler” ve “ondalıklar”, eşit olarak 4 veya 10 gruba bölünmüş veri gruplarını da ifade edebilir (grup sayısından bir fazla kesim noktası olacağını unutmayın).Yüzdelik kırılma noktaları elde etmek için, temel R stats paketinden quantile() öğesini kullanabilirsiniz. Sayısal bir vektör (örneğin, bir veri kümesindeki bir sütun) ve 0 ile 1.0 arasında değişen sayısal değerleri içeren vektör yazılmalıdır. Kesmi noktaları sayısal bir vektör olarak oluşturulur. Konsola ?quantile komutunu girerek istatistiksel metodolojilerin ayrıntılarını keşfedin.• Girdiğiniz sayısal vektörde eksik değerler varsa, en iyisi na.rm = DOĞRU olarak ayarlamaktır.• Adsız bir sayısal vektör elde etmek için names = YANLIŞquantile() sonuçlarını age_categories() veya cut() içinde kesim noktaları olarak kullanabilirsiniz. Aşağıda cut() kullanarak yeni bir sütun oluşturuyoruz, burada kesim noktaları age_years üzerinde quantiles() kullanılarak tanımlanıyor. Aşağıda, yüzdeleri görebilmeniz için janitor’dan tabyl() fonksiyonu kullanarak sonuçları gösteriyoruz Tanımlayıcı tablolar sayfasına bakabilirsiniz. gruptaki, yüzdeliklerin tam olarak %10 olmadıklarına dikkat edin.","code":"\nquantile(linelist$age_years,               # üzerinde çalışılacak sayısal vektörü belirtin\n  probs = c(0, .25, .50, .75, .90, .95),   # istediğiniz yüzdelik dilimleri belirtin\n  na.rm = TRUE)                            # eksik değerleri yoksay ##  0% 25% 50% 75% 90% 95% \n##   0   6  13  23  33  41\nlinelist %>%                                # linelist ile başla \n  mutate(deciles = cut(age_years,           # age_years sütununda cut() olarak yeni sütun ondalık oluştur\n    breaks = quantile(                      # quantile() kullanarak kesim noktalarını tanımlayın\n      age_years,                               # age_years çalıştır\n      probs = seq(0, 1, by = 0.1),             # 0,0 ile 1,0 arasında 0,1’erlik aralıklar\n      na.rm = TRUE),                           # eksik değerleri yoksay\n    include.lowest = TRUE)) %>%             # cut() için 0 yaşını içerir\n  janitor::tabyl(deciles)                   # görüntülemek için tabloya tünelle##  deciles   n    percent valid_percent\n##    [0,2] 748 0.11319613    0.11505922\n##    (2,5] 721 0.10911017    0.11090601\n##    (5,7] 497 0.07521186    0.07644978\n##   (7,10] 698 0.10562954    0.10736810\n##  (10,13] 635 0.09609564    0.09767728\n##  (13,17] 755 0.11425545    0.11613598\n##  (17,21] 578 0.08746973    0.08890940\n##  (21,26] 625 0.09458232    0.09613906\n##  (26,33] 596 0.09019370    0.09167820\n##  (33,84] 648 0.09806295    0.09967697\n##     <NA> 107 0.01619249            NA"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"eşit-boyutlu-gruplar","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Eşit boyutlu gruplar","text":"Sayısal gruplar oluşturmak için başka bir araç, verilerinizi eşit boyutlu gruplara ayırmaya çalışan ntile() dplyr fonksiyonudur - ancak quantile()’den farklı olarak aynı değerin birden fazla grupta görünebileceğini unutmayın. Sayısal vektörü ve ardından grup sayısını girin. Oluşturulan yeni sütundaki değerler, cut() kullanılırken olduğu gibi değer aralığının kendisi değil, yalnızca “sayılar” grubudur (örneğin 1 ila 10).","code":"\n# ntile() ile gruplar oluştur\nntile_data <- linelist %>% \n  mutate(even_groups = ntile(age_years, 10))\n\n# gruba göre sayım ve orantı tablosu yapın\nntile_table <- ntile_data %>% \n  janitor::tabyl(even_groups)\n  \n# aralıkları göstermek için min/maks değerleri ekleyin\nntile_ranges <- ntile_data %>% \n  group_by(even_groups) %>% \n  summarise(\n    min = min(age_years, na.rm=T),\n    max = max(age_years, na.rm=T)\n  )## Warning in min(age_years, na.rm = T): no non-missing arguments to min; returning Inf## Warning in max(age_years, na.rm = T): no non-missing arguments to max; returning -Inf\n# birleştir ve yazdır - değerlerin birden fazla grupta bulunduğunu unutmayın\nleft_join(ntile_table, ntile_ranges, by = \"even_groups\")##  even_groups   n    percent valid_percent min  max\n##            1 651 0.09851695    0.10013844   0    2\n##            2 650 0.09836562    0.09998462   2    5\n##            3 650 0.09836562    0.09998462   5    7\n##            4 650 0.09836562    0.09998462   7   10\n##            5 650 0.09836562    0.09998462  10   13\n##            6 650 0.09836562    0.09998462  13   17\n##            7 650 0.09836562    0.09998462  17   21\n##            8 650 0.09836562    0.09998462  21   26\n##            9 650 0.09836562    0.09998462  26   33\n##           10 650 0.09836562    0.09998462  33   84\n##           NA 107 0.01619249            NA Inf -Inf"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"case_when","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"case_when()","text":"Sayısal bir sütundan kategoriler oluşturmak için case_while() dplyr fonksiyonunu kullanmak mümkündür, ancak epikit veya cut()’tan age_categories() kullanmak daha kolaydır çünkü bunlar otomatik olarak sıralı bir faktör oluşturacaktır.case_while() kullanıyorsanız, lütfen bu sayfanın değerleri yeniden kodla bölümünde daha önce açıklandığı gibi doğru kullanıldığını kontrol edin. Ayrıca tüm sağ taraftaki değerlerin aynı sınıfta olması gerektiğini unutmayın. Bu nedenle, sağ tarafta NA istiyorsanız, “Eksik” yazmalı veya NA_character_ özel NA değerini kullanmalısınız.","code":""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"tünel-zincirine-ekleme-2","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Tünel zincirine ekleme","text":"Aşağıda, temizleme tünel zincirine iki kategorik yaş sütunu oluşturma kodu eklenmiştir:","code":"\n# TEMİZLİK 'TÜNEL' ZİNCİRİ (ham verilerle başlar ve temizleme adımları boyunca iletir)\n##################################################################################\n\n# tünel zincirini temizlemeye başla\n###########################\nlinelist <- linelist_raw %>%\n    \n    # sütun adı sintaksını standartlaştır\n    janitor::clean_names() %>% \n    \n    # sütunları manuel olarak yeniden adlandır\n           # YENİ isim             # ESKİ isim\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # sütunu sil\n    select(-c(row_num, merged_header, x28)) %>% \n  \n    # tekilleştir\n    distinct() %>% \n\n    # sütun ekle\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     \n\n    # sütun sınıfını değiştir\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %>% \n    \n    # sütun ekle: hastaneye yatışta gecikme\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% \n    \n    # hastane sütununun temiz değerleri\n    mutate(hospital = recode(hospital,\n                      # ESKİ = YENİ\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %>% \n    \n    mutate(hospital = replace_na(hospital, \"Missing\")) %>% \n\n    # age_years sütunu oluştur (age ve age_unit'ten)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age)) %>% \n  \n    # YUKARIDAKİ TEMİZLİK ADIMLARI ZATEN TARTIŞILMIŞTIR\n    ###################################################   \n    mutate(\n          # yaş kategorileri: özel\n          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),\n        \n          # yaş kategorileri: 0-85 arası, 5’erli\n          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5)))"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"satır-ekleme","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"8.10 Satır ekleme","text":"","code":""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"teker-teker","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Teker teker","text":"Satırları tek tek manuel olarak eklemek sıkıcıdır ancak dplyr’den add_row() ile yapılabilir. sütunun yalnızca bir sınıfın (karakter, sayısal, mantık vb.) değerlerini içermesi gerektiğini unutmayın. Bu yüzden bir satır eklemek, bunu korumak için dikkat gerektirir..ve .kullanın. Eklemek istediğiniz satırın yerleşimini belirtmek için .= 3, yeni satırı mevcut 3. satırın önüne koyacaktır. Varsayılan davranış, satırı sonuna eklemektir. Belirtilmeyen sütunlar boş bırakılacaktır (NA).Yeni satır numarası garip görünebilir (“…23”) ancak önceden var olan satırlardaki satır numaraları değişmiştir. Bu nedenle, komutu iki kez kullanıyorsanız, yerleştirmeyi dikkatlice inceleyin/test edin.Sağladığınız bir sınıf kapalıysa, aşağıdaki gibi bir hata görürsünüz:((tarih değerine sahip bir satır eklerken, tarihi .Date() fonksiyonuyla .Date(\"2021-12-31\") gibi eklemeyi unutmayın)).","code":"\nlinelist <- linelist %>% \n  add_row(row_num = 666,\n          case_id = \"abc\",\n          generation = 4,\n          `infection date` = as.Date(\"2020-10-10\"),\n          .before = 2)Error: Can't combine ..1$infection date <date> and ..2$infection date <character>."},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"satırların-bağlanması","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Satırların bağlanması","text":"Bir veri çerçevesinin satırlarını başka bir veri çerçevesinin altına bağlayarak veri kümelerini birleştirmek için dplyr’den bind_rows() öğesini kullanabilirsiniz. Bu yöntem, [Verileri birleştirme] sayfasında daha ayrıntılı olarak açıklanmaktadır.","code":""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"satırların-filtrelenmesi","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"8.11 Satırların filtrelenmesi","text":"Sütunları temizledikten ve değerleri yeniden kodladıktan sonra tipik bir temizleme adımı, dplyr filter() komutunu kullanarak belirli satırlar için veri çerçevesini filtrelemektir.filter() içinde, veri kümesindeki bir satırın tutulması için DOĞRU olması gereken mantık koşulunu belirtin. Aşağıda, basit ve karmaşık mantıksal koşullara dayalı olarak satırların nasıl filtreleneceğini gösteriyoruz.","code":""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"basit-filtre","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Basit Filtre","text":"Bu basit örnek, mantıksal bir koşulu karşılayacak satırları filtreleyerek veri çerçevesi satır listesini yeniden tanımlar. Yalnızca parantez içindeki mantıksal ifadenin DOĞRU olarak değerlendirildiği satırlar veri çerçevesinde tutulur.Bu örnekte, cinsiyet sütunundaki değerin “f”ye (büyük/küçük harf duyarlı) eşit olup olmadığını soran cinsiyet == “f” mantıksal ifadesi filtreleme için kullanılmıştır.Filtre uygulanmadan önce linelistteki satır sayısı nrow(linelist) ile gösterilir.Filtre uygulandıktan sonra, linelistteki satır sayısı linelist %>% filter(gender == “f”) %>% nrow().","code":"\nlinelist <- linelist %>% \n  filter(gender == \"f\")   # yalnızca cinsiyetin \"f\"ye eşit olduğu satırları tut"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"eksik-değerlerin-filtrelenmesi","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Eksik değerlerin filtrelenmesi","text":"Eksik değerlere sahip satırları filtrelemek oldukça yaygındır. filter(!.na(column) & !.na(column)) yerine bu amaç için özel olarak oluşturulmuş tidyr fonksiyonunu kullanın: drop_na(). Boş parantezlerle çalıştırılırsa, eksik değerleri olan satırları kaldırır. Alternatif olarak, eksik olup olmadığı değerlendirilecek belirli sütunların adlarını sağlayabilir veya yukarıda açıklanan “tidyselect” yardımcı fonksiyonlarını kullanabilirsiniz.Verilerinizdeki eksiklikleri analiz etmeye ve yönetmeye yönelik birçok teknik için Eksik veriler sayfasına bakın.","code":"\nlinelist %>% \n  drop_na(case_id, age_years)  # case_id veya age_years için eksik değerleri olan satırları bırak"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"satır-numarasına-göre-filtreleme","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Satır numarasına göre filtreleme","text":"Bir veri çerçevesinde veya tibble’da, satır genellikle (R Viewer’da görüldüğünde) ilk sütunun solunda görünen bir “satır numarasına” sahip olacaktır. Bu satır numarası veri çerçevesinde gerçek bir sütun değildir, ancak filter() ifadesinde kullanılabilir.“Satır numarasına” göre filtrelemek için, mantıksal filtreleme ifadesinin bir parçası olarak açık parantezlerle dplyr row_number() fonksiyonunu kullanabilirsiniz. Aşağıda gösterildiği gibi, genellikle %% operatörünü ve bir dizi sayıyı bu mantıksal ifadenin parçası olarak kullanacaksınız. İlk N satırı görmek için özel dplyr fonksiyonu head()’de kullanabilirsiniz.Ayrıca veri çerçevenize tibble fonksiyonu rownames_to_column() (parantez içine hiçbir şey koymayın) kullanarak satır numaralarını gerçek bir sütuna dönüştürebilirsiniz.","code":"\n# İlk 100 satırı gösterin\nlinelist %>% head(100)     # veya son n satırı görmek için tail() kullanın\n\n# sadece 5 satırı göster\nlinelist %>% filter(row_number() == 5)\n\n# satır 2'den 20'ye üç spesifik sütunu göster\nlinelist %>% filter(row_number() %in% 2:20) %>% select(date_onset, outcome, age)"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"karmaşık-filtre","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Karmaşık filtre","text":"Parantezler ( ), |, negate !, %% ve & operatörleri kullanılarak daha karmaşık mantıksal ifadeler oluşturulabilir. Bir örnek aşağıdadır:: Mantıksal bir kriteri reddetmek için ! operatörünü kullanabilirsiniz. Örneğin, !.na(column), sütun değeri eksik değilse doğru olarak değerlendirilir. Aynı şekilde !column %% c(“”, “b”, “c”), sütun değeri vektörde değilse doğru olarak değerlendirilir.","code":""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"verinin-incelenmesi","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Verinin incelenmesi","text":"Aşağıda, başlangıç tarihlerinin bir histogramını oluşturmak için basit bir tek satırlık komut verilmiştir. Bu ham veri kümesine 2012-2013 arasında ikinci bir daha küçük salgının da dahil edildiğini görün. Analizlerimiz için, bu önceki salgın girişlerini kaldırmak istiyoruz.","code":"\nhist(linelist$date_onset, breaks = 50)"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"eksik-sayısal-ve-tarih-verilerinin-filtrelenmesi","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Eksik sayısal ve tarih verilerinin filtrelenmesi","text":"Haziran 2013’ten sonraki satırlara date_onset’e göre filtre uygulayabilir miyiz? Dikkat! Kod filtresini uygulamak(date_onset > .Date(“2013-06-01”))) sonraki salgında başlangıç tarihi eksik olan tüm satırları kaldırır!UYARI: Bir tarih veya sayıdan büyük (>) veya küçük (<) olarak filtrelemek, eksik değerlere sahip satırları kaldırabilir (NA)! Bunun nedeni, NA’nın sonsuz büyük ve küçük olarak kabul edilmesidir.(Tarihlerle çalışma ve lubridate paketi hakkında daha fazla bilgi için Tarihlerle çalışma sayfasına bakın)","code":""},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"filtre-dizaynı","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Filtre Dizaynı","text":"Yalnızca istediğimiz doğru satırları hariç tuttuğumuzdan emin olmak için bir çapraz tabloyu inceleyin:İlk salgını (2012 ve 2013’te) veri kümesinden çıkarmak için başka hangi kriterleri filtreleyebiliriz? Şunu görüyoruz:• 2012 ve 2013 yıllarında ilk salgın Hastanesi ve B Hastanesi’nde meydana geldi ve ayrıca Liman Hastanesi’nde 10 vaka görüldü.• ve B hastanelerinde ikinci salgında vaka görülmedi ama Liman Hastanesinde görüldü.Dışlamak istediklerimiz:• nrow(linelist %>% filter(hospital %% c(“Hospital ”, “Hospital B”) | date_onset < .Date(“2013-06-01”))) • , B hastanesi veya Liman’da 2012 ve 2013’te başlayan sıralar:• nrow(linelist %>% filter(date_onset < .Date(“2013-06-01”))) 2012 ve 2013’te başlayan satırlar• Exclude nrow(linelist %>% filter(hospital %% c(‘Hospital ’, ‘Hospital B’) & .na(date_onset))) ve B Hastanelerinden başlangıç tarihleri eksik satırlar• Ancak nrow(linelist %>% filter(!hospital %% c(‘Hospital ’, ‘Hospital B’) & .na(date_onset))) eksik tarihli diğer satırlar dışlanmayacaknrow(linelist)` satır listesiyle başlıyoruz. Filtre ifademiz:Çapraz tabloyu yeniden yaptığımızda ve B Hastanelerinin tamamen kaldırıldığını; 2012 ve 2013 yıllarındaki 10 Liman Hastanesi vakasının kaldırıldığını ve diğer tüm değerlerin aynı - istediğimiz gibi - olduğunu görüyoruz.Bir filtre komutuna (virgülle ayrılmış) birden çok ifade dahil edilebilir veya kolaylık için zaman ayrı bir filter() komutuna yönlendirebilirsiniz.: Bazı okuyucular, hiçbir eksik değer olmadığında, yalnızca date_hospitalisation’göre filtrelemenin daha kolay olacağını fark edebilir. Bu doğrudur. Ancak date_onset, karmaşık bir filtreyi göstermek amacıyla kullanılmıştır.","code":"\ntable(Hospital  = linelist$hospital,                     # hastane ismi\n      YearOnset = lubridate::year(linelist$date_onset),  # date_onset yılı\n      useNA     = \"always\")                              # eksik verileri göster##                                       YearOnset\n## Hospital                               2012 2013 2014 2015 <NA>\n##   Central Hospital                        0    0  351   99   18\n##   Hospital A                            229   46    0    0   15\n##   Hospital B                            227   47    0    0   15\n##   Military Hospital                       0    0  676  200   34\n##   Missing                                 0    0 1117  318   77\n##   Other                                   0    0  684  177   46\n##   Port Hospital                           9    1 1372  347   75\n##   St. Mark's Maternity Hospital (SMMH)    0    0  322   93   13\n##   <NA>                                    0    0    0    0    0\nlinelist <- linelist %>% \n  # başlangıcın 1 Haziran 2013'ten sonra olduğu VEYA başlangıcın olmadığı ve Hastane A veya B'den DIŞINDA bir hastane olduğu satırları saklayın\n  filter(date_onset > as.Date(\"2013-06-01\") | (is.na(date_onset) & !hospital %in% c(\"Hospital A\", \"Hospital B\")))\n\nnrow(linelist)## [1] 6019\ntable(Hospital  = linelist$hospital,                     # hastane adı\n      YearOnset = lubridate::year(linelist$date_onset),  # date_onset yılı\n      useNA     = \"always\")                              # eksik değerleri göster##                                       YearOnset\n## Hospital                               2014 2015 <NA>\n##   Central Hospital                      351   99   18\n##   Military Hospital                     676  200   34\n##   Missing                              1117  318   77\n##   Other                                 684  177   46\n##   Port Hospital                        1372  347   75\n##   St. Mark's Maternity Hospital (SMMH)  322   93   13\n##   <NA>                                    0    0    0"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"bağımsız-standalone-1","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Bağımsız (Standalone)","text":"Filtreleme, bağımsız bir komut olarak da uygulanabilir (tünel zincirinin bir parçası değil). Diğer dplyr komutları gibi, bu durumda ilk argüman veri kümesinin kendisi olmalıdır.Korumak istediğiniz [satırları, sütunları] yansıtan köşeli parantezler kullanarak alt küme için temel R ’ı da kullanabilirsiniz.","code":"\n# dataframe <- filter(dataframe, condition(s) for rows to keep)\n\nlinelist <- filter(linelist, !is.na(case_id))\n# dataframe <- dataframe[row conditions, column conditions] (blank means keep all)\n\nlinelist <- linelist[!is.na(case_id), ]"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"kayıtların-hızla-gözden-geçirilmesi","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Kayıtların hızla gözden geçirilmesi","text":"Çoğu zaman, yalnızca birkaç sütun için birkaç kaydı hızlı bir şekilde gözden geçirmek istersiniz. Temel R fonksiyonu View(), RStudio’da görüntülemek için bir veri çerçevesi yazdıracaktır.RStudio’daki satır listesini görüntüleyin:Belirli hücreleri (belirli satırlar ve belirli sütunlar) görüntülemeye ilişkin iki örnek:dplyr fonksiyonları filter() ve select():View() içinde, veri çerçevesinde belirli satırları tutmak için veri kümesini filter() öğesine ve ardından belirli sütunları tutmak için select() öğesine yönlendirin. Örneğin, 3 spesifik vakanın başlangıç ve hastaneye yatış tarihlerini gözden geçirmek içinAynı sonucu, görmek istediğiniz alt küme için köşeli parantez [ ] kullanarak, temel R sintaksı ile elde edebilirsiniz.","code":"\nView(linelist)\nView(linelist %>%\n       filter(case_id %in% c(\"11f8ea\", \"76b97a\", \"47a5f5\")) %>%\n       select(date_onset, date_hospitalisation))\nView(linelist[linelist$case_id %in% c(\"11f8ea\", \"76b97a\", \"47a5f5\"), c(\"date_onset\", \"date_hospitalisation\")])"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"tünel-zincirine-ekleme-3","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"Tünel zincirine ekleme","text":"","code":"\n# TEMİZLİK 'TÜNEL' ZİNCİRİ (ham verilerle başlar ve temizleme adımları boyunca iletir)\n##################################################################################\n\n# tünel zincirini temizlemeye başla\n###########################\nlinelist <- linelist_raw %>%\n    \n    # sütun adı sintaksını standartlaştır\n    janitor::clean_names() %>% \n    \n    # sütunları manuel olarak yeniden adlandır\n           # ESKİ isim             # YENİ isim\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # sütunu sil\n    select(-c(row_num, merged_header, x28)) %>% \n  \n    # tekilleştir\n    distinct() %>% \n\n    # sütun ekle\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     \n\n    # sütun sınıfını değiştir\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %>% \n    \n    # sütun ekleme: yatışta gecikme\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% \n    \n    # hastane sütununun temiz değerleri\n    mutate(hospital = recode(hospital,\n                      # ESKİ = İSİM\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %>% \n    \n    mutate(hospital = replace_na(hospital, \"Missing\")) %>% \n\n    # age_years sütunu oluştur (age ve age_unit'ten)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age)) %>% \n  \n    mutate(\n          # yaş kategorileri: özel\n          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),\n        \n          # yaş kategorileri: 0-85 arası, 5’erli \n          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5))) %>% \n    \n    # YUKARIDAKİ TEMİZLİK ADIMLARI ZATEN TARTIŞILMIŞTIR\n    ###################################################\n    filter(\n          # sadece case_id'nin eksik olmadığı satırları tut\n          !is.na(case_id),  \n          \n          # ayrıca yalnızca ikinci salgını tutmak için filtreleyin\n          date_onset > as.Date(\"2013-06-01\") | (is.na(date_onset) & !hospital %in% c(\"Hospital A\", \"Hospital B\")))"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"satır-tabanlı-hesaplamalar","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"8.12 Satır tabanlı hesaplamalar","text":"Bir satır içinde bir hesaplama yapmak istiyorsanız, dplyr’den rowwise() fonksiyonuni kullanabilirsiniz. Satır bazında hesaplamalar için bu çevrimiçi gösterime bakabilirsiniz.Örneğin, bu kod rowwise() komutunu uygular ve ardından satır listesindeki satır için “evet” değerine sahip belirtilen semptom sütunlarının sayısını toplayan yeni bir sütun oluşturur. Sütunlar, bir c() vektörü içinde adlarıyla sum() içinde belirtilir. rowwise() aslında özel bir group_by() türüdür, bu nedenle işiniz bittiğinde ungroup() komutunu kullanmak en iyisidir [verileri gruplandırma sayfasınd].Değerlendirilecek sütunu belirlerken, bu sayfanın select() bölümünde açıklanan “tidyselect” yardımcı fonksiyonlarını kullanmak isteyebilirsiniz. Sadece bir ayarlama yapmanız gerekir (çünkü bunları select() veya summarise() gibi bir dplyr fonksiyonunda kullanmıyorsunuz).Sütun belirtim ölçütlerini dplyr fonksiyonu c_across() içine koyun. Bunun nedeni, c_across’un (belgeler) özellikle rowwise() ile çalışmak üzere tasarlanmış olmasıdır. Örneğin, aşağıdaki kod:• rowwise() uygular, böylece satırda aşağıdaki işlem (sum()) uygulanır (tüm sütunları toplamaz)\n• Yeni sütun num_NA_dates oluşturur, satır için .na() öğesinin DOĞRU olarak değerlendirildiği sütun sayısı tanımlanır.\n• sonraki adımlar için rowwise()’ın etkilerini kaldırmak için grubu çözmek gerekir ungroup()satır için en son veya en son tarihi almak için max() gibi başka fonksiyonlar da uygulayabilirsiniz:","code":"\nlinelist %>%\n  rowwise() %>%\n  mutate(num_symptoms = sum(c(fever, chills, cough, aches, vomit) == \"yes\")) %>% \n  ungroup() %>% \n  select(fever, chills, cough, aches, vomit, num_symptoms) # gösterim için## # A tibble: 5,888 × 6\n##    fever chills cough aches vomit num_symptoms\n##    <chr> <chr>  <chr> <chr> <chr>        <int>\n##  1 no    no     yes   no    yes              2\n##  2 <NA>  <NA>   <NA>  <NA>  <NA>            NA\n##  3 <NA>  <NA>   <NA>  <NA>  <NA>            NA\n##  4 no    no     no    no    no               0\n##  5 no    no     yes   no    yes              2\n##  6 no    no     yes   no    yes              2\n##  7 <NA>  <NA>   <NA>  <NA>  <NA>            NA\n##  8 no    no     yes   no    yes              2\n##  9 no    no     yes   no    yes              2\n## 10 no    no     yes   no    no               1\n## # … with 5,878 more rows\nlinelist %>%\n  rowwise() %>%\n  mutate(num_NA_dates = sum(is.na(c_across(contains(\"date\"))))) %>% \n  ungroup() %>% \n  select(num_NA_dates, contains(\"date\")) # gösterim için## # A tibble: 5,888 × 5\n##    num_NA_dates date_infection date_onset date_hospitalisation date_outcome\n##           <int> <date>         <date>     <date>               <date>      \n##  1            1 2014-05-08     2014-05-13 2014-05-15           NA          \n##  2            1 NA             2014-05-13 2014-05-14           2014-05-18  \n##  3            1 NA             2014-05-16 2014-05-18           2014-05-30  \n##  4            1 2014-05-04     2014-05-18 2014-05-20           NA          \n##  5            0 2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n##  6            0 2014-05-03     2014-05-22 2014-05-23           2014-05-24  \n##  7            0 2014-05-22     2014-05-27 2014-05-29           2014-06-01  \n##  8            0 2014-05-28     2014-06-02 2014-06-03           2014-06-07  \n##  9            1 NA             2014-06-05 2014-06-06           2014-06-18  \n## 10            1 NA             2014-06-05 2014-06-07           2014-06-09  \n## # … with 5,878 more rows\nlinelist %>%\n  rowwise() %>%\n  mutate(latest_date = max(c_across(contains(\"date\")), na.rm=T)) %>% \n  ungroup() %>% \n  select(latest_date, contains(\"date\"))  # gösterim için## # A tibble: 5,888 × 5\n##    latest_date date_infection date_onset date_hospitalisation date_outcome\n##    <date>      <date>         <date>     <date>               <date>      \n##  1 2014-05-15  2014-05-08     2014-05-13 2014-05-15           NA          \n##  2 2014-05-18  NA             2014-05-13 2014-05-14           2014-05-18  \n##  3 2014-05-30  NA             2014-05-16 2014-05-18           2014-05-30  \n##  4 2014-05-20  2014-05-04     2014-05-18 2014-05-20           NA          \n##  5 2014-05-29  2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n##  6 2014-05-24  2014-05-03     2014-05-22 2014-05-23           2014-05-24  \n##  7 2014-06-01  2014-05-22     2014-05-27 2014-05-29           2014-06-01  \n##  8 2014-06-07  2014-05-28     2014-06-02 2014-06-03           2014-06-07  \n##  9 2014-06-18  NA             2014-06-05 2014-06-06           2014-06-18  \n## 10 2014-06-09  NA             2014-06-05 2014-06-07           2014-06-09  \n## # … with 5,878 more rows"},{"path":"veri-temizliği-ve-temel-fonksiyonlar.html","id":"düzenle-ve-sıraya-diz","chapter":"8 Veri temizliği ve temel fonksiyonlar","heading":"8.13 Düzenle ve sıraya diz","text":"Satırları sütun değerlerine göre sıralamak veya sıralamak için dplyr fonksiyonu arrange()’kullanın.Sütunları gereken sırayla basit bir şekilde listeleyin. Sıralamanın önce verilere uygulanan herhangi bir gruplandırma tarafından yapılmasını istiyorsanız .by_group = argümanını DOĞRU belirtin (bkz. Verileri gruplama sayfası).Varsayılan olarak, sütun “artan” düzende sıralanır (sayısal ve ayrıca karakter sütunları için geçerlidir). Bir değişkeni desc() fonksiyonu ile sararak “azalan” düzende sıralayabilirsiniz.Verileri arrange () ile sıralamak, sunum için tablolar hazırlarken, grup başına “üst” satırları almak için slice() kullanırken veya görünüm sırasına göre faktör düzeyi sırasını ayarlarken özellikle yararlıdır.Örneğin, satır listesi satırlarımızı hastaneye göre, ardından azalan düzende date_onset’e göre sıralamak için şunu kullanırız:","code":"\nlinelist %>% \n   arrange(hospital, desc(date_onset))"},{"path":"tarihlerle-çalışma.html","id":"tarihlerle-çalışma","chapter":"9 Tarihlerle çalışma","heading":"9 Tarihlerle çalışma","text":"R’da tarihlerle çalışmak, diğer nesne sınıflarıyla kıyasla daha fazla dikkat etmeyi gerektirmektedir. Aşağıda, bu süreci daha az acı verici hale getirmek için bazı araçlar ve örnekler sunacağız Neyse ki, tarihler pratikle ve lubridate gibi bir dizi yardımcı paketle kolayca yönetilebilir.Ham veriler içe aktarıldığında R genellikle tarihleri karakter nesneleri olarak yorumlamaktadır - bu, zaman serilerini hazırlamak ve zaman aralıklarını hesaplamak gibi genel tarih işlemleri için kullanılamayacakları anlamına gelmektedir. İşleri daha da zorlaştırmak adına, bir tarihin biçimlendirilmesinin birden çok yolu vardır ve bunun için R’ın bir tarihin hangi bölümünün neyi temsil ettiğini (ay, gün, saat, vb.) bilmesine yardımcı olmalısınız.R’daki tarihler özgün nesne sınıflarıdır - ‘Date’ sınıfı. Bu sınıf ayrıca gün ve saat nesnelerini saklayan bir sınıftır. Tarih, saat nesneleri resmi olarak ‘POSIXt’, ‘POSIXct’ ve/veya ‘POSIXlt’ sınıfları olarak adlandırılır (aralarındaki fark önemli değildir). Bu nesnelere gayri resmi olarak datetime sınıfları denir.Bir sütun tarih içerdiğinde R’nin bunu tanımasını sağlamak önemlidir.Tarihler bir nesne sınıfıdır ve üzerinde çalışmak zor olabilir.Burada tarih sütunlarını Date sınıfına dönüştürmenin birkaç yolunu sunuyoruz.","code":""},{"path":"tarihlerle-çalışma.html","id":"hazırlık","chapter":"9 Tarihlerle çalışma","heading":"9.1 Hazırlık","text":"","code":""},{"path":"tarihlerle-çalışma.html","id":"paketleri-yüklemek","chapter":"9 Tarihlerle çalışma","heading":"Paketleri yüklemek","text":"Aşağıdaki kod parçası, bu sayfa için gerekli olan paketlerin yüklenmesini göstermektedir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() fonksiyonuna vurgulamaktayız. base R’dan library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakınız.","code":"\n# Paketin kurulu olup olmadığını kontrol eder, gerekirse kurar ve mevcut oturum için paketi yükler\n\npacman::p_load(\n  lubridate,  # tarihlerin işlenmesi ve dönüştürülmesi için genel paket \n  linelist,   # dağınık tarihleri \"tahmin etme\" işlevi sağlar\n  aweek,      # tarihleri haftalara ve haftaları tarihe dönüştürmek için alternatif bir seçenek\n  zoo,        # ek tarih/saat işlevleri\n  tidyverse,  # veri yönetimi ve görselleştirme \n  rio)        # veri içe/dışa aktarma"},{"path":"tarihlerle-çalışma.html","id":"verileri-içe-aktarma","chapter":"9 Tarihlerle çalışma","heading":"Verileri içe aktarma","text":"Simüle edilmiş bir Ebola salgını ile ilişkili vakaların veri setini içe aktarıyoruz. Adım adım izlenecek verileri indirmek istiyorsanız, [El kitabını ve verileri indir] sayfasındaki talimatlara bakınız. İlgili dosyaların çalışma dizininde olduğunu varsayıyoruz, bu nedenle bu dosya yolunda hiçbir alt klasör belirtilmemiştir.","code":"\nlinelist <- import(\"linelist_cleaned.xlsx\")"},{"path":"tarihlerle-çalışma.html","id":"güncel-tarih","chapter":"9 Tarihlerle çalışma","heading":"9.2 Güncel tarih","text":"base R ile aşağıdaki işlemleri tamamlayarak bilgisayarınızın güncel “sistem” tarihini veya sistem tarih saatini görebilirsiniz.lubridate paketi ile bu fonksiyonlar, sırasıyla ‘today()’ ve ‘now()’ ile de elde edilebilir. date(), haftanın günü ve ay adlarıyla birlikte geçerli tarih ve saati vermektedir.","code":"\n# sistem tarihini al - bu bir DATE sınıfıdır\nSys.Date()## [1] \"2022-11-20\"\n# sistem saatini al - bu bir DATETIME sınıfıdır\nSys.time()## [1] \"2022-11-20 16:20:50 CET\""},{"path":"tarihlerle-çalışma.html","id":"tarihe-dönüştürme","chapter":"9 Tarihlerle çalışma","heading":"9.3 Tarihe Dönüştürme","text":"Bir veri kümesini R’aktardıktan sonra, tarih sütunu değerleri “1989/12/30”, “05/06/2014” veya “13 Ocak 2020” gibi görünebilir. Bu durumlarda, R muhtemelen bu değerleri hala karakter değerleri olarak ele alıyordur. R’bu değerlerin tarih olduğu söylenmelidir - tarih formatının ne olduğu (hangi kısım Gün, hangisi Ay, hangisi Yıl vb.).Gerekli formatlar tanımlandığında, R bu değerleri Date sınıfına dönüştürür. Arka planda R, tarihleri sayı olarak saklayacaktır (“başlangıç” tarihi 1 Ocak 1970’den itibaren gün sayısı). Tarih numarasını büyük bir ihtimalle arayüzde ve hesaplamalarda kullanmayacaksınız, ancak bu, R’ın tarihleri sürekli değişkenler olarak ele almasına ve tarihler arasındaki mesafeyi hesaplama gibi özel işlemlerde kullanmasına izin verir.Varsayılan olarak, R’daki Date sınıfının değerleri YYYY-AA-GG olarak görüntülenmektedir. Bu bölümün ilerleyen kısımlarında, tarih değerlerinin görüntüsünün nasıl değiştirilebileceğini paylaşacağızAşağıda, bir sütunu karakter değerlerinden Date sınıfına dönüştürmek için iki yaklaşım sunmaktayız.İPUCU: Bir sütunun geçerli sınıfını base R fonksiyonu olan class() ile kontrol edebilirsiniz, örneğin class(linelist$date_onset).","code":""},{"path":"tarihlerle-çalışma.html","id":"base-r","chapter":"9 Tarihlerle çalışma","heading":"base R","text":".Date(), bir nesneyi veya sütunu Date sınıfına dönüştürmek için standart, temel R fonksiyonudur. (“D” harfinin büyük harf kullanımına dikkat ediniz)..Date() kullanımı aşağıdaki koşulları içermektedir:Ham karakter tarihinin mevcut formatını veya tarihleri sayı olarak veriyorsanız başlangıç tarihini belirtirmelisiniz (Excel tarihleriyle ilgili bölüme bakınız)Eğer bir karakter sütununda kullanılıyorsa, tüm tarih değerleri aynı formata sahip olmalıdır (eğer durum böyle değilse, linelist paketinden guess_dates() deneyebilirsiniz)İlk olarak, sütununuzun sınıfını base R’den class() fonksiyonu ile kontrol edin. Verilerinizin sınıfı hakkında emin değilseniz veya kafanız karıştıysa (örneğin, “POSIXct” vs. görüyorsanız) ilk adım olarak formatı sıfırlamak kolay bir strateji olabilir. Bunun için sütunu .character() fonksiyonu ile Karakter sınıfına ve ardından onu Date sınıfına dönüştürebilirsiniz.İkinci olarak, ‘.Date()’ fonksiyonu içinde, R’karakter tarih bileşenlerinin geçerli biçimini - hangi karakterlerin ay, gün ve yılı ifade ettiğini ve bunların nasıl ayrıldığını belirtmek için ‘format =’ bağımsız değişkenini kullanabilirsiniz. Değerleriniz zaten R’ın standart tarih biçimlerinden (“YYYY-AA-GG” veya “YYYY/AA/GG”) biriyse, “format =” bağımsız değişkeni gerekli değildir.format = için, aşağıdaki özel “strptime” kısaltmalarını kullanarak geçerli tarih biçimini temsil eden bir karakter dizisi (tırnak içinde) sağlamalısınız. Örneğin, karakter tarihleriniz şu anda “24/04/1968” gibi “GG/AA/YYYY” biçimindeyse, o zaman karakteri dönüştürmek için format = \"%d/%m/%Y\" kullanabilirsiniz. İlgili değerler tarihlere dönüştürülecektir. Formatı tırnak içine almanız gerekmektedir. Eğik çizgi veya kısa çizgileri de eklemeyi unutmayın!strptime kısaltmalarının çoğu aşağıda listelenmiştir. ?strptime komutunu çalıştırarak tam listeyi görebilirsiniz.%d = Aydaki gün (5, 17, 28, vb.)\n%j = Yıl-gün numarası (Julian günü 001-366)\n%= Kısaltılmış gün (Pt, sa, Çar, vb.)\n%= Tam gün (Pazartesi, Salı, vb.)\n%w = Gün sırası (0-6, Pazar 0’dır)\n%u = Gün sırası (1-7, Pazartesi 1’dir)\n%W = Hafta sırası (00-53, Pazartesi haftanın ilk günüdür)\n%U = Hafta sırası (01-53, Pazar haftanın ilk günüdür)\n%m = Ay sırası (örn. 01, 02, 03, 04)\n%b = Kısaltılmış ay (Oca, Şub, vb.)\n%B = Tam ay (Ocak, Şubat, vb.)\n%y = 2-basamak yıl (örn. 89)\n%Y = 4-basamak yıl (örn. 1989)\n%h = saat (24-saat)\n%m = dakika\n%s = saniye\n%z = GMT farkı\n%Z = Saat dilimi (karakter)İPUCU: ‘.Date()’ fonksiyonun ‘format =’ argümanı, R’tarihlerin olmasını istediğiniz biçimi söylemez, bunun yerine tarih bölümlerini siz komutu çalıştırmadan önce oldukları gibi nasıl tanımlayacağınızı söyler.İPUCU: “format =” bağımsız değişkeninde tarihlerinizde bulunan tarih-ayracı (ör. /, - veya boşluk) kullandığınızdan emin olun.Değerler Date sınıfında olduğunda, R varsayılan olarak bunları YYYY-AA-GG olan standart biçimde görüntüler.","code":"\n# Date sınıfına çevir\nlinelist <- linelist %>% \n  mutate(date_onset = as.Date(date_of_onset, format = \"%d/%m/%Y\"))"},{"path":"tarihlerle-çalışma.html","id":"lubridate","chapter":"9 Tarihlerle çalışma","heading":"lubridate","text":"lubridate paketi kullanılarak karakter nesnelerinin tarihlere dönüştürülmesi daha kolay hale getirilebilir. Bu, tarih ve saatlerle çalışmayı base R’dan daha basit ve tutarlı hale getirmek için tasarlanmış bir tidyverse paketidir. lubridate genellikle tarihler ve saatler için altın standart paket olarak kabul edilmektedir. Tarih hesaplamalarında bu paketle çalışmanızı tavsiye etmekteyiz.lubridate paketi, karakter nesnelerini ‘.Date()’ biçiminde belirtmekten daha kolaydır. Paket tarihleri dönüştürmek için tasarlanmış birkaç farklı yardımcı fonksiyon sağlamaktadır. Bu fonksiyonlar çoğunlukla, kaba tarih biçimine özgüdür. Ancak tarihler için çeşitli ayırıcılara ve eş anlamlı tabirlerin kullanılmasına izin verir (ör. 01 - Oca - Ocak) - bunlar, tarih biçimlerinin kısaltmalarından sonra tanımlanır.‘ymd()’ fonksiyonu, yıl, sonra ay, sonra gün olarak sağlanan tarih değerlerini esnek bir şekilde dönüştürür.mdy() fonksiyonu, ay, sonra gün, sonra yıl olarak sağlanan tarih değerlerini esnek bir şekilde dönüştürür.dmy() fonksiyonu, gün, sonra ay, sonra yıl olarak sağlanan tarih değerlerini esnek bir şekilde dönüştürür.Tünelleme kullanılıyorsa, bir karakter sütununun lubridate ile tarihlere dönüştürülmesi şöyle görünebilir:İşlemler tamamlandığında, sütunun sınıfını doğrulamak için class() komutunu çalıştırabilirsiniz.Değerler Date sınıfında olduğunda, R varsayılan olarak bunları YYYY-AA-GG olan standart biçimde görüntüler.Yukarıdaki fonksiyonların 4 basamaklı yıllarda en verimli şekilde çalıştığını unutmayın. lubridate yüzyılı tahmin etmeye çalıştığı için 2 basamaklı yıllar beklenmedik sonuçlar üretebilmektedir.2 basamaklı bir yılı 4 basamaklı bir yıla dönüştürmek için (tümü aynı yüzyılda) sınıf karakterine dönüştürebilir ve ardından stringr paketinden (bkz. Karakterler ve dizeler) str_glue() fonksiyonu kullanarak mevcut rakamları bir ön ek ile birleştirebilirsiniz. Ardından tarihe dönüştürebilirsiniz.","code":"\n# lubridate paketini indirip/yükler \npacman::p_load(lubridate)\n# tarihi yıl-ay-gün biçiminde okur\nymd(\"2020-10-11\")## [1] \"2020-10-11\"\nymd(\"20201011\")## [1] \"2020-10-11\"\n# tarihi ay-gün-yıl biçiminde okur\nmdy(\"10/11/2020\")## [1] \"2020-10-11\"\nmdy(\"Oct 11 20\")## [1] \"2020-10-11\"\n# tarihi gün-ay-yıl biçiminde okur\ndmy(\"11 10 2020\")## [1] \"2020-10-11\"\ndmy(\"11 October 2020\")## [1] \"2020-10-11\"\nlinelist <- linelist %>%\n  mutate(date_onset = lubridate::dmy(date_onset))\n# Sütunun sınıfını kontrol edin\nclass(linelist$date_onset)  \ntwo_digit_years <- c(\"15\", \"15\", \"16\", \"17\")\nstr_glue(\"20{two_digit_years}\")## 2015\n## 2015\n## 2016\n## 2017"},{"path":"tarihlerle-çalışma.html","id":"sütunları-birleştirme","chapter":"9 Tarihlerle çalışma","heading":"Sütunları birleştirme","text":"Birden çok sütunu tek bir tarih sütununda birleştirmek için make_date() ve make_datetime() lubridate fonksiyonlarını kullanabilirsiniz. Örneğin, “linelist” veri formatında onset_day, onset_month ve onset_year sütunlarınız mevcutsa:","code":"\nlinelist <- linelist %>% \n  mutate(onset_date = make_date(year = onset_year, month = onset_month, day = onset_day))"},{"path":"tarihlerle-çalışma.html","id":"excel-tarihleri","chapter":"9 Tarihlerle çalışma","heading":"9.4 Excel tarihleri","text":"Arka planda, çoğu yazılım, tarihleri sayı olarak kaydeder. R 1 Ocak 1970 tarihini başlangıç tarihi olarak ele almaktadır. Bu nedenle, .numeric(.Date(\"1970-01-01)) komutunu çalıştırırsanız 0 sonucunu elde edersiniz.Microsoft Excel, işletim sisteminize bağlı olarak 30 Aralık 1899 (Windows) veya 1 Ocak 1904 (Mac) tarihleri başlangıç tarihi olarak depolamaktadır. Detaylar için Microsoft rehberini inceleyebilirsiniz.Excel tarihleri genellikle R’karakter yerine sayısal değerler olarak aktarılmaktadır. Excel’den içe aktardığınız veri kümesi, tarihleri sayı veya “41369” gibi karakterler olarak gösteriyorsa bunları istenilen formata dönüştürmek için .Date() (veya lubridate’nin as_date() işlevini) kullanabilirsiniz. Ancak yukarıdaki gibi bir “formatı” tanımlamak yerine, origin = argümanıyla Excel başlangıç tarihini R’bildirebilirsiniz.Excel tarihi bir Karakter türü olarak R’aktarılmışsa bu fonksiyon işe yaramaz, bu nedenle sayının Numeric sınıfında olduğundan emin olun!: Başlangıç tarihini R’ın varsayılan tarih biçiminde (“YYYY-AA-GG”) formatlamalısınız.","code":"\n# Exceldeki sayı formatındaki tarihleri dönüştürürken Excel 'başlangıç tarihi' sağlamaya ilişkin bir örnek\ndata_cleaned <- data %>% \n  mutate(date_onset = as.numeric(date_onset)) %>%   # sınıfın numeric olduğundan emin olun\n  mutate(date_onset = as.Date(date_onset, origin = \"1899-12-30\")) # Excel orijinini kullanarak tarih formatına dönüştürme"},{"path":"tarihlerle-çalışma.html","id":"karışık-tarihler","chapter":"9 Tarihlerle çalışma","heading":"9.5 Karışık tarihler","text":"parsedate paketindeki parse_dates() fonksiyonu, birçok farklı biçimde tarihleri içeren “dağınık” bir tarih sütununu okumaya ve tarihleri standart bir biçime dönüştürmeye çalışır. parse_date() hakkında daha fazla bilgiyi için bakınız.Örneğin, parse_dates(), “03 Oca 2018”, “07/03/1982” ve “08/20/85” karakter tarihlerinin bir vektörünü görür ve bunları Date sınıfına dönüştürür: ‘2018-01-03’, ‘1982-03-07’ ve ‘1985-08-20’.","code":"\nparsedate::parse_date(c(\"03 Janry 18\",\n                        \"07/03/1982\",\n                        \"8-20-1985\"))## [1] \"2018-01-03 UTC\" \"1982-07-03 UTC\" \"1985-08-20 UTC\"\n# dater_onset sütununda parse_date() kullanan bir örnek\nlinelist <- linelist %>%      \n  mutate(date_onset = parse_date(date_onset))"},{"path":"tarihlerle-çalışma.html","id":"date-time-sınıfı-ile-çalışma","chapter":"9 Tarihlerle çalışma","heading":"9.6 Date-time sınıfı ile çalışma","text":"Daha önce belirtildiği gibi, R ek olarak datetime sınıfını desteklemektedir - tarih ve saat bilgilerini içeren bir sütun. “Date” sınıfında olduğu gibi, bu verilerin genellikle karakter nesnelerinden datetime nesnelerine dönüştürülmesi gerekmektedir.","code":""},{"path":"tarihlerle-çalışma.html","id":"tarihleri-saatlerle-dönüştürme","chapter":"9 Tarihlerle çalışma","heading":"Tarihleri saatlerle dönüştürme","text":"Standart bir “datetime” nesnesi önce tarihle, ardından bir saat bileşeniyle biçimlendirilir - örneğin 01 Ocak 2020, 16:30. Tarihlerde olduğu gibi, bun durumun biçimlendirilmesinin ve kesinlik düzeyinin (saat, dakika, saniye) tanımlanmasının bir çok yolu mevcuttur.Neyse ki, bu dizeleri ‘datetime’ nesnelerine dönüştürmeye yardımcı olmak için lubridate paketinin yardımcı fonksiyonları mevcuttur. Bu fonksiyonların, sonuna “_h” (saati tanımlar), “_hm” (saat ve dakikayı tanımlar) veya “_hms” (saat, dakika ve saniyeyi tanımlar) uzantıları eklenebilir (örn. dmy_hms()`). Aşağıda bu uzantıların kullanımı için örnekler verilmiştir.Yalnızca saat bilgisi olan datetime verilerini datetime nesnesine dönüştürme:Saat ve dakika bilgisi olan datetime verilerini datetime nesnesine dönüştürme:Saat, dakika ve saniye bilgisi olan datetime verilerini datetime nesnesine dönüştürme:Saat dilimini formata ekleyebilirsiniz ancak bu bilgi yok sayılmaktadır. Daha detaylı bilgi için ilerleyen bölümlerdeki saat dilimleri bölümüne bakınız.Bir veri çerçevesiyle çalışırken, stringr paketinden str_glue() fonksiyonu ve uygun bir lubridate fonksiyonu kullanılarak saat ve tarih sütunları birleştirilebilir. stringr ile ilgili ayrıntılar için Karakterler ve dizeler hakkındaki sayfaya bakınız.Bu örnekte, “linelist” veri çerçevesi “saat:dakika” biçiminde bir sütuna sahiptir. Bunu bir datetime formatına dönüştürmek için aşağıdaki adımları izleyebiliriz:Eksik verileri medyan sütunlarından elde edilen verilerle tamamlanmış, “temiz” bir hasta kabul sütunu oluşturun. Bunu yapıyoruz çünkü lubridate eksik değerler üzerinde çalışmayacaktır. Bunu “date_hospitalisation” sütunuyla birleştirin ve ardından istenilen formata dönüştürmek için “ymd_hm()” işlevini kullanın.","code":"\nymd_h(\"2020-01-01 16hrs\")## [1] \"2020-01-01 16:00:00 UTC\"\nymd_h(\"2020-01-01 4PM\")## [1] \"2020-01-01 16:00:00 UTC\"\ndmy_hm(\"01 January 2020 16:20\")## [1] \"2020-01-01 16:20:00 UTC\"\nmdy_hms(\"01 January 2020, 16:20:40\")## [1] \"2020-01-20 16:20:40 UTC\"\nmdy_hms(\"01 January 2020, 16:20:40 PST\")## [1] \"2020-01-20 16:20:40 UTC\"# paketler\npacman::p_load(tidyverse, lubridate, stringr)\n\n# time_admission, saat:dakika cinsinden bir sütundur\nlinelist <- linelist %>%\n  \n  # uygun saat bulunamadığında, medyan kabul süresini atama\n  mutate(\n    time_admission_clean = ifelse(\n      is.na(time_admission),         # zaman eksikse\n      median(time_admission),        # medyan ata\n      time_admission                 # eksik değilse olduğu gibi tut\n  ) %>%\n  \n    # bir karakter sütunu oluşturmak üzere tarih ve saat sütunlarını birleştirmek için str_glue() fonksiyonunu kullanın\n    # ve sonra onu tarih saatine dönüştürmek için ymd_hm() fonksiyonunu kullanın\n  mutate(\n    date_time_of_admission = str_glue(\"{date_hospitalisation} {time_admission_clean}\") %>% \n      ymd_hm()\n  )"},{"path":"tarihlerle-çalışma.html","id":"sadece-saatleri-çevirme","chapter":"9 Tarihlerle çalışma","heading":"Sadece saatleri çevirme","text":"Verileriniz yalnızca bir karakter süresi (saat ve dakika) içeriyorsa, base R’dan strptime() kullanarak bunları zaman formatına dönüştürebilir ve değiştirebilirsiniz. Örneğin, bu iki süre arasındaki farkı elde etmek için:Bununla birlikte, herhangi bir tarih değerine ulaşılamazsa, tarihin bugün olduğunu varsayıldığını unutmayın. Bir tarih harf dizisini ve bir zamanı harf dizisiyle birleştirmek için, hemen yukarıdaki bölümde stringr’nin nasıl kullanılacağına bakınız. strptime() hakkında daha fazla bilgiyi buradan okuyabilirsiniz.Tek basamaklı sayıları çift basamaklı sayılara dönüştürmek için (ör. 2 basamak elde etmek için baştaki sıfırlarla birlikte saat veya dakika formatına), Karakterler ve dizeler sayfasının “Taban uzunluğu” bölümüne bakınız.","code":"\n# ham karakter süreleri\ntime1 <- \"13:45\" \ntime2 <- \"15:20\"\n\n# Datetime sınıfına dönüştürülen zamanlar\ntime1_clean <- strptime(time1, format = \"%H:%M\")\ntime2_clean <- strptime(time2, format = \"%H:%M\")\n\n# Fark, varsayılan olarak \"difftime\" sınıfındadır, burada sayısal saatlere dönüştürülür\nas.numeric(time2_clean - time1_clean)   # saat farkı## [1] 1.583333"},{"path":"tarihlerle-çalışma.html","id":"saati-ayıklama","chapter":"9 Tarihlerle çalışma","heading":"Saati ayıklama","text":"Bir zamanın alt öğelerini lubridate’paketinden ‘hour()’, ‘minute()’ veya ‘second()’ fonksiyonu ile seçebilirsiniz.Saatin ayıklanması ve ardından günün bölümlerine göre sınıflandırılmasına bir örnek verilmesi gerekirse: “SS:DD” biçimindeki Karakter sınıfı olan time_admission sütununu göz önüne alalım. İlk olarak, karakterleri datetime sınıfına dönüştürmek için yukarıda açıklandığı gibi strptime() fonksiyonu kullanılır. Daha sonra saat, 0-24 arasında bir sayı döndürerek hour() fonksiyonu ile çıkarılır. Son olarak, satırları giriş saatlerine göre Sabah/Öğleden sonra/Akşam/Gece olarak sınıflandırmak için case_while() mantığı kullanılarak bir ‘time_period’ sütunu oluşturulur.case_while() hakkında daha fazla bilgi edinmek için [Temizleme verileri ve temel işlevler] hakkındaki sayfaya bakınız.","code":"\nlinelist <- linelist %>%\n  mutate(hour_admit = hour(strptime(time_admission, format = \"%H:%M\"))) %>%\n  mutate(time_period = case_when(\n    hour_admit > 06 & hour_admit < 12 ~ \"Morning\",\n    hour_admit >= 12 & hour_admit < 17 ~ \"Afternoon\",\n    hour_admit >= 17 & hour_admit < 21 ~ \"Evening\",\n    hour_admit >=21 | hour_admit <= 6 ~ \"Night\"))"},{"path":"tarihlerle-çalışma.html","id":"tarihlerle-çalışma-1","chapter":"9 Tarihlerle çalışma","heading":"9.7 Tarihlerle çalışma","text":"lubridate aynı zamanda date/datetime özelliklerini çıkarma, tarih aritmetiği gerçekleştirme veya tarih aralıklarını hesaplama gibi çeşitli başka işlevler için de kullanılabilir.Burada örnekler için kullanılacak bir tarih tanımlayacağız:","code":"\n# Date sınıfının nesnesini oluşturma\nexample_date <- ymd(\"2020-03-01\")"},{"path":"tarihlerle-çalışma.html","id":"tarih-bileşenlerini-ayıklama","chapter":"9 Tarihlerle çalışma","heading":"Tarih bileşenlerini ayıklama","text":"Ay, gün, hafta içi gibi ortak yönleri çıkarabilirsiniz:Ayrıca bir datetime nesnesinden veya sütunundan saat bileşenlerini de çıkarabilirsiniz. Bu durum, özellikle başvuru saatlerinin dağılımını görmek istiyorsanız yararlı olabilir.Hafta bilgilerini ayıklamak için birkaç seçenek vardır. Aşağıdaki Epidemiyolojik haftalar bölümüne bakın.Bir tarihi belirli bir şekilde görüntülemek istiyorsanız (örneğin, “Ocak 2020” veya “20 Mart Perşembe” veya “20. Hafta, 1977”) bunu Tarihi görüntüleme bölümünde açıklandığı gibi daha esnek bir şekilde yapabilirsiniz.","code":"\nmonth(example_date)  # ay numarası## [1] 3\nday(example_date)    # ayın günü (sayı)## [1] 1\nwday(example_date)   # haftanın gün sayısı (1-7)## [1] 1\nexample_datetime <- ymd_hm(\"2020-03-01 14:45\")\n\nhour(example_datetime)     # saati ayıklama\nminute(example_datetime)   # dakikayı ayıklama\nsecond(example_datetime)   # saniyeyi ayıklama"},{"path":"tarihlerle-çalışma.html","id":"tarih-matematiği","chapter":"9 Tarihlerle çalışma","heading":"Tarih matematiği","text":"lubridate’deki ilgili fonksiyonları kullanarak belirli sayıda gün veya hafta ekleyebilirsiniz.","code":"\n# bu tarihe 3 gün ekleyin\nexample_date + days(3)## [1] \"2020-03-04\"\n# 7 hafta ekleyin ve bu tarihten iki gün çıkarın\nexample_date + weeks(7) - days(2)## [1] \"2020-04-17\""},{"path":"tarihlerle-çalışma.html","id":"tarih-aralıkları","chapter":"9 Tarihlerle çalışma","heading":"Tarih aralıkları","text":"Tarihler arasındaki fark şu şekilde hesaplanabilir:iki tarihin de Date sınıfına ait olduğundan emin olunİki tarih arasındaki “zaman farkını (difftime)” elde etmek için çıkarma işlemini kullanınGerekirse, sonraki matematiksel hesaplamaları yapmak için sonucu sayısal sınıfa dönüştürünAşağıdaki kodda iki tarih arasındaki aralığın hesaplanması ve görüntülenmesi verilmiştir. Date sınıfındaki değerlerde çıkarma (eksi) işareti ile aralıkları bulabilirsiniz. Ancak, döndürülen değerin sınıfının aşağıda gösterildiği gibi “difftime” olduğunu ve sayısala dönüştürülmesi gerektiğini unutmayın.Bir “difftime” üzerinde sonraki işlemleri yapmak için, onu .numeric() ile sayısal değere dönüştürmelisiniz.Bunların hepsi verilerle çalışmak için bir araya getirilebilir - örneğin:Bir veri çerçevesi bağlamında, yukarıdaki tarihlerden biri eksikse, o satır için işlem başarısız olur. Sonuç, sayısal bir değer yerine bir “NA” olarak verilecektir. Bu sütunu hesaplamalar için kullanırken, na.rm = bağımsız değişkenini TRUE (DOĞRU) olarak ayarladığınızdan emin olun. Örneğin:","code":"\n# bu tarih ile 20 Şubat 2020 arasındaki aralığı bulun\noutput <- example_date - ymd(\"2020-02-20\")\noutput    # yazdır## Time difference of 10 days\nclass(output)## [1] \"difftime\"\npacman::p_load(lubridate, tidyverse)   # paketleri yükleme\n\nlinelist <- linelist %>%\n  \n  # dmy biçimini belirterek başlangıç tarihini, karakterden tarih nesnelerine dönüştürün\n  mutate(date_onset = dmy(date_onset),\n         date_hospitalisation = dmy(date_hospitalisation)) %>%\n  \n  # Mart ayında başlamayan tüm vakaları filtreleyin\n  filter(month(date_onset) == 3) %>%\n    \n  # başlangıç ve hastaneye yatış arasındaki gün farkını bulun\n  mutate(days_onset_to_hosp = date_hospitalisation - date_of_onset)\n# verilerin mevcut olduğu tüm vakalar için; hastaneye yatışa kadar geçen medyan gün sayısını hesaplama\nmedian(linelist_delay$days_onset_to_hosp, na.rm = T)"},{"path":"tarihlerle-çalışma.html","id":"tarihi-gösterme","chapter":"9 Tarihlerle çalışma","heading":"9.8 Tarihi gösterme","text":"Tarihler doğru sınıfta formatlandığında; farklı şekilde görüntülenmelerini isteyebilir (örneğin “2018-01-05” yerine “05 Ocak Pazartesi”), satırları tarih öğelerine göre gruplandırabilir (örneğin ay-yıla göre gruplandırma) gösterilme sırasını istediğiniz gibi düzenleyebilirsiniz.","code":""},{"path":"tarihlerle-çalışma.html","id":"format","chapter":"9 Tarihlerle çalışma","heading":"format()","text":"Tarih gösterimini base R fonksiyonu olan format() ile ayarlayabilirsiniz. Bu fonksiyon, “%” strptime kısaltmalarında istenen çıktı biçimini belirten bir karakter dizesini (tırnak içinde) argüman olarak kabul etmektedir.- (.Date() içinde kullanılanla benzer sözdizimi). Aşağıda yaygın olarak kullanılan kısaltmaların çoğu verilmiştir.: format() fonksiyonunu kullanmak değerleri Karakter sınıfına dönüştürür, bu nedenle bu genellikle bir analizin sonuna doğru veya yalnızca görüntüleme amacıyla kullanılır! ?strptime komutunu çalıştırarak tam listeyi görebilirsiniz.%d = Aydaki gün (5, 17, 28, vb.)\n%j = Yıl-gün numarası (Julian günü 001-366)\n%= Kısaltılmış gün (Pt, sa, Çar, vb.)\n%= Tam gün (Pazartesi, Salı, vb.)\n%w = Gün sırası (0-6, Pazar 0’dır)\n%u = Gün sırası (1-7, Pazartesi 1’dir)\n%W = Hafta sırası (00-53, Pazartesi haftanın ilk günüdür)\n%U = Hafta sırası (01-53, Pazar haftanın ilk günüdür)\n%m = Ay sırası (örn. 01, 02, 03, 04)\n%b = Kısaltılmış ay (Oca, Şub, vb.)\n%B = Tam ay (Ocak, Şubat, vb.)\n%y = 2-basamak yıl (örn. 89)\n%Y = 4-basamak yıl (örn. 1989)\n%h = saat (24-saat)\n%m = dakika\n%s = saniye\n%z = GMT farkı\n%Z = Saat dilimi (karakter)Bugünün tarihini biçimlendirmeye bir örnek olarak:str_glue() fonksiyonunu kullanıyorsanız, sözdizimi formatındaki çift tırnak içinde (“) yalnızca tek tırnak kullanmanız gerektiğini unutmayın (yukarıdaki örnekte verildiği gibi).","code":"\n# bugünün tarihi, biçimlendirme ile\nformat(Sys.Date(), format = \"%d %B %Y\")## [1] \"20 November 2022\"\n# tam tarih ve saati almanın kolay yolu (varsayılan biçimlendirme)\ndate()## [1] \"Sun Nov 20 16:20:51 2022\"\n# str_glue() fonksiyonunu kullanarak biçimlendirilmiş birleşik tarih, saat ve saat dilimi\nstr_glue(\"{format(Sys.Date(), format = '%A, %B %d %Y, %z  %Z, ')}{format(Sys.time(), format = '%H:%M:%S')}\")## Sunday, November 20 2022, +0000  UTC, 16:20:51\n# Haftaları görüntüleme formatını kullanma\nformat(Sys.Date(), \"%Y Week %W\")## [1] \"2022 Week 46\""},{"path":"tarihlerle-çalışma.html","id":"ay-yıl","chapter":"9 Tarihlerle çalışma","heading":"Ay-Yıl","text":"Bir Date sütununu Ay-yıl biçimine dönüştürmek için, zoo paketindeki .yearmon() işlevini kullanmanızı öneririz. Bu, tarihi “yearmon” sınıfına dönüştürür ve uygun sıralamayı korur. Buna karşılık, format(column, \"%Y %B\") fonksiyonunun kullanılması, değerleri Karakter sınıfına dönüştürecek ve değerleri alfabetik olarak (yanlış) sıralayacaktır.Aşağıda, “.yearmon()” fonksiyonu kullanılarak “date_onset” sütunundan yeni bir “yearmonth” sütunu oluşturulmuştur. Elde edilen değerlerin varsayılan (doğru) sıralaması tabloda gösterilmiştir.Buna karşılık, aşağıdaki örnekte, format() fonksiyonu ile istenen görüntüleme biçimini verirken, ancak doğru sıralamayı nasıl sağlayamadığını görebilirsiniz.: Bir ggplot() içinde çalışıyor ve sadece tarihlerin nasıl görüntülendiğini düzenlemek istiyorsanız, scale_x_date() fonksiyonu içindeki date_labels = argümanına bir strptime formatı sağlamak yeterli olabilir. Bunun için \"%b %Y\" veya \"%Y %b\" formatını kullanabilirsiniz. Detaylı bilgi için ggplot ipuçları sayfasına bakınız.zoo ayrıca .yearqtr() fonksiyonuna da sahiptir ve ggplot() kullanırken scale_x_yearmon() fonksiyonunu da bu amaçla kullanabilirsiniz.","code":"\n# yeni sütun oluştur\ntest_zoo <- linelist %>% \n     mutate(yearmonth = zoo::as.yearmon(date_onset))\n\n# tabloyu yazdır\ntable(test_zoo$yearmon)## \n## Apr 2014 May 2014 Jun 2014 Jul 2014 Aug 2014 Sep 2014 Oct 2014 Nov 2014 Dec 2014 Jan 2015 Feb 2015 Mar 2015 Apr 2015 \n##        7       64      100      226      528     1070     1112      763      562      431      306      277      186\n# yeni sütun oluştur\ntest_format <- linelist %>% \n     mutate(yearmonth = format(date_onset, \"%b %Y\"))\n\n# tabloyu yazdır\ntable(test_format$yearmon)## \n## Apr 2014 Apr 2015 Aug 2014 Dec 2014 Feb 2015 Jan 2015 Jul 2014 Jun 2014 Mar 2015 May 2014 Nov 2014 Oct 2014 Sep 2014 \n##        7      186      528      562      306      431      226      100      277       64      763     1112     1070"},{"path":"tarihlerle-çalışma.html","id":"dates_epi_wks","chapter":"9 Tarihlerle çalışma","heading":"9.9 Epidemiyolojik haftalar","text":"","code":""},{"path":"tarihlerle-çalışma.html","id":"lubridate-1","chapter":"9 Tarihlerle çalışma","heading":"lubridate","text":"Verileri tarihlerine göre gruplandırmaya ilişkin daha kapsamlı örnekler için [Gruplama verileri] hakkındaki sayfaya bakınız. Aşağıda, verileri haftalara göre gruplandırmayı kısaca açıklamaktayız.Genellikle, lubridate paketindeki floor_date() fonksiyonunu, unit = \"week\" bağımsız değişkeniyle kullanmanızı önermekteyiz. Bu, week_start = bağımsız değişkeniyle tanımlandığı gibi tarihi haftanın “başlangıcına” yuvarlar. Varsayılan hafta başlangıcı 1’dir (Pazartesiler için), ancak haftanın herhangi bir gününü başlangıç olarak belirtebilirsiniz (ör. Pazar günleri için 7). “floor_date()” çok yönlü bir fonksiyondur; unit = öğesini “saniye (second)”, “dakika (minute)”, “saat (hour)”, “gün (day)”, “ay (month)” veya “yıl (year)” olarak ayarlayarak diğer zaman birimlerine yuvarlamak için kullanılabilir.Döndürülen değer, Date sınıfında haftanın başlangıç tarihidir. Date sınıfı, ggplot() tarafından kolayca tanınacağı ve doğru şekilde sıralanacağı için verileri çizerken de gayet kolaylık sağlamaktadır.Tarihleri bir grafikte yalnızca haftasına göre görüntülemek ile ilgileniyorsanız, bu sayfadaki Tarihi görüntüleme bölümüne bakınız. Örneğin, bir epicurve çizerken, istenen strptime “%” terminolojisini sağlayarak tarih görüntüsünü biçimlendirebilirsiniz. Örneğin, yıl ve hafta numarasını döndürmek için “%Y-%W” veya “%Y-%U” kullanabilirsiniz (sırasıyla Pazartesi veya Pazar haftanın ilk günü olarak kabul edilmektedir).","code":""},{"path":"tarihlerle-çalışma.html","id":"haftalık-sayımlar","chapter":"9 Tarihlerle çalışma","heading":"Haftalık sayımlar","text":"Verileri count(), group_by() ve summarise() ile gruplandırmanın kapsamlı açıklamaları için Verileri Gruplama ile ilgili sayfaya bakınız. Aşğıda Kısa bir örnek verilmiştir.unit = \"week\" argümanıyla floor_date() ve mutate() fonksiyonlarıyla yeni bir “hafta” sütunu oluşturuncount() ile haftalık satır (vaka) sayısını alın; tarihi eksik olan vakaları filtreleyinVerilerde tüm haftaların görünmesini sağlamak için tidyr’paketinden complete() ile fonksiyonunu kullanın (satır/durum bilgisi içermeyenleri de eklemek adına). Varsayılan olarak, herhangi bir “yeni” satır için sayım değerleri NA’dır, ancak bunları adlandırılmış bir liste bekleyen fill = argümanıyla 0 yapabilirsiniz (aşağıdaki örnekte verilen n değeri yeni sütununun adıdır)Ortaya çıkan veri çerçevesinin ilk satırları şunlardır:","code":"\n# Haftalık vaka sayılarının yeni bir veri setinde gösterin\nweekly_counts <- linelist %>% \n  drop_na(date_onset) %>%             # başlangıç tarihi eksik vakaları kaldırın\n  mutate(weekly_cases = floor_date(   # \"weekly_cases\" adında yeni bir sütun oluştur\n    date_onset,\n    unit = \"week\")) %>%            \n  count(weekly_cases) %>%           # verileri haftaya göre gruplandır ve grup başına satırları say ('n' sütununu oluşturur)\n  tidyr::complete(                  # vaka bildirilmemiş olan haftalar da dahil olmak üzere tüm haftaların mevcut olduğundan emin ol\n    weekly_cases = seq.Date(          # \"weekly_cases\" sütununu eksiksiz bir dizi olarak yeniden tanımla\n      from = min(weekly_cases),       # minimum tarihten itibaren\n      to = max(weekly_cases),         # maksimum tarihe kadar\n      by = \"week\"),                   # hafta olarak\n    fill = list(n = 0))             # n sütunundaki NA'ları 0 ile değiştir"},{"path":"tarihlerle-çalışma.html","id":"epiweek-alternatifleri","chapter":"9 Tarihlerle çalışma","heading":"Epiweek alternatifleri","text":"lubridate’nin ayrıca biri farklı başlangıç tarih ve nüanslarına sahip olan week(), epiweek() ve isoweek() fonksiyonlarına sahip olduğunu unutmayın. Genel olarak, floor_date() ihtiyacınız olan şeyi kapsamaktadır. Konsola ?week girerek veya buradaki belgeleri okuyarak daha fazla bilgiye ulaşabilirsiniz.Epidemiyolojik haftaları ayarlamak için aweek paketini kullanmayı düşünebilirsiniz. Bununla ilgili daha fazla bilgiyi RECON web sitesinde okuyabilirsiniz. Haftanın başlangıç gününü week_start = \"Monday\" ile ayarlayabileceğiniz ‘date2week()’ ve ‘week2date()’ fonksiyonları mevcuttur. “Hafta” tarzı çıktılar istiyorsanız (örneğin “2020-W12”) bu paket en kolay yoldur. aweek’bir başka avantajı da, tarih sütununa date2week() uygulandığında, döndürülen sütunun (hafta biçimi) otomatik olarak sınıf Faktörü olması ve zaman aralığındaki tüm haftalar için seviyeleri de içermesidir (bu, yukarıda anlatılan complete() komutunda ek adımını yok sayar). aweek, tarihleri ay, yıl vb. gibi diğer zaman birimlerine yuvarlama işlevine sahip değildir.Bir “hafta” biçimini (“2020 W12”) göstermek için başka bir zaman serisi alternatifi de, [Zaman serisi ve salgın tespiti] sayfasında anlatılan tsibble paketindeki yearweek()tir. .","code":""},{"path":"tarihlerle-çalışma.html","id":"tarihlerisaat-dilimlerini-dönüştürme","chapter":"9 Tarihlerle çalışma","heading":"9.10 Tarihleri/saat dilimlerini dönüştürme","text":"Veriler farklı saat dilimlerinde olduğunda, bu verileri birleşik bir saat dilimine standart hale getirmek genellikle önemlidir. Çoğu durumda verilerin saat dilimi bileşeninin manuel olarak kodlanması gerektiğinden, bu daha fazla zorluğa neden olmaktadır.R’da datetime nesnesinin bir saat dilimi bileşeni vardır. Varsayılan olarak, tüm datetime nesneleri kullanılan bilgisayarın yerel saat dilimini kullanmaktadır - bu genellikle, yaz saati uygulaması nedeniyle zaman dilimleri konumlarda sık sık değişeceğinden, adlandırılmış bir saat dilimi yerine konuma özgüdür. Bir tarih sütununun temsil ettiği olay belirli bir zamana atfedilemeyeceğinden ve bu nedenle saat cinsinden ölçülen zaman kaymaları makul bir şekilde açıklanamaz. Tarihin zaman bileşeni olmadan saat dilimlerini doğru bir şekilde yönetmek mümkün değildir.Saat dilimleriyle başa çıkabilmek için, lubridate’de bir datetime nesnesinin saat dilimini farklı bir saat dilimine değiştirmek için kullanılabilecek bir dizi yardımcı fonksiyon mevcuttur. Saat dilimleri, datetime nesnesine geçerli bir tz veritabanı saat dilimi atanarak hesaplanır. Bunların bir listesini aşağıdaki linkte bulabilirsiniz - verileri kullandığınız konum bu listede değilse, saat dilimine yakın büyük şehirleri kullanabilirsiniz, bu, aynı amaca hizmet edecektir.https://en.wikipedia.org/wiki/List_of_tz_database_time_zonesBu büyük ölçüde soyut görünebilir ve kullanıcı farklı zaman dilimlerinde çalışmıyorsa genellikle gerekli değildir.","code":"\n# geçerli saati bir sütuna ata\ntime_now <- Sys.time()\ntime_now## [1] \"2022-11-20 16:20:52 CET\"\n# saat zamanını DEĞİŞTİRİRKEN sütuna yeni bir saat dilimi atamak için with_tz() kullan\ntime_london_real <- with_tz(time_now, \"Europe/London\")\n\n# sütuna yeni bir saat dilimi atamak için force_tz() kullanın, saat zamanını SABİTLEYİN\ntime_london_local <- force_tz(time_now, \"Europe/London\")\n\n\n# Bu kodu çalıştırmak için kullanılan bilgisayar Londra saat diliminde olmadığını unutmayın,\n# zaman farkı olacaktır\n# (bilgisayar saat diliminden londra'ya kadar olan saat farkı)\ntime_london_real - time_london_local## Time difference of -1 hours"},{"path":"tarihlerle-çalışma.html","id":"gecikme-ve-önden-gelme-hesaplamaları","chapter":"9 Tarihlerle çalışma","heading":"9.11 Gecikme ve önden gelme hesaplamaları","text":"lead() ve lag(), bir vektördeki önceki (geciken) veya sonraki (önden gelen) değerleri bulmaya yardımcı olan dplyr paketindeki fonksiyonlarıdır - tipik olarak bir sayısal veya tarih vektörüdür. Bu fonksiyonlar, zaman birimleri arasındaki değişim/fark hesaplamaları yaparken işe yarar.Mevcut bir hafta ile önceki hafta arasındaki vaka farkını hesaplamak istediğinizi varsayalım. Veriler başlangıçta aşağıda gösterildiği gibi haftalık sayılarla elde edilir.lag() veya lead() komutlarını kullanırken veri çerçevesindeki satırların sırası çok önemlidir! - tarihlerinizin / numaralarınızın artan mı yoksa azalan mı olduğuna dikkat etmelisiniz.İlk olarak, önceki (geciken) haftanın değerini içeren yeni bir sütun oluşturun.Geri/ileri birim sayısını n = ile kontrol edin (negatif olmayan bir tam sayı olmalıdır)Var olmayan satırlara yerleştirilen değeri tanımlamak için default = argümanını kullanın (örneğin, gecikmeli değerin olmadığı ilk satır). Varsayılan olarak bu NAdır.Satırlarınız referans sütununuza göre sıralanmıyorsa order_by = TRUE argümanını kullanınArdından, iki vaka sütunu arasındaki farkı hesaplayan yeni bir sütun oluşturun:lead() ve lag() hakkında daha fazla bilgiyi buradaki belgelerde veya `?lag`` kodunu konsola girerek elde edebilirsiniz.","code":"\ncounts <- counts %>% \n  mutate(cases_prev_wk = lag(cases_wk, n = 1))\ncounts <- counts %>% \n  mutate(cases_prev_wk = lag(cases_wk, n = 1),\n         case_diff = cases_wk - cases_prev_wk)"},{"path":"tarihlerle-çalışma.html","id":"kaynaklar-2","chapter":"9 Tarihlerle çalışma","heading":"9.12 Kaynaklar","text":"lubridate tidyverse sayfasılubridate RStudio kopya kağıdı\nVeri Bilimi için R - tarih ve saatler sayfasıÇevrimiçi rehber\nTarih formatları","code":""},{"path":"karakterler-ve-dizeler.html","id":"karakterler-ve-dizeler","chapter":"10 Karakterler ve dizeler","heading":"10 Karakterler ve dizeler","text":"Bu sayfa, karakter değerlerini (“dizeler”) değerlendirmek ve işlemek için stringr paketinin kullanımını göstermektedir.Birleştir, düzenle, ayır, düzenle - str_c(), str_glue(), str_order(), str_split()Temizle ve standardize et\nUzunluğunu ayarla - str_pad(), str_trunc(), str_wrap()\nBüyük küçük harfi değiştir - str_to_upper(), str_to_title(), str_to_lower(), str_to_sentence()\nUzunluğunu ayarla - str_pad(), str_trunc(), str_wrap()Büyük küçük harfi değiştir - str_to_upper(), str_to_title(), str_to_lower(), str_to_sentence()Sırasına göre çıkar ve değerlendir - str_length(), str_sub(), word()Paternlre\nTespit et ve bul - str_detect(), str_subset(), str_match(), str_extract()\nModifiye et ve değiştir - str_sub(), str_replace_all()\nTespit et ve bul - str_detect(), str_subset(), str_match(), str_extract()Modifiye et ve değiştir - str_sub(), str_replace_all()Düzenli ifadeler (“regex”)Gösterimi kolaylaştırmak için çoğu örnekte kısa tanımlı bir karakter vektörü esas alınmıştır, bu örnekler bir veri çerçevesi içindeki sütuna kolayca uyarlanabilir.Bu stringr skeci bu sayfa için ilham vermiştir.","code":""},{"path":"karakterler-ve-dizeler.html","id":"hazırlık-1","chapter":"10 Karakterler ve dizeler","heading":"10.1 Hazırlık","text":"","code":""},{"path":"karakterler-ve-dizeler.html","id":"paketleri-yükleme","chapter":"10 Karakterler ve dizeler","heading":"Paketleri yükleme","text":"stringr ve diğer tidyverse paketlerini kurun veya yükleyin.","code":"\n# paketleri indir/yükle\npacman::p_load(\n  stringr,    # dizeleri işlemek için birçok fonksiyon\n  tidyverse,  # ek veri işleme fonksiyonları\n  tools)      # başlıkları dönüştürmek için alternatif"},{"path":"karakterler-ve-dizeler.html","id":"verileri-yükleme","chapter":"10 Karakterler ve dizeler","heading":"Verileri yükleme","text":"Bu sayfada, simüle edilmiş bir Ebola salgını vakalarının temizlenmiş “satır listesine” ara sıra atıfta bulunulacaktır. Daha fazla bilgi için, “temiz satır listesi” dosyasını indirmek için tıklayın. (.rds dosyası olarak). rio paketinden import() işleviyle veriler içe aktarırılır (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe ve dışa aktarma] sayfasına bakın).first 50 rows linelist displayed .","code":"\n# Satır listesini indir\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"karakterler-ve-dizeler.html","id":"birleştir-böl-ve-düzenle","chapter":"10 Karakterler ve dizeler","heading":"10.2 Birleştir, böl ve düzenle","text":"Bu bölüm aşağıdaki başlıkları içermektedir:str_c(), str_glue(), ve unite() komutlarıyla dizeleri birleştirmekstr_order() komutuyla dizeleri sıralamakstr_split() ve separate() komutuyla dizeleri ayırmak","code":""},{"path":"karakterler-ve-dizeler.html","id":"dizeleri-birleştirme","chapter":"10 Karakterler ve dizeler","heading":"Dizeleri Birleştirme","text":"Birden çok dizeyi tek bir dizede birleştirmek için, stringr’dan str_c fonksiyonu kullanılır. Birleştirilecek farklı karakterler mevcutsa, bunları virgülle ayırarak benzersiz argümanlar olarak eklemeniz yeterlidir.sep = argümanı, eklediğiniz bağımsız değişkenlerin birinin arasına bir karakter değeri ekler (ör. virgül, boşluk veya yeni satır \"\\n\" ekleme)collapse = argümanı, str_c() argümanıyla birden çok vektör kullanılıldığı durumlarda işe yarar. Çıktının öğelerini ayırmak için kullanılır.Aşağıdaki örnek, iki vektörün tek bir vektörde (adlar ve soyadlar) birleşimini göstermektedir. Bir başka benzer örnek, yargı yetkileri ve dava sayıları olabilir. Bu örnekte:sep = değeri ad ve soyad arasını belirlercollapse = değeri bir kişiyi bir diğerinden ayırırNot: İstenilen görüntüleme şekline göre, birleşik dize yazdırırken, yeni satırların düzgün yazdırılması için tüm ifadeyi cat() fonksiyonu içine sarmanız gerekebilir:","code":"\nstr_c(\"String1\", \"String2\", \"String3\")## [1] \"String1String2String3\"\nstr_c(\"String1\", \"String2\", \"String3\", sep = \", \")## [1] \"String1, String2, String3\"\nfirst_names <- c(\"abdul\", \"fahruk\", \"janice\") \nlast_names  <- c(\"hussein\", \"akinleye\", \"okeke\")\n\n# ilgili giriş dizeleri arasını sep belirler, her bir öğenin arasını ise collapse belirler\nstr_c(first_names, last_names, sep = \" \", collapse = \";  \")## [1] \"abdul hussein;  fahruk akinleye;  janice okeke\"\n# Yeni satırların doğru yazdırılması için ifadenin cat() içine sarılması gerekir\ncat(str_c(first_names, last_names, sep = \" \", collapse = \";\\n\"))## abdul hussein;\n## fahruk akinleye;\n## janice okeke"},{"path":"karakterler-ve-dizeler.html","id":"dinamik-dizeler","chapter":"10 Karakterler ve dizeler","heading":"Dinamik dizeler","text":"Bir dizeye dinamik R kodu eklemek için str_glue() fonksiyonunu kullanın. Bu, aşağıda gösterildiği gibi dinamik grafik başlıkları oluşturmak için çok kullanışlı bir fonksiyondurTüm içerik çift tırnak işaretleri arasında girilir str_glue(\"\")Herhangi bir dinamik kod veya önceden tanımlanmış değerlere yapılan referanslar, çift tırnak işareti içerisinde {} küme parantezleri içine yerleştirilir. Aynı str_glue() komutunda birçok küme parantezleri olabilir.\" tırnak işaretini görüntülemek için, çevreleyen çift tırnak içinde tek tırnak kullanılabilir (ör. tarih formatı sağlarken - aşağıdaki örneğe bakın)İpucu: Satır atlamak için \\ni kullanabilirsinizİpucu: Tarih gösterimini ayarlamak için format() ve geçerli tarihi görüntülemek için Sys.Date() fonksiyonlarını kullanabilirsinizDinamik bir grafik başlığının basit bir örneği:Alternatif bir format, parantez içinde yer tutucuları kullanmak ve kodu, aşağıdaki gibi str_glue() fonksiyonunun sonunda ayrı argümanlarda tanımlamaktır. Bu, metin uzunsa kodun okunabilirliğini artırabilir.Bir veri çerçevesinden dizi alımıBazen, bir veri çerçevesinden veri çekmek ve peşpeşe eklemek istenebilir. Aşağıda örnek bir veri çerçevesi bulunmaktadır. Bu veri çerçevesi, yetki alanları; yeni ve toplam dava sayıları hakkında özet bir açıklama yapmak için kullanılabilir.Veri çerçevesi satırlarından veri almak için özel olarak yapılmış str_glue_data() kullanılır:Dizeleri satırlarda birleştirmeBir veri çerçevesi sütunundaki değerleri “birleştirmeye” çalışıyorsanız; örneğin, birden çok satırdaki değerleri bir ayırıcıyla birbirine yapıştırarak tek bir satırda birleştirme, Tekilleştirme sayfasının “toplama” değerleri bölümüne bakabilirsiniz.Veri çerçevesini bir satıra çevirmestr_c() fonksiyonu (veri çerçevesini ve sütun adlarını da belirterek), sep = ve collapse = argümanlarını kullanarak verilerin tek satırda görünmesini sağlayabilirsiniz.Verileri ayrı bir str_c() komutu ile sarmalayarak ifadenin başına “New Cases:” ön metnini ekleyebilirsiniz (“New Cases:” orijinal str_c() içindeyse, birden çok kez görünecektir).","code":"\nstr_glue(\"Data include {nrow(linelist)} cases and are current to {format(Sys.Date(), '%d %b %Y')}.\")## Data include 5888 cases and are current to 20 Nov 2022.\nstr_glue(\"Linelist as of {current_date}.\\nLast case hospitalized on {last_hospital}.\\n{n_missing_onset} cases are missing date of onset and not shown\",\n         current_date = format(Sys.Date(), '%d %b %Y'),\n         last_hospital = format(as.Date(max(linelist$date_hospitalisation, na.rm=T)), '%d %b %Y'),\n         n_missing_onset = nrow(linelist %>% filter(is.na(date_onset)))\n         )## Linelist as of 20 Nov 2022.\n## Last case hospitalized on 30 Apr 2015.\n## 256 cases are missing date of onset and not shown\n# vaka veri çerçevesini hazırla\ncase_table <- data.frame(\n  zone        = c(\"Zone 1\", \"Zone 2\", \"Zone 3\", \"Zone 4\", \"Zone 5\"),\n  new_cases   = c(3, 0, 7, 0, 15),\n  total_cases = c(40, 4, 25, 10, 103)\n  )\ncase_table %>% \n  str_glue_data(\"{zone}: {new_cases} ({total_cases} total cases)\")## Zone 1: 3 (40 total cases)\n## Zone 2: 0 (4 total cases)\n## Zone 3: 7 (25 total cases)\n## Zone 4: 0 (10 total cases)\n## Zone 5: 15 (103 total cases)\nstr_c(case_table$zone, case_table$new_cases, sep = \" = \", collapse = \";  \")## [1] \"Zone 1 = 3;  Zone 2 = 0;  Zone 3 = 7;  Zone 4 = 0;  Zone 5 = 15\"\nstr_c(\"New Cases: \", str_c(case_table$zone, case_table$new_cases, sep = \" = \", collapse = \";  \"))## [1] \"New Cases: Zone 1 = 3;  Zone 2 = 0;  Zone 3 = 7;  Zone 4 = 0;  Zone 5 = 15\""},{"path":"karakterler-ve-dizeler.html","id":"str_unite","chapter":"10 Karakterler ve dizeler","heading":"Sütunları birleştirme","text":"Bir veri çerçevesinde, birden çok sütundaki karakter değerlerini bir araya getirmek, tidyr’den unite() fonksiyonu ile gerçekleştirilebilir. Bu, separate()tam tersidir.Yeni birleşik sütunun adı girilir. Ardından, birleştirmek istenen sütunların adları girilir.Varsayılan olarak, birleşik sütunda kullanılan ayırıcı _ alt çizgidir, ancak bu, sep = argümanı ile değiştirilebilir.remove = veri çerçevesinden giriş sütunlarını kaldırır (varsayılan olarak TRUE)na.rm = birleştirirken eksik değerleri kaldırır (varsayılan olarak FALSE)Aşağıda, göstermek için bir mini veri çerçevesi tanımlanmaktadır:Örnek bir veri çerçevesi:Aşağıda, üç semptom sütununu birleştirilmiştir:","code":"\ndf <- data.frame(\n  case_ID = c(1:6),\n  symptoms  = c(\"jaundice, fever, chills\",     # hasta 1\n                \"chills, aches, pains\",        # hasta 2 \n                \"fever\",                       # hasta 3\n                \"vomiting, diarrhoea\",         # hasta 4\n                \"bleeding from gums, fever\",   # hasta 5\n                \"rapid pulse, headache\"),      # hasta 6\n  outcome = c(\"Recover\", \"Death\", \"Death\", \"Recover\", \"Recover\", \"Recover\"))\ndf_split <- separate(df, symptoms, into = c(\"sym_1\", \"sym_2\", \"sym_3\"), extra = \"merge\")## Warning: Expected 3 pieces. Missing pieces filled with `NA` in 2 rows [3, 4].\ndf_split %>% \n  unite(\n    col = \"all_symptoms\",         # yeni birleşik sütunun adı\n    c(\"sym_1\", \"sym_2\", \"sym_3\"), # birleştirilecek için sütunlar\n    sep = \", \",                   # birleşik sütunda kullanılacak ayırıcı\n    remove = TRUE,                # TRUE ise, veri çerçevesinden girdi sütunlarını kaldırır\n    na.rm = TRUE                  # DOĞRU ise, birleştirmeden önce eksik değerler kaldırılır\n  )##   case_ID                all_symptoms outcome\n## 1       1     jaundice, fever, chills Recover\n## 2       2        chills, aches, pains   Death\n## 3       3                       fever   Death\n## 4       4         vomiting, diarrhoea Recover\n## 5       5 bleeding, from, gums, fever Recover\n## 6       6      rapid, pulse, headache Recover"},{"path":"karakterler-ve-dizeler.html","id":"ayırma","chapter":"10 Karakterler ve dizeler","heading":"Ayırma","text":"Bir dizgiyi belli bir paterne göre bölmek için str_split() kullanılabilir. Bu komut dize(ler)uygun paternde böler ve yeni değerlerden oluşan karakter vektörleri list olarak döndürür.Aşağıdaki basit örnek, verilen dizeyi değerlendirir ve onu üçe böler. Varsayılan olarak, dizin bir bölümü (bir karakter vektörü) list sınıfının bir nesnesine dönüştürülür. Eğer argüman simplify = TRUE ise, sonuç bir karakter matrisi olacaktır.Bu örnekte, dize fonksiyon ile, listeye dönüştürülür - üç değer içeren bir karakter vektörü.Çıktı kaydedilirse, parantez sözdizimi ile n’inci değerine erişebilirsiniz. Belirli bir değere erişmek için the_returned_object[[1]][2] argümanı kullanılır. Bu fonksiyonla listedeki (“fever”) ikinci değere erişir. Değerlere erişim hakkında daha fazla ayrıntı için [R temelleri] sayfasına bakabilirsiniz.str_split() fonksiyonuyla listede birden fazla karakter dizisi mevcutsa, döndürülen listede de birden fazla eleman olacaktır.Veri çerçevesi sütununa dönüştürebileceğiniz bir “karakter matrisi” çıktısını almak için, simplify = TRUE bağımsız değişkenini aşağıda gösterildiği gibi ayarlamalısınız:Ayrıca n = argümanıyla oluşturulacak bölmelerin sayısını da ayarlayabilirsiniz. Aşağıdaki örnekte bölme sayısı 2 ile sınırlandırılmıştır. Diğer virgül ve dizeler ikinci değer içinde kalır.- aynı çıktıları, “simplify” argümanını kullanmadığınız, bunun yerine sütun sayısını (n) belirtmeniz gereken str_split_fixed() fonksiyonu ile de elde edilebilirsiniz.","code":"\nstr_split(string = \"jaundice, fever, chills\",\n          pattern = \",\")## [[1]]\n## [1] \"jaundice\" \" fever\"   \" chills\"\npt1_symptoms <- str_split(\"jaundice, fever, chills\", \",\")\n\npt1_symptoms[[1]][2]  # listeden 2. değeri çıkarır## [1] \" fever\"\nsymptoms <- c(\"jaundice, fever, chills\",     # hasta 1\n              \"chills, aches, pains\",        # hasta 2 \n              \"fever\",                       # hasta 3\n              \"vomiting, diarrhoea\",         # hasta 4\n              \"bleeding from gums, fever\",   # hasta 5\n              \"rapid pulse, headache\")       # hasta 6\n\nstr_split(symptoms, \",\")                     # her hastanın semptomlarını ayırır## [[1]]\n## [1] \"jaundice\" \" fever\"   \" chills\" \n## \n## [[2]]\n## [1] \"chills\" \" aches\" \" pains\"\n## \n## [[3]]\n## [1] \"fever\"\n## \n## [[4]]\n## [1] \"vomiting\"   \" diarrhoea\"\n## \n## [[5]]\n## [1] \"bleeding from gums\" \" fever\"            \n## \n## [[6]]\n## [1] \"rapid pulse\" \" headache\"\nstr_split(symptoms, \",\", simplify = TRUE)##      [,1]                 [,2]         [,3]     \n## [1,] \"jaundice\"           \" fever\"     \" chills\"\n## [2,] \"chills\"             \" aches\"     \" pains\" \n## [3,] \"fever\"              \"\"           \"\"       \n## [4,] \"vomiting\"           \" diarrhoea\" \"\"       \n## [5,] \"bleeding from gums\" \" fever\"     \"\"       \n## [6,] \"rapid pulse\"        \" headache\"  \"\"\nstr_split(symptoms, \",\", simplify = TRUE, n = 2)##      [,1]                 [,2]            \n## [1,] \"jaundice\"           \" fever, chills\"\n## [2,] \"chills\"             \" aches, pains\" \n## [3,] \"fever\"              \"\"              \n## [4,] \"vomiting\"           \" diarrhoea\"    \n## [5,] \"bleeding from gums\" \" fever\"        \n## [6,] \"rapid pulse\"        \" headache\"\nstr_split_fixed(symptoms, \",\", n = 2)"},{"path":"karakterler-ve-dizeler.html","id":"sütunları-ayırma","chapter":"10 Karakterler ve dizeler","heading":"Sütunları ayırma","text":"Veri çerçevesine ait bir sütunu bölmeye çalışıyorsanız, dplyr paketinden separate() fonksiyonu en iyi seçenektir. Bu fonksiyon var olan bir karakter sütununu diğer sütunlara bölmek için kullanılır.Diyelim ki bir case_ID sütunu, birçok semptom içeren bir karakter sütunu ve bir sonuç sütunu içeren basit bir “df” (Sütunları birleştirme bölümünde içinde tanımlanmış ve birleştirilmiş) veri çerçevemiz var. Bu örnekte amacımız, semptomlar sütununu biri bir semptom içeren birçok sütuna ayırmaktır.Verileri separate() fonksiyonuna aktarıldığını varsayarsak, önce ayrılacak sütunu fonksiyona tanımlamalısınız. Ardından, aşağıda gösterildiği gibi yeni sütun adlarını içeren bir c( ) vektörünü olarak = argümanına aktarabilirsiniz.sep = ayırıcı, bir karakter veya bir sayı olabilir (bölünecek karakter konumu olarak yorumlanır)remove = Varsayılan olarak FALSE, giriş sütununu kaldırırconvert = Varsayılan olarak FALSE, “NA” dizelerinin “NA” (eksik veri) formatına dönüştürürextra = bu, ayırılan yeni sütunlarda daha fazla değer varsa bunların ne olacağını kontrol eder.\nextra = \"warn\" sizi uyarır, ancak aşırı değerlerin kaybolacağı anlamına gelir (default)\nextra = \"drop\" aşırı değerlerin uyarı yapılmadan kaybolacağı anlamına gelir\nextra = \"merge\" yalnızca “” argümanında tanımlanan sütun sayısına bölünür - bu ayar tüm verilerinizi korur\nextra = \"warn\" sizi uyarır, ancak aşırı değerlerin kaybolacağı anlamına gelir (default)extra = \"drop\" aşırı değerlerin uyarı yapılmadan kaybolacağı anlamına gelirextra = \"merge\" yalnızca “” argümanında tanımlanan sütun sayısına bölünür - bu ayar tüm verilerinizi korurAşağıda extra = \"merge\" içeren bir örnek verilmiştir - burada hiçbir veri kaybolmaz. İki yeni sütun tanımlanır, ancak ikinci yeni sütunda üçüncü semptomlar kalmaya devam eder:Aşağıda varsayılan extra = \"drop\" kullanıldığında sistem bir uyarı verir ancak üçüncü semptomlar kaybolur:DİKKAT: Yeni sütunlar için yeterli değeri sağlamazsanız verileriniz kaybolabilir.","code":"\n# ikinci ve üçüncü semptomlar ikinci sütunda birleştirildi\ndf %>% \n  separate(symptoms, into = c(\"sym_1\", \"sym_2\"), sep=\",\", extra = \"merge\")## Warning: Expected 2 pieces. Missing pieces filled with `NA` in 1 rows [3].##   case_ID              sym_1          sym_2 outcome\n## 1       1           jaundice  fever, chills Recover\n## 2       2             chills   aches, pains   Death\n## 3       3              fever           <NA>   Death\n## 4       4           vomiting      diarrhoea Recover\n## 5       5 bleeding from gums          fever Recover\n## 6       6        rapid pulse       headache Recover\n# üçüncü semptomlar kaybolur\ndf %>% \n  separate(symptoms, into = c(\"sym_1\", \"sym_2\"), sep=\",\")## Warning: Expected 2 pieces. Additional pieces discarded in 2 rows [1, 2].## Warning: Expected 2 pieces. Missing pieces filled with `NA` in 1 rows [3].##   case_ID              sym_1      sym_2 outcome\n## 1       1           jaundice      fever Recover\n## 2       2             chills      aches   Death\n## 3       3              fever       <NA>   Death\n## 4       4           vomiting  diarrhoea Recover\n## 5       5 bleeding from gums      fever Recover\n## 6       6        rapid pulse   headache Recover"},{"path":"karakterler-ve-dizeler.html","id":"alfabetik-olarak-düzenle","chapter":"10 Karakterler ve dizeler","heading":"Alfabetik olarak düzenle","text":"Birkaç dize alfabetik sıraya göre sıralanabilir. str_order() dizelerin alfabetik olarak sırasını verirken, str_sort() dizeleri alfabetik olarak sıralar.Farklı bir alfabe kullanmak için locale = argümanını ekleyebilirsiniz. R konsoluna stringi::stri_locale_list() girerek yerel ayarların tam listesine bakabınız.","code":"\n# dizeler\nhealth_zones <- c(\"Alba\", \"Takota\", \"Delta\")\n\n# alfabetik sırasını döndürür\nstr_order(health_zones)## [1] 1 3 2\n# dizeleri alfabetik olarak sıralar\nstr_sort(health_zones)## [1] \"Alba\"   \"Delta\"  \"Takota\""},{"path":"karakterler-ve-dizeler.html","id":"r-tabanı-fonksiyonları","chapter":"10 Karakterler ve dizeler","heading":"R tabanı fonksiyonları","text":"Tüm parçaları karaktere dönüştürdükten sonra vektörleri birleştiren R tabanındaki paste() ve paste0() fonksiyonları yaygın bir şekilde kullanılmaktadır. Bunlar str_c() fonksiyonuna benzer şekilde hareket ederler, ancak sözdizimi daha karmaşıktır - parantez içinde bölüm bir virgülle ayrılır. Parçalar ya karakter metnidir (tırnak içinde) ya da önceden tanımlanmış kod nesneleridir (tırnak işaretleri olmadan). Örnek olarak:sep = ve collapse = argümanları özelleştirilebilir. paste0() basitçe paste() fonksiyonunun sep = \" \" (bir boşluk) argümanlı halidir.","code":"\nn_beds <- 10\nn_masks <- 20\n\npaste0(\"Regional hospital needs \", n_beds, \" beds and \", n_masks, \" masks.\")## [1] \"Regional hospital needs 10 beds and 20 masks.\""},{"path":"karakterler-ve-dizeler.html","id":"temizleme-ve-standartlaştırma","chapter":"10 Karakterler ve dizeler","heading":"10.3 Temizleme ve standartlaştırma","text":"","code":""},{"path":"karakterler-ve-dizeler.html","id":"karakterleri-değiştirme","chapter":"10 Karakterler ve dizeler","heading":"Karakterleri değiştirme","text":"Çoğu zaman, bir dize değerinin büyük/küçük harf kullanımı değiştirilmelidir, örneğin şehir adları. Aşağıda stringr paketinden str_to_upper(), str_to_lower() ve str_to_title() fonksiyonlarına ait örnekler verilmiştir:Yukarıdaki örnekler R tabanındaki toupper(), tolower() fonksiyonlarıyla da yapılabilir.İlk karakterHer kelimenin ilk harfini büyütmek için str_to_title() fonksiyonu kullanılır:Daha hassas bir büyük harf kullanımı elde etmek için tools paketinden toTitleCase() fonksiyonunu kullanabilirsiniz (“”, “” ve “” gibi sözcükler büyük harfle yazılmaz).Ayrıca cümlenin yalnızca ilk harfini büyük harf yapan str_to_sentence() kullanabilirsiniz.","code":"\nstr_to_upper(\"California\")## [1] \"CALIFORNIA\"\nstr_to_lower(\"California\")## [1] \"california\"\nstr_to_title(\"go to the US state of california \")## [1] \"Go To The Us State Of California \"\ntools::toTitleCase(\"This is the US state of california\")## [1] \"This is the US State of California\"\nstr_to_sentence(\"the patient must be transported\")## [1] \"The patient must be transported\""},{"path":"karakterler-ve-dizeler.html","id":"str_pad","chapter":"10 Karakterler ve dizeler","heading":"Karakter uzunluğu","text":"Bir dizeye minimum uzunlukta karakter eklemek için str_pad() fonksiyonunu kullanabilirsiniz. Varsayılan olarak boşluklar eklenir, ancak pad = argümanını kullanarak diğer karakterlerle de doldurabilirsiniz.Örneğin, sayıların başını sıfırlarla doldurmak için (saat veya dakika gibi), sayıyı pad = \"0\" ile minimum 2 uzunluğa kadar doldurabilirsiniz.","code":"\n# Farklı uzunluktaki ICD kodları\nICD_codes <- c(\"R10.13\",\n               \"R10.819\",\n               \"R17\")\n\n# Sağ tarafta 7 karaktere kadar doldurulmuş ICD kodları\nstr_pad(ICD_codes, 7, \"right\")## [1] \"R10.13 \" \"R10.819\" \"R17    \"\n# Boşluk yerine nokta içeren karakter alanı\nstr_pad(ICD_codes, 7, \"right\", pad = \".\")## [1] \"R10.13.\" \"R10.819\" \"R17....\"\n# İki basamağın başına sıfır ekle (ör. dakika/saat zamanları için)\nstr_pad(\"4\", 2, pad = \"0\") ## [1] \"04\"\n# \"saat\" adlı sayısal bir sütun kullanan örnek\nhours <- str_pad(hours, 2, pad = \"0\")"},{"path":"karakterler-ve-dizeler.html","id":"kesme","chapter":"10 Karakterler ve dizeler","heading":"Kesme","text":"str_trunc() dize için bir maksimum bir uzunluk belirler. Bir dize bu uzunluğu aşarsa, kısaltılır (kısaltılır) ve dizenin öncesinde daha uzun olduğunu belirtmek için bir üç nokta (…) eklenir. Üç noktanın uzunluk olarak sayıldığına dikkat etmelisiniz. Üç nokta karakterleri ellipsis = argümanı ile değiştirilebilir. İsteğe bağlı side = argümanı, üç noktanın kesilen dize (“sol”, “sağ” veya “merkez”) içinde nerede görüneceğini belirtir.","code":"\noriginal <- \"Symptom onset on 4/3/2020 with vomiting\"\nstr_trunc(original, 10, \"center\")## [1] \"Symp...ing\""},{"path":"karakterler-ve-dizeler.html","id":"standart-uzunluk","chapter":"10 Karakterler ve dizeler","heading":"Standart uzunluk","text":"Standart uzunluğu belirlemek için str_trunc() fonksiyonunu kullanabilirsiniz. Standart uzunluğa göre kısa olan dizeleri genişletmek için str_pad() fonksiyonu kullanılır. Aşağıdaki örnekte, maksimum uzunluk olarak 6 ayarlanmıştır. Burada daha uzun değerler kesilir ve kısa olan değerler genişler.","code":"\n# Farklı uzunluktaki ICD kodları\nICD_codes   <- c(\"R10.13\",\n                 \"R10.819\",\n                 \"R17\")\n\n# en fazla 6 karakterle sınırla\nICD_codes_2 <- str_trunc(ICD_codes, 6)\nICD_codes_2## [1] \"R10.13\" \"R10...\" \"R17\"\n# en az 6 karakter uzunluğunda tut\nICD_codes_3 <- str_pad(ICD_codes_2, 6, \"right\")\nICD_codes_3## [1] \"R10.13\" \"R10...\" \"R17   \""},{"path":"karakterler-ve-dizeler.html","id":"baştakisondaki-boşlukları-kaldırma","chapter":"10 Karakterler ve dizeler","heading":"Baştaki/sondaki boşlukları kaldırma","text":"Bir dize girişinin kenarlarındaki boşlukları, yeni satırları (\\n) veya sekmeleri (\\t) kaldırmak için str_trim() kullanın. Hangi tarafın kırpılacağını belirtmek için komuta \"sağ\" \"sol\" veya \"ikisi\" ekleyin (ör. str_trim(x, \"sağ\")).","code":"\n# Sağda fazla boşluk bulunan kimlik numaraları\nIDs <- c(\"provA_1852  \", # iki fazla boşluk\n         \"provA_2345\",   # fazla boşluk yok\n         \"provA_9460 \")  # bir fazla boşluk\n\n# Kimlik numaraların yalnızca sağ taraftaki fazla boşlukları kaldırılır\nstr_trim(IDs)## [1] \"provA_1852\" \"provA_2345\" \"provA_9460\""},{"path":"karakterler-ve-dizeler.html","id":"tekrarlanan-boşlukları-kaldırma","chapter":"10 Karakterler ve dizeler","heading":"Tekrarlanan boşlukları kaldırma","text":"Bir dizenin içindeki yinelenen boşlukları kaldırmak için str_squish() fonksiyonunu kullanabilirsiniz. Örneğin, çift boşlukları tek boşluklara dönüştürmek için. Ayrıca str_trim() fonksiyonu gibi dizenin dışındaki boşlukları, yeni satırları veya sekmeleri de kaldırır.Daha fazla ayrıntı görmek için R konsolunuza ?str_trim, ?str_pad komutunu giriniz.","code":"\n# orijinal, dize içinde fazla boşluk içeriyor\nstr_squish(\"  Pt requires   IV saline\\n\") ## [1] \"Pt requires IV saline\""},{"path":"karakterler-ve-dizeler.html","id":"paragrafa-sığdırma","chapter":"10 Karakterler ve dizeler","heading":"Paragrafa sığdırma","text":"Uzun bir yapılandırılmamış metni sabit satır uzunluğuna sahip yapılandırılmış bir paragrafa sığdırmak için str_wrap() fonksiyonunu kullanabilirsiniz. satır için ideal karakter uzunluğunu tanımladığınızda, fonksiyon, aşağıdaki örnekte görüldüğü gibi paragraf içine yeni satırlar (\\n) eklemek için bir algoritma uygular.R tabanındaki cat() fonksiyonu ile yapılandırılmış bu yeni paragrafın çıktısı alınabilir.","code":"\npt_course <- \"Symptom onset 1/4/2020 vomiting chills fever. Pt saw traditional healer in home village on 2/4/2020. On 5/4/2020 pt symptoms worsened and was admitted to Lumta clinic. Sample was taken and pt was transported to regional hospital on 6/4/2020. Pt died at regional hospital on 7/4/2020.\"\n\nstr_wrap(pt_course, 40)## [1] \"Symptom onset 1/4/2020 vomiting chills\\nfever. Pt saw traditional healer in\\nhome village on 2/4/2020. On 5/4/2020\\npt symptoms worsened and was admitted\\nto Lumta clinic. Sample was taken and pt\\nwas transported to regional hospital on\\n6/4/2020. Pt died at regional hospital\\non 7/4/2020.\"\ncat(str_wrap(pt_course, 40))## Symptom onset 1/4/2020 vomiting chills\n## fever. Pt saw traditional healer in\n## home village on 2/4/2020. On 5/4/2020\n## pt symptoms worsened and was admitted\n## to Lumta clinic. Sample was taken and pt\n## was transported to regional hospital on\n## 6/4/2020. Pt died at regional hospital\n## on 7/4/2020."},{"path":"karakterler-ve-dizeler.html","id":"pozisyona-göre-düzenleme","chapter":"10 Karakterler ve dizeler","heading":"10.4 Pozisyona göre düzenleme","text":"","code":""},{"path":"karakterler-ve-dizeler.html","id":"karakter-pozisyonuna-göre-çıkarma","chapter":"10 Karakterler ve dizeler","heading":"Karakter pozisyonuna göre çıkarma","text":"Bir dizenin yalnızca bir kısmını döndürmek için str_sub() kullanın. Fonksiyon üç ana argüman alır:karakter vektör(leri)başlangıç pozisyonubitiş pozisyonuPozisyon değeri hakkında bir kaç:Bir pozisyon değeri pozitifse, pozisyon dizenin sol ucundan başlayarak sayılır.Bir pozisyon değeri negatifse, pozisyon dizenin sağ ucundan başlayarak sayılır.Pozisyon numaraları dahildir.Dizinin ötesine uzanan konumlar kesilir (kaldırılır).Aşağıda “pneumonia” dizesine uygulanan bazı örnekler verilmiştir.:","code":"\n# soldan üçüncü başlar ve biter (soldan üçüncü harf)\nstr_sub(\"pneumonia\", 3, 3)## [1] \"e\"\n# 0 mevcut değil\nstr_sub(\"pneumonia\", 0, 0)## [1] \"\"\n# soldan 6., sağdan 1. arasındaki\nstr_sub(\"pneumonia\", 6, -1)## [1] \"onia\"\n# Sağdan 5., sağdan 2. arasındaki\nstr_sub(\"pneumonia\", -5, -2)## [1] \"moni\"\n# 4. soldan dizenin dışındaki bir pozisyona\nstr_sub(\"pneumonia\", 4, 15)## [1] \"umonia\""},{"path":"karakterler-ve-dizeler.html","id":"kelime-pozisyonuna-göre-çıkarma","chapter":"10 Karakterler ve dizeler","heading":"Kelime pozisyonuna göre çıkarma","text":"n’inci ’kelime’yi çıkarmak için, yine stringr paketinden word() fonksiyonunu kullanabilirsiniz. Fonksiyonu kullanabilmek için dizeyi, ardından ayıklanacak ilk sözcük konumunu ve ayıklanacak son sözcük konumunu tanımlamanız gerekmektedir.Varsayılan olarak, sep = ile aksi belirtilmedikçe ‘kelimeler’ arasındaki ayırıcının bir boşluk olduğu varsayılır (örneğin, kelimeler alt çizgilerle ayrıldığında sep = \"_\".","code":"\n# dizeleri değerlendirme\nchief_complaints <- c(\"I just got out of the hospital 2 days ago, but still can barely breathe.\",\n                      \"My stomach hurts\",\n                      \"Severe ear pain\")\n\n# her dizenin 1. ila 3. kelimelerin arasını ayır\nword(chief_complaints, start = 1, end = 3, sep = \" \")## [1] \"I just got\"       \"My stomach hurts\" \"Severe ear pain\""},{"path":"karakterler-ve-dizeler.html","id":"karakteri-pozisyonuna-göre-değiştirme","chapter":"10 Karakterler ve dizeler","heading":"Karakteri pozisyonuna göre değiştirme","text":"Atama operatörüyle (<-) eşleştirilen str_sub() fonksiyonu, bir dizenin bir bölümünü değiştirmek için kullanılabilir:Birden çok dizeye uygulanan bir örnek (örneğin bir sütun). “HIV” uzunluğundaki genişlemeye dikkat edin.","code":"\nword <- \"pneumonia\"\n\n# üçüncü ve dördüncü karakterleri X'e dönüştür\nstr_sub(word, 3, 4) <- \"XX\"\n\n# print\nword## [1] \"pnXXmonia\"\nwords <- c(\"pneumonia\", \"tubercolosis\", \"HIV\")\n\n# üçüncü ve dördüncü karakterleri X'e dönüştür\nstr_sub(words, 3, 4) <- \"XX\"\n\nwords## [1] \"pnXXmonia\"    \"tuXXrcolosis\" \"HIXX\""},{"path":"karakterler-ve-dizeler.html","id":"uzunluğu-değerlendirme","chapter":"10 Karakterler ve dizeler","heading":"Uzunluğu değerlendirme","text":"Alternatif olarak, R tabanından nchar() fonksiyonu kullanabilirsiniz.","code":"\nstr_length(\"abc\")## [1] 3"},{"path":"karakterler-ve-dizeler.html","id":"paternler","chapter":"10 Karakterler ve dizeler","heading":"10.5 Paternler","text":"Birçok stringr fonksiyonu, belirli bir paterne göre algılamak, bulmak, ayıklamak, eşleştirmek, değiştirmek ve bölmek için kullanılabilir.","code":""},{"path":"karakterler-ve-dizeler.html","id":"patern-bulma","chapter":"10 Karakterler ve dizeler","heading":"Patern bulma","text":"Bir dize içindeki bir kalıbın varlığını/yokluğunu algılamak için aşağıdaki gibi str_detect() fonksiyonunu kullanabilirsiniz. Önce aranacak dizeyi veya vektörü (string =) ve sonra aranacak modeli (pattern =) belirlemeniz gerekmektedir. Varsayılan olarak aramanın büyük/küçük harf duyarlı olduğunu unutmayın!Desenin mevcut olup olmadığını bilmek istiyorsanız, negate = argümanı eklenebilir ve TRUE olarak ayarlanabilir.Büyük/küçük harf kullanımını yok saymak için, kalıbı regex() içine sarın ve regex() komutu içinde, ignore_case = TRUE (veya T) argümanını ekleyin.Bir karakter vektörüne veya bir veri çerçevesi sütununa str_detect() uygulandığında, değerlerin biri için DOĞRU veya YANLIŞ sonucunu döndürür.“DOĞRU”ları saymanız gerekiyorsa, çıktıyı sum() fonksiyonu içine almanız yeterlidir. Bu, “DOĞRU” çıktıların sayısını verir.Birden çok terimi aramak için, bunları aşağıda gösterildiği gibi ‘pattern =’ bağımsız değişkenine VEYA çubukları (|) ile ayırarak ekleyin:Uzun bir arama terimleri listesi oluşturmanız gerekiyorsa, bunları str_c() ve sep = | kullanarak birleştirebilir ardından bunun bir karakter nesnesi olarak tanımlayabilir ve daha sonrasında vektör formatında arayabilirsiniz. Aşağıdaki örnek, birinci basamak sağlık çalışanları için olası meslek arama terimlerini içermektedir.Aşağıdaki komut, birinci basamak sağlık çalışanları (occupation_med_frontline) için arama terimlerinden herhangi birini içeren mesleklerin sayısını döndürür:R tabanı dizin arama işlevleriR tabanı fonksiyonu olan grepl(), str_detect() fonksiyonuna benzer bir şekilde çalışır. Çünkü o da bir modelle eşleşmeleri arar ve mantıksal bir vektör döndürür. Temel sözdizimi grepl(pattern, strings_to_search, ignore.case = FALSE, ...) şeklindedir. Avantajlardan biri, ignore.case argümanını yazmanın daha kolay olmasıdır (regex() fonksiyonunu dahil etmeye gerek yoktur).Benzer şekilde, R tabanı fonksiyonları olan sub() ve gsub(), str_replace()benzer şekilde hareket eder. Temel sözdizimleri şöyledir: gsub(pattern, replace, strings_to_search, ignore.case = FALSE). sub() kalıbın ilk örneğini değiştirirken, gsub() kalıbın tüm örneklerini değiştirir.","code":"\nstr_detect(string = \"primary school teacher\", pattern = \"teach\")## [1] TRUE\nstr_detect(string = \"primary school teacher\", pattern = \"teach\", negate = TRUE)## [1] FALSE\nstr_detect(string = \"Teacher\", pattern = regex(\"teach\", ignore_case = T))## [1] TRUE\n# bir meslek vektörü/sütunu \noccupations <- c(\"field laborer\",\n                 \"university professor\",\n                 \"primary school teacher & tutor\",\n                 \"tutor\",\n                 \"nurse at regional hospital\",\n                 \"lineworker at Amberdeen Fish Factory\",\n                 \"physican\",\n                 \"cardiologist\",\n                 \"office worker\",\n                 \"food service\")\n\n# Her dizede \"teach\" kalıbının varlığını tespit et - çıktı DOĞRU/YANLIŞ vektörüdür\nstr_detect(occupations, \"teach\")##  [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\nsum(str_detect(occupations, \"teach\"))## [1] 1\nsum(str_detect(string = occupations, pattern = \"teach|professor|tutor\"))## [1] 3\n# search terms\noccupation_med_frontline <- str_c(\"medical\", \"medicine\", \"hcw\", \"healthcare\", \"home care\", \"home health\",\n                                \"surgeon\", \"doctor\", \"doc\", \"physician\", \"surgery\", \"peds\", \"pediatrician\",\n                               \"intensivist\", \"cardiologist\", \"coroner\", \"nurse\", \"nursing\", \"rn\", \"lpn\",\n                               \"cna\", \"pa\", \"physician assistant\", \"mental health\",\n                               \"emergency department technician\", \"resp therapist\", \"respiratory\",\n                                \"phlebotomist\", \"pharmacy\", \"pharmacist\", \"hospital\", \"snf\", \"rehabilitation\",\n                               \"rehab\", \"activity\", \"elderly\", \"subacute\", \"sub acute\",\n                                \"clinic\", \"post acute\", \"therapist\", \"extended care\",\n                                \"dental\", \"dential\", \"dentist\", sep = \"|\")\n\noccupation_med_frontline## [1] \"medical|medicine|hcw|healthcare|home care|home health|surgeon|doctor|doc|physician|surgery|peds|pediatrician|intensivist|cardiologist|coroner|nurse|nursing|rn|lpn|cna|pa|physician assistant|mental health|emergency department technician|resp therapist|respiratory|phlebotomist|pharmacy|pharmacist|hospital|snf|rehabilitation|rehab|activity|elderly|subacute|sub acute|clinic|post acute|therapist|extended care|dental|dential|dentist\"\nsum(str_detect(string = occupations, pattern = occupation_med_frontline))## [1] 2"},{"path":"karakterler-ve-dizeler.html","id":"virgülleri-noktalara-dönüştürme","chapter":"10 Karakterler ve dizeler","heading":"Virgülleri noktalara dönüştürme","text":"Burada, bir sayı vektöründe virgülleri noktalara dönüştürmek için gsub() kullanımına örnek verilmiştir. Bu durum özellikle verileriniz Amerika Birleşik Devletleri veya İngiltere dışındaki ülkelerden geliyorsa faydalı olabilir.İlk olarak “lengths” üzerinde etkili olan komutun içindeki gsub() fonksiyonu, herhangi bir noktayı boşluksuz “” değerine dönüştürmektedir (silmektedir). Noktayı doğru tanımlamak için başına iki eğik çizgi “eklenmesi” gerekir çünkü normal “.” ifadesi “herhangi bir karakter” anlamına gelir. Ardından, sonuç (yalnızca virgülle), virgüllerin noktalarla değiştirildiği dış gsub() komutuna iletilir.","code":"\nlengths <- c(\"2.454,56\", \"1,2\", \"6.096,5\")\n\nas.numeric(gsub(pattern = \",\",                # virgülleri bul     \n                replacement = \".\",            # nokta ile değiştir\n                x = gsub(\"\\\\.\", \"\", lengths)  # binlik değerlerdeki noktaları kaldır\n                )\n           )                                  # çıktıyı sayısal bir değer olarak tanımla"},{"path":"karakterler-ve-dizeler.html","id":"tamamını-değiştirme","chapter":"10 Karakterler ve dizeler","heading":"Tamamını değiştirme","text":"“Bul ve değiştir” aracı olarak str_replace_all() kullanabilirsiniz. İlk Önce, string = olarak değerlendirilecek dizeleri, sonra değiştirilecek kalıbı pattern = olarak ve ardından değiştirme değerini replacement = olarak tanımlamanız gerekmektedir. Aşağıdaki örnek, tüm “dead” örneklerini “deceased” ile değiştirmektedir. Bu komuttaki argümanların büyük/küçük harfe duyarlı olduğunu unutmayın.Notlar:Paternleri NA olarak değiştirmek için str_replace_na() fonksiyonunu kullanın.str_replace() fonksiyonu bir dizedeki sadece ilk paterni değiştirir, diğerlerini değiştirmez.","code":"\noutcome <- c(\"Karl: dead\",\n            \"Samantha: dead\",\n            \"Marco: not dead\")\n\nstr_replace_all(string = outcome, pattern = \"dead\", replacement = \"deceased\")## [1] \"Karl: deceased\"      \"Samantha: deceased\"  \"Marco: not deceased\""},{"path":"karakterler-ve-dizeler.html","id":"mantığa-göre-arama","chapter":"10 Karakterler ve dizeler","heading":"Mantığa göre arama","text":"case_when() fonksiyonuylastr_detect() genellikle case_while() içinde kullanılır (dplyr paketinden). occupationsın satır listesindeki bir sütun olduğunu varsayalım. Aşağıda mutate(), case_while() fonksiyonları aracılığıyla koşullu mantığı kullanarak is_educator adında yeni bir sütun oluşturmaktayız. case_while() hakkında daha fazla bilgi edinmek için veri temizleme sayfasına bakabilirsiniz.Bir hatırlatma olarak, koşullu mantığa dışlama kriterlerini(negate = F) eklemeniz işinizi kolaylaştırabilir:","code":"\ndf <- df %>% \n  mutate(is_educator = case_when(\n    # meslek içinde terim arama, büyük/küçük harfe duyarlı değil\n    str_detect(occupations,\n               regex(\"teach|prof|tutor|university\",\n                     ignore_case = TRUE))              ~ \"Educator\",\n    # diğerleri\n    TRUE                                               ~ \"Not an educator\"))df <- df %>% \n  # is_educator yeni sütunundaki değer koşullu mantığa dayalıdır\n  mutate(is_educator = case_when(\n    \n    # Meslek sütununun \"Educator\" olarak atanabilmesi için 2 kriteri karşılaması gerekir:\n    # bir arama terimine sahip olmalı VE herhangi bir dışlama terimi olmamalı\n    \n    # Bir arama terimi içermeli\n    str_detect(occupations,\n               regex(\"teach|prof|tutor|university\", ignore_case = T)) &              \n    \n    # VE bir dışlama terimi İÇERMEMELİDİR\n    str_detect(occupations,\n               regex(\"admin\", ignore_case = T),\n               negate = TRUE                        ~ \"Educator\"\n    \n    # Yukarıdaki kriterlere uymayan tüm satırlar\n    TRUE                                            ~ \"Not an educator\"))"},{"path":"karakterler-ve-dizeler.html","id":"patern-konumunu-bulma","chapter":"10 Karakterler ve dizeler","heading":"Patern konumunu bulma","text":"Bir paternin ilk konumunu bulmak için str_locate() kullanabilirsiniz. Fonksiyon çıktı olarak bir başlangıç ve bitiş konumu verir.Diğer str fonksiyonları gibi, dizede paterni karşılayan bütün örneklerin konumlarını döndürecek bir “_all” versiyonu (str_locate_all()) mevcuttur. Bu fonksiyon bir liste çıktısı verir.","code":"\nstr_locate(\"I wish\", \"sh\")##      start end\n## [1,]     5   6\nphrases <- c(\"I wish\", \"I hope\", \"he hopes\", \"He hopes\")\n\nstr_locate(phrases, \"h\" )     # paternin *ilk* örneğinin konumu##      start end\n## [1,]     6   6\n## [2,]     3   3\n## [3,]     1   1\n## [4,]     4   4\nstr_locate_all(phrases, \"h\" ) # paternin *her* örneğinin konumu## [[1]]\n##      start end\n## [1,]     6   6\n## \n## [[2]]\n##      start end\n## [1,]     3   3\n## \n## [[3]]\n##      start end\n## [1,]     1   1\n## [2,]     4   4\n## \n## [[4]]\n##      start end\n## [1,]     4   4"},{"path":"karakterler-ve-dizeler.html","id":"eşleşeni-çıkarma","chapter":"10 Karakterler ve dizeler","heading":"Eşleşeni çıkarma","text":"str_extract_all() eşleşen kalıpların kendisini döndürür; bu fonksiyon, “VEYA” koşulları aracılığıyla birkaç kalıp önerdiğinizde en kullanışlı seçenektir. Örnek olarak, “teach”, “prof” veya “tutor” paternleri için meslekler vektörünü (önceki sekmeye bakın) inceleyebilirsiniz.str_extract_all(), değerlendirilen dize için tüm eşleşmeleri içeren bir “liste” döndürür. Aşağıda, meslek vektörü içinde 3 paternin nasıl eşleştiğini görebilirsiniz.str_extract(), değerlendirilen dizede yalnızca ilk eşleşmeyi ortaya çıkararak, değerlendirilen dize için bir elemanlı bir karakter vektörü üretir. Eşleşmenin olmadığı yerde NA sonucunu döndürür. NAlar, döndürülen vektör na.exclude() fonksiyonu ile sarılarak kaldırılabilir. Çıkan sonuçta ikincisinin nasıl gösterilmediğine dikkat ediniz.","code":"\nstr_extract_all(occupations, \"teach|prof|tutor\")## [[1]]\n## character(0)\n## \n## [[2]]\n## [1] \"prof\"\n## \n## [[3]]\n## [1] \"teach\" \"tutor\"\n## \n## [[4]]\n## [1] \"tutor\"\n## \n## [[5]]\n## character(0)\n## \n## [[6]]\n## character(0)\n## \n## [[7]]\n## character(0)\n## \n## [[8]]\n## character(0)\n## \n## [[9]]\n## character(0)\n## \n## [[10]]\n## character(0)\nstr_extract(occupations, \"teach|prof|tutor\")##  [1] NA      \"prof\"  \"teach\" \"tutor\" NA      NA      NA      NA      NA      NA"},{"path":"karakterler-ve-dizeler.html","id":"alt-küme-ve-sayı","chapter":"10 Karakterler ve dizeler","heading":"Alt küme ve sayı","text":"Bu başlıktaki fonksiyonlar arasında str_subset() ve str_count() bulunmaktadır.str_subset() fonksiyonu paterni içeren gerçek değerleri döndürür:str_count() bir sayı vektörü döndürür: Değerlendirilen değerde bir arama teriminin göründüğü miktar.","code":"\nstr_subset(occupations, \"teach|prof|tutor\")## [1] \"university professor\"           \"primary school teacher & tutor\" \"tutor\"\nstr_count(occupations, regex(\"teach|prof|tutor\", ignore_case = TRUE))##  [1] 0 1 2 1 0 0 0 0 0 0"},{"path":"karakterler-ve-dizeler.html","id":"regex-grupları","chapter":"10 Karakterler ve dizeler","heading":"Regex grupları","text":"HAZIRLANIYOR","code":""},{"path":"karakterler-ve-dizeler.html","id":"özel-karakterler","chapter":"10 Karakterler ve dizeler","heading":"10.6 Özel karakterler","text":"Ters eğik çizgi \\Ters eğik çizgi \\ sonrasındaki karakteri “yok saymak” için kullanılır. Bu şekilde, diğer tırnak işaretleri (\\\") içinde olan bir alıntı işaretini görüntülemek için bir ters eğik çizgi kullanılabilir - ortadaki alıntı işareti, çevreleyen alıntı işaretlerini “iptal etmez”.- bu nedenle, bir ters eğik çizgi görüntülemek istiyorsanız için iki ters eğik çizgi \\\\ yazmalısınız.Özel KarakterlerBu özel karakterlerin tam listesini görüntülemek için R Konsolunda ?\"'\" komutunu çalıştırabilirsiniz (RStudio Yardım bölmesinde görünecektir).","code":""},{"path":"karakterler-ve-dizeler.html","id":"düzenli-ifadeler-regex","chapter":"10 Karakterler ve dizeler","heading":"10.7 Düzenli ifadeler (regex)","text":"","code":""},{"path":"karakterler-ve-dizeler.html","id":"regex-ve-özel-karakterler","chapter":"10 Karakterler ve dizeler","heading":"10.8 Regex ve özel karakterler","text":"Düzenli ifadeler veya “regex”, dizelerdeki kalıpları açıklamak için kısa bir dildir. Eğer aşina değilseniz, düzenli ifadeler yabancı bir dil gibi görünebilir. Burada bu dili biraz gizeminden arındırmaya çalışacağız.Bölümün çocuğu bu rehberden alınmıştır cheatsheet. Bu el kitabının internet erişimi olmayan kişiler tarafından da görüntülenebileceğini ön görülerek burada önemli olanları paylaşıyoruz.“Yapılandırılmamış” metinden belirli kalıplarını çıkarmak için genellikle düzenli bir ifade uygulanır - örneğin tıbbi notlar, hasta şikayetleri, geçmişi veya bir veri çerçevesindeki diğer serbest metin sütunları.Temel bir düzenli ifade oluşturmak için kullanılabilecek dört araç vardır:Karakter setleriMeta karakterlerNiceleyicilerGrouplarKarakter setleriKarakter setleri, bir karakter eşleşmesi için köşeli parantez içinde listeleme seçeneklerini ifade etmenin bir yoludur. Bu nedenle, köşeli parantez içindeki karakterlerden herhangi biri dizede bulunursa eşleşme tetiklenir. Örneğin, sesli harfleri aramak için şu karakter seti kullanılabilir: “[aeiou]”. Diğer bazı yaygın karakter setleri şunlardır:Karakter setleri, \"[-Za-z]\" (herhangi bir büyük veya küçük harf) veya başka bir örnek \"[t-z0-5]\" gibi tek bir parantez içinde (boşluksuz!) birleştirilebilir ( t’den z’ye kadar küçük harf VEYA 0’dan 5’e kadar sayılar).Meta karakterlerMeta karakterler, karakter setlerinin kısaltmasıdır. Önemli olanlardan bazıları aşağıda listelenmiştir:NiceleyicilerGenellikle tek bir karakterde eşleşme aramak istemezsiniz. Niceleyiciler, eşleşmeye izin vermek için harflerin/sayıların uzunluğunu belirlemenize olanak tanır.Niceleyiciler, nicelleştirdikleri karakterin sonrasında olan { } küme parantezleri içinde yazılan sayılardır, örneğin,\"{2}\" iki büyük harfinin örneklerini döndürür.\"{2,4}\" iki ile dört arasında büyük harfi (boşluk koymayın!) örneklerini döndürür.\"{2,}\" iki veya daha fazla büyük harfinin örneklerini döndürür.\"+\" bir veya daha fazla büyük harfinin örneklerini döndürür (farklı bir karakterle karşılaşılıncaya kadar uzatılan grup).Sıfır veya daha fazla eşleşme döndürmek için bir * yıldız işareti ile başlayın (paternin mevcut olduğundan emin değilseniz kullanışlıdır)Nicelik belirteci olarak ‘+’ artı sembolü kullanıldığında, farklı bir karakterle karşılaşılıncaya kadar eşleşme gerçekleşir. Örneğin, bu ifade tüm kelimeleri (alfa karakterleri: \"[-Za-z]+\") döndürür.{2} niceleyicisi kullanıldığında, yalnızca ardışık çiftleri döndürülür. “AAAA” içinde iki çift tanımlanmıştır.{2,4} niceleyicisi kullanıldığında, uzunluğu iki ila dört olan ardışık grupları döndürülebilir.“+” niceleyicisiyle, bir veya daha fazla gruplar döndürülebilir:Relatif pozisyonRelatif pozisyon, bir kalıptan önce gelen veya onu izleyen bir kalıba göre konumu ifade eder. Örneğin, cümleleri çıkarmak için “sonunda bir nokta bulunan iki sayı” (\"\"). (?<=\\.)\\s(?=[-Z])GruplarDüzenli ifadelerinizde grupları yakalamak, çıkarma işlemi sonrasında daha organize bir çıktı elde etmenin bir yoludur.Regex örnekleriAşağıda örnekler için serbest bir metin bulunmaktadır. Bir düzenli ifade arama terimi kullanarak ondan faydalı bilgiler çıkarmaya çalışacağız.Bu ifade tüm kelimelerle (boşluk gibi karakter olmayan bir karaktere ulaşana kadar herhangi bir karakter) eşleşir:\"[0-9]{1,2}\" ifadesi, 1 veya 2 basamak uzunluğunda ardışık sayılarla eşleşir. Ayrıca \"\\\\d{1,2}\" veya \"[:digit:]{1,2}\" şeklinde de yazılabilir.Bu kopya kağıdının 2. sayfasında, normal ifadelerin ve ipuçlarının faydalı bir listesini görüntüleyebilirsiniz.Ayrıca bu rehbere bakabilirsiniz.","code":"\n# niceleyiciler için test dizisi\ntest <- \"A-AA-AAA-AAAA\"\nstr_extract_all(test, \"A{2}\")## [[1]]\n## [1] \"AA\" \"AA\" \"AA\" \"AA\"\nstr_extract_all(test, \"A{2,4}\")## [[1]]\n## [1] \"AA\"   \"AAA\"  \"AAAA\"\nstr_extract_all(test, \"A+\")## [[1]]\n## [1] \"A\"    \"AA\"   \"AAA\"  \"AAAA\"\nstr_extract_all(test, \"\")## [[1]]\n##  [1] \"A\" \"-\" \"A\" \"A\" \"-\" \"A\" \"A\" \"A\" \"-\" \"A\" \"A\" \"A\" \"A\"\npt_note <- \"Patient arrived at Broward Hospital emergency ward at 18:00 on 6/12/2005. Patient presented with radiating abdominal pain from LR quadrant. Patient skin was pale, cool, and clammy. Patient temperature was 99.8 degrees farinheit. Patient pulse rate was 100 bpm and thready. Respiratory rate was 29 per minute.\"\nstr_extract_all(pt_note, \"[A-Za-z]+\")## [[1]]\n##  [1] \"Patient\"     \"arrived\"     \"at\"          \"Broward\"     \"Hospital\"    \"emergency\"   \"ward\"        \"at\"         \n##  [9] \"on\"          \"Patient\"     \"presented\"   \"with\"        \"radiating\"   \"abdominal\"   \"pain\"        \"from\"       \n## [17] \"LR\"          \"quadrant\"    \"Patient\"     \"skin\"        \"was\"         \"pale\"        \"cool\"        \"and\"        \n## [25] \"clammy\"      \"Patient\"     \"temperature\" \"was\"         \"degrees\"     \"farinheit\"   \"Patient\"     \"pulse\"      \n## [33] \"rate\"        \"was\"         \"bpm\"         \"and\"         \"thready\"     \"Respiratory\" \"rate\"        \"was\"        \n## [41] \"per\"         \"minute\"\nstr_extract_all(pt_note, \"[0-9]{1,2}\")## [[1]]\n##  [1] \"18\" \"00\" \"6\"  \"12\" \"20\" \"05\" \"99\" \"8\"  \"10\" \"0\"  \"29\""},{"path":"karakterler-ve-dizeler.html","id":"kaynaklar-3","chapter":"10 Karakterler ve dizeler","heading":"10.9 Kaynaklar","text":"stringr işlevleri için bir referans sayfası burada bulunabilirstringr ile ilgili bir gösterim burada bulunabilir","code":""},{"path":"faktörler.html","id":"faktörler","chapter":"11 Faktörler","heading":"11 Faktörler","text":"R’da faktörler, sabit, kabul edilebilir değerler kümesiyle sıralı kategorilere izin veren bir veri sınıfıdır.Tipik olarak, değerleri (“levels”), grafik ve tablolarda alfabetik olmayan bir şekilde görüntülenebilmeleri için özel bir sıralamaya tabi tutmak isterseniz bir sütunu karakter veya sayısal sınıftan bir faktöre dönüştürmeniz gerekir. Faktörlerin diğer bir yaygın kullanımı, verilerin geçici olarak yok olması nedeniyle oluşabilecek dalgalanmamaları engellemek için grafik açıklamalarını standart hale getirmektir.Bu sayfa, forcats (“ve kategorik değişkenler” için kısa bir ad) paketi ve bazı R tabanındaki fonkisyonların kullanımını göstermektedir. Epidemiyolojik haftalarla ilgili özel faktör vakaları için lubridat ve aweek kullanımına da değiniyoruz.forcats fonksiyonlarının tam listesi çevrimiçi olarak burada bulunabilir. Aşağıda en yaygın olanlardan bazılarını gösteriyoruz.","code":""},{"path":"faktörler.html","id":"hazırlık-2","chapter":"11 Faktörler","heading":"11.1 Hazırlık","text":"","code":""},{"path":"faktörler.html","id":"paketlerin-yüklenmesi-1","chapter":"11 Faktörler","heading":"Paketlerin yüklenmesi","text":"Aşağıdaki kod parçası, analizler için gereken paketlerin yüklenmesini göstermektedir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() vurgulamaktayız. R tabanından library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] sayfasına bakın.","code":"\npacman::p_load(\n  rio,           # içe/dışa aktar\n  here,          # dosya yolu\n  lubridate,     # tarihlerle çalışma\n  forcats,       # faktörler\n  aweek,         # otomatik faktör seviyeleri ile epiweeks oluştur\n  janitor,       # tablolar\n  tidyverse      # data yönetim ve görselleştirmesi\n  )"},{"path":"faktörler.html","id":"veriyi-içe-aktarma","chapter":"11 Faktörler","heading":"Veriyi içe aktarma","text":"Simüle edilmiş bir Ebola salgınına ait vakaların veri setini içe aktarıyoruz. Takip etmek isterseniz, “temiz satır listesi” dosyasını indirmek için tıklayın. (.rds dosyası olarak). Verilerinizi rio paketinden import() işleviyle içe aktarın (.xlsx, .rds, .csv gibi birçok dosya türünü kabul eder - ayrıntılar için [İçe ve dışa aktarma] sayfasına bakın).","code":"\n# veri setini indir\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"faktörler.html","id":"fct_newcat","chapter":"11 Faktörler","heading":"Yeni kategorik değişken","text":"Bu sayfada gösterim için ortak bir senaryo kullanacağız - yeni bir kategorik değişkenin oluşturulması.Sayısal bir sütunu sınıf faktörüne dönüştürürseniz, bunun üzerinde sayısal istatistikleri hesaplayamayacağınızı unutmayın.","code":""},{"path":"faktörler.html","id":"sütun-oluşturma","chapter":"11 Faktörler","heading":"Sütun oluşturma","text":"Biz, mevcut days_onset_hosp sütununu (semptom başlangıcından hastaneye kabule kadar geçen gün) kullanarak satırı birkaç kategoriden birine sınıflandırıp yeni bir delay_cat sütunu oluşturuyoruz. Bunu, satıra sırayla mantıksal ölçütleri (sağ taraf) uygulayan ve yeni delay_cat sütununa karşılık gelen sol taraf değerini döndüren, dplyr paktenin fonksiyonu case_when() ile yapıyoruz. [Temizleme verileri ve temel işlevler] bölümünde case_when() hakkında daha fazla bilgi edinebilirsiniz.","code":"\nlinelist <- linelist %>% \n  mutate(delay_cat = case_when(\n    # criteria                                   # eğer doğruysa yeni değer\n    days_onset_hosp < 2                        ~ \"<2 days\",\n    days_onset_hosp >= 2 & days_onset_hosp < 5 ~ \"2-5 days\",\n    days_onset_hosp >= 5                       ~ \">5 days\",\n    is.na(days_onset_hosp)                     ~ NA_character_,\n    TRUE                                       ~ \"Check me\"))  "},{"path":"faktörler.html","id":"varsayılan-değer-sırası","chapter":"11 Faktörler","heading":"Varsayılan değer sırası","text":"case_when() ile oluşturulduğu gibi, yeni delay_cat sütunu, karakter sınıfının kategorik bir sütunudur - henüz bir faktör değildir. Bu nedenle, bir sıklık tablosunda, benzersiz değerlerin varsayılan bir alfa-numerik düzende sıralandığını görüyoruz - bu, sezgisel olarak pek mantıklı olmayan bir sıradır:Benzer şekilde, bir çubuk grafiği yaparsak, değerler de x ekseninde bu sırayla görünür (R’deki en yaygın görselleştirme paketi olan ggplot2 hakkında daha fazla bilgi için ggplot temelleri sayfasına bakın).","code":"\ntable(linelist$delay_cat, useNA = \"always\")## \n##  <2 days  >5 days 2-5 days     <NA> \n##     2990      602     2040      256\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = delay_cat))"},{"path":"faktörler.html","id":"faktöre-dönüştürme","chapter":"11 Faktörler","heading":"11.2 Faktöre dönüştürme","text":"Bir karakteri veya sayısal sütunu faktör sınıfına dönüştürmek için, forcats paketindeki herhangi bir fonksiyonu kullanabilirsiniz (birçoğu aşağıda ayrıntılı olarak verilmiştir). Bu fonksiyonlarla veriler sınıf faktörüne dönüşecek ve daha sonra seviyelerin belirli şekilde sıralanmasını gerçekleşecek veya buna izin verilecek - örneğin fct_relevel() kullanmak seviye sırasını manuel olarak belirlemenizi sağlar. as_factor() fonksiyonu, başka bir özellik eklemeden sınıfı basitçe dönüştürür.R tabanı fonksiyonu olan factor(), bir sütunu faktöre dönüştürür ve karakter vektöründeki levels = argümanına göre seviyelerin sırasını manuel olarak düzenlemenizi sağlar.Aşağıda, delay_cat sütununu sınıf karakterinden sınıf faktörüne dönüştürmek için mutate() ve fct_relevel() kullanıyoruz. delay_cat sütunu, yukarıdaki Hazırlık bölümünde oluşturulmuştur.unique “values” column now considered “levels” factor. levels order, can printed base R function levels(), alternatively viewed count table via table() base R tabyl() janitor. default, order levels alpha-numeric, . Note NA factor level.fct_relevel() fonksiyonu, seviye sırasını manuel olarak belirlemenize izin veren ek bir özelliğe sahiptir. Düzey değerlerini, aşağıda gösterildiği gibi virgülle ayırarak sırayla, tırnak içinde yazmanız yeterlidir. Yazımın değerlerle tam olarak eşleşmesi gerektiğini unutmayın. Verilerde mevcut olmayan düzeyler oluşturmak istiyorsanız, bunun yerine fct_expand() kullanın).Artık seviyelerin bir önceki komutta belirtildiği gibi mantıklı bir sırayla sıralandığını görebiliriz.Şimdi tablodaki sırası da daha sezgisel bir anlam ifade ediyor.","code":"\nlinelist <- linelist %>%\n  mutate(delay_cat = fct_relevel(delay_cat))\nlevels(linelist$delay_cat)## [1] \"<2 days\"  \">5 days\"  \"2-5 days\"\nlinelist <- linelist %>%\n  mutate(delay_cat = fct_relevel(delay_cat, \"<2 days\", \"2-5 days\", \">5 days\"))\nlevels(linelist$delay_cat)## [1] \"<2 days\"  \"2-5 days\" \">5 days\"\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = delay_cat))"},{"path":"faktörler.html","id":"seviye-ekleme-ve-çıkarma","chapter":"11 Faktörler","heading":"11.3 Seviye ekleme ve çıkarma","text":"","code":""},{"path":"faktörler.html","id":"fct_add","chapter":"11 Faktörler","heading":"Ekleme","text":"Bir faktöre seviye eklemeniz gerekiyorsa, bunu fct_expand() ile yapabilirsiniz. Sütun adını ve ardından yeni seviyeleri (virgülle ayırarak) yazmanız yeterlidir. Değerleri tablolaştırarak yeni seviyeleri ve sıfır sayılarını görebiliriz. R tabanından table()ı veya janitor’dan tabyl() kullanabilirsiniz:: Eksik değerleri (NA) seviyelere kolayca eklemek için özel bir forcats fonksiyonu mevcuttur. Aşağıdaki Eksik değerler ile ilgili bölüme bakın.","code":"\nlinelist %>% \n  mutate(delay_cat = fct_expand(delay_cat, \"Not admitted to hospital\", \"Transfer to other jurisdiction\")) %>% \n  tabyl(delay_cat)   # print table##                       delay_cat    n    percent valid_percent\n##                         <2 days 2990 0.50781250     0.5308949\n##                        2-5 days 2040 0.34646739     0.3622159\n##                         >5 days  602 0.10224185     0.1068892\n##        Not admitted to hospital    0 0.00000000     0.0000000\n##  Transfer to other jurisdiction    0 0.00000000     0.0000000\n##                            <NA>  256 0.04347826            NA"},{"path":"faktörler.html","id":"çıkarma","chapter":"11 Faktörler","heading":"Çıkarma","text":"fct_drop()ı kullanırsanız, sıfır sayımlı “kullanılmayan” seviyeler, seviyeler grubundan çıkarılacaktır. Yukarıda eklediğimiz seviyeler (“Hastaneye kabul edilmedi”) bir seviye olarak mevcuttur, ancak hiçbir satır aslında bu değere sahip değildir. Böylece, faktör sütunumuza fct_drop() uygulanarak çıkarılır:","code":"\nlinelist %>% \n  mutate(delay_cat = fct_drop(delay_cat)) %>% \n  tabyl(delay_cat)##  delay_cat    n    percent valid_percent\n##    <2 days 2990 0.50781250     0.5308949\n##   2-5 days 2040 0.34646739     0.3622159\n##    >5 days  602 0.10224185     0.1068892\n##       <NA>  256 0.04347826            NA"},{"path":"faktörler.html","id":"fct_adjust","chapter":"11 Faktörler","heading":"11.4 Seviye sırasını düzenleme","text":"forcats paketi, faktör düzeylerinin sırasını kolayca ayarlamak için kullanışlı fonksiyonlar da sunar (bir sütun sınıf faktörü olarak tanımlandıktan sonra):Bu fonksiyonlar, iki bağlamda faktör sütununa uygulanabilir:zamanki gibi veri çerçevesindeki sütuna uygulanır, böylece değişen veriler daha sonra da kullanılabilirBir grafik içine uygulanabilir, böylece değişiklik sadece grafik içinde kalır","code":""},{"path":"faktörler.html","id":"elle-düzenleme","chapter":"11 Faktörler","heading":"Elle düzenleme","text":"Bu fonksiyon, faktör seviyelerini manuel olarak sıralamak için kullanılır. Faktör olmayan bir sütunda kullanılırsa, sütun önce sınıf faktörüne dönüştürülür.Parantez içinde önce faktör sütun adını girin, ardından aşağıdakilerden birini sağlayın:Tüm seviyeleri istenen sırada (karakter vektörü c() olarak) veyaBir seviye ve = argümanı kullanılarak düzeltilmiş sıralamaBurada, (zaten Faktör sınıfı olan) delay_cat sütununu yeniden tanımlamaya ve istenen tüm düzey sırasını belirtmeye bir örnek verilmiştir.Sadece bir seviyeyi taşımak istiyorsanız, bunu tek başına fct_relevel() olarak belirtebilir ve = argümanına hangi sırada olması gerektiğini belirtmek için sayı verebilirsiniz. Örneğin, aşağıdaki komut “<2 gün” ifadesini ikinci konuma kaydırır:","code":"\n# seviye sırasını yeniden düzenle\nlinelist <- linelist %>% \n  mutate(delay_cat = fct_relevel(delay_cat, c(\"<2 days\", \"2-5 days\", \">5 days\")))\n# seviye sırasını yeniden düzenle\nlinelist %>% \n  mutate(delay_cat = fct_relevel(delay_cat, \"<2 days\", after = 1)) %>% \n  tabyl(delay_cat)"},{"path":"faktörler.html","id":"grafik-içinde","chapter":"11 Faktörler","heading":"Grafik içinde","text":"forcats komutları, veri çerçevesinde veya yalnızca bir grafik içinde seviye sırasını ayarlamak için kullanılabilir. Sütun adını grafik içinde ggplot()un “sarma” komutunu kullanarak, tersine çevirebilir veya yeniden seviyelendirebilirsiniz. Değişim yalnızca bu grafik için geçerli olacaktır.Aşağıda, ggplot() ile iki grafik oluşturulmuştur (ggplot temelleri sayfasına bakın). İlkinde, delay_cat sütunu, “satır listesi” verisinde olduğu gibi varsayılan düzey sırası ile grafiğin x eksenine eşlenir. İkinci örnekte fct_relevel() içine sarılmış ve grafikteki sırası değiştirilmiştir.Varsayılan x ekseni başlığının oldukça karmaşık olduğuna dikkat edin - bu başlığı ggplot2 labs() argümanı ile değiştirebilirsiniz.","code":"\n# Alfa-numerik varsayılan sıra - ggplot'ta düzenleme yapılmadı\nggplot(data = linelist)+\n    geom_bar(mapping = aes(x = delay_cat))\n\n# ggplot içinde faktör seviyesi düzenlendi\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = fct_relevel(delay_cat, c(\"<2 days\", \"2-5 days\", \">5 days\"))))"},{"path":"faktörler.html","id":"tersine-döndürme","chapter":"11 Faktörler","heading":"Tersine döndürme","text":"Seviye sırasını tersine çevirmek işlemi oldukça yaygındır. Faktörü fct_rev() ile sarmanız yeterlidir.Gerçek faktör seviyelerini değil de yalnızca bir grafiğin açıklamasını tersine çevirmek istiyorsanız, bunu guides() ile yapabileceğinizi unutmayın (bkz. ggplot ipuçları).","code":""},{"path":"faktörler.html","id":"sıklığa-göre","chapter":"11 Faktörler","heading":"Sıklığa göre","text":"Değerleri verilerde görünme sıklığına göre sıralamak için fct_infreq() kullanın. Eksik değerler (NA), açık bir düzeye dönüştürülmediği sürece otomatik olarak sona eklenir (bkz. bu bölüm). fct_rev() ile bir daha sarmalayarak sırayı tersine çevirebilirsiniz.Bu fonksiyon, aşağıda gösterildiği gibi bir ggplot() içinde kullanılabilir.","code":"\n# sıklığa göre sırala\nggplot(data = linelist, aes(x = fct_infreq(delay_cat)))+\n  geom_bar()+\n  labs(x = \"Delay onset to admission (days)\",\n       title = \"Ordered by frequency\")\n\n# sıralamayı tersine çevir\nggplot(data = linelist, aes(x = fct_rev(fct_infreq(delay_cat))))+\n  geom_bar()+\n  labs(x = \"Delay onset to admission (days)\",\n       title = \"Reverse of order by frequency\")"},{"path":"faktörler.html","id":"karşılaşmaya-göre","chapter":"11 Faktörler","heading":"Karşılaşmaya göre","text":"Seviye sırasını, ilk satırdan başlayarak verilerdeki karşılaşma sırasına uyacak şekilde ayarlamak için fct_inorder() fonksiyonunu kullanın. Bu komut, veri çerçevesindeki verileri arrange() fonksiyonu ile düzenledikten sonra faktör sırasını tekrardan ayarlamak için faydalı olacaktır.","code":""},{"path":"faktörler.html","id":"başka-bir-sütunun-özet-istatistiğine-göre","chapter":"11 Faktörler","heading":"Başka bir sütunun özet istatistiğine göre","text":"Bir sütunun seviyelerini başka bir sütunun özet istatistiğine göre sıralamak için fct_reorder()yı kullanabilirsiniz. Görsel olarak, bu, çubukların/noktaların grafik boyunca istikrarlı bir şekilde yükseldiği veya alçaldığı hoş grafiklerle sonuçlanabilir.Aşağıdaki örneklerde, x ekseni delay_cat ve y ekseni ct_blood (döngü eşiği) sayısal sütunudur. Kutu grafikleri, delay_cat grubuna göre CT değeri dağılımını gösterir. Kutu grafiklerini grup medyan CT değerine göre artan sırada sıralamak istiyoruz.Aşağıdaki ilk örnekte, varsayılan sıra olarak alfa-numerik sırası kullanılır. Kutu çizim yüksekliklerinin karışık olduğunu ve belirli bir sırada olmadığını görebilirsiniz. İkinci örnekte ise, delay_cat sütunu (x eksenine eşlenmiştir) fct_reorder() içine sarılmıştır, ct_blood sütunu ikinci ve medyan üçüncü argüman olarak verilmiştir. (maks, ortalama, min vb. de kullanabilirsiniz). Böylece, delay_cat seviyelerinin sırası artan medyan CT değerlerini yansıtacaktır. Bu, ikinci grafikte gösterilmektedir - kutu çizimleri yükselecek şekilde yeniden düzenlenmiştir. Açık bir düzeye dönüştürülmediği sürece, “NA”nın (eksik) sonunda nasıl görüldüğüne dikkat edin.Yukarıdaki örnekte, ggplot() komutundan önce gerekli hiçbir adım olmadığına dikkat edin - gruplama ve hesaplamaların tümü dahili olarak ggplot komutunda yapılır.","code":"\n# kutu grafiği orjinal faktör seviyelerine göre sıralanmıştır\nggplot(data = linelist)+\n  geom_boxplot(\n    aes(x = delay_cat,\n        y = ct_blood, \n        fill = delay_cat))+\n  labs(x = \"Delay onset to admission (days)\",\n       title = \"Ordered by original alpha-numeric levels\")+\n  theme_classic()+\n  theme(legend.position = \"none\")\n\n\n# kutu grafiği medyan CT düzeylerine göre sıralanmıştır\nggplot(data = linelist)+\n  geom_boxplot(\n    aes(x = fct_reorder(delay_cat, ct_blood, \"median\"),\n        y = ct_blood,\n        fill = delay_cat))+\n  labs(x = \"Delay onset to admission (days)\",\n       title = \"Ordered by median CT value in group\")+\n  theme_classic()+\n  theme(legend.position = \"none\")"},{"path":"faktörler.html","id":"son-değere-göre","chapter":"11 Faktörler","heading":"“Son” değere göre","text":"Gruplandırılmış çizgi grafiklerinde fct_reorder2(), düzeylerin (ve dolayısıyla başlığın) grafik “sonu” çizgilerin dikey sıralamasıyla hizalandırırr. Teknik olarak konuşursak, “en büyük x değerleriyle ilişkili y değerlerine göre sıralanır.”Örneğin, zaman içinde hastaneye göre vaka sayılarını gösteren satırlarınız varsa, aes() içindeki color = argümanına fct_reorder2() komutunu uygulayabilirsiniz. Öyle ki açıklamada görünen hastanelerin dikey sırası grafik sonundaki satır sırasıyla hizalanır. Çevrimiçi belgelerde daha fazlasını okuyuabilirsiniz.","code":"\nepidemic_data <- linelist %>%         # satır listesiyle başla   \n    filter(date_onset < as.Date(\"2014-09-21\")) %>%    # görsel netlik için son tarih\n    count(                                            # haftalık ve hastaneye göre vaka sayılarını al\n      epiweek = lubridate::floor_date(date_onset, \"week\"),  \n      hospital                                            \n    ) \n  \nggplot(data = epidemic_data)+                       # grafiği başlat\n  geom_line(                                        # çizgileri hazırla\n    aes(\n      x = epiweek,                                  # x-axis epiweek\n      y = n,                                        # boyu haftalık vaka sayısıdır\n      color = fct_reorder2(hospital, epiweek, n)))+ # veriyi, grafik sonu yüksekliği ve hastaneye göre gruplandırılıp renklendir\n  labs(title = \"Factor levels (and legend display) by line height at end of plot\",\n       color = \"Hospital\")                          # başlığı değiştir"},{"path":"faktörler.html","id":"fct_missing","chapter":"11 Faktörler","heading":"11.5 Eksik değerler","text":"Faktör sütununuzda NA değerleri varsa, bunları fct_explicit_na() ile kolayca “Eksik” gibi adlandırılmış bir düzeye dönüştürebilirsiniz. NA değerleri, sıralamanın sonunda varsayılan olarak “(Eksik)” değerine dönüştürülür. Seviye adını na_level = argümanıyla ayarlayabilirsiniz.Aşağıda, bu işlem delay_cat sütununda ’NA’ları “Missing delay”e dönüştürür. Bu, tabyl() ile bir tabloya yazdırılır.","code":"\nlinelist %>% \n  mutate(delay_cat = fct_explicit_na(delay_cat, na_level = \"Missing delay\")) %>% \n  tabyl(delay_cat)##      delay_cat    n    percent\n##       2-5 days 2040 0.34646739\n##        <2 days 2990 0.50781250\n##        >5 days  602 0.10224185\n##  Missing delay  256 0.04347826"},{"path":"faktörler.html","id":"seviyeleri-birleştirme","chapter":"11 Faktörler","heading":"11.6 Seviyeleri birleştirme","text":"","code":""},{"path":"faktörler.html","id":"elle-düzenleme-1","chapter":"11 Faktörler","heading":"Elle düzenleme","text":"Seviye göstergelerini fct_recode() ile manuel olarak ayarlayabilirsiniz. Bu, dplyr fonksiyonu recode() gibidir (bkz. [Temizleme verileri ve temel işlevler]), farklı olarak yeni faktör seviyelerinin oluşturulmasına izin verir. Bir faktörde basit recode()komutunu kullanırsanız, önceden izin verilen seviyeler ayarlanmadıkça yeni kodlanmış değerler reddedilecektir.Bu araç, yeniden kodlanmış değeri birden çok seviyeye atayarak seviyeleri “birleştirmek” için de kullanılabilir. Sadece bilgileri kaybetmemeye dikkat edin! Bu birleştirme adımlarını yeni bir sütunda yapmayı düşünün (mevcut sütunun üzerine yazmayın).fct_recode(), recode()dan farklı bir sözdizimine sahiptir. recode(), ESKİ = YENİyi kullanırken, fct_recode(), YENİ = ESKİyi kullanır.Geçerli delay_cat seviyeleri şunlardır:Yeni düzeyler, fct_recode(column, \"new\" = \"old\", \"new\" = \"old\", \"new\" = \"old\") sözdizimi kullanılarak oluşturulur ve yazdırılır:Burada seviyeler fct_recode() ile manuel olarak birleştirilirler. “5 günden az” yeni bir düzeyin oluşturulmasında herhangi bir hata olmadığını unutmayın.","code":"\nlevels(linelist$delay_cat)## [1] \"<2 days\"  \"2-5 days\" \">5 days\"\nlinelist %>% \n  mutate(delay_cat = fct_recode(\n    delay_cat,\n    \"Less than 2 days\" = \"<2 days\",\n    \"2 to 5 days\"      = \"2-5 days\",\n    \"More than 5 days\" = \">5 days\")) %>% \n  tabyl(delay_cat)##         delay_cat    n    percent valid_percent\n##  Less than 2 days 2990 0.50781250     0.5308949\n##       2 to 5 days 2040 0.34646739     0.3622159\n##  More than 5 days  602 0.10224185     0.1068892\n##              <NA>  256 0.04347826            NA\nlinelist %>% \n  mutate(delay_cat = fct_recode(\n    delay_cat,\n    \"Less than 5 days\" = \"<2 days\",\n    \"Less than 5 days\" = \"2-5 days\",\n    \"More than 5 days\" = \">5 days\")) %>% \n  tabyl(delay_cat)##         delay_cat    n    percent valid_percent\n##  Less than 5 days 5030 0.85427989     0.8931108\n##  More than 5 days  602 0.10224185     0.1068892\n##              <NA>  256 0.04347826            NA"},{"path":"faktörler.html","id":"diğerine-indirgeme","chapter":"11 Faktörler","heading":"“Diğerine” indirgeme","text":"Faktör seviyelerini bir “Diğer” seviyeye manuel olarak atamak için fct_other() komutunu kullanabilirsiniz. Aşağıda, “Port Hospital” ve “Central Hospital” dışındaki “hospital” sütunundaki tüm seviyeler “Hospital” olarak birleştirilmiştir. keep = veya drop = için bir vektör sağlayabilirsiniz. “Diğer” düzeyinin görünümünü other_level = ile değiştirebilirsiniz.","code":"\nlinelist %>%    \n  mutate(hospital = fct_other(                      # adjust levels\n    hospital,\n    keep = c(\"Port Hospital\", \"Central Hospital\"),  # keep these separate\n    other_level = \"Other Hospital\")) %>%            # All others as \"Other Hospital\"\n  tabyl(hospital)                                   # print table##          hospital    n    percent\n##  Central Hospital  454 0.07710598\n##     Port Hospital 1762 0.29925272\n##    Other Hospital 3672 0.62364130"},{"path":"faktörler.html","id":"frekansa-göre-indirgeme","chapter":"11 Faktörler","heading":"Frekansa göre indirgeme","text":"fct_lump() kullanarak az görülen faktör düzeylerini otomatik olarak birleştirebilirsiniz.Birçok düşük frekans düzeyini bir “Diğer” grubuna “toplamak” için aşağıdakilerden birini yapın:Tutmak istediğiniz grup sayısını n = olarak ayarlayın. En çok görülen n seviyeleri tutulacak ve diğerlerinin tamamı “Diğer” olarak birleştirilecektir.“prop =” değerini, üzerinde tutmak istediğiniz seviyeler için eşik frekans oranı olarak ayarlayın. Diğer tüm değerler “Diğer” olarak birleşecektir.“Diğer” düzeyinin görünümünü other_level = ile değiştirebilirsiniz. Aşağıda, en sık rastlanan iki hastane dışındaki tüm hastaneler “Hospital” olarak birleştirilmiştir.","code":"\nlinelist %>%    \n  mutate(hospital = fct_lump(                      # seviyeleri düzenle\n    hospital,\n    n = 2,                                          # ilk 2 seviyeyi tut\n    other_level = \"Other Hospital\")) %>%            # geri kalanını \"Other Hospital\" olarak tanımla\n  tabyl(hospital)                                   # tabloyu yazdır##        hospital    n   percent\n##         Missing 1469 0.2494905\n##   Port Hospital 1762 0.2992527\n##  Other Hospital 2657 0.4512568"},{"path":"faktörler.html","id":"tüm-seviyeleri-gösterme","chapter":"11 Faktörler","heading":"11.7 Tüm seviyeleri gösterme","text":"Faktörleri kullanmanın bir diğer faydası da, bir veri kümesinde gerçekte hangi değerlerin mevcut olduğuna bakılmaksızın, grafik açıklamalarının ve tabloların görünümünü standart hale getirmesidir.Çok sayıda analiz hazırlıyorsanız (örneğin, birden fazla analiz için), gösterge ve tabloların, değişen seviyelerde veri kompozisyonu ile bile aynı görünmesini isteyebilirsiniz.","code":""},{"path":"faktörler.html","id":"grafiklerde","chapter":"11 Faktörler","heading":"Grafiklerde","text":"Bir ggplot() grafiğinde, ilgili scale_xxxx() fonksiyonuna “drop = FALSE” argümanını eklemeniz yeterlidir. Verilerde bulunup bulunmadıklarına bakılmaksızın tüm faktör seviyeleri görüntülenecektir. Faktör sütun seviyeleriniz fill = kullanılarak görüntüleniyorsa, o zaman scale_fill_discrete() içine aşağıda gösterildiği gibi drop = FALSE değerini eklersiniz. Seviyeleriniz x = (x eksenine göre) color = veya size = ile görüntüleniyorsa, bunu scale_color_discrete() veya scale_size_discrete() argümanlarıyla sağlayabilirsiniz.Aşağıdaki örnek, hastaneye göre yaş kategorisine ait çubuk grafiğidir. scale_fill_discrete(drop = FALSE) eklenmesi, verilerde mevcut olmasa bile tüm yaş gruplarının açıklamada görünmesini sağlar.","code":"\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = hospital, fill = age_cat)) +\n  scale_fill_discrete(drop = FALSE)+                        # boş olsa bile tüm verileri açıklamada göster\n  labs(\n    title = \"All age groups will appear in legend, even if not present in data\")"},{"path":"faktörler.html","id":"tablolarda","chapter":"11 Faktörler","heading":"Tablolarda","text":"Hem R tabanında table() hem de janitor’dan tabyl() tüm faktör seviyelerini (kullanılmayan seviyeler bile) gösterecektir.Bir tablo oluşturmak için dplyr’den count() veya summarise() kullanırsanız, kullanılmamış olanlar da dahil tüm faktör düzeylerini dahil etmek için ‘.drop = FALSE’ bağımsız değişkenini ekleyin.[Açıklayıcı tablolar] sayfasında, scale_discrete belgelerinde veya count() belgelerinde. [Bulaşıcı takibi] sayfasında başka bir örnek görebilirsiniz.","code":""},{"path":"faktörler.html","id":"epiweeks","chapter":"11 Faktörler","heading":"11.8 Epiweeks","text":"Lütfen [Gruplama verileri] sayfasında epidemiyolojik haftaların nasıl oluşturulacağına ilişkin kapsamlı tartışmaya bakın.Epidemiyolojik haftaların nasıl oluşturulacağı ve biçimlendirileceğiyle ilgili ipuçları için lütfen Tarihlerle çalışma sayfasına da bakın.","code":""},{"path":"faktörler.html","id":"grafiklerde-epiweeks","chapter":"11 Faktörler","heading":"Grafiklerde epiweeks","text":"Amacınız bir grafikte görüntülenecek epiweeks oluşturmaksa, bunu [Gruplama verileri] sayfasında açıklandığı gibi lubridate’nin floor_date() ile yapabilirsiniz. Döndürülen değerler YYYY-AA-GG biçiminde Date sınıfında olacaktır. Bu sütunu bir grafik içinde kullanırsanız, tarihler doğal olarak sıralanır; seviyeler veya sınıf Faktörüne dönüştürme konusunda endişelenmenize gerek yoktur. Aşağıdaki başlangıç tarihlerine ait ggplot() histogramına bakın.Bu yaklaşımda, scale_x_date() ile bir eksen üzerindeki tarihlerin görüntülenmesini ayarlayabilirsiniz. Daha fazla bilgi için Salgın eğrileri ile ilgili sayfaya bakın. scale_x_date() öğesinin ‘date_labels =’ bağımsız değişkenine bir “strptime” görüntüleme biçimi belirleyebilirsiniz. Bu biçimler “%” yer tutucularını kullanır. Yer tutucular Tarihlerle çalışma sayfasında ele alınmıştır. 4 basamaklı bir yılı temsil etmek için “%Y” ve hafta numarasını temsil etmek için “%W” veya “%U” kullanın (sırasıyla Pazartesi veya Pazar haftaları).","code":"\nlinelist %>% \n  mutate(epiweek_date = floor_date(date_onset, \"week\")) %>%  # hafta sütununu oluştur\n  ggplot()+                                                  # ggplotu başlat\n  geom_histogram(mapping = aes(x = epiweek_date))+           # başlangıç tarihinin histogramı\n  scale_x_date(date_labels = \"%Y-W%W\")                       # tarihlerin gösterimini YYYY-WWw olacak şekilde ayarla"},{"path":"faktörler.html","id":"verilerde-epiweeks","chapter":"11 Faktörler","heading":"Verilerde epiweeks","text":"Verileri faktöre çevirmedeki amacınız grafik yapmak değilse, bunu iki yoldan yapabilirsiniz:Görüntüleme üzerindeki hassas kontrol için, lubridate epiweek sütununu (YYYY-AA-GG) istenen formatına (YYYY-WWw) ve ardından bunu sınıf Faktörüne dönüştürün .İlk olarak, tarih gösterimini YYYY-AA-GG’den YYYY-Www gösterimine dönüştürmek için R tabanından format() komutunu kullanın (bkz. Tarihlerle çalışma sayfası). Bu süreçte veriler sınıftan karaktere dönüşmüş olacaktır. Ardından, factor() ile karakterden tekrar sınıf Factor’dönüştürün.TEHLİKE: Haftaları yılların önüne koyarsanız (“Www-YYYY”) (“%W-%Y”), varsayılan alfa-numerik sıralaması yanlış olacaktır (ör. 01-2015, 35-2014’ten önce olacaktır). Uzun ve sancılı bir süreçle, sırayı manuel olarak ayarlamanız gerekebilir.Hızlı varsayılan görüntüleme için aweek paketini ve date2week() fonksiyonunu kullanın. week_start = ile haftanın ilk gününü ayarlayabilirsiniz. factor = TRUE olarak ayarlarsanız, çıktı sütunu sıralı bir faktör olacaktır. Ek olarak, faktör, o hafta hiç vaka olmasa bile, aralıktaki tüm haftalar için seviyeleri içermektedir.aweek hakkında daha fazla bilgi için Tarihlerle çalışma sayfasına bakın. Ayrıca week2date() ters fonksiyonu da bu paket içinde mevcuttur.","code":"\nlinelist <- linelist %>% \n  mutate(epiweek_date = floor_date(date_onset, \"week\"),       # epiweeks oluştur (YYYY-AA-GG)\n         epiweek_formatted = format(epiweek_date, \"%Y-W%W\"),  # (YYYY-HHh) formatına dönüştür\n         epiweek_formatted = factor(epiweek_formatted))       # faktöre dönüştür\n\n# seviyeleri göster\nlevels(linelist$epiweek_formatted)##  [1] \"2014-W13\" \"2014-W14\" \"2014-W15\" \"2014-W16\" \"2014-W17\" \"2014-W18\" \"2014-W19\" \"2014-W20\" \"2014-W21\" \"2014-W22\"\n## [11] \"2014-W23\" \"2014-W24\" \"2014-W25\" \"2014-W26\" \"2014-W27\" \"2014-W28\" \"2014-W29\" \"2014-W30\" \"2014-W31\" \"2014-W32\"\n## [21] \"2014-W33\" \"2014-W34\" \"2014-W35\" \"2014-W36\" \"2014-W37\" \"2014-W38\" \"2014-W39\" \"2014-W40\" \"2014-W41\" \"2014-W42\"\n## [31] \"2014-W43\" \"2014-W44\" \"2014-W45\" \"2014-W46\" \"2014-W47\" \"2014-W48\" \"2014-W49\" \"2014-W50\" \"2014-W51\" \"2015-W00\"\n## [41] \"2015-W01\" \"2015-W02\" \"2015-W03\" \"2015-W04\" \"2015-W05\" \"2015-W06\" \"2015-W07\" \"2015-W08\" \"2015-W09\" \"2015-W10\"\n## [51] \"2015-W11\" \"2015-W12\" \"2015-W13\" \"2015-W14\" \"2015-W15\" \"2015-W16\"\ndf <- linelist %>% \n  mutate(epiweek = date2week(date_onset, week_start = \"Monday\", factor = TRUE))\n\nlevels(df$epiweek)"},{"path":"faktörler.html","id":"kaynaklar-4","chapter":"11 Faktörler","heading":"11.9 Kaynaklar","text":"faktörler ile ilgili Veri Bilimi sayfası için Raweek paketi skeci","code":""},{"path":"verilerin-pivotlanması.html","id":"verilerin-pivotlanması","chapter":"12 Verilerin pivotlanması","heading":"12 Verilerin pivotlanması","text":"Verileri yönetirken, pivotlama aşağıdaki iki süreçten birini tarif eder:Daha kapsamlı bir tablonun verilerini özetleyen istatistik tabloları olan pivot tabloların oluşturulmasıBir tablonun uzun formattan geniş formata dönüştürülmesi veya tam tersi.Bu sayfada, ikinci tanıma odaklanacağız. İlk tanım, veri analizinde çok önemli bir adımdır ancak [Verileri gruplandırma] ve Tanımlayıcı tablolar sayfalarında ele alınmıştır.Bu sayfada veri biçimleri tartışılmaktadır. değişkenin kendi sütununa, gözlemin kendi satırına ve değerin kendi hücresine sahip olduğu “düzenli-tidy veri” felsefesi akılda tutulmalıdır. Bu konu hakkında daha fazla bilgiyi Veri Bilimi için R çevrimiçi bölümünde bulabilirsiniz.","code":""},{"path":"verilerin-pivotlanması.html","id":"hazırlık-3","chapter":"12 Verilerin pivotlanması","heading":"12.1 Hazırlık","text":"","code":""},{"path":"verilerin-pivotlanması.html","id":"paketlerin-yüklenmesi-2","chapter":"12 Verilerin pivotlanması","heading":"Paketlerin yüklenmesi","text":"Bu kod bloğu, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gereken durumlarda paketi kuran ve kullanım için yükleyen pacman’ın p_load() fonksiyonunun kullanımı vurgulanmıştır. Ayrıca, R tabanından library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] sayfasına bakın.","code":"\npacman::p_load(\n  rio,          # Dosyanın içe aktarımı\n  here,         # Dosyanın konumu\n  tidyverse)    # veri yönetimi + ggplot2 grafik paketi"},{"path":"verilerin-pivotlanması.html","id":"verinin-içeri-aktarımı","chapter":"12 Verilerin pivotlanması","heading":"Verinin içeri aktarımı","text":"","code":""},{"path":"verilerin-pivotlanması.html","id":"sıtma-hastalığı-için-sayım-verisi","chapter":"12 Verilerin pivotlanması","heading":"Sıtma hastalığı için sayım verisi","text":"Bu sayfada, kuruluş ve yaş grubuna göre günlük sıtma vakalarını içeren kurgusal bir veri setini inceleyeceğiz. Adımları takip etmek isterseniz, veri setini indirmek için buraya tıklayın (.rds dosyası formatında). Verileri rio paketinden import() fonksiyonuyla içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için İçe Aktarma ve Dışa Aktarma sayfasına bakın).İlk 50 satır aşağıda gösterilmiştir.","code":"\n# Verinin içeri aktarımı\ncount_data <- import(\"malaria_facility_count_data.rds\")"},{"path":"verilerin-pivotlanması.html","id":"satır-listesi-verisi","chapter":"12 Verilerin pivotlanması","heading":"Satır listesi verisi","text":"Bu sayfanın sonraki bölümünde, simüle edilmiş bir Ebola salgını vakalarını içeren veri setini de kullanacağız. Devam etmek istiyorsanız, “temiz” satır listesini (.rds dosyası olarak) indirmek için tıklayın. Verilerinizi rio paketinden import() işleviyle içe aktarın (.xlsx, .rds, .csv gibi birçok dosya türünü kabul eder - ayrıntılar için İçe Aktarma ve Dışa Aktarma sayfasına bakın).","code":"\n# Verinin içeri aktarımı\nlinelist <- import(\"linelist_cleaned.xlsx\")"},{"path":"verilerin-pivotlanması.html","id":"genişten-uzuna","chapter":"12 Verilerin pivotlanması","heading":"12.2 Genişten uzuna","text":"","code":""},{"path":"verilerin-pivotlanması.html","id":"geniş-format","chapter":"12 Verilerin pivotlanması","heading":"“Geniş” format","text":"Veriler genellikle “geniş” bir biçimde girilir ve saklanır - burada bir gözlemin (kişinin) özellikleri veya yanıtları tek bir satırda depolanır. Bu sunum için faydalı olsa da, bazı analiz türleri için ideal değildir.Örnek olarak yukarıdaki Hazırlık bölümünde içe aktarılan count_data veri setini ele alalım. satırın bir “tesis-gününü” temsil ettiğini görebilirsiniz. Gerçek vaka sayıları (en sağdaki sütunlar), belirli bir tesis günündeki farklı yaş grubuna ait bilgilerin ayrı sütunlar halinde ancak tek bir satırda saklanacağı şekilde “geniş” bir formatta bulunur.Bu veri tabanındaki ScriptEach gözlemi, belirli bir tarihteki 65 tesisten birindeki sıtma sayımlarını gösterir; bu sayı, count_data$data_date %>% min() ile count_data$data_date %>% max() arasında değişir. Bu tesisler bir Province (il) (North) ve dört District (ilçe)de (Spring, Bolo, Dingo ve Barnard) bulunmaktadır. Veri seti, genel sıtma sayılarının yanı sıra üç yaş grubunun birinde - <4 yaş, 5-14 yaş ve 15 yaş ve üzeri - yaşa özel sayıları da içermektedir.Bunun gibi “geniş” veriler “düzenli veri” standartlarına uymaz, çünkü sütun başlıkları aslında “değişkenleri” temsil etmez - bunlar hipotetik bir “yaş grubu” değişkenini temsil eder.Bu format, bilgileri bir tabloda sunmak veya vaka raporu formlarına veri girmek (örn. Excel’de) için faydalı olabilir. Ancak, analiz aşamasında, bu veriler tipik olarak “düzenli veri” standartlarıyla daha uyumlu “daha uzun” bir formata dönüştürülmelidir. Özellikle R paketi ggplot2, veriler “uzun” formatta olduğunda en iyi sonuçları verir.Toplam sıtma sayılarının zamana göre görselleştirilmesinde, mevcut formattaki verilerle herhangi bir zorluk yaşanmaz:Ancak, yaş grubunun bu toplam sayıya göreli katkılarını göstermek istersek ne olur? Bu durumda, ilgilenilen değişkenin (yaş grubu), veri kümesinde ggplot2’nin “haritalama estetiği” aes() argümanına aktarılabilecek tek bir sütunda bulunması gerekir.","code":"\nggplot(count_data) +\n  geom_col(aes(x = data_date, y = malaria_tot), width = 1)"},{"path":"verilerin-pivotlanması.html","id":"pivot_longer","chapter":"12 Verilerin pivotlanması","heading":"pivot_longer()","text":"tidyr fonksiyonu pivot_longer(), verileri “daha uzun” formata getirir. tidyr, R paketlerinin tidyverse kümesinin bir parçasıdır.Bu fonksiyon, dönüştürülecek bir dizi sütunu kabul eder (cols = argümanı ile belirtilir). Bu nedenle, bir veri tabanının yalnızca bir kısmıyla çalışabilir. Bu fonksiyonla yalnızca vaka sayısı sütunlarını döndürmek istediğimizden, kullandığımız veritabanı için yararlıdıBu süreçte, biri kategorileri (eski sütun adları) ve diğeri de karşılık gelen değerleri (ör. vaka sayıları) içeren iki “yeni” sütun elde edeceksiniz. Bu yeni sütunlar için varsayılan adları kabul edebilir veya kendi adlarınızı sırasıyla names_to = ve values_to = argümanlarıyla belirtebilirsiniz.Pivot_longer()’ı çalışırken görelim…","code":""},{"path":"verilerin-pivotlanması.html","id":"standard-pivoting","chapter":"12 Verilerin pivotlanması","heading":"Standard pivoting","text":"“Geniş” verileri “uzun” bir biçime dönüştürmek için tidyr’pivot_longer() fonksiyonunu kullanmak istiyoruz. Spesifik olarak, sıtma sayılarına ilişkin verileri içeren dört sayısal sütunu iki yeni sütuna dönüştürmek istiyoruz. İki yeni sütundan biri yaş gruplarını ve diğeri yaş gruplarına karşılık gelen değerleri içerecektir.Yeni oluşturulan veri çerçevesinin (df_long) daha fazla satırı olduğuna dikkat edin (12.152’ye karşı 3.038); böylece veri çerçevesi daha uzun bir şekle sahip olur. Aslında, eski versiyonuna göre tam olarak dört kat daha uzundur, çünkü orijinal veri kümesindeki satır şimdi df_long’da dört satırı temsil etmektedir (bir sıtma sayımı gözlemi yaş grubu için bir tane (<4y, 5-14y, 15y+ ve toplam)).Daha önce dört sütunda (malaria_ ön ekiyle başlayanlar) depolanan veriler şimdi iki sütunda depolandığından, daha uzun olmanın yanı sıra, yeni veri kümesi daha az sütuna (8’e karşı 10) sahiptir.Bu dört sütunun adlarının tümü malaria_ önekiyle başladığından, aynı sonucu elde etmek için kullanışlı “tidyselect” start_with() işlevini kullanabilirdik (bu yardımcı işlevlerin daha fazlası için [Verileri temizleme ve temel işlevler] sayfasına bakın).ya da pozisyona göre:veya adlandırılmış aralığa göre:Bu iki yeni sütuna varsayılan ad ve değerler verilir, ancak istediğimiz adları verebilmek için bu varsayılan adları geçersiz kılabiliriz; names_to ve values_to argümanlarını kullanarak yeni sütunlarda hangi bilgilerin depolandığını hatırlayabiliriz. Age_group adlarını ve sayılarını kullanalım:Şimdi bu yeni veri kümesini ggplot2’ye aktarabiliriz ve yeni sütunlardaki count y eksenine ve yeni age_group sütununu fill = argümanına (sütun iç kısmının rengi) atayabiliriz. Bu komut, çubuk grafikte yaş grubuna göre sıtma sayılarını gösterir:Bu yeni grafiği inceleyin ve daha önce oluşturduğumuz grafikle karşılaştırın – Sizce yanlış giden ne?Sürveyans verilerini incelerken yaygın bir sorunla karşılaştık: Grafikteki çubuğun boyu olması gerekenin iki katıdır, çünkü grafiğe malaria_tot sütunundaki toplam sayıları da dahil ettik.Bu sorunu birkaç şekilde halledebiliriz. ggplot()’aktarmadan önce bu toplamları veri kümesinden filtreleyebiliriz:Alternatif olarak, pivot_longer()’ı çalıştırdığımızda bu değişkeni hariç tutabilirdik, böylece sorun oluşturan bu değişkeni ayrı bir değişken olarak veri kümesinde tutabilirdik. Değerlerin yeni satırları doldurmak için nasıl “genişlediğini” inceleyin.","code":"\ndf_long <- count_data %>% \n  pivot_longer(\n    cols = c(`malaria_rdt_0-4`, `malaria_rdt_5-14`, `malaria_rdt_15`, `malaria_tot`)\n  )\n\ndf_long\n# tidyselect yardımcı işleviyle sütun sağlayın\ncount_data %>% \n  pivot_longer(\n    cols = starts_with(\"malaria_\")\n  )## # A tibble: 12,152 × 8\n##    location_name data_date  submitted_date Province District newid name             value\n##    <chr>         <date>     <date>         <chr>    <chr>    <int> <chr>            <int>\n##  1 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt_0-4     11\n##  2 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt_5-14    12\n##  3 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt_15      23\n##  4 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_tot         46\n##  5 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt_0-4     11\n##  6 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt_5-14    10\n##  7 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt_15       5\n##  8 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_tot         26\n##  9 Facility 3    2020-08-11 2020-08-12     North    Dingo        3 malaria_rdt_0-4      8\n## 10 Facility 3    2020-08-11 2020-08-12     North    Dingo        3 malaria_rdt_5-14     5\n## # … with 12,142 more rows\n# pozisyona göre sütun sağlamak\ncount_data %>% \n  pivot_longer(\n    cols = 6:9\n  )\n# ardışık sütun aralıkları sağlama\ncount_data %>% \n  pivot_longer(\n    cols = `malaria_rdt_0-4`:malaria_tot\n  )\ndf_long <- \n  count_data %>% \n  pivot_longer(\n    cols = starts_with(\"malaria_\"),\n    names_to = \"age_group\",\n    values_to = \"counts\"\n  )\n\ndf_long## # A tibble: 12,152 × 8\n##    location_name data_date  submitted_date Province District newid age_group        counts\n##    <chr>         <date>     <date>         <chr>    <chr>    <int> <chr>             <int>\n##  1 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt_0-4      11\n##  2 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt_5-14     12\n##  3 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt_15       23\n##  4 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_tot          46\n##  5 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt_0-4      11\n##  6 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt_5-14     10\n##  7 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt_15        5\n##  8 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_tot          26\n##  9 Facility 3    2020-08-11 2020-08-12     North    Dingo        3 malaria_rdt_0-4       8\n## 10 Facility 3    2020-08-11 2020-08-12     North    Dingo        3 malaria_rdt_5-14      5\n## # … with 12,142 more rows\nggplot(data = df_long) +\n  geom_col(\n    mapping = aes(x = data_date, y = counts, fill = age_group),\n    width = 1\n  )\ndf_long %>% \n  filter(age_group != \"malaria_tot\") %>% \n  ggplot() +\n  geom_col(\n    aes(x = data_date, y = counts, fill = age_group),\n    width = 1\n  )\ncount_data %>% \n  pivot_longer(\n    cols = `malaria_rdt_0-4`:malaria_rdt_15,   # does not include the totals column\n    names_to = \"age_group\",\n    values_to = \"counts\"\n  )## # A tibble: 9,114 × 9\n##    location_name data_date  submitted_date Province District malaria_tot newid age_group        counts\n##    <chr>         <date>     <date>         <chr>    <chr>          <int> <int> <chr>             <int>\n##  1 Facility 1    2020-08-11 2020-08-12     North    Spring            46     1 malaria_rdt_0-4      11\n##  2 Facility 1    2020-08-11 2020-08-12     North    Spring            46     1 malaria_rdt_5-14     12\n##  3 Facility 1    2020-08-11 2020-08-12     North    Spring            46     1 malaria_rdt_15       23\n##  4 Facility 2    2020-08-11 2020-08-12     North    Bolo              26     2 malaria_rdt_0-4      11\n##  5 Facility 2    2020-08-11 2020-08-12     North    Bolo              26     2 malaria_rdt_5-14     10\n##  6 Facility 2    2020-08-11 2020-08-12     North    Bolo              26     2 malaria_rdt_15        5\n##  7 Facility 3    2020-08-11 2020-08-12     North    Dingo             18     3 malaria_rdt_0-4       8\n##  8 Facility 3    2020-08-11 2020-08-12     North    Dingo             18     3 malaria_rdt_5-14      5\n##  9 Facility 3    2020-08-11 2020-08-12     North    Dingo             18     3 malaria_rdt_15        5\n## 10 Facility 4    2020-08-11 2020-08-12     North    Bolo              49     4 malaria_rdt_0-4      16\n## # … with 9,104 more rows"},{"path":"verilerin-pivotlanması.html","id":"birden-çok-sınıfa-ait-verinin-pivotlanması","chapter":"12 Verilerin pivotlanması","heading":"Birden çok sınıfa ait verinin pivotlanması","text":"Yukarıdaki örnek, daha uzun şekilde pivotlamak istediğiniz tüm sütunların aynı sınıfta olduğu durumlarda (karakter, sayısal, mantıksal…) iyi çalışır.Bununla birlikte, bir saha epidemiyoloğu olarak, bu konuda uzman olmayanlar tarafından hazırlanan ve standart dışı verilerle çalışacağınız birçok durum olacaktır - Hadley Wickham’ın Düzenli Veri ilkeleri üzerine ufuk açıcı makalesinde Tolstoy’atıfta bulunarak belirttiği gibi “Düzenli veri kümelerinin hepsi birbirine benzer, ancak dağınık veri kümesi kendi tarzında dağınıktır, aynı aileler gibi.”Karşılaşacağınız özellikle yaygın bir sorun, farklı veri sınıfları içeren sütunları döndürme ihtiyacı olacaktır. Bu pivot işlemi, farklı veri türlerinin tek bir sütunda depolanmasına neden olur ve bu durum istenmeyen bir sonuçtur. Bunun yarattığı karışıklığı ortadan kaldırmak için çeşitli yaklaşımlar vardır. Ancak bu duruma düşmemek için pivot_longer() kullanımında uygulanabilecek önemli bir adım vardır., B ve C öğelerinin biri için farklı zamanlarda bir dizi gözlemin olduğu bir durumu ele alın. Bu öğeler örneğin farklı bireyler (örneğin 21 gün boyunca gün bir Ebola vakasının temaslıları) veya hala çalışır durumda olduklarından emin olmak için yılda bir kez izlenen sağlık ocakları olabilir. Temaslı kişilerini izlemini ele alalım. Verilerin aşağıdaki gibi kaydedildiğini düşünelim:Verinin durumu başlangıçta karmaşıktır. satır, bir öğe hakkında veri içerir, ancak zaman serilerinde zamandaki ilerleme ile sütunlarda sağa doğru ilerleme izlenmektedir. Ayrıca, sütun sınıfları sırayla tarih ve karakter değerleri almaktadır.Bu araştırmacının karşılaştığı kötü bir örnek, 4 yıl boyunca gün 8 yeni gözlem sütununun eklendiği kolera sürveyans verilerini içeriyordu. Bu verilerin depolandığı Excel dosyasını açmak, dizüstü bilgisayarda 10 dakikan fazla zaman almıştır.Bu verilerle çalışmak için, veri çerçevesini uzun biçime dönüştürmemiz, ancak öğeye ait tüm gözlemler için date ve character (durum) sütunu arasındaki ayrımı korumamız gerekir. Bunu yapmazsak, tek bir sütunda değişken türleri karışık şekilde bulunur (Veri yönetimi ve düzenli veriler söz konusu olduğunda gerçekten istenmeyen bir durumdur):Yukarıda, pivot komutu, tarihleri ve karakterleri tek bir değer sütununda birleştirdi. Bu durumda R, tüm sütunu sınıf karakterine dönüştür ve tarih özellikleri kaybolur.Bu durumu önlemek için orijinal sütun adlarının sintaks yapısından yararlanabiliriz. Gözlem numarası, alt çizgi ve ardından “durum” veya “tarih” bilgisi içeren ortak bir adlandırma şeklini kullanmak faydalıdır. Pivot sonrası bu iki veri türünü ayrı sütunlarda tutmak için bu sintakstan yararlanabiliriz.Bunu şu şekilde yapıyoruz:İkinci öğe (\".value\") olmak üzere, names_to = argümanına bir karakter vektörü yazmalısınız. Bu özel terim, pivot sütunlarının adlarındaki bir karaktere göre nasıl bölüneceğini belirtir.Ayrıca, name_sep = argümanına “splitting-ayırma” karakterini de yazmalısınız. Bu durumda, ayırma karakteri alt çizgidir ( “_”)Bu nedenle, yeni sütunların adlandırılması ve bölünmesi, mevcut değişken adlarındaki alt çizgiye göre gerçekleşir.Son dokunuşlar:Tarih sütununun şu anda character sınıfında olduğuna dikkat edin. Tarihlerle çalışma sayfasında açıklanan mutate() ve as_date() fonksiyonlarını kullanarak sınıfı kolayca uygun tarih sınıfına dönüştürebiliriz.Ayrıca, “obs” ön ekini silerek observation sütununu sayısal bir biçime dönüştürmek isteyebiliriz. Bunu stringr paketinden str_remove_all() ile yapabiliriz (Karakterler ve dizeler sayfasına bakın).Ve şimdi bu formattaki verilerle çalışmaya başlayabiliriz, örn. açıklayıcı bir ısı döşemesi çizerek:","code":"\ndf %>% \n  pivot_longer(\n    cols = -id,\n    names_to = c(\"observation\")\n  )## # A tibble: 18 × 3\n##    id    observation value     \n##    <chr> <chr>       <chr>     \n##  1 A     obs1_date   2021-04-23\n##  2 A     obs1_status Healthy   \n##  3 A     obs2_date   2021-04-24\n##  4 A     obs2_status Healthy   \n##  5 A     obs3_date   2021-04-25\n##  6 A     obs3_status Unwell    \n##  7 B     obs1_date   2021-04-23\n##  8 B     obs1_status Healthy   \n##  9 B     obs2_date   2021-04-24\n## 10 B     obs2_status Healthy   \n## 11 B     obs3_date   2021-04-25\n## 12 B     obs3_status Healthy   \n## 13 C     obs1_date   2021-04-23\n## 14 C     obs1_status Missing   \n## 15 C     obs2_date   2021-04-24\n## 16 C     obs2_status Healthy   \n## 17 C     obs3_date   2021-04-25\n## 18 C     obs3_status Healthy\ndf_long <- \n  df %>% \n  pivot_longer(\n    cols = -id,\n    names_to = c(\"observation\", \".value\"),\n    names_sep = \"_\"\n  )\n\ndf_long## # A tibble: 9 × 4\n##   id    observation date       status \n##   <chr> <chr>       <chr>      <chr>  \n## 1 A     obs1        2021-04-23 Healthy\n## 2 A     obs2        2021-04-24 Healthy\n## 3 A     obs3        2021-04-25 Unwell \n## 4 B     obs1        2021-04-23 Healthy\n## 5 B     obs2        2021-04-24 Healthy\n## 6 B     obs3        2021-04-25 Healthy\n## 7 C     obs1        2021-04-23 Missing\n## 8 C     obs2        2021-04-24 Healthy\n## 9 C     obs3        2021-04-25 Healthy\ndf_long <- \n  df_long %>% \n  mutate(\n    date = date %>% lubridate::as_date(),\n    observation = \n      observation %>% \n      str_remove_all(\"obs\") %>% \n      as.numeric()\n  )\n\ndf_long## # A tibble: 9 × 4\n##   id    observation date       status \n##   <chr>       <dbl> <date>     <chr>  \n## 1 A               1 2021-04-23 Healthy\n## 2 A               2 2021-04-24 Healthy\n## 3 A               3 2021-04-25 Unwell \n## 4 B               1 2021-04-23 Healthy\n## 5 B               2 2021-04-24 Healthy\n## 6 B               3 2021-04-25 Healthy\n## 7 C               1 2021-04-23 Missing\n## 8 C               2 2021-04-24 Healthy\n## 9 C               3 2021-04-25 Healthy\nggplot(data = df_long, mapping = aes(x = date, y = id, fill = status)) +\n  geom_tile(colour = \"black\") +\n  scale_fill_manual(\n    values = \n      c(\"Healthy\" = \"lightgreen\", \n        \"Unwell\" = \"red\", \n        \"Missing\" = \"orange\")\n  )"},{"path":"verilerin-pivotlanması.html","id":"uzundan-genişe","chapter":"12 Verilerin pivotlanması","heading":"12.3 Uzundan genişe","text":"Bazı durumlarda, bir veri tabanını daha geniş bir formata dönüştürmek isteyebiliriz. Bunun için pivot_wider() fonksiyonunu kullanabiliriz.Analiz sonuçlarını okuyucu için daha anlaşılır bir formata dönüştürmek istediğimiz zamandır (örneğin, [Sunum için bir tablo][Tables presentation]), bu fonksiyonu. Genellikle bu işlem, bir gözlem için değerlerin birden çok satıra yayıldığı bir veri kümesinin, bu değerlerin tek bir satırda depolandığı bir formata dönüştürülmesini içerir.","code":""},{"path":"verilerin-pivotlanması.html","id":"veri","chapter":"12 Verilerin pivotlanması","heading":"Veri","text":"Sayfanın bu bölümü için, vaka başına bir satır içeren satır listesini kullanacağız (Hazırlık bölümüne bakın).İlk 50 satır:Farklı yaş gruplarındaki bireylerin sayısını cinsiyete göre bilmek istediğimizi varsayalım:Bu bize, ggplot2’de görselleştirme için harika, ancak tabloda sunum için ideal olmayan uzun bir veri tabanı sağlar:","code":"\ndf_wide <- \n  linelist %>% \n  count(age_cat, gender)\n\ndf_wide##    age_cat gender   n\n## 1      0-4      f 640\n## 2      0-4      m 416\n## 3      0-4   <NA>  39\n## 4      5-9      f 641\n## 5      5-9      m 412\n## 6      5-9   <NA>  42\n## 7    10-14      f 518\n## 8    10-14      m 383\n## 9    10-14   <NA>  40\n## 10   15-19      f 359\n## 11   15-19      m 364\n## 12   15-19   <NA>  20\n## 13   20-29      f 468\n## 14   20-29      m 575\n## 15   20-29   <NA>  30\n## 16   30-49      f 179\n## 17   30-49      m 557\n## 18   30-49   <NA>  18\n## 19   50-69      f   2\n## 20   50-69      m  91\n## 21   50-69   <NA>   2\n## 22     70+      m   5\n## 23     70+   <NA>   1\n## 24    <NA>   <NA>  86\nggplot(df_wide) +\n  geom_col(aes(x = age_cat, y = n, fill = gender))"},{"path":"verilerin-pivotlanması.html","id":"daha-geniş-olarak-pivotlama","chapter":"12 Verilerin pivotlanması","heading":"Daha geniş olarak pivotlama","text":"Bu nedenle, verileri raporlara tablo olarak dahil etmek amaçlı olarak daha uygun biçime dönüştürmek için pivot_wider()’ı kullanabiliriz.name_from argümanı, yeni sütun adlarının oluşturulacağı names sütunu belirtirken; values_from argümanı, hücreleri doldurmak için gereken değerlerin alınacağı sütunu belirtir. id_cols = argümanı isteğe bağlıdır, ancak döndürülmemesi gereken satırları içeren sütun adları vektörünü içerir ..Bu tablo daha okuyucu dostudur ve bu nedenle raporlarımıza dahil edilmesi daha uygundur. Flextable ve knitr dahil olmak üzere çeşitli paketlerle güzel bir tablolar oluşturulabilir. Bu süreç Sunum için tablolar sayfasında daha detaylı olarak anlatılmıştır.","code":"\ntable_wide <- \n  df_wide %>% \n  pivot_wider(\n    id_cols = age_cat,\n    names_from = gender,\n    values_from = n\n  )\n\ntable_wide## # A tibble: 9 × 4\n##   age_cat     f     m  `NA`\n##   <fct>   <int> <int> <int>\n## 1 0-4       640   416    39\n## 2 5-9       641   412    42\n## 3 10-14     518   383    40\n## 4 15-19     359   364    20\n## 5 20-29     468   575    30\n## 6 30-49     179   557    18\n## 7 50-69       2    91     2\n## 8 70+        NA     5     1\n## 9 <NA>       NA    NA    86\ntable_wide %>% \n  janitor::adorn_totals(c(\"row\", \"col\")) %>% # adds row and column totals\n  knitr::kable() %>% \n  kableExtra::row_spec(row = 10, bold = TRUE) %>% \n  kableExtra::column_spec(column = 5, bold = TRUE) "},{"path":"verilerin-pivotlanması.html","id":"doldurma","chapter":"12 Verilerin pivotlanması","heading":"12.4 Doldurma","text":"Bazı durumlarda pivot işlemi sonrası ve daha yaygın olarak bir birleştirme sonrası, bazı hücrelerde doldurmak istediğimiz boşluklar kalır.","code":""},{"path":"verilerin-pivotlanması.html","id":"veri-1","chapter":"12 Verilerin pivotlanması","heading":"Veri","text":"Örneğin, ölçüm numarası, tesisin adı ve o andaki vaka sayısı için gözlemleri olan iki veri tabanını inceleyelim. Ancak, ikinci veri kümesinde ek olarak Year değişkeni vardır.İki veri kümesini birleştirmek için bir bind_rows() işlemi gerçekleştirdiğimizde, Year değişkeni, ön bilgi bulunmayan satırlar için (yani ilk veri kümesinde) NA ile doldurulur:","code":"\ndf1 <- \n  tibble::tribble(\n       ~Measurement, ~Facility, ~Cases,\n                  1,  \"Hosp 1\",     66,\n                  2,  \"Hosp 1\",     26,\n                  3,  \"Hosp 1\",      8,\n                  1,  \"Hosp 2\",     71,\n                  2,  \"Hosp 2\",     62,\n                  3,  \"Hosp 2\",     70,\n                  1,  \"Hosp 3\",     47,\n                  2,  \"Hosp 3\",     70,\n                  3,  \"Hosp 3\",     38,\n       )\n\ndf1 ## # A tibble: 9 × 3\n##   Measurement Facility Cases\n##         <dbl> <chr>    <dbl>\n## 1           1 Hosp 1      66\n## 2           2 Hosp 1      26\n## 3           3 Hosp 1       8\n## 4           1 Hosp 2      71\n## 5           2 Hosp 2      62\n## 6           3 Hosp 2      70\n## 7           1 Hosp 3      47\n## 8           2 Hosp 3      70\n## 9           3 Hosp 3      38\ndf2 <- \n  tibble::tribble(\n    ~Year, ~Measurement, ~Facility, ~Cases,\n     2000,            1,  \"Hosp 4\",     82,\n     2001,            2,  \"Hosp 4\",     87,\n     2002,            3,  \"Hosp 4\",     46\n  )\n\ndf2## # A tibble: 3 × 4\n##    Year Measurement Facility Cases\n##   <dbl>       <dbl> <chr>    <dbl>\n## 1  2000           1 Hosp 4      82\n## 2  2001           2 Hosp 4      87\n## 3  2002           3 Hosp 4      46\ndf_combined <- \n  bind_rows(df1, df2) %>% \n  arrange(Measurement, Facility)\n\ndf_combined## # A tibble: 12 × 4\n##    Measurement Facility Cases  Year\n##          <dbl> <chr>    <dbl> <dbl>\n##  1           1 Hosp 1      66    NA\n##  2           1 Hosp 2      71    NA\n##  3           1 Hosp 3      47    NA\n##  4           1 Hosp 4      82  2000\n##  5           2 Hosp 1      26    NA\n##  6           2 Hosp 2      62    NA\n##  7           2 Hosp 3      70    NA\n##  8           2 Hosp 4      87  2001\n##  9           3 Hosp 1       8    NA\n## 10           3 Hosp 2      70    NA\n## 11           3 Hosp 3      38    NA\n## 12           3 Hosp 4      46  2002"},{"path":"verilerin-pivotlanması.html","id":"fill","chapter":"12 Verilerin pivotlanması","heading":"fill()","text":"Bu durumda, özellikle zaman içindeki eğilimleri keşfetmek istiyorsak, yıl dahil etmek için yararlı bir değişkendir. Bu nedenle, doldurulacak sütunu ve doldurma yönünü (bu durumda yukarı) belirterek boş hücreleri doldurmak için fill() komutunu kullanırız:Alternatif olarak, verileri aşağı yönde dolduracak şekilde yeniden düzenleyebiliriz:Artık görselleştirmek için kullanışlı bir veri setimiz var:Ancak bu form tablo halinde sunmak için daha az kullanışlıdır, bu yüzden uzun, düzensiz veri çerçevesini daha geniş, düzenli bir veri çerçevesine dönüştürme alıştırması yapalım:: Bu durumda, ek değişken olan “ölçüm” tablonun oluşturulmasına engel olacağından, yalnızca Facility, Year ve Cases değişkenleri dahil edilmelidir:","code":"\ndf_combined %>% \n  fill(Year, .direction = \"up\")## # A tibble: 12 × 4\n##    Measurement Facility Cases  Year\n##          <dbl> <chr>    <dbl> <dbl>\n##  1           1 Hosp 1      66  2000\n##  2           1 Hosp 2      71  2000\n##  3           1 Hosp 3      47  2000\n##  4           1 Hosp 4      82  2000\n##  5           2 Hosp 1      26  2001\n##  6           2 Hosp 2      62  2001\n##  7           2 Hosp 3      70  2001\n##  8           2 Hosp 4      87  2001\n##  9           3 Hosp 1       8  2002\n## 10           3 Hosp 2      70  2002\n## 11           3 Hosp 3      38  2002\n## 12           3 Hosp 4      46  2002\ndf_combined <- \n  df_combined %>% \n  arrange(Measurement, desc(Facility))\n\ndf_combined## # A tibble: 12 × 4\n##    Measurement Facility Cases  Year\n##          <dbl> <chr>    <dbl> <dbl>\n##  1           1 Hosp 4      82  2000\n##  2           1 Hosp 3      47    NA\n##  3           1 Hosp 2      71    NA\n##  4           1 Hosp 1      66    NA\n##  5           2 Hosp 4      87  2001\n##  6           2 Hosp 3      70    NA\n##  7           2 Hosp 2      62    NA\n##  8           2 Hosp 1      26    NA\n##  9           3 Hosp 4      46  2002\n## 10           3 Hosp 3      38    NA\n## 11           3 Hosp 2      70    NA\n## 12           3 Hosp 1       8    NA\ndf_combined <- \n  df_combined %>% \n  fill(Year, .direction = \"down\")\n\ndf_combined## # A tibble: 12 × 4\n##    Measurement Facility Cases  Year\n##          <dbl> <chr>    <dbl> <dbl>\n##  1           1 Hosp 4      82  2000\n##  2           1 Hosp 3      47  2000\n##  3           1 Hosp 2      71  2000\n##  4           1 Hosp 1      66  2000\n##  5           2 Hosp 4      87  2001\n##  6           2 Hosp 3      70  2001\n##  7           2 Hosp 2      62  2001\n##  8           2 Hosp 1      26  2001\n##  9           3 Hosp 4      46  2002\n## 10           3 Hosp 3      38  2002\n## 11           3 Hosp 2      70  2002\n## 12           3 Hosp 1       8  2002\nggplot(df_combined) +\n  aes(Year, Cases, fill = Facility) +\n  geom_col()\ndf_combined %>% \n  pivot_wider(\n    id_cols = c(Measurement, Facility),\n    names_from = \"Year\",\n    values_from = \"Cases\"\n  ) %>% \n  arrange(Facility) %>% \n  janitor::adorn_totals(c(\"row\", \"col\")) %>% \n  knitr::kable() %>% \n  kableExtra::row_spec(row = 5, bold = TRUE) %>% \n  kableExtra::column_spec(column = 5, bold = TRUE) \ndf_combined %>% \n  pivot_wider(\n    names_from = \"Year\",\n    values_from = \"Cases\"\n  ) %>% \n  knitr::kable()"},{"path":"verilerin-pivotlanması.html","id":"kaynaklar-5","chapter":"12 Verilerin pivotlanması","heading":"12.5 Kaynaklar","text":"Yararlı bir eğitim","code":""},{"path":"verileri-gruplama.html","id":"verileri-gruplama","chapter":"13 Verileri Gruplama","heading":"13 Verileri Gruplama","text":"Bu sayfa, tanımlayıcı analiz için verilerin nasıl gruplandırılacağını ve toplanacağını kapsar. Ortak ve kullanımı kolay fonksiyonlar için tidyverse paket ailesini kullanır.Verileri gruplamak, veri yönetimi ve analizinin temel bir bileşenidir. Gruplandırılmış veriler istatistiksel olarak grup tarafından özetlenir ve grup tarafından çizilebilir. dplyr paketindeki fonksiyonlar (tidyverse’bir parçası) gruplandırmayı ve sonraki işlemleri oldukça kolaylaştırır.Bu sayfa aşağıdaki konuları ele alacaktır:group_by() fonksiyonuyla verileri gruplayınGrubun verilerini kaldırmasummarise() istatistiklerle gruplandırılmış verilercount() ve tally() arasındaki farkgruplandırılmış verilere uygulanan arrange()gruplandırılmış verilere uygulanan filter()gruplandırılmış verilere uygulanan mutate()gruplandırılmış verilere uygulanan select()Alternatif olarak R tabanı aggregate() komutu","code":""},{"path":"verileri-gruplama.html","id":"hazırlık-4","chapter":"13 Verileri Gruplama","heading":"13.1 Hazırlık","text":"","code":""},{"path":"verileri-gruplama.html","id":"paketleri-yükleyin","chapter":"13 Verileri Gruplama","heading":"Paketleri yükleyin","text":"Bu kod parçası, analizler için gereken paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() vurgusunu yapıyoruz. R tabanından library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakabilirsiniz.","code":"\npacman::p_load(\n  rio,       # verileri içe aktarma\n  here,      # dosyaları konumlama\n  tidyverse, # veriyi temizleme, işleme ve grafikleştirme (dplyr dahil)\n  janitor)   # toplam satır ve süruna ekleme yapma"},{"path":"verileri-gruplama.html","id":"verileri-içe-aktar-2","chapter":"13 Verileri Gruplama","heading":"Verileri içe aktar","text":"Simüle edilmiş bir Ebola salgınından vakaların veri setini içe aktarıyoruz. Takip etmek isterseniz, “clean” dosyasını indirmek için tıklayın (.rds dosyası olarak). Veri kümesi, rio paketinden import() fonksiyonu kullanılarak içe aktarılır. Verileri içe aktarmanın çeşitli yolları için İçe ve dışa aktar hakkındaki sayfaya bakın.“linelist”ilk 50 satırı:","code":"\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"verileri-gruplama.html","id":"gruplandırma","chapter":"13 Verileri Gruplama","heading":"13.2 Gruplandırma","text":"dplyr’den group_by() fonsiyonu, satırları kendisine belirtilen sütundaki benzersiz değerlere göre gruplandırır. Birden çok sütun belirtilirse, satırlar sütunlar boyunca benzersiz değer kombinasyonlarına göre gruplanır. benzersiz değer (veya değer kombinasyonu) bir grup oluşturur. Veri kümesinde veya hesaplamalarda sonraki değişiklikler daha sonra grup bağlamında gerçekleştirilebilir.Örneğin, aşağıdaki komut “linelist”alır ve satırları “outcome” sütunundaki benzersiz değerlere göre gruplayarak çıktıyı yeni bir “ll_by_outcome” veri çerçevesi olarak kaydeder. Gruplandırma sütunu/sütunları, ‘group_by()’ fonksiyonunun parantezlerin içine yerleştirilir.Veri kümesinde algılanabilir bir değişiklik olmadığını unutmayın\ngroup_by() çalıştırıldıktan sonra, mutate(), summarise() veya arrange() gibi başka bir dplyr fiili “gruplandırılmış” veri çerçevesine kadar uygulanır.Bununla birlikte, veri çerçevesini yazdırarak gruplamaları “görebilirsiniz”. Gruplandırılmış bir veri çerçevesi yazdırdığınızda, bunun yazdırıldığında hangi gruplamaların uygulandığını ve kaç tane olduğunu gösteren bir tibble sınıf nesnesine dönüştürüldüğünü göreceksiniz - başlık satırının hemen üstüne yazılır.","code":"\nll_by_outcome <- linelist %>% \n  group_by(outcome)\n# hangi grupların aktif olduğunu görmek için yazdır\nll_by_outcome## # A tibble: 5,888 × 30\n## # Groups:   outcome [3]\n##    case_id generation date_infe…¹ date_onset date_hos…² date_out…³ outcome gender   age age_u…⁴ age_y…⁵ age_cat age_c…⁶\n##    <chr>        <dbl> <date>      <date>     <date>     <date>     <chr>   <chr>  <dbl> <chr>     <dbl> <fct>   <fct>  \n##  1 5fe599           4 2014-05-08  2014-05-13 2014-05-15 NA         <NA>    m          2 years         2 0-4     0-4    \n##  2 8689b7           4 NA          2014-05-13 2014-05-14 2014-05-18 Recover f          3 years         3 0-4     0-4    \n##  3 11f8ea           2 NA          2014-05-16 2014-05-18 2014-05-30 Recover m         56 years        56 50-69   55-59  \n##  4 b8812a           3 2014-05-04  2014-05-18 2014-05-20 NA         <NA>    f         18 years        18 15-19   15-19  \n##  5 893f25           3 2014-05-18  2014-05-21 2014-05-22 2014-05-29 Recover m          3 years         3 0-4     0-4    \n##  6 be99c8           3 2014-05-03  2014-05-22 2014-05-23 2014-05-24 Recover f         16 years        16 15-19   15-19  \n##  7 07e3e8           4 2014-05-22  2014-05-27 2014-05-29 2014-06-01 Recover f         16 years        16 15-19   15-19  \n##  8 369449           4 2014-05-28  2014-06-02 2014-06-03 2014-06-07 Death   f          0 years         0 0-4     0-4    \n##  9 f393b4           4 NA          2014-06-05 2014-06-06 2014-06-18 Recover m         61 years        61 50-69   60-64  \n## 10 1389ca           4 NA          2014-06-05 2014-06-07 2014-06-09 Death   f         27 years        27 20-29   25-29  \n## # … with 5,878 more rows, 17 more variables: hospital <chr>, lon <dbl>, lat <dbl>, infector <chr>, source <chr>,\n## #   wt_kg <dbl>, ht_cm <dbl>, ct_blood <dbl>, fever <chr>, chills <chr>, cough <chr>, aches <chr>, vomit <chr>,\n## #   temp <dbl>, time_admission <chr>, bmi <dbl>, days_onset_hosp <dbl>, and abbreviated variable names\n## #   ¹​date_infection, ²​date_hospitalisation, ³​date_outcome, ⁴​age_unit, ⁵​age_years, ⁶​age_cat5"},{"path":"verileri-gruplama.html","id":"benzersiz-gruplar","chapter":"13 Verileri Gruplama","heading":"Benzersiz gruplar","text":"Oluşturulan gruplar, gruplandırma sütunlarında benzersiz değer kombinasyonunu yansıtır.Grupları ve gruptaki satır sayısını görmek için gruplanmış verileri ‘tally()’ öğesine iletin. Sadece benzersiz, sayısız grupları görmek için group_keys() öğesine geçebilirsiniz.Aşağıda, “sonuç” gruplandırma sütununda üç benzersiz değer olduğunu görün: “Ölüm”, “İyileşme” ve “NA”. nrow(linelist %>% filter(outcome == \"Death\")) ölümler, nrow(linelist %>% filter(outcome == \"Recover\")) ve nrow(linelist %) olduğunu görün >% filter(.na(outcome)))` hiçbir sonuç kaydedilmedi.Birden fazla sütuna göre gruplandırabilirsiniz. Aşağıda, veri çerçevesi “sonuç” ve “cinsiyet”e göre gruplandırılır ve ardından hesaplanır. “Sonuç” ve “cinsiyet”benzersiz kombinasyonunun kendi grubu olarak nasıl kaydedildiğine dikkat edin - iki sütun için de eksik değerler dahil edilmektedir.","code":"\nlinelist %>% \n  group_by(outcome) %>% \n  tally()## # A tibble: 3 × 2\n##   outcome     n\n##   <chr>   <int>\n## 1 Death    2582\n## 2 Recover  1983\n## 3 <NA>     1323\nlinelist %>% \n  group_by(outcome, gender) %>% \n  tally()## # A tibble: 9 × 3\n## # Groups:   outcome [3]\n##   outcome gender     n\n##   <chr>   <chr>  <int>\n## 1 Death   f       1227\n## 2 Death   m       1228\n## 3 Death   <NA>     127\n## 4 Recover f        953\n## 5 Recover m        950\n## 6 Recover <NA>      80\n## 7 <NA>    f        627\n## 8 <NA>    m        625\n## 9 <NA>    <NA>      71"},{"path":"verileri-gruplama.html","id":"yeni-sütunlar-1","chapter":"13 Verileri Gruplama","heading":"Yeni sütunlar","text":"Ayrıca, “group_by()” ifadesinin içinde yeni bir gruplandırma sütunu da oluşturabilirsiniz. Bu, ‘group_by()’dan önce ’mutate()’ çağrısına eşdeğerdir. Hızlı bir tablolama için bu stil kullanışlı olabilir, ancak kodunuzda daha fazla netlik için bu sütunu kendi mutate() adımında oluşturmayı ve ardından group_by() ile bağlantı kurmayı düşünün.","code":"\n# group_by() komut satırı listesi %>% *içinde* oluşturulan bir ikili sütuna dayalı grup verileri\nlinelist %>% \n     group_by(\n          age_class = ifelse(age >= 18, \"adult\", \"child\")) %>% \n     tally(sort = T)## # A tibble: 3 × 2\n##   age_class     n\n##   <chr>     <int>\n## 1 child      3618\n## 2 adult      2184\n## 3 <NA>         86"},{"path":"verileri-gruplama.html","id":"gruplandırma-sütunlarını-eklebırak","chapter":"13 Verileri Gruplama","heading":"Gruplandırma sütunlarını ekle/bırak","text":"Varsayılan olarak, zaten gruplanmış veriler üzerinde group_by() çalıştırırsanız, eski gruplar kaldırılacak ve yenileri uygulanacaktır. Mevcut gruplara yeni gruplar eklemek istiyorsanız, .add = TRUE değişkenini ekleyin.** Tüm grupları tut**Bir sınıf faktörü sütununda gruplandırırsanız, şu anda verilerde mevcut olmayan faktör seviyeleri olabilir. Bu sütunda gruplandırırsanız, varsayılan olarak mevcut olmayan seviyeler bırakılır ve grup olarak dahil edilmez. Bunu, tüm seviyelerin gruplar halinde görüneceği şekilde değiştirmek için (verilerde mevcut olmasa bile), group_by() komutunuzda .drop = FALSE değerini ayarlayın.","code":"\n# Çıktıya göre gruplama\nby_outcome <- linelist %>% \n  group_by(outcome)\n\n# İlave olarak cinsiyet olarak gruplama eklemesi\nby_outcome_gender <- by_outcome %>% \n  group_by(gender, .add = TRUE)"},{"path":"verileri-gruplama.html","id":"grubu-kaldır","chapter":"13 Verileri Gruplama","heading":"13.3 Grubu kaldır","text":"Gruplandırılmış veriler, ‘ungroup()’ aracılığıyla özellikle işlenene kadar gruplanmış olarak kalacaktır. Grubu çözmeyi unutursanız, yanlış hesaplamalara yol açabilir! Aşağıda tüm gruplamaların kaldırılmasına ilişkin bir örnek verilmiştir:Ayrıca, sütun adını “ungroup()” içine yerleştirerek yalnızca belirli sütunlar için gruplamayı kaldırabilirsiniz.: count() fiili saydıktan sonra verilerin grubunu otomatik olarak çözer.","code":"\nlinelist %>% \n  group_by(outcome, gender) %>% \n  tally() %>% \n  ungroup()\nlinelist %>% \n  group_by(outcome, gender) %>% \n  tally() %>% \n  ungroup(gender) # cinsiyete göre gruplamayı kaldır, sonuca göre gruplamayı bırak"},{"path":"verileri-gruplama.html","id":"group_summarise","chapter":"13 Verileri Gruplama","heading":"13.4 Özetleme","text":"Özet tablolarının “summarise()” ile nasıl oluşturulacağına ilişkin ayrıntılı bir açıklama için Tanımlayıcı tablolar sayfasının dplyr bölümüne bakın. Burada, gruplandırılmış verilere uygulandığında davranışının nasıl değiştiğini kısaca ele alıyoruz.dplyr fonksiyonusummarise() (veya summarize()) bir veri çerçevesi alır ve onu tanımladığınız özet istatistikleri içeren sütunlarla birlikte yeni bir özet veri çerçevesine dönüştürür. Gruplandırılmamış bir veri çerçevesinde, tüm satırlardan özet istatistikler hesaplanacaktır. Gruplandırılmış verilere ‘summarise()’ uygulamak, grup için bu özet istatistikleri üretir.summarise() sözdizimi, yeni özet sütun(lar)ının adlarını, bir eşittir işaretini ve ardından aşağıda gösterildiği gibi verilere uygulanacak istatistiksel bir fonksiyon sağlayacak şekildedir. Örneğin, “min()”, “max()”, “median()” veya “sd()”. İstatistiksel fonksiyon içinde, üzerinde çalışılacak sütunu ve ilgili herhangi bir değişkeni listeleyebilir (ör. “na.rm = TRUE”). Mantıksal bir ölçütü karşılayan satırların sayısını saymak için sum() kullanabilirsiniz (çift eşittir == ile).Aşağıda, gruplandırılmış veriler olmadan uygulanan bir summarise() örneği verilmiştir. Döndürülen istatistikler, tüm veri kümesinden üretilir.Buna karşılık, aşağıda gruplanmış verilere uygulanan aynı “summarise()” ifadesi yer almaktadır. İstatistikler, bir “sonuç” grubu için hesaplanır. Gruplandırma sütunlarının yeni veri çerçevesine nasıl taşınacağına dikkat edin.İPUCU: TÖzetleme işlevi hem Birleşik Krallık hem de ABD yazımıyla çalışır - summarise() ve summarize() aynı fonksiyonu çağırır.","code":"\n# gruplandırılmamış satır listesindeki özet istatistikler\nlinelist %>% \n  summarise(\n    n_cases  = n(),\n    mean_age = mean(age_years, na.rm=T),\n    max_age  = max(age_years, na.rm=T),\n    min_age  = min(age_years, na.rm=T),\n    n_males  = sum(gender == \"m\", na.rm=T))##   n_cases mean_age max_age min_age n_males\n## 1    5888 16.01831      84       0    2803\n# gruplandırılmış satır listesindeki özet istatistikler\nlinelist %>% \n  group_by(outcome) %>% \n  summarise(\n    n_cases  = n(),\n    mean_age = mean(age_years, na.rm=T),\n    max_age  = max(age_years, na.rm=T),\n    min_age  = min(age_years, na.rm=T),\n    n_males    = sum(gender == \"m\", na.rm=T))## # A tibble: 3 × 6\n##   outcome n_cases mean_age max_age min_age n_males\n##   <chr>     <int>    <dbl>   <dbl>   <dbl>   <int>\n## 1 Death      2582     15.9      76       0    1228\n## 2 Recover    1983     16.1      84       0     950\n## 3 <NA>       1323     16.2      69       0     625"},{"path":"verileri-gruplama.html","id":"sayımlar-ve-seriler","chapter":"13 Verileri Gruplama","heading":"13.5 Sayımlar ve seriler","text":"count() ve tally() benzer işlevsellik sağlar ancak farklıdır. “tally()” ve “count()” arasındaki fark hakkında daha fazla bilgiyi buradan okuyabilirsiniz.","code":""},{"path":"verileri-gruplama.html","id":"tally","chapter":"13 Verileri Gruplama","heading":"tally()","text":"“tally()”, “summarise(n = n())” ifadesinin kısaltmasıdır ve verileri gruplandırmaz. Bu nedenle, gruplandırılmış çetelelere ulaşmak için bir ‘group_by()’ komutunu izlemesi gerekir. Önce en büyük grupları görmek için sort = TRUE ekleyebilirsiniz.","code":"\nlinelist %>% \n  tally()##      n\n## 1 5888\nlinelist %>% \n  group_by(outcome) %>% \n  tally(sort = TRUE)## # A tibble: 3 × 2\n##   outcome     n\n##   <chr>   <int>\n## 1 Death    2582\n## 2 Recover  1983\n## 3 <NA>     1323"},{"path":"verileri-gruplama.html","id":"count","chapter":"13 Verileri Gruplama","heading":"count()","text":"Buna karşılık, “count()” şunları yapar:belirtilen sütun(lar)group_by() uygular“summarise()” uygular ve grup başına satır sayısıyla “n” sütununu döndürürungroup() uygularTıpkı ‘group_by()’ ile olduğu gibi, ‘count()’ komutu için de yeni bir sütun oluşturabilirsiniz:count(), “yuvarlama”nın kullanışlılığı ile birden çok kez çağrılabilir. Örneğin, bir cinsiyet için mevcut hastanelerin sayısını özetlemek için aşağıdakileri çalıştırın. Son sütunun adının, netlik için varsayılan “n” yerine değiştirildiğini unutmayın (name = ile).","code":"\nlinelist %>% \n  count(outcome)##   outcome    n\n## 1   Death 2582\n## 2 Recover 1983\n## 3    <NA> 1323\nlinelist %>% \n  count(age_class = ifelse(age >= 18, \"adult\", \"child\"), sort = T)##   age_class    n\n## 1     child 3618\n## 2     adult 2184\n## 3      <NA>   86\nlinelist %>% \n  # benzersiz sonuç-cinsiyet gruplarına göre sayımlar üretmek\n  count(gender, hospital) %>% \n  #cinsiyete göre satırları toplayın (3) ve cinsiyete göre hastane sayısını sayın (6)\n  count(gender, name = \"hospitals per gender\" ) ##   gender hospitals per gender\n## 1      f                    6\n## 2      m                    6\n## 3   <NA>                    6"},{"path":"verileri-gruplama.html","id":"sayıları-ekle","chapter":"13 Verileri Gruplama","heading":"Sayıları ekle","text":"‘count()’ ve ‘summarise()’aksine, diğer tüm veri çerçevesi sütunlarını korurken grup başına satır sayısıyla yeni bir ’n’ sütunu eklemek için ‘add_count()’ kullanabilirsiniz.Bu, yeni n sütunundaki bir grubun sayım numarasının grubun satırına yazdırılacağı anlamına gelir. Gösteri amacıyla, bu sütunu ekliyoruz ve daha sonra daha kolay görüntüleme için sütunları yeniden düzenliyoruz. Başka bir örnek için aşağıdaki grup boyutuna göre filtrele bölümüne bakabilirsiniz.","code":"\nlinelist %>% \n  as_tibble() %>%                   # daha güzel baskı için tibble'a dönüştürün\n  add_count(hospital) %>%           # hastaneye göre sayılarla n sütunu ekle\n  select(hospital, n, everything()) # demo amaçlı yeniden düzenlemek## # A tibble: 5,888 × 31\n##    hospital          n case_id gener…¹ date_inf…² date_onset date_hos…³ date_out…⁴ outcome gender   age age_u…⁵ age_y…⁶\n##    <chr>         <int> <chr>     <dbl> <date>     <date>     <date>     <date>     <chr>   <chr>  <dbl> <chr>     <dbl>\n##  1 Other           885 5fe599        4 2014-05-08 2014-05-13 2014-05-15 NA         <NA>    m          2 years         2\n##  2 Missing        1469 8689b7        4 NA         2014-05-13 2014-05-14 2014-05-18 Recover f          3 years         3\n##  3 St. Mark's M…   422 11f8ea        2 NA         2014-05-16 2014-05-18 2014-05-30 Recover m         56 years        56\n##  4 Port Hospital  1762 b8812a        3 2014-05-04 2014-05-18 2014-05-20 NA         <NA>    f         18 years        18\n##  5 Military Hos…   896 893f25        3 2014-05-18 2014-05-21 2014-05-22 2014-05-29 Recover m          3 years         3\n##  6 Port Hospital  1762 be99c8        3 2014-05-03 2014-05-22 2014-05-23 2014-05-24 Recover f         16 years        16\n##  7 Missing        1469 07e3e8        4 2014-05-22 2014-05-27 2014-05-29 2014-06-01 Recover f         16 years        16\n##  8 Missing        1469 369449        4 2014-05-28 2014-06-02 2014-06-03 2014-06-07 Death   f          0 years         0\n##  9 Missing        1469 f393b4        4 NA         2014-06-05 2014-06-06 2014-06-18 Recover m         61 years        61\n## 10 Missing        1469 1389ca        4 NA         2014-06-05 2014-06-07 2014-06-09 Death   f         27 years        27\n## # … with 5,878 more rows, 18 more variables: age_cat <fct>, age_cat5 <fct>, lon <dbl>, lat <dbl>, infector <chr>,\n## #   source <chr>, wt_kg <dbl>, ht_cm <dbl>, ct_blood <dbl>, fever <chr>, chills <chr>, cough <chr>, aches <chr>,\n## #   vomit <chr>, temp <dbl>, time_admission <chr>, bmi <dbl>, days_onset_hosp <dbl>, and abbreviated variable names\n## #   ¹​generation, ²​date_infection, ³​date_hospitalisation, ⁴​date_outcome, ⁵​age_unit, ⁶​age_years"},{"path":"verileri-gruplama.html","id":"toplamları-ekle","chapter":"13 Verileri Gruplama","heading":"Toplamları ekle","text":"“tally()” veya “count()” kullandıktan sonra toplam sum satırlarını veya sütunlarını kolayca eklemek için Tanımlayıcı tablolar sayfasının janitor bölümüne bakın. Bu paket, toplamları eklemek ve yüzdeleri göstermek için dönüştürmek için ‘adorn_totals()’ ve ‘adorn_percentages()’ gibi fonksiyonlar sunar. Aşağıda kısa bir örnek verilmiştir:Toplamlar dışında özet istatistikleri içeren daha karmaşık ‘sums’ satırları eklemek için Tanımlayıcı Tablolar sayfasının bu bölümüne bakabilirsiniz.","code":"\nlinelist %>%                                  # vaka satır listesi \n  tabyl(age_cat, gender) %>%                  # iki sütunun çapraz tablo sayımları\n  adorn_totals(where = \"row\") %>%             # toplam satır ekle\n  adorn_percentages(denominator = \"col\") %>%  # sütun paydası ile oranlara dönüştürme\n  adorn_pct_formatting() %>%                  # oranları yüzdelere çevir\n  adorn_ns(position = \"front\") %>%            # \"count (percent)\" olarak göster\n  adorn_title(                                # başlıkları ayarla\n    row_name = \"Age Category\",\n    col_name = \"Gender\")##                      Gender                           \n##  Age Category             f             m          NA_\n##           0-4  640  (22.8%)  416  (14.8%)  39  (14.0%)\n##           5-9  641  (22.8%)  412  (14.7%)  42  (15.1%)\n##         10-14  518  (18.5%)  383  (13.7%)  40  (14.4%)\n##         15-19  359  (12.8%)  364  (13.0%)  20   (7.2%)\n##         20-29  468  (16.7%)  575  (20.5%)  30  (10.8%)\n##         30-49  179   (6.4%)  557  (19.9%)  18   (6.5%)\n##         50-69    2   (0.1%)   91   (3.2%)   2   (0.7%)\n##           70+    0   (0.0%)    5   (0.2%)   1   (0.4%)\n##          <NA>    0   (0.0%)    0   (0.0%)  86  (30.9%)\n##         Total 2807 (100.0%) 2803 (100.0%) 278 (100.0%)"},{"path":"verileri-gruplama.html","id":"tarihe-göre-gruplama","chapter":"13 Verileri Gruplama","heading":"13.6 Tarihe göre gruplama","text":"Verileri tarihe göre gruplarken, ilgilenilen tarih birimi için bir sütuna sahip olmalısınız (veya oluşturmalısınız) (örneğin “gün”, “epiweek”, “ay”, vb.) lubridate’den ‘floor_date()’ kullanarak bu sütunu oluşturabilirsiniz. Tarihlerle çalışma sayfasının Epidemiyolojik haftalar bölümünde açıklandığı gibi. Bu sütuna sahip olduğunuzda, satırları bu benzersiz tarih değerlerine göre gruplandırmak ve toplam sayıları elde etmek için dplyr’den count() kullanabilirsiniz.Tarih durumları için ortak bir ek adım, dizide verilerde mevcut olmayan tüm tarihleri ​​“doldurmaktır”. tidyr’den ‘complete()’ kullanın, böylece aralık içindeki tüm olası tarih birimleri dahil olmak üzere toplu tarih serisi tamamlanır. Bu adım olmadan, hiçbir vakanın bildirilmediği bir hafta verilerinizde görünmeyebilir!‘complete()’ içinde, tarih sütununuzu minimumdan maksimuma ‘seq.Date()’ tarihlerinin bir dizisi olarak yeniden tanımlarsınız. Böylece tarihler genişletilir. Varsayılan olarak, herhangi bir yeni “genişletilmiş” satırdaki büyük/küçük harf sayısı değerleri “NA” olacaktır. Adlandırılmış bir liste bekleyen ‘complete()’ öğesinin ‘fill =’ değişkenini kullanarak bunları 0’ayarlayabilirsiniz (sayımlar sütununuz ‘n’ olarak adlandırılmışsa, ‘fill = list(n = 0)’ sağlayın. Ayrıntılar için ?complete’ komutuna ve örnek için Tarihlerle çalışma sayfasına bakabilirsiniz.","code":""},{"path":"verileri-gruplama.html","id":"günlere-göre-satır-listesi-vakaları","chapter":"13 Verileri Gruplama","heading":"Günlere göre satır listesi vakaları","text":"Burada, “complete()” kullanılmadan ​günlere göre gruplandırma örneği verilmiştir. İlk satırların hiçbir durum olmadan tarihleri atladığını unutmayın.Aşağıda, aralıktaki günün temsil edilmesini sağlamak için complete() komutunu ekliyoruz.","code":"\ndaily_counts <- linelist %>% \n  drop_na(date_onset) %>%        # date_onset eksik olanları kaldırın\n  count(date_onset)              # benzersiz tarih başına satır sayısını say\ndaily_counts <- linelist %>% \n  drop_na(date_onset) %>%                 # date_onset eksik vakayı kaldır\n  count(date_onset) %>%                   # benzersiz tarih başına satır sayısını say\n  complete(                               # hiçbir vaka olmasa bile tüm günlerin görünmesini sağlayın\n    date_onset = seq.Date(                # tarih sütununu günlük tarih dizisi olarak yeniden tanımlayın\n      from = min(date_onset, na.rm=T), \n      to = max(date_onset, na.rm=T),\n      by = \"day\"),\n    fill = list(n = 0))                   # yeni doldurulmuş satırları n sütununda 0 gösterecek şekilde ayarla (varsayılan olarak NA değil) "},{"path":"verileri-gruplama.html","id":"haftalara-bölünmüş-satır-listesi-vakaları","chapter":"13 Verileri Gruplama","heading":"Haftalara bölünmüş satır listesi vakaları","text":"Aynı prensip haftalarca uygulanabilir. İlk önce, unit = \"hafta\" ile floor_date() kullanarak vakanın haftası olan yeni bir sütun oluşturun. Ardından, haftalık vaka sayılarına ulaşmak için yukarıdaki gibi count() kullanın. Hiçbir vaka içermeseler bile tüm haftaların temsil edildiğinden emin olmak için “complete()” ile bitirin.Ortaya çıkan veri çerçevesinin ilk 50 satırı:","code":"\n# Haftalık vaka sayımlarının veri setini yapın\nweekly_counts <- linelist %>% \n  drop_na(date_onset) %>%                 # date_onset eksik vakaları kaldırın\n  mutate(week = lubridate::floor_date(date_onset, unit = \"week\")) %>%  # başlangıç haftasının yeni sütunu\n  count(week) %>%                         # verileri haftaya göre gruplandır ve grup başına satırları say\n  complete(                               # hiçbir vaka olmasa bile tüm günlerin görünmesini sağlayın\n    week = seq.Date(                      # tarih sütununu günlük tarih dizisi olarak yeniden tanımlayın\n      from = min(week, na.rm=T), \n      to = max(week, na.rm=T),\n      by = \"week\"),\n    fill = list(n = 0))                   # yeni doldurulmuş satırları n sütununda 0 gösterecek şekilde ayarla (varsayılan olarak NA değil)"},{"path":"verileri-gruplama.html","id":"aylara-ayrılmış-satır-listesi-vakaları","chapter":"13 Verileri Gruplama","heading":"Aylara ayrılmış satır listesi vakaları","text":"Vakaları aylara toplamak için, yine lubridate paketinden ‘floor_date()’ kullanın, ancak ‘unit= “months”’ bağımsız değişkeni ile. Bu, tarihi ayın 1’ine yuvarlar. Çıktı, Date sınıfı olacaktır. complete() adımında = \"aylar\" ifadesini de kullandığımızı unutmayın.","code":"\n# Aylık vaka sayımlarının veri setini yapın\nmonthly_counts <- linelist %>% \n  drop_na(date_onset) %>% \n  mutate(month = lubridate::floor_date(date_onset, unit = \"months\")) %>%  # yeni sütun, başlangıcın 1. ayı\n  count(month) %>%                          # vakaları aya göre saymak\n  complete(\n    month = seq.Date(\n      min(month, na.rm=T),     # hiçbir vakanın bildirilmediği tüm ayları dahil et\n      max(month, na.rm=T),\n      by=\"month\"),\n    fill = list(n = 0))"},{"path":"verileri-gruplama.html","id":"haftalara-göre-günlük-sayım","chapter":"13 Verileri Gruplama","heading":"Haftalara göre günlük sayım","text":"Günlük sayıları haftalık sayımlarda toplamak için yukarıdaki gibi floor_date() kullanın. Ancak, “count()” yerine “group_by()” ve “summarize()” kullanın, çünkü yalnızca haftalık satır sayısını saymak yerine günlük vaka sayılarını “sum()” yapmanız gerekir.","code":""},{"path":"verileri-gruplama.html","id":"aylara-göre-günlük-sayımlar","chapter":"13 Verileri Gruplama","heading":"Aylara göre günlük sayımlar","text":"Günlük sayıları ay sayılarına toplamak için, yukarıdaki gibi “unit =”month”” ile “floor_date()” kullanın. Ancak, ‘count()’ yerine ‘group_by()’ ve ‘summarize()’ kullanın çünkü sadece aylık satır sayısını saymak yerine günlük vaka sayılarını ‘sum()’ yapmanız gerekir.","code":""},{"path":"verileri-gruplama.html","id":"gruplandırılmış-verileri-düzenleme","chapter":"13 Verileri Gruplama","heading":"13.7 Gruplandırılmış verileri düzenleme","text":"Bir veri çerçevesindeki satırları sıralamak için dplyr fiilinin “arrange()” kullanılması, “.by_group =TRUE” bağımsız değişkenini ayarlamadığınız sürece, veriler gruplandığında aynı şekilde davranır. Bu durumda, satırlar önce gruplandırma sütunlarına ve ardından ‘arrange()’ için belirttiğiniz diğer sütunlara göre sıralanır.","code":""},{"path":"verileri-gruplama.html","id":"gruplandırılmış-verilere-filtre-uygula","chapter":"13 Verileri Gruplama","heading":"13.8 Gruplandırılmış verilere filtre uygula","text":"","code":""},{"path":"verileri-gruplama.html","id":"filtre","chapter":"13 Verileri Gruplama","heading":"filtre()","text":"Veri çerçevesini değerlendiren işlevlerle birlikte uygulandığında (‘max()’, ‘min()’, ‘mean()’ gibi), bu fonksiyonlar artık gruplara uygulanacaktır. Örneğin, hastaların medyan yaşın üzerinde olduğu satırları filtrelemek ve tutmak istiyorsanız, bu artık grup için geçerli olacaktır - satırları grubun medyan yaşının üzerinde tutmak için filtreleyin.","code":""},{"path":"verileri-gruplama.html","id":"grup-başına-satırları-dilimleyin","chapter":"13 Verileri Gruplama","heading":"Grup başına satırları dilimleyin","text":"Verilerdeki satırları konumlarına göre filtreleyen dplyr slice() fonksiyonu da grup başına uygulanabilir. İstenilen “dilimi” elde etmek için grup içindeki verileri sıralamayı unutmayın.Örneğin, hastaneden yalnızca en son 5 başvuruyu almak için:Satır listesini “hastane” sütununa göre gruplandırınKayıtları en geçten en erken ’hastaneye yatış tarihi’ne hastane grubu içinde düzenleyinHer hastaneden ilk 5 sırayı almak için dilimleyinslice_head() - üstten n satır seçer\nslice_tail() - sondan n satır seçer\nslice_sample() - n satırı rastgele seçer\nslice_min() - order_by = sütununda en yüksek değerlere sahip n satırı seçer, bağları korumak için with_ties = TRUE kullanın\n‘slice_max()’ - ‘order_by =’ sütununda en düşük değerlere sahip n satırı seçer, bağları korumak için ’with_ties = TRUE’yu kullanınslice() hakkında daha fazla örnek ve ayrıntı için Tekilleştirme sayfasına bakabilirsiniz.","code":"\nlinelist %>%\n  group_by(hospital) %>%\n  arrange(hospital, date_hospitalisation) %>%\n  slice_head(n = 5) %>% \n  arrange(hospital) %>%                            \n  select(case_id, hospital, date_hospitalisation)  # görüntülemek için## # A tibble: 30 × 3\n## # Groups:   hospital [6]\n##    case_id hospital          date_hospitalisation\n##    <chr>   <chr>             <date>              \n##  1 20b688  Central Hospital  2014-05-06          \n##  2 d58402  Central Hospital  2014-05-10          \n##  3 b8f2fd  Central Hospital  2014-05-13          \n##  4 acf422  Central Hospital  2014-05-28          \n##  5 275cc7  Central Hospital  2014-05-28          \n##  6 d1fafd  Military Hospital 2014-04-17          \n##  7 974bc1  Military Hospital 2014-05-13          \n##  8 6a9004  Military Hospital 2014-05-13          \n##  9 09e386  Military Hospital 2014-05-14          \n## 10 865581  Military Hospital 2014-05-15          \n## # … with 20 more rows"},{"path":"verileri-gruplama.html","id":"group_filter_grp_size","chapter":"13 Verileri Gruplama","heading":"Grup boyutuna göre filtreleyin","text":"‘add_count()’ fonksiyonu, o satırın grubundaki satır sayısını veren orijinal verilere bir ‘n’ sütunu ekler.Aşağıda gösterildiği gibi, “hastane” sütununa “add_count()” uygulanır, bu nedenle yeni “n” sütunundaki değerler, o satırın hastane grubundaki satır sayısını yansıtır. ‘n’ sütunundaki değerlerin nasıl tekrarlandığına dikkat edin. Aşağıdaki örnekte, ‘n’ sütun adı ‘add_count()’ içindeki ‘name =’ kullanılarak değiştirilebilir. Gösteri amacıyla sütunları select() ile yeniden düzenliyoruz.Ardından “küçük” bir hastanede, örneğin 500’den az hastayı kabul eden bir hastanede yatan vaka sıralarını filtrelemek kolaylaşıyor:","code":"\nlinelist %>% \n  as_tibble() %>% \n  add_count(hospital) %>%          # \"bu sıra ile aynı hastaneye kabul edilen sıra sayısı\" ekle\n  select(hospital, n, everything())## # A tibble: 5,888 × 31\n##    hospital          n case_id gener…¹ date_inf…² date_onset date_hos…³ date_out…⁴ outcome gender   age age_u…⁵ age_y…⁶\n##    <chr>         <int> <chr>     <dbl> <date>     <date>     <date>     <date>     <chr>   <chr>  <dbl> <chr>     <dbl>\n##  1 Other           885 5fe599        4 2014-05-08 2014-05-13 2014-05-15 NA         <NA>    m          2 years         2\n##  2 Missing        1469 8689b7        4 NA         2014-05-13 2014-05-14 2014-05-18 Recover f          3 years         3\n##  3 St. Mark's M…   422 11f8ea        2 NA         2014-05-16 2014-05-18 2014-05-30 Recover m         56 years        56\n##  4 Port Hospital  1762 b8812a        3 2014-05-04 2014-05-18 2014-05-20 NA         <NA>    f         18 years        18\n##  5 Military Hos…   896 893f25        3 2014-05-18 2014-05-21 2014-05-22 2014-05-29 Recover m          3 years         3\n##  6 Port Hospital  1762 be99c8        3 2014-05-03 2014-05-22 2014-05-23 2014-05-24 Recover f         16 years        16\n##  7 Missing        1469 07e3e8        4 2014-05-22 2014-05-27 2014-05-29 2014-06-01 Recover f         16 years        16\n##  8 Missing        1469 369449        4 2014-05-28 2014-06-02 2014-06-03 2014-06-07 Death   f          0 years         0\n##  9 Missing        1469 f393b4        4 NA         2014-06-05 2014-06-06 2014-06-18 Recover m         61 years        61\n## 10 Missing        1469 1389ca        4 NA         2014-06-05 2014-06-07 2014-06-09 Death   f         27 years        27\n## # … with 5,878 more rows, 18 more variables: age_cat <fct>, age_cat5 <fct>, lon <dbl>, lat <dbl>, infector <chr>,\n## #   source <chr>, wt_kg <dbl>, ht_cm <dbl>, ct_blood <dbl>, fever <chr>, chills <chr>, cough <chr>, aches <chr>,\n## #   vomit <chr>, temp <dbl>, time_admission <chr>, bmi <dbl>, days_onset_hosp <dbl>, and abbreviated variable names\n## #   ¹​generation, ²​date_infection, ³​date_hospitalisation, ⁴​date_outcome, ⁵​age_unit, ⁶​age_years\nlinelist %>% \n  add_count(hospital) %>% \n  filter(n < 500)"},{"path":"verileri-gruplama.html","id":"gruplandırılmış-verileri-dönüştürün","chapter":"13 Verileri Gruplama","heading":"13.9 Gruplandırılmış verileri dönüştürün","text":"Tüm sütunları ve satırları (özetleme değil) korumak ve grup istatistiklerini içeren yeni bir sütun eklemek için, ‘özet()’ yerine ‘group_by()’dan sonra ’mutate()’ kullanın.Bu, orijinal veri kümesinde diğer tüm sütunların mevcut olduğu grup istatistiklerini istiyorsanız yararlıdır - ör. bir satırı kendi grubuyla karşılaştıran hesaplamalar için.Örneğin, aşağıdaki kod, bir satırın kabul gecikmesi ile hastaneleri için medyan gecikme arasındaki farkı hesaplar. Adımlar:Verileri hastaneye göre gruplandırıno satırın hastanede ortalama gecikmesini içeren yeni bir sütun oluşturmak için “days_onset_hosp” (hastaneye yatış gecikmesi) sütununu kullanınİki sütun arasındaki farkı hesaplayınGösteri amacıyla yalnızca belirli sütunları “select()” olarak seçiyoruz.","code":"\nlinelist %>% \n  # hastaneye göre grup verileri (henüz satır listesinde değişiklik yok)\n  group_by(hospital) %>% \n  \n  # Yeni sütunlar\n  mutate(\n    # hastaneye kabule kadar geçen ortalama gün sayısı (1 ondalık sayıya yuvarlanır)\n    group_delay_admit = round(mean(days_onset_hosp, na.rm=T), 1),\n    \n    # sıra gecikmesi ile hastanelerindeki ortalama gecikme arasındaki fark (1 ondalık basamağa yuvarlanır)\n    diff_to_group     = round(days_onset_hosp - group_delay_admit, 1)) %>%\n  \n  # yalnızca belirli satırları seçin - gösterim/görüntüleme amaçlı\n  select(case_id, hospital, days_onset_hosp, group_delay_admit, diff_to_group)## # A tibble: 5,888 × 5\n## # Groups:   hospital [6]\n##    case_id hospital                             days_onset_hosp group_delay_admit diff_to_group\n##    <chr>   <chr>                                          <dbl>             <dbl>         <dbl>\n##  1 5fe599  Other                                              2               2             0  \n##  2 8689b7  Missing                                            1               2.1          -1.1\n##  3 11f8ea  St. Mark's Maternity Hospital (SMMH)               2               2.1          -0.1\n##  4 b8812a  Port Hospital                                      2               2.1          -0.1\n##  5 893f25  Military Hospital                                  1               2.1          -1.1\n##  6 be99c8  Port Hospital                                      1               2.1          -1.1\n##  7 07e3e8  Missing                                            2               2.1          -0.1\n##  8 369449  Missing                                            1               2.1          -1.1\n##  9 f393b4  Missing                                            1               2.1          -1.1\n## 10 1389ca  Missing                                            2               2.1          -0.1\n## # … with 5,878 more rows"},{"path":"verileri-gruplama.html","id":"gruplandırılmış-verileri-seçin","chapter":"13 Verileri Gruplama","heading":"13.10 Gruplandırılmış verileri seçin","text":"‘select()’ fiili gruplandırılmış veriler üzerinde çalışır, ancak gruplandırma sütunları zaman dahil edilir (‘select()’ içinde belirtilmemiş olsa bile). Bu gruplama sütunlarını istemiyorsanız, önce ungroup() kullanın.","code":""},{"path":"verileri-gruplama.html","id":"kaynaklar-6","chapter":"13 Verileri Gruplama","heading":"13.11 Kaynaklar","text":"Daha fazla bilgi için bazı yararlı kaynaklar şunlardır:Gruplandırılmış veriler üzerinde herhangi bir özet fonksiyonu gerçekleştirebilirsiniz; RStudio veri dönüştürme bilgi sayfasına bakabilirsiniz.dplyr adresindeki Veri Marangozluğu sayfası\ngroup_by() ve grouping üzerindeki tidyverse referans sayfaları.Bu sayfa Veri manipülasyonudplyr’deki koşullarla özetleyin","code":""},{"path":"veri-birleştirme.html","id":"veri-birleştirme","chapter":"14 Veri Birleştirme","heading":"14 Veri Birleştirme","text":"Yukarıda: sol birleştirmenin animasyonlu bir örneği (görüntünün kaynağı)Bu sayfa, “birleştirme(join)”, “eşleştirme(match)”, “ilişkilendirme(link)” “bağlantı kurma(bind)” ve veri çerçevelerini başka şekilde harmanlamanın yollarını açıklamaktadır.Epidemiyolojik analizinizin veya iş akışınızın birden çok veri kaynağını ve birden çok veri kümesinin bağlantısını içermemesi nadir görülen bir durumdur. Belki de laboratuvar verilerini hastanın klinik sonuçlarına veya Google mobilite verilerini bulaşıcı hastalık eğilimlerine, hatta analizin bir aşamasındaki bir veri kümesini kendisinin dönüştürülmüş bir versiyonuna bağlamanız gerekebilir.Bu sayfada aşağıdakilere yönelik kodu gösteriyoruz:Satırların tanımlayıcı sütunlarındaki ortak değerlere göre eşleştirileceği şekilde iki veri çerçevesinin birleştirilmesiDeğerler arasındaki olasılıklı (likely) eşleşmelere dayalı iki veri çerçevesini birleştirmeBaşka bir veri çerçevesinden satırları veya sütunları doğrudan bağlayarak veya (“ekleyerek”) bir veri çerçevesini genişletme","code":""},{"path":"veri-birleştirme.html","id":"hazırlık-5","chapter":"14 Veri Birleştirme","heading":"14.1 Hazırlık","text":"","code":""},{"path":"veri-birleştirme.html","id":"paketleri-yükleme-1","chapter":"14 Veri Birleştirme","heading":"Paketleri yükleme","text":"Bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan ‘p_load()’ vurgusunu yapıyoruz. base R’dan library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakın.","code":"\npacman::p_load(\n  rio,            # içe aktar ve dışa aktar\n  here,           # dosyaların yerini belirle\n  tidyverse,      # veri yönetimi ve görselleştirme\n  RecordLinkage,  # olasılıksal eşleşme\n  fastLink        # olasılıksal eşleşme\n)"},{"path":"veri-birleştirme.html","id":"verileri-içe-aktarma-1","chapter":"14 Veri Birleştirme","heading":"Verileri içe aktarma","text":"Başlamak için, simüle edilmiş bir Ebola salgınından temizlenmiş vaka listesini içe aktarıyoruz. Takip etmek isterseniz click download “clean” linelist (.rds dosyası olarak). rio paketinden import() fonksiyonuyla verileri içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe aktarma ve dışa aktarma] sayfasına bakın).Satır listesinin ilk 50 satırı aşağıda gösterilmiştir.","code":"\n# vaka satır listesini içe aktarma \nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"veri-birleştirme.html","id":"örnek-veri-kümeleri","chapter":"14 Veri Birleştirme","heading":"Örnek veri kümeleri","text":"Aşağıdaki birleştirme bölümünde, aşağıdaki veri kümelerini kullanacağız:Yalnızca “case_id”, “date_onset” ve “hospital” sütunlarını ve yalnızca ilk 10 satırı içeren “vaka satır listesinin” “minyatür” versiyonuHer hastane hakkında daha fazla ayrıntı içeren “hosp_info” adlı ayrı bir veri çerçevesiOlasılıksal eşleştirme bölümünde iki farklı küçük veri seti kullanacağız. Bu veri kümelerini oluşturacak kod o bölümde verilmiştir.","code":""},{"path":"veri-birleştirme.html","id":"joins_llmini","chapter":"14 Veri Birleştirme","heading":"“Minyatür” vaka satır listesi","text":"Aşağıda, yalnızca 10 satır ve yalnızca “case_id”, “date_onset” ve “hospital” sütunlarını içeren minyatür vaka satır listesi bulunmaktadır.","code":"\nlinelist_mini <- linelist %>%                 # orijinal satır listesiyle başla\n  select(case_id, date_onset, hospital) %>%   # sütunları seç\n  head(10)                                    # sadece ilk 10 satırı al"},{"path":"veri-birleştirme.html","id":"joins_hosp_info","chapter":"14 Veri Birleştirme","heading":"Hastane bilgi veri çerçevesi","text":"Aşağıda, yedi hastane hakkında ek bilgi içeren ayrı bir veri çerçevesi oluşturma kodu verilmiştir (çalışma alanı nüfusu ve mevcut bakım düzeyi). “Askeri Hastane” adının iki farklı hastaneye ait olduğunu unutmayın - biri 10000 kişiye hizmet veren birinci basamak ve diğeri 50280 kişiye hizmet veren ikinci basamak.İşte bu veri çerçevesi:","code":"\n#Hastane bilgi veri çerçevesini yapın\nhosp_info = data.frame(\n  hosp_name     = c(\"central hospital\", \"military\", \"military\", \"port\", \"St. Mark's\", \"ignace\", \"sisters\"),\n  catchment_pop = c(1950280, 40500, 10000, 50280, 12000, 5000, 4200),\n  level         = c(\"Tertiary\", \"Secondary\", \"Primary\", \"Secondary\", \"Secondary\", \"Primary\", \"Primary\")\n)"},{"path":"veri-birleştirme.html","id":"ön-temizleme","chapter":"14 Veri Birleştirme","heading":"Ön temizleme","text":"Geleneksel birleştirmeler (olasılıksız) büyük/küçük harfe duyarlıdır ve iki veri çerçevesindeki değerler arasında tam karakter eşleşmeleri gerektirir. Bir birleştirmeyi başlatmadan önce yapmanız gerekebilecek bazı temizleme adımlarını göstermek için, şimdi ‘linelist_mini’ ve ‘hosp_info’ veri kümelerini temizleyip hizalayacağız.Farklılıkları tanımlayın‘linelist_mini’ veri çerçevesindeki ‘hospital’ sütununun değerleriyle eşleşmesi için ‘hosp_info’ veri çerçevesindeki ‘hosp_name’ sütununun değerlerine ihtiyacımız var.base R fonksiyonu ‘unique()’ ile yazdırılan ‘linelist_mini’ veri çerçevesindeki değerler şunlardır:ve burada “hosp_info” veri çerçevesindeki değerler:iki veri çerçevesinde de bazı hastaneler varken, yazımda birçok farklılık olduğunu görebilirsiniz.Değerleri hizalahosp_info veri çerçevesindeki değerleri temizleyerek başlıyoruz. [Temizleme verileri ve temel fonksiyonlar] sayfasında açıklandığı gibi, dplyr’case_while() fonksiyonunu kullanarak değerleri mantıksal kriterlerle yeniden kodlayabiliriz. iki veri çerçevesinde de bulunan dört hastane için değerleri, ‘linelist_mini’ içindeki değerlerle uyumlu olacak şekilde değiştiriyoruz. Diğer hastanelerde değerleri olduğu gibi bırakıyoruz (TRUE ~ hosp_name).UYARI: Genellikle temizlik yapılırken yeni bir sütun oluşturulmalıdır (ör. hosp_name_clean),\nancak gösterim kolaylığı için eski sütunun modifikasyonunu gösteriyoruzHer iki veri çerçevesinde de görünen hastane adları hizalanmıştır. “Hosp_info”da “linelist_mini”de bulunmayan iki hastane vardır - bunları daha sonra, birleştirmede ele alacağız.Birleştirmeden önce, bir sütunu tamamen küçük harfe veya tamamı büyük harfe dönüştürmek genellikle en kolayıdır. Bir sütundaki tüm değerleri BÜYÜK veya küçük harfe dönüştürmeniz gerekiyorsa, ‘mutate()’ kullanın ve sütunustringr’ fonksiyonlarından biriyle sarın. Karakterler ve dizeler sayfasında gösterildiği gibistr_to_upper()str_to_upper()str_to_title()","code":"\nunique(linelist_mini$hospital)## [1] \"Other\"                                \"Missing\"                             \n## [3] \"St. Mark's Maternity Hospital (SMMH)\" \"Port Hospital\"                       \n## [5] \"Military Hospital\"\nunique(hosp_info$hosp_name)## [1] \"central hospital\" \"military\"         \"port\"             \"St. Mark's\"       \"ignace\"           \"sisters\"\nhosp_info <- hosp_info %>% \n  mutate(\n    hosp_name = case_when(\n      # criteria                         # yeni değer\n      hosp_name == \"military\"          ~ \"Military Hospital\",\n      hosp_name == \"port\"              ~ \"Port Hospital\",\n      hosp_name == \"St. Mark's\"        ~ \"St. Mark's Maternity Hospital (SMMH)\",\n      hosp_name == \"central hospital\"  ~ \"Central Hospital\",\n      TRUE                             ~ hosp_name\n      )\n    )\nunique(hosp_info$hosp_name)## [1] \"Central Hospital\"                     \"Military Hospital\"                   \n## [3] \"Port Hospital\"                        \"St. Mark's Maternity Hospital (SMMH)\"\n## [5] \"ignace\"                               \"sisters\""},{"path":"veri-birleştirme.html","id":"dplyr-birleştirmeleri","chapter":"14 Veri Birleştirme","heading":"14.2 dplyr birleştirmeleri","text":"dplyr paketi birkaç farklı birleştirme fonksiyonu sunar. dplyr, tidyverse paketine dahildir. Bu birleştirme fonksiyonları, basit kullanım durumları ile aşağıda açıklanmıştır.Bilgilendirici gifler için https://github.com/gadenbuie’e çok teşekkürler!","code":""},{"path":"veri-birleştirme.html","id":"genel-sözdizimi","chapter":"14 Veri Birleştirme","heading":"Genel sözdizimi","text":"Birleştirme komutları, iki veri çerçevesini yeni bir nesnede birleştirmek için bağımsız komutlar olarak çalıştırılabilir veya bir veri çerçevesini temizlenirken veya başka bir şekilde değiştirilirken bir veri çerçevesini diğerine birleştirmek için bir tünel zincirinde (“%>%”) kullanılabilir. .Aşağıdaki örnekte, “left_join()” fonksiyonu, yeni bir “joined_data” veri çerçevesi oluşturmak için bağımsız bir komut olarak kullanılır. Girişler, veri çerçeveleri 1 ve 2’dir (df1 ve df2). Listelenen ilk veri çerçevesi temel veri çerçevesidir ve listelenen ikincisi buna birleştirilir.Üçüncü argüman “=”, iki veri çerçevesindeki satırları hizalamak için kullanılacak veri çerçevesindeki sütunları belirttiğiniz yerdir. Bu sütunların adları farklıysa, bunları aşağıda gösterildiği gibi bir “c()” vektörü içinde sağlayın; burada satırlar “df1”deki “ID” sütunu ile “df2”deki “tanımlayıcı” sütunu arasındaki ortak değerler temelinde eşleştirilir.iki veri çerçevesindeki “” sütunları tam olarak aynı ada sahipse, bu tek adı tırnak içinde verebilirsiniz.Birden çok alandaki ortak değerlere dayalı veri çerçevelerini birleştiriyorsanız, bu alanları “c()” vektörü içinde listeleyin. Bu örnek, veri kümesindeki üç sütundaki değerler tam olarak aynı hizadaysa satırları birleştirir.Birleştirme komutları bir tünel zinciri içinde de çalıştırılabilir. Bu, aktarılan veri çerçevesini değiştirecektir.Aşağıdaki örnekte ‘df1’ tünellerden geçirilmekte, ‘df2’ ile birleştirilmekte ve böylece ‘df’ değiştirilip yeniden tanımlanmaktadır.UYARI: Birleştirmeler büyük/küçük harfe özeldir! Bu nedenle, birleştirmeden önce tüm değerleri küçük harfe veya büyük harfe dönüştürmek yararlıdır. Karakterler/dizeler ile ilgili sayfaya bakınız.","code":"\n# \"ID\" sütunu (ilk veri çerçevesi) ve \"tanımlayıcı\" sütunu (ikinci veri çerçevesi) arasındaki ortak değerlere göre birleştirme\njoined_data <- left_join(df1, df2, by = c(\"ID\" = \"identifier\"))\n# Her iki veri çerçevesindeki \"ID\" sütunundaki ortak değerlere dayalı birleştirme\njoined_data <- left_join(df1, df2, by = \"ID\")\n# aynı isim-soyisim ve yaşa sahip olanları birleştirme\njoined_data <- left_join(df1, df2, by = c(\"name\" = \"firstname\", \"surname\" = \"lastname\", \"Age\" = \"age\"))\ndf1 <- df1 %>%\n  filter(date_onset < as.Date(\"2020-03-05\")) %>% # öok yönlü temizlik\n  left_join(df2, by = c(\"ID\" = \"identifier\"))    # df2 yi df1 e birleştirmek"},{"path":"veri-birleştirme.html","id":"sol-ve-sağ-birleşimler","chapter":"14 Veri Birleştirme","heading":"Sol ve sağ birleşimler","text":"Bir veri çerçevesine bilgi eklemek için yaygın olarak sol veya sağ birleşim kullanılır - yeni bilgiler yalnızca temel veri çerçevesinde zaten var olan satırlara eklenir. Bunlar, bir veri kümesinden diğerine bilgi eklemek için kullanıldıkları için epidemiyolojik çalışmalarda yaygın olarak kullanılan birleştirmelerdir.Bu birleştirmeleri kullanırken, komuttaki veri çerçevelerinin yazılı sırası önemlidir*.Bir sol birleştirmede, yazılan ilk veri çerçevesi temel satırdırBir sağ birleştirmede, yazılan ikinci veri çerçevesi temel satırdırTemel veri çerçevesinin tüm satırları tutulur. Diğer (ikincil) veri çerçevesindeki bilgiler, temel veri çerçevesine yalnızca tanımlayıcı sütun(lar)ı aracılığıyla bir eşleşme varsa birleştirilir. Ek olarak:İkincil veri çerçevesindeki eşleşmeyen satırlar atlanır.İkincil veri çerçevesindeki bir satırla eşleşen çok sayıda temel satır varsa (çoktan bire), ikincil bilgiler eşleşen bir temel satıra eklenir.Bir temel satır, ikincil veri çerçevesindeki birden çok satırla eşleşirse (bire çok), tüm kombinasyonlar verilir, yani döndürülen veri çerçevenize yeni satırlar eklenebilir!Sol ve sağ birleştirmelerin animasyonlu örnekleri (image source)ÖrnekAşağıda, “hosp_info”nun (ikincil veri çerçevesi, buradan görüntüleyebilirsiniz) “linelist_mini”ye (temel veri çerçevesi, buradan görüntüleyebilirsiniz) bir “left_join()” çıktısı verilmiştir. Orijinal “linelist_mini”, “nrow(linelist_mini)” satırlarına sahiptir. Değiştirilen “linelist_mini” görüntülenir. Aşağıdakilere dikkat ediniz:“linelist_mini”nin sol tarafına iki yeni sütun, “catchment_pop” ve “level” eklendi‘linelist_mini’ temel veri çerçevesinin tüm orijinal satırları tutulur“Askeri Hastane” için herhangi bir orijinal “linelist_mini” satırı, ikincil veri çerçevesindeki iki satırla eşleştiği için çoğaltılır, bu nedenle iki kombinasyon da döndürülürİkincil veri kümesinin (hosp_name) birleştirme tanımlayıcı sütunu, birincil veri kümesindeki (“hastane”) tanımlayıcı sütunuyla gereksiz olduğundan kaybolduTemel satır herhangi bir ikincil satırla eşleşmediğinde (örneğin, “hastane” “Diğer” veya “Eksik” olduğunda), “NA” (boşluk) ikincil veri çerçevesindeki sütunları doldururİkincil veri çerçevesindeki temel veri çerçevesiyle eşleşmeyen satırlar (“kızkardeşler” ve “ignace” hastaneleri) çıkarıldı.","code":"\nlinelist_mini %>% \n  left_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))"},{"path":"veri-birleştirme.html","id":"sağ-birleştirme-mi-yoksa-sol-birleştirme-mi-kullanmalıyım","chapter":"14 Veri Birleştirme","heading":"“Sağ birleştirme mi yoksa sol birleştirme mi kullanmalıyım?”","text":"Yukarıdaki soruyu yanıtlamak için kendinize “hangi veri çerçevesinin tüm satırlarını tutması gerektiğini” sorun. - bunu temel satır olarak kullanın. sol birleştirme komutta yazılan ilk veri çerçevesindeki tüm satırları tutarken, sağ birleştirme tüm satırları ikinci veri çerçevesinde tutar.Aşağıdaki iki komut aynı çıktıyı elde eder - 10 satır “hosp_info” bir “linelist_mini” temel satırına katılmıştır, ancak farklı birleşimler kullanırlar. Sonuç olarak, sütun sırası, “hosp_info”nun sağdan mı (sol birleştirmede) yoksa soldan mı (sağ birleştirmede) geldiğine bağlı olarak farklılık gösterecektir. Sıraların sırası da buna göre değişebilir. Ancak bu sonuçların ikisi de daha sonra, sütunları yeniden sıralamak için “select()” veya satırları sıralamak için “arrange()” kullanılarak ele alınabilir.Sol birleşim yoluyla ‘hosp_info’nun ’linelist_mini’ içindeki sonucu (sağdan gelen yeni sütunlar)İşte sağ birleştirme yoluyla ‘hosp_info’nun ’linelist_mini’ içindeki sonucu (soldan gelen yeni sütunlar)Ayrıca kullanım durumunuzun bir tünel zinciri (%>%) içinde olup olmadığını da göz önünde bulundurun. Borulardaki veri kümesi temel satır ise, buna veri eklemek için büyük olasılıkla bir sol birleştirme kullanacaksınız.","code":"\n# Aşağıdaki iki komut aynı verileri elde eder, ancak farklı sıralı satırlar ve sütunlarla\nleft_join(linelist_mini, hosp_info, by = c(\"hospital\" = \"hosp_name\"))\nright_join(hosp_info, linelist_mini, by = c(\"hosp_name\" = \"hospital\"))"},{"path":"veri-birleştirme.html","id":"tam-birleşme","chapter":"14 Veri Birleştirme","heading":"Tam birleşme","text":"**Tam birleşim, birleşimlerin en *kapsayıcısıdır** - iki veri çerçevesinden tüm satırları döndürür.Birinde mevcut olan ve diğerinde olmayan satırlar varsa (eşleşmenin bulunmadığı durumlarda), veri çerçevesi bunları içerecek ve daha uzun olacaktır. “NA” eksik değerleri, oluşturulan boşlukları doldurmak için kullanılır. Birleştirirken, büyük/küçük harf duyarlılığı ve tam karakter eşleşmeleriyle ilgili sorunları gidermek için sütun ve satır sayısını dikkatle izleyin.“Temel satır” veri çerçevesi, komutta ilk yazılan çerçevedir. Bunun ayarlanması, birleştirme tarafından hangi kayıtların döndürüleceğini etkilemez, ancak sonuçta elde edilen sütun sırasını, satır sırasını ve hangi tanımlayıcı sütunların tutulacağını etkileyebilir.Tam birleştirmenin animasyonlu örneği (görüntü kaynağı)Örneklinelist_mininin(başlangıçtanrow(linelist_mini), buradan görüntüleyebilirsiniz içine hosp_info’nun full_join()’(başlangıçta nrow(hosp_info)`, buradan görüntüleyebilirsiniz) çıktısı aşağıda yer almaktadır. Aşağıdakilere dikkat ediniz:Tüm temel satırlar tutulur (linelist_mini)İkincil satırda temel satırla eşleşmeyen satırlar tutulur (“ignace” ve “sisters”), karşılık gelen “case_id” ve “onset” sütunlarındaki değerler eksik değerlerle doldurulurBenzer şekilde, temel veri çerçevesindeki ikincil ile eşleşmeyen satırlar (“Diğer” ve “Eksik”) tutulur, ikincil sütunlar “catchment_pop” ve “level” eksik değerlerle doldurulurBire çoğa veya çoğa bire eşleşmelerde (ör. “Askeri Hastane” satırları), tüm olası kombinasyonlar döndürülür (son veri çerçevesini uzatarak)Yalnızca temel satırdan tanımlayıcı sütun tutulur (“hastane”)","code":"\nlinelist_mini %>% \n  full_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))"},{"path":"veri-birleştirme.html","id":"iç-birleştirme","chapter":"14 Veri Birleştirme","heading":"İç birleştirme","text":"**İç birleştirme, birleştirmelerin en *kısıtlayıcısıdır** - yalnızca iki veri çerçevesinde eşleşen satırları döndürür.\nBu, temel veri çerçevesindeki satır sayısının gerçekten azalabileceği anlamına gelir. Hangi veri çerçevesinin “temel satır” (işlevde ilk olarak yazılır) olduğunun ayarlanması, hangi satırların döndürüleceğini etkilemez, ancak sütun sırasını, satır sırasını ve hangi tanımlayıcı sütunların tutulacağını etkiler.İç birleştirmenin animasyonlu örneği (görüntü kaynağı)ÖrnekAşağıda, “hosp_info” (ikincil) ile “linelist_mini”nin (temel satır) bir “inner_join()” çıktısı bulunmaktadır. Aşağıdakilere dikkat ediniz:İkincil verilerle eşleşmeyen temel satırlar kaldırılır (“hastane”nin “Eksik” veya “Diğer” olduğu satırlar)Benzer şekilde, temel satırla eşleşmeyen ikincil veri çerçevesindeki satırlar kaldırılır (“hosp_name”nin “kız kardeşler” veya “ignace” olduğu satırlar)Yalnızca temel satırdan tanımlayıcı sütun tutulur (“hastane”)","code":"\nlinelist_mini %>% \n  inner_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))"},{"path":"veri-birleştirme.html","id":"yarım-birleştirme","chapter":"14 Veri Birleştirme","heading":"Yarım birleştirme","text":"Yarım birleştirme, başka bir veri kümesini satır veya sütun eklemek için değil, filtreleme gerçekleştirmek için kullanan bir “filtreleme birleştirme”dir.Bir yarım birleştirme, ikincil veri çerçevesinde bir eşleşmeye sahip olan temel veri çerçevesindeki tüm gözlemleri tutar (ancak yeni sütunlar eklemez veya birden çok eşleşme için herhangi bir satırı çoğaltmaz). Bu “filtreleme” birleşimleri hakkında daha fazla bilgiyi buradan okuyabilirsiniz buradan.Yarım birleştirmenin animasyonlu örneği (görüntü kaynağı)Örnek olarak, aşağıdaki kod, hastane adına göre “linelist_mini” içinde eşleşmeleri olan “hosp_info” veri çerçevesinden satırları döndürür.","code":"\nhosp_info %>% \n  semi_join(linelist_mini, by = c(\"hosp_name\" = \"hospital\"))##                              hosp_name catchment_pop     level\n## 1                    Military Hospital         40500 Secondary\n## 2                    Military Hospital         10000   Primary\n## 3                        Port Hospital         50280 Secondary\n## 4 St. Mark's Maternity Hospital (SMMH)         12000 Secondary"},{"path":"veri-birleştirme.html","id":"karşıt-birleştirme","chapter":"14 Veri Birleştirme","heading":"Karşıt birleştirme","text":"Karşıt birleştirme ‘anti_join()’, temel veri çerçevesindeki ikincil veri çerçevesinde eşleşmeyen* satırları döndüren başka bir “filtreleme birleştirme”dir.Birleştirmeleri filtreleme hakkında daha fazla bilgiyi buradan okuyabilirsiniz buradan.Bir karşıt birleştirme için yaygın senaryolar arasında başka bir veri çerçevesinde mevcut olmayan kayıtların belirlenmesi, bir birleştirmedeki yazım hatalarının giderilmesi (eşleşmesi gereken kayıtların gözden geçirilmesi) ve başka bir birleştirmeden sonra hariç tutulan kayıtların incelenmesi yer alır.‘right_join()’ ve ‘left_join()’ ile olduğu gibi, temel veri çerçevesi (ilk olarak listelenmiştir) önemlidir. Döndürülen satırlar yalnızca temel veri çerçevesindendir. Alttaki gifte, ikincil veri çerçevesindeki o satırın (mor satır 4), taban çizgisiyle eşleşmemesine rağmen döndürülmediğine dikkat edin.Karşıt birleştirmenin animasyonlu örneği (görüntü kaynağı)","code":""},{"path":"veri-birleştirme.html","id":"basit-anti_join-örneği","chapter":"14 Veri Birleştirme","heading":"Basit anti_join() örneği","text":"Basit bir örnek için, ‘linelist_mini’ içinde herhangi bir vaka bulunmayan ‘hosp_info’ hastanelerini bulalım. Temel veri çerçevesi olarak önce ‘hosp_info’yu listeleriz. ’linelist_mini’ içinde bulunmayan hastaneler iade edilir.","code":"\nhosp_info %>% \n  anti_join(linelist_mini, by = c(\"hosp_name\" = \"hospital\"))"},{"path":"veri-birleştirme.html","id":"karmaşık-anti_join-örneği","chapter":"14 Veri Birleştirme","heading":"Karmaşık anti_join() örneği","text":"Başka bir örnek için, “linelist_mini” ve “hosp_info” arasında bir “inner_join()” çalıştırdığımızı varsayalım. Bazıları “hosp_info” içinde bulunmadığından, bu, orijinal “linelist_mini” kayıtlarının yalnızca bir alt kümesini döndürür.İç birleştirme sırasında hariç tutulan ‘linelist_mini’ kayıtlarını gözden geçirmek için aynı ayarlarla (temel satır olarak ‘linelist_mini’) bir ayrıştırma (anti-join) çalıştırabiliriz.İç birleşimde hariç tutulan ‘hosp_info’ kayıtlarını görmek için, temel veri çerçevesi olarak ‘hosp_info’ ile bir ayrıştırma çalıştırabiliriz.","code":"\nlinelist_mini %>% \n  inner_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))\nlinelist_mini %>% \n  anti_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))"},{"path":"veri-birleştirme.html","id":"olasılıksal-eşleştirme","chapter":"14 Veri Birleştirme","heading":"14.3 Olasılıksal eşleştirme","text":"Katılmak için veri kümeleri arasında ortak benzersiz bir tanımlayıcınız yoksa, olasılıklı bir eşleştirme algoritması kullanmayı düşünün. Bu, benzerliğe dayalı olarak kayıtlar arasındaki eşleşmeleri bulur (örneğin, Jaro–Winkler dizi mesafesi veya sayısal mesafe). Aşağıda fastLink paketini kullanan basit bir örnek verilmiştir.Paketleri yükleOlasılıksal eşleşmeyi göstermek için kullanacağımız iki küçük örnek veri kümesi (“durumlar” ve “test_sonuçları”):Veri kümelerini oluşturmak için kullanılan kod:“vakalar” veri kümesinde, test sonuçlarını bekleyen hastaların 9 kaydı vardır.test_results veri kümesi 14 kayıt içerir ve kayıtların olasılıksal eşleşmesine dayalı olarak vakalardaki kayıtlara eklemek istediğimiz sonuç sütununu içerir.","code":"\npacman::p_load(\n  tidyverse,      # veri işleme ve görselleştirme\n  fastLink        # kayıt eşleştirme\n  )\n# veri kümeleri yapmak\n\ncases <- tribble(\n  ~gender, ~first,      ~middle,     ~last,        ~yr,   ~mon, ~day, ~district,\n  \"M\",     \"Amir\",      NA,          \"Khan\",       1989,  11,   22,   \"River\",\n  \"M\",     \"Anthony\",   \"B.\",        \"Smith\",      1970, 09, 19,      \"River\", \n  \"F\",     \"Marialisa\", \"Contreras\", \"Rodrigues\",  1972, 04, 15,      \"River\",\n  \"F\",     \"Elizabeth\", \"Casteel\",   \"Chase\",      1954, 03, 03,      \"City\",\n  \"M\",     \"Jose\",      \"Sanchez\",   \"Lopez\",      1996, 01, 06,      \"City\",\n  \"F\",     \"Cassidy\",   \"Jones\",      \"Davis\",     1980, 07, 20,      \"City\",\n  \"M\",     \"Michael\",   \"Murphy\",     \"O'Calaghan\",1969, 04, 12,      \"Rural\", \n  \"M\",     \"Oliver\",    \"Laurent\",    \"De Bordow\" , 1971, 02, 04,     \"River\",\n  \"F\",      \"Blessing\",  NA,          \"Adebayo\",   1955,  02, 14,     \"Rural\"\n)\n\nresults <- tribble(\n  ~gender,  ~first,     ~middle,     ~last,          ~yr, ~mon, ~day, ~district, ~result,\n  \"M\",      \"Amir\",     NA,          \"Khan\",         1989, 11,   22,  \"River\", \"positive\",\n  \"M\",      \"Tony\",   \"B\",         \"Smith\",          1970, 09,   19,  \"River\", \"positive\",\n  \"F\",      \"Maria\",    \"Contreras\", \"Rodriguez\",    1972, 04,   15,  \"Cty\",   \"negative\",\n  \"F\",      \"Betty\",    \"Castel\",   \"Chase\",        1954,  03,   30,  \"City\",  \"positive\",\n  \"F\",      \"Andrea\",   NA,          \"Kumaraswamy\",  2001, 01,   05,  \"Rural\", \"positive\",      \n  \"F\",      \"Caroline\", NA,          \"Wang\",         1988, 12,   11,  \"Rural\", \"negative\",\n  \"F\",      \"Trang\",    NA,          \"Nguyen\",       1981, 06,   10,  \"Rural\", \"positive\",\n  \"M\",      \"Olivier\" , \"Laurent\",   \"De Bordeaux\",  NA,   NA,   NA,  \"River\", \"positive\",\n  \"M\",      \"Mike\",     \"Murphy\",    \"O'Callaghan\",  1969, 04,   12,  \"Rural\", \"negative\",\n  \"F\",      \"Cassidy\",  \"Jones\",     \"Davis\",        1980, 07,   02,  \"City\",  \"positive\",\n  \"M\",      \"Mohammad\", NA,          \"Ali\",          1942, 01,   17,  \"City\",  \"negative\",\n  NA,       \"Jose\",     \"Sanchez\",   \"Lopez\",        1995, 01,   06,  \"City\",  \"negative\",\n  \"M\",      \"Abubakar\", NA,          \"Abullahi\",     1960, 01,   01,  \"River\", \"positive\",\n  \"F\",      \"Maria\",    \"Salinas\",   \"Contreras\",    1955, 03,   03,  \"River\", \"positive\"\n  )"},{"path":"veri-birleştirme.html","id":"olasılıksal-eşleşme","chapter":"14 Veri Birleştirme","heading":"Olasılıksal eşleşme","text":"fastLink paketindeki fastLink() fonksiyonu, bir eşleştirme algoritması uygulamak için kullanılabilir. İşte temel bilgiler. Konsolunuza ?fastLink girerek daha fazla ayrıntı okuyabilirsiniz.dfA = ve dfB = değişkenleriyle karşılaştırmak için iki veri çerçevesini tanımlayın.varnames = içinde eşleştirme için kullanılacak tüm sütun adlarını verin. Hepsi hem “dfA” hem de “dfB” içinde bulunmalıdır.stringdist.match = içinde, “distance” dizesinde değerlendirilmek üzere varnames içindekilerden sütunlar verin.‘numeric.match =’ içinde, ‘varnames’ içindekilerden sayısal mesafeye göre değerlendirilecek sütunlar verin.Eksik değerler dikkate alınmazVarsayılan olarak, herhangi bir veri çerçevesindeki satır, diğer veri çerçevesindeki en fazla bir satırla eşleştirilir. Değerlendirilen tüm eşleşmeleri görmek istiyorsanız, “dedupe.matches = FALSE” olarak ayarlayın. Tekilleştirme, Winkler’doğrusal atama çözümü kullanılarak yapılır.İpucu: lubridate paketinden ‘day()’, ‘ay()’ ve ‘year()’ kullanarak bir tarih sütununu üç ayrı sayısal sütuna ayırınEşleşmeler için varsayılan eşik 0,94’tür (threshold.match =), ancak bunu daha yüksek veya daha düşük olarak ayarlayabilirsiniz. Eşiği tanımlarsanız, daha yüksek eşiklerin daha fazla yanlış-negatif (aslında eşleşmesi gereken eşleşmeyen satırlar) verebileceğini ve aynı şekilde daha düşük bir eşiğin daha fazla yanlış-pozitif eşleşmeler sağlayabileceğini düşünün.Aşağıda, veriler, ad ve bölge sütunları boyunca harf dizisi mesafesine ve yıl, ay ve doğum günü için sayısal mesafeye göre eşleştirilir. %95 olasılıkla bir eşleşme eşiği belirlenir.Eşleşmelerin incelenmesifastLink()den dönen nesneyi fl_output olarak tanımladık. ‘list’ sınıfında yer alır ve aslında içinde eşleşmenin sonuçlarını detaylandıran birkaç veri çerçevesi içerir. Bu veri çerçevelerinden biri, “durumlar” ve “sonuçlar” arasındaki en olası eşleşmeleri içeren “eşleşmeler”dir. Bu “eşleşmelere” veri çerçevesine fl_output$matches ile erişebilirsiniz. Aşağıda, daha sonra erişim kolaylığı için ‘my_matches’ olarak kaydedilmiştir.“my_matches” yazdırıldığında, iki sütun vektörü görürsünüz: “cases” (“inds.”) ve “results” (“inds.b”) içindeki satır numaraları/indeks (“satır adları” olarak da adlandırılır) çiftleri en iyi eşleşmeleri temsil eder. Bir veri çerçevesinden bir satır numarası eksikse, belirtilen eşleşme eşiğinde diğer veri çerçevesinde hiçbir eşleşme bulunamaz.Dikkat edilmesi gerekenler:İsim yazımında ve doğum tarihlerinde küçük farklılıklar olmasına rağmen eşleşmeler gerçekleşti:\n“Tony B. Smith”, “Anthony B Smith” ile eşleşti\n“Maria Rodriguez”, “Marialisa Rodrigues” ile eşleşti\n“Betty Chase”, “Elizabeth Chase” ile eşleşti\n“Olivier Laurent De Bordeaux”, “Oliver Laurent De Bordow” ile eşleştirildi (eksik doğum tarihi dikkate alınmadı)\n“Tony B. Smith”, “Anthony B Smith” ile eşleşti“Maria Rodriguez”, “Marialisa Rodrigues” ile eşleşti“Betty Chase”, “Elizabeth Chase” ile eşleşti“Olivier Laurent De Bordeaux”, “Oliver Laurent De Bordow” ile eşleştirildi (eksik doğum tarihi dikkate alınmadı)“Cases” bir satır (“Blessing Adebayo” için, 9. satır) “results”da iyi bir eşleşmeye sahip değildi, bu nedenle “eşleşmelerim”de yer verilmedi.Olasılıklı eşleşmelere göre birleştirmeBu eşleşmeleri “results” “cases” birleştirmek için strateji şudur:“my_matches”ı “cases” ile birleştirmek için “left_join()”kullanın (“cases”deki satır adlarını “my_matches” içindeki “inds.” ile eşleştirme)Ardından, “results”ı “cases” ile birleştirmek için başka bir “left_join()” kullanın (“vakalar”daki yeni edinilen “inds.b”yi “results”daki satır adlarıyla eşleştirin)Birleştirmelerden önce üç veri çerçevesini temizlemeliyiz:Hem “dfA” hem de “dfB” satır numaraları (“satır adı”) uygun bir sütuna dönüştürülmelidir.my_matches içindeki iki sütun da sınıf karakterine dönüştürülür, böylece karakter satır adlarına birleştirilebilirler.Yukarıdaki kod kullanılarak gerçekleştirildiği gibi, elde edilen “tamamlandı” veri çerçevesi hem “durumlardan” hem de “sonuçlardan” tüm sütunları içerecektir. Sütun adları aksi takdirde yineleneceğinden, birçoğuna “.x” ve “.y” son ekleri eklenecektir.Alternatif olarak, “results”dan yeni sütun(lar)la “cases” yalnızca “orijinal” 9 kaydı elde etmek için, birleştirmeden önce “results”da “select()”kullanın, böylece yalnızca satır adlarını ve “cases” (örneğin “result” sütunu) eklemek istediğiniz sütunları içerir.iki veri kümesini de yalnızca eşleşen satırlara alt kümelemek isterseniz aşağıdaki kodları kullanabilirsiniz:Veya yalnızca eşleşmeyen satırları görmek için:","code":"\nfl_output <- fastLink::fastLink(\n  dfA = cases,\n  dfB = results,\n  varnames = c(\"gender\", \"first\", \"middle\", \"last\", \"yr\", \"mon\", \"day\", \"district\"),\n  stringdist.match = c(\"first\", \"middle\", \"last\", \"district\"),\n  numeric.match = c(\"yr\", \"mon\", \"day\"),\n  threshold.match = 0.95)## \n## ==================== \n## fastLink(): Fast Probabilistic Record Linkage\n## ==================== \n## \n## If you set return.all to FALSE, you will not be able to calculate a confusion table as a summary statistic.\n## Calculating matches for each variable.\n## Getting counts for parameter estimation.\n##     Parallelizing calculation using OpenMP. 1 threads out of 12 are used.\n## Running the EM algorithm.\n## Getting the indices of estimated matches.\n##     Parallelizing calculation using OpenMP. 1 threads out of 12 are used.\n## Deduping the estimated matches.\n## Getting the match patterns for each estimated match.\n# eşleşmeleri yazdır\nmy_matches <- fl_output$matches\nmy_matches##   inds.a inds.b\n## 1      1      1\n## 2      2      2\n## 3      3      3\n## 4      4      4\n## 5      8      8\n## 6      7      9\n## 7      6     10\n## 8      5     12\n# Eşleştirmeden önce verileri temizleyin\n#############################\n\n# vaka satır adlarını bir sütuna dönüştür \ncases_clean <- cases %>% rownames_to_column()\n\n# test_results satır adlarını bir sütuna dönüştür\nresults_clean <- results %>% rownames_to_column()  \n\n# eşleşen veri kümesindeki tüm sütunları karaktere dönüştürün, böylece satır adlarına birleştirilebilirler\nmatches_clean <- my_matches %>%\n  mutate(across(everything(), as.character))\n\n\n\n# Eşleşmeleri dfA ile birleştirin, ardından dfB ekleyin\n##################################\n# \"inds.b\" sütunu dfA'ya eklendi\ncomplete <- left_join(cases_clean, matches_clean, by = c(\"rowname\" = \"inds.a\"))\n\n#dfB'den sütun(lar) eklendi\ncomplete <- left_join(complete, results_clean, by = c(\"inds.b\" = \"rowname\"))\ncases_clean <- cases %>% rownames_to_column()\n\nresults_clean <- results %>%\n  rownames_to_column() %>% \n  select(rowname, result)    # sadece belirli sütunları seç\n\nmatches_clean <- my_matches %>%\n  mutate(across(everything(), as.character))\n\n# birleştirme\ncomplete <- left_join(cases_clean, matches_clean, by = c(\"rowname\" = \"inds.a\"))\ncomplete <- left_join(complete, results_clean, by = c(\"inds.b\" = \"rowname\"))\ncases_matched <- cases[my_matches$inds.a,]  # Sonuçlarda bir satırla eşleşen vakalarda satırlar\nresults_matched <- results[my_matches$inds.b,]  # Vakalardaki bir satırla eşleşen sonuçlardaki satırlar\ncases_not_matched <- cases[!rownames(cases) %in% my_matches$inds.a,]  # Sonuçlarda bir satırla eşleşmeyen vakalardaki satırlar\nresults_not_matched <- results[!rownames(results) %in% my_matches$inds.b,]  # Bir satırla eşleşmeyen sonuçlardaki satırlars"},{"path":"veri-birleştirme.html","id":"olasılıksal-veri-tekilleştirme","chapter":"14 Veri Birleştirme","heading":"Olasılıksal veri tekilleştirme","text":"Olasılıksal eşleştirme, bir veri kümesini tekilleştirmek için de kullanılabilir. Diğer veri tekilleştirme yöntemleri için veri tekilleştirme sayfasına bakabilirsiniz.Burada “cases” veri kümesiyle başladık, ancak önceki satırların kopyası olabilecek 2 ek satırı olduğundan şimdi buna “cases_dup” adını veriyoruz:\n“Anthony” ile “Tony” ve “Maria Rodriguez” ile “Marialisa Rodrigues” inceleyiniz.Daha önce olduğu gibi “fastLink()”çalıştırın, ancak “cases_dup” veri çerçevesini kendisiyle karşılaştırın. Sağlanan iki veri çerçevesi aynı olduğunda, fonksiyon, çoğaltmayı kaldırmak istediğinizi varsayar. Daha önce yaptığımız gibi stringdist.match = veya numeric.match = belirtmediğimizi unutmayın.Şimdi, getMatches() ile olası kopyaları inceleyebilirsiniz. Veri çerçevesini hem ‘dfA =’ hem de ‘dfB =’ olarak sağlayın ve ‘fastLink()’ fonksiyonunun çıktısını ‘fl.=’ olarak sağlayın. “fl.”, “fastLink.dedupe” sınıfında veya başka bir deyişle “fastLink()”sonucu olmalıdır.Yinelenen kimlikleri gösteren en sağdaki sütuna bakın - son iki satır, 2. ve 3. satırların olası kopyaları olarak tanımlanır.Büyük olasılıkla yinelenen satırların satır numaralarını döndürmek için, “dedupe.ids” sütunundaki benzersiz değer başına satır sayısını sayabilir ve ardından yalnızca birden fazla satıra sahip olanları tutmak için filtre uygulayabilirsiniz. Bu durumda 2. ve 3. satırları bırakır.Muhtemel kopyaların tüm satırlarını incelemek için satır numarasını bu komuta girin:","code":"\n## Aynı veri kümesinde fastLink'i çalıştırın\ndedupe_output <- fastLink(\n  dfA = cases_dup,\n  dfB = cases_dup,\n  varnames = c(\"gender\", \"first\", \"middle\", \"last\", \"yr\", \"mon\", \"day\", \"district\")\n)## \n## ==================== \n## fastLink(): Fast Probabilistic Record Linkage\n## ==================== \n## \n## If you set return.all to FALSE, you will not be able to calculate a confusion table as a summary statistic.\n## dfA and dfB are identical, assuming deduplication of a single data set.\n## Setting return.all to FALSE.\n## \n## Calculating matches for each variable.\n## Getting counts for parameter estimation.\n##     Parallelizing calculation using OpenMP. 1 threads out of 12 are used.\n## Running the EM algorithm.\n## Getting the indices of estimated matches.\n##     Parallelizing calculation using OpenMP. 1 threads out of 12 are used.\n## Calculating the posterior for each pair of matched observations.\n## Getting the match patterns for each estimated match.\n## getMatches() çalıştır\ncases_dedupe <- getMatches(\n  dfA = cases_dup,\n  dfB = cases_dup,\n  fl.out = dedupe_output)\ncases_dedupe %>% \n  count(dedupe.ids) %>% \n  filter(n > 1)##   dedupe.ids n\n## 1          2 2\n## 2          3 2\n# 2. satırı ve tüm olası kopyalarını görüntüler\ncases_dedupe[cases_dedupe$dedupe.ids == 2,]   ##    gender   first middle  last   yr mon day district dedupe.ids\n## 2       M Anthony     B. Smith 1970   9  19    River          2\n## 10      M    Tony     B. Smith 1970   9  19    River          2"},{"path":"veri-birleştirme.html","id":"bağlama-ve-hizalama","chapter":"14 Veri Birleştirme","heading":"14.4 Bağlama ve hizalama","text":"İki veri çerçevesini birleştirmenin başka bir yöntemi, onları birbirine “bağlamaktır”. Bunu satır veya sütunları “eklemek” olarak da düşünebilirsiniz.Bu bölümde ayrıca bir veri çerçevesinin satır sırasının başka bir veri çerçevesindeki sıraya nasıl “hizalanacağı” tartışılacaktır. Bu konu aşağıda Sütunları bağlama bölümünde tartışılmaktadır.","code":""},{"path":"veri-birleştirme.html","id":"satırları-bağlama","chapter":"14 Veri Birleştirme","heading":"Satırları bağlama","text":"Bir veri çerçevesinin satırlarını başka bir veri çerçevesinin altına bağlamak için, dplyr’den bind_rows() kullanın. Çok kapsayıcıdır, bu nedenle iki veri çerçevesinde bulunan herhangi bir sütun çıktıya dahil edilecektir. Birkaç :base R sürümü ‘row.bind()’den farklı olarak, dplyr’nin ’bind_rows()’ fonksiyonu, sütunların sırasının iki veri çerçevesinde de aynı olmasını gerektirmez. Sütun adları aynı şekilde yazıldığı sürece, bunları doğru şekilde hizalayacaktır.İsteğe bağlı olarak .id = argümanını belirtebilirsiniz. Bir karakter sütun adı sağlayın. Bu, satırın orijinal olarak hangi veri çerçevesinden geldiğini belirlemeye yarayan yeni bir sütun üretecektir.Benzer şekilde yapılandırılmış veri çerçevelerinin bir ‘listesinde’ onları tek bir veri çerçevesinde birleştirmek için ‘bind_rows()’ kullanabilirsiniz. purrr ile birden çok satır listesinin içe aktarılmasını içeren Yineleme, döngüler ve listeler sayfasındaki bir örneğe bakın.Satır bağlamanın yaygın bir örneği, “toplam” bir satırı dplyr’nin summarise() fonksiyonuyla yapılmış açıklayıcı bir tabloya bağlamaktır. Aşağıda, toplam satır ile hastaneye göre vaka sayıları ve medyan CT değerleri tablosu oluşturulmuştur.“Summarise()” fonksiyonu, hastaneye göre bir özet veri çerçevesi döndürmek için hastaneye göre gruplandırılmış verilerde kullanılır. Ancak summarise() fonksiyonu otomatik olarak bir “toplamlar” satırı oluşturmaz, bu nedenle verileri tekrar özetleyerek, ancak hastane tarafından gruplandırılmamış verilerle oluştururuz. Bu, yalnızca bir satırdan oluşan ikinci bir veri çerçevesi üretir. Daha sonra nihai tabloya ulaşmak için bu veri çerçevelerini birbirine bağlayabiliriz.[Açıklayıcı tablolar] ve Sunum için tablolar sayfalarında bunun gibi diğer çalışılmış örnekleri inceleyibilirsiniz.İşte “hosp_summary” veri çerçevesi:“Toplam” istatistiklerle (hastaneye göre gruplandırılmamış) bir veri çerçevesi oluşturun. Bu sadece bir satır döndürür.Ve aşağıda bu “totals” veri çerçevesi var. Sadece iki sütunun nasıl olduğuna dikkat edin. Bu sütunlar da “hosp_summary” içindedir, ancak “hosp_summary”de “totals” (“hastane”) içinde olmayan bir sütun vardır.Artık satırları bind_rows() ile birbirine bağlayabiliriz.Artık sonucu görebiliriz. Son satırda, “hosp_summary”de olmayan “hospital” sütunu için boş bir “NA” değerinin nasıl doldurulduğunu görün. Sunum için tablolar sayfasında açıklandığı gibi, replace_na() kullanarak bu hücreyi “Total” ile “doldurabilirsiniz”.","code":"\n# Çekirdek tablo oluştur\n###################\nhosp_summary <- linelist %>% \n  group_by(hospital) %>%                        # Verileri hastaneye göre gruplandır\n  summarise(                                    # İlgilenilen göstergelerin yeni özet sütunları oluşturun\n    cases = n(),                                  # Hastane-çıktı grubu başına satır sayısı     \n    ct_value_med = median(ct_blood, na.rm=T))     # grup başına medyan CT değeri\n# Toplamları oluştur\n###############\ntotals <- linelist %>% \n  summarise(\n    cases = n(),                               # Tüm veri kümesi için satır sayısı    \n    ct_value_med = median(ct_blood, na.rm=T))  # Tüm veri seti için medyan CT\n# Veri çerçevelerini birbirine bağla\ncombined <- bind_rows(hosp_summary, totals)"},{"path":"veri-birleştirme.html","id":"sütunları-bağla","chapter":"14 Veri Birleştirme","heading":"Sütunları bağla","text":"İki veri çerçevesini yanlara birleştirmek için kullanabileceğiniz benzer bir dplyr fonksiyonu bind_cols() vardır. Satırların birbiriyle konuma göre eşleştirildiğini unutmayınız (yukarıdaki birleştirme gibi değil). Örneğin veri çerçevesindeki 12. satır hizalanacaktır.Örneğin, birkaç özet tabloyu birbirine bağlarız. Bunu yapmak için, aynı zamanda, bir veri çerçevesindeki satırların sırasının, ‘match()’ ile başka bir veri çerçevesindeki sıra ile eşleşecek şekilde nasıl yeniden düzenleneceğini de gösteriyoruz.Burada ’vaka_bilgisi’ni, hastaneye göre, vaka sayısı ve ölüm sayısı ile birlikte sıralı vakaların özet veri çerçevesi olarak tanımlıyoruz.Ve diyelim ki burada yine hastane tarafından araştırılan ve “takip edilen” maruz kalan temasların yüzdesi hakkında bilgi içeren farklı bir “contact_fu” veri çerçevesi var.Hastanelerin aynı olduğunu, ancak veri çerçevesinde farklı sıralarda olduğunu unutmayın. En kolay çözüm, ‘hastane’ sütununda bir ‘left_join()’ kullanmak olacaktır, ancak fazladan bir adımla ‘bind_cols()’ da kullanabilirsiniz.","code":"\n# Vaka bilgisi\ncase_info <- linelist %>% \n  group_by(hospital) %>% \n  summarise(\n    cases = n(),\n    deaths = sum(outcome == \"Death\", na.rm=T)\n  )\ncontact_fu <- data.frame(\n  hospital = c(\"St. Mark's Maternity Hospital (SMMH)\", \"Military Hospital\", \"Missing\", \"Central Hospital\", \"Port Hospital\", \"Other\"),\n  investigated = c(\"80%\", \"82%\", NA, \"78%\", \"64%\", \"55%\"),\n  per_fu = c(\"60%\", \"25%\", NA, \"20%\", \"75%\", \"80%\")\n)"},{"path":"veri-birleştirme.html","id":"sırasını-hizalamak-için-match-kullanımı","chapter":"14 Veri Birleştirme","heading":"Sırasını hizalamak için match() kullanımı","text":"Satır sıraları farklı olduğundan, basit bir “bind_cols()” komutu, verilerin yanlış eşleşmesine neden olur. Bunu düzeltmek için, bir veri çerçevesinin satırlarını diğeriyle aynı sırada hizalamak için base R’dan ‘match()’ kullanabiliriz. Bu yaklaşım için iki veri çerçevesinde de yinelenen değer olmadığını varsayıyoruz.‘match()’ kullandığımızda, sözdizimi ‘match(HEDEF SIRA VEKTÖR, DEĞİŞTİRİLECEK VERİ ÇERÇEVESİ SÜTUNU)’ şeklindedir, burada ilk değişken istenen sıradır (ya bağımsız bir vektör, ya da bu durumda bir veri çerçevesi) ve ikinci değişken, yeniden sıralanacak veri çerçevesindeki veri çerçevesi sütunudur. “match()” çıktısı, doğru konum sıralamasını temsil eden bir sayı vektörüdür. Daha fazlasını ?match ile okuyabilirsiniz.Veri çerçevesini yeniden sıralamak için bu sayısal vektörü kullanabilirsiniz - onu ‘[ ]’ alt küme parantezleri içine virgülden önce yerleştirin. [R temelleri] sayfasında temel R köşeli ayraç alt kümesi sözdizimi hakkında daha fazla bilgi edinin. Aşağıdaki komut, satırların yukarıdaki sayısal vektörde sıralandığı eskisi olarak tanımlanan yeni bir veri çerçevesi oluşturur.Artık veri çerçevesi sütunlarını doğru satır sırası ile birbirine bağlayabiliriz. Bazı sütunların çoğaltıldığını ve ‘rename()’ ile temizlenmesi gerekeceğini unutmayın. bind_rows() hakkında daha fazla bilgi edinmek için tıklayınız. buradan.“bind_cols”e bir base R alternatifi, aynı işlemi gerçekleştiren “cbind()”dir.","code":"\nmatch(case_info$hospital, contact_fu$hospital)## [1] 4 2 3 6 5 1\ncontact_fu_aligned <- contact_fu[match(case_info$hospital, contact_fu$hospital),]\nbind_cols(case_info, contact_fu)## New names:\n## • `hospital` -> `hospital...1`\n## • `hospital` -> `hospital...4`## # A tibble: 6 × 6\n##   hospital...1                         cases deaths hospital...4                         investigated per_fu\n##   <chr>                                <int>  <int> <chr>                                <chr>        <chr> \n## 1 Central Hospital                       454    193 St. Mark's Maternity Hospital (SMMH) 80%          60%   \n## 2 Military Hospital                      896    399 Military Hospital                    82%          25%   \n## 3 Missing                               1469    611 Missing                              <NA>         <NA>  \n## 4 Other                                  885    395 Central Hospital                     78%          20%   \n## 5 Port Hospital                         1762    785 Port Hospital                        64%          75%   \n## 6 St. Mark's Maternity Hospital (SMMH)   422    199 Other                                55%          80%"},{"path":"veri-birleştirme.html","id":"kaynaklar-7","chapter":"14 Veri Birleştirme","heading":"14.5 Kaynaklar","text":"Birleşimlerdeki tidyverse sayfasıİlişkisel verilerle ilgili Veri Bilimi için R sayfasıdplyr’deki tidyverse sayfası ciltleme hakkındaPaketin Github sayfasındaki betimlemesi fastLinkMetodolojisini açıklayan yayınfastLink[RecordLinkage paketini] açıklayan yayın\n(https://journal.r-project.org/archive/2010/RJ-2010-017/RJ-2010-017.pdf)","code":""},{"path":"tekilleştirme-1.html","id":"tekilleştirme-1","chapter":"15 Tekilleştirme","heading":"15 Tekilleştirme","text":"Bu sayfa aşağıdaki veri tekilleştirme tekniklerini kapsamaktadır:Yinelenen satırları belirleme ve kaldırmaHer satır grubundan yalnızca belirli satırları (ör. min veya maks) tutmak için satırları “dilimleme”“Toplama” veya birden çok satırdaki değerleri tek satırda birleştirme","code":""},{"path":"tekilleştirme-1.html","id":"hazırlık-6","chapter":"15 Tekilleştirme","heading":"15.1 Hazırlık","text":"","code":""},{"path":"tekilleştirme-1.html","id":"paketleri-yükleme-2","chapter":"15 Tekilleştirme","heading":"Paketleri yükleme","text":"Bu kod parçası, analizler için gereken paketlerin yüklenmesini göstermektedir. Bu el kitabında, paketi kuran ve eğer gerekirse kullanım için yükleyen pacman’ın p_load() işlevlerini vurgulamaktayız. Ayrıca, base R’den library() fonksiyonu ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R’ın Temelleri sayfasına bakabilirsiniz.","code":"\npacman::p_load(\n  tidyverse,   # tekilleştirme, gruplama ve dilimleme işlevleri\n  janitor,     # kopyaları gözden geçirme işlevi\n  stringr)      # dizi aramaları için \"toplama\" değerleri de kullanılabilir"},{"path":"tekilleştirme-1.html","id":"verileri-içeri-aktarma","chapter":"15 Tekilleştirme","heading":"Verileri içeri aktarma","text":"Aşağıda, R kodu ile oluşturulmuş örnek bir veri seti kullanacağız.Veriler, temaslı kişiler ve vakalar dahil olmak üzere COVID-19 telefon görüşmelerinin kayıtlarıdır. Sütunlar, kayıt kimliği - recordID (bilgisayar tarafından oluşturulan), kişi kimliği - personID, ad - name, karşılaşma tarihi - date, karşılaşma zamanı - time, karşılaşmanın amacını - purpose (vaka veya temaslı olarak görüşme için) ve semptomları symptoms_ever (kayıt zamanında kişinin hiç semptom bildirip bildirmediğini) içerir.obs veri kümesini oluşturmak için gereken kod:","code":"\nobs <- data.frame(\n  recordID  = c(1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18),\n  personID  = c(1,1,2,2,3,2,4,5,6,7,2,1,3,3,4,5,5,7,8),\n  name      = c(\"adam\", \"adam\", \"amrish\", \"amrish\", \"mariah\", \"amrish\", \"nikhil\", \"brian\", \"smita\", \"raquel\", \"amrish\",\n                \"adam\", \"mariah\", \"mariah\", \"nikhil\", \"brian\", \"brian\", \"raquel\", \"natalie\"),\n  date      = c(\"1/1/2020\", \"1/1/2020\", \"2/1/2020\", \"2/1/2020\", \"5/1/2020\", \"5/1/2020\", \"5/1/2020\", \"5/1/2020\", \"5/1/2020\",\"5/1/2020\", \"2/1/2020\",\n                \"5/1/2020\", \"6/1/2020\", \"6/1/2020\", \"6/1/2020\", \"6/1/2020\", \"7/1/2020\", \"7/1/2020\", \"7/1/2020\"),\n  time      = c(\"09:00\", \"09:00\", \"14:20\", \"14:20\", \"12:00\", \"16:10\", \"13:01\", \"15:20\", \"14:20\", \"12:30\", \"10:24\",\n                \"09:40\", \"07:25\", \"08:32\", \"15:36\", \"15:31\", \"07:59\", \"11:13\", \"17:12\"),\n  encounter = c(1,1,1,1,1,3,1,1,1,1,2,\n                2,2,3,2,2,3,2,1),\n  purpose   = c(\"contact\", \"contact\", \"contact\", \"contact\", \"case\", \"case\", \"contact\", \"contact\", \"contact\", \"contact\", \"contact\",\n                \"case\", \"contact\", \"contact\", \"contact\", \"contact\", \"case\", \"contact\", \"case\"),\n  symptoms_ever = c(NA, NA, \"No\", \"No\", \"No\", \"Yes\", \"Yes\", \"No\", \"Yes\", NA, \"Yes\",\n                    \"No\", \"No\", \"No\", \"Yes\", \"Yes\", \"No\",\"No\", \"No\")) %>% \n  mutate(date = as.Date(date, format = \"%d/%m/%Y\"))"},{"path":"tekilleştirme-1.html","id":"dedup_data","chapter":"15 Tekilleştirme","heading":"Veri Çerçevesi","text":"bir kişi için karşılaşmaları gözden geçirmek için üst kısımdaki filtre kutularını kullanabilirsiniz.Verileri gözden geçirirken dikkat etmeniz gereken birkaç nokta:İlk iki kayıt, yineleyen kayıt kimliği - recordID de dahil olmak üzere %100 birbirinin tam kopyalarıdır (bir bilgisayar arızası olmalı!)İkinci iki satır, kayıt kimliği - recordID dışındaki tüm sütunlarda birbirinin kopyalarıdır.Birkaç kişi, çeşitli tarih ve saatlerde ve temaslılar ve/veya vakalar olarak birden fazla telefon görüşmesi yaptı.vizitte, kişiye daha öncesinde semptomları olup olmadığı soruldu ve bu bilgilerin bir kısmı eksik.Ve işte janitor paketinden tabyl() fonksiyonu kullanılarak insanların ve karşılaşmalarının amaçlarının kısa bir özeti:","code":"\nobs %>% \n  tabyl(name, purpose)##     name case contact\n##     adam    1       2\n##   amrish    1       3\n##    brian    1       2\n##   mariah    1       2\n##  natalie    1       0\n##   nikhil    0       2\n##   raquel    0       2\n##    smita    0       1"},{"path":"tekilleştirme-1.html","id":"tekilleştirme-2","chapter":"15 Tekilleştirme","heading":"15.2 Tekilleştirme","text":"Bu bölüm, bir veri çerçevesindeki yinelenen satırların nasıl gözden geçirileceğini ve kaldırılacağını açıklamakta ve bir vektörde yinelenen öğelerin nasıl ele alınacağını göstermektedir.","code":""},{"path":"tekilleştirme-1.html","id":"yinelenen-satırları-inceleme","chapter":"15 Tekilleştirme","heading":"Yinelenen satırları inceleme","text":"Yinelenen satırları hızlı bir şekilde gözden geçirmek için janitor paketinden get_dupes() öğesini kullanabilirsiniz. Varsayılan olarak, yinelemeler değerlendirilirken tüm sütunlar dikkate alınır - fonksiyon tarafından döndürülen satırlar, bütün sütunlardaki değerler dikkate alındığında %100 yinelemedir.obs veri çerçevesinde, ilk iki satır %100 kopyadır - sütunda aynı değere sahiptirler (benzersiz olması gereken kayıt kimliği - recordID sütunu dahil - bir bilgisayar arızası olmalı). Döndürülen veri çerçevesi, sağ tarafta otomatik olarak yeni bir dupe_count sütunu içerir ve bu yinelenen değerler kombinasyonuna sahip satır sayısını gösterir.Orijinal veriyi incelemek için linke tıklayınız.Ancak kayıt kimliğini- recordID yok saymayı seçersek 3. ve 4. satırlar da birbirinin kopyasıdır. Yani, recordID dışındaki tüm sütunlarda aynı değerlere sahiptirler. Bir - eksi sembolü kullanarak fonksiyonda yok sayılacak belirli sütunları belirtebilirsiniz.Ayrıca dikkate alınacak sütunları pozitif olarak belirleyebilirsiniz. Aşağıda, yalnızca ad- name ve amaç - name sütunlarında aynı değerlere sahip satırlar döndürülür. “amrish”, üç “temas” karşılaşmasını yansıtmak için nasıl dupe_count’un 3’e eşit olduğuna dikkat edin.Daha fazla satır görmek için sola kaydırın.Orijinal veriyi incelemek için linke tıklayınız.Daha fazla ayrıntı için ?get_dupes fonksiyonunu kullanabilir veya bu çevrimiçi referansa bakabilirsiniz.","code":"\n# Tüm sütunlarda %100 kopyalar\nobs %>% \n  janitor::get_dupes()\n# Sütun kayıt kimliği/recordID dikkate alınmadığında yinelenir\nobs %>% \n  janitor::get_dupes(-recordID)         # if multiple columns, wrap them in c()\n# YALNIZCA ad ve amaç sütunlarına dayalı olarak kopyalar\nobs %>% \n  janitor::get_dupes(name, purpose)"},{"path":"tekilleştirme-1.html","id":"yalnızca-benzersiz-satırları-tutma","chapter":"15 Tekilleştirme","heading":"Yalnızca benzersiz satırları tutma","text":"Bir veri çerçevesinin yalnızca benzersiz satırlarını tutmak için dplyr paketinden distinct() fonksiyonunu kullanabilirsiniz ([Veri ve temel işlevleri temizleme] sayfasında gösterildiği gibi). Yinelenen satırlar, bu tür satırlardan yalnızca ilki tutulacak şekilde kaldırılır. Varsayılan olarak, “ilk” en yüksek satır sayısı - rownumber anlamına gelir (yukarıdan aşağıya sırasında). Yalnızca benzersiz satırlar kalır.Aşağıdaki örnekte, kayıt kimliği - recordID sütununun dikkate alınmaması için distinct() fonksiyonunu çalıştırıyoruz - bu nedenle iki yinelenen satır kaldırılmaktadır. İlk satır (“adam” için) %100 kopyalandı ve kaldırıldı. Ayrıca 3. satır (“amrish” için) recordID (değerlendirilmemiştir) dışındaki sütunda bir kopyaydı ve bu nedenle de kaldırıldı. obs veri kümesinin n’nrow(obs)-2dir, nrow(obs) satırı değil.Tüm veri çerçevesini görmek için sola kaydırın.UYARI: Gruplandırılmış verilerde distinct() kullanılıyorsa, fonksiyon gruba uygulanacaktır.Belirli sütunlara dayalı olarak tekilleştirmeAyrıca tekilleştirme için temel olacak sütunları da belirtebilirsiniz. Bu şekilde, tekilleştirme yalnızca belirtilen sütunlar içinde yinelenen satırlar için geçerlidir. .keep_all = TRUE, olarak ayarlamadığınız sürece, belirtilmeyen tüm sütunlar kaldırılacaktır.Aşağıdaki örnekte, tekilleştirme yalnızca ad - name ve amaç - purpose sütunları için aynı değerlere sahip satırlar için geçerlidir. Böylece, “brian”ın 3 yerine sadece 2 satırı vardır - ilk “temas” karşılaşması ve tek “vaka” karşılaşması. Brian’ın bir amaç için en son karşılaşmasını koruyacak şekilde ayarlamak için, Gruplar içinde Dilimleme sekmesine bakın.Tüm veri çerçevesini görmek için sola kaydırın.Orijinal veriyi incelemek için linke tıklayınız.","code":"\n# veri zincirine eklendi (ör. veri temizleme)\nobs %>% \n  distinct(across(-recordID), # veri çerçevesini yalnızca benzersiz satırlara indirger (herhangi bir kopyadan ilkini tutar)\n           .keep_all = TRUE) \n\n# eğer veri zincirinin dışındaysa, verileri ilk argüman olarak dahil et \n# distinct(obs)\n# veri zincirine eklendi (ör. veri temizleme)\nobs %>% \n  distinct(name, purpose, .keep_all = TRUE) %>%  # satırları ada ve amaca göre benzersiz tut ve tüm sütunları koru\n  arrange(name)                                  # daha kolay görüntüleme için düzenle"},{"path":"tekilleştirme-1.html","id":"bir-vektörde-yinelenen-öğeler","chapter":"15 Tekilleştirme","heading":"Bir vektörde yinelenen öğeler","text":"base R’dan duplicated() fonksiyonu, bir vektörü (sütun) değerlendirecek ve aynı uzunlukta (DOĞRU/YANLIŞ) bir mantıksal vektöre döndürecektir. Bir değer ilk göründüğünde, YANLIŞ’(yinelenen değil) döndürür ve bu değerin sonraki görüntülerinde DOĞRU’ya döndürür. NA’nın diğer herhangi bir değerle nasıl aynı şekilde ele alındığına dikkat edin.Yalnızca yinelenen öğeleri döndürmek için, orijinal vektörün alt kümesini oluşturmak için köşeli parantezleri kullanabilirsiniz:Yalnızca benzersiz öğeleri döndürmek için, base R’dan unique() kullanın. NA’ları sonuçtan çıkarmak için na.omit() öğesini unique() içine yerleştirin.","code":"\nx <- c(1, 1, 2, NA, NA, 4, 5, 4, 4, 1, 2)\nduplicated(x)##  [1] FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\nx[duplicated(x)]## [1]  1 NA  4  4  1  2\nunique(x)           # alternatif olarak, x[!duplicated(x)]kullanın## [1]  1  2 NA  4  5\nunique(na.omit(x))  # NA’ları kaldırın## [1] 1 2 4 5"},{"path":"tekilleştirme-1.html","id":"base-rı-kullanma","chapter":"15 Tekilleştirme","heading":"base R’ı kullanma","text":"Yinelenen satırları döndürmek içinbase R’da, duplicated(df) komutuyla df veri çerçevesinde hangi satırların %100 kopya olduğunu da görebilirsiniz (satırların mantıksal vektörünü döndürür).Bu nedenle, df[duplicated(df),] ile yineleyen satırları görmek için veri çerçevesindeki [ ] temel alt kümesini de kullanabilirsiniz (virgülü unutmayın, bu tüm sütunları görmek istediğiniz anlamına gelir!).Benzersiz satırları döndürmek içinYukarıdaki notlara bakın. Benzersiz satırları görmek için duplicated() işlevinin önünde mantıksal olumsuzlayıcıyı/logical negator !v eklersiniz:df[!duplicated(df),]`Yalnızca belirli sütunların kopyası olan satırları döndürmek içinduplicated() parantez içindeki df’yi alt kümeye alın, böylece bu işlev df’nin yalnızca belirli sütunlarında çalışacaktır.Sütunları belirtmek için, virgülden sonra sütun numaralarını veya adlarını girin (tüm bunların duplicated() fonksiyonu içinde olduğunu unutmayın).duplicated() fonksiyonundan sonra da virgülü dışarıda tuttuğunuzdan emin olun!Örneğin, kopyalar için yalnızca 2 ila 5 arasındaki sütunları değerlendirmek için: df[!duplicated(df[, 2:5]),]\nKopyalar için yalnızca name ve purpose sütununu değerlendirmek için: df[!duplicated(df[, c(\"name\", \"purpose)]),]","code":""},{"path":"tekilleştirme-1.html","id":"dilimleme","chapter":"15 Tekilleştirme","heading":"15.3 Dilimleme","text":"Satır numarasına/konumuna göre satırlara filtre uygulamak için bir veri çerçevesini “dilimlemek”. Bu, özellikle işlevsel grup başına (örneğin, “kişi” başına) birden çok satırınız varsa ve bunlardan yalnızca birini veya birkaçını tutmak istiyorsanız yararlı olur.Temel slice() işlevi sayıları kabul eder ve bu konumlardaki satırları döndürür. Sağlanan sayılar pozitifse, yalnızca döndürülür. Negatifse, bu satırlar döndürülmez. Sayıların tümü pozitif veya tümü negatif olmalıdır.Orijinal veriyi incelemek için linke tıklayınız.Birkaç varyasyon mevcuttur: Bunlara bir sütun ve döndürülecek birkaç satır verilmelidir ( n =’ye).slice_min() ve slice_max() yalnızca belirtilen sütunun minimum veya maksimum değer(ler)ine sahip satır(lar)ı tutar. Bu aynı zamanda sıralı faktörlerin “min” ve “maks” değerlerini döndürmek için de işe yarar.slice_head() ve slice_tail() - sadece ilk veya son satır(lar)ı tutar.slice_sample() - satırların yalnızca rastgele bir örneğini tutar.Saklanacak satırların sayısını veya oranını belirtmek için n = veya prop = argümanlarını kullanın. İşlev bir boru zincirinde kullanılmıyorsa, önce veri bağımsız değişkenini sağlayın (ör. slice(data, n = 2)). Daha fazla bilgi için ?slice bölümüne bakın.Diğer argümanlar:.order_by = slice_min() ve slice_max() içinde kullanılır ve bu, dilimlemeden önce sıralanması gereken bir sütundur.\nwith_ties = Varsayılan olarak DOĞRU, yani bağlar korunur.\n.preserve = Varsayılan olarak YANLIŞ. DOĞRU ise, dilimlemeden sonra gruplama yapısı yeniden hesaplanır.weight_by = Ağırlıklandırmaya göre isteğe bağlı, sayısal sütun (daha büyük sayının örneklenmesi daha olasıdır).\nAyrıca replace = Örneklemenin değiştirilerek/değiştirilmeden yapılıp yapılmadığı için.İPUCU: slice_max() ve slice_min() kullanırken, n =’yi belirttiğinizden/yazdığınızdan emin olun (ör. n = 2, sadece 2 değil). Aksi takdirde bir hata alabilirsiniz. Error: … empty.: slice işlevlerinin yerini alan top_n() fonksiyonuyla karşılaşabilirsiniz.","code":"\nobs %>% slice(4)  # 4. satırı döndür##   recordID personID   name       date  time encounter purpose symptoms_ever\n## 1        3        2 amrish 2020-01-02 14:20         1 contact            No\nobs %>% slice(c(2,4))  # 2. ve 4. satırları döndür##   recordID personID   name       date  time encounter purpose symptoms_ever\n## 1        1        1   adam 2020-01-01 09:00         1 contact          <NA>\n## 2        3        2 amrish 2020-01-02 14:20         1 contact            No\n#obs %>% slice(c(2:4))  # 2'den 4'e kadar olan satırları döndür\nobs %>% slice_max(encounter, n = 1)  # en büyük karşılaşma numarasına sahip satırları döndür##   recordID personID   name       date  time encounter purpose symptoms_ever\n## 1        5        2 amrish 2020-01-05 16:10         3    case           Yes\n## 2       13        3 mariah 2020-01-06 08:32         3 contact            No\n## 3       16        5  brian 2020-01-07 07:59         3    case            No"},{"path":"tekilleştirme-1.html","id":"gruplarla-dilimleme","chapter":"15 Tekilleştirme","heading":"Gruplarla dilimleme","text":"slice_*() fonksiyonları, gruplanmış bir veri çerçevesine uygulandığında çok yararlı olabilir, çünkü dilim işlemi grup üzerinde ayrı ayrı gerçekleştirilir. gruptan bir dilim almak üzere verileri gruplamak için group_by() fonksiyonunu slice() ile birlikte kullanın.Bu, kişi başına birden fazla satırınız varsa ancak bunlardan yalnızca birini tutmak istiyorsanız, tekilleştirme için yararlıdır. Önce group_by() fonksiyonunu kişi başına aynı olan anahtar sütunlarla kullanırsınız ve ardından gruplanmış satırlar arasında farklılık gösterecek bir sütun üzerinde bir slice fonksiyonunu kullanırsınız.Aşağıdaki örnekte, kişi başına yalnızca en son karşılaşmayı tutmak için satırları ada - name göre grupladık ve ardından tarih - date sütununda n = 1 ile slice_max()’ı kullandık. Haberin olsun! Tarihlere slice_max() gibi bir işlevi uygulamak için tarih sütunu Date sınıfı olmalıdır.Varsayılan olarak, “bağlar” (ör. bu senaryoda aynı tarih) korunur ve yine de bazı insanlar için (ör. adam) birden çok satır alırız. Bunu önlemek için with_ties = FALSE olarak ayarladık.UYARI: Eğer arrange() fonksiyonu kullanılıyorsa, verilerin bir grup içinde düzenlenmesi için .by_group = TRUE olarak belirtin.TEHLİKE: Eğer with_ties = FALSE ise, bir bağın ilk satırı tutulur. Bu aldatıcı olabilir. Mariah’nın son randevusunda (6 Ocak) iki karşılaşması var ve ilki (en erken) tutuluyor. Muhtemelen, o gün daha sonraki karşılaşmasını sürdürmek istiyoruz. Bir sonraki örnekte bu bağların nasıl “kırılacağını” görebilirsiniz.Yukarıda, örneğin sadece Amrish’5 Ocak’taki satırının tutulduğunu ve sadece Brian’ın 7 Ocak’taki satırının tutulduğunu görebiliriz. Orijinal veriyi incelemek için linke tıklayınız.“Bağları” kırmak“Bağları kırmak” için birden çok dilim ifadesi çalıştırılabilir. Bu durumda, bir kişinin en son tarihinde birden fazla karşılaşması varsa, en son zamanlı olan karşılaşma tutulur (karakter zamanlarını sıralanabilir bir zaman sınıfına dönüştürmek için lubridate::hm() kullanılır).\nŞimdi, 6 Ocak’ta “Mariah” için tutulan bir satırın, 07:25’teki 2. karşılaşma değil, 08:32’deki 3. karşılaşma olduğuna dikkat edin.ScriptIn yukarıdaki örnekte karşılaşma - encounter sayısına göre dilimleme yapmak da mümkün olabilirdi ama biz örnek amaçlı olarak tarih - date ve saat - time üzerinde dilimi gösterdik.İPUCU: Bir “karakter” sütununda slice_max() veya slice_min() kullanmak için, onu sıralı bir faktör sınıfına dönüştürün!Orijinal veriyi incelemek için linke tıklayınız.","code":"\nobs %>% \n  group_by(name) %>%       # satırları 'ad'a göre gruplandır\n  slice_max(date,          # maksimum tarih değerine sahip grup başına satır tut \n            n = 1,         # sadece tek en yüksek satırı tut\n            with_ties = F) # (tarihin) bir bağı varsa, ilk sırayı alın\n# \"Bağları kırmak\" için çoklu dilim ifadesi örneği\nobs %>%\n  group_by(name) %>%\n  \n  # İLK - en son tarihe göre dilimleyin\n  slice_max(date, n = 1, with_ties = TRUE) %>% \n  \n  # İKİNCİ - bir bağ varsa, en son zamana sahip satırı seçin; bağlar yasak\n  slice_max(lubridate::hm(time), n = 1, with_ties = FALSE)"},{"path":"tekilleştirme-1.html","id":"hepsini-sakla-ama-işaretle","chapter":"15 Tekilleştirme","heading":"Hepsini sakla ama işaretle","text":"Tüm kayıtları tutmak, ancak yalnızca bazılarını analiz için işaretlemek istiyorsanız, benzersiz bir recordID/encounter number:Orijinal veri çerçevesini analiz için yalnızca satırlara küçültün/dilimleyin. Bu azaltılmış veri çerçevesini kaydedin/saklayın.Orijinal veri çerçevesinde, satırları, kayıtlı benzersiz tanımlayıcısının (bu örnekte recordID) indirgenmiş veri çerçevesinde bulunup bulunmadığına bağlı olarak case_when() ile uygun şekilde işaretleyin.Orijinal veriyi incelemek için linke tıklayınız.","code":"\n# 1. Analiz için saklanacak satırların veri çerçevesini tanımlayın\nobs_keep <- obs %>%\n  group_by(name) %>%\n  slice_max(encounter, n = 1, with_ties = FALSE) # her kişi başına yalnızca en son karşılaşmayı tutun\n\n\n# 2. Orijinal veri çerçevesini işaretleyin\nobs_marked <- obs %>%\n\n  # yeni dup_record sütunu oluşturun\n  mutate(dup_record = case_when(\n    \n    # kayıt obs_keep veri çerçevesindeyse\n    recordID %in% obs_keep$recordID ~ \"For analysis\", \n    \n    # analiz amacıyla \"Yoksay\" olarak işaretlenen diğer her şey\n    TRUE                            ~ \"Ignore\"))\n\n# yazdır\nobs_marked##    recordID personID    name       date  time encounter purpose symptoms_ever   dup_record\n## 1         1        1    adam 2020-01-01 09:00         1 contact          <NA>       Ignore\n## 2         1        1    adam 2020-01-01 09:00         1 contact          <NA>       Ignore\n## 3         2        2  amrish 2020-01-02 14:20         1 contact            No       Ignore\n## 4         3        2  amrish 2020-01-02 14:20         1 contact            No       Ignore\n## 5         4        3  mariah 2020-01-05 12:00         1    case            No       Ignore\n## 6         5        2  amrish 2020-01-05 16:10         3    case           Yes For analysis\n## 7         6        4  nikhil 2020-01-05 13:01         1 contact           Yes       Ignore\n## 8         7        5   brian 2020-01-05 15:20         1 contact            No       Ignore\n## 9         8        6   smita 2020-01-05 14:20         1 contact           Yes For analysis\n## 10        9        7  raquel 2020-01-05 12:30         1 contact          <NA>       Ignore\n## 11       10        2  amrish 2020-01-02 10:24         2 contact           Yes       Ignore\n## 12       11        1    adam 2020-01-05 09:40         2    case            No For analysis\n## 13       12        3  mariah 2020-01-06 07:25         2 contact            No       Ignore\n## 14       13        3  mariah 2020-01-06 08:32         3 contact            No For analysis\n## 15       14        4  nikhil 2020-01-06 15:36         2 contact           Yes For analysis\n## 16       15        5   brian 2020-01-06 15:31         2 contact           Yes       Ignore\n## 17       16        5   brian 2020-01-07 07:59         3    case            No For analysis\n## 18       17        7  raquel 2020-01-07 11:13         2 contact            No For analysis\n## 19       18        8 natalie 2020-01-07 17:12         1    case            No For analysis"},{"path":"tekilleştirme-1.html","id":"satır-tamlığını-hesapla","chapter":"15 Tekilleştirme","heading":"Satır tamlığını hesapla","text":"Satırın tamlığı (eksik olmaması) için bir metrik içeren bir sütun oluşturun. Bu, tekilleştirme/dilimleme sırasında hangi satırların diğerlerine göre önceliklendirileceğine karar verirken yardımcı olabilir.Bu örnekte, tamlığını ölçmek istediğiniz “anahtar” sütunlar, bir sütun adları vektörüne kaydedilir.Daha sonra mutate() ile yeni key_completeness sütunu oluşturulur. satırdaki yeni değer, hesaplanmış bir kesir olarak tanımlanır: o satırda anahtar sütunlar arasında eksik olmayan değerlerin sayısı, anahtar sütunların sayısına bölünür.Bu işlem, base R’daki rowSums() fonksiyonunu içermektedir. Ayrıca, tünellemede, veri çerçevesindeki bir noktaya atıfta bulunan . kullanılır (bu durumda, köşeli parantez [] ile alt kümelenmektedir).*Daha fazla satır görmek için sağa kaydırın**Orijinal veriyi incelemek için linke tıklayınız.","code":"\n# bir \"değişken tamlığı\" sütunu oluşturun\n# bu, eksik olmayan değerlere sahip \"key_cols\" olarak belirlenmiş sütunların *oranıdır*\n\nkey_cols = c(\"personID\", \"name\", \"symptoms_ever\")\n\nobs %>% \n  mutate(key_completeness = rowSums(!is.na(.[,key_cols]))/length(key_cols)) "},{"path":"tekilleştirme-1.html","id":"str_rollup","chapter":"15 Tekilleştirme","heading":"15.4 Toplama değerleri","text":"Bu bölüm şunları açıklar:Bazı varyasyonlarla birden çok satırdaki değerleri tek bir satıra “toplama”“Toplanmış” değerlere sahip olduğunuzda, hücredeki değerlerin üzerine nasıl yazılır/öncelik verilirBu sekme, Hazırlık sekmesindeki örnek veri kümesini kullanır.","code":""},{"path":"tekilleştirme-1.html","id":"değerleri-bir-satıra-topla","chapter":"15 Tekilleştirme","heading":"Değerleri bir satıra topla","text":"Aşağıdaki kod örneği, satırları kişiye göre gruplandırmak için group_by() ve summarise() öğelerini kullanır ve ardından gruplanmış satırlardaki tüm benzersiz değerleri birbirine yapıştırır. Böylece kişi başına bir özet satırı elde edersiniz.Tüm yeni sütunlara bir son ek eklenir (bu örnekte “_roll”).Hücre başına yalnızca benzersiz değerleri göstermek istiyorsanız, na.omit() öğesini unique() ile sarın.na.omit() NA değerlerini kaldırır, ancak bu istenmiyorsa paste0(.x)… kaldırılabilir.Fonksiyonun çıktısı, girişlerin tarihe göre düzenlendiği ve birbirine yapıştırıldığı, grup başına bir satırdır (“ID”). Daha fazla satır görmek için sola kaydırın.Orijinal veriyi incelemek için linke tıklayınız.Bu varyasyon yalnızca benzersiz değerleri gösterir:Bu varyasyon, sütuna bir son ek ekler.\nBu durumda, yuvarlandığını belirtmek için “_roll”:","code":"\n# \"Toplama\" değerlerini grup başına bir satırda toplar (\"personID\" başına) \ncases_rolled <- obs %>% \n  \n  # Ada göre grup oluşturur\n  group_by(personID) %>% \n  \n  # Her gruptaki satırları sıralar (ör. tarihe göre)\n  arrange(date, .by_group = TRUE) %>% \n  \n  # Her sütun için, gruplandırılmış satırlardaki tüm değerleri \";\" ile ayırarak birbirine yapıştır\n  summarise(\n    across(everything(),                           # Tüm sütunlara uygula\n           ~paste0(na.omit(.x), collapse = \"; \"))) # NA olmayan benzersiz değerleri birleştiren işlev tanımlanır\n# Varyasyon - yalnızca benzersiz değerleri göster\ncases_rolled <- obs %>% \n  group_by(personID) %>% \n  arrange(date, .by_group = TRUE) %>% \n  summarise(\n    across(everything(),                                   # Tüm sütunlara uygular\n           ~paste0(unique(na.omit(.x)), collapse = \"; \"))) # NA olmayan benzersiz değerleri birleştiren işlev tanımlanır\n# Varyasyon - sütun adlarına eklenen sonek \ncases_rolled <- obs %>% \n  group_by(personID) %>% \n  arrange(date, .by_group = TRUE) %>% \n  summarise(\n    across(everything(),                \n           list(roll = ~paste0(na.omit(.x), collapse = \"; \")))) # _roll sütun adlarına eklenir"},{"path":"tekilleştirme-1.html","id":"değerlerinhiyerarşinin-üzerine-yaz","chapter":"15 Tekilleştirme","heading":"Değerlerin/hiyerarşinin üzerine yaz","text":"Daha sonra tüm yuvarlanan değerleri değerlendirmek ve yalnızca belirli bir değeri (örneğin, “en iyi” veya “maksimum” değer) tutmak istiyorsanız, dize kalıplarını sırayla aramak ve hücre içeriğinin üzerine yazmak için stringr paketinden str_detect() kullanan case_when() öğesini uygulamak için istenen sütunlarda mutate() öğesini kullanabilirsiniz.Şimdi, symptoms_ever sütununda görebilirsiniz, eğer kişi HEP semptomlara “Evet” dediyse, o zaman sadece “Evet” görüntülenir.Orijinal veriyi incelemek için linke tıklayınız.","code":"\n# TEMİZ VAKALAR\n#############\ncases_clean <- cases_rolled %>% \n    \n    # Temiz Evet-Hayır-Bilinmeyen değişkenler: metni dizede bulunan \"en yüksek\" değerle değiştir\n    mutate(across(c(contains(\"symptoms_ever\")),                     # belirtilen sütunlarda çalışır (E/H/B)\n             list(mod = ~case_when(                                 # yeni sütunlara \"_mod\" son ekini ekler; case_when() öğesini uygular\n               \n               str_detect(.x, \"Yes\")       ~ \"Yes\",                 # \"Evet\" algılanırsa, hücre değeri evet'e dönüşür\n               str_detect(.x, \"No\")        ~ \"No\",                  # daha sonra, \"Hayır\" algılanırsa, hücre değeri hayır'a dönüşür\n               str_detect(.x, \"Unknown\")   ~ \"Unknown\",             # daha sonra, \"Bilinmeyen\" algılanırsa, hücre değeri bilinmeyen'e dönüşür\n               TRUE                        ~ as.character(.x)))),   # sonra, başka bir şey varsa olduğu gibi tutulursa\n      .keep = \"unused\")                                             # eski sütunlar kaldırıldı, yalnızca _mod sütunları kaldı"},{"path":"tekilleştirme-1.html","id":"probabilistic-de-duplication","chapter":"15 Tekilleştirme","heading":"15.5 Probabilistic de-duplication","text":"Bazen, ad, yaş, cinsiyet, doğum tarihi vb. gibi çeşitli sütunlarda benzerliğe (ör. dize “mesafe”) dayalı olarak “olası” yinelemeleri belirlemek isteyebilirsiniz. Olası yinelemeleri belirlemek için olasılıklı bir eşleştirme algoritması uygulayabilirsiniz.Bu yöntemle ilgili bir açıklama için [Verileri birleştirme] sayfasına bakın. Olasılıksal Eşleştirme bölümü, bir veri çerçevesini kendisiyle karşılaştırmak için bu algoritmaları uygulamanın bir örneğini içerir, böylece olasılıksal tekilleştirme gerçekleştirir.","code":""},{"path":"tekilleştirme-1.html","id":"kaynaklar-8","chapter":"15 Tekilleştirme","heading":"15.6 Kaynaklar","text":"Bu sayfadaki bilgilerin çoğu şu kaynaklardan ve çevrimiçi vinyetlerden uyarlanmıştır:datanoviadplyr tidyverse referencecran janitor vignette","code":""},{"path":"yineleme-döngüler-ve-listeler.html","id":"yineleme-döngüler-ve-listeler","chapter":"16 Yineleme, döngüler ve listeler","heading":"16 Yineleme, döngüler ve listeler","text":"Epidemiyologlar sıklıkla ülkeler, ilçeler veya yaş grupları gibi alt gruplar üzerinde tekrar eden analizlerle karşı karşıya kalırlar. Bunlar yinelemeyi içeren birçok durumdan sadece birkaçıdır. Aşağıdaki yaklaşımları kullanarak yinelemeli işlemlerinizi kodlamak, bu tür tekrarlayan görevleri daha hızlı gerçekleştirmenize, hata olasılığını azaltmanıza ve kod uzunluğunu azaltmanıza yardımcı olacaktır.Bu sayfa, yinelemeli işlemlere iki yaklaşım sunacaktır - döngülerini ve purrr paketini kullanmak.döngüleri, bir dizi giriş boyunca kodu yineler, ancak R’da diğer programlama dillerinden daha az yaygındır. Yine de, onları burada bir öğrenme aracı ve referans olarak tanıtıyoruz.purrr paketi, yinelemeli işlemlere tidyverse yaklaşımdır - bir işlevi birçok girdi arasında “eşleyerek” çalışır (değerler, sütunlar, veri kümeleri vb.)Yol boyunca, aşağıdaki gibi örnekler göstereceğiz:Birden çok dosyayı içe ve dışa aktarmaBirden fazla yetki alanı için eğriler oluşturmaBir veri çerçevesindeki birkaç sütun için T testleri çalıştırmapurrrsection bölümünde, listeleri - lists oluşturma ve işlemeye ilişkin birkaç örnek de sunacağız.","code":""},{"path":"yineleme-döngüler-ve-listeler.html","id":"hazırlık-7","chapter":"16 Yineleme, döngüler ve listeler","heading":"16.1 Hazırlık","text":"","code":""},{"path":"yineleme-döngüler-ve-listeler.html","id":"paketleri-yükleme-3","chapter":"16 Yineleme, döngüler ve listeler","heading":"Paketleri yükleme","text":"Bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekli olursa paketi kuran ve kullanım için yükleyen pacman’ın p_load() fonksiyonunu vurguluyoruz. Ayrıca, R tabanından library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] sayfasına bakın.","code":"\npacman::p_load(\n     rio,         # içe/dışa aktarma\n     here,        # dosya bulucu\n     purrr,       # yineleme\n     tidyverse    # veri yönetimi ve görselleştirme\n)"},{"path":"yineleme-döngüler-ve-listeler.html","id":"verileri-içe-aktarma-2","chapter":"16 Yineleme, döngüler ve listeler","heading":"Verileri içe aktarma","text":"Simüle edilmiş bir Ebola salgınından vakaların veri setini içe aktarıyoruz. Devam etmek isterseniz, “temiz” satır listesini indirmek için tıklayın (.rds dosyası olarak). Verileri rio paketinden import() fonksiyonuyla içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe ve Dışa Aktarma] sayfasına bakın).Çizgi listesinin ilk 50 satırı aşağıda görüntülenir.","code":"\n# satır listesini içe aktar\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"yineleme-döngüler-ve-listeler.html","id":"for-döngüleri","chapter":"16 Yineleme, döngüler ve listeler","heading":"16.2 for döngüleri","text":"","code":""},{"path":"yineleme-döngüler-ve-listeler.html","id":"iter_loops","chapter":"16 Yineleme, döngüler ve listeler","heading":"R’daki for döngüleri*","text":"döngüleri R’de vurgulanmaz, ancak diğer programlama dillerinde yaygındır. Yeni başlayan olarak, “keşfetmek”te , “hata ayıklamak”ta daha kolay oldukları için öğrenmek ve pratik yapmak için yardımcı olabilirler ve aksi takdirde, özellikle kendi işlevlerinizi yazarken henüz rahat değilseniz, yinelemenin tam olarak ne olduğunu anlamalısınız.purrr ile eşlenmiş işlevlerle yinelemek için döngüleri sayesinde hızla ilerleyebilirsiniz (aşağıdaki bölüme bakın).","code":""},{"path":"yineleme-döngüler-ve-listeler.html","id":"temel-bileşenler","chapter":"16 Yineleme, döngüler ve listeler","heading":"Temel bileşenler","text":"Bir döngüsünün üç temel parçası vardır:Yinelenecek öğelerin sırasıSıradaki öğe başına yapılacak işlemlerSonuçlar için kapsayıcı (isteğe bağlı)Temel sözdizimi şudur: (sıradaki öğe) {öğeyi kullanarak işlemler yapın}. Parantezlere ve küme parantezlerine dikkat edin. Sonuçlar konsola yazdırılabilir veya bir kapsayıcı R nesnesinde saklanabilir.Basit bir döngüsü örneği aşağıdadır.","code":"\nfor (num in c(1,2,3,4,5)) {  # SIRA tanımlanır (1'den 5'e kadar sayılar) ve \"{\" ile döngü açılır\n  print(num + 2)             # İŞLEMLER (her sıra numarasına iki tane ekleyin ve yazdırın)\n}                            # Döngü \"}\" ile kapatılır                          ## [1] 3\n## [1] 4\n## [1] 5\n## [1] 6\n## [1] 7\n                             # Bu örnekte \"kapsayıcı\" yok"},{"path":"yineleme-döngüler-ve-listeler.html","id":"sıralama","chapter":"16 Yineleme, döngüler ve listeler","heading":"Sıralama","text":"Bu, döngüsünün “” kısmıdır - işlemler dizideki öğe için “” çalışır. Sıra, bir dizi değer (ör. yetki alanlarının adları, hastalıklar, sütun adları, liste öğeleri, vb.) olabilir veya bir dizi ardışık sayı (ör. 1,2,3,4,5) olabilir. yaklaşımın aşağıda açıklanan kendi araçları vardır.Bir dizi ifadesinin temel yapısı vektördeki öğedir.“Öğe” yerine herhangi bir karakter veya kelime yazabilirsiniz (örn. “”, “num”, “hosp”, “bölge” vb.). Bu “öğenin” değeri, vektördeki değerden geçerek döngünün yinelemesinde değişir.Vektör, karakter değerleri, sütun adları veya belki bir dizi sayı olabilir - bunlar yinelemede değişecek olan değerlerdir. Bunları “item” terimini kullanarak döngüsü işlemleri içinde kullanabilirsiniz.Örnek: karakter değerleri dizisiBu örnekte, hastane adlarının önceden tanımlanmış bir karakter vektöründeki bir değer için bir döngü gerçekleştirilir.Hastane_adı - hospital_names vektöründen değerleri temsil etmek için hosp terimini seçtik. Döngünün ilk yinelemesi için, hosp değeri hastane_adı - hospital_names[[1]] olacaktır. İkinci döngü için hastane_adı - hospital_names[[2]] olacaktır. Ve bunun gibi…Örnek: sütun adları dizisiBu, mevcut bir R nesnesinin adlarının çıkarıldığı ve vektör haline geldiği, yukarıdaki karakter dizisinin bir varyasyonudur. Örneğin, bir veri çerçevesinin sütun adları. Uygun bir şekilde, döngüsünün işlem kodunda, sütun adları orijinal veri çerçevelerini indekslemek (alt kümeler) için kullanılabilir.Aşağıda sıra, satır listesi veri çerçevesinin adları - names() (sütun adları) şeklindedir. “Öğe” adımız, döngüler ilerledikçe sütun adını temsil edecek olan col’dur.Örnek olarak, dizideki değer için çalıştırılan döngüsünün içine işlem kodunu ekledik. Bu kodda, sıra değerleri (sütun adları), seferinde bir satır listesini indekslemek (alt küme) için kullanılır. R temelleri sayfasında öğretildiği gibi, alt küme için çift köşeli ayraçlar [[ ]] kullanılır. Elde edilen sütun .na() öğesine, ardından sütunda eksik olan değerlerin sayısını üretmek için sum() öğesine iletilir. Sonuç konsola yazdırılır - sütun için bir sayı.Sütun adlarıyla indeksleme hakkında bir - sütunun kendisine atıfta bulunurken sadece “col” yazmayın! col sadece karakter sütun adını temsil eder! Tüm sütuna başvurmak için, sütun adını linelist[[col]] aracılığıyla satır listesinde bir dizin olarak kullanmalısınız.Sayıların dizisiBu yaklaşımda, dizi ardışık sayılar dizisidir. Bu nedenle, “öğe”nin değeri bir karakter değeri değil (ör. “Merkez Hastane” veya “tarih_başlangıç”) bir sayıdır. Bu, veri çerçevesini satır numarasına göre indekslemek için döngüsü içindeki “öğe” numarasını kullanabileceğiniz için veri çerçeveleri arasında döngü yapmak için kullanışlıdır.Örneğin, veri çerçevenizdeki satırda döngü yapmak ve belirli bilgileri çıkarmak istediğinizi varsayalım. “Öğeleriniz” sayısal satır numaraları olacaktır. Çoğu zaman, bu durumda “öğeler” olarak yazılır.döngüsü işlemi, “veri çerçevemdeki 1’den toplam satır sayısına kadar bir sayı dizisindeki öğe için X yap” şeklinde açıklanabilir. Döngünün ilk yinelemesi için “item” değeri 1 olur. İkinci yineleme için 2 olur, vb.Sıra kodda şöyle görünür: (1:nrow(linelist)) {OPERATIONS CODE} burada “öğeyi” temsil eder ve 1:nrow(linelist) 1’den satır listesindeki satır sayısına kadar ardışık sayılar dizisi üretir.Dizinin sayı olmasını istiyorsanız, ancak bir vektörden başlıyorsanız (bir veri çerçevesi değil), vektördeki bir öğeki bir sayı dizisini döndürmek için seq_along() kısayolunu kullanın. Örneğin, (seq_along(hospital_names) {OPERATIONS CODE}.Aşağıdaki kod aslında kendi döngülerinde ’nin değeri olacak olan sayıları döndürür.Dizide sayıları kullanmanın bir avantajı, döngü çıktılarını depolayan bir kapsayıcıyı indekslemek için numarasını kullanmanın da kolay olmasıdır. Aşağıdaki İşlemler bölümünde bunun bir örneği var.","code":"\n# hastane isimlerinin vektörünü yap\nhospital_names <- unique(linelist$hospital)\nhospital_names # yazdır## [1] \"Other\"                                \"Missing\"                             \n## [3] \"St. Mark's Maternity Hospital (SMMH)\" \"Port Hospital\"                       \n## [5] \"Military Hospital\"                    \"Central Hospital\"\n# karakter sıralı bir 'for döngüsü'\n\nfor (hosp in hospital_names){       # sıra\n  \n       # İŞLEMLER BURAYA YAZILIR\n  }\nfor (col in names(linelist)){        # satır listesindeki her sütun için döngü çalışır; \"col\" ile temsil edilen sütun adı\n  \n  # Örnek işlem kodu - sütundaki eksik değerlerin sayısını yazdır\n  print(sum(is.na(linelist[[col]])))  # sıra listesi, \"col\" öğesinin geçerli değeriyle indekslenir\n     \n}## [1] 0\n## [1] 0\n## [1] 2087\n## [1] 256\n## [1] 0\n## [1] 936\n## [1] 1323\n## [1] 278\n## [1] 86\n## [1] 0\n## [1] 86\n## [1] 86\n## [1] 86\n## [1] 0\n## [1] 0\n## [1] 0\n## [1] 2088\n## [1] 2088\n## [1] 0\n## [1] 0\n## [1] 0\n## [1] 249\n## [1] 249\n## [1] 249\n## [1] 249\n## [1] 249\n## [1] 149\n## [1] 765\n## [1] 0\n## [1] 256\nfor (i in 1:nrow(linelist)) {  # bir veri çerçevesinde kullan\n  # İŞLEMLER BURAYA YAZILIR\n}  \nseq_along(hospital_names)  # adlandırılmış bir vektör üzerinde kullan## [1] 1 2 3 4 5 6"},{"path":"yineleme-döngüler-ve-listeler.html","id":"operasyonlar","chapter":"16 Yineleme, döngüler ve listeler","heading":"Operasyonlar","text":"Bu, döngüsünün küme parantezleri { } içindeki koddur. Bu kodun sıradaki “öğe” için çalışmasını istiyorsunuz. Bu nedenle, kodunuzun “öğe” ile değişen parçasının gerçekten değişeceği şekilde doğru kodlanmış olmasına dikkat edin! Örneğin, indeksleme için [[ ]] kullanmayı unutmayın.Aşağıdaki örnekte, satır listesindeki bir satırı yineliyoruz. satırın cinsiyet - gender ve yaş - age değerleri birbirine yapıştırılır ve cases_demographics kapsayıcı karakter vektöründe saklanır. Döngü çıktısını “kapsayıcı” vektöründe doğru konuma kaydetmek için indekslemeyi [[]] nasıl kullandığımıza dikkat edin.","code":"\n# sonuçları depolamak için kapsayıcı oluştur - bir karakter vektörü\ncases_demographics <- vector(mode = \"character\", length = nrow(linelist))\n\n# for döngüsü\nfor (i in 1:nrow(linelist)){\n  \n  # OPERASYONLAR\n  # indeksleme için parantez kullanarak satır i için satır listesinden değerleri ayıkla\n  row_gender  <- linelist$gender[[i]]\n  row_age     <- linelist$age_years[[i]]    # indekslemeyi unutmayın!\n     \n  # cinsiyet-yaşı birleştirin ve indekslenmiş konumda kapsayıcı vektöründe sakla\n  cases_demographics[[i]] <- str_c(row_gender, row_age, sep = \",\") \n\n}  # döngü sonu\n\n\n# kapsayıcının ilk 10 satırını göster\nhead(cases_demographics, 10)##  [1] \"m,2\"  \"f,3\"  \"m,56\" \"f,18\" \"m,3\"  \"f,16\" \"f,16\" \"f,0\"  \"m,61\" \"f,27\""},{"path":"yineleme-döngüler-ve-listeler.html","id":"kapsayıcı","chapter":"16 Yineleme, döngüler ve listeler","heading":"Kapsayıcı","text":"Bazen döngüsünün sonuçları konsola veya RStudio Plots bölmesine yazdırılır. Diğer zamanlarda, çıktıları daha sonra kullanmak üzere bir “kapsayıcı”da saklamak isteyeceksiniz. Böyle bir kapsayıcı, bir vektör, bir veri çerçevesi ve hatta bir liste olabilir.döngüsüne başlamadan önce bile sonuçlar için kapsayıcı oluşturmak en verimli yöntemdir. Pratikte bu, boş bir vektör, veri çerçevesi veya liste oluşturmak anlamına gelir. Bunlar, vektörler veya listeler için vector() işlevleriyle veya bir veri çerçevesi için matrix() ve data.frame() işlevleriyle oluşturulabilir.Boş vektörvector()’u kullanın ve ekleyeceğiniz nesnelerin beklenen sınıfına göre mode = belirtin - “çift” (sayıları tutmak için), “karakter” veya “mantıksal”. Ayrıca length = önceden ayarlamalısınız. Bu, döngüsü dizinizin uzunluğu olmalıdır.hastane için medyan kabul gecikmesini saklamak istediğinizi varsayalım. “Çift” kullanır ve uzunluğu beklenen çıktıların sayısı (veri setindeki benzersiz hastanelerin sayısı) olarak ayarlarsınız.Boş veri çerçevesiBunun gibi satır ve sütun sayısını belirterek boş bir veri çerçevesi oluşturabilirsiniz:Boş listeBir döngüsü tarafından oluşturulan bazı grafikleri bir listede saklamak isteyebilirsiniz. Liste vektör gibidir, ancak içinde farklı sınıflardan olabilen diğer R nesnelerini içerir. Listedeki öğeler tek bir sayı, bir veri çerçevesi, bir vektör ve hatta başka bir liste olabilir.Aslında yukarıdakiyle aynı vector() komutunu kullanarak, ancak mode = \"list\" ile boş bir liste başlatıyorsunuz. Uzunluğu istediğiniz gibi belirtin.","code":"\ndelays <- vector(\n  mode = \"double\",                            # numaraları kaydetmeyi bekliyoruz\n  length = length(unique(linelist$hospital))) # veri setindeki benzersiz hastanelerin sayısı\ndelays <- data.frame(matrix(ncol = 2, nrow = 3))\nplots <- vector(mode = \"list\", length = 16)"},{"path":"yineleme-döngüler-ve-listeler.html","id":"yazdırma","chapter":"16 Yineleme, döngüler ve listeler","heading":"Yazdırma","text":"Bir döngüsü içinden yazdırmak için büyük olasılıkla print() işleviyle açıkça sarmanız gerekeceğini unutmayın.Aşağıdaki bu örnekte dizi, hastane tarafından satır listesinin alt kümesi için kullanılan açık bir karakter vektörüdür. Sonuçlar bir kapsayıcıda saklanmaz, bunun yerine print() işleviyle konsola yazdırılır.","code":"\nfor (hosp in hospital_names){ \n     hospital_cases <- linelist %>% filter(hospital == hosp)\n     print(nrow(hospital_cases))\n}## [1] 885\n## [1] 1469\n## [1] 422\n## [1] 1762\n## [1] 896\n## [1] 454"},{"path":"yineleme-döngüler-ve-listeler.html","id":"for-döngüsünü-test-etme","chapter":"16 Yineleme, döngüler ve listeler","heading":"For döngüsünü test etme","text":"Döngünüzü test etmek için, <- 10 veya hosp <- \"Central Hospital\" gibi “öğe”nin geçici bir atamasını yapmak için bir komut çalıştırabilirsiniz. Bunu döngünün dışında yapın ve ardından beklenen sonuçların üretilip üretilmediğini görmek için yalnızca işlem kodunuzu (kıvrımlı parantez içindeki kod) çalıştırın.","code":""},{"path":"yineleme-döngüler-ve-listeler.html","id":"döngü-grafikleri","chapter":"16 Yineleme, döngüler ve listeler","heading":"Döngü grafikleri","text":"Üç bileşeni (kapsayıcı, sıralama ve operasyonlar) bir araya getirmek için hastane için bir epi eğrisi çizmeye çalışalım (Salgın eğrileri sayfasına bakın).Aşağıdaki gibi incidence2 paketini kullanarak tüm vakaların cinsiyete göre güzel bir epik eğrisini yapabiliriz:hastanenin vakası için ayrı bir grafik oluşturmak için bu epi eğri kodunu bir döngüsüne koyabiliriz.İlk olarak, benzersiz hastane adlarının adlandırılmış bir vektörünü, hospital_names olarak kaydederiz. döngüsü şu adların biri için bir kez çalışacaktır: (hosp hospital_names). döngüsünün yinelemesinde, vektörden gelen mevcut hastane adı, döngü içinde kullanım için hosp olarak temsil edilecektir.Döngü işlemleri içinde, normal olarak R kodunu yazabilirsiniz, ancak değerinin değişeceğini bilerek “öğe”yi (bu durumda hosp) kullanın. Bu döngü içinde:Satır listesine bir filter() uygulanır, öyle ki hastane - hospital sütunu, hosp’un mevcut değerine eşit olmalıdır.İnsidans nesnesi, filtrelenmiş satır listesinde oluşturulur.Mevcut hastane için grafik, hosp kullanan otomatik ayarlı bir başlıkla oluşturulur.Mevcut hastane için grafik geçici olarak kaydedilir ve ardından yazdırılır.Döngü, daha sonra, hospital_names içindeki bir sonraki hastane ile tekrar etmek için ilerler","code":"\n# 'insidans' nesnesi oluşturun\noutbreak <- incidence2::incidence(   \n     x = linelist,                   # dataframe - tam satır listesi\n     date_index = date_onset,        # tarih sütunu\n     interval = \"week\",              # haftalık toplu sayımlar\n     groups = gender,                # cinsiyete göre grup değerleri\n     na_as_group = TRUE)             # eksik cinsiyet ayrı bir gruptur\n\n# plot epi eğrisi\nplot(outbreak,                       # olay nesnesinin adı\n     fill = \"gender\",                # cinsiyete göre renk çubukları\n     color = \"black\",                # çubukların anahat rengi\n     title = \"Outbreak of ALL cases\" # başlık\n     )\n# hastane isimlerinin vektörünü yapın\nhospital_names <- unique(linelist$hospital)\n\n# hospital_names deki her ad (\"hosp\") için epi eğrisini oluşturun ve yazdırın\nfor (hosp in hospital_names) {\n     \n     # mevcut hastaneye özgü olay nesnesi oluşturun\n     outbreak_hosp <- incidence2::incidence(\n          x = linelist %>% filter(hospital == hosp),   # satır listesi mevcut hastaneye göre filtrelenir\n          date_index = date_onset,\n          interval = \"week\", \n          groups = gender,\n          na_as_group = TRUE\n     )\n     \n     # Grafik oluşturun ve kaydedin. Başlık otomatik olarak mevcut hastaneye göre ayarlanır\n     plot_hosp <- plot(\n       outbreak_hosp,\n       fill = \"gender\",\n       color = \"black\",\n       title = stringr::str_glue(\"Epidemic of cases admitted to {hosp}\")\n     )\n     \n     # mevcut hastane için grafik yazdırın\n     print(plot_hosp)\n     \n} # hospital_names içindeki her hastane için çalıştırıldığında for döngüsünü sonlandırın "},{"path":"yineleme-döngüler-ve-listeler.html","id":"bir-döngünün-ilerlemesini-izleme","chapter":"16 Yineleme, döngüler ve listeler","heading":"Bir döngünün ilerlemesini izleme","text":"Birçok yinelemeli bir döngü, dakikalarca hatta saatlerce çalışabilir. Bu nedenle, ilerlemeyi R konsoluna yazdırmak yararlı olabilir. Aşağıdaki ifadesi, 100. sayıyı yazdırmak için döngü fonksiyonlarının içine yerleştirilebilir. Döngünüzdeki “öğe” olacak şekilde ayarlayın.","code":"# her 100 yinelemede ilerlemeyi yazdırmak için kodlu döngü\nfor (i in seq_len(nrow(linelist))){\n\n  # yazdırma ilerlemesi\n  if(i %% 100==0){    # %% operatörü kalandır\n    print(i)\n\n}"},{"path":"yineleme-döngüler-ve-listeler.html","id":"iter_purrr","chapter":"16 Yineleme, döngüler ve listeler","heading":"16.3 purrr ve listeler","text":"Yinelemeli işlemlere başka bir yaklaşım da purrr paketidir - yineleme için tidyverse yaklaşımdır.Aynı görevi birkaç kez yapmakla karşı karşıya kalırsanız, muhtemelen birçok girdide kullanabileceğiniz genelleştirilmiş bir çözüm oluşturmaya değer. Örneğin, birden fazla yetki alanları için grafikler oluşturmak veya birçok dosyayı içe aktarmak ve birleştirmek.Ayrıca purrr’ın birkaç avantajı daha vardır - %>% tünelleriyle kullanabilirsiniz, döngülerine kıyasla normalden daha iyi hataları ele alır ve sözdizimi oldukça temiz ve basittir! Bir döngüsü kullanıyorsanız, muhtemelen purrr ile daha net ve özlü bir şekilde yapabilirsiniz!purrr’ın fonksiyonel programlama aracı olduğunu unutmayın. Yani, yinelemeli olarak uygulanacak işlemler fonksiyonlara sarılır. Kendi işlevlerinizi nasıl yazacağınızı öğrenmek için [Yazma işlevleri] sayfasına bakın.purrr ayrıca neredeyse tamamen listeler ve vektörler üzerine kuruludur - bu yüzden bunu o listenin/vektörün bir öğesine bir işlev uygulamak olarak düşünün!","code":""},{"path":"yineleme-döngüler-ve-listeler.html","id":"paketleri-yükleme-4","chapter":"16 Yineleme, döngüler ve listeler","heading":"Paketleri yükleme","text":"purrr tidyverse’bir parçasıdır, bu nedenle ayrı bir paket kurmaya/yüklemeye gerek yoktur.","code":"\npacman::p_load(\n     rio,            # içe/dışa aktar\n     here,           # ilgili dosya yolları\n     tidyverse,      # mgt ve viz verisi\n     writexl,        # Excel dosyasını birden çok sayfayla yaz\n     readxl          # Excel'i birden çok sayfayla içe aktar\n)"},{"path":"yineleme-döngüler-ve-listeler.html","id":"map","chapter":"16 Yineleme, döngüler ve listeler","heading":"map()","text":"purrr’un temel bir işlevi, sağladığınız bir listenin/vektörün giriş öğesine bir işlevi “eşleyen” (uygulayan) map() işlevidir.Temel sözdizimi map(.x = SEQUENCE, .f = FUNCTION, ARGUMENTS). Biraz daha ayrıntılı olarak:.x =, .f işlevinin yinelemeli olarak uygulanacağı girdilerdir - ör. yetki alanları adları vektörü, veri çerçevesindeki sütunlar veya veri çerçeveleri listesi..f =, .x girişinin bir öğesine uygulanacak fonksiyondur - zaten var olan print() gibi bir işlev veya tanımladığınız özel bir işlev olabilir. İşlev genellikle yaklaşık işaretinden sonra yazılır ~ (ayrıntılar aşağıdadır).Sözdizimi hakkında birkaç daha:Fonksiyonun daha fazla argümana ihtiyacı yoksa, parantez ve yaklaşık işareti olmadan yazılabilir (ör. .f = mean). yineleme için aynı değerde olacak bağımsız değişkenler sağlamak için, bunları map() içinde ancak .f = bağımsız değişkeninin dışında sağlayın, örneğin na.rm = T içine map(.x = my_list, .f = mean, na.rm=T).Bu yinelemenin .x değeri için yer tutucu olarak .f = fonksiyonu içinde .x (veya basitçe .) kullanabilirsiniz.Fonksiyon üzerinde daha fazla kontrole sahip olmak için yaklaşık sözdizimini (~) kullanın - fonksiyonu parantez içinde normal olarak yazın, örneğin: map(.x = my_list, .f = ~mean(., na.rm = T)). Bu söz dizimini özellikle bir bağımsız değişkenin değeri yinelemeyi değiştirecekse veya .x değerinin kendisiyse kullanın (aşağıdaki örneklere bakın)map() kullanımının çıktısı bir listedir - liste, vektör gibi bir nesne sınıfıdır, ancak öğeleri farklı sınıflardan olabilir. Bu nedenle, map() tarafından üretilen bir liste birçok veri çerçevesi veya birçok vektör, birçok tek değer ve hatta birçok liste içerebilir! Aşağıda açıklanan ve diğer çıktı türlerini üreten alternatif map() sürümleri vardır (örneğin, bir veri çerçevesi oluşturmak için .map_dfr(), karakter vektörleri üretmek için map_chr() ve sayısal vektörler üretmek için map_dbl()).","code":""},{"path":"yineleme-döngüler-ve-listeler.html","id":"iter_combined","chapter":"16 Yineleme, döngüler ve listeler","heading":"Örnek - Excel sayfalarını içe aktarın ve birleştirin","text":"Yaygın bir epidemiyolog göreviyle gösterelim: - aka verileri içeren bir Excel çalışma kitabını içe aktarmak istiyorsunuz, ancak veriler çalışma kitabındaki farklı adlandırılmış sayfalara bölünüyor. Sayfaları tek bir veri çerçevesinde nasıl verimli bir şekilde içe aktarır ve birleştirirsiniz?Diyelim ki aşağıdaki Excel çalışma kitabı bize gönderildi. sayfa belirli bir hastaneden vakaları içerir.İşte map() kullanan bir yaklaşım:map() import() işlevi, böylece Excel sayfası için çalışırbind_rows() kullanarak içe aktarılan veri çerçevelerini bir araya getirinYol boyunca, satır için orijinal sayfa adını koruyarak bu bilgiyi son veri çerçevesinde yeni bir sütunda saklayınİlk olarak, sayfa adlarını çıkarmamız ve kaydetmemiz gerekiyor. Excel çalışma kitabının dosya yolunu, sayfa adlarını ayıklayan readxl paketinden excel_sheets() işlevine sağlıyoruz. Bunları sheet_names adlı bir karakter vektöründe saklarız.İşte isimler:Artık bu ad vektörüne sahip olduğumuza göre, map() bunları import()işlevine birer birer sağlayabilir. Bu örnekte sheet_names, .x ve import() .f işlevidir.İçe aktarma ve dışa aktarma sayfasından, Excel çalışma kitaplarında kullanıldığında import() öğesinin içe aktarılacak sayfayı belirten = bağımsız değişkeni kabul edebileceğini hatırlayın..f fonksiyonu import() içinde, sheet_names vektörü aracılığıyla değeri yinelemede değişecek olan = .x’sağlarız - önce “Merkez Hastane”, ardından “Askeri Hastane” vb.- map() kullandığımız için, Excel sayfasındaki veriler bir liste içinde ayrı bir veri çerçevesi olarak kaydedilecektir. Bu liste öğelerinin (veri çerçevelerinin) birinin bir ada sahip olmasını istiyoruz, bu nedenle sheet_names map()’e aktarmadan önce onu set_names() aracılığıyla purrr’dan geçiririz, bu da liste öğesinin uygun adı almasını sağlar.Çıktı listesini combined olarak kaydediyoruz.Çıktıyı incelediğimizde, bir Excel sayfasındaki verilerin bir adla listeye kaydedildiğini görüyoruz. Bu iyi, ama tam olarak bitirmedik.Son olarak, benzer şekilde yapılandırılmış veri çerçevelerinin listesini kabul eden ve bunları tek bir veri çerçevesinde birleştiren bind_rows() (dplyr’den) işlevini kullanıyoruz. Liste öğesi adlarından yeni bir sütun oluşturmak için, .id = bağımsız değişkenini kullanırız ve ona yeni sütun için istenen adı veririz.Tüm komut dizisi aşağıdadır:Ve şimdi, orijin sayfasını içeren bir sütuna sahip bir veri çerçevemiz var!Bilmeniz gereken map() varyasyonları vardır. Örneğin, map_dfr() bir liste değil, bir veri çerçevesi döndürür. Böylece yukarıdaki görev için kullanabilirdik ve satırları bağlamak zorunda kalmazdık. Ama o zaman vakanın hangi sayfadan (hastaneden) geldiğini yakalayamazdık.Diğer varyasyonlar arasında map_chr(), map_dbl() bulunur. Bunlar iki nedenden dolayı çok faydalı işlevlerdir. İlk önce. yinelemeli bir işlevin çıktısını otomatik olarak bir vektöre (listeye değil) dönüştürürler. İkincisi, verilerin geri geldiği sınıfı açıkça kontrol edebilirler - verilerinizin map_chr() ile bir karakter vektörü veya map_dbl() ile sayısal vektör olarak geri gelmesini sağlarsınız. Bölümde daha sonra bunlara dönelim!map_at() ve map_if() işlevleri yineleme için de çok kullanışlıdır - bir listenin hangi öğelerini yinelemeniz gerektiğini belirlemenize izin verirler! Bunlar basitçe bir dizin/ad vektörü (map_at() durumunda) veya mantıksal bir test (map_if() durumunda) uygulayarak çalışır.Hastane verilerinin ilk sayfasını okumak istemediğimiz bir örnek kullanalım. map() yerine map_at() kullanırız ve .= bağımsız değişkeni c(-1) olarak belirtiriz, bu da .x’ilk öğesini kullanılmaması anlamına gelir. Alternatif olarak, hangi öğelerin kullanılacağını belirtmek için, .= için, bir pozitif sayı veya ad vektörü sağlayabilirsiniz.İlk sayfa adının yine de çıktı listesinin bir öğesi olarak görüneceğini unutmayın - ancak bu yalnızca tek bir karakter adıdır (veri çerçevesi değil). Satırları bağlamadan önce bu öğeyi kaldırmanız gerekir. Liste öğelerinin nasıl kaldırılacağını ve değiştirileceğini daha sonraki bir bölümde ele alacağız.","code":"\nsheet_names <- readxl::excel_sheets(\"hospital_linelists.xlsx\")\nsheet_names## [1] \"Central Hospital\"              \"Military Hospital\"             \"Missing\"                      \n## [4] \"Other\"                         \"Port Hospital\"                 \"St. Mark's Maternity Hospital\"\ncombined <- sheet_names %>% \n  purrr::set_names() %>% \n  map(.f = ~import(\"hospital_linelists.xlsx\", which = .x))\nsheet_names <- readxl::excel_sheets(\"hospital_linelists.xlsx\")  # extract sheet names\n \ncombined <- sheet_names %>%                                     # begin with sheet names\n  purrr::set_names() %>%                                        # set their names\n  map(.f = ~import(\"hospital_linelists.xlsx\", which = .x)) %>%  # iterate, import, save in list\n  bind_rows(.id = \"origin_sheet\") # combine list of data frames, preserving origin in new column  \nsheet_names <- readxl::excel_sheets(\"hospital_linelists.xlsx\")\n\ncombined <- sheet_names %>% \n     purrr::set_names() %>% \n     # ilk sayfayı hariç tut\n     map_at(.f = ~import( \"hospital_linelists.xlsx\", which = .x),\n            .at = c(-1))"},{"path":"yineleme-döngüler-ve-listeler.html","id":"veri-kümesini-bölme-ve-dışa-aktarma","chapter":"16 Yineleme, döngüler ve listeler","heading":"Veri kümesini bölme ve dışa aktarma","text":"Aşağıda, bir veri kümesinin parçalara nasıl bölüneceğine ve ardından bir parçayı ayrı bir Excel sayfası veya ayrı bir CSV dosyası olarak dışa aktarmak için map() yinelemesinin nasıl kullanılacağına ilişkin bir örnek veriyoruz.","code":""},{"path":"yineleme-döngüler-ve-listeler.html","id":"bölünmüş-veri-seti","chapter":"16 Yineleme, döngüler ve listeler","heading":"Bölünmüş veri seti","text":"Veri çerçevesi olarak tam vaka satır listesine sahip olduğumuzu ve şimdi hastane için ayrı bir satır listesi oluşturmak ve birini ayrı bir CSV dosyası olarak dışa aktarmak istediğimizi varsayalım. Aşağıda, izleyen adımları yapıyoruz:hospital sütunundaki benzersiz değerlere göre satır listesi veri çerçevesini bölmek için group_split() (dplyr’den) kullanın. Çıktı, hastane alt kümesi başına bir veri çerçevesi içeren bir listedir.View(linelist_split) çalıştırabilir ve bu listenin birinin bir hastaneden vakaları temsil eden 6 veri çerçevesi (“tibbles”) içerdiğini görebiliriz.Ancak, listedeki veri çerçevelerinin varsayılan olarak adları olmadığını unutmayın! birinin bir adı olmasını ve ardından CSV dosyasını kaydederken bu adı kullanmasını istiyoruz.Adları çıkarmaya yönelik bir yaklaşım, listedeki veri çerçevesinden hospital sütununu çıkarmak için pull() (dplyr’den) kullanmaktır. Ardından, güvende olmak için değerleri karaktere dönüştürürüz ve ardından o belirli veri çerçevesinin adını almak için unique() işlevini kullanırız. Bu adımların tümü, veri çerçevesine map() aracılığıyla uygulanır.Artık liste öğelerinin birinin bir adı olduğunu görebiliriz. Bu isimlere names(linelist_split) üzerinden erişilebilir.","code":"\nlinelist_split <- linelist %>% \n     group_split(hospital)\nnames(linelist_split) <- linelist_split %>%   # Assign to names of listed data frames \n     # Extract the names by doing the following to each data frame: \n     map(.f = ~pull(.x, hospital)) %>%        # Pull out hospital column\n     map(.f = ~as.character(.x)) %>%          # Convert to character, just in case\n     map(.f = ~unique(.x))                    # Take the unique hospital name\nnames(linelist_split)## [1] \"Central Hospital\"                     \"Military Hospital\"                   \n## [3] \"Missing\"                              \"Other\"                               \n## [5] \"Port Hospital\"                        \"St. Mark's Maternity Hospital (SMMH)\""},{"path":"yineleme-döngüler-ve-listeler.html","id":"birden-fazla-group_split-sütunu","chapter":"16 Yineleme, döngüler ve listeler","heading":"Birden fazla group_split() sütunu","text":"Hastane VE cinsiyetin kesişimine göre alt küme satır listesi üretmek gibi, satır listesini birden fazla gruplama sütununa bölmek istiyorsanız, liste öğelerini adlandırmak için farklı bir yaklaşıma ihtiyacınız olacaktır. Bu, dplyr’den group_keys() kullanarak benzersiz “grup anahtarları”nın toplanmasını içerir - bunlar bir veri çerçevesine döndürülür. Ardından, aşağıda gösterildiği gibi unite() ile grup anahtarlarını değerler halinde birleştirebilir ve bu grup adlarını linelist_split’e atayabilirsiniz.Şimdi, tire ile ayrılmış gruplamaları bir araya getiriyoruz ve bunları linelist_split’te liste elemanlarının adları olarak atadık. NA’yı “Eksik” ile değiştirdiğimiz için bu, bazı ekstra satırlar alır, sütun değerlerini birleştirmek için dplyr’den unite() kullanın (tire ile ayrılmış), ve sonra linelist_split adları olarak kullanılabilmesi için adsız bir vektöre dönüştürün.","code":"\n# benzersiz hastane-cinsiyet kombinasyonlarına göre bölünmüş satır listesi\nlinelist_split <- linelist %>% \n     group_split(hospital, gender)\n\n# group_keys() öğesini bir veri çerçevesi olarak çıkar\ngroupings <- linelist %>% \n     group_by(hospital, gender) %>%       \n     group_keys()\n\ngroupings      # benzersiz gruplamaları göster ## # A tibble: 18 × 2\n##    hospital                             gender\n##    <chr>                                <chr> \n##  1 Central Hospital                     f     \n##  2 Central Hospital                     m     \n##  3 Central Hospital                     <NA>  \n##  4 Military Hospital                    f     \n##  5 Military Hospital                    m     \n##  6 Military Hospital                    <NA>  \n##  7 Missing                              f     \n##  8 Missing                              m     \n##  9 Missing                              <NA>  \n## 10 Other                                f     \n## 11 Other                                m     \n## 12 Other                                <NA>  \n## 13 Port Hospital                        f     \n## 14 Port Hospital                        m     \n## 15 Port Hospital                        <NA>  \n## 16 St. Mark's Maternity Hospital (SMMH) f     \n## 17 St. Mark's Maternity Hospital (SMMH) m     \n## 18 St. Mark's Maternity Hospital (SMMH) <NA>\n# Tek bir ad değerinde birleştir\nnames(linelist_split) <- groupings %>% \n     mutate(across(everything(), replace_na, \"Missing\")) %>%  # tüm sütunlarda NA'yı \"Eksik\" ile değiştir\n     unite(\"combined\", sep = \"-\") %>%                         # Tüm sütun değerlerini tek bir sütunda birleştir\n     setNames(NULL) %>% \n     as_vector() %>% \n     as.list()"},{"path":"yineleme-döngüler-ve-listeler.html","id":"excel-sayfaları-olarak-dışa-aktar","chapter":"16 Yineleme, döngüler ve listeler","heading":"Excel sayfaları olarak dışa aktar","text":"Hastane satır listelerini, sayfa başına bir satır listesi ile bir Excel çalışma kitabı olacak şekilde dışa aktarmak için, writexl paketinden write_xlsx() işlevine yalnızca linelist_split adlı listeyi sağlayabiliriz. Bu, birden çok sayfa içeren bir Excel çalışma kitabını kaydetme özelliğine sahiptir. Liste öğesi adları, sayfa adları olarak otomatik olarak uygulanır.Artık Excel dosyasını açıp hastanenin kendi sayfası olduğunu görebilirsiniz.","code":"\nlinelist_split %>% \n     writexl::write_xlsx(path = here(\"data\", \"hospital_linelists.xlsx\"))"},{"path":"yineleme-döngüler-ve-listeler.html","id":"export-as-csv-files","chapter":"16 Yineleme, döngüler ve listeler","heading":"Export as CSV files","text":"Bu biraz daha karmaşık bir komuttur, ancak hastaneye özel bir satır listesini hastaneye özel bir dosya adıyla ayrı bir CSV dosyası olarak da dışa aktarabilirsiniz.Yine map() kullanıyoruz: liste öğesi adlarının (yukarıda gösterilen) vektörünü alıyoruz ve bunlar arasında yineleme yapmak için map() kullanıyoruz, bu adı taşıyan linelist_split listesindeki veri çerçevesine export() (rio paketinden, [İçe ve dışa aktarma] sayfasına bakın) uyguluyoruz. Adı benzersiz bir dosya adı oluşturmak için de kullanırız. İşte nasıl çalıştığı:map()’e .x olarak iletilen karakter adlarının vektörüyle başlıyoruz..f fonksiyonu, bir veri çerçevesi ve yazmak için bir dosya yolu gerektiren export() işlevidir..x girişi (hastane adı), linelist_split listesinin o belirli öğesini çıkarmak/indekslemek için .f içinde kullanılır. Bu, export() işlevine aynı anda yalnızca bir veri çerçevesinin sağlanmasıyla sonuçlanır.Örneğin, map() “Askeri Hastane” için yinelendiğinde, linelist_split[[.x]] aslında linelist_split[[\"Military Hospital\"]] olur, bu nedenle linelist_split öğesinin ikinci öğesini döndürür - ki bu, Askeri Hastanedeki tüm vakalardır.export() için sağlanan dosya yolu, str_glue() kullanımı yoluyla dinamiktir (bkz. Karakterler ve dizeler sayfası):\n() dosya yolunun temelini almak ve “data” klasörünü belirtmek için kullanılır (str_glue() çift tırnak işaretini kesmemek için tek tırnak işaretlerini edin)\n() dosya yolunun temelini almak ve “data” klasörünü belirtmek için kullanılır (str_glue() çift tırnak işaretini kesmemek için tek tırnak işaretlerini edin)Ardından bir eğik çizgi / ve ardından tekrar dosyanın tanımlanabilmesi için mevcut hastane adını yazdıran.xSon olarak, export() öğesinin bir CSV dosyası oluşturmak için kullandığı “.csv” uzantısıArtık dosyanın R Project “Epi_R_handbook” un “data” klasörüne kaydedildiğini görebilirsiniz!","code":"\nnames(linelist_split) %>%\n     map(.f = ~export(linelist_split[[.x]], file = str_glue(\"{here('data')}/{.x}.csv\")))"},{"path":"yineleme-döngüler-ve-listeler.html","id":"özel-işlevler","chapter":"16 Yineleme, döngüler ve listeler","heading":"Özel işlevler","text":"map() sağlamak için kendi işlevinizi oluşturmak isteyebilirsiniz.hastanenin vakası için salgın eğrileri oluşturmak istediğimizi varsayalım. Bunu purrr kullanarak yapmak için, .f işlevimiz zamanki gibi ggplot() ve + ile uzantılar olabilir. map() çıktısı zaman bir liste olduğundan, grafikler bir listede saklanır. Grafikler oldukları için, ggpubr paketinden ggarrange() fonksiyonuyla çıkarılabilir ve grafiklendirilebilir. (dokümantasyon)Bu map() kodu çok dağınık görünüyorsa, ilgili ggplot() komutunuzu özel bir kullanıcı tanımlı fonksiyon olarak kaydederek aynı sonucu elde edebilirsiniz, örneğin ona make_epicurve() adını verebiliriz. Bu işlev daha sonra map() içinde kullanılır. .x yinelemeli olarak hastane adıyla değiştirilecek ve make_epicurve() fonksiyonunda hosp_name olarak kullanılacaktır. Detaylar için Yazma fonksiyonları sayfasına bakın.","code":"\n# listeden öğeleri grafiklendirebilmek için paketi yükle\npacman::p_load(\"ggpubr\")\n\n# 6 hastane \"adlar\"ının vektörü boyunca haritala (daha önce oluşturulmuş)\n# belirtilen ggplot işlevini kullanın\n# çıktı, 6 ggplot içeren bir listedir\nhospital_names <- unique(linelist$hospital)\n\nmy_plots <- map(\n  .x = hospital_names,\n  .f = ~ggplot(data = linelist %>% filter(hospital == .x)) +\n                geom_histogram(aes(x = date_onset)) +\n                labs(title = .x)\n)\n\n# ggplot'ları yazdırın (bir listede saklanırlar)\nggarrange(plotlist = my_plots, ncol = 2, nrow = 3)\n# Fonksiyon oluştur\nmake_epicurve <- function(hosp_name){\n  \n  ggplot(data = linelist %>% filter(hospital == hosp_name)) +\n    geom_histogram(aes(x = date_onset)) +\n    theme_classic()+\n    labs(title = hosp_name)\n  \n}\n# haritalama\nmy_plots <- map(hospital_names, ~make_epicurve(hosp_name = .x))\n\n# ggplot'ları yazdırın (bir listede saklanırlar)\nggarrange(plotlist = my_plots, ncol = 2, nrow = 3)"},{"path":"yineleme-döngüler-ve-listeler.html","id":"sütunlar-arasında-bir-fonksiyonu-eşleme","chapter":"16 Yineleme, döngüler ve listeler","heading":"Sütunlar arasında bir fonksiyonu eşleme","text":"Diğer bir yaygın kullanım durumu, bir işlevi birçok sütun arasında eşlemektir. Aşağıda, t.test() fonksiyonunu, sayısal değerleri cinsiyete göre karşılaştırarak, veri çerçevesi satır listesindeki sayısal sütunlar arasında eşliyoruz / map().Basit istatistiksel testler sayfasından t.test()’t.test(numeric column ~ binary column) gibi bir formül biçiminde girdiler alabileceğini hatırlayın. Bu örnekte aşağıdakileri yapıyoruz:İlgilenilen sayısal sütunlar satır listesinden seçilir - bunlar map() için .x girdileri olurt.test() metodu, sayısal sütuna uygulanan .f fonksiyonu olarak sağlanırt.test() parantezleri içinde:\nilk ~ , map()’.x üzerinde yineleneceği .f’den önce gelir\n.x, t.test() işlevine sağlanan geçerli sütunu temsil eder\nikinci ~ yukarıda açıklanan t testi denkleminin bir parçasıdır\nt.test() işlevi, denklemin sağ tarafında bir ikili sütun bekler. linelist$gender vektörünü bağımsız ve statik olarak sağlıyoruz (select()’e dahil edilmediğine dikkat edin).\nilk ~ , map()’.x üzerinde yineleneceği .f’den önce gelir.x, t.test() işlevine sağlanan geçerli sütunu temsil ederikinci ~ yukarıda açıklanan t testi denkleminin bir parçasıdırt.test() işlevi, denklemin sağ tarafında bir ikili sütun bekler. linelist$gender vektörünü bağımsız ve statik olarak sağlıyoruz (select()’e dahil edilmediğine dikkat edin).map() bir liste döndürür, bu nedenle çıktı t-test sonuçlarının bir listesidir - analiz edilen sayısal sütun için bir liste öğesi.RStudio’da açıldığında (Görüntülendiğinde) t.test_results listesi şöyle görünür. Bu sayfadaki örnekler için önemli olan kısımları vurguladık.En üstte tüm listenin t.test_results olarak adlandırıldığını ve beş öğeye sahip olduğunu görebilirsiniz. Bu beş öğe, linelist’den cinsiyet - gender ile bir t-testinde kullanılan değişkenden sonra age, wt_km, ht_cm, ct_blood, temp olarak adlandırılır.Bu beş öğenin biri, içinde p.value ve conf.int gibi öğeler bulunan listelerdir. p.value gibi bu öğelerden bazıları tek sayılardır, oysa tahmin - estimate gibi bazıları iki veya daha fazla öğeden oluşur (f grubunda ortalama ve m grubunda ortalama).: Bir veri çerçevesindeki yalnızca belirli sütunlara bir işlev uygulamak istiyorsanız, [Verileri temizleme ve temel işlevler] sayfasında açıklandığı gibi mutate() ve across()’u da kullanabileceğinizi unutmayın. Aşağıda, yalnızca “yaş” sütunlarına .character() uygulamasının bir örneği verilmiştir. Parantez ve virgüllerin yerleşimine dikkat edin.","code":"\n# Sonuçlar bir liste olarak kaydedilir\nt.test_results <- linelist %>% \n  select(age, wt_kg, ht_cm, ct_blood, temp) %>%  # eşlemek için yalnızca bazı sayısal sütunları saklayın\n  map(.f = ~t.test(.x ~ linelist$gender))        # t.test fonksiyonu, SAYISAL ~ KATEGORİSEL denklemi ile\n# \"yaş\" içeren sütun adına sahip sütunları karakter sınıfına dönüştürün\nlinelist <- linelist %>% \n  mutate(across(.cols = contains(\"age\"), .fns = as.character))  "},{"path":"yineleme-döngüler-ve-listeler.html","id":"listeden-çıkarma","chapter":"16 Yineleme, döngüler ve listeler","heading":"Listeden çıkarma","text":"map() List sınıfının bir çıktısını ürettiği için, eşlik eden purrr fonksiyonlarını kullanarak listelerden nasıl veri çıkarılacağını tartışmak için biraz zaman harcayacağız. Bunu göstermek için önceki bölümdeki t.test_results listesini kullanacağız. Bu 5 listeden oluşan bir listedir - 5 listenin biri, linelist veri çerçevesinden bir sütun ile ikili sütun cinsiyeti - gender arasındaki bir t-testinin sonuçlarını içerir. Liste yapısının görseli için yukarıdaki bölümdeki resme bakın.","code":""},{"path":"yineleme-döngüler-ve-listeler.html","id":"elementlerin-isimleri","chapter":"16 Yineleme, döngüler ve listeler","heading":"Elementlerin isimleri","text":"Öğelerin adlarını çıkarmak için, yalnızca R tabanından names() fonksiyonunu kullanın. Bu durumda, t-testleri gerçekleştirilen 5 değişkenin adları olan bir alt listenin adını döndürmek için t.test_results üzerinde names() kullanırız.","code":"\nnames(t.test_results)## [1] \"age\"      \"wt_kg\"    \"ht_cm\"    \"ct_blood\" \"temp\""},{"path":"yineleme-döngüler-ve-listeler.html","id":"ada-veya-konuma-göre-öğeler","chapter":"16 Yineleme, döngüler ve listeler","heading":"Ada veya konuma göre öğeler","text":"Liste öğelerini ada veya konuma göre çıkarmak için, R temelleri sayfasında açıklandığı gibi köşeli ayraçları [[ ]] kullanabilirsiniz. Aşağıda, t.tests_results listesini indekslemek için çift parantez kullanıyoruz ve t-testinin yaşa - age göre sonuçları olan ilk öğeyi gösteriyoruz.Bununla birlikte, aşağıda aynı sonuçları elde etmek için basit ve esnek purrr fonksiyonları map() ve pluck() kullanımını göstereceğiz.","code":"\nt.test_results[[1]] # pozisyona göre ilk eleman## \n##  Welch Two Sample t-test\n## \n## data:  .x by linelist$gender\n## t = -21.3, df = 4902.9, p-value < 2.2e-16\n## alternative hypothesis: true difference in means between group f and group m is not equal to 0\n## 95 percent confidence interval:\n##  -7.544409 -6.272675\n## sample estimates:\n## mean in group f mean in group m \n##        12.66085        19.56939\nt.test_results[[1]][\"p.value\"] # ilk öğeden \"p.value\" adlı öğeyi döndür ## $p.value\n## [1] 2.350374e-96"},{"path":"yineleme-döngüler-ve-listeler.html","id":"pluck","chapter":"16 Yineleme, döngüler ve listeler","heading":"pluck()","text":"pluck(), elemanları ada veya konuma göre çeker. Örneğin - yaş için t testi sonuçlarını çıkarmak için pluck() işlevini şu şekilde kullanabilirsiniz:Diğer seviyeleri virgülle belirterek daha derin seviyeleri indeksleyin. Aşağıdaki, t.test_results listesindeki liste yaşından age “p.value” adlı öğeyi çıkarır. Karakter adları yerine sayıları da kullanabilirsiniz.pluck() işlevini bir birinci düzey öğede çalıştırmak için map() kullanarak tüm birinci düzey öğelerden bu tür iç öğeleri ayıklayabilirsiniz. Örneğin, aşağıdaki kod, t.test_results içindeki tüm listelerden “p.value” öğelerini çıkarır. t testi sonuçlarının listesi, yinelenen .x’dir, pluck() yinelenen .f fonksiyonudur ve fonksiyona “p-değeri” sağlar.Başka bir alternatif olarak, map(), eleman adını tırnak içinde yazabileceğiniz bir kestirme yol sunar ve onu çıkarır. map() kullanırsanız çıktı bir liste olur, map_chr() kullanırsanız bu adlandırılmış bir karakter vektörü olur ve map_dbl() kullanırsanız bu adlandırılmış bir sayısal vektör olur.purrr belgelerinde pluck() hakkında daha fazla bilgi edinebilirsiniz. Bir öğe yoksa NULL yerine bir hata döndüren chuck() kardeş işlevine sahiptir.","code":"\nt.test_results %>% \n  pluck(\"age\")        # alternatif olarak, pluck(1) kullanın## \n##  Welch Two Sample t-test\n## \n## data:  .x by linelist$gender\n## t = -21.3, df = 4902.9, p-value < 2.2e-16\n## alternative hypothesis: true difference in means between group f and group m is not equal to 0\n## 95 percent confidence interval:\n##  -7.544409 -6.272675\n## sample estimates:\n## mean in group f mean in group m \n##        12.66085        19.56939\nt.test_results %>% \n  pluck(\"age\", \"p.value\")## [1] 2.350374e-96\nt.test_results %>%\n  map(pluck, \"p.value\")   # her p değerini döndür## $age\n## [1] 2.350374e-96\n## \n## $wt_kg\n## [1] 2.664367e-182\n## \n## $ht_cm\n## [1] 3.515713e-144\n## \n## $ct_blood\n## [1] 0.4473498\n## \n## $temp\n## [1] 0.5735923\nt.test_results %>% \n  map_dbl(\"p.value\")   # p-değerlerini adlandırılmış bir sayısal vektör olarak döndür##           age         wt_kg         ht_cm      ct_blood          temp \n##  2.350374e-96 2.664367e-182 3.515713e-144  4.473498e-01  5.735923e-01"},{"path":"yineleme-döngüler-ve-listeler.html","id":"listeyi-veri-çerçevesine-dönüştür","chapter":"16 Yineleme, döngüler ve listeler","heading":"Listeyi veri çerçevesine dönüştür","text":"Bu karmaşık bir konudur - daha eksiksiz öğreticiler için Kaynaklar bölümüne bakın. Yine de, t-testi sonuçlarının listesini bir veri çerçevesine dönüştürmeyi göstereceğiz. Değişken, p değeri ve iki gruptan (erkek ve kadın) ortalamalar için sütunlar içeren bir veri çerçevesi oluşturacağız.Kullanılacak bazı yeni yaklaşımlar ve işlevler şunlardır:tibble() fonksiyonu, bir tibble (veri çerçevesi gibi) oluşturmak için kullanılacaktır\nTüm t.test_results’un ilk tibble sütunu olarak depolanmasını önlemek için tibble() fonksiyonunu küme parantezleri { } ile çevreliyoruz\nTüm t.test_results’un ilk tibble sütunu olarak depolanmasını önlemek için tibble() fonksiyonunu küme parantezleri { } ile çevreliyoruztibble() içinde sütun, mutate() sözdizimine benzer şekilde açıkça oluşturulur:\n., t.test_results’u temsil eder\nt-test değişken adlarıyla (liste öğesinin adı) bir sütun oluşturmak için yukarıda açıklandığı gibi names()kullanırız\np değerleriyle bir sütun oluşturmak için, p.value öğelerini çekmek ve bunları sayısal bir vektöre dönüştürmek için yukarıda açıklandığı gibi map_dbl() kullanırız\n., t.test_results’u temsil edert-test değişken adlarıyla (liste öğesinin adı) bir sütun oluşturmak için yukarıda açıklandığı gibi names()kullanırızp değerleriyle bir sütun oluşturmak için, p.value öğelerini çekmek ve bunları sayısal bir vektöre dönüştürmek için yukarıda açıklandığı gibi map_dbl() kullanırızAma şimdi grup için (erkekler ve kadınlar) ortalamaları içeren sütunlar ekleyelim.Öğe tahminini/estimate çıkarmamız gerekir, ancak bu aslında içinde iki öğe içerir (f grubunda ortalama ve m grubunda ortalama). Bu nedenle, map_chr() veya map_dbl() ile bir vektöre basitleştirilemez. Bunun yerine, tibble() içinde kullanılan map() fonksiyonunu kullanıyoruz, bu tibble içinde bir sınıf listesi sütunu yaratacaktır! Evet, bu mümkün!Bu liste sütununa sahip olduğunuzda, bu “iç içe liste” sütunlarını “dikdörtgenleştirmenize” veya “iç içeden çıkarmanıza” yardımcı olan birkaç tidyr fonksiyonu (tidyverse’nin bir parçası) vardır. Onlar hakkında daha fazla bilgiyi buradan veya vignette(\"rectangle\") çalıştırarak okuyun. Kısaca:unnest_wider() - bir liste sütununun elemanına kendi sütununu verirunnest_longer() - bir liste sütununun elemanına kendi satırını verirhoist() - unnest_wider() gibi davranır, ancak hangi öğelerin yuvalanacağını siz belirlersinizAşağıda, tibble’ın ortalama - means sütununu (iç içe bir liste olan) belirterek tibble’ı unnest_wider() öğesine iletiyoruz. Sonuç, ortalamaların biri daha önce bir means hücresinde bulunan iki öğeyi yansıtan iki yeni sütunla değiştirilmesidir.","code":"\nt.test_results %>% {\n  tibble(\n    variables = names(.),\n    p         = map_dbl(., \"p.value\"))\n  }## # A tibble: 5 × 2\n##   variables         p\n##   <chr>         <dbl>\n## 1 age       2.35e- 96\n## 2 wt_kg     2.66e-182\n## 3 ht_cm     3.52e-144\n## 4 ct_blood  4.47e-  1\n## 5 temp      5.74e-  1\nt.test_results %>% \n  {tibble(\n    variables = names(.),\n    p = map_dbl(., \"p.value\"),\n    means = map(., \"estimate\"))}## # A tibble: 5 × 3\n##   variables         p means       \n##   <chr>         <dbl> <named list>\n## 1 age       2.35e- 96 <dbl [2]>   \n## 2 wt_kg     2.66e-182 <dbl [2]>   \n## 3 ht_cm     3.52e-144 <dbl [2]>   \n## 4 ct_blood  4.47e-  1 <dbl [2]>   \n## 5 temp      5.74e-  1 <dbl [2]>\nt.test_results %>% \n  {tibble(\n    variables = names(.),\n    p = map_dbl(., \"p.value\"),\n    means = map(., \"estimate\")\n    )} %>% \n  unnest_wider(means)## # A tibble: 5 × 4\n##   variables         p `mean in group f` `mean in group m`\n##   <chr>         <dbl>             <dbl>             <dbl>\n## 1 age       2.35e- 96              12.7              19.6\n## 2 wt_kg     2.66e-182              45.8              59.6\n## 3 ht_cm     3.52e-144             109.              142. \n## 4 ct_blood  4.47e-  1              21.2              21.2\n## 5 temp      5.74e-  1              38.6              38.6"},{"path":"yineleme-döngüler-ve-listeler.html","id":"listeleri-atma-saklama-ve-sıkıştırma","chapter":"16 Yineleme, döngüler ve listeler","heading":"Listeleri atma, saklama ve sıkıştırma","text":"purrr ile çalışmak genellikle listeler içerdiğinden, listeleri değiştirmek için bazı purrr fonksiyonlarını kısaca inceleyeceğiz. purrr fonksiyonlarıyla ilgili daha eksiksiz eğitimler için Kaynaklar bölümüne bakın.list_modify() birçok kullanıma sahiptir, bunlardan biri bir liste öğesini kaldırmak olabilirkeep(), .p = için belirtilen öğeleri veya .p = için sağlanan bir işlevin DOĞRU olarak değerlendirildiği yerde tutardiscard(), .p için belirtilen öğeleri veya .p = için sağlanan bir işlevin DOĞRU olarak değerlendirildiği yerde kaldırırcompact() tüm boş öğeleri kaldırırBirden çok dosyayı içe aktarmak ve birleştirmek için map() kullanımıyla ilgili yukarıdaki bölümde oluşturulan birleşik listeyi kullanan bazı örnekler (6 vaka sıra listesi veri çerçevesi içerir):Öğeler, list_modify() ile adlarına göre ve adı NULL’eşitlenerek kaldırılabilir.Ayrıca, .p = (DOĞRU veya YANLIŞ olarak değerlendirilen bir denklem) için bir “yüklem” denklemi sağlayarak, ölçütlere göre öğeleri kaldırabilirsiniz. Fonksiyonun önüne bir tilde ~ yerleştirin ve liste öğesini temsil etmek için .x kullanın. keep() kullanılarak DOĞRU olarak değerlendirilen liste öğeleri tutulacaktır. Tersine, eğer discard() kullanılıyorsa, DOĞRU olarak değerlendirilen liste elemanları kaldırılacaktır.Aşağıdaki örnekte, sınıfları veri çerçeveleri değilse liste öğeleri atılır.Yüklem işleviniz ayrıca liste öğesindeki öğelere/sütunlara başvurabilir. Örneğin, aşağıda, ct_blood sütununun ortalamasının 25’üzerinde olduğu liste öğeleri atılır.Bu komut, tüm boş liste öğelerini kaldırır:","code":"\ncombined %>% \n  list_modify(\"Central Hospital\" = NULL)   # liste öğesini isme göre kaldır\n# yalnızca 500'den fazla satır içeren liste öğelerini tut\ncombined %>% \n  keep(.p = ~nrow(.x) > 500)  \n# Veri çerçevesi olmayan liste öğelerini at\ncombined %>% \n  discard(.p = ~class(.x) != \"data.frame\")\n# yalnızca ct_blood sütun ortalamasının 25'in üzerinde olduğu liste öğelerini tut\ncombined %>% \n  discard(.p = ~mean(.x$ct_blood) > 25)  \n# Tüm boş liste öğelerini kaldırın\ncombined %>% \n  compact()"},{"path":"yineleme-döngüler-ve-listeler.html","id":"pmap","chapter":"16 Yineleme, döngüler ve listeler","heading":"pmap()","text":"BU BÖLÜM YAPIM AŞAMASINDADIR.","code":""},{"path":"yineleme-döngüler-ve-listeler.html","id":"fonksiyonları-uygulama","chapter":"16 Yineleme, döngüler ve listeler","heading":"16.4 Fonksiyonları uygulama","text":"“Uygula” fonksiyon ailesi, yinelemeli işlemler için purrr’R tabanı alternatifidir. Onlar hakkında daha fazlasını buradan okuyabilirsiniz.","code":""},{"path":"yineleme-döngüler-ve-listeler.html","id":"kaynaklar-9","chapter":"16 Yineleme, döngüler ve listeler","heading":"16.5 Kaynaklar","text":"Data Carpentry ile döngüleriYinelemede Veri Bilimi için R sayfasıExcel dosyaları yazma/okuma üzerine skeçjennybc tarafından bir purrr dersi jennybcRebecca Barter’dan bir başka purrr dersi Rebecca Bartermap, pmap ve imap hakkında bir purrr eğitimi map, pmap, imappurrr hile sayfasıpurrr ipuçları ve püf noktalarısakla ve ","code":""},{"path":"tanımlayıcı-tablolar.html","id":"tanımlayıcı-tablolar","chapter":"17 Tanımlayıcı tablolar","heading":"17 Tanımlayıcı tablolar","text":"Bu sayfa, verileri özetlemek ve tanımlayıcı istatistiklerle tablolar oluşturmak için janitor, dplyr, gtsummary, rstatix ve temel R’ın kullanımını göstermektedir.Bu sayfa, temel tabloların nasıl oluşturulacağını, sunum için tablolar sayfası ise tabloların nasıl güzel bir şekilde biçimlendirileceğini ve yazdırılacağını kapsar.Bu paketlerin birinin kod dilinin basitliği, çıktıların erişilebilirliği, basılı çıktıların kalitesi alanlarında avantajları ve dezavantajları vardır. Senaryonuz için hangi yaklaşımın işe yaradığına karar vermek için bu sayfayı kullanın.Tablolama ve çapraz tablo özet tabloları için birkaç seçeneğiniz vardır. Göz önünde bulundurulması gereken faktörlerden bazıları, kod basitliği, özelleştirilebilirlik, istenen çıktı (veri çerçevesi olarak veya “güzel” yani .png/.jpeg/.html görüntüsü olarak R konsoluna yazdırılabilir) ve çıktı sonrası işleme kolaylığıdır. Durumunuz için aracı seçerken aşağıdaki noktaları göz önünde bulundurun.• Tabloları ve çapraz tabloları oluşturmak ve “süslemek” için janitor’dan tabyl() kullanın• Birden çok sütun ve/veya grup için sayısal özet istatistiklerin veri çerçevelerini kolayca oluşturmak için rstatix’ten get_summary_stats() kullanın• Daha karmaşık istatistikler, düzenli veri çerçevesi çıktıları veya ggplot() için veri hazırlamak için dplyr’den summarise() ve count() kullanın• Ayrıntılı ve yayına hazır tablolar oluşturmak için gtsummary’den tbl_summary() kullanın\n• Yukarıdaki paketlere erişiminiz yoksa, temel R’dan table() kullanın","code":""},{"path":"tanımlayıcı-tablolar.html","id":"hazırlık-8","chapter":"17 Tanımlayıcı tablolar","heading":"17.1 Hazırlık","text":"","code":""},{"path":"tanımlayıcı-tablolar.html","id":"paketleri-yükleme-5","chapter":"17 Tanımlayıcı tablolar","heading":"Paketleri yükleme","text":"Bu kod bloğu, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’ın p_load() fonksiyonu vurgulanmaktadır. Ayrıca, temel R’dan library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R’ın temelleri sayfasına bakabilirsiniz.","code":"\npacman::p_load(\n  rio,          # Dosya içeri aktarımı\n  here,         # Dosyaların tespit edilmesi \n  skimr,        # Verinin gözden geçirilmesi \n  tidyverse,    # Veri yönetimi + ggplot2 grafikleri  \n  gtsummary,    # Özet istatistikler ve testler\n  rstatix,      # Özet istatistikler ve istatistik testler\n  janitor,      # Toplamların ve yüzdelerin eklenmesi \n  scales,       # Yüzdelerin oranlara kolayca çevrilmesi \n  flextable     # Tabloların “güzel” resimlere dönüştürülmesi \n  )"},{"path":"tanımlayıcı-tablolar.html","id":"verinin-içeri-aktarımı-1","chapter":"17 Tanımlayıcı tablolar","heading":"Verinin içeri aktarımı","text":"Simüle edilmiş bir Ebola salgını veri setini içe aktarıyoruz. Devam etmek istiyorsanız, “temiz” satır listesini (.rds dosyası olarak) indirmek için tıklayın click download “clean” linelist . Verilerinizi rio paketinden import() fonksiyonuyla içe aktarın (.xlsx, .rds, .csv gibi birçok dosya türünü kabul eder - ayrıntılar için İçe Aktarma ve Dışa Aktarma sayfasına bakın).first 50 rows linelist displayed .","code":"\n# satır listesini içe aktar\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"tanımlayıcı-tablolar.html","id":"verileri-gözden-geçirme","chapter":"17 Tanımlayıcı tablolar","heading":"17.2 Verileri gözden geçirme","text":"","code":""},{"path":"tanımlayıcı-tablolar.html","id":"skimr-paketi","chapter":"17 Tanımlayıcı tablolar","heading":"skimr paketi","text":"skimr paketini kullanarak, veri tabaınızdaki değişkenlerin biri için ayrıntılı ve estetik bir genel bakış elde edebilirsiniz. github sayfasında github. skimr hakkında daha fazla bilgi edinin.Aşağıda, ’skim()’fonksiyonu tüm satır listesi veri çerçevesine uygulanır. Veri çerçevesine genel bir bakış ve sütunun (sınıfa göre) bir özeti çıkarılır.\nTable 17.1: Data summary\nVariable type: characterVariable type: DateVariable type: factorVariable type: numericTüm bir veri tabanı hakkında bilgi almak için temel R’dan summary() fonksiyonunu da kullanabilirsiniz, ancak bu çıktıyı okumak skimr çıktısından daha zor olabilir. Bu nedenle, sayfa sayısından tasarruf etmek için çıktı aşağıda gösterilmemiştir.","code":"\n## veritabanındaki her değişken için bilgiyi edin \nskim(linelist)\n## veritabanındaki her sütun için bilgiyi edin  \nsummary(linelist)"},{"path":"tanımlayıcı-tablolar.html","id":"özet-istatistikleri","chapter":"17 Tanımlayıcı tablolar","heading":"Özet İstatistikleri","text":"Sayısal bir sütunda özet istatistikleri göstermek için temel R işlevlerini kullanabilirsiniz. Bir sayısal sütun için yararlı özet istatistiklerin çoğunu aşağıdaki gibi summary() kullanarak elde edebilirsiniz. Veri çerçevesi adının da aşağıda gösterildiği gibi belirtilmesi gerektiğini unutmayın.Dizin parantezleri [ ] ile veri çerçevesinin belirli bir bölümüne erişebilir ve kaydedebilirsiniz:max(), min(), median(), ortalama(), quantile(), sd() ve range() gibi temel R işlevleriyle istatistikleri tek tek elde edebilirsiniz. Tam bir liste için R’ın temelleri sayfasına bakabilirsiniz.UYARI: Verileriniz eksik değerler içeriyorsa, R bunu belirtmenizi ister. Bu nedenle, na.rm = TRUE argümanı aracılığıyla R’nin eksik değerleri yok saymasını belirtmediğiniz sürece komut NA değerini verir.na.rm = TRUE.Özet istatistikleri bir veri çerçevesi biçiminde döndürmek için rstatix’teki get_summary_stats() fonkisyonunu kullanabilirsiniz. Bu fonksiyon, sonraki işlemleri gerçekleştirmek veya istatistiklerle çizim yapmak için yardımcı olabilir. rstatix paketi ve işlevleri hakkında daha fazla ayrıntı için Temel istatistiksel testler sayfasına bakın.","code":"\nsummary(linelist$age_years)##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n##    0.00    6.00   13.00   16.02   23.00   84.00      86\nsummary(linelist$age_years)[[2]]            # yalnızca ikinci ögeyi göster## [1] 6\n# eşdeğeri, eleman adı için yukarıdakine alternatif olarak \n# summary(linelist$age_years)[[\"1st Qu.\"]]  \nlinelist %>% \n  get_summary_stats(\n    age, wt_kg, ht_cm, ct_blood, temp,  # hesaplanacak sütunlar\n    type = \"common\")                    # döndürülecek özet istatistikler## # A tibble: 5 × 10\n##   variable     n   min   max median   iqr  mean     sd    se    ci\n##   <fct>    <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl>\n## 1 age       5802   0    84     13      17  16.1 12.6   0.166 0.325\n## 2 wt_kg     5888 -11   111     54      25  52.6 18.6   0.242 0.475\n## 3 ht_cm     5888   4   295    129      68 125.  49.5   0.645 1.26 \n## 4 ct_blood  5888  16    26     22       2  21.2  1.69  0.022 0.043\n## 5 temp      5739  35.2  40.8   38.8     1  38.6  0.977 0.013 0.025"},{"path":"tanımlayıcı-tablolar.html","id":"tbl_janitor","chapter":"17 Tanımlayıcı tablolar","heading":"17.3 janitor paketi","text":"janitor paketleri, yüzdeleri, oranları, sayıları vb. görüntülemek için yardımcı işlevlerin uygulandığı tablolar ve çapraz tablolar oluşturmak için tabyl() fonksiyonunu sunar.Aşağıda, sıra listesi veri çerçevesini janitor fonksiyonlarına aktarıyoruz ve sonucu yazdırıyoruz. İstenirse, sonuç tablolarını <- atama operatörü ile de kaydedebilirsiniz.","code":""},{"path":"tanımlayıcı-tablolar.html","id":"basit-tabyl","chapter":"17 Tanımlayıcı tablolar","heading":"Basit tabyl","text":"‘tabyl()’ öğesinin belirli bir sütunda varsayılan kullanımı, değerler, sayılar ve sütun bazında “yüzdeler” (oranlar) oluşturur. Oranlar çok basamaklı olabilir. Aşağıda açıklandığı gibi ‘adorn_rounding()’ ile ondalık basamak sayısını ayarlayabilirsiniz.Yukarıda gördüğünüz gibi, eksik değerler varsa,  etiketli bir satırda görüntülenirler. Bunların gösterimini show_na = FALSE ile kapatabilirsiniz. Eksik değer yoksa bu satır görünmez. Eksik değerler varsa, tüm oranlar hem ham olarak (paydadaki NA sayıları dahil) hem de “geçerli” (paydadaki NA sayıları hariç) formda verilir.Sütun sınıfı faktörse ve verilerinizde yalnızca belirli düzeyler varsa, tüm düzeyler tabloda görünmeye devam eder. show_missing_levels = FALSE belirterek bu özelliği kapatabilirsiniz. Faktörler sayfasında daha fazla bilgiye ulaşabilirsiniz.","code":"\nlinelist %>% tabyl(age_cat)##  age_cat    n     percent valid_percent\n##      0-4 1095 0.185971467   0.188728025\n##      5-9 1095 0.185971467   0.188728025\n##    10-14  941 0.159816576   0.162185453\n##    15-19  743 0.126188859   0.128059290\n##    20-29 1073 0.182235054   0.184936229\n##    30-49  754 0.128057065   0.129955188\n##    50-69   95 0.016134511   0.016373664\n##      70+    6 0.001019022   0.001034126\n##     <NA>   86 0.014605978            NA"},{"path":"tanımlayıcı-tablolar.html","id":"çapraz-tablolar","chapter":"17 Tanımlayıcı tablolar","heading":"Çapraz tablolar","text":"Çapraz tablolar, tabyl() içinde bir veya daha fazla ek sütun eklenerek elde edilir. Çıktıda yalnızca sayıların elde edildiğini unutmayın - oranlar ve yüzdeler, aşağıda gösterilen ek adımlarla eklenebilir.","code":"\nlinelist %>% tabyl(age_cat, gender)##  age_cat   f   m NA_\n##      0-4 640 416  39\n##      5-9 641 412  42\n##    10-14 518 383  40\n##    15-19 359 364  20\n##    20-29 468 575  30\n##    30-49 179 557  18\n##    50-69   2  91   2\n##      70+   0   5   1\n##     <NA>   0   0  86"},{"path":"tanımlayıcı-tablolar.html","id":"tbl_adorn","chapter":"17 Tanımlayıcı tablolar","heading":"tabyl’in “süslenmesi”","text":"Toplamları eklemek veya oranlara, yüzdelere dönüştürme işlemi veya ekranı başka bir şekilde ayarlamak için janitor “adorn” fonkisyonlarını kullanın. Tabloyu bu fonksiyonlardan birkaçından geçirebilirsiniz.Yukarıdaki işlevleri uyguladığınız sıra önemlidir. Aşağıda bazı örnekler verilmiştir.Varsayılan oranlar yerine yüzdeleri olan basit, tek yönlü bir tablo örneği:Toplam satır ve satır yüzdelerini içeren bir çapraz tablo.Hem sayıların hem de yüzdelerin görüntülenmesi için ayarlanmış bir çapraz tablo.","code":"\nlinelist %>%               # vaka satır listesi \n  tabyl(age_cat) %>%       # sayıları-oranları yaşa göre tablo haline getirin\n  adorn_pct_formatting()   # oranları yüzdelere çevir##  age_cat    n percent valid_percent\n##      0-4 1095   18.6%         18.9%\n##      5-9 1095   18.6%         18.9%\n##    10-14  941   16.0%         16.2%\n##    15-19  743   12.6%         12.8%\n##    20-29 1073   18.2%         18.5%\n##    30-49  754   12.8%         13.0%\n##    50-69   95    1.6%          1.6%\n##      70+    6    0.1%          0.1%\n##     <NA>   86    1.5%             -\nlinelist %>%                                  \n  tabyl(age_cat, gender) %>%                  # yaş ve cinsiyete göre sayılar\n  adorn_totals(where = \"row\") %>%             # toplam satırı ekle\n  adorn_percentages(denominator = \"row\") %>%  # sayıları oranlara dönüştür\n  adorn_pct_formatting(digits = 1)            # oranları yüzdelere çevir##  age_cat     f     m    NA_\n##      0-4 58.4% 38.0%   3.6%\n##      5-9 58.5% 37.6%   3.8%\n##    10-14 55.0% 40.7%   4.3%\n##    15-19 48.3% 49.0%   2.7%\n##    20-29 43.6% 53.6%   2.8%\n##    30-49 23.7% 73.9%   2.4%\n##    50-69  2.1% 95.8%   2.1%\n##      70+  0.0% 83.3%  16.7%\n##     <NA>  0.0%  0.0% 100.0%\n##    Total 47.7% 47.6%   4.7%\nlinelist %>%                                  # vaka listesi\n  tabyl(age_cat, gender) %>%                  # çapraz tablo sayıları\n  adorn_totals(where = \"row\") %>%             # toplam satırı ekle\n  adorn_percentages(denominator = \"col\") %>%  # oranlara dönüştürmek\n  adorn_pct_formatting() %>%                  # yüzdeye dönüştür\n  adorn_ns(position = \"front\") %>%            # \"sayı (yüzde)\" olarak görüntüleme\n  adorn_title(                                # başlıkların ayarlanması \n    row_name = \"Age Category\",\n    col_name = \"Gender\")##                      Gender                           \n##  Age Category             f             m          NA_\n##           0-4  640  (22.8%)  416  (14.8%)  39  (14.0%)\n##           5-9  641  (22.8%)  412  (14.7%)  42  (15.1%)\n##         10-14  518  (18.5%)  383  (13.7%)  40  (14.4%)\n##         15-19  359  (12.8%)  364  (13.0%)  20   (7.2%)\n##         20-29  468  (16.7%)  575  (20.5%)  30  (10.8%)\n##         30-49  179   (6.4%)  557  (19.9%)  18   (6.5%)\n##         50-69    2   (0.1%)   91   (3.2%)   2   (0.7%)\n##           70+    0   (0.0%)    5   (0.2%)   1   (0.4%)\n##          <NA>    0   (0.0%)    0   (0.0%)  86  (30.9%)\n##         Total 2807 (100.0%) 2803 (100.0%) 278 (100.0%)"},{"path":"tanımlayıcı-tablolar.html","id":"tabyl-çıktısının-alınması","chapter":"17 Tanımlayıcı tablolar","heading":"tabyl çıktısının alınması","text":"Varsayılan olarak tabyl, R konsolunuza ham formda yazdıracaktır.Alternatif olarak, RStudio Viewer’da .png, .jpeg, .html, vb. olarak dışa aktarılabilen bir resim olarak yazdırmak için tabyl’flextable veya benzeri bir pakete geçirebilirsiniz. Bu işlem, Sunum için tablolar sayfasında tartışılmaktadır. Bu şekilde yazdırıyorsanız ve adorn_titles() kullanıyorsanız, place = argümanını “combined” belirtmeniz gerektiğini unutmayın.Age Category/GenderfmNA_Total0-4640 (22.8%)416 (14.8%)39 (14.0%)1095 (18.6%)5-9641 (22.8%)412 (14.7%)42 (15.1%)1095 (18.6%)10-14518 (18.5%)383 (13.7%)40 (14.4%) 941 (16.0%)15-19359 (12.8%)364 (13.0%)20  (7.2%) 743 (12.6%)20-29468 (16.7%)575 (20.5%)30 (10.8%)1073 (18.2%)30-49179  (6.4%)557 (19.9%)18  (6.5%) 754 (12.8%)50-69  2  (0.1%) 91  (3.2%) 2  (0.7%)  95  (1.6%)70+  0  (0.0%)  5  (0.2%) 1  (0.4%)   6  (0.1%)  0  (0.0%)  0  (0.0%)86 (30.9%)  86  (1.5%)","code":"\nlinelist %>%\n  tabyl(age_cat, gender) %>% \n  adorn_totals(where = \"col\") %>% \n  adorn_percentages(denominator = \"col\") %>% \n  adorn_pct_formatting() %>% \n  adorn_ns(position = \"front\") %>% \n  adorn_title(\n    row_name = \"Age Category\",\n    col_name = \"Gender\",\n    placement = \"combined\") %>% # resim olarak yazdırmak için bu gereklidir\n  flextable::flextable() %>%    # güzel görüntüye dönüştür\n  flextable::autofit()          # satır başına bir satıra biçimlendir"},{"path":"tanımlayıcı-tablolar.html","id":"diğer-tablolarda-kullanımı","chapter":"17 Tanımlayıcı tablolar","heading":"Diğer tablolarda kullanımı","text":"janitor adorn_*() işlevlerini, dplyr’den summarise() ve count() veya temel R’dan table() tarafından oluşturulanlar diğer tabloları da kullanabilirsiniz. Tabloyu istenen janitor fonksiyonuna yönlendirmeniz yeterlidir. Örneğin:","code":"\nlinelist %>% \n  count(hospital) %>%   # dplyr fonksiyonu\n  adorn_totals()        # janitor fonksiyonu##                              hospital    n\n##                      Central Hospital  454\n##                     Military Hospital  896\n##                               Missing 1469\n##                                 Other  885\n##                         Port Hospital 1762\n##  St. Mark's Maternity Hospital (SMMH)  422\n##                                 Total 5888"},{"path":"tanımlayıcı-tablolar.html","id":"tabyl-kaydedilmesi","chapter":"17 Tanımlayıcı tablolar","heading":"tabyl kaydedilmesi","text":"Tabloyu flextable gibi bir paketle “güzel” bir resme dönüştürürseniz, o paketteki fonksiyonlarla kaydedebilirsiniz (flextable’da save_as_html(), save_as_word(), save_as_ppt() ve save_as_image() gibi fonksiyonlar bulunmaktadır. Sunum için tablolar sayfasında kapsamlı bir şekilde tartışılmıştır. Aşağıdaki tablo, elle düzenlenebilen bir Word belgesi olarak kaydedilmiştir:","code":"\nlinelist %>%\n  tabyl(age_cat, gender) %>% \n  adorn_totals(where = \"col\") %>% \n  adorn_percentages(denominator = \"col\") %>% \n  adorn_pct_formatting() %>% \n  adorn_ns(position = \"front\") %>% \n  adorn_title(\n    row_name = \"Age Category\",\n    col_name = \"Gender\",\n    placement = \"combined\") %>% \n flextable::flextable() %>%                     # resme dönüştür\n  flextable::autofit() %>%                       # satır başına yalnızca bir satır\n  flextable::save_as_docx(path = \"tabyl.docx\")   # dosya yoluna Word belgesi kaydet"},{"path":"tanımlayıcı-tablolar.html","id":"janitor_age_out_stats","chapter":"17 Tanımlayıcı tablolar","heading":"İstatistikler","text":"Aşağıda gösterildiği gibi, stats paketinden chisq.test() veya fisher.test() gibi fonksiyonlarla tablolar üzerinde istatistiksel testler uygulayabilirsiniz. Bu işlem, eksik değerlere izin verilmez, bu nedenle show_na = FALSE ile tablodan hariç tutulurlar.Daha fazla kod ve istatistiklerle ilgili ipuçları için [Temel istatistik testleri] sayfasına bakın.","code":"\nage_by_outcome <- linelist %>% \n  tabyl(age_cat, outcome, show_na = FALSE) \n\nchisq.test(age_by_outcome)## \n##  Pearson's Chi-squared test\n## \n## data:  age_by_outcome\n## X-squared = 6.4931, df = 7, p-value = 0.4835"},{"path":"tanımlayıcı-tablolar.html","id":"diğer-ipuçları","chapter":"17 Tanımlayıcı tablolar","heading":"Diğer ipuçları","text":"• Yukarıdaki hesaplamalardan herhangi birinden eksik değerleri hariç tutmak için na.rm = TRUE değişkenini kullanın.• tabyl() tarafından oluşturulmamış tablolara herhangi bir adorn_*() yardımcı fonksiyonu uyguluyorsanız, bunları adorn_percentage(,,,c(cases,deaths)) sintaksıyla belirli sütunlara uygulayabilirsiniz. (Sütunlar 4. değişken olarak belirtilmedir.). Sintaksı basit değil, bu nedenle bu işlem yerine summarise() kullanmayı düşünün.• Daha fazla ayrıntıyı janitor sayfasından ve tabyl gösteriminden okuyabilirsiniz.\njanitor sayfası ve tabyl göstergesi.","code":""},{"path":"tanımlayıcı-tablolar.html","id":"dplyr-paketi","chapter":"17 Tanımlayıcı tablolar","heading":"17.4 dplyr paketi","text":"dplyr, tidyverse paketlerinin bir parçasıdır ve çok yaygın bir veri yönetimi aracıdır.dplyr’ın summarise() ve count() fonksiyonları tablolar oluşturmak, istatistikleri hesaplamak, gruba göre özetlemek veya tabloları ggplot()’geçirmek için kullanışlı bir yaklaşımdır.summarise(), yeni bir özet veri çerçevesi oluşturur. Veriler gruplandırılmamışsa, tüm veri çerçevesinin belirtilen özet istatistiklerini içeren tek satırlık bir veri çerçevesi oluşturur. Veriler gruplandırılmışsa, yeni veri çerçevesinde grup başına bir satır oluşturacaktır (bkz. Verilerin gruplandırması sayfası).summarise() fonksiyonunun parantezleri içinde, yeni özet sütununun adını ve ardından bir eşittir işareti ve uygulanacak istatistiksel işlevi argüman olarak belirtmelisiniz.\n\nİPUCU: Özetleme işlevi hem İngiliz hem de Amerikan İngilizcesi ile yazılabilir. (summarise() summarize()).","code":""},{"path":"tanımlayıcı-tablolar.html","id":"gözlem-sayılarını-elde-etme","chapter":"17 Tanımlayıcı tablolar","heading":"Gözlem sayılarını elde etme","text":"summarise() içinde uygulanacak en basit fonksiyon n()’dir. Satır sayısını elde etmek için parantezleri boş bırakın.Verileri önceden gruplandırıldığında bu daha ilginç sonuçlar elde edilir.Yukarıdaki komut, count() işlevi kullanılarak kısaltılabilir. count() şunları yapar:Verileri belirlenen sütunlara göre gruplandırırVerileri n() ile özetler (n sütunu oluşturur)Verileri gruplarını çözerSayılar sütununun adını varsayılan n’den name = değişkeniyle değiştirebilirsiniz.İki veya daha fazla gruplandırma sütunundaki sayılar “uzun” biçimde tablo halinde döndürülür. n sütununda gözlem sayıları bulunmaktadır. “Uzun” ve “geniş” veri biçimleri hakkında bilgi edinmek için verileri pivotlama sayfasına bakın.","code":"\nlinelist %>%                 # satır listesiyle başla\n  summarise(n_rows = n())    # n_rows sütunu ile özet veri çerçevesi elde edilir##   n_rows\n## 1   5888\nlinelist %>% \n  group_by(age_cat) %>%     # verileri age_cat sütunundaki değerlere göre gruplandır\n  summarise(n_rows = n())   # *grup başına* satır sayısı elde edilir## # A tibble: 9 × 2\n##   age_cat n_rows\n##   <fct>    <int>\n## 1 0-4       1095\n## 2 5-9       1095\n## 3 10-14      941\n## 4 15-19      743\n## 5 20-29     1073\n## 6 30-49      754\n## 7 50-69       95\n## 8 70+          6\n## 9 <NA>        86\nlinelist %>% \n  count(age_cat)##   age_cat    n\n## 1     0-4 1095\n## 2     5-9 1095\n## 3   10-14  941\n## 4   15-19  743\n## 5   20-29 1073\n## 6   30-49  754\n## 7   50-69   95\n## 8     70+    6\n## 9    <NA>   86\nlinelist %>% \n  count(age_cat, outcome)##    age_cat outcome   n\n## 1      0-4   Death 471\n## 2      0-4 Recover 364\n## 3      0-4    <NA> 260\n## 4      5-9   Death 476\n## 5      5-9 Recover 391\n## 6      5-9    <NA> 228\n## 7    10-14   Death 438\n## 8    10-14 Recover 303\n## 9    10-14    <NA> 200\n## 10   15-19   Death 323\n## 11   15-19 Recover 251\n## 12   15-19    <NA> 169\n## 13   20-29   Death 477\n## 14   20-29 Recover 367\n## 15   20-29    <NA> 229\n## 16   30-49   Death 329\n## 17   30-49 Recover 238\n## 18   30-49    <NA> 187\n## 19   50-69   Death  33\n## 20   50-69 Recover  38\n## 21   50-69    <NA>  24\n## 22     70+   Death   3\n## 23     70+ Recover   3\n## 24    <NA>   Death  32\n## 25    <NA> Recover  28\n## 26    <NA>    <NA>  26"},{"path":"tanımlayıcı-tablolar.html","id":"tüm-seviyelerin-gösterimi","chapter":"17 Tanımlayıcı tablolar","heading":"Tüm seviyelerin gösterimi","text":"Bir sınıf faktörü sütunu oluştururken, summarise() veya count() komutuna .drop = FALSE argümanını ekleyerek (yalnızca verilerde değerleri olan seviyeleri değil) tüm seviyelerin gösterebilirsiniz.Bu teknik, tablolarınızı/grafiklerinizi standart hale getirmek için kullanışlıdır. Özellikle, birden fazla alt grup için grafik oluştururken ya da rutin raporlar için tekrarlayan grafiklerr oluştururken faydalıdır. Bu koşulların birinde, verilerdeki değerler değişse de sabit kalan seviyeler tanımlayabilirsiniz.Daha fazla bilgi için Faktörler sayfasına bakın.","code":""},{"path":"tanımlayıcı-tablolar.html","id":"tbl_dplyr_prop","chapter":"17 Tanımlayıcı tablolar","heading":"Oranlar","text":"Oranlar, yeni bir sütun oluşturmak için tablonun mutate() fonksiyonuna yönlendirmesi ile elde edilebilir. Yeni sütun, sayım sütununun (varsayılan olarak n) sayım sütununun toplamının elde edildiği sum()’bölünmesiyle oluşturulur (bu işlem bir oran verir).Bu durumda, mutate() komutundaki sum() öğesinin, oranın paydası olarak kullanılmak üzere tüm n sütununun toplamını vereceğini unutmayın. Verileri gruplandırılması sayfasında açıklandığı gibi, gruplandırılmış verilerde sum() fonksiyonu kullanılıyorsa (örneğin, mutate() fonksiyonu group_by() komutunu takip ediyorsa), gruba göre toplamlar elde edilir. Yukarıda belirtildiği gibi, count() fonksiyonu grupları çözerek görevini tamamlar. Böylece, bu senaryoda tam sütun oranlarını elde ederiz.Yüzdeleri kolayca görüntülemek için, scales paketinden percent() fonksiyonunu kullanabilirsiniz (bu fonksiyonda verinin sınıf karakterine dönüştürüldüğünü unutmayın).Aşağıda gruplar içindeki oranları hesaplamak için bir yöntem gösterilmiştir. Seçici olarak uygulanan farklı veri gruplama düzeylerine dayanan bir yöntemdir. İlk olarak, veriler group_by() aracılığıyla sonuca göre gruplandırılır. Ardından, count() uygulanır. Bu fonksiyon, verileri age_cat’e göre gruplandırır ve sonuç-age_cat kombinasyonu için gözlem sayılarını verir. Daha önemlisi, count() aynı zamanda age_cat gruplandırmasını da çözer, bu nedenle geriye kalan tek veri gruplaması sonuca göre orijinal gruplandırmadır. Bu nedenle, oranları hesaplamada son adımı (payda sum(n)) hala sonuca göre gruplandırılmıştır.","code":"\nage_summary <- linelist %>% \n  count(age_cat) %>%                     # cinsiyete göre grupla ve say (\"n\" sütunu oluşur)\n  mutate(                                # sütunun yüzdesini oluştur – paydaya dikkat edin \n    percent = scales::percent(n / sum(n))) \n\n# çıktı al \nage_summary##   age_cat    n percent\n## 1     0-4 1095  18.60%\n## 2     5-9 1095  18.60%\n## 3   10-14  941  15.98%\n## 4   15-19  743  12.62%\n## 5   20-29 1073  18.22%\n## 6   30-49  754  12.81%\n## 7   50-69   95   1.61%\n## 8     70+    6   0.10%\n## 9    <NA>   86   1.46%\nage_by_outcome <- linelist %>%                  # satır listesiyle başla\n  group_by(outcome) %>%                         # sonuca göre gruplandır\n  count(age_cat) %>%                            # age_cat ile gruplandır ve say ve ardından age_cat gruplamasını kaldır \n  mutate(percent = scales::percent(n / sum(n))) # yüzdeyi hesapla - paydanın sonuç grubuna göre olduğuna dikkat edin"},{"path":"tanımlayıcı-tablolar.html","id":"grafikleştirme","chapter":"17 Tanımlayıcı tablolar","heading":"Grafikleştirme","text":"Yukarıdaki gibi “uzun” bir tablo ggplot() ile rahatça görüntülenebilir. Veriler ggplot() tarafından doğal olarak kabul edilen “uzun” formattadır. ggplot temelleri ve ggplot ipuçları sayfalarındaki diğer örneklere bakın.","code":"\nlinelist %>%                      # satır listesiyle başlama\n  count(age_cat, outcome) %>%     # sayıları iki sütuna göre gruplandırın ve tablolaştırın\n  ggplot()+                       # yeni veri çerçevesini ggplot'a geçir\n    geom_col(                     # sütun grafiği oluştur\n      mapping = aes(   \n        x = outcome,              # sonucu x eksenine eşle\n        fill = age_cat,           # age_cat'i dolguya eşle\n        y = n))                   # sayım sütununu `n` yüksekliğe eşle"},{"path":"tanımlayıcı-tablolar.html","id":"özet-istatistiği","chapter":"17 Tanımlayıcı tablolar","heading":"Özet istatistiği","text":"dplyr ve summarise()’önemli bir avantajı, median(), mean(), max(), min(), sd() (standart sapma) ve yüzdelikler gibi daha ileri istatistik özetleri oluşturma yeteneğidir. Belirli mantık kriterlerini karşılayan satır sayılarını elde etmek için sum() fonksiyonuna da kullanabilirsiniz. Yukarıdaki gibi, bu çıktılar tüm veri çerçevesi için veya belli grup gruplar için oluşturulabilir.Sintaks aynıdır - summarise() parantezleri içinde yeni özet sütunlarının adları, ardından bir eşittir işareti ve uygulanacak istatistiksel fonksiyonlar yazılmalıdır. İstatistiksel fonksiyon içinde, üzerinde çalışılacak sütunları ve ilgili argümanlar yazılmalıdır (örneğin, çoğu matematiksel fonksiyon için na.rm = DOĞRU).Mantıksal bir ölçütü karşılayan satır sayısını elde etmek için sum()’u da kullanabilirsiniz. İçindeki ifade TRUE olarak değerlendirilirse sayıma girer. Örneğin:sum(age_years < 18, na.rm=T)sum(gender == \"male\", na.rm=T)sum(response %% c(\"Likely\", \"Likely\"))Aşağıda, satır listesi verilerinde, semptom başlangıcından hastaneye kabule kadar geçen gün gecikmesi değişkeni (sütun days_onset_hosp) özetlenmiştir.Bazı ipuçları• Belirli ölçütleri karşılayan (==) satırları “saymak” için bir mantıksal ifadeyle sum() kullanın\n• sum() gibi matematiksel fonksiyonlarda na.rm = TRUE kullanımına dikkat edin, aksi takdirde eksik değerler varsa NA elde edilir.\n• Yüzdelere kolayca dönüştürmek için scales paketindeki percent() işlevini kullanın\n• Sırasıyla 1 veya 2 ondalık basamak sağlamak için accuracy = argümanını 0,1 veya 0,01 olarak ayarlayın\n• Ondalık sayıları belirtmek için temel R’dan round() fonksiyonunu kullanın\n• Bu istatistikleri tüm veri kümesinde hesaplamak için, group_by() olmadan summarise() kullanın.\n• Daha sonraki hesaplamalar için (örneğin payda oluşturmak için) veri çerçevenizden select() ile seçebileceğiniz sütunlar oluşturabilirsiniz.","code":"\nsummary_table <- linelist %>%                                        # linelist ile başlayın, yeni nesne olarak kaydedin\n  group_by(hospital) %>%                                             # tüm hesaplamaları hastaneye göre gruplandır\n  summarise(                                                         # yalnızca aşağıdaki özet sütunları elde edilecek\n    cases       = n(),                                                # grup başına satır sayısı\n    delay_max   = max(days_onset_hosp, na.rm = T),                    # maksimum gecikme\n    delay_mean  = round(mean(days_onset_hosp, na.rm=T), digits = 1),  # ortalama gecikme, yuvarlanmış\n    delay_sd    = round(sd(days_onset_hosp, na.rm = T), digits = 1),  # gecikmelerin standart sapması, yuvarlanmış\n    delay_3     = sum(days_onset_hosp >= 3, na.rm = T),               # 3 veya daha fazla gün gecikmeli satır sayısı\n    pct_delay_3 = scales::percent(delay_3 / cases)                    # önceden tanımlanmış gecikme sütununu yüzdeye dönüştür\n  )\n\nsummary_table  # yazdır## # A tibble: 6 × 7\n##   hospital                             cases delay_max delay_mean delay_sd delay_3 pct_delay_3\n##   <chr>                                <int>     <dbl>      <dbl>    <dbl>   <int> <chr>      \n## 1 Central Hospital                       454        12        1.9      1.9     108 24%        \n## 2 Military Hospital                      896        15        2.1      2.4     253 28%        \n## 3 Missing                               1469        22        2.1      2.3     399 27%        \n## 4 Other                                  885        18        2        2.2     234 26%        \n## 5 Port Hospital                         1762        16        2.1      2.2     470 27%        \n## 6 St. Mark's Maternity Hospital (SMMH)   422        18        2.1      2.3     116 27%"},{"path":"tanımlayıcı-tablolar.html","id":"koşullu-istatistikler","chapter":"17 Tanımlayıcı tablolar","heading":"Koşullu istatistikler","text":"Koşullu istatistikleri elde etmek isteyebilirsiniz - ör. belirli ölçütleri karşılayan maksimum satır sayısı elde edilebilir. Bu işlem, sütun parantez [ ] ile alt kümelere ayrılarak gerçekleştirilebilir. Aşağıdaki örnek, ateşi olan veya olmayan hastalar için maksimum vücut sıcaklığını verir. Ancak unutmayın - group_by()ve pivot_wider() komutlarıyla (aşağıda gösterildiği gibi) başka bir sütun eklemek daha uygun olabilir. (#tbls_pivot_wider)).","code":"\nlinelist %>% \n  group_by(hospital) %>% \n  summarise(\n    max_temp_fvr = max(temp[fever == \"yes\"], na.rm = T),\n    max_temp_no = max(temp[fever == \"no\"], na.rm = T)\n  )## # A tibble: 6 × 3\n##   hospital                             max_temp_fvr max_temp_no\n##   <chr>                                       <dbl>       <dbl>\n## 1 Central Hospital                             40.4        38  \n## 2 Military Hospital                            40.5        38  \n## 3 Missing                                      40.6        38  \n## 4 Other                                        40.8        37.9\n## 5 Port Hospital                                40.6        38  \n## 6 St. Mark's Maternity Hospital (SMMH)         40.6        37.9"},{"path":"tanımlayıcı-tablolar.html","id":"hepsini-birleştirmek","chapter":"17 Tanımlayıcı tablolar","heading":"Hepsini birleştirmek","text":"stringr’den str_glue() fonksiyonu, birkaç sütundaki değerleri yeni bir sütunda birleştirmek için kullanışlıdır. Genellikle bu fonksiyon summarise() komutundan sonra kullanılır.Karakterler ve dizeler sayfasında, unite() ve paste0() dahil olmak üzere sütunları birleştirmek için çeşitli seçenekler tartışılmaktadır. Bu kullanım örneğinde, unite()’den daha esnek olduğu ve paste0()’dan daha basit sözdizimine sahip olduğu için str_glue() vurgulanmıştır.Aşağıdaki örnekte, summary_table veri çerçevesinde, delay_mean ve delay_sd sütunları birleştirilecek, yeni sütuna parantez biçimlendirmesi eklenecek ve ilgili eski sütunlar kaldırılacaktır.Ardından, tabloyu daha anlaşılır hale getirmek için, janitor’dan adorn_totals() ile toplam bir satır eklenir (bu fonksiyon sayısal olmayan sütunları yok sayar). Son olarak, hem yeniden sıralamak hem de sütunları yeniden adlandırmak için dplyr’den select() kullanıyoruz.Artık flextable’geçebilir ve tablonun çıktısını Word, .png, .jpeg, .html, Powerpoint, RMarkdown, vb.’ye alabilirsiniz! (Sunum için tablolar sayfasına bakınız).","code":"\nsummary_table %>% \n  mutate(delay = str_glue(\"{delay_mean} ({delay_sd})\")) %>%  # diğer değerleri birleştir ve biçimlendir\n  select(-c(delay_mean, delay_sd)) %>%                       # iki eski sütunu sil  \n  adorn_totals(where = \"row\") %>%                            # toplam satırı ekle\n  select(                                                    # sütunları sırala ve yeniden adlandır\n    \"Hospital Name\"   = hospital,\n    \"Cases\"           = cases,\n    \"Max delay\"       = delay_max,\n    \"Mean (sd)\"       = delay,\n    \"Delay 3+ days\"   = delay_3,\n    \"% delay 3+ days\" = pct_delay_3\n    )##                         Hospital Name Cases Max delay Mean (sd) Delay 3+ days % delay 3+ days\n##                      Central Hospital   454        12 1.9 (1.9)           108             24%\n##                     Military Hospital   896        15 2.1 (2.4)           253             28%\n##                               Missing  1469        22 2.1 (2.3)           399             27%\n##                                 Other   885        18   2 (2.2)           234             26%\n##                         Port Hospital  1762        16 2.1 (2.2)           470             27%\n##  St. Mark's Maternity Hospital (SMMH)   422        18 2.1 (2.3)           116             27%\n##                                 Total  5888       101         -          1580               -"},{"path":"tanımlayıcı-tablolar.html","id":"yüzdelikler","chapter":"17 Tanımlayıcı tablolar","heading":"Yüzdelikler","text":"Burada dplyr’deki yüzdelikler ve çeyrekliklere özel olarak değinilecektir. Yüzdelikleri döndürmek için, ‘quantile()’ fonksiyonunu varsayılanlarla kullanın veya istediğiniz değeri/değerleri ‘probs =’ değişkeni ile belirtin.Yüzdelikleri gruplara göre elde etmek istiyorsanız, group_by() öğesine basitçe başka bir sütun eklerseniz, uzun ve kullanışsız çıktılarla karşılaşabilirsiniz. Bu nedenle, bunun yerine istenen yüzdelik düzeyi için bir sütun oluşturma yöntemini kullanın.dplyr summarise() fonksiyonu kesinlikle daha iyi kontrol sağlarken, ihtiyacınız olan tüm özet istatistiklerin rstatix paketinden get_summary_stat() ile elde edebilirsiniz. Gruplandırılmış veriler üzerinde çalışıyorsanız, %0, %25, %50, %75 ve %100 değerlerini elde edebilirsiniz. Gruplandırılmamış verilere uygularsanız, yüzdelikleri probs = c(.05, .5, .75, .98) değişkeni ile belirtebilirsiniz.","code":"\n# yaşın varsayılan yüzdelik değerlerini alın (%0, %25, %50, %75, %100)\nlinelist %>% \n  summarise(age_percentiles = quantile(age_years, na.rm = TRUE))##   age_percentiles\n## 1               0\n## 2               6\n## 3              13\n## 4              23\n## 5              84\n# manuel olarak belirtilen yaş yüzdelik değerlerini alın (%5, %50, %75, %98)\nlinelist %>% \n  summarise(\n    age_percentiles = quantile(\n      age_years,\n      probs = c(.05, 0.5, 0.75, 0.98), \n      na.rm=TRUE)\n    )##   age_percentiles\n## 1               1\n## 2              13\n## 3              23\n## 4              48\n#   manuel olarak belirtilen yaş yüzdelik değerlerini alın (%5, %50, %75, %98)\nlinelist %>% \n  group_by(hospital) %>% \n  summarise(\n    p05 = quantile(age_years, probs = 0.05, na.rm=T),\n    p50 = quantile(age_years, probs = 0.5, na.rm=T),\n    p75 = quantile(age_years, probs = 0.75, na.rm=T),\n    p98 = quantile(age_years, probs = 0.98, na.rm=T)\n    )## # A tibble: 6 × 5\n##   hospital                               p05   p50   p75   p98\n##   <chr>                                <dbl> <dbl> <dbl> <dbl>\n## 1 Central Hospital                         1    12    21  48  \n## 2 Military Hospital                        1    13    24  45  \n## 3 Missing                                  1    13    23  48.2\n## 4 Other                                    1    13    23  50  \n## 5 Port Hospital                            1    14    24  49  \n## 6 St. Mark's Maternity Hospital (SMMH)     2    12    22  50.2\nlinelist %>% \n  group_by(hospital) %>% \n  rstatix::get_summary_stats(age, type = \"quantile\")## # A tibble: 6 × 8\n##   hospital                             variable     n  `0%` `25%` `50%` `75%` `100%`\n##   <chr>                                <fct>    <dbl> <dbl> <dbl> <dbl> <dbl>  <dbl>\n## 1 Central Hospital                     age        445     0     6    12    21     58\n## 2 Military Hospital                    age        884     0     6    14    24     72\n## 3 Missing                              age       1441     0     6    13    23     76\n## 4 Other                                age        873     0     6    13    23     69\n## 5 Port Hospital                        age       1739     0     6    14    24     68\n## 6 St. Mark's Maternity Hospital (SMMH) age        420     0     7    12    22     84\nlinelist %>% \n  rstatix::get_summary_stats(age, type = \"quantile\")## # A tibble: 1 × 7\n##   variable     n  `0%` `25%` `50%` `75%` `100%`\n##   <fct>    <dbl> <dbl> <dbl> <dbl> <dbl>  <dbl>\n## 1 age       5802     0     6    13    23     84"},{"path":"tanımlayıcı-tablolar.html","id":"birleştirilmiş-verileri-özetleyin","chapter":"17 Tanımlayıcı tablolar","heading":"Birleştirilmiş verileri özetleyin","text":"Birleştirilmiş verilerle başlarsanız, n() fonksiyonunu kullandığınızda, toplanan sayıların toplamını değil, satır sayısını elde edersiniz. Toplamları almak için verilerin sayımlar sütununda sum() öğesini kullanın.\nÖrneğin, linelist_agg adında sayım veri çerçevesiyle başladığınızı varsayalım- vaka sayıları sonuca ve cinsiyete göre “uzun” biçimde gösterilir.\nAşağıda, sonuca ve cinsiyete göre satır listesi vaka sayılarının örnek veri çerçevesini oluşturuyoruz (Anlaşılması için eksik değerler kaldırıldı).Sayıları (n sütunundaki) gruba göre toplamak için summarise()’kullanabilirsiniz, ancak yeni sütunu sum(n, na.rm=T) değerine eşitlemeniz gerekmektedir. Toplam işlemine koşullu öğe eklemek için, sayımlar sütunundaki alt küme ayracını [ ] kullanabilirsiniz.","code":"\nlinelist_agg <- linelist %>% \n  drop_na(gender, outcome) %>% \n  count(outcome, gender)\n\nlinelist_agg##   outcome gender    n\n## 1   Death      f 1227\n## 2   Death      m 1228\n## 3 Recover      f  953\n## 4 Recover      m  950\nlinelist_agg %>% \n  group_by(outcome) %>% \n  summarise(\n    total_cases  = sum(n, na.rm=T),\n    male_cases   = sum(n[gender == \"m\"], na.rm=T),\n    female_cases = sum(n[gender == \"f\"], na.rm=T))## # A tibble: 2 × 4\n##   outcome total_cases male_cases female_cases\n##   <chr>         <int>      <int>        <int>\n## 1 Death          2455       1228         1227\n## 2 Recover        1903        950          953"},{"path":"tanımlayıcı-tablolar.html","id":"across-birden-çok-sütun-arasından","chapter":"17 Tanımlayıcı tablolar","heading":"across() birden çok sütun arasından","text":"summarise() fonksiyonunu across() kullanarak birden çok sütuna uygulayabilirsiniz. Bu şekilde birçok sütun için aynı istatistikleri hesaplayabilirsiniz . summarise() fonksiyonu içine across() fonksiyonunu yerleştirin ve aşağıdakileri belirtin:.cols = sütun adlarının bir vektörü olarak .cols = c() veya “tidyselect” yardımcı işlevleri (aşağıda açıklanmıştır).fns =gerçekleştirilecek fonksiyon (parantez yok) - bir liste içinde birden çok fonksiyon belirtebilirsiniz.Aşağıda, mean() birkaç sayısal sütuna uygulanmıştır. Bir sütun vektörü .cols = argümanı olarak belirtilir ve .fns = olarak tek bir fonksiyon- bu durumda (parantez olmadan) ortalama belirtilir. İşlev için ek argümanlar (ör. na.rm=TRUE), .fns = argümanından sonra virgülle ayrılmış olarak yazılır.Across() kullanılırken parantez ve virgüllerin sırasını doğru yapmak zor olabilir. Across() içinde, sütunları, fonksiyonları ve fonkisyonlar için gereken fazladan argümanları dahil etmeniz gerektiğini unutmayın.Aynı anda birden fazla fonksiyon çalıştırılabilir. Aşağıda, bir liste list() içinde .fns = için mean ve sd fonkisyonları sağlanır. Yeni sütunları istediğimiz gibbi adlandırabiliriz (örneğin, “ortalama” ve “sd”).Sütunları seçmek için .cols = argümanı için sağlayabileceğiniz “tidyselect” yardımcı işlevleri şunlardır:• everything() - belirtilmeyen diğer tüm sütunlar\n• last_col() – son sütun\n• () - tüm sütunlara bir fonksiyonu uygular ve DOĞRU olanları seçer\n• starts_with() - belirli bir ön-ekle eşleşir. Örnek: starts_with(“date”)\n• ends_with() - belirli bir son-ekle eşleşir. Örnek:ends_with(“_end”)\n• contains() - bir karakter dizisi içeren sütunlar. Örnek:contains(“time”)\n• matches() - regüler bir ifade (regex) uygulamak için. Örnek:contains(“[pt]al”)\n• num_range() -\n• any_of() – sütun adlandırılmışsa eşleşir. Ad mevcut değilse kullanışlıdır. Örnek:\n• any_of(date_onset, date_death, cardiac_arrest)Örneğin, sayısal sütunun ortalamasını elde etmek için () fonksiyonunu kullanın ve içinde .numeric’parentez olmadan kullanın. Bütün bunlar across() komutu içinde kalır.","code":"\nlinelist %>% \n  group_by(outcome) %>% \n  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm),  # sütunlar\n                   .fns = mean,                               # fonksiyon\n                   na.rm=T))                                  # ekstra değişkenler## # A tibble: 3 × 5\n##   outcome age_years  temp wt_kg ht_cm\n##   <chr>       <dbl> <dbl> <dbl> <dbl>\n## 1 Death        15.9  38.6  52.6  125.\n## 2 Recover      16.1  38.6  52.5  125.\n## 3 <NA>         16.2  38.6  53.0  125.\nlinelist %>% \n  group_by(outcome) %>% \n  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm), # sütunlar\n                   .fns = list(\"mean\" = mean, \"sd\" = sd),    # çoklu fonksiyon \n                   na.rm=T))                                 # ekstra değişkenler## # A tibble: 3 × 9\n##   outcome age_years_mean age_years_sd temp_mean temp_sd wt_kg_mean wt_kg_sd ht_cm_mean ht_cm_sd\n##   <chr>            <dbl>        <dbl>     <dbl>   <dbl>      <dbl>    <dbl>      <dbl>    <dbl>\n## 1 Death             15.9         12.3      38.6   0.962       52.6     18.4       125.     48.7\n## 2 Recover           16.1         13.0      38.6   0.997       52.5     18.6       125.     50.1\n## 3 <NA>              16.2         12.8      38.6   0.976       53.0     18.9       125.     50.4\nlinelist %>% \n  group_by(outcome) %>% \n  summarise(across(\n    .cols = where(is.numeric),  # veri çerçevesindeki tüm sayısal sütunlar\n    .fns = mean,\n    na.rm=T))## # A tibble: 3 × 12\n##   outcome generation   age age_years   lon   lat wt_kg ht_cm ct_blood  temp   bmi days_onset_hosp\n##   <chr>        <dbl> <dbl>     <dbl> <dbl> <dbl> <dbl> <dbl>    <dbl> <dbl> <dbl>           <dbl>\n## 1 Death         16.7  15.9      15.9 -13.2  8.47  52.6  125.     21.3  38.6  45.6            1.84\n## 2 Recover       16.4  16.2      16.1 -13.2  8.47  52.5  125.     21.1  38.6  47.7            2.34\n## 3 <NA>          16.5  16.3      16.2 -13.2  8.47  53.0  125.     21.2  38.6  48.3            2.07"},{"path":"tanımlayıcı-tablolar.html","id":"tbls_pivot_wider","chapter":"17 Tanımlayıcı tablolar","heading":"Pivot genişletme","text":"Tablonuzu “geniş” biçimde oluşturmayı tercih ederseniz, tidyr pivot_wider() fonksiyonunu kullanarak dönüştürebilirsiniz. Sütunları rename() ile yeniden adlandırmanız gerekebilir. Daha fazla bilgi için Verilerin pivotlanması sayfasına bakın.Aşağıdaki örnek, oranlar bölümündeki “uzun” tablodur ve age_by_outcome ile başlamaktadır.Daha geniş bir tablo halinde özetlemek için ScriptTo ile, mevcut age_cat sütunundaki değerlerden name_from = age_cat ayarını yaparak yeni sütunlar yaratırız. Yeni tablo değerleri mevcut n sütunundan, value_from = n ile elde edilecektir. Pivotlama komutumuzda (çıktı) belirtilmeyen sütunlar, en sol tarafta değişmeden kalacaktır.","code":"\nage_by_outcome <- linelist %>%                  # satır listesiyle başla\n  group_by(outcome) %>%                         # sonuca göre gruplandır\n  count(age_cat) %>%                            # age_cat ile gruplandırın ve sayın ve ardından age_cat gruplamasını kaldırın\n  mutate(percent = scales::percent(n / sum(n))) # yüzdeyi hesapla - paydanın sonuç grubuna göre olduğuna dikkat edin\nage_by_outcome %>% \n  select(-percent) %>%   # basit gösterim için sadece sayımlar \n  pivot_wider(names_from = age_cat, values_from = n)  ## # A tibble: 3 × 10\n## # Groups:   outcome [3]\n##   outcome `0-4` `5-9` `10-14` `15-19` `20-29` `30-49` `50-69` `70+`  `NA`\n##   <chr>   <int> <int>   <int>   <int>   <int>   <int>   <int> <int> <int>\n## 1 Death     471   476     438     323     477     329      33     3    32\n## 2 Recover   364   391     303     251     367     238      38     3    28\n## 3 <NA>      260   228     200     169     229     187      24    NA    26"},{"path":"tanımlayıcı-tablolar.html","id":"tbl_dplyr_totals","chapter":"17 Tanımlayıcı tablolar","heading":"Toplam satırlar","text":"summarise () işlevi, gruplanmış veriler üzerinde çalıştığında, otomatik olarak “toplam” istatistikler üretmez. Aşağıda, toplam satır eklemeye yönelik iki yaklaşım sunulmaktadır:","code":""},{"path":"tanımlayıcı-tablolar.html","id":"janitorün-adorn_totals-fonskiyonu","chapter":"17 Tanımlayıcı tablolar","heading":"janitor’ün adorn_totals() fonskiyonu","text":"Tablonuz yalnızca toplamda elde edilebilecek sayılardan veya orantılardan/yüzdelerden oluşuyorsa, yukarıdaki bölümde açıklandığı gibi janitor adorn_totals() fonksiyonunu kullanarak toplamları ekleyebilirsiniz. Bu fonkisyonun yalnızca sayısal sütunları toplayabileceğine dikkat edin - diğer toplam özet istatistiklerini hesaplamak istiyorsanız dplyr ile sonraki yaklaşıma bakın.Aşağıda, satır listesi cinsiyete göre gruplandırılmıştır ve sonucu bilinen, ölen ve iyileşen vakaların sayısını açıklayan bir tabloda özetlenmiştir. Tabloyu adorn_totals()’yönlendirmek, tablonun altına sütunun toplamını yansıtan bir toplam satır ekler. Diğer adorn_*() işlevleri, kodda belirtildiği gibi ekranı ayarlar.","code":"\nlinelist %>% \n  group_by(gender) %>%\n  summarise(\n    known_outcome = sum(!is.na(outcome)),           # Sonucun eksik olmadığı gruptaki satır sayısı\n    n_death  = sum(outcome == \"Death\", na.rm=T),    # Sonucun ölüm olduğu gruptaki satır sayısı\n    n_recover = sum(outcome == \"Recover\", na.rm=T), # Sonucun hayatta kalma olduğu gruptaki satır sayısı\n  ) %>% \n  adorn_totals() %>%                                # Toplam satırı (her sayısal sütunun toplamı)\n  adorn_percentages(\"col\") %>%                      # Sütun oranlarını al\n  adorn_pct_formatting() %>%                        # Oranları yüzdelere dönüştür\n  adorn_ns(position = \"front\")                      # % ve sayıları göster (sayılar önde)##  gender known_outcome       n_death     n_recover\n##       f 2180  (47.8%) 1227  (47.5%)  953  (48.1%)\n##       m 2178  (47.7%) 1228  (47.6%)  950  (47.9%)\n##    <NA>  207   (4.5%)  127   (4.9%)   80   (4.0%)\n##   Total 4565 (100.0%) 2582 (100.0%) 1983 (100.0%)"},{"path":"tanımlayıcı-tablolar.html","id":"toplam-veride-summarise-sonrasında-bind_rows-fonksiyonu","chapter":"17 Tanımlayıcı tablolar","heading":"Toplam veride summarise() sonrasında bind_rows() fonksiyonu","text":"Tablonuz median(), mean() vb. özet istatistiklerden oluşuyorsa, yukarıda gösterilen adorn_totals() yaklaşımı yeterli olmayacaktır. Bunun yerine, tüm veri kümesi için özet istatistikleri elde etmek için ayrı bir summarise() komutu kullanarak hesaplamanız ve ardından sonuçları orijinal gruplandırılmış özet tablosuna eklemeniz gerekir. Birleştirmeyi yapmak için, Verilerin birleştirilmesi sayfasında açıklanan dplyr’dan bind_rows() fonksiyonunu kullanabilirsiniz. Aşağıda bir örnek verilmiştir:group_by() ve summarise() ile hastane bazında sonuçların özetini şu şekilde çıkarabilirsiniz:Toplamları almak için summarise() komutunu çalıştırın, ancak verileri yalnızca sonuca göre (hastaneye göre değil) şu şekilde gruplandırın:Bu iki veri çerçevesini birbirine bağlayabiliriz. by_hospital’4 sütunu, toplamların ise 3 sütunu olduğunu unutmayın. bind_rows() kullanılarak, sütunlar ada göre birleştirilir ve fazladan boşluklar NA ifadesi ile doldurulur (örneğin, iki yeni toplam satırı için sütun hastane değerleri). Satırları bağladıktan sonra, bu boş alanları replace_na() kullanarak “toplam”dönüştürürüz (bkz. Veri temizliği ve çekirdek fonksiyonlar sayfaları).Altta “Toplam” satırları olan yeni tablo yer almaktadır.Bu tablo, istediğiniz gibi “uzun” biçimdedir. İsteğe bağlı olarak, tabloyu daha okunabilir hale getirmek için bu tabloyu daha geniş forma pivotlayabilirsiniz. Yukarıdaki daha geniş pivotlama ile ilgili bölüme ve Verilerin pivotlanması sayfasına bakın. Ayrıca daha fazla sütun ekleyebilir ve düzenleyebilirsiniz. İlgili kod aşağıdadır.Daha sonra bu tablo daha “güzel” bir şekilde yazdırabilir. Aşağıda flextable ile elde edilen çıktı yer almaktadır. Bu “güzel” tablonun nasıl elde edileceği hakkında daha ayrıntılı bilgiyi Sunum için Tablolar sayfasından okuyabilirsiniz.HospitalTotal cases known outcomeRecoveredDiedTotal% casesMedian CT valuesTotal% casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22","code":"\nby_hospital <- linelist %>% \n  filter(!is.na(outcome) & hospital != \"Missing\") %>%  # Eksik sonuç veya hastane verisi olan vakaları sil\n  group_by(hospital, outcome) %>%                      # Veriyi grupla \n  summarise(                                           # İlgilenilen göstergelerin yeni özet sütunları oluşturun\n    N = n(),                                            # Hastane-sonuç grubu başına satır sayısı\n    ct_value = median(ct_blood, na.rm=T))               # by_hospital grubu başına medyan CT değeri\n\nby_hospital # tabloyu yazdır  ## # A tibble: 10 × 4\n## # Groups:   hospital [5]\n##    hospital                             outcome     N ct_value\n##    <chr>                                <chr>   <int>    <dbl>\n##  1 Central Hospital                     Death     193       22\n##  2 Central Hospital                     Recover   165       22\n##  3 Military Hospital                    Death     399       21\n##  4 Military Hospital                    Recover   309       22\n##  5 Other                                Death     395       22\n##  6 Other                                Recover   290       21\n##  7 Port Hospital                        Death     785       22\n##  8 Port Hospital                        Recover   579       21\n##  9 St. Mark's Maternity Hospital (SMMH) Death     199       22\n## 10 St. Mark's Maternity Hospital (SMMH) Recover   126       22\ntotals <- linelist %>% \n      filter(!is.na(outcome) & hospital != \"Missing\") %>%\n      group_by(outcome) %>%                            # Hastaneye göre değil, yalnızca sonuca göre gruplandırılmış  \n      summarise(\n        N = n(),                                       # Bu istatistikler artık sadece sonuca göre     \n        ct_value = median(ct_blood, na.rm=T))\n\ntotals # tabloyu yazdır## # A tibble: 2 × 3\n##   outcome     N ct_value\n##   <chr>   <int>    <dbl>\n## 1 Death    1971       22\n## 2 Recover  1469       22\ntable_long <- bind_rows(by_hospital, totals) %>% \n  mutate(hospital = replace_na(hospital, \"Total\"))\ntable_long %>% \n  \n  # Daha geniş pivotlama ve formatlama \n\n    mutate(hospital = replace_na(hospital, \"Total\")) %>% \n  pivot_wider(                                         # Uzundan genişe pivotlama\n    values_from = c(ct_value, N),                       # yeni değerler ct ve count sütunlarından alınmıştır\n    names_from = outcome) %>%                           # sonuçlardan yeni sütun adları \n  mutate(                                              # Yeni sütunlar ekle\n    N_Known = N_Death + N_Recover,                               # sonucu bilinen sayı\n    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # ölen vakaların yüzdesi (1 ondalık basamağa kadar)\n    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # iyileşenlerin yüzdesi (1 ondalık basamağa kadar)\n  select(                                              # Sütunları yeniden sırala\n    hospital, N_Known,                                   # Giriş sütunları\n    N_Recover, Pct_Recover, ct_value_Recover,            # İyileşenlerin sütunları\n    N_Death, Pct_Death, ct_value_Death)  %>%             # Ölen vakaların sütunları\n  arrange(N_Known)                                  # Satırları en düşükten en yükseğe doğru düzenleyin (Toplam satır en altta)## # A tibble: 6 × 8\n## # Groups:   hospital [6]\n##   hospital                             N_Known N_Recover Pct_Recover ct_value_Recover N_Death Pct_Death ct_value_Death\n##   <chr>                                  <int>     <int> <chr>                  <dbl>   <int> <chr>              <dbl>\n## 1 St. Mark's Maternity Hospital (SMMH)     325       126 38.8%                     22     199 61.2%                 22\n## 2 Central Hospital                         358       165 46.1%                     22     193 53.9%                 22\n## 3 Other                                    685       290 42.3%                     21     395 57.7%                 22\n## 4 Military Hospital                        708       309 43.6%                     22     399 56.4%                 21\n## 5 Port Hospital                           1364       579 42.4%                     21     785 57.6%                 22\n## 6 Total                                   3440      1469 42.7%                     22    1971 57.3%                 22"},{"path":"tanımlayıcı-tablolar.html","id":"tbl_gt","chapter":"17 Tanımlayıcı tablolar","heading":"17.5 gtsummary paketi","text":"Özet istatistiklerinizi yayına hazır bir grafikte yazdırmak istiyorsanız, gtsummary paketini ve onun tbl_summary() fonksiyonunu kullanabilirsiniz. Kod ilk başta karmaşık görünebilir, ancak çıktıları güzel görünür ve RStudio Viewer panelinize HTML görüntüsü olarak yazdırılır. gösterimi burada.Ayrıca istatistiksel testlerin sonuçlarını gtsummary tablolarına ekleyebilirsiniz. Bu işlem, Basit istatistik testleri sayfasının gtsummary bölümünde açıklanmıştır.Basit istatistiksel testler sayfası.tbl_summary()’yi tanıtmak için öncelikle büyük ve güzel tablolar oluşturan en temel işlevlerini göstereceğiz. Daha sonra düzenlemelerin ve özel tablolar yapımını detaylı olarak inceleyeceğiz.","code":""},{"path":"tanımlayıcı-tablolar.html","id":"özet-tablosu","chapter":"17 Tanımlayıcı tablolar","heading":"Özet tablosu","text":"tbl_summary()’nin varsayılan fonksiyonuyla belirtilen sütunları alır ve tek komutta bir özet tablo oluşturur. İşlev, sütun sınıfına uygun istatistikleri yazdırır: sayısal sütunlar için medyan ve çeyrekler arası aralık (IQR) ve kategorik sütunlar için gözlem sayısı (%) istatistiklerini verir. Eksik değerler “Bilinmeyen” ifadesnie dönüştürülür. İstatistikleri açıklamak için en alta dipnotlar eklenirken, toplam N üstte gösterilir.","code":"\nlinelist %>% \n  select(age_years, gender, outcome, fever, temp, hospital) %>%  # sadece ilgilenilen sütunları tut\n  tbl_summary()                                                  # varsayılan"},{"path":"tanımlayıcı-tablolar.html","id":"ayarlar-1","chapter":"17 Tanımlayıcı tablolar","heading":"Ayarlar","text":"Şimdi fonksiyonun nasıl çalıştığını ve ayarlamaların nasıl yapıldığını anlatacağız. Temel değişkenler aşağıda detaylandırılmıştır:=\n2 yönlü bir tablo oluşturarak tablonuzu bir sütuna göre (örn. sonuca göre) tabakalandırabilirsiniz.statistic =\nHangi istatistiklerin gösterileceğini ve nasıl görüntüleneceğini belirtmek için denklem kullanın. Denklemin bir tilde ~ işareti ile ayrılmış iki tarafı vardır. Sağ tarafta istenen istatistiksel hesap, sol tarafta ise bu hesabın uygulanacağı sütunlar yer almaktadır.• Denklemin sağ tarafındaki stringr’den str_glue() sintaksına (bkz. “n” (sayılar için), “N” (payda için), “mean”, “median”, “sd”, “max”, “min”, yüzdelikleri ( “p##” olarak; örneğin p25, toplamın yüzdeliği p) dahil edebilirsiniz. Ayrıntılar için ?tbl_summary komutunu uygulayın.• Denklemin sol tarafı için sütunları ada göre (örn. yaş veya c(yaş, cinsiyet)) veya all_continuous(), all_categorical(), include(), start_with(), vb. gibi yardımcıları kullanarak belirtebilirsiniz.Basit bir statistics = denklemi örneği, yalnızca age_years sütununun ortalamasını yazdırmak için aşağıdaki gibi görünebilir:Biraz daha karmaşık gibi görünebilen denklem “({min}, {maks})”, maksimum ve minimum değerleri parantez içine alır ve virgülle ayırır:Ayrı sütunlar veya sütun türleri için sintaksı de farklılaştırabilirsiniz. Aşağıdaki daha karmaşık örnekte, statistic = argümanına sağlanan değer, tablonun tüm sürekli sayısal sütunlar için parantez içinde standart sapma ile ortalamayı, tüm kategorik sütunlar için ise n, payda ve yüzdeyi yazdırması gerektiğini belirten bir listedir.digits =\nRakamları ve yuvarlamayı ayarlayın. İsteğe bağlı olarak, bu yalnızca sürekli sütunlar için belirtilebilir (aşağıdaki gibi).label=\nSütun adının nasıl görüntüleneceğini ayarlayın. Bir tilde ~ ile ayrılmış sütun adını ve istenen etiketi sağlayın. Varsayılan, sütun adıdır.Missing_text=\nEksik değerlerin nasıl görüntüleneceğini ayarlayın. Varsayılan ifade “Bilinmeyen”dir.type =\nBu argüman, istatistiklerin hangi düzeyinin gösterileceğini ayarlamak için kullanılır. Sintaksı, statistic = değişkeni ile benzerdir, çünkü solda sütunlar ve sağda değer içeren bir denklem oluşturursunuz. İki yaygın senaryo şunları içerir:• type = all_categorical() ~ “categorical” İkili sütunları (örn. ateş evet/hayır) yalnızca “evet” satırı yerine tüm seviyeleri göstermeye zorlar• type = all_continuous() ~ “continuous2” Daha sonraki bir bölümde gösterildiği gibi, değişken başına çok satırlı istatistiklere izin verirAşağıdaki örnekte, bu bağımsız değişkenlerin biri orijinal özet tablosunu değiştirmek için kullanılır:","code":"\nlinelist %>% \n  select(age_years) %>%         # yalnızca ilgilenilen sütunları tut\n  tbl_summary(                  # özet tablo oluştur\n    statistic = age_years ~ \"{mean}\") # yaş ortalamasını yazdır\nlinelist %>% \n  select(age_years) %>%                       # yalnızca ilgilenilen sütunları tut \n  tbl_summary(                                # özet tablo oluştur\n    statistic = age_years ~ \"({min}, {max})\") # yaşın en küçük ve en büyük değerlerini yazdır\nlinelist %>% \n  select(age_years, gender, outcome, fever, temp, hospital) %>% # yalnızca ilgilenilen sütunları tut\n  tbl_summary(     \n    by = outcome,                                               # tüm tabloyu sonuca göre katmanlandır\n    statistic = list(all_continuous() ~ \"{mean} ({sd})\",        # sürekli sütunlar için istatistikler ve biçim\n                     all_categorical() ~ \"{n} / {N} ({p}%)\"),   # kategorik sütunlar için istatistikler ve biçim\n    digits = all_continuous() ~ 1,                              # sürekli sütunlar için yuvarlama\n    type   = all_categorical() ~ \"categorical\",                 # tüm kategorik seviyeleri görüntülemeye zorla\n    label  = list(                                              # sütun adları için etiketleri göster\n      outcome   ~ \"Outcome\",                           \n      age_years ~ \"Age (years)\",\n      gender    ~ \"Gender\",\n      temp      ~ \"Temperature\",\n      hospital  ~ \"Hospital\"),\n    missing_text = \"Missing\"                                    # eksik değerler nasıl gösterilmelidir\n  )## 1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_explicit_na()` on `outcome` column before passing to `tbl_summary()`."},{"path":"tanımlayıcı-tablolar.html","id":"sürekli-değişkenler-için-çok-satırlı-istatistikler","chapter":"17 Tanımlayıcı tablolar","heading":"Sürekli değişkenler için çok satırlı istatistikler","text":"Sürekli değişkenler için birden çok istatistik satırı yazdırmak istiyorsanız, bunu type = değişkenini “continuous2” olarak ayarlayarak belirtebilirsiniz. Hangi istatistikleri göstermek istediğinizi seçerek, daha önce gösterilen tüm öğeleri tek bir tabloda birleştirebilirsiniz. Bunun için type argümanına “continuous2” girerek tabloyu geri almak istediğinizi fonksiyona belirtmeniz gerekir. Eksik değerlerin sayısı “Bilinmeyen” olarak gösterilir.Bu tabloları p değerleri eklenerek, renk ve başlıkları ayarlayarak vb. gibi birçok başka şekilde değiştirilebilir. Bu işlemler çoğu belgelerde açıklanmıştır (Konsol’?tbl_summary komutunu girin) ve diğer işlemler ise istatistiksel testler bölümünde açıklanmıştır.istatistiksel testler.","code":"\nlinelist %>% \n  select(age_years, temp) %>%                      # yalnızca ilgilenilen sütunları tut\n  tbl_summary(                                     # özet tablo oluştur\n    type = all_continuous() ~ \"continuous2\",       # birden fazla istatistik yazdırmak istediğinizi belirtin\n    statistic = all_continuous() ~ c(\n      \"{mean} ({sd})\",                             # 1. satır: ortalama ve SD\n      \"{median} ({p25}, {p75})\",                   # 2. satır: medyan ve IQR\n      \"{min}, {max}\")                              # satır 3: min ve maks\n    )"},{"path":"tanımlayıcı-tablolar.html","id":"r-tabanı","chapter":"17 Tanımlayıcı tablolar","heading":"17.6 R tabanı","text":"Sütunları tablolamak ve çapraz tablo oluşturmak için table() fonkisyonunu kullanabilirsiniz. Yukarıdaki seçeneklerden farklı olarak, aşağıda gösterildiği gibi bir sütun adına başvurduğunuzda veri çerçevesini belirtmelisiniz.Uyarı: NA (eksik) değerler, useNA = “always” (aynı zamanda “hayır” veya “eğer” olarak da ayarlanabilir) değişkenini eklemediğiniz sürece tablo haline getirilmeyecektir.İPUCU: Baz fonksiyonlarda tekrarlanan veri çerçevesi belirtme ihtiyacını ortadan kaldırmak için magrittr’den %$% operatörünü kullanabilirsiniz. Örneğin aşağıdaki satır listesi tablosunu inceleyin (çıktı, useNA = “always”)Birden çok sütun, virgülle ayrılmış şekilde ardışık olarak listelenerek çapraz tablo haline getirilebilir. İsteğe bağlı olarak, sütuna Outcome = linelist$outcome değişkeni gösterildiği gibi bir ad atayabilirsiniz.","code":"\ntable(linelist$outcome, useNA = \"always\")## \n##   Death Recover    <NA> \n##    2582    1983    1323\nage_by_outcome <- table(linelist$age_cat, linelist$outcome, useNA = \"always\") # tabloyu nesne olarak kaydet\nage_by_outcome   # tabloyu yazdır##        \n##         Death Recover <NA>\n##   0-4     471     364  260\n##   5-9     476     391  228\n##   10-14   438     303  200\n##   15-19   323     251  169\n##   20-29   477     367  229\n##   30-49   329     238  187\n##   50-69    33      38   24\n##   70+       3       3    0\n##   <NA>     32      28   26"},{"path":"tanımlayıcı-tablolar.html","id":"oranlar","chapter":"17 Tanımlayıcı tablolar","heading":"Oranlar","text":"Oranları elde etmek için yukarıdaki tabloyu prop.table() aktarın geçirin. Oranların (1) satırlardan mı, (2) sütunlardan mı yoksa tüm tablodan mı (3) olmasını istediğinizi belirtmek için margins = argümanını kullanın. Kolay anlaşılmasını sağlamak için, 2 basamak belirterek tabloyu temel R’daki round() fonksiyonuna yönlendiririz.","code":"\n# yukarıda tanımlanan tablo oranlarını, satırlara göre, yuvarlanmış olarak alın\nprop.table(age_by_outcome, 1) %>% round(2)##        \n##         Death Recover <NA>\n##   0-4    0.43    0.33 0.24\n##   5-9    0.43    0.36 0.21\n##   10-14  0.47    0.32 0.21\n##   15-19  0.43    0.34 0.23\n##   20-29  0.44    0.34 0.21\n##   30-49  0.44    0.32 0.25\n##   50-69  0.35    0.40 0.25\n##   70+    0.50    0.50 0.00\n##   <NA>   0.37    0.33 0.30"},{"path":"tanımlayıcı-tablolar.html","id":"toplamlar","chapter":"17 Tanımlayıcı tablolar","heading":"Toplamlar","text":"Satır ve sütun toplamlarını eklemek için tabloyu addmargins() fonksiyonuna iletin. Bu fonksiyon hem sayılar hem de oranlar için geçerlidir.\n”","code":"\naddmargins(age_by_outcome)##        \n##         Death Recover <NA>  Sum\n##   0-4     471     364  260 1095\n##   5-9     476     391  228 1095\n##   10-14   438     303  200  941\n##   15-19   323     251  169  743\n##   20-29   477     367  229 1073\n##   30-49   329     238  187  754\n##   50-69    33      38   24   95\n##   70+       3       3    0    6\n##   <NA>     32      28   26   86\n##   Sum    2582    1983 1323 5888"},{"path":"tanımlayıcı-tablolar.html","id":"veri-çerçevesine-dönüştürmek","chapter":"17 Tanımlayıcı tablolar","heading":"Veri çerçevesine dönüştürmek","text":"Bir tablo() nesnesini doğrudan bir veri çerçevesine dönüştürmek kolay değildir. Bir yaklaşım aşağıda gösterilmiştir:tabloyu useNA = “always” değişkenini kullanmadan oluşturun. Bunun yerine forcats’tan fct_explicit_na() fonksiyonu ile NA değerlerini “(Missing)”e dönüştürün.Toplamları (isteğe bağlı) addmargins() fonkisyonuna yönlendirerek ekleyinTemel R fonksiyonuna tünelleme için .data.frame.matrix() fonksiyonunu kullanınİlk sütunun adını belirterek tabloyu rownames_to_column() tibble fonksiyonuna aktarınTabloyu istediğiniz gibi yazdırın, görüntüleyin veya dışa aktarın. Bu örnekte, Sunum için tablolar sayfasında açıklandığı gibi flextable paketinden flextable() fonksiyonu kullanılmıştır. Bu şekilde tablo RStudio görüntüleyici bölmesine HTML görüntüsü olarak yazdırılacaktır.Age CategoryDeathRecover(Missing)Sum0-44713642601,0955-94763912281,09510-1443830320094115-1932325116974320-294773672291,07330-4932923818775450-693338249570+3306(Missing)32282686Sum2,5821,9831,3235,888","code":"\ntable(fct_explicit_na(linelist$age_cat), fct_explicit_na(linelist$outcome)) %>% \n  addmargins() %>% \n  as.data.frame.matrix() %>% \n  tibble::rownames_to_column(var = \"Age Category\") %>% \n  flextable::flextable()"},{"path":"tanımlayıcı-tablolar.html","id":"kaynaklar-10","chapter":"17 Tanımlayıcı tablolar","heading":"17.7 Kaynaklar","text":"Bu sayfadaki bilgilerin çoğu şu kaynaklardan ve çevrimiçi görüntülerden uyarlanmıştır:gtsummarydplyr","code":""},{"path":"basit-istatistiksel-testler.html","id":"basit-istatistiksel-testler","chapter":"18 Basit istatistiksel testler","heading":"18 Basit istatistiksel testler","text":"Bu sayfa, base R, rstatix ve gtsummary kullanılarak basit istatistiksel testlerin nasıl gerçekleştirileceğini gösterir.t testiShapiro-Wilk testiWilcoxon sıra toplamı testiKruskal-Wallis testiKi-kare testiSayısal değişkenler arasındaki korelasyonlar…başka birçok test yapılabilir, ancak biz sadece bu yaygın testleri göstermekteyiz ve daha fazla belgeye bağlantı vermekteyiz.Yukarıdaki paketlerin biri belirli avantajlar ve dezavantajlar getirir:İstatistiksel çıktıları R Konsoluna yazdırmak için base R fonksiyonlarını kullanınSonuçları bir veri çerçevesinde döndürmek için veya testlerin gruplara göre yapılmasını istiyorsanız rstatix fonksiyonlarını kullanınYayına hazır tabloları hızlı bir şekilde yazdırmak istiyorsanız gtsummary kullanın","code":""},{"path":"basit-istatistiksel-testler.html","id":"hazırlık-9","chapter":"18 Basit istatistiksel testler","heading":"18.1 Hazırlık","text":"","code":""},{"path":"basit-istatistiksel-testler.html","id":"paketleri-yükleyin-1","chapter":"18 Basit istatistiksel testler","heading":"Paketleri yükleyin","text":"Bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() vurgusunu yapıyoruz. base R’dan library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakın.","code":"\npacman::p_load(\n  rio,          # Dosyayı içe aktarma\n  here,         # Dosyayı konumlama\n  skimr,        # Veriye göz atma\n  tidyverse,    # veri yönetimi + ggplot2 grafikleri, \n  gtsummary,    # özet istatistikler ve testler\n  rstatix,      # istatistikler\n  corrr,        # Sayısal değişkenler için Korelasyon analizi \n  janitor,      # Tablolara toplamı ve yüzdeleri ekleme\n  flextable     # Tabloları HTML formatına dönüştürme\n  )"},{"path":"basit-istatistiksel-testler.html","id":"verileri-içe-aktar-3","chapter":"18 Basit istatistiksel testler","heading":"Verileri içe aktar","text":"Simüle edilmiş bir Ebola salgınından vakaların veri setini içe aktarıyoruz. Takip etmek isterseniz, “temiz” vaka listesini indirmek için tıklayınız(.rds dosyası olarak). Verilerinizi rio paketinden import() fonksiyonuyla içe aktarın (.xlsx, .rds, .csv gibi birçok dosya türünü kabul eder - ayrıntılar için [İçe aktarma ve dışa aktarma] sayfasına bakın).Vaka listesinin ilk 50 satırı aşağıda görüntülenmektedir.base (temel) R {}İstatistiksel testler yapmak için base R fonksiyonlarını kullanabilirsiniz. Komutlar nispeten basittir ve sonuçlar basit görüntüleme için R Konsoluna yazdırılacaktır. Bununla birlikte, çıktılar genellikle listelerdir ve bu nedenle sonuçları sonraki işlemlerde kullanmak istiyorsanız manipüle edilmesi daha zordur.","code":"\n# Vaka listesini içe aktarma\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"basit-istatistiksel-testler.html","id":"t-testleri","chapter":"18 Basit istatistiksel testler","heading":"T testleri","text":"“Student’s t-Test” olarak da adlandırılan bir t-testi, genellikle iki grup arasındaki bazı sayısal değişkenlerin ortalamaları arasında önemli bir fark olup olmadığını belirlemek için kullanılır. Burada, sütunların aynı veri çerçevesinde olup olmadığına bağlı olarak bu testi yapmak için sözdizimini göstereceğiz.Sözdizimi 1: Bu, sayısal ve kategorik sütunlarınız aynı veri çerçevesinde olduğundaki sözdizimidir. Denklemin sol tarafında sayısal sütunu ve sağ tarafında kategorik sütunu sağlayın. Veri kümesini data = olarak belirtin. İsteğe bağlı olarak, paired = TRUE, ve conf.level = (0.95 default), vealternative =(“iki taraflı”, “daha az” veya “daha büyük”) olarak ayarlayın. Daha fazla ayrıntı için ?t.test girin.Sözdizimi 2: Bu alternatif sözdizimini kullanarak iki ayrı sayısal vektörü karşılaştırabilirsiniz. Örneğin, iki sütun farklı veri kümelerindeyse.Örneklerin ortalamasının belirli bir değerden önemli ölçüde farklı olup olmadığını belirlemek için bir t testi de kullanabilirsiniz. Burada, mu = olarak bilinen/varsayımsal popülasyon ortalaması ile tek örnekli bir t-testi yapıyoruz:","code":"\n## T-testi ile grupların yaş ortalamalarını karşılaştırma\nt.test(age_years ~ gender, data = linelist)## \n##  Welch Two Sample t-test\n## \n## data:  age_years by gender\n## t = -21.344, df = 4902.3, p-value < 2.2e-16\n## alternative hypothesis: true difference in means between group f and group m is not equal to 0\n## 95 percent confidence interval:\n##  -7.571920 -6.297975\n## sample estimates:\n## mean in group f mean in group m \n##        12.60207        19.53701\nt.test(df1$age_years, df2$age_years)\nt.test(linelist$age_years, mu = 45)"},{"path":"basit-istatistiksel-testler.html","id":"shapiro-wilk-testi","chapter":"18 Basit istatistiksel testler","heading":"Shapiro-Wilk testi","text":"Shapiro-Wilk testi bir örneğin normal dağılıma sahip bir popülasyondan gelip gelmediğini belirlemek için kullanılabilir (diğer birçok testin varsayımı ve analizinde olduğu gibi, örneğin t-testi). Ancak, bu yalnızca 3 ila 5000 gözlem arasındaki bir örnek üzerinde kullanılabilir. Daha büyük numuneler için bir quantile-quantile (Q-Q) grafiği yardımcı olabilir.","code":"\nshapiro.test(linelist$age_years)"},{"path":"basit-istatistiksel-testler.html","id":"wilcoxon-sıralama-toplamı-testi","chapter":"18 Basit istatistiksel testler","heading":"Wilcoxon sıralama toplamı testi","text":"Mann–Whitney U testi olarak da adlandırılan Wilcoxon sıralama toplamı testi, genellikle iki sayısal örneğin popülasyonları normal dağılmadığında veya eşit olmayan varyansa sahip olduğunda kullanılır.","code":"\n## Wilcox testi ile grupların yaş dağılımını karşılaştırma\nwilcox.test(age_years ~ outcome, data = linelist)## \n##  Wilcoxon rank sum test with continuity correction\n## \n## data:  age_years by outcome\n## W = 2501868, p-value = 0.8308\n## alternative hypothesis: true location shift is not equal to 0"},{"path":"basit-istatistiksel-testler.html","id":"kruskal-wallis-testi","chapter":"18 Basit istatistiksel testler","heading":"Kruskal-Wallis testi","text":"Kruskal-Wallis testi, ikiden fazla örneklemin dağılımdaki farklılıklarını test etmek için kullanılabilecek Wilcoxon testinin bir uzantısıdır. Yalnızca iki örnek kullanıldığında, Wilcoxon testiyle aynı sonuçları verir.","code":"\n## Kruskal-Wallis testi ile grupların yaş dağılımını karşılaştırma\nkruskal.test(age_years ~ outcome, linelist)## \n##  Kruskal-Wallis rank sum test\n## \n## data:  age_years by outcome\n## Kruskal-Wallis chi-squared = 0.045675, df = 1, p-value = 0.8308"},{"path":"basit-istatistiksel-testler.html","id":"ki-kare-testi","chapter":"18 Basit istatistiksel testler","heading":"Ki-kare testi","text":"Pearson Ki-kare testi kategorik gruplar arasındaki önemli farklılıkları test etmek için kullanılır.","code":"\n## Ki-kare testi ile her grubun oranlarını karşılaşırma\nchisq.test(linelist$gender, linelist$outcome)## \n##  Pearson's Chi-squared test with Yates' continuity correction\n## \n## data:  linelist$gender and linelist$outcome\n## X-squared = 0.0011841, df = 1, p-value = 0.9725"},{"path":"basit-istatistiksel-testler.html","id":"rstatix-paketi","chapter":"18 Basit istatistiksel testler","heading":"18.2 rstatix paketi","text":"rstatix paketi, istatistiksel testlerin çalıştırılmasını ve sonuçlarını “tünel dostu” bir çerçevede alma olanağı sunar. Sonuçlar üzerinde işlemleri gerçekleştirebilmeniz için sonuçlar, otomatik olarak bir veri çerçevesindedir. İstatistiklerin grup için çalıştırılması ve fonksiyonlara geçirilen verileri gruplamak kolaydır.","code":""},{"path":"basit-istatistiksel-testler.html","id":"özet-istatistikler","chapter":"18 Basit istatistiksel testler","heading":"Özet istatistikler","text":"get_summary_stats() fonksiyonu, özet istatistikleri döndürmenin hızlı bir yoludur. Veri kümenizi bu fonksiyona aktarmanız ve analiz edilecek sütunları sağlamanız yeterlidir. Hiçbir sütun belirtilmemişse, istatistikler tüm sütunlar için hesaplanır.Varsayılan olarak, tam bir özet istatistik aralığı döndürülür: n, maks, min, medyan, %25 ile, %75 ile, IQR, medyan mutlak sapma (mad), ortalama, standart sapma, standart hata ve güven aralığı.type = için şu değerlerden birini sağlayarak döndürülecek özet istatistiklerin bir alt kümesini belirtebilirsiniz: “full”, “common”, “robust”, “five_number”, “mean_sd”, “mean_se”, “mean_ci” , “median_iqr”, “median_mad”, “quantile”, “mean”, “median”, “min”, “max”.gruplama değişkeni için bir satır döndürülecek şekilde gruplandırılmış verilerle de kullanılabilir:İstatistiksel testler yapmak için rstatix’de kullanabilirsiniz:","code":"\nlinelist %>%\n  rstatix::get_summary_stats(age, temp)## # A tibble: 2 × 13\n##   variable     n   min   max median    q1    q3   iqr    mad  mean     sd    se    ci\n##   <fct>    <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl>  <dbl> <dbl>  <dbl> <dbl> <dbl>\n## 1 age       5802   0    84     13     6    23      17 11.9    16.1 12.6   0.166 0.325\n## 2 temp      5739  35.2  40.8   38.8  38.2  39.2     1  0.741  38.6  0.977 0.013 0.025\nlinelist %>%\n  group_by(hospital) %>%\n  rstatix::get_summary_stats(age, temp, type = \"common\")## # A tibble: 12 × 11\n##    hospital                             variable     n   min   max median   iqr  mean     sd    se    ci\n##    <chr>                                <fct>    <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl>\n##  1 Central Hospital                     age        445   0    58     12    15    15.7 12.5   0.591 1.16 \n##  2 Central Hospital                     temp       450  35.2  40.4   38.8   1    38.5  0.964 0.045 0.089\n##  3 Military Hospital                    age        884   0    72     14    18    16.1 12.4   0.417 0.818\n##  4 Military Hospital                    temp       873  35.3  40.5   38.8   1    38.6  0.952 0.032 0.063\n##  5 Missing                              age       1441   0    76     13    17    16.0 12.9   0.339 0.665\n##  6 Missing                              temp      1431  35.8  40.6   38.9   1    38.6  0.97  0.026 0.05 \n##  7 Other                                age        873   0    69     13    17    16.0 12.5   0.422 0.828\n##  8 Other                                temp       862  35.7  40.8   38.8   1.1  38.5  1.01  0.034 0.067\n##  9 Port Hospital                        age       1739   0    68     14    18    16.3 12.7   0.305 0.598\n## 10 Port Hospital                        temp      1713  35.5  40.6   38.8   1.1  38.6  0.981 0.024 0.046\n## 11 St. Mark's Maternity Hospital (SMMH) age        420   0    84     12    15    15.7 12.4   0.606 1.19 \n## 12 St. Mark's Maternity Hospital (SMMH) temp       410  35.9  40.6   38.8   1.1  38.5  0.983 0.049 0.095"},{"path":"basit-istatistiksel-testler.html","id":"t-testi","chapter":"18 Basit istatistiksel testler","heading":"T-testi","text":"Sayısal ve kategorik sütunları belirtmek için bir formül sözdizimi kullanın:Veya ~ 1 kullanın ve tek örnekli bir T-testi için mu = belirtin. Bu grup tarafından da yapılabilir.Uygulanabilirse, istatistiksel testler aşağıda gösterildiği gibi grup bazında yapılabilir:","code":"\nlinelist %>% \n  t_test(age_years ~ gender)## # A tibble: 1 × 10\n##   .y.       group1 group2    n1    n2 statistic    df        p    p.adj p.adj.signif\n## * <chr>     <chr>  <chr>  <int> <int>     <dbl> <dbl>    <dbl>    <dbl> <chr>       \n## 1 age_years f      m       2807  2803     -21.3 4902. 9.89e-97 9.89e-97 ****\nlinelist %>% \n  t_test(age_years ~ 1, mu = 30)## # A tibble: 1 × 7\n##   .y.       group1 group2         n statistic    df     p\n## * <chr>     <chr>  <chr>      <int>     <dbl> <dbl> <dbl>\n## 1 age_years 1      null model  5802     -84.2  5801     0\nlinelist %>% \n  group_by(gender) %>% \n  t_test(age_years ~ 1, mu = 18)## # A tibble: 3 × 8\n##   gender .y.       group1 group2         n statistic    df         p\n## * <chr>  <chr>     <chr>  <chr>      <int>     <dbl> <dbl>     <dbl>\n## 1 f      age_years 1      null model  2807    -29.8   2806 7.52e-170\n## 2 m      age_years 1      null model  2803      5.70  2802 1.34e-  8\n## 3 <NA>   age_years 1      null model   192     -3.80   191 1.96e-  4"},{"path":"basit-istatistiksel-testler.html","id":"shapiro-wilk-testi-1","chapter":"18 Basit istatistiksel testler","heading":"Shapiro-Wilk testi","text":"Yukarıda belirtildiği gibi, örneklem büyüklüğü 3 ile 5000 arasında olmalıdır.","code":"\nlinelist %>% \n  head(500) %>%            # Vaka listesinin ilk 500 satırı, sadece örnek için\n  shapiro_test(age_years)## # A tibble: 1 × 3\n##   variable  statistic        p\n##   <chr>         <dbl>    <dbl>\n## 1 age_years     0.917 6.67e-16"},{"path":"basit-istatistiksel-testler.html","id":"wilcoxon-sıralama-toplamı-testi-1","chapter":"18 Basit istatistiksel testler","heading":"Wilcoxon sıralama toplamı testi","text":"","code":"\nlinelist %>% \n  wilcox_test(age_years ~ gender)## # A tibble: 1 × 9\n##   .y.       group1 group2    n1    n2 statistic        p    p.adj p.adj.signif\n## * <chr>     <chr>  <chr>  <int> <int>     <dbl>    <dbl>    <dbl> <chr>       \n## 1 age_years f      m       2807  2803   2829274 3.47e-74 3.47e-74 ****"},{"path":"basit-istatistiksel-testler.html","id":"kruskal-wallis-testi-1","chapter":"18 Basit istatistiksel testler","heading":"Kruskal-Wallis testi","text":"Mann-Whitney U testi olarak da bilinir.","code":"\nlinelist %>% \n  kruskal_test(age_years ~ outcome)## # A tibble: 1 × 6\n##   .y.           n statistic    df     p method        \n## * <chr>     <int>     <dbl> <int> <dbl> <chr>         \n## 1 age_years  5888    0.0457     1 0.831 Kruskal-Wallis"},{"path":"basit-istatistiksel-testler.html","id":"ki-kare-testi-1","chapter":"18 Basit istatistiksel testler","heading":"Ki-kare testi","text":"Ki-kare test fonksiyonu bir tablo kabul eder, bu nedenle önce bir çapraz tablo oluştururuz. Çapraz tablo oluşturmanın birçok yolu vardır (bkz. Tanımlayıcı tablolar) ancak burada janitor ‘den ’tabyl()’ kullanıyoruz ve ’chisq_test()’e geçmeden önce en soldaki değer etiketleri sütununu kaldırıyoruz.rstatix fonksiyonları ile daha birçok fonksiyon ve istatistiksel test çalıştırılabilir. rstatix belgelerine buradan çevrimiçi veya ?rstatix girerek inceleyebilirsiniz.","code":"\nlinelist %>% \n  tabyl(gender, outcome) %>% \n  select(-1) %>% \n  chisq_test()## # A tibble: 1 × 6\n##       n statistic     p    df method          p.signif\n## * <dbl>     <dbl> <dbl> <int> <chr>           <chr>   \n## 1  5888      3.53 0.473     4 Chi-square test ns"},{"path":"basit-istatistiksel-testler.html","id":"stats_gt","chapter":"18 Basit istatistiksel testler","heading":"18.3 gtsummary paketi","text":"Bu paketle oluşturulmuş güzel bir tabloya istatistiksel bir testin sonuçlarını eklemek istiyorsanız gtsummary kullanın (Açıklayıcı tablolar sayfasının gtsummary bölümünde açıklandığı gibi) ).‘tbl_summary’ ile karşılaştırmanın istatistiksel testlerinin yapılması,\nBir tabloya add_p fonskiyonu ve hangi testin kullanılacağını belirtir. kullanarak çoklu test için p değerlerinin düzeltilmesi mümkündür.\n‘add_q’ işlevi. Ayrıntılar için ?tbl_summary çalıştırın.","code":""},{"path":"basit-istatistiksel-testler.html","id":"ki-kare-testi-2","chapter":"18 Basit istatistiksel testler","heading":"Ki-kare testi","text":"Kategorik bir değişkenin oranlarını iki grupta karşılaştırın. Kategorik bir değişkene uygulandığında ‘add_p()’ için varsayılan istatistiksel test, süreklilik düzeltmeli ki-kare bağımsızlık testi yapmaktır, ancak herhangi bir beklenen değer sayısı 5’altındaysa, o zaman Fisher’ın kesin testi kullanılır.","code":"\nlinelist %>% \n  select(gender, outcome) %>%    # ilgilenilen değişkenleri tutma\n  tbl_summary(by = outcome) %>%  # özet tablo oluştur ve gruplama değişkenini belirle\n  add_p()                        # hangi testin gerçekleştirileceğini belirtin## 1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_explicit_na()` on `outcome` column before passing to `tbl_summary()`."},{"path":"basit-istatistiksel-testler.html","id":"t-testleri-1","chapter":"18 Basit istatistiksel testler","heading":"T testleri","text":"İki grupta sürekli bir değişken için ortalamalardaki farkı karşılaştırın.\nÖrneğin, ortalama yaşı hasta sonucuna göre karşılaştırın.","code":"\nlinelist %>% \n  select(age_years, outcome) %>%             # ilgilenilen değişkenleri tutma\n  tbl_summary(                               # özet tablo üretme\n    statistic = age_years ~ \"{mean} ({sd})\", # hangi istatistiklerin gösterileceğini belirtin\n    by = outcome) %>%                        # gruplama değişkenini belirtin\n  add_p(age_years ~ \"t.test\")                # hangi testlerin gerçekleştirileceğini belirtin## 1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_explicit_na()` on `outcome` column before passing to `tbl_summary()`."},{"path":"basit-istatistiksel-testler.html","id":"wilcoxon-sıralama-toplamı-testi-2","chapter":"18 Basit istatistiksel testler","heading":"Wilcoxon sıralama toplamı testi","text":"Sürekli bir değişkenin dağılımını iki grupta karşılaştırın. Varsayılan ayar, iki grubu karşılaştırırken Wilcoxon sıra toplamı testi ve medyanı (IQR) kullanmaktır. Ancak normal dağılmayan veriler veya çoklu grupların karşılaştırılması için Kruskal-wallis testi daha uygundur.","code":"\nlinelist %>% \n  select(age_years, outcome) %>%                       # ilgilenilen değişkenleri tutma\n  tbl_summary(                                         # özet tablo üretme\n    statistic = age_years ~ \"{median} ({p25}, {p75})\", # hangi istatistiğin gösterileceğini belirtin (bu varsayılandır, bu nedenle kaldırılabilir)\n    by = outcome) %>%                                  # gruplama değişkenini belirtin\n  add_p(age_years ~ \"wilcox.test\")                     # hangi testin gerçekleştirileceğini belirtin (bu varsayılandır, bu nedenle parantezler boş bırakılabilir)## 1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_explicit_na()` on `outcome` column before passing to `tbl_summary()`."},{"path":"basit-istatistiksel-testler.html","id":"kruskal-wallis-testi-2","chapter":"18 Basit istatistiksel testler","heading":"18.3.1 Kruskal-wallis testi","text":"Verilerin normal dağılıp dağılmadığına bakılmaksızın, sürekli bir değişkenin iki veya daha fazla gruptaki dağılımını karşılaştırın.","code":"\nlinelist %>% \n  select(age_years, outcome) %>%                       # ilgilenilen değişkenleri tutma\n  tbl_summary(                                         # özet tablo üretme\n    statistic = age_years ~ \"{median} ({p25}, {p75})\", # hangi istatistiğin gösterileceğini belirtin (bu varsayılandır, bu nedenle kaldırılabilir)\n    by = outcome) %>%                                  # gruplama değişkenini belirtin\n  add_p(age_years ~ \"kruskal.test\")                    # hangi testin gerçekleştirileceğini belirtin## 1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_explicit_na()` on `outcome` column before passing to `tbl_summary()`."},{"path":"basit-istatistiksel-testler.html","id":"korelasyonlar","chapter":"18 Basit istatistiksel testler","heading":"18.4 Korelasyonlar","text":"Sayısal değişkenler arasındaki korelasyon tidyverse kullanılarak araştırılabilir.\ncorrr paketi, Pearson Kendall kullanarak korelasyonları hesaplamanıza izin verir.\ntau veya Spearman rho, Paket bir tablo oluşturur ve ayrıca\ndeğerleri otomatik olarak çizer.","code":"\ncorrelation_tab <- linelist %>% \n  select(generation, age, ct_blood, days_onset_hosp, wt_kg, ht_cm) %>%   # ilgilenilen sayısal değişkenleri tutma\n  correlate()      # korelasyon tablosu oluşturma (varsayılan pearson kullanılarak)\n\ncorrelation_tab    # yazdır## # A tibble: 6 × 7\n##   term            generation       age ct_blood days_onset_hosp    wt_kg    ht_cm\n##   <chr>                <dbl>     <dbl>    <dbl>           <dbl>    <dbl>    <dbl>\n## 1 generation        NA       -0.0222    0.179         -0.288    -0.0302  -0.00942\n## 2 age               -0.0222  NA         0.00849       -0.000635  0.833    0.877  \n## 3 ct_blood           0.179    0.00849  NA             -0.600    -0.00636  0.0181 \n## 4 days_onset_hosp   -0.288   -0.000635 -0.600         NA         0.0153  -0.00953\n## 5 wt_kg             -0.0302   0.833    -0.00636        0.0153   NA        0.884  \n## 6 ht_cm             -0.00942  0.877     0.0181        -0.00953   0.884   NA\n## Duplike girdileri kaldırma (üstteki tablo yansıtılır) \ncorrelation_tab <- correlation_tab %>% \n  shave()\n\n## Korelasyon tablosunu gösterme \ncorrelation_tab## # A tibble: 6 × 7\n##   term            generation       age ct_blood days_onset_hosp  wt_kg ht_cm\n##   <chr>                <dbl>     <dbl>    <dbl>           <dbl>  <dbl> <dbl>\n## 1 generation        NA       NA        NA              NA       NA        NA\n## 2 age               -0.0222  NA        NA              NA       NA        NA\n## 3 ct_blood           0.179    0.00849  NA              NA       NA        NA\n## 4 days_onset_hosp   -0.288   -0.000635 -0.600          NA       NA        NA\n## 5 wt_kg             -0.0302   0.833    -0.00636         0.0153  NA        NA\n## 6 ht_cm             -0.00942  0.877     0.0181         -0.00953  0.884    NA\n## korelasyon grafikleri \nrplot(correlation_tab)"},{"path":"basit-istatistiksel-testler.html","id":"kaynaklar-11","chapter":"18 Basit istatistiksel testler","heading":"18.5 Kaynaklar","text":"Bu sayfadaki bilgilerin çoğu şu kaynaklardan ve çevrimiçi gösterimlerden uyarlanmıştır:gtsummary\ndplyr\ncorrr\nsthda correlation","code":""},{"path":"tek-değişkenli-ve-çok-değişkenli-regresyon.html","id":"tek-değişkenli-ve-çok-değişkenli-regresyon","chapter":"19 Tek değişkenli ve çok değişkenli regresyon","heading":"19 Tek değişkenli ve çok değişkenli regresyon","text":"Bu sayfa, “glm()” ve gtsummary paketi gibi base R regresyon fonksiyonlarının kullanımını gösterir.\nDeğişkenler arasındaki ilişkilere bakarak bunu yapar (örneğin, odds oranları, risk oranları ve tehlike oranları). Ayrıca regresyon çıktılarını temizlemek için broom paketindeki ‘tidy()’ gibi fonksiyonları kullanır.Tek değişkenli: ikiye iki tabloTabakalı: mantel-haenszel tahminleriÇok değişkenli: değişken seçimi, model seçimi, final tablosuForest GrafikleriCox orantılı tehlike regresyonu için [Hayatta kalma analizi] sayfasına bakınız.: Çok değişkenli terimini, birden fazla açıklayıcı değişken içeren bir regresyona atıfta bulunmak için kullanırız. Bu anlamda çok değişkenli bir model, çeşitli sonuçları olan bir regresyon olacaktır - ayrıntılar için editoryal e bakabilirsiniz ","code":""},{"path":"tek-değişkenli-ve-çok-değişkenli-regresyon.html","id":"hazırlık-10","chapter":"19 Tek değişkenli ve çok değişkenli regresyon","heading":"19.1 Hazırlık","text":"","code":""},{"path":"tek-değişkenli-ve-çok-değişkenli-regresyon.html","id":"paketleri-yükleyin-2","chapter":"19 Tek değişkenli ve çok değişkenli regresyon","heading":"Paketleri yükleyin","text":"Bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() vurgusunu yapıyoruz. base R’dan library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakın.","code":"\npacman::p_load(\n  rio,          # Dosyayı içe aktarma\n  here,         # Dosyayı konumlama\n  tidyverse,    # veri yönetimi + ggplo2 grafikleri \n  stringr,      # metin dizelerini düzenle \n  purrr,        # düzenli bir şekilde nesneler üzerinde döngü sağlama\n  gtsummary,    # özet istatistikler ve testler\n  broom,        # regresyonlardan elde edilen sonuçları toparlama\n  lmtest,       # olasılık oranı testleri\n  parameters,   # regresyonlardan elde edilen sonuçları toparlamaya alternatif\n  see          # Forest grafiklerini görselleştirmeye alternatif\n  )"},{"path":"tek-değişkenli-ve-çok-değişkenli-regresyon.html","id":"verileri-içe-aktar-4","chapter":"19 Tek değişkenli ve çok değişkenli regresyon","heading":"Verileri içe aktar","text":"Simüle edilmiş bir Ebola salgınından vakaların veri setini içe aktarıyoruz. Takip etmek isterseniz, “clean” linelist indirmek için tıklayın (.rds dosyası olarak). Verilerinizi rio paketinden import() fonksiyonuyla içe aktarın (.xlsx, .rds, .csv gibi birçok dosya türünü kabul eder - ayrıntılar için [İçe aktarma ve dışa aktarma] sayfasına bakınız).Vaka listesinin ilk 50 satırı aşağıda görüntülenir.","code":"\n# Vaka listesini içe aktarma\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"tek-değişkenli-ve-çok-değişkenli-regresyon.html","id":"temiz-veri","chapter":"19 Tek değişkenli ve çok değişkenli regresyon","heading":"Temiz veri","text":"","code":""},{"path":"tek-değişkenli-ve-çok-değişkenli-regresyon.html","id":"açıklayıcı-değişkenleri-saklayın","chapter":"19 Tek değişkenli ve çok değişkenli regresyon","heading":"Açıklayıcı değişkenleri saklayın","text":"Açıklayıcı sütunların adlarını bir karakter vektörü olarak saklıyoruz. Buna daha sonra atıfta bulunulacaktır.","code":"\n## ilgilenilen değişkenleri tanımlama \nexplanatory_vars <- c(\"gender\", \"fever\", \"chills\", \"cough\", \"aches\", \"vomit\")"},{"path":"tek-değişkenli-ve-çok-değişkenli-regresyon.html","id":"lere-ve-0lara-dönüştür","chapter":"19 Tek değişkenli ve çok değişkenli regresyon","heading":"1’lere ve 0’lara dönüştür","text":"Aşağıda, lojistik regresyon modellerinin beklentileriyle işbirliği yapmak için “evet”/“hayır”, “e”/“k” ve “ölü”/“canlı” olan açıklayıcı sütunları 1/0’çeviriyoruz. Bunu verimli bir şekilde yapmak için, aynı anda birden çok sütunu dönüştürmek için dplyr’den ‘across()’ kullanıldı. sütuna uyguladığımız fonksiyon, belirtilen değerleri 1’lere ve 0’lara dönüştürmek için mantık uygulayan ‘case_while()’ (ayrıca dplyr) fonksiyonudur. Temizleme verileri ve temel işlevler sayfasındaki ‘across()’ ve ‘case_while()’ ile ilgili bölümlere bakınızNot: “.” aşağıdaki, ‘cross()’ tarafından işlenmekte olan sütunu temsil eder.","code":"\n## ikili değişkenleri 0/1'e dönüştür\nlinelist <- linelist %>%  \n  mutate(across(                                      \n    .cols = all_of(c(explanatory_vars, \"outcome\")),  ## listelenen her sütun ve \"sonuç\" için\n    .fns = ~case_when(                              \n      . %in% c(\"m\", \"yes\", \"Death\")   ~ 1,           ## erkek, evet ve ölü'yü 1 olarak yeniden kodla\n      . %in% c(\"f\", \"no\",  \"Recover\") ~ 0,           ## kadın, hayır ve iyileşme'yi sıfır olarak kodla\n      TRUE                            ~ NA_real_)    ## geri kalanını kayıp veri olarak kaydet\n    )\n  )"},{"path":"tek-değişkenli-ve-çok-değişkenli-regresyon.html","id":"eksik-değerlere-sahip-satırları-bırakın","chapter":"19 Tek değişkenli ve çok değişkenli regresyon","heading":"Eksik değerlere sahip satırları bırakın","text":"Eksik değerleri olan satırları bırakmak için, tidyr drop_na() fonksiyonunu kullanabilirsiniz. Ancak, bunu yalnızca ilgilenilen sütunlarda değerleri eksik olan satırlar için yapmak istiyoruz.Yapmamız gereken ilk şey, “explanatory_vars” vektörümüzün “age” sütununu içerdiğinden emin olmaktır (“age”, yalnızca ikili değişkenler için olan önceki “case_while()” işleminde bir hata üretebilirdi). Ardından, “outcome” sütununda veya “explanatory_vars” sütunlarından herhangi birinde eksik değerleri olan satırları kaldırmak için “linelist”“drop_na()”ya yönlendiririz.Kodu çalıştırmadan önce, ‘linelist’teki satır sayısı ’nrow(linelist)’ şeklindedir.‘linelist’te’ kalan satır sayısı ‘nrow(linelist)’ şeklindedir.","code":"\n## açıklayıcı değişkenlere age_category ekleyin \nexplanatory_vars <- c(explanatory_vars, \"age_cat\")\n\n## ilgilenilen değişkenler için eksik bilgi içeren satırları bırak \nlinelist <- linelist %>% \n  drop_na(any_of(c(\"outcome\", explanatory_vars)))"},{"path":"tek-değişkenli-ve-çok-değişkenli-regresyon.html","id":"tek-değişkenli","chapter":"19 Tek değişkenli ve çok değişkenli regresyon","heading":"19.2 Tek değişkenli","text":"Tıpkı Açıklayıcı tablolar sayfasında olduğu gibi, kullandığınız senaryo hangi R paketini kullanacağınızı belirleyecektir. Tek değişkenli analiz yapmak için iki seçenek sunuyoruz:Sonuçları konsola hızlı bir şekilde yazdırmak için base R’da bulunan fonksiyonları kullanın. Çıktıları düzenlemek için broom paketini kullanın.Yayına hazır çıktıları modellemek ve almak için gtsummary paketini kullanın","code":""},{"path":"tek-değişkenli-ve-çok-değişkenli-regresyon.html","id":"base-r-1","chapter":"19 Tek değişkenli ve çok değişkenli regresyon","heading":"base R","text":"","code":""},{"path":"tek-değişkenli-ve-çok-değişkenli-regresyon.html","id":"doğrusal-lineer-regresyon","chapter":"19 Tek değişkenli ve çok değişkenli regresyon","heading":"Doğrusal (Lineer) regresyon","text":"base R fonskiyonu ‘lm()’, sayısal yanıt ile doğrusal bir ilişkiye sahip olduğu varsayılan açıklayıcı değişkenler arasındaki ilişkiyi değerlendirerek doğrusal regresyon gerçekleştirir.Denklemi, yanıt ve açıklayıcı sütun adları yaklaşık bir “~” ile ayrılmış şekilde bir formül olarak sağlayın. Ayrıca, veri kümesini data = olarak belirtin. Model sonuçlarını daha sonra kullanmak üzere bir R nesnesi olarak tanımlayın.Daha sonra katsayıları (Tahminler), P-değerini, artıkları ve diğer ölçüleri görmek için model sonuçlarında “summary()” komutunu çalıştırabilirsiniz.Alternatif olarak, broom paketindeki tidy() fonksiyonunu kullanabilirsiniz. Sonuçlar bir tabloya dönüştürülür. Sonuçlarda yıl yaş arttıkça boy da 3.5 cm artıyor ve bu istatistiksel olarak anlamlıdır.Daha sonra bu regresyonu bir ggplot’eklemek için de kullanabilirsiniz, bunu yapmak için önce broomdan ‘augment()’ fonksiyonunu kullanarak gözlemlenen veri ve uygun çizgi için noktaları tek bir veri çerçevesine çekeriz.Ayrıca, “geom_smooth()” fonksiyonunu kullanarak ggplot’doğrudan basit bir doğrusal regresyon eklemek de mümkündür.Daha ayrıntılı öğreticiler için bu bölümün sonundaki Kaynak bölümüne bakabilirsiniz.","code":"\nlm_results <- lm(ht_cm ~ age, data = linelist)\nsummary(lm_results)## \n## Call:\n## lm(formula = ht_cm ~ age, data = linelist)\n## \n## Residuals:\n##      Min       1Q   Median       3Q      Max \n## -128.579  -15.854    1.177   15.887  175.483 \n## \n## Coefficients:\n##             Estimate Std. Error t value Pr(>|t|)    \n## (Intercept)  69.9051     0.5979   116.9   <2e-16 ***\n## age           3.4354     0.0293   117.2   <2e-16 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Residual standard error: 23.75 on 4165 degrees of freedom\n## Multiple R-squared:  0.7675, Adjusted R-squared:  0.7674 \n## F-statistic: 1.375e+04 on 1 and 4165 DF,  p-value: < 2.2e-16\ntidy(lm_results)## # A tibble: 2 × 5\n##   term        estimate std.error statistic p.value\n##   <chr>          <dbl>     <dbl>     <dbl>   <dbl>\n## 1 (Intercept)    69.9     0.598       117.       0\n## 2 age             3.44    0.0293      117.       0\n## regresyon noktalarını ve gözlemlenen verileri tek bir veri kümesine çekin\npoints <- augment(lm_results)\n\n## x ekseni olarak yaşı kullanarak verileri grafikleştirin\nggplot(points, aes(x = age)) + \n  ## boy için noktalar koyun \n  geom_point(aes(y = ht_cm)) + \n  ## regresyon çizginizi çizin \n  geom_line(aes(y = .fitted), colour = \"red\")\n## verinizi bir grafiğe ekleyin \n ggplot(linelist, aes(x = age, y = ht_cm)) + \n  ## noktaları gösterin\n  geom_point() + \n  ## lineer regresyon ekleyin \n  geom_smooth(method = \"lm\", se = FALSE)## `geom_smooth()` using formula = 'y ~ x'"},{"path":"tek-değişkenli-ve-çok-değişkenli-regresyon.html","id":"lojistik-regresyon","chapter":"19 Tek değişkenli ve çok değişkenli regresyon","heading":"Lojistik regresyon","text":"stats paketindeki (base R’ın bir parçası) ‘glm()’ fonksiyonu, Genelleştirilmiş Doğrusal Modellere (GLM) uymak için kullanılır.glm(), tek değişkenli ve çok değişkenli lojistik regresyon için kullanılabilir (örneğin, Odds Ratio’ları elde etmek için). İşte temel parçalar:formül = Model glm() için bir denklem olarak sağlanır, tilde ~ nin sağında çıktısı, solunda açıklayıcı değişkenler bulunur.family = Bu, çalıştırılacak modelin türünü belirler. Lojistik regresyon için family= \"binom\" kullanın, poisson için family = \"poisson\" kullanın. Diğer örnekler aşağıdaki tablodadır.data = Veri çerçevenizi belirtinGerekirse, bağlantı işlevini family = familytype(link = \"linkfunction\")) sözdizimi aracılığıyla da belirtebilirsiniz. Diğer aileler ve ‘ağırlıklar =’ ve ‘alt küme =’ (‘?glm’) gibi isteğe bağlı bağımsız değişkenler hakkındaki belgelerde daha fazlasını okuyabilirsiniz.glm() çalıştırıldığında, sonuçların adlandırılmış bir R nesnesi olarak kaydedilmesi en yaygın yöntemdir. Ardından, aşağıda gösterildiği gibi summary() kullanarak sonuçları konsolunuza yazdırabilir veya sonuçlar üzerinde diğer işlemleri gerçekleştirebilirsiniz ( örneğin; üstünü almak gibi).Negatif bir binom regresyonu çalıştırmanız gerekiyorsa MASS paketini kullanabilirsiniz; “glm.nb()”, “glm()” ile aynı sözdizimini kullanır.\nFarklı regresyonların gözden geçirilmesi için UCLA istatistik sayfasına bakabilirsiniz.","code":"\n# glm() için değişkenler\nglm(formula, family, data, weights, subset, ...)"},{"path":"tek-değişkenli-ve-çok-değişkenli-regresyon.html","id":"tek-değişkenli-glm","chapter":"19 Tek değişkenli ve çok değişkenli regresyon","heading":"Tek değişkenli glm()","text":"Bu örnekte, farklı yaş kategorileri ile ölümün sonucu arasındaki ilişkiyi değerlendiriyoruz (Hazırlık bölümünde 1 olarak kodlanmıştır). Aşağıda, “age_cat” tarafından “sonucun” tek değişkenli bir modeli verilmiştir. Model çıktısını model olarak kaydedip ardından summary() ile konsola yazdırıyoruz. Sağlanan tahminlerin log oranları olduğunu ve temel seviyenin “age_cat” (“0-4”) birinci faktör seviyesi olduğunu unutmayınız.Belirli bir değişkenin temel seviyesini değiştirmek için, sütunun Faktör sınıfı olduğundan emin olun ve istenen seviyeyi fct_relevel() ile ilk konuma taşıyın (Faktörler sayfasındaki sayfaya bakabilirsiniz). Örneğin, aşağıda ‘age_cat’ sütununu alıyoruz ve değiştirilmiş veri çerçevesini ‘glm()’ içine aktarmadan önce temel olarak “20-29” ayarlıyoruz.","code":"\nmodel <- glm(outcome ~ age_cat, family = \"binomial\", data = linelist)\nsummary(model)## \n## Call:\n## glm(formula = outcome ~ age_cat, family = \"binomial\", data = linelist)\n## \n## Deviance Residuals: \n##    Min      1Q  Median      3Q     Max  \n## -1.339  -1.278   1.024   1.080   1.354  \n## \n## Coefficients:\n##               Estimate Std. Error z value Pr(>|z|)   \n## (Intercept)   0.233738   0.072805   3.210  0.00133 **\n## age_cat5-9   -0.062898   0.101733  -0.618  0.53640   \n## age_cat10-14  0.138204   0.107186   1.289  0.19726   \n## age_cat15-19 -0.005565   0.113343  -0.049  0.96084   \n## age_cat20-29  0.027511   0.102133   0.269  0.78765   \n## age_cat30-49  0.063764   0.113771   0.560  0.57517   \n## age_cat50-69 -0.387889   0.259240  -1.496  0.13459   \n## age_cat70+   -0.639203   0.915770  -0.698  0.48518   \n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## (Dispersion parameter for binomial family taken to be 1)\n## \n##     Null deviance: 5712.4  on 4166  degrees of freedom\n## Residual deviance: 5705.1  on 4159  degrees of freedom\n## AIC: 5721.1\n## \n## Number of Fisher Scoring iterations: 4\nlinelist %>% \n  mutate(age_cat = fct_relevel(age_cat, \"20-29\", after = 0)) %>% \n  glm(formula = outcome ~ age_cat, family = \"binomial\") %>% \n  summary()## \n## Call:\n## glm(formula = outcome ~ age_cat, family = \"binomial\", data = .)\n## \n## Deviance Residuals: \n##    Min      1Q  Median      3Q     Max  \n## -1.339  -1.278   1.024   1.080   1.354  \n## \n## Coefficients:\n##              Estimate Std. Error z value Pr(>|z|)    \n## (Intercept)   0.26125    0.07163   3.647 0.000265 ***\n## age_cat0-4   -0.02751    0.10213  -0.269 0.787652    \n## age_cat5-9   -0.09041    0.10090  -0.896 0.370220    \n## age_cat10-14  0.11069    0.10639   1.040 0.298133    \n## age_cat15-19 -0.03308    0.11259  -0.294 0.768934    \n## age_cat30-49  0.03625    0.11302   0.321 0.748390    \n## age_cat50-69 -0.41540    0.25891  -1.604 0.108625    \n## age_cat70+   -0.66671    0.91568  -0.728 0.466546    \n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## (Dispersion parameter for binomial family taken to be 1)\n## \n##     Null deviance: 5712.4  on 4166  degrees of freedom\n## Residual deviance: 5705.1  on 4159  degrees of freedom\n## AIC: 5721.1\n## \n## Number of Fisher Scoring iterations: 4"},{"path":"tek-değişkenli-ve-çok-değişkenli-regresyon.html","id":"sonuçları-yazdırmak","chapter":"19 Tek değişkenli ve çok değişkenli regresyon","heading":"Sonuçları yazdırmak","text":"Çoğu kullanım için, yukarıdaki çıktılarda birkaç değişiklik yapılmalıdır. broom paketindeki ‘tidy()’ fonksiyonu, model sonuçlarını sunulabilir kılmak için uygundur.Burada model çıktılarının bir sayım tablosuyla nasıl birleştirileceğini gösteriyoruz.Modeli “tidy()” öğesine geçirerek ve “üssel = TRUE” ve “conf.int = TRUE” ayarını yaparak üslü günlük odds oranı tahminlerini ve güven aralıklarını(GA) alın.Çıktı alınan tibble ‘model’ aşağıdadır:Bu model sonuçlarını bir sayım tablosuyla birleştirin. Aşağıda, [Açıklayıcı tablolar] sayfasında anlatıldığı gibi, janitor’dan ‘tabyl()’ fonksiyonuyla bir sayımlar çapraz tablosunu oluşturuyoruz.Bu “counts_table” veri çerçevesi şöyle görünür:Şimdi ‘counts_table’ ve ‘model’ sonuçlarını ‘bind_cols()’ (dplyr) ile yatay olarak birbirine bağlayabiliriz. bind_cols() ile iki veri çerçevesindeki satırların mükemmel şekilde hizalanması gerektiğini unutmayın. Bu kodda, bir tünel zinciri içinde bağlı olduğumuz için, tünelli nesneyi “counts_table” olarak temsil etmek için “.” kullanırız ve onu “model”e bağlarız. İşlemi bitirmek için, istenen sütunları ve sıralarını seçmek için ‘select()’ kullanırız ve son olarak 2 ondalık basamak belirtmek için tüm sayısal sütunlara base R ‘round()’ fonksiyonunu uygularız.Birleştirilmiş veri çerçevesinin nasıl göründüğü, flextable fonksiyonuyla güzel bir görüntü olarak yazdırılmıştır. [Tablolar sunum], bu tür tabloların flextable ile nasıl özelleştirileceğini veya knitr veya GT gibi çok sayıda başka paketin nasıl kullanılacağını açıklar.","code":"\nmodel <- glm(outcome ~ age_cat, family = \"binomial\", data = linelist) %>% \n  tidy(exponentiate = TRUE, conf.int = TRUE) %>%        # GA'larını üret ve üstelleştir\n  mutate(across(where(is.numeric), round, digits = 2))  # tüm sayısal sütunları yuvarla\ncounts_table <- linelist %>% \n  janitor::tabyl(age_cat, outcome)\ncombined <- counts_table %>%           # sayım tablosuyla başla\n  bind_cols(., model) %>%              # regresyonun çıktıları ile birleştir \n  select(term, 2:3, estimate,          # sütunları seç ve yeniden düzenle\n         conf.low, conf.high, p.value) %>% \n  mutate(across(where(is.numeric), round, digits = 2)) ## 2 basamak şeklinde yuvarla\ncombined <- combined %>% \n  flextable::qflextable()"},{"path":"tek-değişkenli-ve-çok-değişkenli-regresyon.html","id":"birden-çok-tek-değişkenli-modeli-döngüye-alma","chapter":"19 Tek değişkenli ve çok değişkenli regresyon","heading":"Birden çok tek değişkenli modeli döngüye alma","text":"Aşağıda daha basit bir yaklaşım için glm() ve tidy() kullanan bir yöntem sunuyoruz, gtsummary bölümüne bakın.Tek değişkenli olasılık oranları (yani birbirini kontrol etmeyen) üretmek için modelleri çeşitli maruziyet değişkenleri üzerinde çalıştırmak için aşağıdaki yaklaşımı kullanabilirsiniz. Tek değişkenli formüller oluşturmak için stringr’den str_c()’ kullanır (bkz. )ve son olarak **tidyr**'denbind_rows()ile birlikte tüm model çıktılarını daraltır. Bu yaklaşım, yineleme için **purrr** paketindenmap()` kullanır - bu araç hakkında daha fazla bilgi için Yineleme, döngüler ve listeler sayfasına bakın.Açıklayıcı değişkenlerin sütun adlarından oluşan bir vektör oluşturun. Bunu zaten bu sayfanın Hazırlık bölümünden ‘açıklayıcı_değişkenler’ olarak aldık.Açıklayıcı değişkenlerin sütun adlarından oluşan bir vektör oluşturun. Bunu zaten bu sayfanın Hazırlık bölümünden ‘açıklayıcı_değişkenler’ olarak aldık.Solda “sonuç” ve sağda “açıklayıcı_değişkenler”den bir sütun adı ile birden çok dize formülü oluşturmak için “str_c()” kullanın. “.” noktası, “açıklayıcı_değişkenler”deki sütun adının yerini alır.Solda “sonuç” ve sağda “açıklayıcı_değişkenler”den bir sütun adı ile birden çok dize formülü oluşturmak için “str_c()” kullanın. “.” noktası, “açıklayıcı_değişkenler”deki sütun adının yerini alır.Bu dizi formüllerini ‘map()’ öğesine iletin ve girişe uygulanacak fonksiyon olarak ‘~glm()’ öğesini ayarlayın. “glm()” içinde, regresyon formülünü “.formula(.x)” olarak ayarlayın, burada “.x”, yukarıdaki adımda tanımlanan dizi formülüyle değiştirilecektir. map(), biri için gerilemeler çalıştırarak, dizi formüllerinin biri üzerinde döngü yapacaktır.Bu dizi formüllerini ‘map()’ öğesine iletin ve girişe uygulanacak fonksiyon olarak ‘~glm()’ öğesini ayarlayın. “glm()” içinde, regresyon formülünü “.formula(.x)” olarak ayarlayın, burada “.x”, yukarıdaki adımda tanımlanan dizi formülüyle değiştirilecektir. map(), biri için gerilemeler çalıştırarak, dizi formüllerinin biri üzerinde döngü yapacaktır.Bu ilk ‘map()’ çıktıları, regresyon çıktılarına ‘tidy()’ uygulayan ikinci bir ‘map()’ komutuna iletilir.Bu ilk ‘map()’ çıktıları, regresyon çıktılarına ‘tidy()’ uygulayan ikinci bir ‘map()’ komutuna iletilir.Son olarak, ikinci ‘map()’ çıktısı (düzenlenmiş veri çerçevelerinin bir listesi) ‘bind_rows()’ ile yoğunlaştırılır, bu da tüm tek değişkenli sonuçları içeren bir veri çerçevesiyle sonuçlanır.Son olarak, ikinci ‘map()’ çıktısı (düzenlenmiş veri çerçevelerinin bir listesi) ‘bind_rows()’ ile yoğunlaştırılır, bu da tüm tek değişkenli sonuçları içeren bir veri çerçevesiyle sonuçlanır.Bu sefer, son nesne ‘modelleri’ daha uzundur çünkü artık birkaç tek değişkenli regresyonun birleşik sonuçlarını temsil etmektedir. Tüm “model” satırlarını görmek için tıklayın.Daha önce olduğu gibi, açıklayıcı değişken için ‘vaka listesi’nden bir sayım tablosu oluşturabilir, onu ’modellere’ bağlayabilir ve güzel bir tablo yapabiliriz. Değişkenlerle başlıyoruz ve onları map() ile yineliyoruz. dplyr fonksiyonlarıyla bir sayım tablosu oluşturmayı içeren kullanıcı tanımlı bir fonksiyonu yineliyoruz. Daha sonra sonuçlar birleştirilir ve ‘modeller’ model sonuçlarıyla birleştirilir.Aşağıda veri çerçevesinin neye benzediği görülmektedir. Bu tablonun güzel HTML çıktısına nasıl dönüştürüleceği hakkında fikirler için Tablolar hakkındaki sayfaya bakın (ör. flextable ile).","code":"\nexplanatory_vars %>% str_c(\"outcome ~ \", .)## [1] \"outcome ~ gender\"  \"outcome ~ fever\"   \"outcome ~ chills\"  \"outcome ~ cough\"   \"outcome ~ aches\"  \n## [6] \"outcome ~ vomit\"   \"outcome ~ age_cat\"\nmodels <- explanatory_vars %>%       # ilgilenilen değişkenlerle başla\n  str_c(\"outcome ~ \", .) %>%         # her değişkeni formüle birleştir (\"outcome ~ variable of interest\")\n  \n  # her tek değişkenli formülü yineleyin\n  map(                               \n    .f = ~glm(                       # formülleri birer birer glm() öğesine iletin\n      formula = as.formula(.x),      # glm() içinde, dizİ formülü .x'tir\n      family = \"binomial\",           # glm (logistic) tipini belirle\n      data = linelist)) %>%          # veri kümesi\n  \n  # glm regresyon çıktılarının her birini düzenleyin\n  map(\n    .f = ~tidy(\n      .x, \n      exponentiate = TRUE,           # üstelleştirme \n      conf.int = TRUE)) %>%          # güven aralığına dönme\n  \n  # regresyon çıktılarının listesini bir veri çerçevesine daralt\n  bind_rows() %>% \n  \n  # tüm sayısal sütunları yuvarla\n  mutate(across(where(is.numeric), round, digits = 2))\n## Her açıklayıcı değişken için\nuniv_tab_base <- explanatory_vars %>% \n  map(.f = \n    ~{linelist %>%                ## vaka listesiyle başla\n        group_by(outcome) %>%     ## veri setini çıktıya göre gruplandırma\n        count(.data[[.x]]) %>%    ## ilgilenilen değişken için sayılar üret\n        pivot_wider(              ## geniş formata yayılma (çapraz tablodaki gibi)\n          names_from = outcome,\n          values_from = n) %>% \n        drop_na(.data[[.x]]) %>%         ## eksik olan satırları bırak\n        rename(\"variable\" = .x) %>%      ## ilgili sütununun değişkenini \"değişken\" olarak değiştir\n        mutate(variable = as.character(variable))} ## karaktere dönüştürün, aksi takdirde ikili olmayan (kategorik) değişkenler faktör olarak ortaya çıkar ve birleştirilemez\n      ) %>% \n  \n  ## sayım çıktılarının listesini bir veri çerçevesine daralt\n  bind_rows() %>% \n  \n  ## regresyon çıktıları ile birleştirme \n  bind_cols(., models) %>% \n  \n  ## yalnızca ilgilenilen sütunları tutma \n  select(term, 2:3, estimate, conf.low, conf.high, p.value) %>% \n  \n  ## ondalık basamakları yuvarla\n  mutate(across(where(is.numeric), round, digits = 2))"},{"path":"tek-değişkenli-ve-çok-değişkenli-regresyon.html","id":"reg_gt_uni","chapter":"19 Tek değişkenli ve çok değişkenli regresyon","heading":"gtsummary paketi","text":"Aşağıda gtsummary paketinden tbl_uvregression() kullanımını sunuyoruz. Tıpkı Tanımlayıcı tablolar sayfasındaki gibi, gtsummary fonksiyonları istatistikleri çalıştırmada ve profesyonel görünümlü çıktılar üretmede iyi bir iş çıkarır. Bu fonksiyon, tek değişkenli regresyon sonuçlarının bir tablosunu üretir.‘Vaka listesi’nden (açıklayıcı değişkenler ve sonuç değişkeni) yalnızca gerekli sütunları seçiyoruz ve bunları ’tbl_uvregression()’ içine aktarıyoruz. Veri Hazırlama bölümünde ‘açıklayıcı_değişkenler’ olarak tanımladığımız sütunların biri üzerinde (cinsiyet, ateş, titreme, öksürük, ağrı, kusmuk ve yaş_kedi) tek değişkenli regresyon uygulayacağız.Fonksiyonun kendi içinde, method = glm (tırnak işaretleri olmadan), y = sonuç sütununu (outcome) sağlarız, family= binomial yoluyla, lojistik regresyonu çalıştırmak istediğimizi method.args = ile belirtiriz. Ve ona sonuçları üslü hale getirmesini söylüyoruz.Çıktı HTML’dir ve sayıları içermektedir.Bu tablo çıktısında, metin etiketlerini ayarlamak, satırları p değerlerine göre kalınlaştırmak vb. gibi birçok değişiklik yapabilirsiniz. Öğreticilere buradan ve başka çevrimiçi yerlerden bakabilirsiniz.","code":"\nuniv_tab <- linelist %>% \n  dplyr::select(explanatory_vars, outcome) %>% ## ilgilenilen değişkenleri seç\n\n  tbl_uvregression(                         ## tek değişkenli tablo üret\n    method = glm,                           ## çalıştırmak istediğiniz regresyonu tanımlayın (genelleştirilmiş doğrusal model)\n    y = outcome,                            ## sonuç değişkenini tanımlayın\n    method.args = list(family = binomial),  ## ne tür bir glm çalıştırmak istediğini tanımla (lojistik)\n    exponentiate = TRUE                     ## odds oranlarını üretmek için üstelleştir (logaritmik oranlar yerine)\n  )\n\n## tek değişkenli sonuç tablosunu göster \nuniv_tab"},{"path":"tek-değişkenli-ve-çok-değişkenli-regresyon.html","id":"tabakalı","chapter":"19 Tek değişkenli ve çok değişkenli regresyon","heading":"19.3 Tabakalı","text":"Tabakalı analiz şu anda gtsummary üzerinde çalışıyor,\nbu sayfa zamanı gelince güncellenecektir.","code":""},{"path":"tek-değişkenli-ve-çok-değişkenli-regresyon.html","id":"çok-değişkenli","chapter":"19 Tek değişkenli ve çok değişkenli regresyon","heading":"19.4 Çok Değişkenli","text":"Çok değişkenli analiz için yine iki yaklaşım sunuyoruz:glm() ve tidy()gtsummary paketiİş akışı biri için benzerdir ve yalnızca son tabloyu bir araya getirmenin son adımı farklıdır.","code":""},{"path":"tek-değişkenli-ve-çok-değişkenli-regresyon.html","id":"çok-değişkenli-yürütme","chapter":"19 Tek değişkenli ve çok değişkenli regresyon","heading":"Çok değişkenli yürütme","text":"Burada glm() kullanıyoruz ama denklemin sağ tarafına artı sembolleriyle (+) ayırarak daha fazla değişken ekliyoruz.Modeli tüm açıklayıcı değişkenlerimizle çalıştırmak için şunu çalıştırırız:İki değişken ve aralarında bir etkileşim eklemek istiyorsanız, bunları “+” yerine yıldız işareti “*” ile ayırabilirsiniz. Yalnızca etkileşimi belirtiyorsanız, bunları iki nokta üst üste : ile ayırın. Örneğin:İsteğe bağlı olarak, bu kodu, önceden tanımlanmış sütun adları vektöründen yararlanmak ve str_c() kullanarak yukarıdaki komutu yeniden oluşturmak için kullanabilirsiniz. Bu, açıklayıcı değişken adlarınız değişiyorsa veya hepsini yeniden yazmak istemiyorsanız yararlı olabilir.","code":"\nmv_reg <- glm(outcome ~ gender + fever + chills + cough + aches + vomit + age_cat, family = \"binomial\", data = linelist)\n\nsummary(mv_reg)## \n## Call:\n## glm(formula = outcome ~ gender + fever + chills + cough + aches + \n##     vomit + age_cat, family = \"binomial\", data = linelist)\n## \n## Deviance Residuals: \n##    Min      1Q  Median      3Q     Max  \n## -1.383  -1.279   1.029   1.078   1.346  \n## \n## Coefficients:\n##               Estimate Std. Error z value Pr(>|z|)\n## (Intercept)   0.069054   0.131726   0.524    0.600\n## gender        0.002448   0.065133   0.038    0.970\n## fever         0.004309   0.080522   0.054    0.957\n## chills        0.034112   0.078924   0.432    0.666\n## cough         0.138584   0.089909   1.541    0.123\n## aches        -0.070705   0.104078  -0.679    0.497\n## vomit         0.086098   0.062618   1.375    0.169\n## age_cat5-9   -0.063562   0.101851  -0.624    0.533\n## age_cat10-14  0.136372   0.107275   1.271    0.204\n## age_cat15-19 -0.011074   0.113640  -0.097    0.922\n## age_cat20-29  0.026552   0.102780   0.258    0.796\n## age_cat30-49  0.059569   0.116402   0.512    0.609\n## age_cat50-69 -0.388964   0.262384  -1.482    0.138\n## age_cat70+   -0.647443   0.917375  -0.706    0.480\n## \n## (Dispersion parameter for binomial family taken to be 1)\n## \n##     Null deviance: 5712.4  on 4166  degrees of freedom\n## Residual deviance: 5700.2  on 4153  degrees of freedom\n## AIC: 5728.2\n## \n## Number of Fisher Scoring iterations: 4\nglm(outcome ~ gender + age_cat * fever, family = \"binomial\", data = linelist)\n##  ilgilenilen tüm değişkenlerle bir regresyon çalıştırın \nmv_reg <- explanatory_vars %>%  ## açıklayıcı sütun adlarının vektörüyle başlayın\n  str_c(collapse = \"+\") %>%     ## bir artı ile ayrılmış ilgilenilen değişkenlerin tüm adlarını birleştirin\n  str_c(\"outcome ~ \", .) %>%    ## formül stilinde sonuç ile ilgilenilen değişkenlerin adlarını birleştirin\n  glm(family = \"binomial\",      ## glm tipini lojistik olarak tanımlayın\n      data = linelist)          ## veri setinizi tanımlayın"},{"path":"tek-değişkenli-ve-çok-değişkenli-regresyon.html","id":"modeli-oluşturma","chapter":"19 Tek değişkenli ve çok değişkenli regresyon","heading":"Modeli oluşturma","text":"Belirli açıklayıcı değişkenleri içeren çeşitli modelleri kaydederek modelinizi adım adım oluşturabilirsiniz. Bu modelleri, aşağıdaki gibi lmtest paketinden lrtest() kullanarak olasılık-oran testleri ile karşılaştırabilirsiniz:: base anova(model1, model2, test = \"Chisq) kullanılması aynı sonuçları verir Diğer bir seçenek ise model nesnesini alıp stats paketinden step() fonksiyonunu uygulamaktır. Modeli oluştururken hangi değişken seçim yönünü kullanmak istediğinizi belirtin.Netlik için R oturumunuzda bilimsel gösterimi de kapatabilirsiniz:Tek değişkenli analiz bölümünde açıklandığı gibi, log oranlarını ve GA’nı üslendirmek için model çıktısını ‘tidy()’ öğesine iletin. Son olarak, tüm sayısal sütunları iki ondalık basamağa yuvarlarız. Tüm satırları görmek için kaydırın.Ortaya çıkan veri çerçevesi şöyle görünür:","code":"\nmodel1 <- glm(outcome ~ age_cat, family = \"binomial\", data = linelist)\nmodel2 <- glm(outcome ~ age_cat + gender, family = \"binomial\", data = linelist)\n\nlmtest::lrtest(model1, model2)## Likelihood ratio test\n## \n## Model 1: outcome ~ age_cat\n## Model 2: outcome ~ age_cat + gender\n##   #Df  LogLik Df  Chisq Pr(>Chisq)\n## 1   8 -2852.6                     \n## 2   9 -2852.6  1 0.0002     0.9883\n## AIC'ye (Akaike information criterion) dayalı ileri seçimi kullanarak bir model seçin\n## yönü ayarlayarak \"geri\" veya \"her ikisini\" de yapabilirsiniz.\nfinal_mv_reg <- mv_reg %>%\n  step(direction = \"forward\", trace = FALSE)\noptions(scipen=999)\nmv_tab_base <- final_mv_reg %>% \n  broom::tidy(exponentiate = TRUE, conf.int = TRUE) %>%  ## düzenli veri çerçevesinin tahminlerini elde edin \n  mutate(across(where(is.numeric), round, digits = 2))          ## yuvarlama "},{"path":"tek-değişkenli-ve-çok-değişkenli-regresyon.html","id":"tek-değişkenli-ve-çok-değişkenli-birleştirme","chapter":"19 Tek değişkenli ve çok değişkenli regresyon","heading":"Tek değişkenli ve çok değişkenli birleştirme","text":"","code":""},{"path":"tek-değişkenli-ve-çok-değişkenli-regresyon.html","id":"gtsummary-ile-birleştirme","chapter":"19 Tek değişkenli ve çok değişkenli regresyon","heading":"gtsummary ile birleştirme","text":"gtsummary paketi, tbl_regression() fonksiyonunu sağlar.\nBu paket regresyondan çıktıları alan (bu durumda glm()) ve güzel bir sonuç üreten özet tablodur.Tabloyu görelim:gtsummary tarafından üretilen birkaç farklı çıktı tablosunu tbl_merge() fonksiyonuyla da birleştirebilirsiniz. Şimdi çok değişkenli sonuçları, oluşturduğumuz gtsummary tek değişkenli sonuçlarla birleştiriyoruz yukarıda:","code":"\n## son regresyonun sonuç tablosunu göster\nmv_tab <- tbl_regression(final_mv_reg, exponentiate = TRUE)\nmv_tab\n## tek değişkenli sonuçlarla birleştir\ntbl_merge(\n  tbls = list(univ_tab, mv_tab),                          # birleştir\n  tab_spanner = c(\"**Univariate**\", \"**Multivariable**\")) # başlık adlarını ayarla"},{"path":"tek-değişkenli-ve-çok-değişkenli-regresyon.html","id":"dplyr-ile-birleştirme","chapter":"19 Tek değişkenli ve çok değişkenli regresyon","heading":"dplyr ile birleştirme","text":"glm()/tidy() tek değişkenli ve çok değişkenli çıktıları birleştirmenin alternatif bir yolu, dplyr birleştirme fonksiyonlarıdır.Daha önceki tek değişkenli sonuçları (sayıları içeren ‘univ_tab_base’) derlenmiş çok değişkenli sonuçlar ‘mv_tab_base’ ile birleştirebilirsinizYalnızca istediğimiz sütunları tutmak, sıralarını belirlemek ve yeniden adlandırmak için select() kullanabilirsinizDouble sınıfı olan tüm sütunlarda iki ondalık basamakla round() kullanabilirsiniz","code":"\n## tek ve çok değişkenli tabloları birleştir\nleft_join(univ_tab_base, mv_tab_base, by = \"term\") %>% \n  ## sütunları seç ve yeniden isimlendir\n  select( # yeni isim =  eski isim\n    \"characteristic\" = term, \n    \"recovered\"      = \"0\", \n    \"dead\"           = \"1\", \n    \"univ_or\"        = estimate.x, \n    \"univ_ci_low\"    = conf.low.x, \n    \"univ_ci_high\"   = conf.high.x,\n    \"univ_pval\"      = p.value.x, \n    \"mv_or\"          = estimate.y, \n    \"mvv_ci_low\"     = conf.low.y, \n    \"mv_ci_high\"     = conf.high.y,\n    \"mv_pval\"        = p.value.y \n  ) %>% \n  mutate(across(where(is.double), round, 2))   ## # A tibble: 20 × 11\n##    characteristic recovered  dead univ_or univ_ci_low univ_ci_high univ_pval mv_or mvv_ci_low mv_ci_high mv_pval\n##    <chr>              <dbl> <dbl>   <dbl>       <dbl>        <dbl>     <dbl> <dbl>      <dbl>      <dbl>   <dbl>\n##  1 (Intercept)          909  1168    1.28        1.18         1.4       0     1.07       0.83       1.39    0.6 \n##  2 gender               916  1174    1           0.88         1.13      0.97  1          0.88       1.14    0.97\n##  3 (Intercept)          340   436    1.28        1.11         1.48      0     1.07       0.83       1.39    0.6 \n##  4 fever               1485  1906    1           0.85         1.17      0.99  1          0.86       1.18    0.96\n##  5 (Intercept)         1472  1877    1.28        1.19         1.37      0     1.07       0.83       1.39    0.6 \n##  6 chills               353   465    1.03        0.89         1.21      0.68  1.03       0.89       1.21    0.67\n##  7 (Intercept)          272   309    1.14        0.97         1.34      0.13  1.07       0.83       1.39    0.6 \n##  8 cough               1553  2033    1.15        0.97         1.37      0.11  1.15       0.96       1.37    0.12\n##  9 (Intercept)         1636  2114    1.29        1.21         1.38      0     1.07       0.83       1.39    0.6 \n## 10 aches                189   228    0.93        0.76         1.14      0.51  0.93       0.76       1.14    0.5 \n## 11 (Intercept)          931  1144    1.23        1.13         1.34      0     1.07       0.83       1.39    0.6 \n## 12 vomit                894  1198    1.09        0.96         1.23      0.17  1.09       0.96       1.23    0.17\n## 13 (Intercept)          338   427    1.26        1.1          1.46      0     1.07       0.83       1.39    0.6 \n## 14 age_cat5-9           365   433    0.94        0.77         1.15      0.54  0.94       0.77       1.15    0.53\n## 15 age_cat10-14         273   396    1.15        0.93         1.42      0.2   1.15       0.93       1.41    0.2 \n## 16 age_cat15-19         238   299    0.99        0.8          1.24      0.96  0.99       0.79       1.24    0.92\n## 17 age_cat20-29         345   448    1.03        0.84         1.26      0.79  1.03       0.84       1.26    0.8 \n## 18 age_cat30-49         228   307    1.07        0.85         1.33      0.58  1.06       0.85       1.33    0.61\n## 19 age_cat50-69          35    30    0.68        0.41         1.13      0.13  0.68       0.4        1.13    0.14\n## 20 age_cat70+             3     2    0.53        0.07         3.2       0.49  0.52       0.07       3.19    0.48"},{"path":"tek-değişkenli-ve-çok-değişkenli-regresyon.html","id":"forest-grafiği","chapter":"19 Tek değişkenli ve çok değişkenli regresyon","heading":"19.5 Forest Grafiği","text":"Bu bölüm, regresyonunuzun çıktılarıyla bir grafiğin nasıl üretileceğini gösterir.\nİki seçenek vardır, ggplot2 kullanarak kendiniz bir grafik oluşturabilir veya easystats (birçok paket içeren bir paket) adlı bir meta paket kullanabilirsiniz.ggplot2 çizim paketine aşina değilseniz ggplot temelleri sayfasına bakın.","code":""},{"path":"tek-değişkenli-ve-çok-değişkenli-regresyon.html","id":"ggplot2-paketi","chapter":"19 Tek değişkenli ve çok değişkenli regresyon","heading":"ggplot2 paketi","text":"Çok değişkenli regresyon sonuçlarının öğelerini çizerek ggplot() ile bir Forest grafiği oluşturabilirsiniz. Bu “geomları” kullanarak grafiklerin katmanlarını ekleyin:geom_point() ile tahminlergeom_errorbar() ile güven aralıklarıOR(Odds Ratio)= 1’de geom_vline() ile dikey bir çizgiÇizmeden önce, y eksenindeki değişkenlerin/seviyelerin sırasını ayarlamak için forcats paketinden fct_relevel() kullanmak isteyebilirsiniz. “ggplot()”, bu yaş kategorisi değerleri için iyi çalışmayan (“30”, “5”ten önce görünür) alfa-sayısal sırada görüntüleyebilir. Daha fazla ayrıntı için Faktörler sayfasına bakın.","code":"\n## kesme değerini çok değişkenli sonuçlarınızdan kaldırın\nmv_tab_base %>% \n  \n  #y ekseni boyunca görünecek seviyelerin sırasını ayarlayın\n  mutate(term = fct_relevel(\n    term,\n    \"vomit\", \"gender\", \"fever\", \"cough\", \"chills\", \"aches\",\n    \"age_cat5-9\", \"age_cat10-14\", \"age_cat15-19\", \"age_cat20-29\",\n    \"age_cat30-49\", \"age_cat50-69\", \"age_cat70+\")) %>%\n  \n  # grafikten \"kesme değeri\" satırını kaldır\n  filter(term != \"(Intercept)\") %>% \n  \n  ## değişkeni y eksenine göre grafikleştir, x eksenini tahmin et(OR)\n  ggplot(aes(x = estimate, y = term)) +\n  \n  ## tahminini nokta olarak göster\n  geom_point() + \n  \n  ## güven aralıkları için bir hata çubuğu ekleyin\n  geom_errorbar(aes(xmin = conf.low, xmax = conf.high)) + \n  \n  ## OR = 1'in referans için nerede olduğunu kesikli çizgi olarak göster\n  geom_vline(xintercept = 1, linetype = \"dashed\")"},{"path":"tek-değişkenli-ve-çok-değişkenli-regresyon.html","id":"easystats-paketleri","chapter":"19 Tek değişkenli ve çok değişkenli regresyon","heading":"easystats paketleri","text":"ggplot2’nin sağladığı iyi düzeyde kontrolü istemiyorsanız, alternatif olarak easystats paketlerinin bir kombinasyonunu kullanabilirsiniz.parameters paketindeki ‘model_parameters()’ fonksiyonu, broom paket işlevi ‘tidy()’ ile eşdeğerdir. see paketi daha sonra bu çıktıları kabul eder ve bir “ggplot()” nesnesi olarak varsayılan bir Forest grafiği oluşturur.","code":"\npacman::p_load(easystats)\n \n## kesme değerini çok değişkenli sonuçlarınızdan kaldırın \nfinal_mv_reg %>% \n  model_parameters(exponentiate = TRUE) %>% \n  plot()"},{"path":"tek-değişkenli-ve-çok-değişkenli-regresyon.html","id":"kaynaklar-12","chapter":"19 Tek değişkenli ve çok değişkenli regresyon","heading":"19.6 Kaynaklar","text":"Bu sayfanın içeriği şu kaynaklar ve çevrimiçi gösterimlerden yararlanılarak hazırlanmıştır.R’da Linear regressiongtsummaryUCLA stats sayfasısthda stepwise regression","code":""},{"path":"eksik-veri.html","id":"eksik-veri","chapter":"20 Eksik Veri","heading":"20 Eksik Veri","text":"Bu sayfada aşağıdakilerin nasıl yapılacağı anlatılacaktır:Eksikliği değerlendirinEksikliğe göre satırları filtreleyinZaman içinde eksikleri çizinGrafiklerde “Boş Veri”nin nasıl görüntüleneceğini ele alınEksik değer atamasını gerçekleştirin: MCAR, MAR, MNAR","code":""},{"path":"eksik-veri.html","id":"hazırlık-11","chapter":"20 Eksik Veri","heading":"20.1 Hazırlık","text":"","code":""},{"path":"eksik-veri.html","id":"paketleri-yükleyin-3","chapter":"20 Eksik Veri","heading":"Paketleri yükleyin","text":"Bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() vurgusunu yapıyoruz. base R’dan library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakabilirsiniz.","code":"\npacman::p_load(\n  rio,           # İçe aktar/Dışa aktar\n  tidyverse,     # Veri yönetimi ve görselleştirme\n  naniar,        # Eksikliği değerlendir ve görselleştir\n  mice           # Eksik veri yerine aktarma\n)"},{"path":"eksik-veri.html","id":"verileri-içe-aktar-5","chapter":"20 Eksik Veri","heading":"Verileri içe aktar","text":"Simüle edilmiş bir Ebola salgınından vakaların veri setini içe aktarıyoruz. Takip etmek isterseniz, “clean” satır listesi dosyasını indirmek için tıklayın  (.rds dosyası olarak). Verilerinizi rio paketinden import() fonksiyonuyla içe aktarın (.xlsx, .rds, .csv gibi birçok dosya türünü kabul eder - ayrıntılar için [İçe aktarma ve dışa aktarma] sayfasına bakabilirsiniz).Satır listesinin ilk 50 satırı aşağıda görüntülenmektedir.","code":"\n# Satır listesini içe aktar\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"eksik-veri.html","id":"içe-aktarma-işleminde-eksikliği-dönüştürme","chapter":"20 Eksik Veri","heading":"İçe aktarma işleminde eksikliği dönüştürme","text":"Verilerinizi içe aktarırken, eksik olarak sınıflandırılması gereken değerlerin farkında olun. Örneğin, 99, 999, “Eksik”, boş hücreler (““) veya boşluklu hücreler (” “). Veri içe aktarma komutu sırasında bunları ’NA’ya (R’ın eksik veri sürümü) dönüştürebilirsiniz.\nTam sözdizimi dosya türüne göre değiştiğinden, ayrıntılar için Eksik veriler ile ilgili sayfanın içe aktarılmasıyla ilgili sayfaya bakın.","code":""},{"path":"eksik-veri.html","id":"rda-eksik-değerler","chapter":"20 Eksik Veri","heading":"20.2 R’da eksik değerler","text":"Aşağıda, bazı bitişik değerler ve fonksiyonlarla birlikte, R’da eksikliğin sunulma ve değerlendirilme yollarını araştırıyoruz.","code":""},{"path":"eksik-veri.html","id":"na","chapter":"20 Eksik Veri","heading":"“NA”","text":"R’da, eksik değerler ‘NA’ ile temsil edilir. Bunun * tırnak işaretleri olmadan * yazıldığını unutmayın. “NA” farklıdır ve sadece normal bir karakter değeridir (aynı zamanda Beatles’ın Hey Jude şarkısından bir söz).Verilerinizin “99” veya “Eksik” veya “Bilinmeyen” gibi eksikleri temsil etmenin başka yolları olabilir - “boş” görünen boş karakter değerini “” veya tek bir boşluk ” ” bile olabilir. Bunların farkında olun ve içe aktarma sırasında bunları ’NA’ya dönüştürün veya ‘na_if()’ ile veri temizleme sırasında yapabilirsiniz.Veri temizleme işleminizde, tüm ‘NA’ları “Eksik” veya ’replace_na()’ya benzer şekilde veya faktörler için ’fct_explicit_na()’ ile de değiştirmek isteyebilirsiniz.","code":""},{"path":"eksik-veri.html","id":"na-sürümleri","chapter":"20 Eksik Veri","heading":"“NA” sürümleri","text":"Çoğu zaman, “NA” eksik bir değeri temsil eder ve şey yolunda gider. Ancak, bazı durumlarda, bir nesne sınıfına (karakter, sayısal, vb.) özgü “NA”nın varyasyonları gereksinimiyle karşılaşabilirsiniz. Bu nadiren olacak, ancak bilmenizde fayda vardır.\nBunun için tipik senaryo, dplyr fonksiyonu “case_while()” ile yeni bir sütun oluştururken gerçekleşmektedir. Verileri ve temel fonksiyonları temizleme sayfasında açıklandığı gibi, bu fonksiyon veri çerçevesindeki satırı değerlendirir, satırların belirtilen mantıksal ölçütlerini (kodun sağ tarafı) karşılayıp karşılamadığını değerlendirir ve doğru yeni değerini atar ( kodun sol tarafı). Önemli olan: sağ taraftaki tüm değerler aynı sınıf olmalıdır.Sağ tarafta ‘NA’ istiyorsanız, aşağıda listelenen özel ‘NA’ seçeneklerinden birini belirtmeniz gerekebilir. Diğer sağ taraftaki değerler karakter ise, bunun yerine “Missing” kullanmayı düşünün veya aksi takdirde “NA_character_” kullanın. Hepsi sayısal ise, ‘NA_real_’ kullanın. Hepsi tarih veya mantıklıysa, ‘NA’ kullanabilirsiniz.NA - tarihler veya mantıksal DOĞRU/YANLIŞ için kullanınNA_character_ - karakterler için kullanınNA_real_ - sayısal değerler için kullanınYine, yeni bir sütun oluşturmak için case_while() kullanmıyorsanız bu varyasyonlarla karşılaşmanız pek olası değildir. Daha fazla bilgi için NA ile ilgili R belgelerine bakabilirsiniz.","code":"\nlinelist <- linelist %>% \n  \n  # \"Yaş\" sütunundan yeni \"yaş_yıl\" sütununu oluştur\n  mutate(age_years = case_when(\n    age_unit == \"years\"  ~ age,       # eğer yaş yıl şeklinde verildiyse, orijinal değeri atayın\n    age_unit == \"months\" ~ age/12,    # eğer yaş ay şeklinde verildiyse, 12'ye bölün\n    is.na(age_unit)      ~ age,       # eğer yaş birimi eksikse, yılmış gibi kabul edin\n    TRUE                 ~ NA_real_)) # diğer durumlarda kayıp veri olarak atayın"},{"path":"eksik-veri.html","id":"null","chapter":"20 Eksik Veri","heading":"‘NULL’","text":"‘NULL’, R’dan ayrılmış başka bir değerdir. Bu, ne doğru ne de yanlış olan bir ifadenin mantıksal temsilidir. Değerleri tanımsız olan ifadeler veya fonksiyonlar tarafından döndürülür. Belirli senaryolarda “NULL” döndürmek için fonksiyon yazmadıkça veya belki de [shiny uygulaması][Shiny Panoları] yazmadıkça NULL değerini genellikle bir değer olarak atamayın.Boşluk .null() kullanılarak değerlendirilebilir ve .null() ile dönüşüm yapılabilir.“NULL” ve “NA” arasındaki farkla ilgili bu blog gönderisine bakabilirsiniz.","code":""},{"path":"eksik-veri.html","id":"nan","chapter":"20 Eksik Veri","heading":"NaN","text":"İmkansız değerler “NaN” özel değeri ile temsil edilir. Bunun bir örneği, R’ı 0’ı 0’bölmeye zorlamanızdır. Bunu .nan() ile değerlendirebilirsiniz. “.infinite()” ve “.finite()” gibi tamamlayıcı fonksiyonlarla da karşılaşabilirsiniz.","code":""},{"path":"eksik-veri.html","id":"inf","chapter":"20 Eksik Veri","heading":"“Inf”","text":"“Inf”, örneğin bir sayıyı 0’böldüğünüzde olduğu gibi sonsuz bir değeri temsil eder.Bunun işinizi nasıl etkileyebileceğine dair bir örnek olarak: Diyelim ki şu değerleri içeren bir “z” vektörünüz/sütununuz var: “z <- c(1, 22, NA, Inf, NaN, 5)”En yüksek değeri bulmak için sütunda ‘max()’ kullanmak istiyorsanız, ‘NA’yı hesaplamadan çıkarmak için ’na.rm = TRUE’yu kullanabilirsiniz, ancak ’Inf’ ve ‘NaN’ arta kalacak ve Inf döndürülecektir. Bunu çözmek için, hesaplamada yalnızca sonlu değerlerin kullanılacağı şekilde alt kümeler için “[ ]” ve “.finite()” köşeli parantezlerini kullanabilirsiniz: “max(z[.finite(z)])”.","code":"\nz <- c(1, 22, NA, Inf, NaN, 5)\nmax(z)                           # NA'ya döner\nmax(z, na.rm=T)                  # Inf'ye döner\nmax(z[is.finite(z)])             # 22'ye döner"},{"path":"eksik-veri.html","id":"örnekler-1","chapter":"20 Eksik Veri","heading":"Örnekler","text":"“Zorlamanın getirdiği NA’lar” yaygın bir uyarı mesajıdır. Bu, aksi takdirde sayısal olan bir vektöre karakter değeri eklemek gibi geçersiz bir dönüştürme yapmaya çalışırsanız olabilir.Bir vektörde “NULL” yok sayılır.Bir sayının varyansı “NA” ile sonuçlanır.","code":"\nas.numeric(c(\"10\", \"20\", \"thirty\", \"40\"))## Warning: NAs introduced by coercion## [1] 10 20 NA 40\nmy_vector <- c(25, NA, 10, NULL)  # tanımla\nmy_vector                         # yazdır## [1] 25 NA 10\nvar(22)## [1] NA"},{"path":"eksik-veri.html","id":"faydalı-fonksiyonları","chapter":"20 Eksik Veri","heading":"20.3 Faydalı fonksiyonları","text":"Aşağıdakiler, eksik değerleri değerlendirirken veya işlerken yararlı base R fonksiyonlarıdır:","code":""},{"path":"eksik-veri.html","id":"is.na-ve-is.na","chapter":"20 Eksik Veri","heading":"is.na() ve !is.na()","text":"Eksik değerleri belirlemek için .na() kullanın veya eksik olmayan değerleri belirlemek için tersini (önde ! ile) kullanın. Bunların ikisi de mantıksal bir değer (“DOĞRU” veya “YANLIŞ”) döndürür. ‘DOĞRU’ sayısını saymak için elde edilen vektörü ‘sum()’ ile toplayabileceğinizi unutmayın, ör. sum(.na(linelist$date_outcome)).","code":"\nmy_vector <- c(1, 4, 56, NA, 5, NA, 22)\nis.na(my_vector)## [1] FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE\n!is.na(my_vector)## [1]  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\nsum(is.na(my_vector))## [1] 2"},{"path":"eksik-veri.html","id":"na.omit","chapter":"20 Eksik Veri","heading":"na.omit()","text":"Bu fonksiyon, bir veri çerçevesine uygulanırsa, herhangi bir eksik değere sahip satırları kaldıracaktır. Aynı zamanda base R’dandır.\nBir vektöre uygulanırsa, uygulandığı vektörden ‘NA’ değerlerini kaldıracaktır. Örneğin:","code":"\nna.omit(my_vector)## [1]  1  4 56  5 22\n## attr(,\"na.action\")\n## [1] 4 6\n## attr(,\"class\")\n## [1] \"omit\""},{"path":"eksik-veri.html","id":"drop_na","chapter":"20 Eksik Veri","heading":"drop_na()","text":"Bu, [veri temizleme ardışık düzeninde][Verileri ve temel fonksiyonları temizleme] yararlı olan bir tidyr fonksiyonudur. Parantezler boş olarak çalıştırılırsa, herhangi bir eksik değeri olan satırları kaldırır. Sütun adları parantez içinde belirtilirse, bu sütunlarda eksik değerlere sahip satırlar atlanır. Sütunları belirtmek için “tidyselect” sözdizimini de kullanabilirsiniz.","code":"\nlinelist %>% \n  drop_na(case_id, date_onset, age) # bu sütunlardan herhangi biri için satır eksik değerleri bırakır"},{"path":"eksik-veri.html","id":"na.rm-doğru","chapter":"20 Eksik Veri","heading":"na.rm = DOĞRU","text":"‘max()’, ‘min()’, ‘sum()’ veya ‘mean()’ gibi bir matematiksel işlevi çalıştırdığınızda, herhangi bir ‘NA’ değeri mevcutsa, döndürülen değer ‘NA’ olacaktır. Bu varsayılan davranış kasıtlıdır, böylece verilerinizden herhangi biri eksikse uyarılırsınız.Hesaplamadan eksik değerleri kaldırarak bunu önleyebilirsiniz. Bunu yapmak için “na.rm = TRUE” bağımsız değişkenini ekleyin (“na.rm”, “NA”yı kaldır” anlamına gelir).","code":"\nmy_vector <- c(1, 4, 56, NA, 5, NA, 22)\n\nmean(my_vector)     ## [1] NA\nmean(my_vector, na.rm = TRUE)## [1] 17.6"},{"path":"eksik-veri.html","id":"bir-veri-çerçevesindeki-eksikliği-değerlendir","chapter":"20 Eksik Veri","heading":"20.4 Bir veri çerçevesindeki eksikliği değerlendir","text":"naniar paketini, “linelist” veri çerçevesindeki eksiklikleri değerlendirmek ve görselleştirmek için kullanabilirsiniz.","code":"\n# paketi kurun ve/veya yükleyin\npacman::p_load(naniar)"},{"path":"eksik-veri.html","id":"eksikliği-ölçme","chapter":"20 Eksik Veri","heading":"Eksikliği ölçme","text":"Eksik olan tüm değerlerin yüzdesini bulmak için pct_miss() kullanın. Eksik değerlerin sayısını almak için n_miss() kullanın.Aşağıdaki iki fonksiyon, sırasıyla herhangi bir eksik değere sahip veya tamamen tamamlanmış satırların yüzdesini döndürür. “NA”nın eksik anlamına geldiğini ve `\"\" veya \" \" eksik olarak sayılamayacağını unutmayın.","code":"\n# eksik TÜM veri çerçevesi değerlerinin yüzdesi\npct_miss(linelist)## [1] 6.688745\n# Herhangi bir değeri eksik olan satırların yüzdesi\npct_miss_case(linelist)   # sayımlar için n_complete() kullanın## [1] 69.12364\n# Tamamlanan satırların yüzdesi (eksik değer yok)  \npct_complete_case(linelist) # sayımlar için n_complete() kullanın## [1] 30.87636"},{"path":"eksik-veri.html","id":"eksikliği-görselleştirme","chapter":"20 Eksik Veri","heading":"Eksikliği görselleştirme","text":"gg_miss_var() fonksiyonu size sütundaki eksik değerlerin sayısını (veya %) gösterecektir. Birkaç nüans:Gruplara göre grafiği görmek için facet = değişkenlerine bir sütun adı (tırnak içinde değil) ekleyebilirsiniz.Varsayılan olarak, yüzdeler yerine sayılar gösterilir, bunu show_pct = TRUE ile değiştirin+ labs(...) ile normal bir ggplot() için olduğu gibi eksen ve başlık etiketleri ekleyebilirsiniz.Burada veriler fonksiyona %>% yoluyla tünellenerek iletilir. facet = değişkeni ayrıca verileri bölmek için kullanılır.Veri çerçevesini bir değerin eksik olup olmadığını gösteren bir ısı haritası olarak görselleştirmek için vis_miss()‘kullanabilirsiniz.\nAyrıca veri çerçevesinden belirli sütunları ’select()’ ile seçerek, yalnızca bu sütunların gösterilmesini sağlayabilirsiniz.","code":"\ngg_miss_var(linelist, show_pct = TRUE)\nlinelist %>% \n  gg_miss_var(show_pct = TRUE, facet = outcome)\n# Tüm veri çerçevesindeki eksikliğin ısı grafiği  \nvis_miss(linelist)"},{"path":"eksik-veri.html","id":"eksiklik-ilişkilerini-keşfedin-ve-görselleştirin","chapter":"20 Eksik Veri","heading":"Eksiklik ilişkilerini keşfedin ve görselleştirin","text":"Olmayan bir şeyi nasıl görselleştirirsiniz??? Varsayılan olarak, “ggplot()” grafiklerden eksik değerlere sahip noktaları kaldırır.naniar, geom_miss_point() aracılığıyla bir çözüm sunar. İki sütunlu bir dağılım grafiği oluştururken, değerlerden biri eksik, diğeri mevcut olan kayıtlar, eksik değerler sütundaki en düşük değerden %10 daha düşük olarak ayarlanarak ve belirgin bir şekilde renklendirilerek gösterilir.Aşağıdaki dağılım grafiğinde kırmızı noktalar, bir sütunun değerinin mevcut olduğu ancak diğer sütunun değerinin eksik olduğu kayıtlardır. Bu, eksik değerlerin eksik olmayan değerlere göre dağılımını görmenizi sağlar.Veri çerçevesindeki başka bir sütun tarafından katmanlandırılmış eksiklikleri değerlendirmek için, veri çerçevesindeki bir yüzdelik ısı haritasını bir faktör/kategorik (veya tarih) sütun ile döndüren ‘gg_miss_fct()’ fonksiyonu ile sağlayın:Bu fonksiyon, eksiklerin zaman içinde nasıl değiştiğini görmek için bir tarih sütunu ile de kullanılabilir:","code":"\nggplot(\n  data = linelist,\n  mapping = aes(x = age_years, y = temp)) +     \n  geom_miss_point()\ngg_miss_fct(linelist, age_cat5)\ngg_miss_fct(linelist, date_onset)## Warning: Removed 29 rows containing missing values (`geom_tile()`)."},{"path":"eksik-veri.html","id":"gölge-sütunları","chapter":"20 Eksik Veri","heading":"“Gölge” sütunları","text":"Bir sütundaki eksikliği ikinci bir sütundaki değerlere göre görselleştirmenin başka bir yolu da naniar’ın oluşturabileceği “gölgeyi” kullanmaktır. bind_shadow() mevcut sütun için bir ikili NA/`NA değil` sütunu oluşturur ve tüm bu yeni sütunları “_NA” ekiyle orijinal veri kümesine bağlar. Bu, sütun sayısını iki katına çıkarır - aşağıda göreceğiniz üzere:Bu “gölge” sütunlar, eksik değerlerin oranını başka bir sütuna göre çizmek için kullanılabilir.Örneğin, aşağıdaki grafik, “days_onset_hosp” (semptom başlangıcından hastaneye yatışa kadar geçen gün sayısı) eksik kayıtların oranını, bu kaydın “tarih_hastaneye yatış” değerine göre gösterir. Esasen, x ekseni sütununun yoğunluğunu çiziyorsunuz, ancak sonuçları (‘renk =’) ilgilenilen bir gölge sütunu ile katmanlıyorsunuz. Bu analiz, x ekseni bir sayısal veya tarih sütunuysa en iyi sonucu verir.Bu “gölge” sütunları, aşağıda gösterildiği gibi istatistiksel bir özet oluşturmak için de kullanabilirsiniz:Bir sütunun zaman içinde eksik olan değerlerinin oranını çizmenin alternatif bir yolu aşağıda gösterilmiştir. naniar içermez. Bu örnek, eksik olan haftalık gözlemlerin yüzdesini gösterir.Verileri, gözlemlerin oranını “NA” (ve diğer ilgili değerler) ile özetleyerek yararlı bir zaman biriminde (günler, haftalar vb.) toplayın.Eksik oranı ggplot() kullanarak bir çizgi olarak çizin.Aşağıda, satır listesini alıyoruz, hafta için yeni bir sütun ekliyoruz, verileri haftaya göre gruplandırıyoruz ve ardından değerin eksik olduğu o haftanın kayıtlarının yüzdesini hesaplıyoruz. (: 7 günün yüzdesini istiyorsanız, hesaplama biraz farklı olacaktır).Sonra eksik oranı haftaya göre bir çizgi olarak çizeriz. ggplot2 çizim paketine aşina değilseniz ggplot temelleri sayfasına bakabilirsiniz.","code":"\nshadowed_linelist <- linelist %>% \n  bind_shadow()\n\nnames(shadowed_linelist)##  [1] \"case_id\"                 \"generation\"              \"date_infection\"          \"date_onset\"             \n##  [5] \"date_hospitalisation\"    \"date_outcome\"            \"outcome\"                 \"gender\"                 \n##  [9] \"age\"                     \"age_unit\"                \"age_years\"               \"age_cat\"                \n## [13] \"age_cat5\"                \"hospital\"                \"lon\"                     \"lat\"                    \n## [17] \"infector\"                \"source\"                  \"wt_kg\"                   \"ht_cm\"                  \n## [21] \"ct_blood\"                \"fever\"                   \"chills\"                  \"cough\"                  \n## [25] \"aches\"                   \"vomit\"                   \"temp\"                    \"time_admission\"         \n## [29] \"bmi\"                     \"days_onset_hosp\"         \"case_id_NA\"              \"generation_NA\"          \n## [33] \"date_infection_NA\"       \"date_onset_NA\"           \"date_hospitalisation_NA\" \"date_outcome_NA\"        \n## [37] \"outcome_NA\"              \"gender_NA\"               \"age_NA\"                  \"age_unit_NA\"            \n## [41] \"age_years_NA\"            \"age_cat_NA\"              \"age_cat5_NA\"             \"hospital_NA\"            \n## [45] \"lon_NA\"                  \"lat_NA\"                  \"infector_NA\"             \"source_NA\"              \n## [49] \"wt_kg_NA\"                \"ht_cm_NA\"                \"ct_blood_NA\"             \"fever_NA\"               \n## [53] \"chills_NA\"               \"cough_NA\"                \"aches_NA\"                \"vomit_NA\"               \n## [57] \"temp_NA\"                 \"time_admission_NA\"       \"bmi_NA\"                  \"days_onset_hosp_NA\"\nggplot(data = shadowed_linelist,          # gölge sütunlu veri çerçevesi\n  mapping = aes(x = date_hospitalisation, # sayısal veya tarih sütunu\n                colour = age_years_NA)) + # ilgi alanı gölge sütunu\n  geom_density()                          # yoğunluk eğrilerini çizme\nlinelist %>%\n  bind_shadow() %>%                # gösteri sütunlarını oluştur\n  group_by(date_outcome_NA) %>%    # katmanlama için gölge sütunları\n  summarise(across(\n    .cols = age_years,             # hesaplamalar için ilgilenilen değişken\n    .fns = list(\"mean\" = mean,     # hesaplanacak istatistikler\n                \"sd\" = sd,\n                \"var\" = var,\n                \"min\" = min,\n                \"max\" = max),  \n    na.rm = TRUE))                 # stat hesaplamaları için diğer değişkenler## # A tibble: 2 × 6\n##   date_outcome_NA age_years_mean age_years_sd age_years_var age_years_min age_years_max\n##   <fct>                    <dbl>        <dbl>         <dbl>         <dbl>         <dbl>\n## 1 !NA                       16.0         12.6          158.             0            84\n## 2 NA                        16.2         12.9          167.             0            69\noutcome_missing <- linelist %>%\n  mutate(week = lubridate::floor_date(date_onset, \"week\")) %>%   # yeni hafta sütunu oluşturun\n  group_by(week) %>%                                             # satırları haftaya göre gruplayın\n  summarise(                                                     # her haftayı özetleyin\n    n_obs = n(),                                                  # kayıtların sayısı\n    \n    outcome_missing = sum(is.na(outcome) | outcome == \"\"),        # değeri eksik olan kayıt sayısı\n    outcome_p_miss  = outcome_missing / n_obs,                    # değeri eksik kayıtların oranı\n  \n    outcome_dead    = sum(outcome == \"Death\", na.rm=T),           # ölü olarak kayıt sayısı\n    outcome_p_dead  = outcome_dead / n_obs) %>%                   # ölü olarak kayıtların oranı\n  \n  tidyr::pivot_longer(-week, names_to = \"statistic\") %>%         # hafta dışındaki tüm sütunları ggplot için uzun biçime döndür\n  filter(stringr::str_detect(statistic, \"_p_\"))                  # sadece orantı değerlerini tut\nggplot(data = outcome_missing)+\n    geom_line(\n      mapping = aes(x = week, y = value, group = statistic, color = statistic),\n      size = 2,\n      stat = \"identity\")+\n    labs(title = \"Weekly outcomes\",\n         x = \"Week\",\n         y = \"Proportion of weekly records\") + \n     scale_color_discrete(\n       name = \"\",\n       labels = c(\"Died\", \"Missing outcome\"))+\n    scale_y_continuous(breaks = c(seq(0,1,0.1)))+\n  theme_minimal()+\n  theme(legend.position = \"bottom\")"},{"path":"eksik-veri.html","id":"eksik-değerlere-sahip-verileri-kullanma","chapter":"20 Eksik Veri","heading":"20.5 Eksik değerlere sahip verileri kullanma","text":"","code":""},{"path":"eksik-veri.html","id":"eksik-değerlere-sahip-satırları-filtreleyin","chapter":"20 Eksik Veri","heading":"Eksik değerlere sahip satırları filtreleyin","text":"Eksik değerlere sahip satırları hızla kaldırmak için dplyr drop_na() fonksiyonunu kullanın.Orijinal ‘linelist’, ‘nrow(linelist)’ satırlarına sahiptir. Ayarlanan satır sayısı aşağıda gösterilmiştir:Belirli sütunlarda eksik olan satırların bırakılmasını belirtebilirsiniz:Sütunları arka arkaya listeleyebilir veya “tidyselect” yardımcı işlevlerini kullanabilirsiniz:","code":"\nlinelist %>% \n  drop_na() %>%     # HERHANGİ eksik değerleri olan satırları kaldırın\n  nrow()## [1] 1818\nlinelist %>% \n  drop_na(date_onset) %>% # date_onset eksik satırları kaldırın\n  nrow()## [1] 5632\nlinelist %>% \n  drop_na(contains(\"date\")) %>% # herhangi bir \"tarih\" sütununda satır eksik değerleri kaldırın \n  nrow()## [1] 3029"},{"path":"eksik-veri.html","id":"ggplot-içindeki-nayı-işleme","chapter":"20 Eksik Veri","heading":"ggplot() içindeki NAyı işleme","text":"Bir başlıktaki bir çizimden hariç tutulan değerlerin sayısını bildirmek genellikle akıllıca olur. Aşağıda bir örnek verilmiştir:‘ggplot()’ içinde, ‘labs()’ ve içine bir ‘caption =’ ekleyebilirsiniz. Altyazıda, değerleri bir cümleye dinamik olarak yapıştırmak için stringr paketinden str_glue() kullanabilirsiniz, böylece verilere uyum sağlarlar. Bir örnek aşağıdadır:Yeni bir satır için \\n kullanımına dikkat edin.Birden fazla sütun, çizilmeyen değerlere katkıda bulunacaksa (örneğin, çizimde yaş veya cinsiyet yansıtılıyorsa), gösterilmeyen sayıyı doğru bir şekilde hesaplamak için bu sütunları da filtrelemeniz gerektiğini unutmayın.Bazen, “ggplot()” komutundan önceki komutlarda dizeyi bir nesne olarak kaydetmek ve “str_glue()” içindeki adlandırılmış dize nesnesine başvurmak daha kolay olabilir.","code":"\nlabs(\n  title = \"\",\n  y = \"\",\n  x = \"\",\n  caption  = stringr::str_glue(\n  \"n = {nrow(central_data)} from Central Hospital;\n  {nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown.\"))  "},{"path":"eksik-veri.html","id":"faktörlerde-na","chapter":"20 Eksik Veri","heading":"Faktörlerde “NA”","text":"İlgilendiğiniz sütun bir faktörse, “NA” değerlerini bir karakter değerine dönüştürmek için forcats paketinden “fct_explicit_na()” kullanın. Faktörler sayfasında daha fazla ayrıntıya bakabilirsiniz. Varsayılan olarak, yeni değer “(Eksik)” şeklindedir ancak bu, na_level = değişkeni ile ayarlanabilir.","code":"\npacman::p_load(forcats)   # paketi yükle\n\nlinelist <- linelist %>% \n  mutate(gender = fct_explicit_na(gender, na_level = \"Missing\"))\n\nlevels(linelist$gender)## [1] \"f\"       \"m\"       \"Missing\""},{"path":"eksik-veri.html","id":"atama","chapter":"20 Eksik Veri","heading":"20.6 Atama","text":"Bazen, verilerinizi analiz ederken, “boşlukları doldurmak” ve eksik verileri eklemek önemli olabilir. Tüm eksik değerleri çıkardıktan sonra bir veri kümesini zaman basitçe analiz edebilirsiniz. Ancak bu, birçok yönden sorunlara neden olabilir. İşte iki örnek:Eksik değerlere sahip tüm gözlemleri veya büyük miktarda eksik veriye sahip değişkenleri kaldırarak, bazı analiz türlerini yapma gücünüzü veya yeteneğinizi azaltabilirsiniz. Örneğin, daha önce keşfettiğimiz gibi, linelist veri kümemizdeki gözlemlerin yalnızca küçük bir kısmında tüm değişkenlerimizde eksik veri yoktur. Veri setimizin çoğunu kaldırırsak, çok fazla bilgi kaybederiz! Ve değişkenlerimizin çoğunda bir miktar eksik veri var - çoğu analiz için çok fazla verisi olan değişkeni bırakmak da muhtemelen makul değildir.Eksik değerlere sahip tüm gözlemleri veya büyük miktarda eksik veriye sahip değişkenleri kaldırarak, bazı analiz türlerini yapma gücünüzü veya yeteneğinizi azaltabilirsiniz. Örneğin, daha önce keşfettiğimiz gibi, linelist veri kümemizdeki gözlemlerin yalnızca küçük bir kısmında tüm değişkenlerimizde eksik veri yoktur. Veri setimizin çoğunu kaldırırsak, çok fazla bilgi kaybederiz! Ve değişkenlerimizin çoğunda bir miktar eksik veri var - çoğu analiz için çok fazla verisi olan değişkeni bırakmak da muhtemelen makul değildir.Verilerinizin neden eksik olduğuna bağlı olarak, yalnızca eksik olmayan verilerin analizi yanlı veya yanıltıcı sonuçlara yol açabilir. Örneğin, daha önce öğrendiğimiz gibi, bazı hastaların ateş veya öksürük gibi bazı önemli semptomları olup olmadığına ilişkin verileri kaçırıyor olabiliriz. Ancak, bir olasılık olarak, belki de bu bilgi çok hasta olmayan insanlar için kaydedilmemiştir. Bu durumda, bu gözlemleri kaldırmış olsaydık, veri kümemizdeki en sağlıklı insanlardan bazılarını hariç tutmuş olurduk ve bu gerçekten herhangi bir sonucu saptırabilirdi.Verilerinizin neden eksik olduğuna bağlı olarak, yalnızca eksik olmayan verilerin analizi yanlı veya yanıltıcı sonuçlara yol açabilir. Örneğin, daha önce öğrendiğimiz gibi, bazı hastaların ateş veya öksürük gibi bazı önemli semptomları olup olmadığına ilişkin verileri kaçırıyor olabiliriz. Ancak, bir olasılık olarak, belki de bu bilgi çok hasta olmayan insanlar için kaydedilmemiştir. Bu durumda, bu gözlemleri kaldırmış olsaydık, veri kümemizdeki en sağlıklı insanlardan bazılarını hariç tutmuş olurduk ve bu gerçekten herhangi bir sonucu saptırabilirdi.Ne kadarının eksik olduğunu görmenin yanı sıra verilerinizin neden eksik olabileceğini düşünmek de önemlidir. Bunu yapmak, eksik verileri yüklemenin ne kadar önemli olabileceğine ve ayrıca sizin durumunuzda hangi eksik verileri yükleme yönteminin en iyi olabileceğine karar vermenize yardımcı olabilir.","code":""},{"path":"eksik-veri.html","id":"eksik-veri-türleri","chapter":"20 Eksik Veri","heading":"Eksik veri türleri","text":"İşte üç genel eksik veri türü:Rastgele Tamamen Eksik (MCAR). Bu, verilerin eksik olma olasılığı ile verilerinizdeki diğer değişkenlerden herhangi biri arasında bir ilişki olmadığı anlamına gelir. Eksik olma olasılığı tüm durumlarda aynıdır. Bu nadir görülen bir durumdur. Ancak, verilerinizin MCAR olduğuna inanmak için güçlü bir nedeniniz varsa, yalnızca eksik olmayan verileri empoze etmeden analiz ediyorsa, sonuçlarınızı etkilemeyecektir (ancak biraz güç kaybedebilirsiniz). [TODO: MCAR için istatistiksel testleri tartışmayı düşünün]Rastgele Tamamen Eksik (MCAR). Bu, verilerin eksik olma olasılığı ile verilerinizdeki diğer değişkenlerden herhangi biri arasında bir ilişki olmadığı anlamına gelir. Eksik olma olasılığı tüm durumlarda aynıdır. Bu nadir görülen bir durumdur. Ancak, verilerinizin MCAR olduğuna inanmak için güçlü bir nedeniniz varsa, yalnızca eksik olmayan verileri empoze etmeden analiz ediyorsa, sonuçlarınızı etkilemeyecektir (ancak biraz güç kaybedebilirsiniz). [TODO: MCAR için istatistiksel testleri tartışmayı düşünün]Rastgele Eksik (MAR). Bu isim aslında biraz yanıltıcıdır, çünkü MAR, sahip olduğunuz diğer bilgilere dayanarak verilerinizin sistematik, öngörülebilir bir şekilde eksik olduğu anlamına gelir. Örneğin, belki de veri setimizde eksik bir ateş değeri olan gözlem aslında kaydedilmemiştir çünkü üşüyen ve ağrıyan hastanın sadece ateşi olduğu varsayıldığından ateşleri hiç ölçülmemiştir. Eğer doğruysa, titreme ve ağrılı eksik gözlemin de bir ateşi olduğunu kolayca tahmin edebilir ve bu bilgiyi eksik verilerimizi değerlendirmek için kullanabiliriz. Uygulamada, bu daha çok bir spektrumdur. Belki bir hastada hem üşüme hem de ağrı varsa, ateşi ölçülmediyse de ateşi olma olasılığı daha yüksekti, ama zaman değil. Mükemmel bir şekilde öngörülebilir olmasa bile yine de öngörülebilir. Yaygın bir eksik veri türüdür.Rastgele Eksik (MAR). Bu isim aslında biraz yanıltıcıdır, çünkü MAR, sahip olduğunuz diğer bilgilere dayanarak verilerinizin sistematik, öngörülebilir bir şekilde eksik olduğu anlamına gelir. Örneğin, belki de veri setimizde eksik bir ateş değeri olan gözlem aslında kaydedilmemiştir çünkü üşüyen ve ağrıyan hastanın sadece ateşi olduğu varsayıldığından ateşleri hiç ölçülmemiştir. Eğer doğruysa, titreme ve ağrılı eksik gözlemin de bir ateşi olduğunu kolayca tahmin edebilir ve bu bilgiyi eksik verilerimizi değerlendirmek için kullanabiliriz. Uygulamada, bu daha çok bir spektrumdur. Belki bir hastada hem üşüme hem de ağrı varsa, ateşi ölçülmediyse de ateşi olma olasılığı daha yüksekti, ama zaman değil. Mükemmel bir şekilde öngörülebilir olmasa bile yine de öngörülebilir. Yaygın bir eksik veri türüdür.Rastgele Eksik Değil (MNAR veya NMAR). Bu, bir değerin eksik olma olasılığının sistematik OLMADIĞINI veya sahip olduğumuz diğer bilgiler kullanılarak öngörülebilir olmadığını, ancak rastgele olarak da eksik olmadığını varsayar. Bu durumda, bilinmeyen veya hakkında bilgi sahibi olmadığınız nedenlerden dolayı veriler eksiktir. Örneğin, veri setimizde yaşla ilgili bilgiler eksik olabilir, çünkü bazı çok yaşlı hastalar kaç yaşında olduklarını ya bilmiyorlar ya da söylemeyi reddediyorlardır. Bu durumda, yaşa ilişkin eksik veriler, değerin kendisiyle ilgilidir (ve dolayısıyla rastgele değildir) ve sahip olduğumuz diğer bilgilere dayanarak tahmin edilebilir değildir. MNAR karmaşıktır ve çoğu zaman bununla başa çıkmanın en iyi yolu, verilerin neden eksik olduğu hakkında daha fazla veri veya bilgi toplamaya çalışmaktır.Rastgele Eksik Değil (MNAR veya NMAR). Bu, bir değerin eksik olma olasılığının sistematik OLMADIĞINI veya sahip olduğumuz diğer bilgiler kullanılarak öngörülebilir olmadığını, ancak rastgele olarak da eksik olmadığını varsayar. Bu durumda, bilinmeyen veya hakkında bilgi sahibi olmadığınız nedenlerden dolayı veriler eksiktir. Örneğin, veri setimizde yaşla ilgili bilgiler eksik olabilir, çünkü bazı çok yaşlı hastalar kaç yaşında olduklarını ya bilmiyorlar ya da söylemeyi reddediyorlardır. Bu durumda, yaşa ilişkin eksik veriler, değerin kendisiyle ilgilidir (ve dolayısıyla rastgele değildir) ve sahip olduğumuz diğer bilgilere dayanarak tahmin edilebilir değildir. MNAR karmaşıktır ve çoğu zaman bununla başa çıkmanın en iyi yolu, verilerin neden eksik olduğu hakkında daha fazla veri veya bilgi toplamaya çalışmaktır.Genel olarak, MCAR verilerini empoze etmek genellikle oldukça basittir, MNAR ise imkansız değilse de çok zordur. Yaygın veri atama yöntemlerinin çoğu MAR’ı varsayar.","code":""},{"path":"eksik-veri.html","id":"faydalı-paketler","chapter":"20 Eksik Veri","heading":"Faydalı paketler","text":"Eksik verileri yüklemek için bazı yararlı paketler Mmisc, missForest (eksik verileri yüklemek için rastgele forestları kullanır) ve MICE’dir (Multivariate Imputation Chained Equations- Zincirli Denklemlerle Çok Değişkenli Tahminleme). Bu bölüm için sadece çeşitli teknikleri uygulayan MICE paketini kullanacağız. MICE paketi üreticisi, burada daha fazla ayrıntıya giren eksik verilerin empoze edilmesi hakkında bir çevrimiçi kitap yayınlamıştır (https://stefvanbuuren.name/fimd/).Fare paketini yüklemek için kod:","code":"\npacman::p_load(mice)"},{"path":"eksik-veri.html","id":"ortalama-atama","chapter":"20 Eksik Veri","heading":"Ortalama Atama","text":"Bazen basit bir analiz yapıyorsanız veya MCAR’ı varsayabileceğinizi düşünmek için güçlü bir nedeniniz varsa, eksik sayısal değerleri o değişkenin ortalamasına kolayca ayarlayabilirsiniz. Belki de veri setimizde eksik olan sıcaklık ölçümlerinin ya MCAR olduğunu ya da sadece normal değerler olduğunu varsayabiliriz. Veri kümemizdeki eksik sıcaklık değerlerini ortalama sıcaklık değeriyle değiştiren yeni bir değişken oluşturma kodu burada. Bununla birlikte, birçok durumda verileri ortalamayla değiştirmek yanlılığa neden olabilir, bu nedenle kullanırken dikkatli olun.Kategorik verileri belirli bir değerle değiştirmek için de benzer bir işlem yapabilirsiniz. Tüm gözlemlerin çıktılarının eksik verili olmasına karşın (“Ölüm” veya “İyileşme” olabilir) ölümlerden oluştuğunu bildiğinizi farz edin (: bu aslında bu veri kümesi için doğru değildir):","code":"\nlinelist <- linelist %>%\n  mutate(temp_replace_na_with_mean = replace_na(temp, mean(temp, na.rm = T)))\nlinelist <- linelist %>%\n  mutate(outcome_replace_na_with_death = replace_na(outcome, \"Death\"))"},{"path":"eksik-veri.html","id":"regresyon-ataması","chapter":"20 Eksik Veri","heading":"Regresyon ataması","text":"Biraz daha gelişmiş bir yöntem, eksik bir değerin ne olabileceğini tahmin etmek için bir tür istatistiksel model kullanmak ve bunu tahmin edilen değerle değiştirmektir. Burada, sıcaklığın eksik olduğu, ancak yaş ve ateşin olmadığı tüm gözlemler için, tahmin edici olarak ateş durumu ve yaş kullanılarak basit doğrusal regresyon kullanılarak tahmin değerleri oluşturmaya bir örnek verilmiştir. Pratikte bu tür basit yaklaşımlardan daha iyi bir model kullanmak istersiniz.Veya, eksik sıcaklık gözlemleri için emsal değerler oluşturmak üzere MICE paketi aracılığıyla aynı modelleme yaklaşımını kullanarak:Bu, eksik verileri tahmin edilen değerlerle değiştirmek için missForest paketini kullanmak gibi bazı daha gelişmiş yöntemlerle aynı türde bir yaklaşımdır. Bu durumda, tahmin modeli doğrusal bir regresyon yerine random forest’tir. Bunu yapmak için diğer model türlerini de kullanabilirsiniz. Bununla birlikte, bu yaklaşım MCAR altında iyi çalışsa da, MAR veya MNAR’ın durumunuzu daha doğru tanımladığına inanıyorsanız biraz dikkatli olmalısınız. Tahmininizin kalitesi, tahmin modelinizin ne kadar iyi olduğuna bağlı olacaktır ve çok iyi bir modelde bile, empoze edilen verilerinizin değişkenliği iyi tahmin edilemeyebilir.","code":"\nsimple_temperature_model_fit <- lm(temp ~ fever + age_years, data = linelist)\n\n#sadece sıcaklığın eksik olduğu gözlemler için değerleri tahmin etmek için basit sıcaklık modelimizi kullanma\npredictions_for_missing_temps <- predict(simple_temperature_model_fit,\n                                        newdata = linelist %>% filter(is.na(temp))) \nmodel_dataset <- linelist %>%\n  select(temp, fever, age_years)  \n\ntemp_imputed <- mice(model_dataset,\n                            method = \"norm.predict\",\n                            seed = 1,\n                            m = 1,\n                            print = F)## Warning: Number of logged events: 1\ntemp_imputed_values <- temp_imputed$imp$temp"},{"path":"eksik-veri.html","id":"locf-ve-bocf","chapter":"20 Eksik Veri","heading":"LOCF ve BOCF","text":"İleriye taşınan son gözlem (Last observation carried forward- LOCF) ve ileriye taşınan temel gözlem (Baseline observation carried forward-BOCF), zaman serisi/boylamsal veriler için değerlendirme yöntemleridir. Buradaki fikir, eksik verilerin yerine önceki gözlenen değeri almaktır. Art arda birden fazla değer eksik olduğunda, yöntem en son gözlenen değeri arar.tidyr paketindeki fill() fonksiyonu hem LOCF hem de BOCF ataması için kullanılabilir (ancak, HMISC, zoo ve data.table gibi diğer paketler ayrıca bunu yapmak için yöntemler içerir). fill() sözdizimini göstermek için 2000 ve 2001 yıllarının çeyreği için bir hastalık vakalarının sayısını içeren basit bir zaman serisi veri seti oluşturacağız. Ancak, Q1’den sonraki çeyrekler için yıl değeri eksik olduğundan onları saymamız gerekecek. ‘fill()’ bağlantısı [Pivoting data] sayfasında da gösterilmektedir.: fill() fonskiyonunu kullanmadan önce verilerinizin doğru şekilde sıralandığından emin olun. fill() varsayılan olarak “aşağı” doldurma şeklindedir, ancak .direction parametresini değiştirerek değerleri farklı yönlere de uygulayabilirsiniz. Yıl değerinin yalnızca yılın sonunda kaydedildiği ve önceki çeyrekler için eksik olduğu benzer bir veri seti yapabiliriz:Bu örnekte, LOCF ve BOCF açıkça yapılması gereken doğru şeylerdir, ancak daha karmaşık durumlarda bu yöntemlerin uygun olup olmadığına karar vermek daha zor olabilir. Örneğin hastanede yatan bir hasta için ilk günden sonra eksik laboratuvar değerleriniz olabilir. Bazen bu, laboratuvar değerlerinin değişmediği anlamına gelebilir… ama aynı zamanda hastanın iyileştiği ve değerlerinin ilk günden sonra çok farklı olacağı anlamına da gelebilir! Bu yöntemleri dikkatli kullanın.","code":"\n# basit veri setimizi oluşturmak\ndisease <- tibble::tribble(\n  ~quarter, ~year, ~cases,\n  \"Q1\",    2000,    66013,\n  \"Q2\",      NA,    69182,\n  \"Q3\",      NA,    53175,\n  \"Q4\",      NA,    21001,\n  \"Q1\",    2001,    46036,\n  \"Q2\",      NA,    58842,\n  \"Q3\",      NA,    44568,\n  \"Q4\",      NA,    50197)\n\n# eksik yıl değerlerinin ataması:\ndisease %>% fill(year)## # A tibble: 8 × 3\n##   quarter  year cases\n##   <chr>   <dbl> <dbl>\n## 1 Q1       2000 66013\n## 2 Q2       2000 69182\n## 3 Q3       2000 53175\n## 4 Q4       2000 21001\n## 5 Q1       2001 46036\n## 6 Q2       2001 58842\n## 7 Q3       2001 44568\n## 8 Q4       2001 50197\n# biraz farklı veri kümemizi oluşturmak\ndisease <- tibble::tribble(\n  ~quarter, ~year, ~cases,\n  \"Q1\",      NA,    66013,\n  \"Q2\",      NA,    69182,\n  \"Q3\",      NA,    53175,\n  \"Q4\",    2000,    21001,\n  \"Q1\",      NA,    46036,\n  \"Q2\",      NA,    58842,\n  \"Q3\",      NA,    44568,\n  \"Q4\",    2001,    50197)\n\n# eksik yıl değerlerini \"yukarı\" yönde atamak:\ndisease %>% fill(year, .direction = \"up\")## # A tibble: 8 × 3\n##   quarter  year cases\n##   <chr>   <dbl> <dbl>\n## 1 Q1       2000 66013\n## 2 Q2       2000 69182\n## 3 Q3       2000 53175\n## 4 Q4       2000 21001\n## 5 Q1       2001 46036\n## 6 Q2       2001 58842\n## 7 Q3       2001 44568\n## 8 Q4       2001 50197"},{"path":"eksik-veri.html","id":"çoklu-atama","chapter":"20 Eksik Veri","heading":"Çoklu Atama","text":"MICE paketinin yazarı tarafından daha önce bahsettiğimiz çevrimiçi kitap (https://stefvanbuuren.name/fimd/), birden fazla değerlemenin ayrıntılı bir açıklamasını ve neden kullanmak isteyeceğinizi içermektedir. Ancak, işte yöntemin temel bir açıklaması:Birden çok atama yaptığınızda, eksik değerlerin makul veri değerlerine atfedildiği birden çok veri kümesi oluşturursunuz (araştırma verilerinize bağlı olarak, bu atfedilen veri kümelerinden daha fazlasını veya daha azını oluşturmak isteyebilirsiniz, ancak MICE paketi varsayılan sayıyı 5’e ayarlar). Aradaki fark, bir empoze edilen değerin tek, belirli bir değerden ziyade tahmini bir dağılımdan çekilmesidir (bu nedenle bir miktar rastgelelik içerir). Sonuç olarak, bu veri kümelerinin biri biraz farklı emsal değerlere sahip olacaktır (ancak, eksik olmayan veriler bu empoze edilen veri kümelerinin birinde aynı olacaktır). Bu yeni veri kümelerinin birinde atama yapmak için hala bir tür tahmine dayalı model kullanıyorsunuz (MICE Tahmini Ortalama Eşleştirme, lojistik regresyon ve random forest dahil olmak üzere birçok tahmin yöntemi seçeneği vardır) ancak MICE paketinin modelleme detaylarına dikkat etmelisiniz.Ardından, bu yeni atfedilen veri kümelerini oluşturduktan sonra, bu yeni empoze edilmiş veri kümelerinin biri için yapmayı planladığınız istatistiksel modeli veya analizi uygulayabilir ve\nmodellerin sonuçlarını bir araya toplayabilirsiniz. Bu, hem MCAR hem de birçok MAR ayarındaki yanlılığı azaltmak için çok iyi çalışır ve genellikle daha doğru standart hata tahminleriyle sonuçlanır.Burada, bir yaş ve ateş durumu (yukarıdaki basitleştirilmiş model_veri kümemiz) kullanarak satır listesi veri kümemizdeki sıcaklığı tahmin etmek için Çoklu Atama işleminin uygulanmasına bir örnek verilmiştir:Burada MICE’nin standart yöntemi Tahmini Ortalama Eşleştirme yöntemini kullandık. Daha sonra, bu veri kümelerinin birinde basit doğrusal regresyonlardan elde edilen sonuçları ayrı ayrı tahmin etmek ve havuzlamak için bu emsal veri kümelerini kullandık. Üzerinde durduğumuz birçok ayrıntı ve MICE paketini kullanırken Çoklu Atama işlemi sırasında ayarlayabileceğiniz birçok ayar vardır. Örneğin, zaman sayısal verileriniz olmaz ve başka atama yöntemlerini kullanmanız gerekebilir (diğer birçok veri ve yöntem türü için MICE paketini kullanmaya devam edebilirsiniz). Ancak, eksik veriler önemli bir sorun olduğunda daha sağlam bir analiz için, Çoklu Atama iyi bir çözümdür ancak, zaman tam bir vaka analizi yapmaktan daha fazla işe yaramaz.","code":"\n# model_dataset'imizdeki tüm değişkenler için eksik değerler atamak ve 10 yeni atanmış veri kümesi oluşturmak\nmultiple_imputation = mice(\n  model_dataset,\n  seed = 1,\n  m = 10,\n  print = FALSE) ## Warning: Number of logged events: 1\nmodel_fit <- with(multiple_imputation, lm(temp ~ age_years + fever))\n\nbase::summary(mice::pool(model_fit))##          term     estimate    std.error     statistic        df       p.value\n## 1 (Intercept) 3.703143e+01 0.0270863456 1367.16240465  26.83673  1.583113e-66\n## 2   age_years 3.867829e-05 0.0006090202    0.06350905 171.44363  9.494351e-01\n## 3    feveryes 1.978044e+00 0.0193587115  102.17849544 176.51325 5.666771e-159"},{"path":"eksik-veri.html","id":"kaynaklar-13","chapter":"20 Eksik Veri","heading":"20.7 Kaynaklar","text":"Kılavuz naniar packageGaleri missing value visualizationsÇevrimiçi kitap R’da birden fazla değer atama hakkında MICE paketi yaratıcısının kitabı","code":""},{"path":"standardize-edilmiş-hızlar.html","id":"standardize-edilmiş-hızlar","chapter":"21 Standardize edilmiş hızlar","heading":"21 Standardize edilmiş hızlar","text":"Bu sayfa, hastaneye yatış veya ölüm oranları gibi bir çıktıyı yaş ve cinsiyet gibi özelliklere göre standardize etmenin iki yolunu gösterecektir.dsr paketini kullanmaPHEindicatormethods paketini kullanmaBirden fazla ülkeden nüfus verileri, standart nüfus verileri, ölümler vb. birleştirilmesi için yaygın kullanımı olduğu için, veri hazırlama/temizleme/birleştirme süreçlerini kapsamlı bir şekilde göstererek başlıyoruz.","code":""},{"path":"standardize-edilmiş-hızlar.html","id":"genel-bakış-1","chapter":"21 Standardize edilmiş hızlar","heading":"21.1 Genel bakış","text":"Standardizasyonun iki ana yöntemi vardır: Direkt ve indirekt standardizasyon.\nve B ülkeleri için ölüm hızlarını yaşa ve cinsiyete göre standardize etmek ve bu ülkeler arasındaki standardize edilmiş oranları karşılaştırmak istediğimizi varsayalım.Direk standardizasyon için, ülkesi ve B ülkesi için yaş ve cinsiyet tabakası için risk altındaki popülasyon büyüklüğüve ölümlerin sayısını bilmeniz gerekecektir. Örneğimizdeki bir katman 15-44 yaş arası kadınlar olabilir.İndirekt standardizasyon için, ülkenin toplam ölüm sayısı, yaş ve cinsiyet yapısını bilmeniz gerekir. Dolayısıyla bu seçenek, yaşa ve cinsiyete özgü ölüm hızları veya nüfus sayıları mevcut değilse uygulanabilir. Direkt standardizasyondaki tahminler örneklem varyasyonundan etkileneceğinden; tabaka başına küçük sayıların olması durumunda indirekt standardizasyon tercih edilir.","code":""},{"path":"standardize-edilmiş-hızlar.html","id":"hazırlık-12","chapter":"21 Standardize edilmiş hızlar","heading":"21.2 Hazırlık","text":"Standardizasyonun nasıl yapıldığını göstermek için, ve B ülkelerinin yaşa (5 yıllık tabakalar halinde) ve cinsiyete (kadın, erkek) göre kurgusal nüfus büyüklükleri ve ölüm sayımlarını kullanacağız. Veri setlerini kullanıma hazır hale getirmek için aşağıdaki hazırlık adımlarını gerçekleştireceğiz:Paketlerin yüklenmesiVeri tabanlarının yüklenmesiİki ülkenin nüfus ve ölüm verilerini birleştirilmesiYaş-cinsiyet katmanı başına bir satır olacak şekilde daha uzun şekilde pivotlamaReferans popülasyonunu (dünya standart nüfusu) temizleme ve ülke verilerine eklemeSenaryonuzda, verileriniz farklı bir biçimde gelebilir. Belki verileriniz il, şehir veya başka bir hizmet alanına göre düzenlenmiştir. ölüm için bir satır ve bu ölümlerin biri (veya önemli bir kısmı) için yaş ve cinsiyet bilgileri olabilir. Bu durumda, yaş-cinsiyet katmanlarına göre olay ve nüfus sayıları içeren bir veri tabanı oluşturmak için [Verileri gruplandırma], [Verileri pivotlama] ve Tanımlayıcı tablolar sayfalarına bakın.Ayrıca bir referans popülasyona, standart popülasyona ihtiyacımız vardır. Bu alıştırma için world_standard_population_by_sex’kullanacağız. Dünya standart nüfusu, 46 ülkenin nüfusuna dayanmaktadır ve 1960 yılında geliştirilmiştir. Birçok “standart” popülasyon vardır - bir örnek olarak, NHS İskoçya’nın web sitesi Avrupa Standart Nüfusu, Dünya Standart Nüfusu ve İskoçya Standardı hakkında detaylı bilgi içermektedir. (European Standard Population, World Standard Population Scotland Standard Population).","code":""},{"path":"standardize-edilmiş-hızlar.html","id":"paketlerin-yüklenmesi-3","chapter":"21 Standardize edilmiş hızlar","heading":"Paketlerin yüklenmesi","text":"Bu kod kümesi, analizler için gereken paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’ın p_load() fonksiyonunu vurguluyoruz. Ayrıca, R tabanından library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R’ın temelleri] sayfasına bakın.**DİKKAT:_** Daha yeni bir R sürümüne sahipseniz, dsr paketi doğrudan CRAN’den indirilemez. Ancak, yine de bu paket CRAN arşivinden temin edilebilir. Bu şekilde paketi yükleyebilir ve kullanabilirsiniz. Mac kullanıcısı olmayanlar için:Mac kullanıcıları için:","code":"\npacman::p_load(\n     rio,                 # verileri içe/dışa aktar\n     here,                # dosyaları bul\n     tidyverse,           # veri yönetimi ve görselleştirme\n     stringr,             # karakterleri ve dizeleri (string) temizleme\n     frailtypack,         # frailty modelleri için dsr için gerekli\n     dsr,                 # hızları standardize et\n     PHEindicatormethods) # hızların  standardizasyonu için alternatif\npackageurl <- \"https://cran.r-project.org/src/contrib/Archive/dsr/dsr_0.2.2.tar.gz\"\ninstall.packages(packageurl, repos=NULL, type=\"source\")\n# Diğer çözüm\nrequire(devtools)\ndevtools::install_version(\"dsr\", version=\"0.2.2\", repos=\"http:/cran.us.r.project.org\")\nrequire(devtools)\ndevtools::install_version(\"dsr\", version=\"0.2.2\", repos=\"https://mac.R-project.org\")"},{"path":"standardize-edilmiş-hızlar.html","id":"popülasyon-verisinin-yüklenmesi","chapter":"21 Standardize edilmiş hızlar","heading":"Popülasyon verisinin yüklenmesi","text":"El kitabındaki tüm örnek verilerin nasıl indirileceğine ilişkin talimatlar için [Verilerin ve el kitabının indirilmesi] sayfasına bakın. Aşağıdaki import() komutlarını çalıştırarak Standardizasyon sayfası verilerini Github depomuzdan doğrudan R’aktarabilirsiniz:İlk önce karşılaştıracağımız iki ülke olan “Ülke ” ve “Ülke B” için demografik verileri (5 yıllık yaş kategorisine göre kadın ve erkek sayıları) yüklüyoruz.","code":"\n# A ülkesi için demografik veriyi doğrudan Github'dan içe aktarın\nA_demo <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics.csv\")\n\n# A ülkesi için ölümleri doğrudan Github'dan içe aktarın\nA_deaths <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryA.csv\")\n\n# B ülkesi için demografik veriyi doğrudan Github'dan içe aktarın\nB_demo <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics_2.csv\")\n\n# B ülkesi için ölümleri doğrudan Github'dan içe aktarın\nB_deaths <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryB.csv\")\n\n# B ülkesi için demografik veriyi doğrudan Github'dan içe aktarın\nstandard_pop_data <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/world_standard_population_by_sex.csv\")\n# A ülkesi\nA_demo <- import(\"country_demographics.csv\")\n# B ülkesi\nB_demo <- import(\"country_demographics_2.csv\")"},{"path":"standardize-edilmiş-hızlar.html","id":"ölüm-sayılarının-yüklenmesi","chapter":"21 Standardize edilmiş hızlar","heading":"Ölüm sayılarının yüklenmesi","text":"Elimizde uygun bir şekilde, ilgilenilen zaman dilimindeki yaş ve cinsiyete göre ölüm sayıları da bulunmaktadır. ülkenin ölüm sayıları aşağıda gösterilen ayrı bir dosyadadır.Ülkesindeki ÖlümlerB Ülkesindeki Ölümler","code":""},{"path":"standardize-edilmiş-hızlar.html","id":"nüfus-ve-ölüm-verilerinin-temizliği","chapter":"21 Standardize edilmiş hızlar","heading":"Nüfus ve ölüm verilerinin temizliği","text":"Bu verileri aşağıdaki şekillerde birleştirmemiz ve dönüştürmemiz gerekiyor:Ülke popülasyonlarını tek bir veri tabanında birleştirin ve bir yaş-cinsiyet katmanının bir satır olması için “uzun” şekilde pivotlayınÜlke ölüm sayılarını tek bir veri tabanında birleştirin ve bir yaş-cinsiyet katmanının bir satır olması için “uzun” şekilde pivotlayınÖlümleri nüfusla birleştirinİlk olarak, ülke popülasyonları veri tabanlarını birleştirip, daha sonra uzun biçimde pivotlar ve temizlik yaparız. Daha fazla ayrıntı için Verilerin pivotlanması sayfasına bakın.Birleşik nüfus verileri şimdi şöyle görünür (ve B ülkelerini görmek için tıklayın):Şimdi de iki ölüm veri setinde benzer işlemler yapıyoruz.Ölüm verileri şimdi böyle görünüyor ve iki ülkeden de veriler içermekte:Şimdi Country, age_cat5 ve Sex ortak sütunlarına dayalı ölüm ve nüfus verilerini birleştiriyoruz. Bu işlem, Deaths sütununu ekler.Artık Sex, age_cat5 ve Country’yi faktör olarak sınıflandırabilir ve Faktörler sayfasında açıklandığı gibi forcats paketinden fct_relevel() fonksiyonunu kullanarak seviye sırasını ayarlayabiliriz. Unutulmamalıdır ki, faktör seviyelerinin sınıflandırılması verileri gözle görülür şekilde değiştirmez, ancak arrange() komutu verileri ülkeye, yaş kategorisine ve cinsiyete göre sıralar.DİKKAT: tabakada az sayıda ölüm varsa, yaşa göre 5 yıllık kategoriler yerine 10 veya 15 yıllık kategorileri kullanmayı düşünün.","code":"\npop_countries <- A_demo %>%  # A ülkesi veritabanı ile başla\n     bind_rows(B_demo) %>%        # Satırları B veri tabanıyla bağla, çünkü sütunlar aynı şekilde adlandırılır\n     pivot_longer(                       # uzun şekilde pivotlama\n          cols = c(m, f),                   # birleştirilecek sütunlar\n          names_to = \"Sex\",                 # kategoriyi (\"m\" veya \"f\") içeren yeni sütunun adı \n          values_to = \"Population\") %>%     # özetlenen sayısal değerleri içeren yeni sütunun adı\n     mutate(Sex = recode(Sex,            # anlaşılması için değerleri yeniden kodla\n          \"m\" = \"Male\",\n          \"f\" = \"Female\"))\ndeaths_countries <- A_deaths %>%    # A ülkesi ölüm veritabanı ile başlayın\n     bind_rows(B_deaths) %>%        # Satırları B veri tabanıyla bağla, çünkü sütunlar aynı şekilde adlandırılır\n     pivot_longer(                  # uzun şekilde pivotlama\n          cols = c(Male, Female),        # birleştirilecek sütunlar\n          names_to = \"Sex\",              # kategoriyi (\"m\" veya \"f\") içeren yeni sütunun adı\n          values_to = \"Deaths\") %>%      # özetlenen sayısal değerleri içeren yeni sütunun adı\n     rename(age_cat5 = AgeCat)      # anlaşılması için değerleri yeniden kodla\ncountry_data <- pop_countries %>% \n     left_join(deaths_countries, by = c(\"Country\", \"age_cat5\", \"Sex\"))\ncountry_data <- country_data %>% \n  mutate(\n    Country = fct_relevel(Country, \"A\", \"B\"),\n      \n    Sex = fct_relevel(Sex, \"Male\", \"Female\"),\n        \n    age_cat5 = fct_relevel(\n      age_cat5,\n      \"0-4\", \"5-9\", \"10-14\", \"15-19\",\n      \"20-24\", \"25-29\",  \"30-34\", \"35-39\",\n      \"40-44\", \"45-49\", \"50-54\", \"55-59\",\n      \"60-64\", \"65-69\", \"70-74\",\n      \"75-79\", \"80-84\", \"85\")) %>% \n          \n  arrange(Country, age_cat5, Sex)"},{"path":"standardize-edilmiş-hızlar.html","id":"referans-popülasyonun-yüklenmesi","chapter":"21 Standardize edilmiş hızlar","heading":"Referans popülasyonun yüklenmesi","text":"Son olarak, direkt standardizasyon için referans popülasyonu (cinsiyete göre dünya “standart nüfusu”) içe aktarıyoruz.","code":"\n# Referans popülasyon\nstandard_pop_data <- import(\"world_standard_population_by_sex.csv\")"},{"path":"standardize-edilmiş-hızlar.html","id":"referans-popülasyon-verisinin-temizliği","chapter":"21 Standardize edilmiş hızlar","heading":"Referans popülasyon verisinin temizliği","text":"country_data ve standard_pop_data veri çerçevelerindeki yaş kategorisi değerlerinin hizalanması gerekir.Şu anda, standart_pop_data veri çerçevesinden age_cat5 sütununun değerleri “yıllar” ve “artı” kelimelerini içerirken country_data veri çerçevesindeki sütun bu kelimeleri içermemektedir. Yaş kategorisi değerlerini eşleştirmemiz gerekecek. Bu kalıpları boşluksuz olarak \"\" biçiminde değiştirmek için Karakterler ve dizeler sayfasında açıklandığı gibi stringr paketinden str_replace_all() komutunu kullanıyoruz.Ayrıca, dsr paketi standart popülasyonda sayıları içeren sütunun \"pop\" olarak adlandırılmasını bekler. Bu yüzden bu sütunu bu şekilde yeniden adlandırıyoruz.DİKKAT: Bir artı sembolünü kaldırmak için str_replace_all() kullanmayı denerseniz, özel bir sembol olduğu için çalışmayacaktır. str_replace_call(column, \"\\\\+\", \"\") örneğinde olduğu gibi önüne iki ters eğik çizgi koyarak özel özelliklerden kaçınabilirsiniz.","code":"\n# Sütun değerlerinden belirli dizeyi kaldır\nstandard_pop_clean <- standard_pop_data %>%\n     mutate(\n          age_cat5 = str_replace_all(age_cat5, \"years\", \"\"),   # \"year\"'ı kaldır\n          age_cat5 = str_replace_all(age_cat5, \"plus\", \"\"),    # \"plus\"'ı kaldır\n          age_cat5 = str_replace_all(age_cat5, \" \", \"\")) %>%   # \" \" boşluğu kaldır\n     \n     rename(pop = WorldStandardPopulation)   # dsr paketi tarafından tanınması için sütun adını \"pop\" olarak değiştir"},{"path":"standardize-edilmiş-hızlar.html","id":"standard_all","chapter":"21 Standardize edilmiş hızlar","heading":"Standart popülasyon ile veri tabanının oluşturulması","text":"Son olarak, aşağıda ayrıntıları verilen PHEindicatormethods paketi, ülke için gerçekleşen olay (ölüm), nüfus sayıları ve standart popülasyon verilerini istemektedir. Bu amaçla bir all_data veri tabanı oluşturacağız.Tam veri tabanı bu şekilde görülmektedir:","code":"\nall_data <- left_join(country_data, standard_pop_clean, by=c(\"age_cat5\", \"Sex\"))"},{"path":"standardize-edilmiş-hızlar.html","id":"dsr-paketi","chapter":"21 Standardize edilmiş hızlar","heading":"21.3 dsr paketi","text":"Aşağıda, dsr paketini kullanarak direkt standardize edilmiş hızları hesaplamayı ve karşılaştırmayı gösteriyoruz. dsr paketi, direkt standardize edilmiş hızları hesaplamanıza ve karşılaştırmanıza olanak tanır (indirekt standardize edilmiş oranlar yok!).Veri Hazırlama bölümünde ülkeler ve standart nüfus için ayrı ayrı veri tabanları oluşturduk:Ülke için tabaka başına nüfus ve ölüm sayısını içeren bir nüfus tablosu olan country_data nesnesiReferans popülasyonumuz olan World Standard Population için tabaka başına popülasyonu gösteren içeren standard_pop_clean nesnesiBu ayrı veri tabanlarını dsr yaklaşımı için kullanacağız.","code":""},{"path":"standardize-edilmiş-hızlar.html","id":"standardize-edilmiş-hızlar-1","chapter":"21 Standardize edilmiş hızlar","heading":"Standardize edilmiş hızlar","text":"Aşağıda, yaş ve cinsiyet için direkt standardize edilmiş oranları ülkeler için hesaplıyoruz. Bu işlem için dsr() fonksiyonunu kullanıyoruz.: dsr(), ülke popülasyonları ve olay sayıları (ölümler) için bir veri tabanı ve referans popülasyonu için ayrı bir veri tabanı bekler. Ayrıca bu referans popülasyon veri tabanında birim-zaman sütun adının “pop” olmasını bekler (bunu veri Hazırlama bölümünde sağladık)Aşağıdaki kodda görüldüğü gibi bu fonksiyon için birçok argüman vardır. Dikkat çekici bir şekilde, event = ölümler sütununa ve fu = (“follow ”- “takip”), Population sütununa ayarlanmıştır. Karşılaştırma alt gruplarını Country sütunu olarak belirledik ve age_cat5 ve Sex’e göre standardize ettik. Bu son iki sütuna belirli bir argüman atanmaz. Ayrıntılar için ?dsr komutuna bakınız.Yukarıda, ülkesinin B ülkesinden daha düşük bir kaba ölüm hızına sahip olduğunu, ancak yaş ve cinsiyet için direkt standardizasyon sonrası, ülkesinin daha yüksek bir standardize edilmiş hıza sahip olduğunu görüyoruz.","code":"\n# Yaş ve cinsiyet için direkt standardize edilmiş hızları ülke başına hesapla\nmortality_rate <- dsr::dsr(\n     data = country_data,  # tabaka başına ölüm sayısını içeren nesneyi belirt\n     event = Deaths,       # tabaka başına ölüm sayısını içeren sütun\n     fu = Population,      # tabaka başına nüfus sayısını içeren sütun\n     subgroup = Country,   # karşılaştırmak istediğimiz birimler\n     age_cat5,             # standardize etmek istediğimiz özellikler\n     Sex,\n     refdata = standard_pop_clean, # pop olarak adlandırılan sütundaki sayılarla referans popülasyonu\n     method = \"gamma\",      # 95% güven aralığını hesaplayan yöntem\n     sig = 0.95,            # anlamlılık düzeyi\n     mp = 100000,           # 100.000 kişilik nüfus başına hız istiyoruz\n     decimals = 2)          # ondalık basamak sayısı\n\n\n# Çıktıyı iyi görünen bir HTML tablosu olarak yazdır\nknitr::kable(mortality_rate) # direkt standardizasyondan önce ve sonra ölüm oranını göster"},{"path":"standardize-edilmiş-hızlar.html","id":"standardize-hız-oranları","chapter":"21 Standardize edilmiş hızlar","heading":"Standardize hız oranları","text":"Standardize ölüm oranı, ülkesinde B ülkesine kıyasla 1,22 kat daha yüksektir (%95 GA 1,17-1,27).","code":"\n# Calculate RR\nmortality_rr <- dsr::dsrr(\n     data = country_data, # tabaka başına ölüm sayısını içeren nesneyi belirt\n     event = Deaths,      # tabaka başına ölüm sayısını içeren sütun\n     fu = Population,     # tabaka başına nüfus sayısını içeren sütun\n     subgroup = Country,  # karşılaştırmak istediğimiz birimler\n     age_cat5,\n     Sex,                 # standardize istediğimiz özellikler\n     refdata = standard_pop_clean, # pop olarak adlandırılan sütundaki sayılarla referans popülasyonu\n     refgroup = \"B\",      # karşılaştırma için referans\n     estimate = \"ratio\",  # tahmin tipi\n     sig = 0.95,          # anlamlılık seviyesi\n     mp = 100000,         # 100.000 kişilik nüfus başına hız istiyoruz\n     decimals = 2)        # ondalık basamak sayısı\n\n# Tabloyu yazdır\nknitr::kable(mortality_rr) "},{"path":"standardize-edilmiş-hızlar.html","id":"standardize-hız-farkı","chapter":"21 Standardize edilmiş hızlar","heading":"Standardize hız farkı","text":"Ülkesi, B ülkesine kıyasla 100.000 nüfus başına 4.24 ek ölüme (%95 GA 3.24-5.24) sahiptir.","code":"\n# Calculate RD\nmortality_rd <- dsr::dsrr(\n     data = country_data,       # tabaka başına ölüm sayısını içeren nesneyi belirt\n     event = Deaths,            # tabaka başına ölüm sayısını içeren sütun \n     fu = Population,           # tabaka başına nüfus sayısını içeren sütun\n     subgroup = Country,        # karşılaştırmak istediğimiz birimler\n     age_cat5,                  # standardize istediğimiz özellikler\n     Sex,                        \n     refdata = standard_pop_clean, # pop olarak adlandırılan sütundaki sayılarla referans popülasyonu\n     refgroup = \"B\",            # karşılaştırma için referans\n     estimate = \"difference\",   # tahmin tipi\n     sig = 0.95,                # anlamlılık seviyesi\n     mp = 100000,               # 100.000 kişilik nüfus başına hız istiyoruz\n     decimals = 2)              # ondalık basamak sayısı\n\n# Tabloyu yazdır\nknitr::kable(mortality_rd) "},{"path":"standardize-edilmiş-hızlar.html","id":"standard_phe","chapter":"21 Standardize edilmiş hızlar","heading":"21.4 PHEindicatormethods paketi","text":"Standardize hızları hesaplamanın başka bir yolu da PHEindicatormethods paketidir. Bu paket, direkt ve indirekt olarak standardize edilmiş hızları hesaplamanıza olanak tanır. İkisini de göstereceğiz.Bu bölüm, Hazırlık bölümünün sonunda oluşturulan all_data veri tabanını kullanacaktır. Bu veri tabanı, ülke popülasyonlarını, ölüm olaylarını ve dünya için standart referans popülasyonu içerir. Burada görüntüleyebilirsiniz.","code":""},{"path":"standardize-edilmiş-hızlar.html","id":"direkt-standardize-edilmiş-hızlar","chapter":"21 Standardize edilmiş hızlar","heading":"Direkt standardize edilmiş hızlar","text":"Aşağıda, önce verileri ülkeye göre gruplandırıyoruz ve ardından ülke başına direkt standardize edilmiş hızları elde etmek için phe_dsr() fonksiyonuna aktarıyoruz.: Referans (standart) popülasyon, ülkeye özgü veri tabanında bir sütun olarak veya ayrı bir vektör olarak verilebilir. Ülkeye özel veri tabanı oluşturulduysa, stdpoptype= \"field\" olarak ayarlanmalıdır. Vektör olarak sağlanmışsa, stdpoptype = \"vector\" olarak ayarlanmalıdır. İkinci durumda, kayıtlar pozisyona göre eşleştirileceğinden, satırların tabaklara göre sıralamasının hem ülkeye özgü veri tabanında hem de referans popülasyonda benzer olduğundan emin olmalısınız. Aşağıdaki örneğimizde, ülkeye özgü veri tabanında bir sütun olarak referans popülasyon verilmiştir.Daha fazla bilgi için ?phr_dsr ile ilgili yardıma veya Referanslar bölümündeki bağlantılara bakabilirsiniz","code":"\n# yaş ve cinsiyet için direkt standardize edilmiş hızları ülke başına hesapla\nmortality_ds_rate_phe <- all_data %>%\n     group_by(Country) %>%\n     PHEindicatormethods::phe_dsr(\n          x = Deaths,                 # gözlemlenen olay sayısını içeren sütun\n          n = Population,             # her tabaka için standart olmayan nüfusu içeren sütunlar\n          stdpop = pop,               # her tabaka için standart popülasyonlar\n          stdpoptype = \"field\")       # bağımsız bir vektör için \"vector-vektör\" veya verilerde standart popülasyonların olduğu durumlarda \"field-alan\"\n\n# Tabloyu yazdır\nknitr::kable(mortality_ds_rate_phe)"},{"path":"standardize-edilmiş-hızlar.html","id":"standard_indirect","chapter":"21 Standardize edilmiş hızlar","heading":"İndirekt standardize edilmiş hızlar","text":"İnidirekt standardizasyon için, tabaka başına ölüm sayısı, nüfus ve bir referans popülasyona ihtiyacınız vardır. Bu örnekte, standart_pop_clean referans popülasyonu tabaka başına ölüm sayısını içermediğinden, B ülkesini referans popülasyon olarak kullanarak ülkesi için hızları hesaplayacağız.Aşağıda, önce B ülkesinden referans popülasyonu oluşturuyoruz. Ardından, ülkesi için ölüm ve nüfus verilerini çıkarıyoruz, bu verileri referans popülasyonla birleştiriyoruz ve indirekt standardize edilmiş hızları elde etmek için phe_isr() fonksiyonuna aktarıyoruz. Tabii ki, bunun tersini de yapabilirsiniz.: Aşağıdaki örneğimizde, referans popülasyonu ayrı bir veri tabanı olarak verilmiştir. Bu durumda, kayıtlar pozisyona göre eşleştirileceğinden, x =, n =, x_ref = ve n_ref = vektörlerinin tümünün, ülkemize özgü veri tabanıyla aynı standardizasyon kategorisi (tabaka) değerlerine göre sıralandığından emin oluruz.Daha fazla bilgi için ?phr_isr komutu ile ilgili yardıma veya Referanslar bölümündeki bağlantılara bakın.","code":"\n# Referans popülasyonu oluştur\nrefpopCountryB <- country_data %>% \n  filter(Country == \"B\") \n\n# A ülkesi için yaş ve cinsiyete göre indirekt standardize edilmiş hızları hesapla\nmortality_is_rate_phe_A <- country_data %>%\n     filter(Country == \"A\") %>%\n     PHEindicatormethods::phe_isr(\n          x = Deaths,                 # gözlemlenen olay sayısını içeren sütun\n          n = Population,             # her tabaka için standardize edilmemiş popülasyonu içeren sütunlar\n          x_ref = refpopCountryB$Deaths,  # her tabaka için referans ölüm sayısı\n          n_ref = refpopCountryB$Population)  # her tabaka için referans popülasyon\n\n# Tabloyu yazdır\nknitr::kable(mortality_is_rate_phe_A)"},{"path":"standardize-edilmiş-hızlar.html","id":"kaynaklar-14","chapter":"21 Standardize edilmiş hızlar","heading":"21.5 Kaynaklar","text":"dsr paketini kullanarak başka bir tekrarlanabilir örnek görmek isterseniz, lütfen bu skece bakın.PHEindicatormethods paketini kullanan başka bir örnek için lütfen bu web sitesine gidin.PHEindicatormethods referans pdf dosyasına bakın.","code":""},{"path":"hareketli-ortalamalar.html","id":"hareketli-ortalamalar","chapter":"22 Hareketli ortalamalar","heading":"22 Hareketli ortalamalar","text":"Bu sayfa, hareketli ortalamaları hesaplamak ve görselleştirmek için iki yöntemi kapsayacaktır:slider paketi ile hesaplama**tidyquant* paketi ile ggplot() komutu içinde hesaplama","code":""},{"path":"hareketli-ortalamalar.html","id":"hazırlık-13","chapter":"22 Hareketli ortalamalar","heading":"22.1 Hazırlık","text":"","code":""},{"path":"hareketli-ortalamalar.html","id":"paketleri-yükleme-6","chapter":"22 Hareketli ortalamalar","heading":"Paketleri yükleme","text":"Bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini göstermektedir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’ın p_load() fonksiyonunu öneriyoruz. Ayrıca, R tabanından library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] sayfasına bakın.","code":"\npacman::p_load(\n  tidyverse,      # verinin yönetimi ve görselleştirilmesi için\n  slider,         # hareketli ortalamaları hesaplamak için\n  tidyquant       # ggplot içinde hareketli ortalamaları hesaplamak için\n)"},{"path":"hareketli-ortalamalar.html","id":"verinin-içe-aktarımı","chapter":"22 Hareketli ortalamalar","heading":"Verinin içe aktarımı","text":"Simüle edilmiş Ebola salgını vakalarını içeren veri setini içe aktarıyoruz. Takip etmek istiyorsanız, “temiz” satır listesini (.rds dosyası olarak) indirmek için tıklayın. rio paketinden import() fonksiyonu ile verileri içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için İçe Aktarma ve Dışa Aktarma sayfasına bakın).Satır listesinin ilk 50 satırı aşağıda görüntülenir.","code":"\n# satır listesini içe aktar\nlinelist <- import(\"linelist_cleaned.xlsx\")"},{"path":"hareketli-ortalamalar.html","id":"slider-ile-hesaplama","chapter":"22 Hareketli ortalamalar","heading":"22.2 slider ile hesaplama","text":"Grafik haline getirmeden önce bir veri çerçevesinde hareketli ir ortalama hesaplamak için bu yaklaşımı kullanın.slider paketi, yuvarlanan ortalamaları, kümülatif toplamları, yuvarlanan regresyonları vb. hesaplamak için “kayan pencere” fonksiyonu içerir. Bir veri çerçevesini bir satır vektörü olarak ele alır ve bir veri çerçevesi üzerinde satır bazında yinelemelere izin verir.Ortak fonksiyonlardan bazıları:slide_dbl() - kayan pencere kullanarak işlem gerçekleştiren sayısal bir sütunu yineler (dolayısıyla “_dbl”)\nslide_sum() - slide_dbl() için yuvarlanan toplam kısayol fonksiyonu\nslide_mean() - slide_dbl() için yuvarlanan ortalama kısayol fonksiyonu\nslide_sum() - slide_dbl() için yuvarlanan toplam kısayol fonksiyonuslide_mean() - slide_dbl() için yuvarlanan ortalama kısayol fonksiyonuslide_index_dbl() - pencere ilerlemesini indekslemek için ayrı bir sütun kullanarak; yuvarlanan pencereyi sayısal bir sütuna uygular (bazı tarihler eksikken tarihe göre yuvarlanıyorsa kullanışlıdır)\nslide_index_sum() - indeksleme ile birlikte yuvarlanan toplam kısayol fonksiyonu\nslide_index_mean() - indekslemeli yuvarlanan ortalama kısayol fonksiyonu\nslide_index_sum() - indeksleme ile birlikte yuvarlanan toplam kısayol fonksiyonuslide_index_mean() - indekslemeli yuvarlanan ortalama kısayol fonksiyonuslider paketi, bu sayfada Kaynaklar bölümünde ele alınan birçok başka fonkisyona da sahiptir. En yaygın olanlara kısaca değineceğiz.Temel argümanlarVarsayılan ilk argüman olan .x, yinelenecek ve fonksiyonu uygulayacak vektördür..= slider fonksiyonların “indeks” versiyonları için - geçişi “indekslemek” için bir sütun oluşturur aşağıdaki bölüme bakın).f =, varsayılan ikinci argüman;\nOrtalama gibi parantezsiz yazılmış bir fonksiyon veya\nBir fonksiyona dönüştürülecek bir formül. Örneğin ~ .x - ortalama(.x), mevcut değerden pencerenin değerinin ortalamasını hesaplar ve elde edilen sonucu sunar.\nOrtalama gibi parantezsiz yazılmış bir fonksiyon veyaBir fonksiyona dönüştürülecek bir formül. Örneğin ~ .x - ortalama(.x), mevcut değerden pencerenin değerinin ortalamasını hesaplar ve elde edilen sonucu sunar.Daha fazla ayrıntı için bu kaynak materyaline bakınPencere büyüklüğü., .veya iki argümanı kullanarak pencerenin boyutunu belirtin:.= - Bir tamsayı verin.= - Bir tamsayı verin.complete = - Yalnızca eksiksiz pencerelerde hesaplama yapılmasını istiyorsanız bunu DOĞRU olarak ayarlayınÖrneğin, mevcut değeri ve önceki altı değeri içeren 7 günlük bir pencere elde etmek için .= 6 argümanını kullanın. “Ortalanmış” bir pencere elde etmek için hem .= hem de .= için aynı sayıyı sağlayın.Varsayılan olarak, .complete = FALSE olarak kodlanmıştır, bu nedenle tam satır penceresi mevcut değilse, fonksiyonlar hesaplamayı gerçekleştirmek için mevcut satırları kullanacaktır. Bu argümanı DOĞRU olarak ayarlamak, hesaplamaların yalnızca eksiksiz pencerelerde gerçekleştirilmesini sağlar.Pencerenin genişletilmesiKümülatif işlemleri gerçekleştirmek için, .= argümanını Inf olarak ayarlayın. Bu argüman, işlemi mevcut değerde ve daha önceki değerlerde yürütecektir.","code":""},{"path":"hareketli-ortalamalar.html","id":"roll_index","chapter":"22 Hareketli ortalamalar","heading":"Tarihe göre yuvarlama","text":"Uygulamalı epidemiyolojide yuvarlanan hesaplamanın en olası kullanım durumu, zaman içinde değişim gösteren bir ölçümün incelenmesidir (Örnek: Günlük vaka sayılarına dayalı olarak vaka insidansının yuvarlanan bir ölçümü)tarih için değer içeren temiz bir zaman serisi veriniz varsa, burada Zaman Serisi ve Salgın Tespiti sayfasında gösterildiği gibi slide_dbl() fonksiyonunu kullanabilirsiniz.Bununla birlikte, birçok epidemiyoloji uygulamasında, kaydedilen hiçbir olayın gerçekleşmediği, verilerinizde eksik tarihler olabilir. Bu durumlarda, slider fonksiyonların “indeks” sürümlerini kullanmak doğrudur.","code":""},{"path":"hareketli-ortalamalar.html","id":"indekslenmiş-veri","chapter":"22 Hareketli ortalamalar","heading":"İndekslenmiş veri","text":"Aşağıda, vaka satır listesinde slide_index_dbl() fonksiyonunu kullanan bir örnek gösterilmiştir. Diyelim ki hedefimiz 7 günlük bir insidansı hesaplamak (7 günlük bir pencere kullanarak vakaların toplamını göstermek). Yuvarlanan ortalama örneği için, gruplandırılmış yuvarlanma ile ilgili aşağıdaki bölüme bakın.Başlamak için, dplyr’den count() fonksiyonu ile hesaplandığı gibi, satır listesinde günlük vaka sayılarını göstermek için daily_counts veri kümesi oluşturulur.daily_counts veri çerçevesinden nrow(daily_counts) satır elde edilebilir. Günlük vaka sayısında gün bir satırla temsil edilmektedir, ancak özellikle salgının başlarında bazı günler mevcut değil (o günlerde vaka tespit edilmemiştir).Standart bir yuvarlanma işlevinin (slide_dbl() gibi) 7 günlük değil 7 satırlık bir pencere kullanacağını bilmek önemlidir. Dolayısıyla, eksik tarihler varsa, bazı pencereler aslında 7 takvim gününden daha fazla uzatılacaktır!slide_index_dbl() ile “akıllı” bir yuvarlanma penceresi elde edilebilir. “İndeks”, işlevin yuvarlanan pencere için “indeks” olarak alacağı ayrı bir sütun kullandığı anlamına gelir. Pencere sadece veri çerçevesinin satırlarına bağlı değildir.İndeks sütunu bir tarihse, pencere içeriğini lubridate days() veya month() fonksiyonları ile .= ve/veya .= olarak belirtebilirsiniz. Bu durumda fonksiyon, pencerede olmayan günleri sanki oradaymış gibi (NA değerleri olarak) kabul edecektir.Bir karşılaştırma gösterilirse. Aşağıda, düzenli ve indekslenmiş pencerelerle 7 günlük vaka insidansını hesaplıyoruz.İlk 7 satır için normal sütunda, satırlar birbirine için 7 günlük aralık içinde olmamasına rağmen istikrarlı artışı gözlemleyin! Komşu “indekslenmiş” sütun, eksik takvim günlerini de hesaba katar, bu nedenle 7 günlük toplamları, vakaların birbirlerinden daha uzak zamanlarda görüldüğü salgın döneminde çok daha düşüktür.Bu veri, ggplot() fonksiyonu kullanılarak grafik haline getirilebilir.","code":"\n# günlük sayımların veri kümesini oluştur\ndaily_counts <- linelist %>% \n  count(date_hospitalisation, name = \"new_cases\")\nrolling <- daily_counts %>% \n  mutate(                                # yeni sütunlar oluştur\n    # Using slide_dbl()\n    ###################\n    reg_7day = slide_dbl(\n      new_cases,                         # new_cases üzerinde hesapla\n      .f = ~sum(.x, na.rm = T),          # fonksiyon, eksik değerler kaldırılmış sum() işlemidir\n      .before = 6),                      # pencere mevcut SATIR ve 6 önceki SATIR\n    \n    # slide_index_dbl() kullanımı\n    #########################\n    indexed_7day = slide_index_dbl(\n        new_cases,                       # new_cases üzerinde hesapla\n        .i = date_hospitalisation,       # date_onset ile indekse eklenme \n        .f = ~sum(.x, na.rm = TRUE),     # fonksiyon, eksik değerlerin olmadığı sum() işlevidir\n        .before = days(6))               # pencere mevcut GÜN ve 6 önceki GÜN\n    )\nggplot(data = rolling)+\n  geom_line(mapping = aes(x = date_hospitalisation, y = indexed_7day), size = 1)"},{"path":"hareketli-ortalamalar.html","id":"roll_slider_group","chapter":"22 Hareketli ortalamalar","heading":"Gruba göre yuvarlanma","text":"slider fonksiyonlarını kullanmadan önce verilerinizi gruplandırırsanız, kayan pencereler grup olarak uygulanacaktır. Satırlarınızı grup bazında istediğiniz sıraya göre düzenlemeye özen gösteriniz.yeni grup başladığında, kayan pencere yeniden başlayacaktır. Bu nedenle, bilinmesi gereken bir ayrıntı vardır. Verileriniz gruplandırılmışsa ve .complete = TRUE olarak ayarladıysanız, gruplar arasındaki geçişte boş değerler elde edersiniz. Fonksiyon satırlar arasında aşağı doğru hareket ettikçe, gruplandırma sütunundaki geçiş, hesaplamaya izin vermek için minimum pencere boyutunun oluşturulma sürecini yeniden başlatacaktır.Verileri gruplandırmayla ilgili ayrıntılar için [Verilerin Gruplandırılması] ile ilgili el kitabı sayfasına bakın.Aşağıda, listedeki vakaları tarihe ve hastaneye göre sayıyoruz. Daha sonra sıraları artan şekilde, önce hastaneye göre sonra da tarihe göre sıralamaktayız. Sonrasında group_by() fonksiyonunu ayarlıyoruz. Ardından yeni yuvarlanan ortalamamızı oluşturabiliriz.İşte yeni veri seti:Artık ggplot() içinde ~ hastaneyi - hospital facet_wrap() içinde belirterek verileri grup bazında görüntüleyerek hareketli ortalamaları çizebiliriz. Burada iki şekil oluşturuyoruz - günlük vaka sayılarını gösteren bir geom_col() ve 7 günlük hareketli ortalamayı gösteren bir geom_line().**TEHLİKE:_** “slide() tsibble 0.9.0’da kullanımdan kaldırılmıştır ve artık geçersizdir” şeklinde bir hata alırsanız, lütfen bunun yerine slider::slide() kullanın. Bu, tsibble paketindeki slide() fonksiyonunun, slider paketindeki slide() fonksiyonunu maskelediği anlamına gelir. Slider::slide_dbl() şekklinde komutunuzda paketi belirterek bu hatayı düzeltin.","code":"\ngrouped_roll <- linelist %>%\n\n  count(hospital, date_hospitalisation, name = \"new_cases\") %>% \n\n  arrange(hospital, date_hospitalisation) %>%   # satırları hastaneye ve ardından tarihe göre düzenle\n  \n  group_by(hospital) %>%              # hastaneye göre grupla\n    \n  mutate(                             # yuvarlanan ortalama  \n    mean_7day_hosp = slide_index_dbl(\n      .x = new_cases,                 # hastane-gün başına vaka sayısı\n      .i = date_hospitalisation,      # giriş tarihi indeksi\n      .f = mean,                      # mean() kullanımı                  \n      .before = days(6)               # mevcut günü ve önceki 6 günü kullan\n      )\n  )\nggplot(data = grouped_roll)+\n  geom_col(                       # günlük vaka sayılarını gri çubuklar olarak çiz\n    mapping = aes(\n      x = date_hospitalisation,\n      y = new_cases),\n    fill = \"grey\",\n    width = 1)+\n  geom_line(                      # hastaneye göre renklendirilen çizgi olarak yuvarlanan ortalama grafiği\n    mapping = aes(\n      x = date_hospitalisation,\n      y = mean_7day_hosp,\n      color = hospital),\n    size = 1)+\n  facet_wrap(~hospital, ncol = 2)+ # hastane başına mini grafikler oluştur\n  theme_classic()+                 # arka planı basitleştir  \n  theme(legend.position = \"none\")+ # çizelgeyi (legend) kaldır\n  labs(                            # grafik etiketlerini ekle\n    title = \"7-day rolling average of daily case incidence\",\n    x = \"Date of admission\",\n    y = \"Case incidence\")"},{"path":"hareketli-ortalamalar.html","id":"ggplot-içinde-tidyquant-hesabı","chapter":"22 Hareketli ortalamalar","heading":"22.3 ggplot() içinde tidyquant hesabı","text":"tidyquant paketi, bir ggplot() komutunun içinde hareketli ortalamaları hesaplamak için başka bir yaklaşım sunar.Satır listesinin altındaki veriler, başlangıç tarihine göre sayılır ve soluk bir çizgi (alpha < 1) olarak çizilir. Üstte, tidyquant paketinden geom_ma() ile oluşturulan, belirtilen renk ve kalınlıkta 7 günlük (n = 7) pencereli bir satır yer alır.Varsayılan olarak geom_ma() basit hareketli ortalama kullanır (ma_fun = \"SMA\"), ancak başka türler de belirtilebilir, örneğin:“EMA” - üstel hareketli ortalama (son gözlemlere daha fazla ağırlık verilir)“WMA” - ağırlıklı hareketli ortalama (ağırlık, hareketli ortalamadaki gözlemleri ağırlıklandırmak için kullanılır)Diğerleri fonksiyon belgelerinde bulunabilirtidyquant’ta bulunan seçenekler hakkında daha fazla ayrıntı için bu skece bakın.","code":"\nlinelist %>% \n  count(date_onset) %>%                 # gün başına vaka sayımı\n  drop_na(date_onset) %>%               # başlangıç tarihi eksik vakaları kaldır\n  ggplot(aes(x = date_onset, y = n))+   # ggplot’u başlat\n    geom_line(                          # ham değerleri çiz\n      size = 1,\n      alpha = 0.2                       # yarı şeffaf çizgi\n      )+             \n    tidyquant::geom_ma(                 # hareketli ortalama grafiği çiz\n      n = 7,           \n      size = 1,\n      color = \"blue\")+ \n  theme_minimal()                       # sade arka plan"},{"path":"hareketli-ortalamalar.html","id":"kaynaklar-15","chapter":"22 Hareketli ortalamalar","heading":"22.4 Kaynaklar","text":"slider paketi için yararlı çevrimiçi skeçslider github sayfasıslider skecitidyquant skeciHafta sonlarını ve tatilleri “atlamanızı” gerekiyorsa, almanac paketini kullabilirsiniz.","code":""},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"zaman-serileri-ve-salgınların-tespit-edilmesi","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"23 Zaman serileri ve salgınların tespit edilmesi","text":"","code":""},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"genel-bakış-2","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"23.1 Genel bakış","text":"Bu sekme, zaman serisi analizi için gereken birkaç paketin kullanımını göstermektedir. Bu tip analizler öncelikle tidyvers tidyverts ailesinden gelen paketlerle yapılır, ancak bulaşıcı hastalık epidemiyolojisi için daha uygun olan RECON trend paketini trending de kullanır.Aşağıdaki örnekte, Almanya’da hazırlanmış Campylobacter bir veri setini kullandığımıza dikkat edin (ayrıntılar için el kitabının veri bölümüne bakabilirsiniz). Ancak, aynı kodu birden fazla ülke veya başka tabakalar içeren bir veritabanlarında çalıştırmak istiyorsanız, r4epis github deposunda örnek bir kod şablonu bulunmaktadır.r4epis github repo.Kapsanan konular:Zaman serisi verileriTanımlayıcı analizUyum (fitting) regresyonlarıİki zaman serisinin ilişkisiSalgın tespitiKesintili zaman serisi","code":""},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"hazırlık-14","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"23.2 Hazırlık","text":"","code":""},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"paketler-1","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"Paketler","text":"Bu kod kümesi, analizler için gereken paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’ın p_load() fonksiyonunu vurguluyoruz. Ayrıca temel R’dan library() ile paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R temelleri sayfasına bakın. R temelleri","code":"\npacman::p_load(rio,          # Dosyanın içe aktarılması\n               here,         # Dosyanın yerinin bulunması\n               tidyverse,    # veri yönetimi + ggplot2 grafikleri\n               tsibble,      # zaman serisi veri tabanlarını işlemek\n               slider,       # hareketli ortalamaları hesaplamak için\n               imputeTS,     # eksik değerleri doldurmak için\n               feasts,       # zaman serilerinde ayrıştırma ve otokorelasyon için\n               forecast,     # sin ve cosin terimlerini verilere uydurun (not: feasts sonrası yüklenmelidir)\n               trending,     # model oluştur ve değerlendir\n               tmaptools,    # yer adlarına göre coğrafi koordinatları (boylam/enlem) almak için\n               ecmwfr,       # copernicus uydu CDS API ile etkileşim için\n               stars,        # .nc (iklim verileri) dosyalarını okumak için\n               units,        # for defining units of measurement (climate data)\n               yardstick,    # model doğruluğuna bakmak için\n               surveillance  # sapma tespiti için\n               )"},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"veri-yükleme","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"Veri yükleme","text":"Bu el kitabında kullanılan tüm verileri, [el kitabının ve verilerin indirilmesi] sayfasındaki talimatlar aracılığıyla indirebilirsiniz.Bu bölümde kullanılan örnek veri seti, 2001 ve 2011 yılları arasında Almanya’da rapor edilen haftalık kampilobakter vaka sayılarıdır. Bu veri dosyasını (.xlsx) indirmek için buraya tıklayabilirsiniz.(.xlsx) olarak görülecektir.Bu veri seti, surveillance paketinde bulunan veri setinin küçültülmüş bir versiyonudur. (detaylar için surveillance paketini yükleyin ve bkz. ?campyDE) surveillanceBu verileri rio paketinden import() fonksiyonu ile içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe Aktarma ve Dışa Aktarma] sayfasına bakın).Sayımların ilk 10 satırı aşağıda gösterilmiştir","code":"\n# sayımları R'ye aktar\ncounts <- rio::import(\"campylobacter_germany.xlsx\")"},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"temiz-veri-1","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"Temiz veri","text":"Aşağıdaki kod, tarih sütununun uygun biçimde olmasını sağlar. Bu sekme için tsibble paketini kullanacağız ve bu nedenle bir takvim haftası değişkeni oluşturmak için yearweek fonksiyonu kullanılacaktır. Bunu yapmanın başka yolları da vardır (ayrıntılar için Tarihlerle çalışma sayfasına bakın), ancak zaman serileri için en iyisi tarihleri tek bir çerçeve (tsibble) içinde tutmaktır.","code":"\n## tarih sütununun uygun biçimde olduğundan emin olun\ncounts$date <- as.Date(counts$date)\n\n## bir takvim haftası değişkeni oluşturun\n## Pazartesi gününden başlayarak haftaların ISO tanımlarına uyumlu hale getirilmesi\ncounts <- counts %>% \n     mutate(epiweek = yearweek(date, week_start = 1))"},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"iklim-verisinin-indirilmesi","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"İklim verisinin indirilmesi","text":"Bu sayfanın iki zaman serisi bölümünde, kampilobakter vaka sayılarını iklim verileriyle karşılaştıracağız.\nDünyanın herhangi bir yerindeki iklim verileri AB’nin Copernicus Uydusundan indirilebilir.Bunlar kesin ölçümler değildir, ancak bir modele dayalıdır (interpolasyona benzer), tahminlerin yanı sıra küresel saatlik bilgi kapsamı elde edilebilir.Bu iklim veri dosyalarının birini [el kitabının ve verilerin indirilmesi] sayfasından indirebilirsiniz.Burada gösterim amacıyla, verileri Copernicus iklim veri deposundan çekmek için ecmwfr paketini kullanmak için gereken R kodunu tanıtacağız. Bunun çalışması için ücretsiz bir hesap oluşturmanız gerekecektir. Paketin web sitesinde bunun nasıl yapılacağına dair yararlı bir yol gösterilmiştirwalkthrough.Aşağıda, uygun API anahtarlarına sahip olduğunuzda, bunun nasıl yapılacağına ilişkin örnek kod verilmiştir. Aşağıdaki X’leri hesap kimliklerinizle değiştirmeniz gerekir. seferinde bir yıllık veri indirmeniz gerekir, aksi takdirde sunucu zaman aşımına uğrayacaktır.Verilerini indirmek istediğiniz konumun koordinatlarından emin değilseniz, açık sokak haritalarından koordinatları almak için tmaptools paketini kullanabilirsiniz. Alternatif bir seçenek photon paketidir,photon ancak bu henüz CRAN’da yayınlanmamıştır; photon’un güzel yanı, aramanız için birkaç eşleşme olduğunda daha fazla bağlamsal veri sağlamasıdır.","code":"\n## konum koordinatlarını al\ncoords <- geocode_OSM(\"Germany\", geometry = \"point\")\n\n## ERA-5 sorgulaması için boylamları/enlemleri bir araya getirin (sınırlayıcı kutu)\n## (tek bir noktanın koordinatlarının tekrar edebileceği gibi)\nrequest_coords <- str_glue_data(coords$coords, \"{y}/{x}/{y}/{x}\")\n\n\n## Kopernik uydusundan modellenen verileri çekme (ERA-5 yeniden analizi)\n## https://cds.climate.copernicus.eu/cdsapp#!/software/app-era5-explorer?tab=app\n## https://github.com/bluegreen-labs/ecmwfr\n\n## hava durumu verileri için anahtar ayarla\nwf_set_key(user = \"XXXXX\",\n           key = \"XXXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXX\",\n           service = \"cds\") \n\n## ilgilenilen her yıl için çalıştırın (aksi takdirde sunucu zaman aşımına uğrar)\nfor (i in 2002:2011) {\n  \n  ## sorguyu bir araya getir\n  ## nasıl yapılacağı için buraya bakın: https://bluegreen-labs.github.io/ecmwfr/articles/cds_vignette.html#the-request-syntax\n  ## yukarıdaki eklenti düğmesini kullanarak isteği bir listeye dönüştürün (listeye python)\n  ## Hedef, çıktı dosyasının adıdır!\n\n  request <- request <- list(\n    product_type = \"reanalysis\",\n    format = \"netcdf\",\n    variable = c(\"2m_temperature\", \"total_precipitation\"),\n    year = c(i),\n    month = c(\"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"10\", \"11\", \"12\"),\n    day = c(\"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"10\", \"11\", \"12\",\n            \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\",\n            \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\"),\n    time = c(\"00:00\", \"01:00\", \"02:00\", \"03:00\", \"04:00\", \"05:00\", \"06:00\", \"07:00\",\n             \"08:00\", \"09:00\", \"10:00\", \"11:00\", \"12:00\", \"13:00\", \"14:00\", \"15:00\",\n             \"16:00\", \"17:00\", \"18:00\", \"19:00\", \"20:00\", \"21:00\", \"22:00\", \"23:00\"),\n    area = request_coords,\n    dataset_short_name = \"reanalysis-era5-single-levels\",\n    target = paste0(\"germany_weather\", i, \".nc\")\n  )\n  \n # dosyayı indirin ve mevcut çalışma dizininde saklayın\n  file <- wf_request(user     = \"XXXXX\",  # kullanıcı ID (kimlik doğrulama için)\n                     request  = request,  # istek\n                     transfer = TRUE,     # dosyayı indir \n                     path     = here::here(\"data\", \"Weather\")) ## dosyayı kaydetmek için yolak\n  }"},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"iklim-verisinin-yüklenmesi","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"İklim verisinin yüklenmesi","text":"İster iklim verilerini el kitabımız üzerinden indirmiş olun, ister yukarıdaki kodu kullanmış olun, artık bilgisayarınızda aynı klasörde saklanan 10 yıllık “.nc” iklim veri dosyalarına sahip olmalısınız.Bu dosyaları stars paketiyle R’aktarmak için aşağıdaki kodu kullanın.Bu dosyalar nesne verisi olarak içe aktarıldıktan sonra onları bir veri çerçevesine dönüştüreceğiz.","code":"\n## hava durumu klasörüne giden yolu tanımlayın \nfile_paths <- list.files(\n  here::here(\"data\", \"time_series\", \"weather\"), # replace with your own file path \n  full.names = TRUE)\n\n## sadece şu anki ilgi alanına sahip olanları saklayın\nfile_paths <- file_paths[str_detect(file_paths, \"germany\")]\n\n## tüm dosyaları stars nesnesi olarak oku\ndata <- stars::read_stars(file_paths)## t2m, tp, \n## t2m, tp, \n## t2m, tp, \n## t2m, tp, \n## t2m, tp, \n## t2m, tp, \n## t2m, tp, \n## t2m, tp, \n## t2m, tp, \n## t2m, tp,\n## veri çerçevesine değiştir\ntemp_data <- as_tibble(data) %>% \n  ## değişkenler ekleyin ve birimleri düzeltin\n  mutate(\n    ## takvim haftası değişkeni oluşturun\n    epiweek = tsibble::yearweek(time), \n    ## tarih değişkeni oluşturun (takvim haftasının başlangıcı)\n    date = as.Date(epiweek),\n    ## sıcaklığı kelvin'den santigrat dereceye değiştir\n    t2m = set_units(t2m, celsius), \n    ## yağışı metreden milimetreye değiştir\n    tp  = set_units(tp, mm)) %>% \n  ## haftaya göre gruplandır (tarihi de sakla)\n  group_by(epiweek, date) %>% \n  ## haftalık ortalamanın özetlenmesi\n  summarise(t2m = as.numeric(mean(t2m)), \n            tp = as.numeric(mean(tp)))## `summarise()` has grouped output by 'epiweek'. You can override using the `.groups` argument."},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"zaman-serisi-verisi","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"23.3 Zaman serisi verisi","text":"Zaman serisi verilerini yapılandırmak ve işlemek için bir dizi farklı paket vardır. Bahsedildiği gibi, tidyverts paket ailesine odaklanacağız ve bu nedenle zaman serisi nesnemizi tanımlamak için tsibble paketini kullanacağız. Zaman serisi nesnesi olarak tanımlanan bir veri setine sahip olmak, analizimizi yapılandırmanın çok daha kolay olduğu anlamına gelir.Bunu yapmak için tsibble() fonksiyonunu kullanırız ve “indeks”, yani ilgilenilen zaman birimini belirten değişkeni belirtiriz. Bizim durumumuzda bu, epiweek değişkenidir.Örneğin, il bazında haftalık sayıları olan bir veri setimiz olsaydı, key = değişkenini kullanarak gruplama değişkenini de belirleyebilirdik. Bu, grup için analiz yapmamızı sağlar.class(counts)’baktığınızda, düzenli bir veri çerçevesi (“tbl_df”, “tbl”, “data.frame”) olmanın yanı sıra, bir zaman serisi veri çerçevesinin (“tbl_ts”) ek özelliklerine sahip olduğunu gösterir.ggplot2 kullanarak verilerinize hızlıca göz atabilirsiniz. Olay örgüsünde net bir mevsimsel motif olduğunu ve eksik veri olmadığını görüyoruz. Ancak, yılın başında raporlama ile ilgili bir sorun var gibi görünüyor; vakalar yılın son haftasında düşmekte ve sonraki yılın ilk haftasında artmaktadır.TEHLİKE: Çoğu veri kümesi bu örnek kadar temiz değildir. Aşağıdaki gibi duplikasyonları ve eksikleri kontrol etmeniz gerekecektir. ","code":"\n## zaman serisi nesnesini tanımla\ncounts <- tsibble(counts, index = epiweek)\n## haftaya göre vakaların bir çizgi grafiğini çizin\nggplot(counts, aes(x = epiweek, y = case)) + \n     geom_line()"},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"duplikasyonlar","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"Duplikasyonlar","text":"tsibble yinelenen gözlemlere izin vermez. Bu nedenle, satırın benzersiz veya (anahtar değişkene göre) grup içinde benzersiz olması gerekir. Paket, kopyaları tanımlamaya yardımcı olan birkaç işleve sahiptir. Bunlar, satırın bir kopya olup olmadığına dair bir DOĞRU/YANLIŞ vektörü veren are_duplicated() ve size duplike satırların veri çerçevesini veren duplicates() fonksiyonlarını içerir.İstediğiniz satırları nasıl seçeceğinizle ilgili daha fazla ayrıntı için Tekilleştirme (De-duplikasyon) sayfasına bakabilirsiniz. Tekilleştirme","code":"\n## satırların kopya olup olmadığını DOĞRU/YANLIŞ vektörü olarak çıkarın\nare_duplicated(counts, index = epiweek) \n\n## yinelenen satırların veri çerçevesini çıkarın\nduplicates(counts, index = epiweek) "},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"eksikler","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"Eksikler","text":"Yukarıdaki kısa incelememizde hiçbir eksik olmadığını gördük, ancak yeni yıl civarında raporlama gecikmesinde bir sorun olduğunu da gördük. Bu sorunu çözmenin bir yolu, bu değerleri eksik olarak ayarlamak ve ardından değerleri atfetmek olabilir. Zaman serisi atamasının en basit şekli, en son kayıp olmayan ve bir sonraki kayıp olmayan değer arasına düz bir çizgi çizmektir. Bunu yapmak için imputeTS paketinden na_interpolation() fonksiyonunu kullanacağız.Tahmin için değerler atamada diğer seçenekler için Eksik veri sayfasına bakabilirsiniz.Diğer bir alternatif, hareketli ortalama hesaplamak, belirgin raporlama sorunlarını denemek ve düzeltmek olabilir (bir sonraki bölüme ve Hareketli ortalamalar sayfasına bakın)Hareketli ortalamalar).","code":"\n## raporlama sorunları olan haftalar yerine eksikleri olan bir değişken oluşturun\ncounts <- counts %>% \n     mutate(case_miss = if_else(\n          ## epiweek 52, 53, 1 veya 2 içeriyorsa\n          str_detect(epiweek, \"W51|W52|W53|W01|W02\"), \n          ## sonrasında eksik olarak ayarlayın\n          NA_real_, \n          ## aksi takdirde değeri saklayın\n          case\n     ))\n\n## alternatif olarak eksikleri doğrusal trendle interpolasyon yapın\n## en yakın iki bitişik nokta arasında\ncounts <- counts %>% \n  mutate(case_int = imputeTS::na_interpolation(case_miss)\n         )\n\n## orijinaline kıyasla hangi değerlerin atfedildiğini (impute) kontrol etmek için\nggplot_na_imputations(counts$case_miss, counts$case_int) + \n  ## geleneksel bir grafik oluşturun (siyah eksenli ve beyaz arka planlı)\n  theme_classic()"},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"tanımlayıcı-analizler","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"23.4 Tanımlayıcı analizler","text":"","code":""},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"timeseries_moving","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"Hareketli ortalamalar","text":"Veriler çok gürültülüyse (yukarı ve aşağı atlamalar sayılır), hareketli bir ortalama hesaplamak yardımcı olabilir. Aşağıdaki örnekte, hafta için önceki dört haftadaki ortalama vaka sayısını hesaplıyoruz. Bu hesap ile, verilerin daha yorumlanabilir hale gelmesi için düzeltme yapılır. Örneğimiz için bu düzeltmenin faydası kısıtlıdır, bu yüzden daha fazla analiz için interpolasyonlu verilere bağlı kalınacaktuır. Daha fazla ayrıntı için Hareketli ortalamalar sayfasına bakın. Hareketli ortalamalar.","code":"\n## hareketli bir ortalama değişkeni oluşturun (eksiklerle ilgilenilecektir)\ncounts <- counts %>% \n     ## ma_4w değişkenini oluştur\n     ## case değişkeninin her satırının üzerine kaydırın\n     mutate(ma_4wk = slider::slide_dbl(case, \n                               ## her satır için ad hesapla\n                               ~ mean(.x, na.rm = TRUE),\n                               ## önceki dört haftayı kullan\n                               .before = 4))\n\n## farkını hızla görselleştirin \nggplot(counts, aes(x = epiweek)) + \n     geom_line(aes(y = case)) + \n     geom_line(aes(y = ma_4wk), colour = \"red\")"},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"periyodisite","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"Periyodisite","text":"Aşağıda bir periodogram oluşturmak için özel bir fonksiyon tanımlıyoruz. R’de fonksiyonların nasıl yazılacağı hakkında bilgi için Fonksiyon yazma sayfasına bakın.İlk olarak fonksiyon tanımlanır. Fonksiyonun argümanları, sütun sayıları olan bir veri tabanını, veri tabanının ilk haftası olan başlangıç_haftası =, yılda kaç periyot olduğunu gösteren bir sayıyı (örneğin 52, 12) ve son olarak çıktı stilini içerir (aşağıdaki koddaki ayrıntılara bakın).: Yukarıdaki haftaları sinüs ve kosinüs terimlerine eklemek mümkündür, ancak bu terimleri oluşturmak için bir fonksiyon kullanacağız (aşağıdaki regresyon bölümüne bakınız) ","code":"\n## Fonksiyonun argümanları\n#####################\n## x veritabanıdır\n## x içindeki oranlar ya da sayımlar değişkendir\n## start_week is the first week in your dataset\n## periyot bir yıldaki birim sayısıdır \n## çıktı, dönüş spektral periodogramı ya da peak görülen haftalardır.\n  ## \"periodogram\" veya \"weeks\"\n\n# Fonksiyonu tanımlamak\nperiodogram <- function(x, \n                        counts, \n                        start_week = c(2002, 1), \n                        period = 52, \n                        output = \"weeks\") {\n  \n\n    ## bir tsibble olmadığından emin olun, projeye filtre uygulayın ve yalnızca ilgilenilen sütunları tutun\n    prepare_data <- dplyr::as_tibble(x)\n    \n    # veriyi hazırla <- prepare_data[prepare_data[[strata]] == j, ]\n    prepare_data <- dplyr::select(prepare_data, {{counts}})\n    \n    ## spec.pgram ile kullanılabilecek bir ara zaman serisi (“zoo”) oluşturun\n    zoo_cases <- zoo::zooreg(prepare_data, \n                             start = start_week, frequency = period)\n    \n    ## hızlı fourier dönüşümü kullanmayan bir spektral periodogram elde edin\n    periodo <- spec.pgram(zoo_cases, fast = FALSE, plot = FALSE)\n    \n    ## pieak haftaları elde edin \n    periodo_weeks <- 1 / periodo$freq[order(-periodo$spec)] * period\n    \n    if (output == \"weeks\") {\n      periodo_weeks\n    } else {\n      periodo\n    }\n    \n}\n\n## en yüksek frekanslara sahip haftaları çıkarmak için spektral periodogram alın\n## (mevsimsellik kontrolü)\nperiodo <- periodogram(counts, \n                       case_int, \n                       start_week = c(2002, 1),\n                       output = \"periodogram\")\n\n## görselleştirme için bir veri çerçevesine tam spektrum ve frekans yerleştirilir\nperiodo <- data.frame(periodo$freq, periodo$spec)\n\n## en sık meydana gelen periyodikliği gösteren bir periodogram çizin\nggplot(data = periodo, \n                aes(x = 1/(periodo.freq/52),  y = log(periodo.spec))) + \n  geom_line() + \n  labs(x = \"Period (Weeks)\", y = \"Log(density)\")\n## haftaları içeren vektörü artan sırayla elde edin \npeak_weeks <- periodogram(counts, \n                          case_int, \n                          start_week = c(2002, 1), \n                          output = \"weeks\")"},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"ayrıştırma","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"Ayrıştırma","text":"Klasik ayrıştırma, bir zaman serisini parçalara ayırmak için kullanılır ve bu parçalar birlikte gördüğünüz modeli oluşturur. Bu farklı parçalar şunlardır:• Trend döngüsü (verinin uzun vadeli seyri)\n• Mevsimsellik (tekrarlanan modeller)\n• Rastgele (trend ve sezon çıkarıldıktan sonra kalan)","code":"\n## sayımlar veri tabanını ayrıştır \ncounts %>% \n  # additif klasik ayrıştırma modeli uygula \n  model(classical_decomposition(case_int, type = \"additive\")) %>% \n  ## önemli bilgileri modelden çıkarın\n  components() %>% \n  ## grafik oluştur \n  autoplot()"},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"otokorelasyon","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"Otokorelasyon","text":"Otokorelasyon size haftadaki sayımlar ile önceki haftalardaki sayımlar (gecikme olarak adlandırılır) arasındaki ilişkiyi anlatır.ACF() fonksiyonunu kullanarak, farklı gecikmelerdeki ilişkiyi bize bir dizi çizgi gösteren bir grafik oluşturabiliriz. Gecikmenin 0 (x = 0) olduğu yerde, çizgi gözlem ile kendisi arasındaki ilişkiyi gösterdiğinden (burada gösterilmemiştir) zaman 1 olacaktır. Burada gösterilen ilk satır (x = 1), gözlem ile bir önceki gözlem arasındaki ilişkiyi gösterir (1 gecikme), ikincisi gözlem ile iki önceki gözlem arasındaki ilişkiyi gösterir (2 gecikme) ve gecikme sayıları bu şekilde artarak devam eder (bir gözlem ile 1 yıllık (52 hafta öncesi) gözlem arasındaki ilişkiyi gösteren 52’ye kadar)PACF() fonksiyonunun kullanılması (kısmi otokorelasyon için) aynı ilişkiyi gösterir, ancak aradaki diğer tüm haftalar için ayarlanmış bir ölçüttür. Kısmi otokorelasyon, periyodikliği belirlemek için daha az yararlıdır.Ljung-Box testini (stats paketinde) kullanarak zaman serisinde null hipotezini (yani otokorelasyonlu olup olmadığı) test edebilirsiniz. Anlamlı bir p değeri, verilerde otokorelasyon olduğunu gösterir.","code":"\n## sayım veri tabanını kullanma\ncounts %>% \n  ## yıl içindeki gecikmeleri kullanarak otokorelasyonu hesaplayın\n  ACF(case_int, lag_max = 52) %>% \n  ## grafik oluşturun\n  autoplot()\n## sayım veri tabanını kullanma \ncounts %>% \n  ## yıl içindeki gecikmeleri kullanarak kısmi otokorelasyonu hesaplayın\n  PACF(case_int, lag_max = 52) %>% \n  ## grafik oluşturun\n  autoplot()\n## bağımsızlık testi \nBox.test(counts$case_int, type = \"Ljung-Box\")## \n##  Box-Ljung test\n## \n## data:  counts$case_int\n## X-squared = 462.65, df = 1, p-value < 2.2e-16"},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"uyum-regresyonları","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"23.5 Uyum regresyonları","text":"Bir zaman serisine çok sayıda farklı regresyon sığdırmak mümkündür, ancak burada negatif iki terimli regresyonun nasıl sığdırılacağını göstereceğiz - çünkü bu genellikle bulaşıcı hastalıklardaki sayım verileri için en uygun olanıdır.","code":""},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"fourier-terimleri","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"Fourier terimleri","text":"Fourier terimleri, sinüs ve kosinüs eğrilerinin eş epi hafta ve case_int değişkenlerini kullanarak fourier terimleri ekleyindeğeridir. Aradaki fark, bu terimlerin verilerinizi açıklamak için en uygun eğri kombinasyonunu bulmaya dayalı bulunmasıdır.Yalnızca bir fourier terimine kullanacak olsaydınız, periodogramınızda görülen en sık meydana gelen gecikmeniz için (bizim durumumuzda 52 hafta) bir sinüs ve bir kosinüs kullanmaya eşdeğer olacaktır. Forecast paketindeki fourier() fonksiyonunu kullanıyoruz.Aşağıdaki kodda $ operatörünü kullanarak atadık, çünkü fourier() iki sütun oluşturur (biri sinüs, diğeri kosinüs için) ve bu nedenle bunlar veri tabanına “fourier” adı verilen bir liste olarak eklenir - ancak bu liste daha sonra regresyonda normal bir değişken olarak kullanılabilir:","code":"\n## epi hafta ve case_int değişkenlerini kullanarak fourier terimleri ekleyin\ncounts$fourier <- select(counts, epiweek, case_int) %>% \n  fourier(K = 1)"},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"negatif-binomial","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"Negatif binomial","text":"Temel istatistik (base stats) veya MASS fonksiyonlarını (örn. lm(), glm() ve glm.nb()) kullanarak uyumlu regresyonlar oluşturmak mümkündür. Bununla birlikte, uygun güven ve tahmin aralıklarının (aksi takdirde mevcut olmayan) hesaplanmasına izin verdiği için, trending paketindeki fonksiyonları kullanacağız. Bu fonksiyonların sintaksı aynıdır ve bir çıktı değişkeni, ardından bir tilde (~) belirtir ve ardından artı (+) ile ayırarak ilgilendiğiniz çeşitli maruz kalma değişkenlerinizi eklersiniz.Diğer fark, önce modeli tanımlamamız ve ardından onu verilere fit() ile uydurmamızdır. Bu, aynı sintaksa sahip birden çok farklı modeli karşılaştırmaya izin verdiği için yararlıdır.İPUCU: Sayılar yerine oranları kullanmak istiyorsanız, offset(log(population) terimini ekleyerek popülasyon değişkenini logaritmik bir offset terimi olarak dahil edebilirsiniz. Bu durumda bir oran oluşturmak için predict() fonksiyonunu kullanmadan önce popülasyonu 1 olarak ayarlamanız gerekir. İPUCU: ARIMA veya prophet gibi daha karmaşık modelleri uygulamak için fable paketine bakAbilirsiniz. fable.","code":"\n## uydurmak istediğiniz modeli tanımlayın (negatif binom)\nmodel <- glm_nb_model(\n  ## ilgilenilen sonuç olarak vaka sayısını belirlemek\n  case_int ~\n    ## trendi hesaba katmak için epiweek'i kullanın\n    epiweek +\n    ## mevsimselliği hesaba katmak için fourier terimlerini kullanın\n    fourier)\n\n## sayım veri tabanını kullanarak modelinize uydurun\nfitted_model <- trending::fit(model, data.frame(counts))\n\n## güven ve tahmin aralıklarını hesaplayın\nobserved <- predict(fitted_model, simulate_pi = FALSE)\n\n## regresyonunuzu görselleştirin \nggplot(data = observed, aes(x = epiweek)) + \n  ## model tahmini için bir satır ekleyin\n  geom_line(aes(y = estimate),\n            col = \"Red\") + \n  ## tahmin aralıkları için bir bant ekleyin\n  geom_ribbon(aes(ymin = lower_pi, \n                  ymax = upper_pi), \n              alpha = 0.25) + \n  ## gözlemlenen vaka sayılarınız için bir satır ekleyin\n  geom_line(aes(y = case_int), \n            col = \"black\") + \n  ## geleneksel bir grafik oluşturun (siyah eksenli ve beyaz arka planlı)\n  theme_classic()"},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"artıklar-residuals","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"Artıklar (Residuals)","text":"Modelimizin gözlemlenen verilere ne kadar uyum gösterdiğini görmek için artıklara bakmamız gerekir. Artıklar, gözlemlenen değerler ile modelden tahmin edilen değerler arasındaki farktır. Bunu basitçe case_int - tahmin formülünü kullanarak hesaplayabiliriz, ancak residuals() fonksiyonu bunu bizim için doğrudan regresyondan çıkarır.Aşağıdan gördüğümüz gibi modelle tüm varyansı açıklamamaktayız. Daha fazla fourier terimi kullanmamız ve genliği ele almamız gerekebilir. Ancak bu örnek için olduğu gibi bırakacağız. Grafikler, modelimizin tepe ve diplerde (sayılar en yüksek ve en düşük olduğunda) daha kötü olduğunu ve gözlemlenen sayıları olduğundan daha az tahmin etme olasılığının (underestimate) yüksek olabileceğini gösteriyor.","code":"\n## artıkların hesabı \nobserved <- observed %>% \n  mutate(resid = residuals(fitted_model$fitted_model, type = \"response\"))\n\n## artıklar zaman içinde oldukça sabit mi (değilse: salgın? uygulamada değişiklik?)\nobserved %>%\n  ggplot(aes(x = epiweek, y = resid)) +\n  geom_line() +\n  geom_point() + \n  labs(x = \"epiweek\", y = \"Residuals\")\n## artıklarda otokorelasyon var mı (hatanın bir motifi var mı?)\nobserved %>% \n  as_tsibble(index = epiweek) %>% \n  ACF(resid, lag_max = 52) %>% \n  autoplot()\n## artıklar normal olarak dağılmış mı (tahminin altında mı yoksa üzerinde mi?)\nobserved %>%\n  ggplot(aes(x = resid)) +\n  geom_histogram(binwidth = 100) +\n  geom_rug() +\n  labs(y = \"count\") \n## gözlemlenen sayıları artıklarıyla karşılaştırın\n  ## ayrıca motif görülmemeli\nobserved %>%\n  ggplot(aes(x = estimate, y = resid)) +\n  geom_point() +\n  labs(x = \"Fitted\", y = \"Residuals\")\n## artıkların otokorelasyonunu test edin\n## H0, artıkların beyaz gürültü (yani rastgele) olmasıdır\n## bağımsızlık testi\n## p değeri anlamlıysa rastgele değil\nBox.test(observed$resid, type = \"Ljung-Box\")## \n##  Box-Ljung test\n## \n## data:  observed$resid\n## X-squared = 346.64, df = 1, p-value < 2.2e-16\n## \n##  Box-Ljung test\n## \n## data:  observed$resid\n## X-squared = 346.64, df = 1, p-value < 2.2e-16"},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"iki-zaman-serisinin-ilişkisi","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"23.6 İki zaman serisinin ilişkisi","text":"Burada, campylobacter vaka sayılarını açıklamak için hava durumu verilerini (özellikle sıcaklık) kullanmayı inceliyoruz.","code":""},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"veritabanlarının-birleştirilmesi","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"Veritabanlarının birleştirilmesi","text":"Hafta değişkenini kullanarak veri tabanlarımızı birleştirebiliriz. Birleştirme hakkında daha fazla bilgi için birleştirme ilgili el kitabı bölümüne bakın. joining.","code":"\n## sol birleştirme, böylece yalnızca sayılarda mevcut olan satırlarımız olur \n## temp_data'dan tarih değişkenini çıkarın (aksi takdirde yinelenir)\n\ncounts <- left_join(counts, \n                    select(temp_data, -date),\n                    by = \"epiweek\")"},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"tanımlayıcı-analizler-1","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"Tanımlayıcı analizler","text":"Görünür bir ilişki olup olmadığını görmek için önce verilerinizi çizin. Aşağıdaki grafik, iki değişkenin mevsimselliği yönünden görünür bir ilişki olduğunu ve sıcaklığın vaka sayısından birkaç hafta önce zirveye ulaştığını göstermektedir. Verilerin pivotlanması hakkında daha fazla bilgi için, verilerin pivotlanmasıyla ilgili el kitabı bölümüne bakın. pivoting data.","code":"\ncounts %>% \n  ## sadece ilgilendiğimiz değişkenler veritabanında kalır  \n  select(epiweek, case_int, t2m) %>% \n  ## verilerinizi uzun formatta değiştirin\n  pivot_longer(\n    ## anahtar olarak epiweek'i kullanın\n    !epiweek,\n    ## sütun adlarını yeni \"ölçü\" sütununa taşıyın\n    names_to = \"measure\", \n    ## hücre değerlerini yeni \"değerler\" sütununa taşı\n    values_to = \"value\") %>% \n  ## yukarıdaki veritabanından bir grafik oluşturun \n  ## epiweek'i x ekseninde ve değerler (sayılar/santigrat) y ekseninde grafik çizin\n  ggplot(aes(x = epiweek, y = value)) + \n    ## sıcaklık ve vaka sayıları için ayrı bir grafik oluşturun\n    ## kendi y eksenlerini ayarlamalarına izin verin\n    facet_grid(measure ~ ., scales = \"free_y\") +\n    ## ikisini de bir çizgi grafiği olarak çizin \n    geom_line()"},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"gecikmeler-ve-çapraz-korelasyonlar","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"Gecikmeler ve çapraz korelasyonlar","text":"Vakalar ve sıcaklık arasında hangi haftaların en çok ilişkili olduğunu test etmek çapraz korelasyon uygulanır. feasts paketinden çapraz korelasyon fonksiyonunu (CCF()) kullanabiliriz. Ayrıca autoplot() fonksiyonunu kullanarak (arrange kullanmak yerine) grafik oluşturabilirsiniz.Burada 4 haftalık bir gecikmenin en yüksek oranda ilişkili olduğunu görüyoruz, bu nedenle regresyonumuza dahil etmek için gecikmeli bir sıcaklık değişkeni oluşturuyoruz.TEHLİKE: Gecikmeli sıcaklık değişkenindeki verilerin ilk dört haftasının eksik olduğunu (NA) unutmayın - çünkü veri almak için önceki dört hafta mevcut değildi. Bu veri tabanını trending predict() fonksiyonuyla kullanmak için, daha aşağıda predict() fonksiyonu içinde simulate_pi = FALSE argümanını kullanmamız gerekir. Simulate (simüle et) seçeneğini kullanmak istediysek, aşağıdaki kod parçasına drop_na(t2m_lag4) terimini ekleyerek eksikleri çıkararak yeni bir veri tabanı olarak kaydetmeliyiz.","code":"\ncounts %>% \n  ## interpolasyonlu sayımlar ve sıcaklık arasındaki çapraz korelasyonu hesaplayın\n  CCF(case_int, t2m,\n      ## maksimum gecikmeyi 52 hafta olarak ayarlayın\n      lag_max = 52, \n      ## korelasyon katsayısını hesaplayın\n      type = \"correlation\") %>% \n  ## korelasyon katsayısını azalan biçimde dizin\n  ## en yüksek ilişkili gecikmeleri göster\n  arrange(-ccf) %>% \n  ## sadece ilk 10'u gösterin \n  slice_head(n = 10)## # A tsibble: 10 x 2 [1W]\n##         lag   ccf\n##    <cf_lag> <dbl>\n##  1      -4W 0.749\n##  2      -5W 0.745\n##  3      -3W 0.735\n##  4      -6W 0.729\n##  5      -2W 0.727\n##  6      -7W 0.704\n##  7      -1W 0.695\n##  8      -8W 0.671\n##  9       0W 0.649\n## 10      47W 0.638\ncounts <- counts %>% \n  ## sıcaklık için dört hafta gecikmeli yeni bir değişken oluşturun\n  mutate(t2m_lag4 = lag(t2m, n = 4))"},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"iki-değişkenli-negatif-binomial","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"İki değişkenli negatif binomial","text":"Daha önce gösterildiği gibi negatif bir binom regresyon modeli geliştiriyoruz. Bu sefer modelimize dört hafta gecikmeli sıcaklık değişkenini ekliyoruz.UYARI: predict() değişkeninde simulate_pi = FALSE kullanımına dikkat edin. Bunun nedeni, trending’varsayılan davranışının bir tahmin aralığı oluşturmak için ciTools paketini kullanmasıdır. NA (eksik) sayılar varsa bu paket çalışmaz ve daha granüler aralıklar üretir. Ayrıntılar için ?trending::predict.trending_model_fit’e bakın. Tek tek terimleri araştırmak için, get_model() fonksiyonunu kullanarak orijinal negatif binom regresyonunu trend formatından çıkarabilir sonrasında üstel tahminleri ve ilişkili güven aralıklarını elde etmek için broom paketi tidy() işlevine iletebiliriz. Bu bize, trend ve mevsimsellik için kontrol edildikten sonra gecikmeli sıcaklığın vaka sayılarına benzer olduğunu ve vaka sayılarıyla anlamlı olarak ilişkili (tahmini ~ 1) olduğunu gösterir. Bu sonuç , gecikmeli sıcaklık değişkeninin gelecekteki vaka sayılarını tahmin etmek için iyi bir değişken olabileceğini düşündürmektedir (iklim tahminleri zaten hazır olduğu için).Modelin hızlı görsel incelemesi, modelin gözlemlenen vaka sayılarını tahmin etmede daha iyi bir iş çıkarabileceğini gösterir.","code":"\n## uydurmak istediğiniz modeli tanımlayın (negatif binom)\nmodel <- glm_nb_model(\n  ## ilgilenilen çıktı olarak vaka sayısını belirleyin \n  case_int ~\n    ## trendi hesaba katmak için epiweek'i kullanın\n    epiweek +\n    ## mevsimselliği hesaba katmak için fourier terimlerini kullanın\n    fourier + \n    ## dört hafta gecikmeli sıcaklık değişkenini kullanın\n    t2m_lag4\n    )\n\n## sayım veri tabanını kullanarak uyumlu modelinizi oluşturun\nfitted_model <- trending::fit(model, data.frame(counts))\n\n## güven aralıklarını ve tahmin aralıklarını hesaplayın\nobserved <- predict(fitted_model, simulate_pi = FALSE)\nfitted_model %>% \n  ## orijinal negatif binom regresyonunu elde edin \n  get_model() %>% \n  ## sonuçların tidy veri çerçevesini elde edin\n  tidy(exponentiate = TRUE, \n       conf.int = TRUE)## # A tibble: 5 × 7\n##   term         estimate  std.error statistic  p.value conf.low conf.high\n##   <chr>           <dbl>      <dbl>     <dbl>    <dbl>    <dbl>     <dbl>\n## 1 (Intercept)   339.    0.108          53.8  0         274.      419.   \n## 2 epiweek         1.00  0.00000774     10.9  8.13e-28    1.00      1.00 \n## 3 fourierS1-52    0.752 0.0214        -13.3  1.84e-40    0.721     0.784\n## 4 fourierC1-52    0.823 0.0200         -9.78 1.35e-22    0.791     0.855\n## 5 t2m_lag4        1.01  0.00269         2.48 1.30e- 2    1.00      1.01\n## regresyonunuzu çiz\nggplot(data = observed, aes(x = epiweek)) + \n  ## model tahmini için bir satır ekleyin\n  geom_line(aes(y = estimate),\n            col = \"Red\") + \n  ## tahmin aralıkları için bir bant ekleyin\n  geom_ribbon(aes(ymin = lower_pi, \n                  ymax = upper_pi), \n              alpha = 0.25) + \n  ## gözlemlenen vaka sayılarınız için bir satır ekleyin\n  geom_line(aes(y = case_int), \n            col = \"black\") + \n  ## geleneksel bir grafik oluşturun (siyah eksenli ve beyaz arka planlı)\n  theme_classic()"},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"rezidüeller-artıklar","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"Rezidüeller (Artıklar)","text":"Modelimizin gözlemlenen verilerle ne kadar uyumlu olduğunu görmek için artıkları tekrar araştırırız. Buradaki sonuçlar ve yorum önceki regresyona benzer, bu nedenle sıcaklık değişkenini içermeyen daha basit bir modele bağlı kalmak daha uygun olabilir.","code":"\n## artıkları hesapla\nobserved <- observed %>% \n  mutate(resid = case_int - estimate)\n\n## artıklar zaman içinde oldukça sabit mi (değilse: salgın? uygulamada değişiklik?)\nobserved %>%\n  ggplot(aes(x = epiweek, y = resid)) +\n  geom_line() +\n  geom_point() + \n  labs(x = \"epiweek\", y = \"Residuals\")## Warning: Removed 4 rows containing missing values (`geom_line()`).## Warning: Removed 4 rows containing missing values (`geom_point()`).\n## Uyarı: Eksik değerler içeren 4 satır kaldırıldı (geom_path).\n\n \n## artıklarda otokorelasyon var mı (hatanın bir motifi var mı?)\nobserved %>% \n  as_tsibble(index = epiweek) %>% \n  ACF(resid, lag_max = 52) %>% \n  autoplot()\n## artıklar normal dağılım gösteriyor mu (tahminin altında mı yoksa üzerinde mi?)\nobserved %>%\n  ggplot(aes(x = resid)) +\n  geom_histogram(binwidth = 100) +\n  geom_rug() +\n  labs(y = \"count\") ## Warning: Removed 4 rows containing non-finite values (`stat_bin()`).\n## Uyarı: Sonlu olmayan değerler içeren 4 satır kaldırıldı (stat_bin).\n\n \n## gözlemlenen sayıları artıklarıyla karşılaştırın\n  ## ayrıca tekrarlama olmamalı\nobserved %>%\n  ggplot(aes(x = estimate, y = resid)) +\n  geom_point() +\n  labs(x = \"Fitted\", y = \"Residuals\")## Warning: Removed 4 rows containing missing values (`geom_point()`).\n## Uyarı: Eksik değerler içeren 4 satır kaldırıldı (geom_point).\n\n \n## artıkların otokorelasyonunu test edin\n## H0, artıkların beyaz gürültü (yani rastgele) olmasıdır\n## bağımsızlık testi\n## p değeri anlamlıysa rastgele değildir\nBox.test(observed$resid, type = \"Ljung-Box\")## \n##  Box-Ljung test\n## \n## data:  observed$resid\n## X-squared = 339.52, df = 1, p-value < 2.2e-16"},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"salgınların-tespit-edilmesi","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"23.7 Salgınların tespit edilmesi","text":"Burada salgınları tespit etmek için iki (benzer) yöntem göstereceğiz. İlki, yukarıdaki bölümler üzerine kuruludur. Regresyonları önceki yıllara uydurmak için trending paketini kullanıyoruz ve ardından gelecek yıl görmeyi umduğumuzu değerleri tahmin ediyoruz. Gözlenen sayımlar beklediğimizin üzerindeyse, bir salgın olduğunu gösterebilir. İkinci yöntem benzer ilkelere dayanmaktadır ancak aşırı değerlerin (aberration) tespiti için bir dizi farklı algoritmaya sahip surveillance paketini kullanır.UYARI: Normalde, mevcut yılla ilgilenirsiniz (yalnızca mevcut haftaya kadar olan sayıları bildiğiniz için). Bu örnekte 2011’39. haftasındaymış gibi analiz yapıyoruz.","code":""},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"trending-paketi","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"trending paketi","text":"Bu yöntem için bir temel tanımlarız, genellikle yaklaşık 5 yıllık veri olmalıdır). Temel veriler için bir regresyon modeli oluştururuz ve ardından bunu gelecek yıl için tahmin elde etmek için kullanırız.","code":""},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"kesim-eşik-tarihi","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"Kesim (eşik) tarihi","text":"Tarihlerinizi tek bir yerde tanımlamak ve ardından bunları kodunuzun geri kalanında kullanmak daha kolaydır.Burada bir başlangıç tarihi (gözlemlerimizin başladığı tarih) ve bir bitiş tarihi (temel dönemimizin sonu olan- ve tahmine ne zaman başlayacağımızın tarihi) tanımlarız. ~Ayrıca ilgilendiğimiz yılda (tahmin edeceğimiz yılda) kaç hafta olduğunu da tanımlarız ~. Ayrıca, temel kesim tarihimiz ile tahmin etmek istediğimiz bitiş tarihi arasında kaç hafta olduğunu da tanımlarız.: Bu örnekte, şu anda Eylül 2011’sonundaymış gibi davranıyoruz (“2011 W39”).","code":"\n## başlangıç tarihini tanımlayın (gözlemlerin başladığı zaman)\nstart_date <- min(counts$epiweek)\n\n## bir bitiş haftası tanımlayın (temel verinin sonu, tahmin döneminin başlangıcı)\ncut_off <- yearweek(\"2010-12-31\")\n\n## ilgilenilen son tarihi tanımlayın (yani tahminin sonu)\nend_date <- yearweek(\"2011-12-31\")\n\n## ilgilenilen dönemde (yıl) kaç hafta bulun\nnum_weeks <- as.numeric(end_date - cut_off)"},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"satır-eklemek","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"Satır eklemek","text":"Tidyverse formatında tahmin yapabilmek için, veri setimizde doğru sayıda satıra, yani yukarıda tanımlanan end_date tarihine kadar hafta için bir satıra ihtiyacımız var. Aşağıdaki kod, bu satırları bir gruplama değişkenine göre eklemenize izin verir - örneğin, bir veri tabanında birden fazla ülkemiz varsa, ülkeye göre gruplayabilir ve ardından biri için uygun satırlar ekleyebiliriz. tsibble’ın group_by_key() fonksiyonu , bu gruplandırmayı yapmamıza ve ardından gruplanmış verileri dplyr fonkisyonlarına, group_modify() ve add_row()’geçirmemize izin verir. Ardından, verilerde mevcut olan maksimum hafta değerinden bir sonraki hafta ile bitiş haftası arasındaki hafta sırasını belirleriz.","code":"\n## yılın sonuna kadar eksik haftaları ekleyin\ncounts <- counts %>%\n  ## bölgeye göre grup\n  group_by_key() %>%\n  ## her grup için en yüksek epiweek’ten yıl sonuna kadar satır ekleyin\n  group_modify(~add_row(.,\n                        epiweek = seq(max(.$epiweek) + 1, \n                                      end_date,\n                                      by = 1)))"},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"fourier-terimleri-1","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"Fourier terimleri","text":"Fourier terimlerimizi yeniden tanımlamamız gerekiyor - çünkü bu terimleri temel tarihe uydurmak ve gelecek yıl için ekstrapole etmek istiyoruz. Bunu yapmak için fourier() fonkisyonundan iki çıktı listesini bir araya getirmemiz gerekiyor; ilki temel veriler içindir ve ikincisi ilgilenilen yılı (h argümanını tanımlayarak) tahmin eder.: Satırları bağlamak için rbind() (tidyverse’teki bind_rows yerine) kullanmalıyız, çünkü fourier sütunları bir liste biçimindedir (yani ayrı ayrı adlandırılmaz).","code":"\n## fourier terimlerini tanımlayın (sincos)\ncounts <- counts %>% \n  mutate(\n    ## 2010 kesim tarihinden önceki ve sonraki haftalar için fourier terimlerini birleştirin\n    ## (yani 2011 fourier terimleri tahmin edilmektedir)\n    fourier = rbind(\n      ## önceki yıllar için fourier terimlerini getirin \n      fourier(\n        ## sadece 2011'den önceki satırları tutun\n        filter(counts, \n               epiweek <= cut_off), \n        ## bir dizi sin cos terimini dahil et\n        K = 1\n        ), \n      ## 2011 için fourier terimlerini tahmin edin (temel verileri kullanarak)\n      fourier(\n        ## sadece 2011'den önceki satırları tutun\n        filter(counts, \n               epiweek <= cut_off),\n        ## bir dizi sin cos terimini dahil et\n        K = 1, \n        ## 52 hafta sonrasını tahmin et\n        h = num_weeks\n        )\n      )\n    )"},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"verinin-bölünmesi-ve-uyumlu-regresyon","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"Verinin bölünmesi ve uyumlu regresyon","text":"Şimdi veri setimizi temel periyoda (tahminin başladığı zamana kadarki veri) ve tahmin periyoduna bölmemiz gerekiyor. Bu, group_by()’den sonra dplyr group_split() fonkisyonu kullanılarak yapılır ve biri kesme işleminden önce diğeri sonra olmak üzere iki veri çerçevesi içeren bir liste oluşturur.Daha sonra veri kümelerini listeden çıkarmak için purrr paketi pluck() fonksiyonunu kullanırız (bu fonksiyon köşeli parantez kullanmaya eşdeğer, örneğin dat[[1]] gibi ) ve daha sonra modelimizi temel verilere uydurabilir ve ardından kesintiden sonra ilgilendiğimiz veri için predict() fonksiyonunu kullanabiliriz.Purrr hakkında daha fazla bilgi edinmek için Yineleme (iterasyon), döngüler ve listeler sayfasına bakın.UYARI: predict() fonksiyonunda simulate_pi = FALSE argümanının kullanımına dikkat edin. Bunun nedeni, trend oluşturmanın varsayılan davranışının bir tahmin aralığını oluşturmak için ciTools paketinin kullanılmasıdır. NA (eksik) değerler varsa bu fonksiyon çalışmaz ve ayrıca daha granüler aralıklar üretir. Ayrıntılar için ?trending::predict.trending_model_fit’e bakın. Daha önce olduğu gibi modelimizi ggplot ile görselleştirebiliriz. %95 tahmin aralığının üzerindeki gözlemlenen değerleri dikkat çekmek amacıyla kırmızı noktalarla vurgularız. Bu sefer tahminin başladığı tarihi etiketlemek için dikey bir çizgi de ekliyoruz.","code":"\n# uyum ve tahmin için bölünmüş veriler\ndat <- counts %>% \n  group_by(epiweek <= cut_off) %>%\n  group_split()\n\n## uydurmak istediğiniz modeli tanımlayın (negatif binom)\nmodel <- glm_nb_model(\n  ## set number of cases as outcome of interest\n  case_int ~\n    ## use epiweek to account for the trend\n    epiweek +\n    ## use the furier terms to account for seasonality\n    fourier\n)\n\n# Uyum ve tahmin için hangi verilerin kullanılacağını tanımlayın\nfitting_data <- pluck(dat, 2)\npred_data <- pluck(dat, 1) %>% \n  select(case_int, epiweek, fourier)\n\n# modeli uydurun\nfitted_model <- trending::fit(model, data.frame(fitting_data))\n\n# Uydurulan veriler için sınır ve tahmin değerleri elde edin\nobserved <- fitted_model %>% \n  predict(simulate_pi = FALSE)\n\n# tahmin için kullanılacak veri ile tahmin \nforecasts <- fitted_model %>% \n  predict(data.frame(pred_data), simulate_pi = FALSE)\n\n## temel ve tahmin edilmiş veri tabanlarını birleştirin \nobserved <- bind_rows(observed, forecasts)\n## regresyonunuzu görselleştirin \nggplot(data = observed, aes(x = epiweek)) + \n  ## model tahmini için bir satır ekleyin\n  geom_line(aes(y = estimate),\n            col = \"grey\") + \n  ## tahmin aralıkları için bir bant ekleyin\n  geom_ribbon(aes(ymin = lower_pi, \n                  ymax = upper_pi), \n              alpha = 0.25) + \n  ## gözlemlenen vaka sayılarınız için bir çizgi grafiği ekleyin\n  geom_line(aes(y = case_int), \n            col = \"black\") + \n  ## beklenenin üzerinde gözlenen sayımlar için saçılım grafiği\n  geom_point(\n    data = filter(observed, case_int > upper_pi), \n    aes(y = case_int), \n    colour = \"red\", \n    size = 2) + \n  ## tahminin nerede başladığını göstermek için dikey çizgi ve etiket ekleyin\n  geom_vline(\n           xintercept = as.Date(cut_off), \n           linetype = \"dashed\") + \n  annotate(geom = \"text\", \n           label = \"Forecast\", \n           x = cut_off, \n           y = max(observed$upper_pi) - 250, \n           angle = 90, \n           vjust = 1\n           ) + \n  ## geleneksel bir grafik oluşturun (siyah eksenli ve beyaz arka planlı)\n  theme_classic()## Warning: Removed 13 rows containing missing values (`geom_line()`).\n## Uyarı: Eksik değerler içeren 13 satır kaldırıldı(geom_path)."},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"öngörünün-doğrulanması-validasyonu","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"Öngörünün doğrulanması (validasyonu)","text":"Artıkları incelemenin ötesinde, modelinizin gelecekteki durumları tahmin etmede ne kadar iyi olduğunu araştırmak önemlidir. Bu size eşik uyarılarınızın ne kadar güvenilir olduğu konusunda fikir verir.Doğrulamanın geleneksel yolu, önceki yılı ne kadar iyi tahmin edebileceğinizi görmektir (çünkü “şimdiki yıl” için sayıları henüz bilmiyorsunuz). Örneğin, veri setimizde 2010’u tahmin etmek için 2002’den 2009’kadar olan verileri kullanıp sonra bu tahminlerin ne kadar doğru olduğunu ölçerdik. Ardından modeli 2010 verilerini içerecek şekilde uygulayıp 2011 sayılarını tahmin etmek için kullanın.Aşağıdaki şekilde Hyndman ve arkadaşlarının “Tahmin ilkeleri ve uygulaması” bölümünde görülebileceği gibi.\nHyndman et al “Forecasting principles\npractice”.Görsel yazarlardan alınan izinle yeniden oluşturulmuşturBu yöntemin dezavantajı, elinizdeki tüm verileri kullanmamanız ve modelin tahmin için kullandığınız son model olmamasıdır.Bir alternatif, çapraz doğrulama adı verilen bir yöntem kullanmaktır. Bu senaryoda, bir yıl sonrasını tahmin etmek için birden fazla modele uydurabilmek için mevcut tüm verileri kaydırırsınız. Aynı makaleden [Hyndman ve arkadaşlarına ait metninden]((https://otexts.com/fpp3/) alınan aşağıdaki şekilde görüldüğü gibi, modelde giderek daha fazla veri kullanıyorsunuz.Örneğin, ilk model 2003’ü tahmin etmek için 2002’yi kullanıyor , ikincisi 2004’ü tahmin etmek için 2002 ve 2003’ü kullanır, vb.\nGörsel yazarlardan alınan izinle yeniden oluşturulmuşturAşağıda, veri kümeleri üzerinde döngü işlemini uygulamak için purrr paketinden map() fonksiyonunu kullanıyoruz. Daha sonra, doğruluk ölçülerini hesaplama amacıyla yardstick paketini kullanmak için elde ettiğimiz tahminleri bir veri tabanına aktarır ve orijinal vaka sayılarıyla birleştiririz. Aşağıda belirtilen dört ölçüyü hesaplıyoruz: Kök Ortalama Kare Hatası (RMSE), Ortalama mutlak hata (MAE), Ortalama mutlak ölçekli hata (MASE), Ortalama mutlak yüzde hatası (MAPE).UYARI: predict() fonksiyonunda simulate_pi = FALSE argümanının kullanımına dikkat edin. Bunun nedeni, trend oluşturmanın varsayılan davranışının bir tahmin aralığını oluşturmak için ciTools paketinin kullanılmasıdır. NA (eksik) değerler varsa bu fonksiyon çalışmaz ve ayrıca daha granüler aralıklar üretir. Ayrıntılar için ?trending::predict.trending_model_fit’e bakın. ","code":"\n## Çapraz doğrulama: Kayan pencereye dayalı olarak önümüzdeki haftaları tahmin etme\n\n## 52 haftalık pencerelerde kaydırarak verilerinizi genişletin (öncesi + sonrası)\n## 52 hafta sonrasını tahmin etmek\n## (daha uzun gözlem zincirleri oluşturur- eski verileri tutar)\n\n## kaydırmak istediğiniz pencereyi tanımlayın\nroll_window <- 52\n\n## tahmin etmek istediğiniz haftaları tanımlayın  \nweeks_ahead <- 52\n\n## yinelenen, giderek daha uzun verilerden oluşan bir veri seti oluşturun\n## her veri setini benzersiz bir kimlikle etiketleyin\n## yalnızca ilgilenilen yıldan önceki vakaları kullanın (yani 2011)\ncase_roll <- counts %>% \n  filter(epiweek < cut_off) %>% \n  ## sadece hafta ve vaka sayısı değişkenlerini veri tabanında tut \n  select(epiweek, case_int) %>% \n    ## en son x sayıda gözlemi uzaklaştırın \n    ## önümüzdeki kaç haftayı tahmin etmek istediğinize bağlı olarak \n    ## (aksi takdirde \"bilinmeyen\" için tahmin yapılacaktır)\n    slice(1:(n() - weeks_ahead)) %>%\n    as_tsibble(index = epiweek) %>% \n    ## gruplandırma kimliği oluşturmak amacıyla x’teki her hafta için kaydırın\n    ## kaydırma pencerisinin özgüllüğüne bağlı \n    stretch_tsibble(.init = roll_window, .step = 1) %>% \n  ## önceki vakası yokmuş gibi ilk çifti uzaklaştırın drop the first couple \n  filter(.id > roll_window)\n\n## benzersiz veri setlerinin her biri için aşağıdaki kodu çalıştırın\nforecasts <- purrr::map(unique(case_roll$.id), \n                        function(i) {\n  \n  ## yalnızca mevcut katlantının uygun olmasını sağlayın\n  mini_data <- filter(case_roll, .id == i) %>% \n    as_tibble()\n  \n  ## tahmin için boş bir veri seti oluşturun\n  forecast_data <- tibble(\n    epiweek = seq(max(mini_data$epiweek) + 1,\n                  max(mini_data$epiweek) + weeks_ahead,\n                  by = 1),\n    case_int = rep.int(NA, weeks_ahead),\n    .id = rep.int(i, weeks_ahead)\n  )\n  \n  ## tahmin verilerini orijinale ekleyin\n  mini_data <- bind_rows(mini_data, forecast_data)\n  \n  ## en son eksik olmayan sayım verilerine dayalı olarak kesim tarhini tanımlayın\n  cv_cut_off <- mini_data %>% \n    ## sadece eksik olmayan satırları tutun \n    drop_na(case_int) %>% \n    ## en son haftayı elde edin \n    summarise(max(epiweek)) %>% \n    ## bir veri çerçevesinde olmayacak şekilde dışa aktar \n    pull()\n  \n  ## mini_data’yı tsibble haline getirin\n  mini_data <- tsibble(mini_data, index = epiweek)\n  \n  ## fourier terimlerini tanımlayın (sincos) \n  mini_data <- mini_data %>% \n    mutate(\n    ## fourier terimlerini kesim tarihinden önceki ve sonraki haftaları kombine etmek için kullanın \n    fourier = rbind(\n      ## önceki yıllardan fourier terimelerini getirin \n      forecast::fourier(\n        ## sadece kesim öncesi satırları tutun \n        filter(mini_data, \n               epiweek <= cv_cut_off), \n        ## bir sin cos terim setini dahil edin \n        K = 1\n        ), \n      ## takiben eden yıl için fourier terimlerini tahmin edin (temel veriyi kullanarak)\n      fourier(\n        ## sadece kesim öncesi satırları tutun\n        filter(mini_data, \n               epiweek <= cv_cut_off),\n        ## bir sin cos terim setini dahil edin\n        K = 1, \n        ## 52 hafta sonrasını tahmin edin \n        h = weeks_ahead\n        )\n      )\n    )\n\n  \n  \n    # uyum ve tahmin için bölünmüş veriler\n  dat <- mini_data %>% \n    group_by(epiweek <= cv_cut_off) %>%\n    group_split()\n\n  ## uydurmak istediğiniz modeli tanımlayın (negatif binom)\n  model <- glm_nb_model(\n    ## ilgilenilen çıktı olarak vaka sayısını ayarlayın \n    case_int ~\n      ## trendi hesaba katmak için epiweek'i kullanın\n      epiweek +\n      ## mevsimselliği hesaba katmak için fourier terimlerini kullanın\n      fourier\n  )\n\n  # Uyum ve tahmin için hangi verilerin kullanılacağını tanımlayın\n  fitting_data <- pluck(dat, 2)\n  pred_data <- pluck(dat, 1)\n  \n  # modeli uydurun \n  fitted_model <- trending::fit(model, fitting_data)\n  \n  # istenilen verilerle tahmin \n  forecasts <- fitted_model %>% \n    predict(data.frame(pred_data), simulate_pi = FALSE) %>% \n    ## sadece hafta ve tahmin değerini tutun \n    select(epiweek, estimate)\n    \n  }\n  )\n\n## listeyi tüm tahminlerle birlikte bir veri çerçevesine dönüştürün\nforecasts <- bind_rows(forecasts)\n\n## tahmin ile gözlenen verileri birleştirin \nforecasts <- left_join(forecasts, \n                       select(counts, epiweek, case_int),\n                       by = \"epiweek\")\n\n## {yardstick} ile ölçümlerin hesabı\n  ## RMSE: Kök Ortalama Kare Hatası\n  ## MAE:  Ortalama mutlak hata \n  ## MASE: Ortalama mutlak ölçekli hata\n  ## MAPE: Ortalama mutlak yüzde hatası\n\nmodel_metrics <- bind_rows(\n  ## tahmin edilen veri setinizde gözlemlenen ile tahmin edileni karşılaştırın\n  rmse(forecasts, case_int, estimate), \n  mae( forecasts, case_int, estimate),\n  mase(forecasts, case_int, estimate),\n  mape(forecasts, case_int, estimate),\n  ) %>% \n  ## yalnızca metrik türünü ve çıktısını tutun\n  select(Metric  = .metric, \n         Measure = .estimate) %>% \n  ## geniş formatta yapın, böylece satırları bağlayın\n  pivot_wider(names_from = Metric, values_from = Measure)\n\n## metrik modeli getirin \nmodel_metrics## # A tibble: 1 × 4\n##    rmse   mae  mase  mape\n##   <dbl> <dbl> <dbl> <dbl>\n## 1  252.  199.  1.96  17.3"},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"surveillance-paketi","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"surveillance paketi","text":"Bu bölümde, salgın tespit algoritmalarına dayalı uyarı eşikleri oluşturmak için surveillance paketini kullanıyoruz. Pakette birkaç farklı yöntem mevcuttur, ancak burada iki seçeneğe odaklanacağız. Ayrıntılar için, kullanılan algoritmaların uygulaması ve teorisi hakkındaki bu makalelere bakın. application\nve theory.İlk seçenek, iyileştirilmiş Farrington yöntemini kullanır. Bu yöntem, negatif bir binom glm’ye (trend dahil) uyum gösterir ve eşik değeri oluşturmak için geçmiş salgınları (aykırı değerler) düşük değer olarak kullanır.İkinci seçenek glrnb yöntemini kullanır. Bu aynı zamanda negatif bir binom glm’ye (genelleştirilmiş doğrusal modele) de uyar, ancak trend ve fourier terimlerini içerir (burada tercih edilir). Regresyon, “kontrol ortalamasını” (~uyumlu değerleri) hesaplamak için kullanılır - daha sonra hafta için ortalamada kayma olup olmadığını değerlendirmek için hesaplanmış bir genelleştirilmiş olabilirlik oranı (likelihood ratio) istatistiği kullanır. hafta için eşiğin önceki haftaları hesaba kattığını unutmayın, bu nedenle sürekli bir kayma varsa bir alarm tetiklenecektir. (Ayrıca alarmdan sonra algoritmanın sıfırlandığını unutmayın)surveillance paketiyle çalışmak için öncelikle çerçeveye sığacak bir “gözetim zaman serisi” nesnesi (sts() fonksiyonunu kullanarak) tanımlamamız gerekir.Daha sonra Farrington yöntemi için parametrelerimizi bir liste halinde tanımlarız. Ardından farringtonFlexible() fonksiyonunu kullanarak algoritmayı çalıştırırız ve ardından bunu veri setimize dahil etmek için farringtonmethod@upperbound kullanarak bir uyarı eşiğini çıkarabiliriz. Farringtonmethod@alarm kullanarak hafta için uyarı tetiklendiyse (eşiğin üzerindeyse) DOĞRU/YANLIŞ değerlerini çıkarmak da mümkündür.Daha sonra sonuçları daha önce olduğu gibi ggplot’ta görselleştirebiliriz.","code":"\n## gözetim zaman serisi nesnesini tanımla\n## not. popülasyon nesnesine bir payda ekleyebilirsiniz (bkz. ?sts)\ncounts_sts <- sts(observed = counts$case_int[!is.na(counts$case_int)],\n                 start = c(\n              ## yalnızca start_date tarihinden itibaren yılı tutmak için alt küme\n              as.numeric(str_sub(start_date, 1, 4)), \n              ## yalnızca start_date tarihinden itibaren haftayı tutmak için alt küme\n              as.numeric(str_sub(start_date, 7, 8))), \n              ## veri türünü tanımlayın (bu durumda haftalık)\n              freq = 52)\n\n## dahil etmek istediğiniz hafta aralığını tanımlayın (ör. tahmin dönemi)\n## not. sts nesnesi yalnızca kendilerine tanımlanmış hafta ya da yılları atamadan gözlemleri sayar \n## bu nedenle uygun olanı tanımlamak için verilerimizi kullanırız\nweekrange <- cut_off - start_date\n## kontrolü tanımlayın \nctrl <- list(\n  ## eşik için zaman periyodunu tanımlayın (yani 2011)\n  range = which(counts_sts@epoch > weekrange),\n  b = 9, ## temelden kaç yıl geriye \n  w = 2, ## haftalar halinde kaydırma penceresi \n  weightsThreshold = 2.58, ## geçmiş salgınların yeniden ağırlıklandırılması (geliştirilmiş noufaily yöntemi - orijinal öneriler 1)\n  ## pastWeeksNotIncluded = 3, ## mevcut tüm haftaları kullanın (noufaily önerisi 26’yı çıkarın)\n  trend = TRUE,\n  pThresholdTrend = 1, ## 0.05 normally, however 1 is advised in the improved method (i.e. always keep)\n  thresholdMethod = \"nbPlugin\",\n  populationOffset = TRUE\n  )\n\n## farrington’ın esnek yöntemini uygulayın \nfarringtonmethod <- farringtonFlexible(counts_sts, ctrl)\n\n## orijinal veri setinde eşik adı verilen yeni bir değişken oluşturun\n## farrington'dan gelen üst sınırı içerir\n## not: bu yalnızca 2011'deki haftalar içindir (bu nedenle satırları alt kümelere ayırmanız gerekir)\ncounts[which(counts$epiweek >= cut_off & \n               !is.na(counts$case_int)),\n              \"threshold\"] <- farringtonmethod@upperbound\nggplot(counts, aes(x = epiweek)) + \n  ## gözlemlenen vaka sayılarını bir çizgi olarak ekleyin\n  geom_line(aes(y = case_int, colour = \"Observed\")) + \n  ## sapma algoritmasının üst sınırını ekleyin \n  geom_line(aes(y = threshold, colour = \"Alert threshold\"), \n            linetype = \"dashed\", \n            size = 1.5) +\n  ## renkleri belirleyin \n  scale_colour_manual(values = c(\"Observed\" = \"black\", \n                                 \"Alert threshold\" = \"red\")) + \n  ## geleneksel bir grafik oluşturun (siyah eksenli ve beyaz arka planlı)\n  theme_classic() + \n  ## lejantın (işaret tablosunun) başlığını kaldırın  \n  theme(legend.title = element_blank())"},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"glrnb-yöntemi","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"GLRNB yöntemi","text":"Benzer şekilde GLRNB yöntemi için bir parametremizi bir liste halinde tanımlıyoruz, ardından algoritmayı uygun hale getiriyoruz ve üst sınırları çıkarıyoruz.UYARI: Bu yöntem, eşikleri hesaplamak için “kaba kuvvet” (önyüklemeye [bootstrapping’e] benzer) kullanır, bu nedenle uzun zaman alabilir!Ayrıntılar için GLRNB gösterimi\nbakabilirsiniz.Çıktıları daha önce olduğu gibi görselleştirin.","code":"\n## kontrol ayarlarını belirleyin \nctrl <- list(\n  ## hangi zaman dilimi için eşik değer isteneceğini tanımlayın (yani 2011)\n  range = which(counts_sts@epoch > weekrange),\n  mu0 = list(S = 1,    ## dahil edilecek fourier terimlerinin (harmonik) sayısı\n  trend = TRUE,   ## trendin dahil edilip edilmeyeceği\n  refit = FALSE), ## her alarmdan sonra modelin yeniden uydurulup uydurulmayacağı \n  ## cARL = GLR istatistiği için eşik (keyfi)\n     ## 3 ~ yanlış pozitifleri en aza indirmek için orta yol\n     ## 1, glm.nb'nin %99 tahmin aralığına uyar - zirvelerden sonraki değişikliklerle (uyarı için eşik düşürüldü)\n   c.ARL = 2,\n   # theta = log(1.5), ## salgın vakalarında %50 artışa eşittir\n   ret = \"cases\"     ## vaka sayısı olarak üst sınıra dönüş eşiği\n  )\n\n## glrnb yöntemini uygula\nglrnbmethod <- glrnb(counts_sts, control = ctrl, verbose = FALSE)\n\n## orijinal veri setinde eşik adı verilen yeni bir değişken oluşturun\n## glrnb'den üst sınırı içeren\n## not. bu yalnızca 2011'deki haftalar içindir (bu nedenle satırları alt kümelere ayırmanız gerekir)\ncounts[which(counts$epiweek >= cut_off & \n               !is.na(counts$case_int)),\n              \"threshold_glrnb\"] <- glrnbmethod@upperbound\nggplot(counts, aes(x = epiweek)) + \n  ## gözlemlenen vaka sayılarını bir çizgi olarak ekleyin\n  geom_line(aes(y = case_int, colour = \"Observed\")) + \n  ## sapma algoritmasının üst sınırına ekleyin\n  geom_line(aes(y = threshold_glrnb, colour = \"Alert threshold\"), \n            linetype = \"dashed\", \n            size = 1.5) +\n  ## renkleri belirleyin \n  scale_colour_manual(values = c(\"Observed\" = \"black\", \n                                 \"Alert threshold\" = \"red\")) + \n  ## geleneksel bir grafik oluşturun (siyah eksenli ve beyaz arka planlı)\n  theme_classic() + \n  ## lejantın (işaret tablosunun) başlığını kaldırın  \n  theme(legend.title = element_blank())"},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"kesintili-zaman-serileri","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"23.8 Kesintili zaman serileri","text":"Kesintili zaman serileri (ayrıca bölümlere ayrılmış regresyon veya müdahale analizi olarak da adlandırılır), genellikle aşıların hastalık insidansı üzerindeki etkisini değerlendirmede kullanılır. Ancak çok çeşitli müdahalelerin etkisini değerlendirmek için kullanılabilir. Örneğin, hastane prosedürlerinde değişiklikler veya bir popülasyona yeni bir hastalık türünün görülmesi. Bu örnekte, 2008’sonunda Almanya’ya yeni bir Campylobacter türünün geldiğini farz edeceğiz ve bunun vaka sayısını etkileyip etkilemediğini göreceğiz. Negatif binom regresyonunu tekrar kullanacağız. Bu seferki regresyon, müdahaleden önce (veya burada yeni suşun gelişi) ve diğeri (ön/pre- ve son/post dönemler) olmak üzere iki kısma ayrılacaktır. Bu, iki zaman periyodunu karşılaştıran bir insidans oranı hesaplamamızı sağlar. Denklemi açıklamak anlatımı daha net hale getirebilir (eğer değilse, görmezden gelin!).Negatif binom regresyon aşağıdaki gibi tanımlanabilir:\\[\\log(Y_t)= β_0 + β_1 \\times t+ β_2 \\times δ(t-t_0) + β_3\\times(t-t_0 )^+ + log(pop_t) + e_t\\]Neresi:\n\\(Y_t\\), \\(t\\) anında gözlemlenen vaka sayısıdır\n\\(pop_t\\), \\(t\\) anındaki 100.000’lerdeki nüfus büyüklüğüdür (burada kullanılmaz)\n\\(t_0\\) ön dönemin son yılıdır (varsa geçiş süresi dahil)\n\\(δ(x\\) gösterge işlevidir (x≤0 ise 0 ve x>0 ise 1’dir)\n\\((x)^+\\) kesme operatörüdür (x>0 ise x, aksi takdirde 0’dır)\n\\(e_t\\) kalıntıyı belirtir\nGerektiğinde ek terimler trend ve sezon eklenebilir.\\(β_2 \\times δ(t-t_0) + β_3\\times(t-t_0 )^+\\) genelleştirilmiş doğrusaldır\nsonrası dönemin bir parçasıdır ve ön dönemde sıfırdır.\nBu, \\(β_2\\) ve \\(β_3\\) tahminlerinin müdahalenin etkileri olduğu anlamına gelir.Elimizdeki tüm verileri (yani geriye dönük olarak) kullanacağımızdan, burada tahmin yapmadan fourier terimlerini yeniden hesaplamamız gerekiyor. Ek olarak, regresyon için gereken ekstra terimleri hesaplamamız gerekiyor.Daha sonra bu terimleri negatif bir binom regresyonuna uydurmak için kullanırız ve çıktısı yüzde değişimi olan bir tablo elde ederiz. Bu örnekte, önemli bir değişiklik görülmemiştir.DİKKAT: Npredict() değişkeninde simulate_pi = FALSE kullanımına dikkat edin. Bunun nedeni, trending’varsayılan davranışının bir tahmin aralığı oluşturmak için ciTools paketini kullanmasıdır. NA (eksik) sayılar varsa bu paket çalışmaz ve daha granüler aralıklar üretir. Ayrıntılar için ?trending::predict.trending_model_fit’e bakın. Daha önce olduğu gibi, regresyonun çıktılarını görselleştirebiliriz.","code":"\n## epi hafta ve case_int değişkenlerini kullanarak fourier terimleri ekleyin\ncounts$fourier <- select(counts, epiweek, case_int) %>% \n  as_tsibble(index = epiweek) %>% \n  fourier(K = 1)\n\n## müdahale haftasını tanımla\nintervention_week <- yearweek(\"2008-12-31\")\n\n## regresyon için değişkenleri tanımlayın\ncounts <- counts %>% \n  mutate(\n    ## formüldeki t'ye karşılık gelir\n      ## hafta sayısı (muhtemelen düz epiweeks değişkenini de kullanabilir)\n    # linear = row_number(epiweek), \n    ## formüldeki delta(t-t0)'a karşılık gelir\n      ## müdahale öncesi veya sonrası dönem\n    intervention = as.numeric(epiweek >= intervention_week), \n    ## formüldeki (t-t0)^+'a karşılık gelir\n      ## müdahale sonrası hafta sayısı\n      ## (0 ile hesaplanan değer arasındaki sayılardan daha büyük sayıyı seçin)\n    time_post = pmax(0, epiweek - intervention_week + 1))\n## uydurmak istediğiniz modeli tanımlayın (negatif binom)\nmodel <- glm_nb_model(\n  ## ilgilenilen çıktı olarak vaka sayısını belirleyeni \n  case_int ~\n    ## trendi hesaba katmak için epiweek'i kullanın\n    epiweek +\n    ## mevsimselliği hesaba katmak için fourier terimlerini kullanın\n    fourier + \n    ## öncesi (pre-) veya sonrası (post-) dönemde ekleyin\n    intervention + \n    ## müdahale sonrası zamanı ekleyin\n    time_post\n    )\n\n## sayım veri setini kullanarak modelinizi uydurun \nfitted_model <- trending::fit(model, counts)\n\n## güven ve tahmin aralıklarını hesaplayın\nobserved <- predict(fitted_model, simulate_pi = FALSE)\n\n\n\n## tabloda tahminleri ve yüzde değişimini gösterin \nfitted_model %>% \n  ## orijinal negatif binom regresyonunu çıkarın\n  get_model() %>% \n  ## sonuçların düzenli (tidy) veri çerçevesini elde edin \n  tidy(exponentiate = TRUE, \n       conf.int = TRUE) %>% \n  ## sadece müdahale değerini koruyun\n  filter(term == \"intervention\") %>% \n  ## tahmin ve güven aralıkları için IRR'yi yüzde değişikliğine değiştirin\n  mutate(\n    ## ilgilenilen sütunların her biri için - yeni bir sütun oluşturun\n    across(\n      all_of(c(\"estimate\", \"conf.low\", \"conf.high\")), \n      ## yüzde değişimini hesaplamak için formülü uygulayın\n            .f = function(i) 100 * (i - 1), \n      ## yeni sütun adlarına bir sonek \"_perc\"  ekleyin\n      .names = \"{.col}_perc\")\n    ) %>% \n  ## yalnızca belirli sütunları tutun (ve yeniden adlandırın)\n  select(\"IRR\" = estimate, \n         \"95%CI low\" = conf.low, \n         \"95%CI high\" = conf.high,\n         \"Percentage change\" = estimate_perc, \n         \"95%CI low (perc)\" = conf.low_perc, \n         \"95%CI high (perc)\" = conf.high_perc,\n         \"p-value\" = p.value)## # A tibble: 1 × 7\n##     IRR `95%CI low` `95%CI high` `Percentage change` `95%CI low (perc)` `95%CI high (perc)` `p-value`\n##   <dbl>       <dbl>        <dbl>               <dbl>              <dbl>               <dbl>     <dbl>\n## 1 0.936       0.874         1.00               -6.40              -12.6               0.306    0.0645\nggplot(observed, aes(x = epiweek)) + \n  ## gözlemlenen vaka sayılarını bir çizgi olarak ekle\n  geom_line(aes(y = case_int, colour = \"Observed\")) + \n  ## model tahmini için bir satır ekleyin\n  geom_line(aes(y = estimate, col = \"Estimate\")) + \n  ## tahmin aralıkları için bir bant ekleyin\n  geom_ribbon(aes(ymin = lower_pi, \n                  ymax = upper_pi), \n              alpha = 0.25) + \n  ## tahminin nerede başladığını göstermek için dikey çizgi ve etiket ekleyin\n  geom_vline(\n           xintercept = as.Date(intervention_week), \n           linetype = \"dashed\") + \n  annotate(geom = \"text\", \n           label = \"Intervention\", \n           x = intervention_week, \n           y = max(observed$upper_pi), \n           angle = 90, \n           vjust = 1\n           ) + \n  ## renkleri tanımlayın\n  scale_colour_manual(values = c(\"Observed\" = \"black\", \n                                 \"Estimate\" = \"red\")) + \n  ## geleneksel bir grafik oluşturun (siyah eksenli ve beyaz arka planlı)\n  theme_classic()## Warning: Removed 13 rows containing missing values (`geom_line()`).\n## Uyarı: Eksik değerler içeren 13 satır kaldırıldı (geom_path)."},{"path":"zaman-serileri-ve-salgınların-tespit-edilmesi.html","id":"kaynaklar-16","chapter":"23 Zaman serileri ve salgınların tespit edilmesi","heading":"23.9 Kaynaklar","text":"Tahminleme: İlkeler ve uygulama ders kitabıEPIET zaman serisi analizi vaka çalışmalarıPenn State kursu\nSurveillance paketi metni","code":""},{"path":"salgın-modelleme.html","id":"salgın-modelleme","chapter":"24 Salgın Modelleme","heading":"24 Salgın Modelleme","text":"","code":""},{"path":"salgın-modelleme.html","id":"genel-bakış-3","chapter":"24 Salgın Modelleme","heading":"24.1 Genel Bakış","text":"Salgın modelleme için, oldukça karmaşık analizleri minimum çabayla yapmamızı sağlayan, büyüyen bir araç grubu vardır. Bu bölüm, bu araçların aşağıdaki amaçlarla nasıl kullanılacağına ilişkin bir genel bakış sağlayacaktır:etkin üreme sayısı Rt ve iki katına çıkma süresi gibi ilgili istatistikleri tahmin etmegelecekteki insidansın kısa vadeli projeksiyonlarını üretmeBu bölüm araçların altında yatan metodolojilere ve istatistiksel yöntemlere genel bir bakış değildir, bu nedenle bu konuyu kapsayan bazı makalelere bağlantılar için lütfen Kaynaklar sekmesine bakınız. Bu araçları kullanmadan önce yöntemleri anladığınızdan emin olun; bu, sonuçlarını doğru bir şekilde yorumlayabilmenizi sağlayacaktır.Aşağıda, bu bölümde üreteceğimiz çıktılardan birine bir örnek verilmiştir.","code":""},{"path":"salgın-modelleme.html","id":"hazırlık-15","chapter":"24 Salgın Modelleme","heading":"24.2 Hazırlık","text":"Rt tahmini için EpiNow ve EpiEstim olmak üzere iki farklı yöntem ve paketin yanı sıra vaka insidansını tahmin etmek için projections paketini kullanacağız.Bu kod parçası, analizler için gereken paketlerin yüklenmesini gösterir.\nBu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() vurgusunu yapıyoruz.\nbase R’dan library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakın.Bu bölümdeki tüm analizler için temizlenmiş vaka satır listesini kullanacağız. Takip etmek isterseniz, “clean” dosyasını indirmek için tıklayın. ” \n(.rds dosyası olarak). Bu el kitabında kullanılan tüm örnek verileri indirmek için [El kitabı ve verileri indir] sayfasına bakınız.","code":"\npacman::p_load(\n   rio,          # dosya içe aktarma\n   here,         # dosya konumlama\n   tidyverse,    # Veri yönetimi + ggplot2 grafikleri\n   epicontacts,  # bulaş ağlarının analizi\n   EpiNow2,      # Rt tahminleme\n   EpiEstim,     # Rt tahminleme\n   projections,  # İnsidans öngörme\n   incidence2,   # İnsidans verilerini işleme\n   epitrix,      # Faydalı epi fonksiyonları\n   distcrete     # Ayrık gecikme dağılımları\n)\n# temizlenmiş satır listesini içe aktarma\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"salgın-modelleme.html","id":"rt-tahmini","chapter":"24 Salgın Modelleme","heading":"24.3 Rt Tahmini","text":"","code":""},{"path":"salgın-modelleme.html","id":"epinow2-vs.-epiestim","chapter":"24 Salgın Modelleme","heading":"EpiNow2 vs. EpiEstim","text":"Üreme sayısı R, bir hastalığın bulaşıcılığının bir ölçüsüdür ve enfekte vaka başına beklenen ikincil vaka sayısı olarak tanımlanır. Tamamen duyarlı bir popülasyonda bu değer, R0 (Rnought) temel üreme sayısını temsil eder. Bununla birlikte, bir salgın veya pandemi sırasında bir popülasyondaki duyarlı bireylerin sayısı değiştikçe ve çeşitli müdahale önlemleri uygulandıkça, en yaygın olarak kullanılan ölçüm aktarılabilirlik, etkili üreme sayısıdır Rt; bu, belirli bir t zamanında virüslü vaka başına beklenen ikincil vaka sayısı olarak tanımlanır.EpiNow2 paketi, Rt tahmini için en gelişmiş çerçeveyi sağlar. Diğer yaygın olarak kullanılan paket olan EpiEstim’e göre iki önemli avantajı vardır:Raporlamadaki gecikmeleri hesaba katar ve bu nedenle son veriler eksik olsa bile Rt tahminini yapabilir.Rt’yi raporlamanın başlangıç ​​tarihlerinden ziyade enfeksiyon tarihlerinde tahmin eder; bu, bir müdahalenin etkisinin Rt’deki bir değişikliğe gecikme ile değil hemen yansıtılacağı anlamına gelir.Bununla birlikte, aynı zamanda iki önemli dezavantajı vardır:Bulaş süresi dağılımı (yani birincil ve ikincil vakaların enfeksiyonu arasındaki gecikmelerin dağılımı), kuluçka dönemi dağılımı (yani enfeksiyon ve semptom başlangıcı arasındaki gecikmelerin dağılımı) ve verilerinizle ilgili herhangi bir başka gecikme dağılımı (ör. raporlama tarihleriniz varsa, semptomların başlangıcından raporlamaya kadar olan gecikmelerin dağılımına ihtiyaç duyarsınız). Bu, Rt’nin daha doğru bir şekilde tahmin edilmesini sağlayacak olsa da, EpiEstim yalnızca seri aralık dağılımını (yani, birincil ve ikincil vakanın semptom başlangıcı arasındaki gecikmelerin dağılımına) ihtiyaç duyar. Elinizdeki tek veri bu olduğunda çok kıymetlidir.EpiNow2, EpiEstim’den önemli ölçüde daha yavaştır, anekdot olarak yaklaşık 100-1000 kat! Örneğin, bu bölümde ele alınan örnek salgın için Rt tahmini yaklaşık dört saat sürer (bu, yüksek doğruluk sağlamak için çok sayıda yineleme için çalıştırılmasındandır. Gerekirse muhtemelen azaltılabilir, ancak ifade edilmek istenen algoritmanın genel olarak yavaş çalıştığıdır). Rt tahminlerinizi düzenli olarak güncelliyorsanız, kullanışlı olmayabilir.Bu nedenle hangi paketi kullanmayı seçeceğiniz, size sunulan verilere, zamana ve hesaplama kaynaklarına bağlı olacaktır.","code":""},{"path":"salgın-modelleme.html","id":"epinow2","chapter":"24 Salgın Modelleme","heading":"EpiNow2","text":"","code":""},{"path":"salgın-modelleme.html","id":"tahmini-gecikme-dağılımları","chapter":"24 Salgın Modelleme","heading":"Tahmini gecikme dağılımları","text":"EpiNow2’yi çalıştırmak için gereken gecikme dağılımları, sahip olduğunuz verilere bağlıdır. Esasen, Rt tahmininde kullanmak istediğiniz bulaşma tarihinden olay tarihine kadar olan gecikmeyi tanımlayabilmeniz gerekir. Başlangıç ​​tarihlerini kullanıyorsanız, bu sadece kuluçka dönemi dağılımı olacaktır. Raporlama tarihlerini kullanıyorsanız, enfeksiyondan raporlamaya kadar olan gecikmeye ihtiyacınız vardır. Bu dağıtımın doğrudan bilinmesi pek mümkün olmadığından, EpiNow2 birden çok gecikme dağıtımını birlikte zincirlemenize olanak tanır. Bu durumda, enfeksiyondan semptom başlangıcına (örneğin, muhtemelen bilinen kuluçka dönemi) ve semptom başlangıcından raporlamaya (genellikle verilerden tahmin edebileceğiniz) gecikmeyi bilmelisiniz.Örnek satır listesindeki tüm vakalarımız için başlangıç ​​tarihlerine sahip olduğumuzdan, verilerimizi (örn. semptom başlangıç ​​tarihleri) enfeksiyon tarihine bağlamak için yalnızca kuluçka dönemi dağılımına ihtiyaç duyacağız. Bu dağılımı verilerden tahmin edebilir veya literatürdeki değerleri kullanabiliriz.Ebola’nın kuluçka dönemine ilişkin bir literatür tahmini (bu makaleden alınmıştır) ortalama 9.1, standart sapma 7.3 ve maksimum değer 30 aşağıdaki gibi belirtilecektir:EpiNow2 bu gecikme dağılımlarının bir log ölçeğinde sağlanmasını gerektirdiğini unutmayın, bu nedenle “log” değerin etrafında çağrılır (kafa karıştırıcı bir şekilde doğal bir değerde sağlanması gereken “max” parametresi hariç). “mean_sd” ve “sd_sd”, ortalamanın standart sapması ve standart sapmasının tahminlerini tanımlamaktadır. Bu durumda bunlar bilinmediğinden, oldukça gelişigüzel 0,1 değerini seçiyoruz.Bu analizde, kuluçka dönemi dağılımını tahmin etmemiz gibi değil, satır listesinde enfeksiyon ve başlangıç ​​arasında gözlemlenen gecikmelere uyacak bir lognormal dağılımı ‘bootstrapped_dist_fit’ fonksiyonu ile tahminliyoruz.İhtiyacımız olan diğer dağılım ise üreme süresidir. Bulaşma zamanları ve iletim bağlantılarına ilişkin verilerimiz olduğundan, bu dağılımı, bulaşan-bulaşan çiftlerinin bulaşma süreleri arasındaki gecikmeyi hesaplayarak satır listesinden tahmin edebiliriz. Bunu yapmak için, epicontacts paketindeki kullanışlı get_pairwise fonksiyonunu kullanıyoruz. Bu, iletim çiftleri arasındaki satır listesi özelliklerinin ikili farklılıklarını hesaplamamıza izin veriyor. Önce bir epicontacts nesnesi oluşturuyoruz (daha fazla ayrıntı için İletim zincirleri sayfasına bakabilirsiniz):Daha sonra, “get_pairwise” kullanılarak hesaplanan iletim çiftleri arasındaki enfeksiyon sürelerindeki farkı bir gama dağılımına uydururuz:","code":"\nincubation_period_lit <- list(\n  mean = log(9.1),\n  mean_sd = log(0.1),\n  sd = log(7.3),\n  sd_sd = log(0.1),\n  max = 30\n)\n## inkübasyon süresini tahminleme\nincubation_period <- bootstrapped_dist_fit(\n  linelist$date_onset - linelist$date_infection,\n  dist = \"lognormal\",\n  max_value = 100,\n  bootstraps = 1\n)\n## kişileri oluştur\ncontacts <- linelist %>%\n  transmute(\n    from = infector,\n    to = case_id\n  ) %>%\n  drop_na()\n\n## temaslı kişileri oluştur\nepic <- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n## gama oluşturma süresini tahmin et\ngeneration_time <- bootstrapped_dist_fit(\n  get_pairwise(epic, \"date_infection\"),\n  dist = \"gamma\",\n  max_value = 20,\n  bootstraps = 1\n)"},{"path":"salgın-modelleme.html","id":"epinow2-çalıştırmak","chapter":"24 Salgın Modelleme","heading":"EpiNow2 Çalıştırmak","text":"Şimdi sadece dplyr group_by() ve n() fonskiyonlarıyla kolayca yapabileceğimiz satır listesinden günlük insidansı hesaplamamız gerekiyor. EpiNow2 sütun adlarının “date” ve “confirm” olmasını gerektirdiğini unutmayın.Daha sonra ‘epinow’ fonksiyonunu kullanarak Rt değerini tahmin edebiliriz. Girişlerle ilgili bazı notlar:‘delays’ değişkenine herhangi bir sayıda ‘zincirleme’ gecikme dağılımı sağlayabiliriz; onları sadece ‘delay_opts’ işlevi içindeki incubation_period’ nesnesinin yanına ekleyebiliriz.“return_output”, çıktının yalnızca bir dosyaya kaydedilmesini değil, R içinde döndürülmesini sağlar.“verbose” ilerlemenin bir okumasını istediğimizi belirtir.“horizon”, gelecekteki insidansı kaç gün için tahmin etmek istediğimizi gösterir.Çıkarımı ne kadar süreyle çalıştırmak istediğimizi belirtmek için ‘stan’ değişkenine ek seçenekler iletiyoruz. Artan “örnekler” ve “zincirler”, belirsizliği daha iyi karakterize eden daha doğru bir tahmin verecektir, ancak çalışması daha uzun sürecektir..","code":"\n## başlangıç tarihlerinden insidans almak\ncases <- linelist %>%\n  group_by(date = date_onset) %>%\n  summarise(confirm = n())\n## epinow çalıştır\nepinow_res <- epinow(\n  reported_cases = cases,\n  generation_time = generation_time,\n  delays = delay_opts(incubation_period),\n  return_output = TRUE,\n  verbose = TRUE,\n  horizon = 21,\n  stan = stan_opts(samples = 750, chains = 4)\n)"},{"path":"salgın-modelleme.html","id":"çıktıları-analiz-etme","chapter":"24 Salgın Modelleme","heading":"Çıktıları analiz etme","text":"Kodun çalışması bittiğinde, aşağıdaki gibi çok kolay bir şekilde bir özet çizebiliriz. Resmin tamamını görmek için kaydırınız.Ayrıca çeşitli özet istatistiklere de bakabiliriz:Daha fazla analiz ve özel çizim için, $estimates$summarised üzerinden özetlenen günlük tahminlere erişebilirsiniz. dplyr ile kullanım kolaylığı için bunu varsayılan ’veri.tablosu’ndan ’tibble’çevireceğiz.Örnek olarak, ikiye katlama süresinin ve Rt’nin bir grafiğini yapalım. Aşırı yüksek katlama zamanlarını planlamaktan kaçınmak için, Rt birin çok üzerinde olduğunda, salgının yalnızca ilk birkaç ayına bakacağız.Tahmini büyüme oranından iki katına çıkma süresini hesaplamak için “log(2)/growth_rate” formülünü kullanırız.","code":"\n## özet grafiği çiz\nplot(epinow_res)\n## özet tablo\nepinow_res$summary##                                  measure                  estimate  numeric_estimate\n## 1: New confirmed cases by infection date                4 (2 -- 6) <data.table[1x9]>\n## 2:        Expected change in daily cases                    Unsure              0.56\n## 3:            Effective reproduction no.        0.88 (0.73 -- 1.1) <data.table[1x9]>\n## 4:                        Rate of growth -0.012 (-0.028 -- 0.0052) <data.table[1x9]>\n## 5:          Doubling/halving time (days)          -60 (130 -- -25) <data.table[1x9]>\n## özeti çıkar ve tibble'a dönüştür\nestimates <- as_tibble(epinow_res$estimates$summarised)\nestimates\n## medyan çizim için geniş df yapın\ndf_wide <- estimates %>%\n  filter(\n    variable %in% c(\"growth_rate\", \"R\"),\n    date < as.Date(\"2014-09-01\")\n  ) %>%\n  ## büyüme oranlarını ikiye katlama sürelerine dönüştürme\n  mutate(\n    across(\n      c(median, lower_90:upper_90),\n      ~ case_when(\n        variable == \"growth_rate\" ~ log(2)/.x,\n        TRUE ~ .x\n      )\n    ),\n    ## dönüşümü yansıtmak için değişkeni yeniden adlandırın\n    variable = replace(variable, variable == \"growth_rate\", \"doubling_time\")\n  )\n\n## nicel çizim için uzun df yapın\ndf_long <- df_wide %>%\n  ## burada eşleşen nicelikleri eşleştiriyoruz (örneğin, alt_90 ila üst_90)\n  pivot_longer(\n    lower_90:upper_90,\n    names_to = c(\".value\", \"quantile\"),\n    names_pattern = \"(.+)_(.+)\"\n  )\n\n## grafik yapın\nggplot() +\n  geom_ribbon(\n    data = df_long,\n    aes(x = date, ymin = lower, ymax = upper, alpha = quantile),\n    color = NA\n  ) +\n  geom_line(\n    data = df_wide,\n    aes(x = date, y = median)\n  ) +\n  ## alt simge etiketine izin vermek için label_parsed kullanın\n  facet_wrap(\n    ~ variable,\n    ncol = 1,\n    scales = \"free_y\",\n    labeller = as_labeller(c(R = \"R[t]\", doubling_time = \"Doubling~time\"), label_parsed),\n    strip.position = 'left'\n  ) +\n  ## nicel şeffaflığı manuel olarak tanımla\n  scale_alpha_manual(\n    values = c(`20` = 0.7, `50` = 0.4, `90` = 0.2),\n    labels = function(x) paste0(x, \"%\")\n  ) +\n  labs(\n    x = NULL,\n    y = NULL,\n    alpha = \"Credibel\\ninterval\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\",\n    date_labels = \"%b %d\\n%Y\"\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(\n    strip.background = element_blank(),\n    strip.placement = 'outside'\n  )"},{"path":"salgın-modelleme.html","id":"epiestim","chapter":"24 Salgın Modelleme","heading":"EpiEstim","text":"EpiEstim’çalıştırmak için günlük insidans hakkında veri sağlamamız ve seri aralığı (yani semptomların başlangıcı arasındaki gecikmelerin dağılımını (birincil ve ikincil vakalar) belirtmemiz gerekir).İnsidans verileri EpiEstim’e bir vektör, veri çerçevesi veya orijinal insidans paketinden bir “insidans” nesnesi olarak sağlanabilir. İçe aktamalar ve yerel olarak edinilen enfeksiyonlar arasında bile ayrım yapabilirsiniz. Daha fazla detay için ?estimate_R adresindeki belgelere bakabilirsiniz.Girdiyi incidence2 kullanarak oluşturacağız. incidence2 paketiyle ilgili daha fazla örnek için Salgın eğrileri ile ilgili sayfaya bakabilirsiniz. incidence2 paketinde, “estimateR()”nin beklenen girdisiyle tam olarak uyuşmayan güncellemeler olduğundan, gerekli bazı küçük ek adımlar vardır. İnsidans nesnesi, tarihlerin ve ilgili vaka sayılarının bulunduğu bir tibble’dan oluşur. Tüm tarihlerin dahil edildiğinden emin olmak için tidyr’den ‘complete()’ kullanırız. Daha sonra sonraki bir adımda ‘estimate_R()’ tarafından beklenenle hizalanacak şekilde sütunları ‘yeniden adlandırın()’.Paket, ayrıntıları “?estimate_R” adresindeki belgelerde sağlanan seri aralığı belirtmek için çeşitli seçenekler sunar. Biz burada bunlardan ikisini ele alacağız.","code":"\n## başlangıç tarihinden itibaren insidansı almak\ncases <- incidence2::incidence(linelist, date_index = date_onset) %>% # günlere göre vaka sayılarını al\n  tidyr::complete(date_index = seq.Date(                              # tüm tarihlerin temsil edildiğinden emin olun\n    from = min(date_index, na.rm = T),\n    to = max(date_index, na.rm=T),\n    by = \"day\"),\n    fill = list(count = 0)) %>%                                       # NA sayılarını 0'a çevir\n  rename(I = count,                                                   # EstimateR'a göre beklenen adlarla yeniden adlandırın\n         \n         dates = date_index)"},{"path":"salgın-modelleme.html","id":"literatürden-seri-aralık-tahminlerini-kullanma","chapter":"24 Salgın Modelleme","heading":"Literatürden seri aralık tahminlerini kullanma","text":"method = \"parametric_si\" seçeneğini kullanarak, make_configfonksiyonu kullanılarak oluşturulan birconfig` nesnesindeki seri aralığın ortalamasını ve standart sapmasını manuel olarak belirtebiliriz. [Bu belgede] https://bmcmedicine.biomedcentral.com/articles/10.1186/s12916-014-0196-0'da tanımlanan sırasıyla 12,0 ve 5,2’lik bir ortalama ve standart sapma kullanıyoruz:Daha sonra estimate_R fonksiyonuyla Rt değerini tahmin edebiliriz:ve çıktıların bir özetini çizin:","code":"\n## make config\nconfig_lit <- make_config(\n  mean_si = 12.0,\n  std_si = 5.2\n)\nepiestim_res_lit <- estimate_R(\n  incid = cases,\n  method = \"parametric_si\",\n  config = config_lit\n)## Default config will estimate R on weekly sliding windows.\n##     To change this change the t_start and t_end arguments.\nplot(epiestim_res_lit)"},{"path":"salgın-modelleme.html","id":"verilerden-seri-aralık-tahminlerini-kullanma","chapter":"24 Salgın Modelleme","heading":"Verilerden seri aralık tahminlerini kullanma","text":"Semptom başlangıç tarihlerine ve iletim bağlantılarına ilişkin verilere sahip olduğumuz için, bulaştırıcı-enfekte çiftlerinin başlangıç tarihleri arasındaki gecikmeyi hesaplayarak satır listesinden seri aralığı da tahmin edebiliriz. EpiNow2 bölümünde yaptığımız gibi, epicontacts paketindeki get_pairwise fonksiyonunu kullanacağız, bu da iletim çiftleri arasındaki satır listesi özelliklerinin ikili farklarını hesaplamamızı sağlar. Önce bir epicontacts nesnesi oluşturuyoruz (daha fazla ayrıntı için İletim zincirleri sayfasına bakın):Daha sonra, “get_pairwise” kullanılarak hesaplanan iletim çiftleri arasındaki başlangıç tarihlerindeki farkı bir gama dağılımına uydururuz. Bu yerleştirme prosedürü için epitrix paketindeki kullanışlı ’fit_disc_gamma’yı kullanıyoruz, çünkü bir ayrıştırılmış dağıtıma ihtiyacımız var.Daha sonra bu bilgiyi config nesnesine iletiyoruz, EpiEstim’tekrar çalıştırıyoruz ve sonuçları çiziyoruz:","code":"\n## kişileri oluştur\ncontacts <- linelist %>%\n  transmute(\n    from = infector,\n    to = case_id\n  ) %>%\n  drop_na()\n\n## temaslıları oluştur\nepic <- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n## gama seri aralığını tahmin et\nserial_interval <- fit_disc_gamma(get_pairwise(epic, \"date_onset\"))\n## yapılandırma yap\nconfig_emp <- make_config(\n  mean_si = serial_interval$mu,\n  std_si = serial_interval$sd\n)\n\n## epiestim çalıştır\nepiestim_res_emp <- estimate_R(\n  incid = cases,\n  method = \"parametric_si\",\n  config = config_emp\n)## Default config will estimate R on weekly sliding windows.\n##     To change this change the t_start and t_end arguments.\n## grafik çıktısı al\nplot(epiestim_res_emp)"},{"path":"salgın-modelleme.html","id":"tahmin-zaman-pencerelerini-belirtme","chapter":"24 Salgın Modelleme","heading":"Tahmin zaman pencerelerini belirtme","text":"Bu varsayılan seçenekler, haftalık kayan bir tahmin sağlar ve kesin bir tahmin için Rt’ı salgında çok erken tahmin ettiğinize dair bir uyarı görevi görebilir. Aşağıda gösterildiği gibi tahmin için daha ileri bir başlangıç tarihi ayarlayarak bunu değiştirebilirsiniz. Ne yazık ki, EpiEstim, zaman penceresi için başlangıç ve bitiş tarihlerine atıfta bulunan bir tam sayı vektörü sağlamanız gerektiğinden, bu tahmin sürelerini belirtmek için yalnızca çok hantal bir yol sağlar.Şimdi EpiEstim’yeniden çalıştırıyoruz ve tahminlerin yalnızca Haziran’dan itibaren başladığını görebiliyoruz:","code":"\n## 1 Haziran'da başlayan bir tarih vektörü tanımlayın\nstart_dates <- seq.Date(\n  as.Date(\"2014-06-01\"),\n  max(cases$dates) - 7,\n  by = 1\n) %>%\n  ## sayısala dönüştürmek için başlangıç tarihini çıkarın\n  `-`(min(cases$dates)) %>%\n  ## tam sayıya çevirin\n  as.integer()\n\n## bir haftalık sürgülü pencere protokolüne altı gün ekleyin\nend_dates <- start_dates + 6\n  \n## yapılandırma yap\nconfig_partial <- make_config(\n  mean_si = 12.0,\n  std_si = 5.2,\n  t_start = start_dates,\n  t_end = end_dates\n)\n## epiestim'i çalıştır\nepiestim_res_partial <- estimate_R(\n  incid = cases,\n  method = \"parametric_si\",\n  config = config_partial\n)\n\n## çıktıları grafikleştir\nplot(epiestim_res_partial)"},{"path":"salgın-modelleme.html","id":"çıktıları-analiz-etme-1","chapter":"24 Salgın Modelleme","heading":"Çıktıları analiz etme","text":"Ana çıkışlara $R üzerinden erişilebilir. Örnek olarak, bir Rt grafiği ve Rt çarpımı ve o gün rapor edilen vaka sayısı tarafından verilen bir “iletim potansiyeli” ölçüsü oluşturacağız. Bu, yeni nesil enfeksiyonda beklenen vaka sayısını temsil eder.","code":"\n## medyan için geniş veri çerçevesi yapın\ndf_wide <- epiestim_res_lit$R %>%\n  rename_all(clean_labels) %>%\n  rename(\n    lower_95_r = quantile_0_025_r,\n    lower_90_r = quantile_0_05_r,\n    lower_50_r = quantile_0_25_r,\n    upper_50_r = quantile_0_75_r,\n    upper_90_r = quantile_0_95_r,\n    upper_95_r = quantile_0_975_r,\n    ) %>%\n  mutate(\n    ## medyan tarihini t_start ve t_end'den çıkarın\n    dates = epiestim_res_emp$dates[round(map2_dbl(t_start, t_end, median))],\n    var = \"R[t]\"\n  ) %>%\n  ## günlük insidans verilerinde birleştirme  \n  left_join(cases, \"dates\") %>%\n  ## tüm r tahminlerinde riski hesapla\n  mutate(\n    across(\n      lower_95_r:upper_95_r,\n      ~ .x*I,\n      .names = \"{str_replace(.col, '_r', '_risk')}\"\n    )\n  ) %>%\n  ## ayrı r tahminleri ve risk tahminleri\n  pivot_longer(\n    contains(\"median\"),\n    names_to = c(\".value\", \"variable\"),\n    names_pattern = \"(.+)_(.+)\"\n  ) %>%\n  ## faktör seviyeleri atamak\n  mutate(variable = factor(variable, c(\"risk\", \"r\")))\n\n## niceliklerden uzun veri çerçevesi yapmak\ndf_long <- df_wide %>%\n  select(-variable, -median) %>%\n  ## seperate r/risk estimates and quantile levels\n  pivot_longer(\n    contains(c(\"lower\", \"upper\")),\n    names_to = c(\".value\", \"quantile\", \"variable\"),\n    names_pattern = \"(.+)_(.+)_(.+)\"\n  ) %>%\n  mutate(variable = factor(variable, c(\"risk\", \"r\")))\n\n## grafik yapmak\nggplot() +\n  geom_ribbon(\n    data = df_long,\n    aes(x = dates, ymin = lower, ymax = upper, alpha = quantile),\n    color = NA\n  ) +\n  geom_line(\n    data = df_wide,\n    aes(x = dates, y = median),\n    alpha = 0.2\n  ) +\n  ## alt simge etiketine izin vermek için label_parsed kullanın\n  facet_wrap(\n    ~ variable,\n    ncol = 1,\n    scales = \"free_y\",\n    labeller = as_labeller(c(r = \"R[t]\", risk = \"Transmission~potential\"), label_parsed),\n    strip.position = 'left'\n  ) +\n  ## nicel şeffaflığı manuel olarak tanımla\n  scale_alpha_manual(\n    values = c(`50` = 0.7, `90` = 0.4, `95` = 0.2),\n    labels = function(x) paste0(x, \"%\")\n  ) +\n  labs(\n    x = NULL,\n    y = NULL,\n    alpha = \"Credible\\ninterval\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\",\n    date_labels = \"%b %d\\n%Y\"\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(\n    strip.background = element_blank(),\n    strip.placement = 'outside'\n  )"},{"path":"salgın-modelleme.html","id":"tahmini-insidans","chapter":"24 Salgın Modelleme","heading":"24.4 Tahmini insidans","text":"","code":""},{"path":"salgın-modelleme.html","id":"epinow2-1","chapter":"24 Salgın Modelleme","heading":"EpiNow2","text":"EpiNow2, Rt tahmininin yanı sıra, başlık altındaki EpiSoon paketi ile entegrasyon yoluyla Rt tahminini ve vaka sayılarının projeksiyonlarını da destekler. Tek yapmanız gereken, ‘epinow’ fonksiyon çağrınızda, geleceğe kaç gün yansıtmak istediğinizi belirten ‘horizon’ değişkenini belirtmek; EpiNow2’nin nasıl kurulup çalıştırılacağına ilişkin ayrıntılar için “Rt Tahmini” altındaki EpiNow2 bölümüne bakabilirsiniz. Bu bölümde, “epinow_res” nesnesinde saklanan bu analizin çıktılarını çizeceğiz.","code":"\n## grafik için minimum tarihi belirleyin\nmin_date <- as.Date(\"2015-03-01\")\n\n## özetlenmiş tahminleri çıkar\nestimates <-  as_tibble(epinow_res$estimates$summarised)\n\n## vaka insidansı hakkında ham verileri ayıklayın\nobservations <- as_tibble(epinow_res$estimates$observations) %>%\n  filter(date > min_date)\n\n## vaka sayılarının öngörülen tahminlerini çıkarın\ndf_wide <- estimates %>%\n  filter(\n    variable == \"reported_cases\",\n    type == \"forecast\",\n    date > min_date\n  )\n\n## nicel çizim için daha da uzun formata dönüştürün\ndf_long <- df_wide %>%\n  ## burada eşleşen nicelikleri eşleştiriyoruz (örneğin, alt_90 ila üst_90)\n  pivot_longer(\n    lower_90:upper_90,\n    names_to = c(\".value\", \"quantile\"),\n    names_pattern = \"(.+)_(.+)\"\n  )\n\n## çizimi yapın\nggplot() +\n  geom_histogram(\n    data = observations,\n    aes(x = date, y = confirm),\n    stat = 'identity',\n    binwidth = 1\n  ) +\n  geom_ribbon(\n    data = df_long,\n    aes(x = date, ymin = lower, ymax = upper, alpha = quantile),\n    color = NA\n  ) +\n  geom_line(\n    data = df_wide,\n    aes(x = date, y = median)\n  ) +\n  geom_vline(xintercept = min(df_long$date), linetype = 2) +\n  ## nicel şeffaflığı manuel olarak tanımla\n  scale_alpha_manual(\n    values = c(`20` = 0.7, `50` = 0.4, `90` = 0.2),\n    labels = function(x) paste0(x, \"%\")\n  ) +\n  labs(\n    x = NULL,\n    y = \"Daily reported cases\",\n    alpha = \"Credible\\ninterval\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\",\n    date_labels = \"%b %d\\n%Y\"\n  ) +\n  theme_minimal(base_size = 14)"},{"path":"salgın-modelleme.html","id":"projeksiyonlar","chapter":"24 Salgın Modelleme","heading":"Projeksiyonlar","text":"RECON tarafından geliştirilen projeksiyonlar paketi, etkin üreme sayısı Rt ve seri aralığı hakkında bilgi gerektiren kısa vadeli insidans tahminleri yapmayı çok kolaylaştırır. Burada literatürden seri aralık tahminlerinin nasıl kullanılacağını ve satır listesinden kendi tahminlerimizin nasıl kullanılacağını ele alacağız.","code":""},{"path":"salgın-modelleme.html","id":"literatürden-seri-aralık-tahminlerini-kullanma-1","chapter":"24 Salgın Modelleme","heading":"Literatürden seri aralık tahminlerini kullanma","text":"projeksiyonlar, discrete paketinden ‘discrete’ sınıfının ayrık bir seri aralık dağılımını gerektirir. Bu yazıda tanımlanan ortalama 12.0 ve standart sapması 5.2 olan bir gama dağılımı kullanacağız. Bu değerleri bir gama dağılımı için gereken şekil ve ölçek parametrelerine dönüştürmek için, epitrix paketindeki ‘gamma_mucv2shapescale’ fonkdiyonunu kullanacağız.İşte seri aralığın doğru göründüğünden emin olmak için hızlı bir kontrol. Az önce tanımladığımız gama dağılımının yoğunluğuna, ‘dgamma’ çağırmaya eşdeğer olan ‘$d’ ile erişiriz:","code":"\n## ortalama mu ve katsayısından şekil ve ölçek parametreleri alın\n## varyasyon (ör. standart sapmanın ortalamaya oranı)\nshapescale <- epitrix::gamma_mucv2shapescale(mu = 12.0, cv = 5.2/12)\n\n## ayrık nesne yapmak\nserial_interval_lit <- distcrete::distcrete(\n  name = \"gamma\",\n  interval = 1,\n  shape = shapescale$shape,\n  scale = shapescale$scale\n)\n## seri aralığın doğru göründüğünden emin olmak için kontrol edin\nqplot(\n  x = 0:50, y = serial_interval_lit$d(0:50), geom = \"area\",\n  xlab = \"Serial interval\", ylab = \"Density\"\n)"},{"path":"salgın-modelleme.html","id":"verilerinden-seri-aralık-tahminlerini-kullanma","chapter":"24 Salgın Modelleme","heading":"Verilerinden seri aralık tahminlerini kullanma","text":"Semptom başlangıç tarihlerine ve iletim bağlantılarına ilişkin verilere sahip olduğumuz için, bulaştırıcı-enfekte çiftlerinin başlangıç tarihleri arasındaki gecikmeyi hesaplayarak satır listesinden seri aralığı da tahmin edebiliriz. EpiNow2 bölümünde yaptığımız gibi, epicontacts paketindeki get_pairwise fonksiyonunu kullanacağız. Bu da iletim çiftleri arasındaki satır listesi özelliklerinin ikili farklarını hesaplamamıza izin verir. Önce bir epicontacts nesnesi oluşturuyoruz (daha fazla ayrıntı için İletim zincirleri sayfasına bakabilirsiniz:Daha sonra iletim çiftleri arasındaki başlangıç tarihlerindeki farkı bir gama dağılımına uydururuz, “get_pairwise” kullanarak hesaplarız. Ayrık bir dağıtım gerektirdiğinden, bu yerleştirme prosedürü için epitrix paketindeki kullanışlı ’fit_disc_gamma’yı kullanıyoruz.","code":"\n## kişileri üretin \ncontacts <- linelist %>%\n  transmute(\n    from = infector,\n    to = case_id\n  ) %>%\n  drop_na()\n\n## temaslı kişileri üretin\nepic <- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n## gama seri aralığını tahmin et\nserial_interval <- fit_disc_gamma(get_pairwise(epic, \"date_onset\"))\n\n## tahmini inceleme\nserial_interval[c(\"mu\", \"sd\")]## $mu\n## [1] 11.51242\n## \n## $sd\n## [1] 7.700005"},{"path":"salgın-modelleme.html","id":"tahmini-insidans-1","chapter":"24 Salgın Modelleme","heading":"Tahmini insidans","text":"Gelecekteki vakaları tahmin etmek için, yine de bir “insidans” nesnesi şeklinde tarihsel vakayı ve ayrıca makul Rt değerleri örneğini sağlamamız gerekiyor. Bu değerleri, önceki bölümde (“Tahmini Rt” başlığı altında) EpiEstim tarafından oluşturulan ve ‘epiestim_res_emp’ nesnesi içinde depolanan Rt tahminlerini kullanarak üreteceğiz. Aşağıdaki kodda, Rt için ortalama ve standart sapma tahminlerini çıkarıyoruz. Salgının son zaman penceresi (bir vektördeki son öğeye erişmek için “tail” fonksiyonunu kullanarak) ve “rgamma” kullanarak bir gama dağılımından 1000 değeri simüle edin. İleriye dönük projeksiyonlar için kullanmak istediğiniz kendi Rt değerleri vektörünüzü de sağlayabilirsiniz.Daha sonra gerçek tahmini yapmak için project() fonksiyonunu kullanırız. ‘n_days’ değişkenleri ile kaç gün için projeksiyon yapmak istediğimizi ve ‘n_sim’ değişkeni kullanarak simülasyonların sayısını belirliyoruz.Daha sonra ‘plot()’ ve ‘add_projections()’ fonksiyonlarını kullanarak insidansı ve projeksiyonları kolayca çizebiliriz. Köşeli parantez operatörünü kullanarak yalnızca en son durumları göstermek için ‘insidans’ nesnesini kolayca alt kümeye koyabiliriz.Çıktıyı bir veri çerçevesine dönüştürerek günlük vaka sayılarının ham tahminlerini de kolayca çıkarabilirsiniz.","code":"\n## başlangıç tarihlerinden insidans nesnesi oluşturun\ninc <- incidence::incidence(linelist$date_onset)## 256 missing observations were removed.\n## en son tahminden makul r değerleri çıkar\nmean_r <- tail(epiestim_res_emp$R$`Mean(R)`, 1)\nsd_r <- tail(epiestim_res_emp$R$`Std(R)`, 1)\nshapescale <- gamma_mucv2shapescale(mu = mean_r, cv = sd_r/mean_r)\nplausible_r <- rgamma(1000, shape = shapescale$shape, scale = shapescale$scale)\n\n## dağıtımı kontrol et\nqplot(x = plausible_r, geom = \"histogram\", xlab = expression(R[t]), ylab = \"Counts\")## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n## projeksiyon yapma\nproj <- project(\n  x = inc,\n  R = plausible_r,\n  si = serial_interval$distribution,\n  n_days = 21,\n  n_sim = 1000\n)\n## insidans ve projeksiyon çizimi\nplot(inc[inc$dates > as.Date(\"2015-03-01\")]) %>%\n  add_projections(proj)\n## ham veriler için veri çerçevesine dönüştür\nproj_df <- as.data.frame(proj)\nproj_df"},{"path":"salgın-modelleme.html","id":"kaynaklar-17","chapter":"24 Salgın Modelleme","heading":"24.5 Kaynaklar","text":"EpiEstim’de uygulanan metodolojiyi açıklayan makale.EpiNow2’de uygulanan metodolojiyi açıklayan makale.Rt tahminine yönelik çeşitli metodolojik ve pratik hususları açıklayan makale.","code":""},{"path":"temaslı-izlemi.html","id":"temaslı-izlemi","chapter":"25 Temaslı izlemi","heading":"25 Temaslı izlemi","text":"Bu sayfa, bu tür verilere özgü bazı önemli hususları ve yaklaşımları ekleyerek, kişi izleme verilerinin açıklayıcı analizini gösterir.Bu sayfa, diğer sayfalarda kapsanan temel R veri yönetimi ve görselleştirme yetkinliklerinin çoğuna atıfta bulunur (ör. veri temizleme, özet oluşturma, tablolar, zaman serisi analizleri), ancak operasyonel karar verme için yararlı olan kişi izlemeye özgü örnekleri yine de vurgulayacağız. Örneğin, zaman içinde veya coğrafi alanlar arasında temaslı izleme takip verilerinin görselleştirilmesini veya ilgili temaslı izleme yöneticileri için temiz Temel Performans Göstergesi (KPI) tablolarının oluşturulmasını içerir.Gösteri amacıyla Veriye.Git platformundan örnek temaslı izleme verilerini kullanacağız. Burada kapsanan ilkeler, diğer platformlardan gelen temaslı izleme verileri için geçerli olacaktır - verilerinizin yapısına bağlı olarak yalnızca farklı veri ön işleme adımlarından geçmeniz gerekebilir.Go.Data projesi hakkında daha fazla bilgiyi Github Documentation sitesinde veya Community Practice sitesinden okuyabilirsiniz.","code":""},{"path":"temaslı-izlemi.html","id":"hazırlık-16","chapter":"25 Temaslı izlemi","heading":"25.1 Hazırlık","text":"","code":""},{"path":"temaslı-izlemi.html","id":"paketleri-yükleyin-4","chapter":"25 Temaslı izlemi","heading":"Paketleri yükleyin","text":"Bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() vurgusunu yapıyoruz. base R’dan library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakın.","code":"\npacman::p_load(\n  rio,          # veriyi içe aktar  \n  here,         # göreli dosya yolları  \n  janitor,      # veri temizleme ve tablolar\n  lubridate,    # tarihlerle çalışmak\n  epikit,       # age_categories() fonksiyonu\n  apyramid,     # yal piramitleri\n  tidyverse,    # veri işleme ve görselleştirme\n  RColorBrewer, # renk paletleri\n  formattable,  # süslü tablolar\n  kableExtra    # tablo biçimlendirme\n)"},{"path":"temaslı-izlemi.html","id":"verileri-içe-aktarma-3","chapter":"25 Temaslı izlemi","heading":"Verileri içe aktarma","text":"Kişilerin ve “takiplerinin” örnek veri kümelerini içe aktaracağız. Bu veriler Go.Data API’sinden alınmış, yuvalanmamış ve “.rds” dosyaları olarak depolanmıştır.Bu el kitabı için tüm örnek verileri [El kitabını ve verileri indir] sayfasından indirebilirsiniz.Bu sayfaya özel örnek temaslı izleme verilerini indirmek istiyorsanız, aşağıdaki üç indirme bağlantısını kullanın:\nİndire tıklayınız\nvaka inceleme verileri (.rds file)\n\nİndire tıklayınız\niletişim kayıt verileri (.rds file)\n\nİndire tıklayınız\ntemaslı izlem verileri (.rds file)\nİndirilebilir dosyalardaki orijinal formlarında, veriler Go.Data API’si tarafından sağlanan verileri yansıtır (API’ler hakkında bilgi edinin). Örneğin, buradaki amaçlar için, bu sayfada okumayı kolaylaştıracak verileri temizleyeceğiz. Bir Go.Data örneği kullanıyorsanız, verilerinizi nasıl alacağınıza ilişkin talimatların tamamını buradan görüntüleyebilirsiniz.Aşağıda, veri kümeleri rio paketinden import() fonksiyonu kullanılarak içe aktarılır. Verileri içe aktarmanın çeşitli yolları için İçe ve dışa aktar hakkındaki sayfaya bakın. Dosya yolunu belirtmek için burada() kullanıyoruz - bilgisayarınıza özel dosya yolunu sağlamalısınız. Daha sonra gösterim amacıyla basitleştirmek için verilerin yalnızca belirli sütunlarını seçmek için select() kullanırız.","code":""},{"path":"temaslı-izlemi.html","id":"vaka-verileri","chapter":"25 Temaslı izlemi","heading":"Vaka verileri","text":"Bu veriler, vakaların bir tablosu ve bunlarla ilgili bilgilerdir.nrow(cases) vakaları :","code":"\ncases <- import(here(\"data\", \"godata\", \"cases_clean.rds\")) %>% \n  select(case_id, firstName, lastName, gender, age, age_class,\n         occupation, classification, was_contact, hospitalization_typeid)"},{"path":"temaslı-izlemi.html","id":"kişi-verileri","chapter":"25 Temaslı izlemi","heading":"Kişi verileri","text":"Bu veriler, tüm kişilerin ve bunlarla ilgili bilgilerin bir tablosudur. Yine, kendi dosya yolunuzu sağlayın. İçe aktardıktan sonra, aşağıdakileri içeren birkaç ön veri temizleme adımı gerçekleştiririz:Age_class’ı bir faktör olarak ayarlayın ve seviye sırasını tersine çevirin, böylece daha genç yaşlar ilk sırada yer alır.Birini yeniden adlandırırken yalnızca belirli sütunu seçinBazı örnek görselleştirmelerin netliğini artırmak için, yönetici düzeyi 2 eksik olan satırları “Djembe”ye yapay olarak atayınnrow(contacts), contacts verisetinin satırları:","code":"\ncontacts <- import(here(\"data\", \"godata\", \"contacts_clean.rds\")) %>% \n  mutate(age_class = forcats::fct_rev(age_class)) %>% \n  select(contact_id, contact_status, firstName, lastName, gender, age,\n         age_class, occupation, date_of_reporting, date_of_data_entry,\n         date_of_last_exposure = date_of_last_contact,\n         date_of_followup_start, date_of_followup_end, risk_level, was_case, admin_2_name) %>% \n  mutate(admin_2_name = replace_na(admin_2_name, \"Djembe\"))"},{"path":"temaslı-izlemi.html","id":"takip-verileri","chapter":"25 Temaslı izlemi","heading":"Takip verileri","text":"Bu veriler, ilgili kişilerle “takip” etkileşimlerinin kayıtlarıdır. temasın, maruz kaldıktan sonra 14 gün boyunca gün bir karşılaşma yapması gerekiyor.Birkaç temizleme adımını içe aktarıp gerçekleştiriyoruz. Belirli sütunları seçiyoruz ve ayrıca bir karakter sütununu tüm küçük harf değerlerine dönüştürüyoruz.” nrow(followups)“-row”followups” veri kümesinin ilk 50 satırı (satır bir takip etkileşimidir ve sonuç durumu “followup_status” sütunundadır):","code":"\nfollowups <- rio::import(here::here(\"data\", \"godata\", \"followups_clean.rds\")) %>% \n  select(contact_id, followup_status, followup_number,\n         date_of_followup, admin_2_name, admin_1_name) %>% \n  mutate(followup_status = str_to_lower(followup_status))"},{"path":"temaslı-izlemi.html","id":"ilişki-verileri","chapter":"25 Temaslı izlemi","heading":"İlişki verileri","text":"Burada vakalar ve kişiler arasındaki ilişkiyi gösteren verileri içe aktarıyoruz. Gösterilecek belirli bir sütunu seçiyoruz.Aşağıda, vakalar ve ilgili kişiler arasındaki tüm ilişkileri kaydeden “ilişkiler” veri kümesinin ilk 50 satırı verilmiştir.","code":"\nrelationships <- rio::import(here::here(\"data\", \"godata\", \"relationships_clean.rds\")) %>% \n  select(source_visualid, source_gender, source_age, date_of_last_contact,\n         date_of_data_entry, target_visualid, target_gender,\n         target_age, exposure_type)"},{"path":"temaslı-izlemi.html","id":"tanımlayıcı-analizler-2","chapter":"25 Temaslı izlemi","heading":"25.2 Tanımlayıcı analizler","text":"Vakalarınız, temaslılarınız ve ilişkileri hakkında tanımlayıcı analizler yapmak için bu el kitabının diğer sayfalarında kapsanan teknikleri kullanabilirsiniz. Aşağıda bazı örnekler verilmiştir.","code":""},{"path":"temaslı-izlemi.html","id":"demografi","chapter":"25 Temaslı izlemi","heading":"Demografi","text":"[Demografik piramitler][Demografik piramitler ve Likert ölçekleri] ile ilgili sayfada gösterildiği gibi, yaş ve cinsiyet dağılımını görselleştirebilirsiniz (burada apyramid paketini kullanıyoruz).","code":""},{"path":"temaslı-izlemi.html","id":"temaslıların-yaşı-ve-cinsiyeti","chapter":"25 Temaslı izlemi","heading":"Temaslıların yaşı ve cinsiyeti","text":"Aşağıdaki piramit, temaslıların yaş dağılımını cinsiyete göre karşılaştırmaktadır. Yaşı eksik olan kişilerin en üstteki bilinmeyen çubuklarına dahil edildiğini unutmayın. Bu varsayılan davranışı değiştirebilirsiniz, ancak daha sonra bir başlıkta eksik olan numarayı listelemeyi düşünebilirsiniz.Go.Data veri yapısıyla, ‘ilişkiler’ veri kümesi hem vakaların hem de ilgili kişilerin yaşlarını içerir, böylece bu veri kümesini kullanabilir ve bu iki insan grubu arasındaki farkları gösteren bir yaş piramidi oluşturabilirsiniz. “İlişkiler” veri çerçevesi, sayısal yaş sütunlarını kategorilere dönüştürmek için değiştirilecektir (bkz. [Temizleme verileri ve temel işlevler] sayfası). Ayrıca, ggplot2 ile çizimi kolaylaştırmak için veri çerçevesini daha uzun süre döndürürüz (bkz. [Özetleme verileri]).Şimdi bu dönüştürülmüş veri setini daha önce olduğu gibi ‘age_pyramid()’ ile çizebiliriz, ancak ‘gender’ yerine ‘category’ (temaslı veya vaka) koyabiliriz.Mesleki dağılım gibi diğer özellikleri de görebiliriz (örneğin pasta grafiği şeklinde).","code":"\napyramid::age_pyramid(\n  data = contacts,                                   # temaslı verisetini kullanma\n  age_group = \"age_class\",                           # kategorik yaş sütunu\n  split_by = \"gender\") +                             # piramidin yarısının cinsiyeti\n  labs(\n    fill = \"Gender\",                                 # göstergenin başlığı\n    title = \"Age/Sex Pyramid of COVID-19 contacts\")+ # grafiğin başlığı\n  theme_minimal()                                    # basit arkaplan\nrelation_age <- relationships %>% \n  select(source_age, target_age) %>% \n  transmute(                              # transmute, mutate() gibidir ancak bahsedilmeyen tüm diğer sütunları kaldırır\n    source_age_class = epikit::age_categories(source_age, breakers = seq(0, 80, 5)),\n    target_age_class = epikit::age_categories(target_age, breakers = seq(0, 80, 5)),\n    ) %>% \n  pivot_longer(cols = contains(\"class\"), names_to = \"category\", values_to = \"age_class\")  \n\n\nrelation_age## # A tibble: 200 × 2\n##    category         age_class\n##    <chr>            <fct>    \n##  1 source_age_class 80+      \n##  2 target_age_class 15-19    \n##  3 source_age_class <NA>     \n##  4 target_age_class 50-54    \n##  5 source_age_class <NA>     \n##  6 target_age_class 20-24    \n##  7 source_age_class 30-34    \n##  8 target_age_class 45-49    \n##  9 source_age_class 40-44    \n## 10 target_age_class 30-34    \n## # … with 190 more rows\napyramid::age_pyramid(\n  data = relation_age,                               # değiştirilmiş ilişki veri kümesini kullan\n  age_group = \"age_class\",                           # kategorik yaş sütunu\n  split_by = \"category\") +                           # vakalar ve temaslılar tarafından\n  scale_fill_manual(\n    values = c(\"orange\", \"purple\"),                  # renkleri VE etiketleri belirtmek için\n    labels = c(\"Case\", \"Contact\"))+\n  labs(\n    fill = \"Legend\",                                           # göstergenin başlığı\n    title = \"Age/Sex Pyramid of COVID-19 contacts and cases\")+ # grafiğin başlığı\n  theme_minimal()                                              # basit arkaplan\n# Veri kümesini temizleyin ve mesleğe göre sayıları alın\nocc_plot_data <- cases %>% \n  mutate(occupation = forcats::fct_explicit_na(occupation),  # NA eksik değerleri bir kategori yapın\n         occupation = forcats::fct_infreq(occupation)) %>%   # sıklık sırasına göre sıra faktörü seviyeleri\n  count(occupation)                                          # mesleğe göre sayıları alın\n  \n# pasta grafiği yapın\nggplot(data = occ_plot_data, mapping = aes(x = \"\", y = n, fill = occupation))+\n  geom_bar(width = 1, stat = \"identity\") +\n  coord_polar(\"y\", start = 0) +\n  labs(\n    fill = \"Occupation\",\n    title = \"Known occupations of COVID-19 cases\")+\n  theme_minimal() +                    \n  theme(axis.line = element_blank(),\n        axis.title = element_blank(),\n        axis.text = element_blank())"},{"path":"temaslı-izlemi.html","id":"vaka-başına-kişi-sayısı","chapter":"25 Temaslı izlemi","heading":"Vaka başına kişi sayısı","text":"Vaka başına temaslı sayısı, temaslı numaralandırmanın kalitesini ve nüfusun halk sağlığı müdahalesine uygunluğunu değerlendirmek için önemli bir ölçü olabilir.Veri yapınıza bağlı olarak bu, tüm vakaları ve ilgili kişileri içeren bir veri seti ile değerlendirilebilir. Go.Data veri kümelerinde, vakalar (“kaynaklar”) ve kişiler (“hedefler”) arasındaki bağlantılar “ilişkiler” veri kümesinde depolanır.Bu veri kümesinde satır bir ilgili kişidir ve kaynak vaka satırda listelenir. Birden fazla vakayla ilişkisi olan hiç kimse yok, ancak bu varsa, planlamadan önce olanları hesaba katmanız gerekebilir (ve onları da keşfedin!).Kaynak vaka başına satır (kişi) sayısını sayarak başlarız. Bu bir veri çerçevesi olarak kaydedilir.Bu verileri bir histogram olarak çizmek için geom_histogram() kullanıyoruz.","code":"\ncontacts_per_case <- relationships %>% \n  count(source_visualid)\n\ncontacts_per_case## # A tibble: 23 × 2\n##    source_visualid     n\n##    <chr>           <int>\n##  1 CASE-2020-0001     13\n##  2 CASE-2020-0002      5\n##  3 CASE-2020-0003      2\n##  4 CASE-2020-0004      4\n##  5 CASE-2020-0005      5\n##  6 CASE-2020-0006      3\n##  7 CASE-2020-0008      3\n##  8 CASE-2020-0009      3\n##  9 CASE-2020-0010      3\n## 10 CASE-2020-0012      3\n## # … with 13 more rows\nggplot(data = contacts_per_case)+        # yukarıda oluşturulan sayım veri çerçevesiyle başlayın\n  geom_histogram(mapping = aes(x = n))+  # vaka başına kişi sayısının histogramını yazdırın\n  scale_y_continuous(expand = c(0,0))+   # y ekseninde 0'ın altındaki fazla boşluğu kaldırın\n  theme_light()+                         # arka planı basitleştirin\n  labs(\n    title = \"Number of contacts per case\",\n    y = \"Cases\",\n    x = \"Contacts per case\"\n  )"},{"path":"temaslı-izlemi.html","id":"temaslı-takibi","chapter":"25 Temaslı izlemi","heading":"25.3 Temaslı Takibi","text":"Temaslı izleme verileri genellikle karantinadaki kişilerin günlük semptom kontrollerinin sonuçlarını kaydeden “takip” verilerini içerir. Bu verilerin analizi, yanıt stratejisini bilgilendirebilir, takip kaybı riski altındaki veya hastalık geliştirme riski altındaki temaslıları belirleyebilir.","code":""},{"path":"temaslı-izlemi.html","id":"veri-temizleme","chapter":"25 Temaslı izlemi","heading":"Veri temizleme","text":"Bu veriler çeşitli biçimlerde bulunabilir. Kişi başına bir satır ve takip eden “gün” başına bir sütun içeren “geniş” formatlı bir Excel sayfası olarak bulunabilirler. “Uzun” ve “geniş” verilerin açıklamaları ve verilerin nasıl daha geniş veya daha uzun döndürüleceği için [Pivoting data] bölümüne bakabilirsiniz.Go.Data örneğimizde, bu veriler, takip etkileşimi başına bir satır ile “uzun” bir formatta olan “takipler” veri çerçevesinde depolanır. İlk 50 satır şöyle görünür:UYARI: Takip verileriyle uğraşırken mükerrerlere dikkat edin; çünkü belirli bir temaslı için aynı gün içinde birkaç hatalı takip olabilir. Belki bir hata gibi görünüyor ama gerçeği yansıtıyor olabilir - ör. bir iletişim izleyicisi, ilgili kişiye ulaşamadıkları günün erken saatlerinde bir takip formu gönderebilir ve kendilerine daha sonra ulaşıldığında ikinci bir form gönderebilir. Yinelenenleri nasıl ele almak istediğinize ilişkin operasyonel bağlama göre değişecektir. - yalnızca yaklaşımınızı net bir şekilde belgelediğinizden emin olun. Kaç tane “mükerrer” satır örneğimiz olduğunu görelim:Örnek verilerimizde, bunun geçerli olduğu tek kayıt, kimliği eksik olanlardır! Bunları kaldırabiliriz. Ancak, öğretmek amacıyla, tekilleştirme adımlarını göstereceğiz. Böylece kişi başına günde yalnızca bir izlemi yapılan ile muhatap olunur. Daha fazla ayrıntı için Tekilleştirme ile ilgili sayfaya bakabilirsiniz. En son karşılaşma kaydının doğru olduğunu varsayacağız. Ayrıca ‘followup_number’ sütununu (1 - 14 aralığında olması gereken takip “günü”) temizleme fırsatını da kullanıyoruz.takip eden karşılaşma için, bir takip durumumuz var (örneğin, karşılaşmanın olup olmadığı ve olduysa, temasta belirti olup olmadığı gibi). Tüm değerleri görmek için ‘followup_status’ ile hızlı bir ‘tabyl()’ (janitor’dan) veya ‘table()’ (R tabanından) (bkz. Tanımlayıcı tablolar) sonuçların birinin sıklığını görebilmek için çalıştırabiliriz.Bu veri setinde “seen_not_ok”, “semptomlarla görülen” ve “seen_ok”, “semptomsuz görülen” anlamına gelir.","code":"\nfollowups %>% \n  count(contact_id, date_of_followup) %>%   # benzersiz contact_days alın\n  filter(n > 1)                             # sayının 1'den fazla olduğu kayıtları görüntüleyin  ## # A tibble: 3 × 3\n##   contact_id date_of_followup     n\n##   <chr>      <date>           <int>\n## 1 <NA>       2020-09-03           2\n## 2 <NA>       2020-09-04           2\n## 3 <NA>       2020-09-05           2\nfollowups_clean <- followups %>%\n  \n  # yinelenenleri kaldırın\n  group_by(contact_id, date_of_followup) %>%        # temaslı günü başına grup satırları\n  arrange(contact_id, desc(date_of_followup)) %>%   # takip tarihine göre her temas günü için satırlar düzenleyin (en son en üstte)\n  slice_head() %>%                                  # benzersiz kişi kimliği başına yalnızca ilk satırı tutun  \n  ungroup() %>% \n  \n  # diğer temizlemeler\n  mutate(followup_number = replace(followup_number, followup_number > 14, NA)) %>% # hatalı verileri temizle\n  drop_na(contact_id)                               # eksik contact_id olan satırları kaldırın\nfollowups_clean %>% \n  tabyl(followup_status)##  followup_status   n    percent\n##           missed  10 0.02325581\n##    not_attempted   5 0.01162791\n##    not_performed 319 0.74186047\n##      seen_not_ok   6 0.01395349\n##          seen_ok  90 0.20930233"},{"path":"temaslı-izlemi.html","id":"zaman-içinde-grafik","chapter":"25 Temaslı izlemi","heading":"Zaman içinde grafik","text":"Tarih verileri sürekli olduğundan, x eksenine atanan ‘date_of_followup’ ile bunları çizmek için bir histogram kullanacağız. ‘followup_status’ sütununa atadığımız ‘aes()’ içinde bir ‘fill = ’değişkenleri belirleyerek “yığınlanmış” bir histogram elde edebiliriz. Sonuç olarak, ’labs()’ öğesinin ‘fill =’ değişkenini kullanarak gösterge başlığını ayarlayabilirsiniz.Temaslıların dalgalar halinde tanımlandığını (muhtemelen salgın vaka dalgalarına karşılık gelen) ve takip tamamlamanın salgın boyunca görünüşte iyileşmediğini görebiliriz.UYARI: Çok sayıda çizim hazırlıyorsanız (örneğin, birden fazla konu için), göstergelerin değişen seviyelerde veri tamamlama veya veri birleştirme ile bile aynı görünmesini isteyeceksiniz. Verilerde tüm takip durumlarının bulunmadığı grafikler olabilir, ancak yine de bu kategorilerin göstergelerde standart olarak görünmesini istiyorsunuz. Ggplot’larda (yukarıdaki gibi), ‘scale_fill_discrete()’ için ‘drop = FALSE’ değişkenini belirtebilirsiniz. Tablolarda, tüm faktör düzeyleri için sayıları gösteren ‘tabyl()’ kullanın veya dplyr’den ‘count()’ kullanıyorsanız, tüm faktör düzeyleri için sayıları dahil etmek için ‘.drop = FALSE’ bağımsız değişkenini ekleyin.","code":"\nggplot(data = followups_clean)+\n  geom_histogram(mapping = aes(x = date_of_followup, fill = followup_status)) +\n  scale_fill_discrete(drop = FALSE)+   # göstergedeki tüm faktör seviyelerini (followup_status), kullanılmayanları bile gösterin\n  theme_classic() +\n  labs(\n    x = \"\",\n    y = \"Number of contacts\",\n    title = \"Daily Contact Followup Status\",\n    fill = \"Followup Status\",\n    subtitle = str_glue(\"Data as of {max(followups$date_of_followup, na.rm=T)}\"))   # dinamik altyazı"},{"path":"temaslı-izlemi.html","id":"günlük-bireysel-izleme","chapter":"25 Temaslı izlemi","heading":"Günlük bireysel izleme","text":"Salgınınız yeterince küçükse, bir kişiye ayrı ayrı bakmak ve takipleri boyunca durumlarını görmek isteyebilirsiniz. Neyse ki, bu “izlemeler” veri kümesi halihazırda takip “sayısı” (1-14) sütununu içeriyor. Verilerinizde bu yoksa, karşılaşma tarihi ile ilgili kişi için takibin başlaması amaçlanan tarih arasındaki farkı hesaplayarak oluşturabilirsiniz.Uygun bir görselleştirme mekanizması (eğer vaka sayısı çok büyük değilse), geom_tile() ile yapılmış bir ısı grafiği olabilir. [Isı grafiği] sayfasında daha fazla ayrıntıya bakın.","code":"\nggplot(data = followups_clean)+\n  geom_tile(mapping = aes(x = followup_number, y = contact_id, fill = followup_status),\n            color = \"grey\")+       # gri kılavuz çizgileri\n  scale_fill_manual( values = c(\"yellow\", \"grey\", \"orange\", \"darkred\", \"darkgreen\"))+\n  theme_minimal()+\n  scale_x_continuous(breaks = seq(from = 1, to = 14, by = 1))"},{"path":"temaslı-izlemi.html","id":"grubuna-göre-analiz-et","chapter":"25 Temaslı izlemi","heading":"Grubuna göre analiz et","text":"Belki de bu takip verileri, operasyonel karar verme için günlük veya haftalık olarak görüntülenmektedir. Coğrafi alana veya kişi izleme ekibine göre daha anlamlı ayrıştırmalar isteyebilirsiniz. Bunu group_by() için sağlanan sütunları ayarlayarak yapabiliriz.","code":"\nplot_by_region <- followups_clean %>%                                        # takip veri seti ile başlayın\n  count(admin_1_name, admin_2_name, followup_status) %>%   # benzersiz bölge durumuna göre sayıları al (sayılarla 'n' sütununu oluşturur)\n  \n  \n  ggplot(                                         # ggplot() başlatın\n    mapping = aes(x = reorder(admin_2_name, n),     # 'n' sütunundaki sayısal değerlere göre yönetici faktör düzeylerini yeniden sıralayın\n                  y = n,                            # 'n' sütunundan çubuğun yükseklikleri\n                  fill = followup_status,           # durumlarına göre renk yığılmış çubuklar\n                  label = n))+                      # geom_label()'e geçmek için              \n  geom_col()+                                     # yığılmış çubuklar, yukarıdan devredilen haritalama\n  geom_text(                                      # metin ekleme, yukarıdan devredilen haritalama\n    size = 3,                                         \n    position = position_stack(vjust = 0.5), \n    color = \"white\",           \n    check_overlap = TRUE,\n    fontface = \"bold\")+\n  coord_flip()+\n  labs(\n    x = \"\",\n    y = \"Number of contacts\",\n    title = \"Contact Followup Status, by Region\",\n    fill = \"Followup Status\",\n    subtitle = str_glue(\"Data as of {max(followups_clean$date_of_followup, na.rm=T)}\")) +\n  theme_classic()+                                                                      # Arka planı basitleştirin\n  facet_wrap(~admin_1_name, strip.position = \"right\", scales = \"free_y\", ncol = 1)      # yönleri tanıtın\n\nplot_by_region"},{"path":"temaslı-izlemi.html","id":"kpi-tabloları","chapter":"25 Temaslı izlemi","heading":"25.4 KPI Tabloları","text":"Kişi takibi performansını izlemek için farklı ayrıştırma seviyelerinde ve farklı zaman dilimlerinde hesaplanabilen ve izlenebilen bir dizi farklı Temel Performans Göstergesi (KPI) vardır. Hesaplamaları yapıp ve temel tablo formatına sahip olduğunuzda; farklı KPI’ları değiştirmek oldukça kolaydır.ResolveToSaveLives.org kaynağındaki bu gibi çok sayıda kişi izleme KPI’sı kaynağı vardır. Çalışmanın çoğu, veri yapınızı gözden geçirecek ve tüm dahil etme/hariç tutma kriterlerini düşünecektir. Aşağıda birkaç örnek gösteriyoruz; Go.Data meta veri yapısını kullanarak:Aşağıda, yönetici alanlarındaki iletişim takibini göstermek için güzel bir tablo görseli oluşturmaya yönelik örnek bir alıştırmayı inceleyeceğiz. Sonunda, formattable paketi ile sunuma uygun hale getireceğiz (ancak flextable gibi başka paketleri de kullanabilirsiniz - bkz. Sunum için tablolar).Bunun gibi bir tabloyu nasıl oluşturacağınız, temaslı izleme verilerinizin yapısına bağlı olacaktır. dplyr fonksiyonlarını kullanarak verileri nasıl özetleyeceğinizi öğrenmek için [Açıklayıcı tablolar] sayfasını kullanın.Dinamik olacak ve veriler değiştikçe değişecek bir tablo oluşturacağız. Sonuçları ilginç hale getirmek için, tabloyu belirli bir günde çalıştırmayı simüle etmemize izin verecek bir “rapor_tarihi” ayarlayacağız (10 Haziran 2020’yi seçiyoruz). Veriler o tarihe kadar filtrelenir.Şimdi, veri yapımıza dayanarak aşağıdakileri yapacağız:“Takip” verileriyle başlayın ve benzersiz kişi için içerecek şekilde özetleyin:\nEn son kayıt tarihi (karşılaşmanın durumu ne olursa olsun)\nTemaslının “görüldüğü” en son karşılaşma tarihi\nNihai “görülen” karşılaşmadaki karşılaşma durumu (örneğin semptomlu, semptomlar olmadan)\nEn son kayıt tarihi (karşılaşmanın durumu ne olursa olsun)Temaslının “görüldüğü” en son karşılaşma tarihiNihai “görülen” karşılaşmadaki karşılaşma durumu (örneğin semptomlu, semptomlar olmadan)Bu verileri genel iletişim durumu, bir temaslıya son maruz kalma tarihi vb. gibi diğer bilgileri içeren temaslı verileriyle birleştirin. Ayrıca, son temastan bu yana geçen gün sayısı gibi bir ilgili temaslı için ilgilenilen metrikleri hesaplayacağız.Gelişmiş iletişim verilerini coğrafi bölgeye (admin_2_name) göre gruplandırıyoruz ve bölge başına özet istatistikleri hesaplıyoruzSon olarak, sunum için tabloyu güzelce biçimlendiriyoruz.İlk olarak, ilgilenilen bilgileri almak için takip verilerini özetliyoruz:İşte veriler böyle görünüyor:Şimdi bu bilgiyi “kişiler” veri kümesine ekleyeceğiz ve bazı ek sütunları hesaplayacağız.İşte veriler böyle görünüyor. Sağdaki “kişiler” sütununu ve en sağdaki yeni hesaplanmış sütunu edin.Ardından, özet istatistik sütunlarından oluşan kısa bir veri çerçevesi elde etmek için kişi verilerini bölgeye göre özetleyeceğiz.Ve şimdi, “başlangıç” tarihini gösteren bir dipnot da dahil olmak üzere biçimlendirilebilir ve knitr paketlerinden stil uyguluyoruz.","code":"\n# Raporun bu tarihten itibaren verilerle çalıştırılmasını simüle etmek için \"Rapor tarihi\"ni ayarlayın\nreport_date <- as.Date(\"2020-06-10\")\n\n# Rapor tarihini yansıtacak takip verileri oluşturun.\ntable_data <- followups_clean %>% \n  filter(date_of_followup <= report_date)\nfollowup_info <- table_data %>% \n  group_by(contact_id) %>% \n  summarise(\n    date_last_record   = max(date_of_followup, na.rm=T),\n    date_last_seen     = max(date_of_followup[followup_status %in% c(\"seen_ok\", \"seen_not_ok\")], na.rm=T),\n    status_last_record = followup_status[which(date_of_followup == date_last_record)]) %>% \n  ungroup()\ncontacts_info <- followup_info %>% \n  right_join(contacts, by = \"contact_id\") %>% \n  mutate(\n    database_date       = max(date_last_record, na.rm=T),\n    days_since_seen     = database_date - date_last_seen,\n    days_since_exposure = database_date - date_of_last_exposure\n    )\ncontacts_table <- contacts_info %>% \n  \n  group_by(`Admin 2` = admin_2_name) %>%\n  \n  summarise(\n    `Registered contacts` = n(),\n    `Active contacts`     = sum(contact_status == \"UNDER_FOLLOW_UP\", na.rm=T),\n    `In first week`       = sum(days_since_exposure < 8, na.rm=T),\n    `In second week`      = sum(days_since_exposure >= 8 & days_since_exposure < 15, na.rm=T),\n    `Became case`         = sum(contact_status == \"BECAME_CASE\", na.rm=T),\n    `Lost to follow up`   = sum(days_since_seen >= 3, na.rm=T),\n    `Never seen`          = sum(is.na(date_last_seen)),\n    `Followed up - signs` = sum(status_last_record == \"Seen_not_ok\" & date_last_record == database_date, na.rm=T),\n    `Followed up - no signs` = sum(status_last_record == \"Seen_ok\" & date_last_record == database_date, na.rm=T),\n    `Not Followed up`     = sum(\n      (status_last_record == \"NOT_ATTEMPTED\" | status_last_record == \"NOT_PERFORMED\") &\n        date_last_record == database_date, na.rm=T)) %>% \n    \n  arrange(desc(`Registered contacts`))\ncontacts_table %>%\n  mutate(\n    `Admin 2` = formatter(\"span\", style = ~ formattable::style(\n      color = ifelse(`Admin 2` == NA, \"red\", \"grey\"),\n      font.weight = \"bold\",font.style = \"italic\"))(`Admin 2`),\n    `Followed up - signs`= color_tile(\"white\", \"orange\")(`Followed up - signs`),\n    `Followed up - no signs`= color_tile(\"white\", \"#A0E2BD\")(`Followed up - no signs`),\n    `Became case`= color_tile(\"white\", \"grey\")(`Became case`),\n    `Lost to follow up`= color_tile(\"white\", \"grey\")(`Lost to follow up`), \n    `Never seen`= color_tile(\"white\", \"red\")(`Never seen`),\n    `Active contacts` = color_tile(\"white\", \"#81A4CE\")(`Active contacts`)\n  ) %>%\n  kable(\"html\", escape = F, align =c(\"l\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\")) %>%\n  kable_styling(\"hover\", full_width = FALSE) %>%\n  add_header_above(c(\" \" = 3, \n                     \"Of contacts currently under follow up\" = 5,\n                     \"Status of last visit\" = 3)) %>% \n  kableExtra::footnote(general = str_glue(\"Data are current to {format(report_date, '%b %d %Y')}\"))"},{"path":"temaslı-izlemi.html","id":"bulaş-matrisleri","chapter":"25 Temaslı izlemi","heading":"25.5 Bulaş Matrisleri","text":"Isı grafikleri sayfasında tartışıldığı gibi, “geom_tile()” kullanarak “kimin kime bulaştırdığını” gösteren bir matris oluşturabilirsiniz.Yeni kişiler oluşturulduğunda, Go.Data bu ilişki bilgilerini “ilişkiler” API uç noktasında saklar ve bu veri setinin ilk 50 satırını aşağıda görebiliriz. Bu, bir temasın kendi kaynak durumuna zaten katılmış olduğu göz önüne alındığında, nispeten az adımla bir ısı grafiği oluşturabileceğimiz anlamına gelir.Yukarıda vakaları ve ilgili kişileri karşılaştıran yaş piramidi için yapıldığı gibi, ihtiyacımız olan birkaç değişkeni seçebilir ve hem kaynaklar (vakalar) hem de hedefler (temaslılar) için kategorik yaş gruplamaları içeren sütunlar oluşturabiliriz.Daha önce açıklandığı gibi, çapraz tablo oluşturuyoruz;orantılarla uzun biçime dönüştürün;ve yaşa göre bir ısı haritası oluşturun.","code":"\nheatmap_ages <- relationships %>% \n  select(source_age, target_age) %>% \n  mutate(                              # transmute fonksiyonu, mutate() gibidir ancak diğer tüm sütunları kaldırır\n    source_age_class = epikit::age_categories(source_age, breakers = seq(0, 80, 5)),\n    target_age_class = epikit::age_categories(target_age, breakers = seq(0, 80, 5))) \ncross_tab <- table(\n  source_cases = heatmap_ages$source_age_class,\n  target_cases = heatmap_ages$target_age_class)\n\ncross_tab##             target_cases\n## source_cases 0-4 5-9 10-14 15-19 20-24 25-29 30-34 35-39 40-44 45-49 50-54 55-59 60-64 65-69 70-74 75-79 80+\n##        0-4     0   0     0     0     0     0     0     0     0     1     0     1     0     0     0     0   0\n##        5-9     0   0     1     0     0     0     0     1     0     0     0     1     0     0     0     0   0\n##        10-14   0   0     0     0     0     0     0     0     0     0     0     0     0     0     0     0   0\n##        15-19   0   0     0     0     0     0     0     0     0     0     0     0     0     0     0     0   0\n##        20-24   1   1     0     1     2     0     2     1     0     0     0     1     0     0     0     0   1\n##        25-29   1   2     0     0     0     0     0     0     0     0     0     0     0     0     0     0   0\n##        30-34   0   0     0     0     0     0     0     0     1     1     0     1     0     0     0     0   0\n##        35-39   0   2     0     0     0     0     0     0     0     1     0     0     0     0     0     0   0\n##        40-44   0   0     0     0     1     0     2     1     0     3     1     1     0     0     0     1   1\n##        45-49   1   2     2     0     0     0     3     0     1     0     3     2     1     0     0     0   1\n##        50-54   1   2     1     2     0     0     1     0     0     3     4     1     0     1     0     0   1\n##        55-59   0   1     0     0     1     1     2     0     0     0     0     0     0     0     0     0   0\n##        60-64   0   0     0     0     0     0     0     0     0     0     0     0     0     0     0     0   0\n##        65-69   0   0     0     0     0     0     0     0     0     0     0     0     0     0     0     0   0\n##        70-74   0   0     0     0     0     0     0     0     0     0     0     0     0     0     0     0   0\n##        75-79   0   0     0     0     0     0     0     0     0     0     0     0     0     0     0     0   0\n##        80+     1   0     0     2     1     0     0     0     1     0     0     0     0     0     0     0   0\nlong_prop <- data.frame(prop.table(cross_tab))\nggplot(data = long_prop)+       # oranlarda sıklık olarak uzun veriler kullanın\n  geom_tile(                    # görselleştirin\n    aes(\n      x = target_cases,         # vaka yaşı x ekseninde\n      y = source_cases,         # kaynak yaşı y ekseninde\n      fill = Freq))+            # arkaplan rengi verilerdeki Sıklık sütunudur\n  scale_fill_gradient(          # dolgu rengini ayarlayın\n    low = \"blue\",\n    high = \"orange\")+\n  theme(axis.text.x = element_text(angle = 90))+\n  labs(                         # etiketler\n    x = \"Target case age\",\n    y = \"Source case age\",\n    title = \"Who infected whom\",\n    subtitle = \"Frequency matrix of transmission events\",\n    fill = \"Proportion of all\\ntranmsission events\"     # göstergenin başlığı\n  )"},{"path":"temaslı-izlemi.html","id":"kaynaklar-18","chapter":"25 Temaslı izlemi","heading":"25.6 Kaynaklar","text":"https://github.com/WorldHealthOrganization/godata/tree/master/analytics/r-reportinghttps://worldhealthorganization.github.io/godata/https://community-godata..int/","code":""},{"path":"anket-analizi.html","id":"anket-analizi","chapter":"26 Anket analizi","heading":"26 Anket analizi","text":"","code":""},{"path":"anket-analizi.html","id":"genel-bakış-4","chapter":"26 Anket analizi","heading":"26.1 Genel bakış","text":"Bu sayfa, anket analizi için çeşitli paketlerin kullanımını göstermektedir.Çoğu anket R paketleri, ağırlıklı analiz yapmak için survey paketine güvenir. survey paketinin yanı sıra srvyr (tidyverse-stili kodlamaya izin veren bir survey sarmalayıcısı) ve gtsummary (yayına hazır tablolara izin veren bir survey sarmalayıcısı) kullanacağız. Orijinal survey paketi tidyverse-stili kodlamaya izin vermese de, anket ağırlıklı genelleştirilmiş doğrusal modellere izin verme avantajına sahiptir (bu sayfaya daha sonraki bir tarihte eklenecektir). Örnekleme ağırlıkları oluşturmak için sitrep paketinden bir fonksiyonu kullanmayı da göstereceğiz (n.b , bu paket şu anda CRAN’da değil, ancak github’dan kurulabilir).Bu sayfanın çoğu “R4Epis” projesi için yapılan çalışmalara dayanmaktadır; ayrıntılı kod ve R-markdown şablonları için “R4Epis” github sayasına bakabilirsiniz. survey paketine ait kodlardan bazıları, EPIET vaka çalışmalarının ilk sürümlerini temel almaktadır.Şu anda bu sayfa, örneklem büyüklüğü hesaplamalarını veya örneklemeyi ele almamaktadır. Örnek boyutu hesaplayıcıyı kullanmak için basit bir kullanım için OpenEpi’ye bakabilirsiniz. El kitabının GIS temelleri sayfasında eninde sonunda uzamsal rastgele örnekleme üzerine bir bölüm mevcuttur ve bu sayfa sonunda örnekleme çerçeveleri ve örnek boyutu hesaplamaları hakkında bir bölüme sahip olacaktır.Anket verisiGözlem süresiAğırlıklandırmaAnket tasarım nesneleriTanımlayıcı analizAğırlıklı orantılarAğırlıklı hızlar","code":""},{"path":"anket-analizi.html","id":"hazırlık-17","chapter":"26 Anket analizi","heading":"26.2 Hazırlık","text":"","code":""},{"path":"anket-analizi.html","id":"paketler-2","chapter":"26 Anket analizi","heading":"Paketler","text":"Bu kod parçası, analizler için gereken paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman paketinden p_load() fonksiyonunu kullanacağız. Ayrıca R tabanı’dan library() ile paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] sayfasına bakabilirsiniz.Burada ayrıca, github’dan henüz CRAN’da yayınlanmayan bir paketi yüklemek için pacman paketinden p_load_gh() fonksiyonunu kullanmayı gösteriyoruz.","code":"\n## paketleri CRAN'dan yükle\npacman::p_load(rio,          # Dosya içe aktarma\n               here,         # Dosya bulucu\n               tidyverse,    # veri yönetimi + ggplot2 grafikleri\n               tsibble,      # zaman serisi veri kümelerini işleme\n               survey,       # anket işlevleri için\n               srvyr,        # anket paketi için dplyr sarmalayıcı\n               gtsummary,    # tablolar üretmek için anket paketi için sarıcı\n               apyramid,     # yaş piramitleri oluşturmaya adanmış bir paket\n               patchwork,    # ggplot'ları birleştirmek için\n               ggforce       # alüvyon/sankey grafikleri için\n               ) \n\n## paketleri github'dan yükle\npacman::p_load_gh(\n     \"R4EPI/sitrep\"          # gözlem süresi / ağırlıklandırma fonksiyonları için\n)"},{"path":"anket-analizi.html","id":"veri-yükleme-1","chapter":"26 Anket analizi","heading":"Veri yükleme","text":"Bu bölümde kullanılan örnek veri kümeleri aşağıda listelenmiştir:kurgusal ölüm anketi verileri.araştırma alanı için kurgusal nüfus sayımları.kurgusal ölüm anketi verileri için veri sözlüğü.Bu, MSF OCA etik inceleme kurulu tarafından önceden onaylanmış ankete dayanmaktadır. Kurgusal veri seti “R4Epis” projesi kapsamında üretilmiştir. Bunların tümü, Open Data Kit’e dayalı bir veri toplama yazılımı olan KoboToolbox kullanılarak toplanan verilere dayanmaktadır.Kobo, hem toplanan verileri hem de bu veri kümesi için veri sözlüğünü dışa aktarmanıza olanak tanır. Veri temizlemeyi basitleştirdiği ve değişkenleri/soruları aramak için kullanışlı olduğu için bunu yapmanızı şiddetle tavsiye etmekteyiz.İPUCU: Kobo veri sözlüğünün anket sayfasının “name” sütununda değişken adları vardır. değişken için olası değerler, seçenekler sayfasında belirtilmiştir. Seçenekler sekmesinde “name” kısaltılmış değere sahiptir ve “label::english” ve “label::french” sütunları gerekli uzun versiyonlara da sahiptir. Bir Kobo sözlük excel dosyasını içe aktarmak için epidict paketi msf_dict_survey() fonksiyonunu kullanarak bu adları otomatik olarak yeniden biçimlendirebilirsiniz. Bu sayede kodlarınızı tekrardan kullanma şansınız olur.DİKKAT: Bu örnek veri kümesi dışa aktarılan formatı ile aynı değildir (Kobo’da farklı anket düzeylerini ayrı ayrı dışa aktardığınız gibi) - farklı düzeyleri birleştirmek için aşağıdaki anket verileri bölümüne bakmalısınız.Veri kümesi, rio paketinden import() fonksiyonu kullanılarak içe aktarılır. Verileri içe aktarmanın çeşitli yolları için İçe ve dışa aktarma sayfasına bakın.Anketin ilk 10 satırı aşağıda gösterilmiştir.Uygun ağırlıklar üretebilmemiz için örneklem popülasyonundaki verileri de içe aktarmak istiyoruz. Bu veriler farklı formatlarda olabilir, ancak aşağıda görüldüğü gibi olmasını öneririz (bu sadece bir excel’e yazılabilir).Anketin ilk 10 satırı aşağıda gösterilmiştir.Küme anketleri için küme düzeyinde anket ağırlıkları eklemek isteyebilirsiniz. Bu verileri yukarıdaki gibi okuyabilirsiniz. Alternatif olarak, yalnızca birkaç sayı varsa, bunlar bir tibble’aşağıdaki gibi girilebilir. durumda, anket verilerinizle eşleşen bir küme tanımlayıcısına sahip bir sütuna ve bir kümedeki hane sayısını içeren başka bir sütuna ihtiyacınız olacaktır.","code":"\n# anket verilerini içe aktar\nsurvey_data <- rio::import(\"survey_data.xlsx\")\n\n# sözlüğü R’ın içine aktar\nsurvey_dict <- rio::import(\"survey_dict.xlsx\") \n# nüfus verilerini içe aktar\npopulation <- rio::import(\"population.xlsx\")\n## her kümedeki hane sayısını tanımla\ncluster_counts <- tibble(cluster = c(\"village_1\", \"village_2\", \"village_3\", \"village_4\", \n                                     \"village_5\", \"village_6\", \"village_7\", \"village_8\",\n                                     \"village_9\", \"village_10\"), \n                         households = c(700, 400, 600, 500, 300, \n                                        800, 700, 400, 500, 500))"},{"path":"anket-analizi.html","id":"veri-temizleme-1","chapter":"26 Anket analizi","heading":"Veri temizleme","text":"Aşağıdaki kodlar, tarih sütununun uygun biçimde olmasını sağlar. Bunu yapmanın başka yolları da vardır (ayrıntılar için Tarihlerle çalışma sayfasına bakın), ancak tarihleri tanımlamak için sözlüğü kullanmak hızlı ve kolaydır.Ayrıca **epikit* paketindeki age_categories() fonksiyonunu kullanarak bir yaş grubu değişkeni oluşturuyoruz - ayrıntılar için el kitabındaki Verileri temizleme bölümüne bakabilirsiniz. Ek olarak, çeşitli kümelerin hangi bölgede olduğunu tanımlayan bir karakter değişkeni oluşturuyoruz.Son olarak, tüm evet/hayır değişkenlerini DOĞRU/YANLIŞ değişkenlere yeniden kodlarız - aksi takdirde bunlar survey orantı fonksiyonları tarafından kullanılamaz.","code":"\n## sözlükten tarih değişkeni adlarını seç \nDATEVARS <- survey_dict %>% \n  filter(type == \"date\") %>% \n  filter(name %in% names(survey_data)) %>% \n  ## filter to match the column names of your data\n  pull(name) # select date vars\n  \n## tarihleri değiştir\nsurvey_data <- survey_data %>%\n  mutate(across(all_of(DATEVARS), as.Date))\n\n\n## yıl değişkenine yalnızca ay cinsinden yaşı olanları ekle (on ikiye böl)\nsurvey_data <- survey_data %>% \n  mutate(age_years = if_else(is.na(age_years), \n                             age_months / 12, \n                             age_years))\n\n## yaş grubu değişkenini tanımla\nsurvey_data <- survey_data %>% \n     mutate(age_group = age_categories(age_years, \n                                    breakers = c(0, 3, 15, 30, 45)\n                                    ))\n\n\n## farklı bir değişkenin gruplarına dayalı bir karakter değişkeni oluştur\nsurvey_data <- survey_data %>% \n  mutate(health_district = case_when(\n    cluster_number %in% c(1:5) ~ \"district_a\", \n    TRUE ~ \"district_b\"\n  ))\n\n\n## sözlükten evet/hayır değişken isimlerini seç\nYNVARS <- survey_dict %>% \n  filter(type == \"yn\") %>% \n  filter(name %in% names(survey_data)) %>% \n  ## filter to match the column names of your data\n  pull(name) # select yn vars\n  \n## tarihleri değiştir \nsurvey_data <- survey_data %>%\n  mutate(across(all_of(YNVARS), \n                str_detect, \n                pattern = \"yes\"))"},{"path":"anket-analizi.html","id":"anket-verisi","chapter":"26 Anket analizi","heading":"26.3 Anket verisi","text":"Anketler için kullanılabilecek çok sayıda farklı örnekleme tasarımı vardır. Burada şu kodları göstereceğiz:\n- Tabakalı\n- Küme\n- Tabakalı ve kümeYukarıda açıklandığı gibi (anketinizi nasıl tasarladığınıza bağlı olarak) seviye için veriler Kobo’dan ayrı bir veri seti olarak dışa aktarılacaktır. Örneğimizde, haneler için bir düzey ve bu hanelerdeki bireyler için bir düzey vardır.Bu iki seviye benzersiz bir tanımlayıcı ile birbirine bağlanır. Bir Kobo veri kümesi için bu değişken, bireysel düzeyde “_parent_index” ile eşleşen hane düzeyinde “_index” dir. Bu, eşleşen bireyle hane için yeni satırlar oluşturacaktır, ayrıntılar için Verileri ekleme ilgili el kitabı bölümüne bakabilirsiniz.","code":"\n## eksiksiz bir veri seti oluşturmak için bireysel ve hane verilerini birleştir\nsurvey_data <- left_join(survey_data_hh, \n                         survey_data_indiv,\n                         by = c(\"_index\" = \"_parent_index\"))\n\n\n## iki düzeyin endekslerini birleştirerek benzersiz bir tanımlayıcı oluştur\nsurvey_data <- survey_data %>% \n     mutate(uid = str_glue(\"{index}_{index_y}\"))"},{"path":"anket-analizi.html","id":"gözlem-süresi","chapter":"26 Anket analizi","heading":"26.4 Gözlem süresi","text":"Mortalite araştırmaları için, ilgilendiğimiz döneme ait uygun bir ölüm oranını hesaplayabilmek için bireyin bölgede ne kadar süredir bulunduğunu bilmek istiyoruz. Bu, tüm anketlerde geçerli değildir, ancak özellikle ölüm anketleri için bu önemlidir, çünkü bunlar sık sık hareketli veya göç etmiş nüfuslarda kullanılabilir.Bunu yapmak için önce, geri çağırma dönemi olarak da bilinen ilgilendiğimiz süreyi tanımlarız (yani, katılımcılardan soruları cevaplarken rapor vermelerinin istendiği süre). Daha sonra bu süreyi, uygun olmayan tarihleri kayıp olarak ayarlamak için kullanabiliriz, örneğin ölümler ilgili dönemin dışından bildirilirse.Daha sonra birey için başlangıç ve bitiş tarihlerini tanımlamak için tarih değişkenlerimizi kullanabiliriz. Tarihlerin nedenlerini belirlemek için sitrep paketinden find_start_date() fonksiyonunu kullanabilir ve ardından bunu günler arasındaki farkı (kişi-zaman) hesaplamak için kullanabiliriz.başlangıç tarihi: Geri çağırma döneminiz içindeki en erken uygun varış olayı Geri çağırma sürenizin başlangıcı (önceden tanımladığınız) veya varsa, geri çağırma başlangıcından sonraki bir tarih (örneğin varışlar veya doğumlar)bitiş tarihi: Geri çağırma süreniz içindeki en erken uygun ayrılma olayı Geri çağırma sürenizin sonu ya da varsa, geri çağırma süresinin bitiminden önceki bir tarih (örn. ayrılışlar, ölümler)","code":"\n## geri çağırma süresinin başlangıcını/sonunu ayarla\n## veri setinden tarih değişkenleri olarak değiştirilebilir\n## (örn. başlangıç tarihi & anket tarihi)\nsurvey_data <- survey_data %>% \n  mutate(recall_start = as.Date(\"2018-01-01\"), \n         recall_end   = as.Date(\"2018-05-01\")\n  )\n\n\n# kurallara göre uygunsuz tarihleri NA olarak ayarla\n## örneğin, başlangıçtan önce varışlar, bitişten sonra ayrılışlar\nsurvey_data <- survey_data %>%\n      mutate(\n           arrived_date = if_else(arrived_date < recall_start, \n                                 as.Date(NA),\n                                  arrived_date),\n           birthday_date = if_else(birthday_date < recall_start,\n                                  as.Date(NA),\n                                  birthday_date),\n           left_date = if_else(left_date > recall_end,\n                              as.Date(NA),\n                               left_date),\n           death_date = if_else(death_date > recall_end,\n                               as.Date(NA),\n                               death_date)\n           )\n## başlangıç ve bitiş tarihleri/nedenleri için yeni değişkenler oluştur\nsurvey_data <- survey_data %>% \n     ## ankete girilen en erken tarihi seç\n     ## doğumlardan, hane girişlerinden ve kamp varışlarından\n     find_start_date(\"birthday_date\",\n                  \"arrived_date\",\n                  period_start = \"recall_start\",\n                  period_end   = \"recall_end\",\n                  datecol      = \"startdate\",\n                  datereason   = \"startcause\" \n                 ) %>%\n     ## ankete girilen en erken tarihi seç\n     ## kamptan ayrılma, ölüm ve çalışmanın bitiminden\n     find_end_date(\"left_date\",\n                \"death_date\",\n                period_start = \"recall_start\",\n                period_end   = \"recall_end\",\n                datecol      = \"enddate\",\n                datereason   = \"endcause\" \n               )\n\n\n## başlangıçta/sonda olanları etiketle (doğumlar/ölümler hariç)\nsurvey_data <- survey_data %>% \n     mutate(\n       ##geri çağırma süresinin başlangıcı olarak başlangıç tarihini gir (boş olanlar için)\n       startdate = if_else(is.na(startdate), recall_start, startdate), \n       ## geri çağırma periyoduna eşitse, başlangıç nedenini başlangıçta gösterecek şekilde ayarla\n       ## doğum tarihine eşit değilse\n       startcause = if_else(startdate == recall_start & startcause != \"birthday_date\",\n                              \"Present at start\", startcause), \n       ## geri çağırma süresinin bitimi için bitiş tarihini gir (boş olanlar için)\n       enddate = if_else(is.na(enddate), recall_end, enddate), \n       ## son nedeni, geri çağırma sonuna eşitse, sonunda sunacak şekilde ayarla\n       ## ölüm tarihine eşit olmadıkça\n       endcause = if_else(enddate == recall_end & endcause != \"death_date\", \n                            \"Present at end\", endcause))\n\n\n## Gözlem süresini gün olarak tanımla\nsurvey_data <- survey_data %>% \n  mutate(obstime = as.numeric(enddate - startdate))"},{"path":"anket-analizi.html","id":"ağırlıklandırma","chapter":"26 Anket analizi","heading":"26.5 Ağırlıklandırma","text":"Anket ağırlıkları eklemeden önce hatalı gözlemleri bırakmanız önemlidir. Örneğin, negatif gözlem süresine sahip gözlemleriniz varsa, bunları kontrol etmeniz gerekecektir (bunu sitrep paketinden assert_positive_timespan() fonksiyonuyla yapabilirsiniz. Başka bir şey de boş satırlar bırakmak istiyorsanız (örneğin drop_na(uid) ile) veya kopyaları kaldırabilirsiniz (ayrıntılar için El Kitabının Tekilleştirme bölümüne bakın). İzinsiz olanların da çıkarılması gerekir.Bu örnekte, bırakmak ve ayrı bir veri çerçevesinde saklamak istediğimiz durumları filtreliyoruz - bu şekilde anketten hariç tutulanları tanımlayabiliriz. Ardından, bu bırakılan durumları anket verilerimizden çıkarmak için dplyr paketinden anti_join() fonksiyonunu kullanırız.TEHLİKE: Ağırlık değişkeninizde veya anket tasarımınızla ilgili herhangi bir değişkende (örneğin yaş, cinsiyet, tabaka veya küme değişkenleri) eksik değerler olamaz.Yukarıda bahsedildiği gibi, üç farklı çalışma tasarımı (katmanlı, küme ve tabakalı küme) için ağırlıkların nasıl ekleneceğini gösteriyoruz. Bunlar, kaynak popülasyon ve/veya incelenen kümeler hakkında bilgi gerektirir. Bu örnek için tabakalı küme kodunu kullanacağız, ancak çalışma tasarımınız için en uygun olanı kullanın.","code":"\n## düşürdüğünüz vakaları tanımlayabilmek için sakla (ör.rıza dışı\n## veya yanlış köy/küme)\ndropped <- survey_data %>% \n  filter(!consent | is.na(startdate) | is.na(enddate) | village_name == \"other\")\n\n## kullanılmayan satırları anket veri setinden çıkarmak için bırakılan vakaları kullan \nsurvey_data <- anti_join(survey_data, dropped, by = names(dropped))\n# tabakalı ------------------------------------------------------------------\n# \"surv_weight_strata\" adında bir değişken oluştur\n# her birey için ağırlıklar içerir - yaş grubuna, cinsiyete ve sağlık bölgesine göre\nsurvey_data <- add_weights_strata(x = survey_data,\n                                         p = population,\n                                         surv_weight = \"surv_weight_strata\",\n                                         surv_weight_ID = \"surv_weight_ID_strata\",\n                                         age_group, sex, health_district)\n\n## küme ---------------------------------------------------------------------\n\n# hane başına görüşülen bireylerin kişi sayısını al\n# hane (ebeveyn) indeks değişkeni sayılarına sahip bir değişken ekler\nsurvey_data <- survey_data %>%\n  add_count(index, name = \"interviewed\")\n\n\n## küme ağırlıkları oluştur\nsurvey_data <- add_weights_cluster(x = survey_data,\n                                          cl = cluster_counts,\n                                          eligible = member_number,\n                                          interviewed = interviewed,\n                                          cluster_x = village_name,\n                                          cluster_cl = cluster,\n                                          household_x = index,\n                                          household_cl = households,\n                                          surv_weight = \"surv_weight_cluster\",\n                                          surv_weight_ID = \"surv_weight_ID_cluster\",\n                                          ignore_cluster = FALSE,\n                                          ignore_household = FALSE)\n\n\n# tabakalı ve küme ---------------------------------------------------------\n# küme ve tabalalar için bir anket ağırlığı oluştur\nsurvey_data <- survey_data %>%\n  mutate(surv_weight_cluster_strata = surv_weight_strata * surv_weight_cluster)"},{"path":"anket-analizi.html","id":"anket-tasarım-nesneleri","chapter":"26 Anket analizi","heading":"26.6 Anket tasarım nesneleri","text":"Çalışma tasarımınıza göre anket nesnesi oluşturun. Ağırlık orantılarını vb. hesaplamak için veri çerçeveleri ile aynı şekilde kullanılır. Bundan önce gerekli tüm değişkenlerin oluşturulduğundan emin olun.Dört seçenek vardır, kullanmadıklarınızı yorumlayarak kodun dışında bırakın:Basit rastgeleTabakalıKümeTabakalı kümeBu şablon için - anketleri iki ayrı katmanda (sağlık bölgeleri ve B) gruplandırdığımızı farz edeceğiz. Bu nedenle, genel tahminler elde etmek için küme ve tabaka ağırlıklarının birleştirilmesine ihtiyacımız var.Daha önce de belirtildiği gibi, bunu yapmak için iki paket mevcuttur. Klasik olan survey paketidir; ve daha sonra düzenli tidyverse dostu nesneler ve işlevler yapan srvyr adında bir sarmalayıcı paket vardır. Burada ikisini de göstereceğiz, ancak bu bölümdeki kodun çoğunun srvyr tabanlı nesneleri kullanacağını unutmayın. Tek istisna, gtsummary paketinin yalnızca anket nesnelerini kabul etmesidir.","code":""},{"path":"anket-analizi.html","id":"survey-paketi","chapter":"26 Anket analizi","heading":"26.6.1 Survey paketi","text":"survey paketi, R tabanı kodlamasını etkin bir şekilde kullanır ve bu nedenle tüneller (%>%) veya diğer dplyr sözdizimini kullanmak mümkün değildir. survey paketiyle, uygun kümeler, ağırlıklar ve tabakalarla bir anket nesnesi tanımlamak için svydesign() fonksiyonunu kullanırız.: Değişkenlerin önünde yaklaşık işareti (~) kullanmamız gerekir, bunun nedeni paketin formüllere dayalı değişkenler atamak için R tabanı sözdizimini kullanmasıdır.","code":"\n# basit rastgele ---------------------------------------------------------------\nbase_survey_design_simple <- svydesign(ids = ~1, # küme kimliği yok demek için 1\n                   weights = NULL,               # Ağırlık eklenmedi\n                   strata = NULL,                # örnekleme basitti (tabaka yok)\n                   data = survey_data            # veri kümesini belirtmek zorunda\n                  )\n\n## tabakalı --------------------------------------------------------------------\nbase_survey_design_strata <- svydesign(ids = ~1,  # küme kimliği yok demek için 1\n                   weights = ~surv_weight_strata, # yukarıda oluşturulan ağırlık değişkeni\n                   strata = ~health_district,     # örnekleme bölgelere göre tabakalandırılmıştır\n                   data = survey_data             # veri kümesini belirtmek zorunda\n                  )\n\n# küme -------------------------------------------------------------------------\nbase_survey_design_cluster <- svydesign(ids = ~village_name, # küme kimlikleri\n                   weights = ~surv_weight_cluster, # yukarıda oluşturulan ağırlık değişkeni\n                   strata = NULL,                 # örnekleme basitti (tabaka yok)\n                   data = survey_data              # veri kümesini belirtmek zorunda\n                  )\n\n# tabakalı küme ----------------------------------------------------------------\nbase_survey_design <- svydesign(ids = ~village_name,      # küme kimlikleri\n                   weights = ~surv_weight_cluster_strata, # yukarıda oluşturulan ağırlık değişkeni\n                   strata = ~health_district,             # örnekleme bölgelere göre tabakalandırılmıştır\n                   data = survey_data                     # veri kümesini belirtmek zorunda\n                  )"},{"path":"anket-analizi.html","id":"srvyr-paketi","chapter":"26 Anket analizi","heading":"26.6.2 Srvyr paketi","text":"srvyr paketiyle, yukarıdakiyle aynı argümanlara sahip olan ancak tünellere (%>%) izin veren as_survey_design() fonksiyonunu kullanabiliriz ve bu nedenle tilde (~) kullanmamız gerekmez.","code":"\n## basit rastgele --------------------------------------------------------------\nsurvey_design_simple <- survey_data %>% \n  as_survey_design(ids = 1, # küme kimliği yok demek için 1\n                   weights = NULL, # Ağırlık eklenmedi\n                   strata = NULL # örnekleme basitti (tabaka yok)\n                  )\n## tabakalı --------------------------------------------------------------------\nsurvey_design_strata <- survey_data %>%\n  as_survey_design(ids = 1, # küme kimliği yok demek için 1\n                   weights = surv_weight_strata, # yukarıda oluşturulan ağırlık değişkeni\n                   strata = health_district # örnekleme bölgelere göre tabakalandırılmıştır\n                  )\n## küme ------------------------------------------------------------------------\nsurvey_design_cluster <- survey_data %>%\n  as_survey_design(ids = village_name, # küme kimlikleri\n                   weights = surv_weight_cluster, # yukarıda oluşturulan ağırlık değişkeni\n                   strata = NULL # örnekleme basitti (tabaka yok)\n                  )\n\n## tabakalı küme ---------------------------------------------------------------\nsurvey_design <- survey_data %>%\n  as_survey_design(ids = village_name, # küme kimlikleri\n                   weights = surv_weight_cluster_strata, # yukarıda oluşturulan ağırlık değişkeni\n                   strata = health_district # örnekleme bölgelere göre tabakalandırılmıştır\n                  )"},{"path":"anket-analizi.html","id":"tanımlayıcı-analiz","chapter":"26 Anket analizi","heading":"26.7 Tanımlayıcı analiz","text":"Temel tanımlayıcı analiz ve görselleştirme, el kitabının diğer bölümlerinde kapsamlı bir şekilde ele alınmıştır, bu nedenle burada üzerinde durmayacağız. Ayrıntılar için tanımlayıcı tablolar, istatistiksel testler, sunum tabloları, ggplot temelleri ve R markdown raporları ile ilgili bölümlere bakabilirsiniz.Bu bölümde, örnekleminizdeki yanlılığı nasıl araştırıp bunu görselleştireceğimize odaklanacağız. Ayrıca alüvyon/sankey diyagramlarını kullanarak bir anket ortamında nüfus akışını görselleştirmeye bakacağız.Genel olarak, aşağıdaki tanımlayıcı analizleri dahil etmeyi düşünmelisiniz:Dahil edilen kümelerin, hanelerin ve bireylerin nihai sayısıDışlanan kişi sayısı ve dışlanma nedenleriKüme başına medyan (aralık) hane ve hane başına birey sayısı","code":""},{"path":"anket-analizi.html","id":"örnekleme-yanlılığı","chapter":"26 Anket analizi","heading":"26.7.1 Örnekleme yanlılığı","text":"Örnekleminiz ve kaynak popülasyon arasındaki yaş grubundaki orantıları karşılaştırın. Bu, potansiyel örnekleme yanlılığını vurgulayabilmek için önemlidir. Benzer şekilde, cinsiyete göre dağılımlara bakarak da bunu tekrarlayabilirsiniz.Bu p değerlerinin yalnızca gösterge niteliğinde olduğunu ve kaynak popülasyona kıyasla çalışma örneğinizdeki dağılımların açıklayıcı bir tartışmasının (veya aşağıdaki yaş piramitleriyle görselleştirmenin) binom testinin kendisinden daha önemli olduğunu unutmayın. Bunun nedeni, örnek boyutunun artmasının, verilerinizi ağırlıklandırdıktan sonra alakasız olabilecek farklılıklara yol açmamasıdır.","code":"\n## çalışma popülasyonunun sayıları ve orantıları\nag <- survey_data %>% \n  group_by(age_group) %>% \n  drop_na(age_group) %>% \n  tally() %>% \n  mutate(proportion = n / sum(n), \n         n_total = sum(n))\n\n## kaynak popülasyonun sayıları ve orantıları\npropcount <- population %>% \n  group_by(age_group) %>%\n    tally(population) %>%\n    mutate(proportion = n / sum(n))\n\n## iki tablonun sütunlarını birbirine bağla, yaşa göre grupla ve bir\n## n/toplamın popülasyondan önemli ölçüde farklı olup olmadığını görmek için binom testi orantısı.\n  ## buradaki son ek, iki veri kümesinin her birindeki sütunların sonuna metne ekler\nleft_join(ag, propcount, by = \"age_group\", suffix = c(\"\", \"_pop\")) %>%\n  group_by(age_group) %>%\n  ## broom::tidy(binom.test()) binom testinden bir veri çerçevesi yapar ve\n  ## p.value, parametre, conf.low, conf.high, method ve değişkenlerini ekleyecektir.\n  ## Burada sadece p.value kullanacağız. diğerlerini dahil edebilirsiniz\n  ## güven aralıklarını bildirmek istiyorsanız sütunlar\n  mutate(binom = list(broom::tidy(binom.test(n, n_total, proportion_pop)))) %>%\n  unnest(cols = c(binom)) %>% # important for expanding the binom.test data frame\n  mutate(proportion_pop = proportion_pop * 100) %>%\n  ## Yanlış pozitifleri düzeltmek için p-değerlerini ayarla\n  ## (çünkü birden fazla yaş grubunu test ediyor). Bu sadece yapacak\n  ## birçok yaş kategoriniz varsa bir fark verir\n  mutate(p.value = p.adjust(p.value, method = \"holm\")) %>%\n                      \n  ## Yalnızca 0,001'in üzerindeki p değerlerini göster (<0,001 olarak rapor edilenler)\n  mutate(p.value = ifelse(p.value < 0.001, \n                          \"<0.001\", \n                          as.character(round(p.value, 3)))) %>% \n  \n  ## sütunları uygun şekilde yeniden adlandır\n  select(\n    \"Age group\" = age_group,\n    \"Study population (n)\" = n,\n    \"Study population (%)\" = proportion,\n    \"Source population (n)\" = n_pop,\n    \"Source population (%)\" = proportion_pop,\n    \"P-value\" = p.value\n  )## # A tibble: 5 × 6\n## # Groups:   Age group [5]\n##   `Age group` `Study population (n)` `Study population (%)` `Source population (n)` `Source population (%)` `P-value`\n##   <chr>                        <int>                  <dbl>                   <dbl>                   <dbl> <chr>    \n## 1 0-2                             12                 0.0256                    1360                     6.8 <0.001   \n## 2 3-14                            42                 0.0896                    7244                    36.2 <0.001   \n## 3 15-29                           64                 0.136                     5520                    27.6 <0.001   \n## 4 30-44                           52                 0.111                     3232                    16.2 0.002    \n## 5 45+                            299                 0.638                     2644                    13.2 <0.001"},{"path":"anket-analizi.html","id":"demografik-piramitler","chapter":"26 Anket analizi","heading":"26.7.2 Demografik piramitler","text":"Demografik (veya yaş-cinsiyet) piramitler, anket popülasyonunuzdaki dağılımı görselleştirmenin kolay bir yoludur. Anket tabaklarına göre yaş ve cinsiyet için tanımlayıcı tabloları oluşturmayı da düşünmeye değer. Yukarıda oluşturulan anket tasarım nesnemizi kullanarak ağırlıklı orantılara izin verdiği için apyramid paketini kullanmayı göstereceğiz. Demografik piramitler oluşturmaya yönelik diğer seçenekler, el kitabının bu bölümünde kapsamlı bir şekilde ele alınmıştır. Ayrıca, orantıları olan bir grafik üretmek için birkaç satır kodlama kaydeden, age_pyramid() adlı sitrep paketinden bir sarmalayıcı işlevi kullanacağız.Yukarıda örnekleme yanlılığı bölümünde görülen resmi binom farklılık testinde olduğu gibi, burada örneklenen popülasyonumuzun kaynak popülasyondan önemli ölçüde farklı olup olmadığını ve ağırlıklandırmanın bu farkı düzeltip düzeltmediğini görselleştirmekle ilgileniyoruz. Bunu yapmak için ggplot görselleştirmelerimizi yan yana göstermek için patchwork paketini kullanacağız; ayrıntılar için el kitabının ggplot ipuçları bölümündeki grafikleri birleştirme bölümüne bakın. Kaynak popülasyonumuzu, ağırlıksız anket popülasyonumuzu ve ağırlıklı anket popülasyonumuzu görselleştireceğiz. Anketinizin katmanına göre görselleştirmeyi de düşünebilirsiniz - buradaki örneğimizde bu, stack_by = \"health_district\" argümanını kullanmak olacaktır (ayrıntılar için ?age_pyramid komutuna bknz.).: x ve y eksenleri piramitlerde çevrilir.","code":"\n## x ekseni sınırlarını ve etiketlerini tanımlayın -----------------------------\n## (bu sayıları grafiğinizin değerleri olacak şekilde güncelle)\nmax_prop <- 35      # göstermek istediğiniz en yüksek orantıyı seç\nstep <- 5           # etiketler arasında istediğiniz boşluğu seç\n\n## bu kısım, vektörü yukarıdaki sayıları kullanarak eksen sonları ile tanımlar.\nbreaks <- c(\n    seq(max_prop/100 * -1, 0 - step/100, step/100), \n    0, \n    seq(0 + step / 100, max_prop/100, step/100)\n    )\n\n## bu kısım vektörü yukarıdaki sayıları kullanarak eksen limitleri ile tanımlar.\nlimits <- c(max_prop/100 * -1, max_prop/100)\n\n## bu kısım, vektörü, eksen etiketleriyle birlikte yukarıdaki sayıları kullanarak tanımlar.\nlabels <-  c(\n      seq(max_prop, step, -step), \n      0, \n      seq(step, max_prop, step)\n    )\n\n\n## ayrı ayrı grafikler oluştur  ------------------------------------------------\n\n## kaynak popülasyonu grafiklendir \n## not: bunun genel nüfus için daraltılması gerekiyor (yani sağlık bölgelerinin kaldırılması)\nsource_population <- population %>%\n  ## yaş ve cinsiyetin faktörler olduğundan emin ol\n  mutate(age_group = factor(age_group, \n                            levels = c(\"0-2\", \n                                       \"3-14\", \n                                       \"15-29\",\n                                       \"30-44\", \n                                       \"45+\")), \n         sex = factor(sex)) %>% \n  group_by(age_group, sex) %>% \n  ## birlikte her sağlık bölgesi için sayıları ekle\n  summarise(population = sum(population)) %>% \n  ## genel orantıyı hesaplayabilmek için gruplandırmayı kaldır\n  ungroup() %>% \n  mutate(proportion = population / sum(population)) %>% \n  ## piramid grafiği\n  age_pyramid(\n            age_group = age_group, \n            split_by = sex, \n            count = proportion, \n            proportional = TRUE) +\n  ## sadece y ekseni etiketini göster (aksi takdirde her üç çizimde de tekrarlanır)\n  labs(title = \"Source population\", \n       y = \"\", \n       x = \"Age group (years)\") + \n  ## x eksenini tüm grafikler için aynı yap\n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n  \n  \n## ağırlıksız örnek popülasyonunu grafiklendir\nsample_population <- age_pyramid(survey_data, \n                 age_group = \"age_group\", \n                 split_by = \"sex\",\n                 proportion = TRUE) + \n  ## sadece x ekseni etiketini göster (aksi takdirde her üç grafikte de tekrarlanır)\n  labs(title = \"Unweighted sample population\", \n       y = \"Proportion (%)\", \n       x = \"\") + \n  ## x eksenini tüm grafikler için aynı yap\n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n\n\n## ağırlıklı örnek popülasyonunu grafiklendir \nweighted_population <- survey_design %>% \n  ## değişkenlerin faktör olduğundan emin ol\n  mutate(age_group = factor(age_group), \n         sex = factor(sex)) %>%\n  age_pyramid(\n    age_group = \"age_group\",\n    split_by = \"sex\", \n    proportion = TRUE) +\n  ## sadece x ekseni etiketini göster (aksi takdirde her üç grafikte de tekrarlanır)\n  labs(title = \"Weighted sample population\", \n       y = \"\", \n       x = \"\")  + \n  ## x eksenini tüm grafikler için aynı yap\n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n\n## üç grafiğin tümünü birleştir ------------------------------------------------\n## + kullanarak üç grafiği yan yana birleştir\nsource_population + sample_population + weighted_population + \n  ## sadece bir legand göster ve temayı tanımla \n  ## temayı plot_layout() ile birleştirmek için & kullanımına dikkat et\n  plot_layout(guides = \"collect\") & \n  theme(legend.position = \"bottom\",                    # açıklamayı aşağıya taşı\n        legend.title = element_blank(),                # başlığı kaldır\n        text = element_text(size = 18),                # metin boyutunu değiştir\n        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1) # x ekseni metnini çevir\n       )"},{"path":"anket-analizi.html","id":"alluvialsankey-diagramı","chapter":"26 Anket analizi","heading":"26.7.3 Alluvial/sankey diagramı","text":"Bireyler için başlangıç noktalarını ve sonuçları görselleştirmek, genel bir bakış elde etmek için çok yardımcı olabilir. Mobil popülasyonlar için oldukça açık bir uygulama var, ancak kohortlar veya bireyler için durumlarda geçişlerin olduğu diğer durumlar gibi çok sayıda başka uygulama var. Bu diyagramların alüvyon, sankey ve paralel kümeler dahil olmak üzere birkaç farklı adı vardır - ayrıntılar el kitabının Diyagramlar ve çizelgeler bölümündedir.","code":"\n## verileri özetle\nflow_table <- survey_data %>%\n  count(startcause, endcause, sex) %>%  # sayımları al \n  gather_set_data(x = c(\"startcause\", \"endcause\"))     # grafiklendirme için formatı değiştir\n\n\n## veri kümesini çiz \n  ## x ekseninde başlangıç ve bitiş nedenleri\n  ## gather_set_data, her olası kombinasyon için bir kimlik oluşturur\n  ## y ile bölme, olası başlangıç/bitiş kombinasyonlarını verir\n  ## n'nin sayı olarak verdiği değer (orantı olarak da değiştirilebilir)\nggplot(flow_table, aes(x, id = id, split = y, value = n)) +\n  ## cinsiyete göre renk çizgileri\n  geom_parallel_sets(aes(fill = sex), alpha = 0.5, axis.width = 0.2) +\n  ## etiket kutularını gri doldur\n  geom_parallel_sets_axes(axis.width = 0.15, fill = \"grey80\", color = \"grey80\") +\n  ## metin rengini ve açısını değiştir (ayarlanması gerekiyor)\n  geom_parallel_sets_labels(color = \"black\", angle = 0, size = 5) +\n  ## ayarlanmış y ve x eksenleri (muhtemelen daha fazla dikey alana ihtiyaç duyar)\n  scale_x_discrete(name = NULL, expand = c(0, 0.2)) + \n  ## eksen etiketlerini kaldır\n  theme(\n    title = element_text(size = 26),\n    text = element_text(size = 26),\n    axis.line = element_blank(),\n    axis.ticks = element_blank(),\n    axis.text.y = element_blank(),\n    panel.background = element_blank(),\n    legend.position = \"bottom\",                    # açıklamayı aşağıya taşı\n    legend.title = element_blank(),                # başlığı kaldır\n  )"},{"path":"anket-analizi.html","id":"ağırlıklı-orantılar","chapter":"26 Anket analizi","heading":"26.8 Ağırlıklı orantılar","text":"Bu bölüm, ilişkili güven aralıkları ve tasarım etkisi ile birlikte ağırlıklı sayımlar ve oranlar için tabloların nasıl üretileceğini detaylandıracaktır. Aşağıdaki paketlerdeki işlevleri kullanan dört farklı seçenek vardır: survey, srvyr, sitrep ve gtsummary. Standart bir epidemiyoloji stili tablosu oluşturmak üzere minimum kodlama için, srvyr kodunun sarmalayıcısı olan sitrep fonksiyonunu öneriyoruz; Ancak bunun henüz CRAN’da olmadığını ve gelecekte değişebileceğini unutmayın. Aksi takdirde, survey kodu muhtemelen en istikrarlı ve uzun vadeli paket olacaktır, oysa srvyr paketi en iyi şekilde derli toplu iş akışlarına uymaktadır. gtsummary fonksiyonları çok fazla potansiyele sahip olsa da, bu kitap yazıldığı sırada deneysel ve eksiktirler.","code":""},{"path":"anket-analizi.html","id":"survey-paketi-1","chapter":"26 Anket analizi","heading":"26.8.1 Survey paketi","text":"Ağırlıklı orantılar ve beraberindeki %95 güven aralıklarını elde etmek için survey paketinden svyciprop() fonksiyonunu kullanabiliriz. Uygun bir tasarım efekti, svyprop() fonksiyonu yerine svymean() kullanılarak da çıkarılabilir. svyprop() fonksiyonunun yalnızca 0 ile 1 (veya DOĞRU/YANLIŞ) arasındaki değişkenleri kabul ediyor gibi göründüğünü, dolayısıyla kategorik değişkenlerin çalışmayacağını belirtmekte fayda var.: survey paketinden gelen foksiyonlar ayrıca srvyr tasarım nesnelerini de kabul etmektedir, ancak burada anket survey nesnesini yalnızca tutarlılık için kullandık. Yukarıda gösterilen survey fonksiyonları, aşağıda kendimizi tanımladığımız, svy_prop adlı bir fonksiyonda birleştirebiliriz; ve daha sonra bu fonksiyonu purrr paketindeki map() ile birlikte birkaç değişken üzerinde yineleme yapmak ve bir tablo oluşturmak için kullanabiliriz. purrr hakkında ayrıntılar için el kitabı yineleme bölümüne bakabilirsiniz.","code":"\n## ağırlıklı sayılar üretme\nsvytable(~died, base_survey_design)## died\n##      FALSE       TRUE \n## 1406244.43   76213.01\n## ağırlıklı orantılar üretme\nsvyciprop(~died, base_survey_design, na.rm = T)##               2.5% 97.5%\n## died 0.0514 0.0208  0.12\n## tasarım efektini al\nsvymean(~died, base_survey_design, na.rm = T, deff = T) %>% \n  deff()## diedFALSE  diedTRUE \n##  3.755508  3.755508\n# Ağırlıklı sayıları, oranlatıları, CI ve tasarım etkisini hesaplamak için fonksiyonu tanımla\n# x tırnak içindeki değişkendir \n# tasarım, sizin anket tasarım nesnenizdir\n\nsvy_prop <- function(design, x) {\n  \n  ## ilgilenilen değişkeni bir formüle koy\n  form <- as.formula(paste0( \"~\" , x))\n  ## svytable'dan yalnızca DOĞRU sayım sütununu sakla\n  weighted_counts <- svytable(form, design)[[2]]\n  ## orantıları hesapla (yüzdeleri almak için 100 ile çarpın)\n  weighted_props <- svyciprop(form, design, na.rm = TRUE) * 100\n  ## güven aralıklarını çıkarın ve yüzdeleri elde etmek için çarp\n  weighted_confint <- confint(weighted_props) * 100\n  ## tasarım etkisini hesaplamak için svymean kullanın ve yalnızca DOĞRU sütununu koru\n  design_eff <- deff(svymean(form, design, na.rm = TRUE, deff = TRUE))[[TRUE]]\n  \n  ## tek bir veri çerçevesinde birleştir\n  full_table <- cbind(\n    \"Variable\"        = x,\n    \"Count\"           = weighted_counts,\n    \"Proportion\"      = weighted_props,\n    weighted_confint, \n    \"Design effect\"   = design_eff\n    )\n  \n  ## tabloyu veri çerçevesi olarak döndür\n  full_table <- data.frame(full_table, \n             ## remove the variable names from rows (is a separate column now)\n             row.names = NULL)\n  \n  ## sayısalları tekrar sayısal olarak değiştir\n  full_table[ , 2:6] <- as.numeric(full_table[, 2:6])\n  \n  ## veri çerçevesini döndür\n  full_table\n}\n\n## bir tablo oluşturmak için birkaç değişken üzerinde yineleme yap\npurrr::map(\n  ## ilgilenilen değişkenleri tanımla\n  c(\"left\", \"died\", \"arrived\"), \n  ## durum fonksiyonu kullanımı ve bu fonksiyon için argümanlar (tasarım)\n  svy_prop, design = base_survey_design) %>% \n  ## listeyi tek bir veri çerçevesine daralt\n  bind_rows() %>% \n  ## yuvarla\n  mutate(across(where(is.numeric), round, digits = 1))##   Variable    Count Proportion X2.5. X97.5. Design.effect\n## 1     left 701199.1       47.3  39.2   55.5           2.4\n## 2     died  76213.0        5.1   2.1   12.1           3.8\n## 3  arrived 761799.0       51.4  40.9   61.7           3.9"},{"path":"anket-analizi.html","id":"srvyr-paketi-1","chapter":"26 Anket analizi","heading":"26.8.2 Srvyr paketi","text":"srvyr ile bir tablo oluşturmak için dplyr sözdizimini kullanabiliriz. survey_mean() fonksiyonunun kullanıldığını ve orantı argümanının belirtildiğini ve ayrıca tasarım etkisini hesaplamak için aynı fonksiyonu kullanıldığını unutmayın. Bunun nedeni, srvyr paketinin yukarıdaki bölümde kullanılan svyciprop() ve svymean() survey paketi fonksiyonun ikisinin de etrafını sarmasıdır.: Kategorik değişkenlerden orantıları srvyr paketini kullanarak da almak pek mümkün görünmüyor, buna ihtiyacınız varsa sitrep paketini kullanmanız gerekir. Detaylar için aşağıdaki bölüme göz atın.Burada da purrr paketini kullanarak birden çok değişken üzerinde yineleme yapacak bir fonksiyon yazabiliriz. purrr hakkında ayrıntılar için el kitabı yineleme bölümüne bakabilirsiniz.","code":"\n## srvyr tasarım nesnesini kullan\nsurvey_design %>% \n  summarise(\n    ## ağırlıklı sayıları üret\n    counts = survey_total(died), \n    ## ağırlıklı orantıları ve güven aralıkları üret\n    ## yüzde almak için 100 ile çarp\n    props = survey_mean(died, \n                        proportion = TRUE, \n                        vartype = \"ci\") * 100, \n    ## tasarım efekti üret\n    deff = survey_mean(died, deff = TRUE)) %>% \n  ## sadece ilgi alanlarını tut\n  ## (standart hataları bırakın ve orantı hesaplamasını tekrarla)\n  select(counts, props, props_low, props_upp, deff_deff)## # A tibble: 1 × 5\n##   counts props props_low props_upp deff_deff\n##    <dbl> <dbl>     <dbl>     <dbl>     <dbl>\n## 1 76213.  5.14      2.08      12.1      3.76\n# Ağırlıklı sayıları, orantıları, CI ve tasarım etkisini hesaplamak için işlevi tanımla\n# tasarım, sizin anket tasarım nesnenizdir\n# x tırnak içindeki değişkendir\n\n\nsrvyr_prop <- function(design, x) {\n  \n  summarise(\n    ## anket tasarım nesnesini kullan\n    design, \n    ## ağırlıklı sayıları üret\n    counts = survey_total(.data[[x]]), \n    ## ağırlıklı orantıları ve güven aralıkları üret\n    ## yüzde almak için 100 ile çarp\n    props = survey_mean(.data[[x]], \n                        proportion = TRUE, \n                        vartype = \"ci\") * 100, \n    ## tasarım efekti üret\n    deff = survey_mean(.data[[x]], deff = TRUE)) %>% \n  ## değişken adını ekle\n  mutate(variable = x) %>% \n  ## sadece ilgi alanlarını tut\n  ## (standart hataları bırak ve orantı hesaplamasını tekrarla)\n  select(variable, counts, props, props_low, props_upp, deff_deff)\n  \n}\n  \n\n## bir tablo oluşturmak için birkaç değişken üzerinde yineleme yap\npurrr::map(\n  ## ilgilenilen değişkenleri tanımla\n  c(\"left\", \"died\", \"arrived\"), \n  ## durum fonksiyonu kullanımı ve bu fonksiyon için argümanlar (tasarım)\n  ~srvyr_prop(.x, design = survey_design)) %>% \n  ## listeyi tek bir veri çerçevesine daralt\n  bind_rows()## # A tibble: 3 × 6\n##   variable  counts props props_low props_upp deff_deff\n##   <chr>      <dbl> <dbl>     <dbl>     <dbl>     <dbl>\n## 1 left     701199. 47.3      39.2       55.5      2.38\n## 2 died      76213.  5.14      2.08      12.1      3.76\n## 3 arrived  761799. 51.4      40.9       61.7      3.93"},{"path":"anket-analizi.html","id":"sitrep-paketi","chapter":"26 Anket analizi","heading":"26.8.3 Sitrep paketi","text":"sitrep paketinin tab_survey() fonksiyonu, minimum kodlama ile ağırlıklı tablolar oluşturmanıza olanak tanıyan srvyr paketi için bir sarmalayıcıdır. Ayrıca kategorik değişkenler için ağırlıklı orantıları hesaplamanıza olanak tanır.","code":"\n## anket tasarım nesnesini kullan\nsurvey_design %>% \n  ## ilgilenilen değişkenlerin isimlerini alıntı yapılmadan ilet\n  tab_survey(arrived, left, died, education_level,\n             deff = TRUE,   # tasarım etkisini hesapla\n             pretty = TRUE  # oranı ve %95 CI'yi birleştir\n             )## Warning: removing 257 missing value(s) from `education_level`## # A tibble: 9 × 5\n##   variable        value            n  deff ci                \n##   <chr>           <chr>        <dbl> <dbl> <chr>             \n## 1 arrived         TRUE       761799.  3.93 51.4% (40.9--61.7)\n## 2 arrived         FALSE      720658.  3.93 48.6% (38.3--59.1)\n## 3 left            TRUE       701199.  2.38 47.3% (39.2--55.5)\n## 4 left            FALSE      781258.  2.38 52.7% (44.5--60.8)\n## 5 died            TRUE        76213.  3.76 5.1% (2.1--12.1)  \n## 6 died            FALSE     1406244.  3.76 94.9% (87.9--97.9)\n## 7 education_level higher     171644.  4.70 42.4% (26.9--59.7)\n## 8 education_level primary    102609.  2.37 25.4% (16.2--37.3)\n## 9 education_level secondary  130201.  6.68 32.2% (16.5--53.3)"},{"path":"anket-analizi.html","id":"gtsummary-paketi","chapter":"26 Anket analizi","heading":"26.8.4 Gtsummary paketi","text":"gtsummary paketinde henüz güven aralıklarını veya tasarım efektini eklemek için yerleşik fonksiyonlar yok gibi görünüyor. Burada, güven aralıkları eklemek için bir fonksiyonun nasıl tanımlanacağını ve ardından tbl_svysummary() fonksiyonunu kullanılarak oluşturulan bir gtsummary tablosuna güven aralıklarının nasıl ekleneceğini gösteriyoruz.","code":"\nconfidence_intervals <- function(data, variable, by, ...) {\n  \n  ## güven aralıklarını çıkarın ve yüzdeleri elde etmek için çarp\n  props <- svyciprop(as.formula(paste0( \"~\" , variable)),\n              data, na.rm = TRUE)\n  \n  ## güven aralıklarını çıkar\n  as.numeric(confint(props) * 100) %>% ## sayısal yap ve yüzde için çarp\n    round(., digits = 1) %>%           ## bir haneye yuvarla\n    c(.) %>%                           ## sayıları matristen çıkar\n    paste0(., collapse = \"-\")          ## tek karakterle birleştir\n}\n\n## anket paketi tasarım nesnesini kullan\ntbl_svysummary(base_survey_design, \n               include = c(arrived, left, died),   ## dahil etmek istediğiniz değişkenleri tanımla\n               statistic = list(everything() ~ c(\"{n} ({p}%)\"))) %>% ## ilgi istatistiklerini tanımla\n  add_n() %>%  ## add the weighted total \n  add_stat(fns = everything() ~ confidence_intervals) %>% ## güven aralığını ekle\n  ## sütun başlıklarını değiştir\n  modify_header(\n    list(\n      n ~ \"**Weighted total (N)**\",\n      stat_0 ~ \"**Weighted Count**\",\n      add_stat_1 ~ \"**95%CI**\"\n    )\n    )"},{"path":"anket-analizi.html","id":"ağırlıklı-hızlar","chapter":"26 Anket analizi","heading":"26.9 Ağırlıklı hızlar","text":"Benzer şekilde ağırlıklı hızlar için (ölüm hızları gibi) survey veya srvyr paketini kullanabilirsiniz. Birkaç değişken üzerinde yineleme yapmak için benzer şekilde (yukarıdakilere benzer) fonksiyonlar yazabilirsiniz. Ayrıca gtsummary için yukarıdaki gibi bir fonksiyon oluşturabilirsiniz, ancak şu anda dahili bir fonksiyonelliği bulunmamaktadır.","code":""},{"path":"anket-analizi.html","id":"survey-paketi-2","chapter":"26 Anket analizi","heading":"26.9.1 Survey paketi","text":"","code":"\nratio <- svyratio(~died, \n         denominator = ~obstime, \n         design = base_survey_design)\n\nci <- confint(ratio)\n\ncbind(\n  ratio$ratio * 10000, \n  ci * 10000\n)##       obstime    2.5 %   97.5 %\n## died 5.981922 1.194294 10.76955"},{"path":"anket-analizi.html","id":"srvyr-paketi-2","chapter":"26 Anket analizi","heading":"26.9.2 Srvyr paketi","text":"","code":"\nsurvey_design %>% \n  ## gözlem süresini hesaba katmak için kullanılan anket hızı\n  summarise(\n    mortality = survey_ratio(\n      as.numeric(died) * 10000, \n      obstime, \n      vartype = \"ci\")\n    )## # A tibble: 1 × 3\n##   mortality mortality_low mortality_upp\n##       <dbl>         <dbl>         <dbl>\n## 1      5.98         0.349          11.6"},{"path":"anket-analizi.html","id":"kaynaklar-19","chapter":"26 Anket analizi","heading":"26.10 Kaynaklar","text":"UCLA istatistik sayfasıAnket verilerini ücretsiz analiz edinsrvyr paketigtsummary paketiEPIET anket vaka çalışmaları","code":""},{"path":"sağkalım-analizi.html","id":"sağkalım-analizi","chapter":"27 Sağkalım Analizi","heading":"27 Sağkalım Analizi","text":"","code":""},{"path":"sağkalım-analizi.html","id":"genel-bakış-5","chapter":"27 Sağkalım Analizi","heading":"27.1 Genel Bakış","text":"Sağkalım analizi, belirli bir birey veya birey grubu için, başarısızlık (bir hastalığın ortaya çıkması, bir hastalıktan iyileşme, ölüm, tedaviye yanıttan sonra nüks…) olarak adlandırılan bir olay noktasını tanımlamaya odaklanır. Bu, bireylerin gözlemlendiği başarısızlık süresi (veya kohort/nüfus temelli çalışmalarda izleme süresi) olarak adlandırılan bir süreden sonra ortaya çıkar. Başarısızlık süresini belirlemek için, daha sonra bir başlangıç zamanı tanımlamak gerekir (bu, dahil etme tarihi, teşhis tarihi olabilir…).Sağkalım analizinin nihayi çıktısı, başlangıç noktası ile olay arasındaki zamandır. Mevcut tıbbi araştırmalarda, örneğin klinik çalışmalarda bir tedavinin etkisini veya çeşitli kanser sağkalım ölçümlerini değerlendirmek için kanser epidemiyolojisinde yaygın olarak kullanılmaktadır.Genellikle sağkalım ihtimali ile ifade edilir;ki bu, ilgilenilen olayın t süresi boyunca gerçekleşmemiş olma olasılığıdır.Sansürleme: Sansür; izlem sonunda, bazı kişilerin ilgilendikleri olay olmadığında ve bu nedenle gerçek zamanlarının bilinmediği durumlarda meydana gelir. Burada çoğunlukla doğru sansürlemeye odaklanacağız, ancak genel olarak sansürleme ve sağkalım analizi hakkında daha fazla ayrıntı için referansları görebilirsiniz.","code":""},{"path":"sağkalım-analizi.html","id":"hazırlık-18","chapter":"27 Sağkalım Analizi","heading":"27.2 Hazırlık","text":"","code":""},{"path":"sağkalım-analizi.html","id":"paketleri-yükleyin-5","chapter":"27 Sağkalım Analizi","heading":"Paketleri yükleyin","text":"R’da sağkalım analizlerini çalıştırmak için en yaygın kullanılan paketlerden biri survival paketidir. Önce o kurulur ve ardından bu bölümde kullanılacak diğer paketlerin yanı sıra o da yüklenir:Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() vurgusu yapılmaktadır. R tabanı’ndan library() ile kurulu paketler de yüklenebilir. R paketleri hakkında daha fazla bilgi için R’ın temelleri sayfasına bakabilirsiniz.Bu sayfa, önceki sayfaların çoğunda kullanılan ve uygun bir sağkalım verisine sahip olmak için bazı değişiklikler uyguladığımız satır listesini kullanarak sağkalım analizlerini araştırmaktadır.","code":""},{"path":"sağkalım-analizi.html","id":"veri-kümesini-içe-aktar","chapter":"27 Sağkalım Analizi","heading":"Veri kümesini içe aktar","text":"Simüle edilmiş bir Ebola salgınından vakaların veri seti içe aktarılmaktadır. Takip etmek için; “temiz satır listesi” dosyasını indirmek için tıklayın. (.rds dosyası olarak). rio paketinden import() işleviyle veriler içe aktarılabilir (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe ve dışa aktarma] sayfasına bakılabilir).","code":"\n# import linelist\nlinelist_case_data <- rio::import(\"linelist_cleaned.rds\")"},{"path":"sağkalım-analizi.html","id":"veri-yönetimi-ve-dönüştürme","chapter":"27 Sağkalım Analizi","heading":"Veri yönetimi ve dönüştürme","text":"Kısacası, sağkalım verileri aşağıdaki üç özelliğe sahip olarak tanımlanabilir:Bağımlı değişken veya sonuç, iyi tanımlanmış bir olayın meydana gelmesine kadar geçen bekleme süresidir.Gözlemler, bazı birimler için verilerin analiz edildiği sırada ilgili olayın meydana gelmediği anlamında sansürlenir.Bekleme süresi üzerindeki etkisini değerlendirmek veya kontrol etmek istediğimiz öngörüler veya açıklayıcı değişkenler vardır.Böylece, bu yapıya uymak ve sağkalım analizini yürütmek için gereken farklı değişkenler ortaya çıkarılmaktadır.Bu analiz için yeni bir veri çerçevesini linelist_surv olarak;İlgilendiğimiz olayı “ölüm” olarak; (dolayısıyla sağkalım olasılığımız, başlangıç zamanından belirli bir süre sonra sağkalım olasılığı olacaktır),Başlangıç zamanı ile sonuç zamanı arasındaki izlem süresini (futime) gün olarak;Sansürlenmiş hastalar iyileşen veya nihai sonucu bilinmeyen, yani “ölüm” olayının gözlemlenmediği hastalar olarak (event=0);\ntanımlanmaktadır.DİKKAT: Gerçek bir kohort çalışmasında, bireyler gözlendiğinde, başlangıç zamanı ve izlem sonu hakkındaki bilgiler bilindiği için, başlangıç tarihi veya sonuç tarihi bilinmiyorsa gözlemler kaldırılacaktır. Ayrıca başlangıç tarihinin sonuç tarihinden sonra olduğu durumlar da yanlış kabul edildiğinden kaldırılacaktır.İPUCU: Bir tarihe göre büyük (>) veya küçük (<) olarak filtrelemenin eksik değerlere sahip satırları kaldırabileceği göz önüne alındığında, filtreyi yanlış tarihlere uygulamak eksik tarihlere sahip satırları da kaldıracaktır.Ardından, içinde yalnızca 3 yaş kategorisi bulunan bir age_cat_small sütunu oluşturmak için case_while() kullanılmaktadır.İPUCU: Oluşturulan yeni sütunlar, futime hakkında bir özet ve oluşturulduğu event ve outcome arasında bir çapraz tablo yapılarak doğrulanabilir. Bu doğrulamanın yanı sıra, sağkalım analizi sonuçlarını yorumlarken medyan takip süresini iletmek iyi bir alışkanlıktır.Doğru atamaları sağlamak için yeni age_cat_small var ve eski age_cat sütunu çapraz tablo haline getirilmektedir.Şimdi, belirli değişkenlere (yeni oluşturulanlar dahil) bakarak linelist_surv verilerinin ilk 10 gözlemi gözden geçirilmektedir.Bu yeni sütunun cinsiyete göre dağılımı hakkında daha fazla ayrıntıya sahip olmak için age_cat_small ve gender sütunları da çapraz tablo haline getirilebilir. [Açıklayıcı tablolar] sayfasında açıklandığı gibi janitor’dan tabyl() ve adorn fonksiyonları kullanılmaktadır.","code":"\n#create a new data called linelist_surv from the linelist_case_data\n\nlinelist_surv <-  linelist_case_data %>% \n     \n  dplyr::filter(\n       # remove observations with wrong or missing dates of onset or date of outcome\n       date_outcome > date_onset) %>% \n  \n  dplyr::mutate(\n       # create the event var which is 1 if the patient died and 0 if he was right censored\n       event = ifelse(is.na(outcome) | outcome == \"Recover\", 0, 1), \n    \n       # create the var on the follow-up time in days\n       futime = as.double(date_outcome - date_onset), \n    \n       # create a new age category variable with only 3 strata levels\n       age_cat_small = dplyr::case_when( \n            age_years < 5  ~ \"0-4\",\n            age_years >= 5 & age_years < 20 ~ \"5-19\",\n            age_years >= 20   ~ \"20+\"),\n       \n       # previous step created age_cat_small var as character.\n       # now convert it to factor and specify the levels.\n       # Note that the NA values remain NA's and are not put in a level \"unknown\" for example,\n       # since in the next analyses they have to be removed.\n       age_cat_small = fct_relevel(age_cat_small, \"0-4\", \"5-19\", \"20+\")\n       )\nsummary(linelist_surv$futime)##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##    1.00    6.00   10.00   11.98   16.00   64.00\n# cross tabulate the new event var and the outcome var from which it was created\n# to make sure the code did what it was intended to\nlinelist_surv %>% \n  tabyl(outcome, event)##  outcome    0    1\n##    Death    0 1952\n##  Recover 1547    0\n##     <NA> 1040    0\nlinelist_surv %>% \n  tabyl(age_cat_small, age_cat)##  age_cat_small 0-4 5-9 10-14 15-19 20-29 30-49 50-69 70+ NA_\n##            0-4 834   0     0     0     0     0     0   0   0\n##           5-19   0 852   717   575     0     0     0   0   0\n##            20+   0   0     0     0   862   554    69   5   0\n##           <NA>   0   0     0     0     0     0     0   0  71\nlinelist_surv %>% \n  select(case_id, age_cat_small, date_onset, date_outcome, outcome, event, futime) %>% \n  head(10)##    case_id age_cat_small date_onset date_outcome outcome event futime\n## 1   8689b7           0-4 2014-05-13   2014-05-18 Recover     0      5\n## 2   11f8ea           20+ 2014-05-16   2014-05-30 Recover     0     14\n## 3   893f25           0-4 2014-05-21   2014-05-29 Recover     0      8\n## 4   be99c8          5-19 2014-05-22   2014-05-24 Recover     0      2\n## 5   07e3e8          5-19 2014-05-27   2014-06-01 Recover     0      5\n## 6   369449           0-4 2014-06-02   2014-06-07   Death     1      5\n## 7   f393b4           20+ 2014-06-05   2014-06-18 Recover     0     13\n## 8   1389ca           20+ 2014-06-05   2014-06-09   Death     1      4\n## 9   2978ac          5-19 2014-06-06   2014-06-15   Death     1      9\n## 10  fc15ef          5-19 2014-06-16   2014-07-09 Recover     0     23\nlinelist_surv %>% \n  tabyl(gender, age_cat_small, show_na = F) %>% \n  adorn_totals(where = \"both\") %>% \n  adorn_percentages() %>% \n  adorn_pct_formatting() %>% \n  adorn_ns(position = \"front\")##  gender         0-4         5-19          20+         Total\n##       f 482 (22.4%) 1184 (54.9%)  490 (22.7%) 2156 (100.0%)\n##       m 325 (15.0%)  880 (40.6%)  960 (44.3%) 2165 (100.0%)\n##   Total 807 (18.7%) 2064 (47.8%) 1450 (33.6%) 4321 (100.0%)"},{"path":"sağkalım-analizi.html","id":"sağkalım-analizinin-temelleri","chapter":"27 Sağkalım Analizi","heading":"27.3 Sağkalım analizinin temelleri","text":"","code":""},{"path":"sağkalım-analizi.html","id":"sağkalım-analiz-materyali-oluşturma","chapter":"27 Sağkalım Analizi","heading":"Sağkalım analiz materyali oluşturma","text":"İzlem süresi ve olay sütunlarından bir hayatta kalma nesnesi oluşturmak için ilk olarak survival’den Surv() kısmını kullanılır.Böyle bir adımın sonucu, zaman bilgisini ve ilgilenilen olayın (ölüm) gözlemlenip gözlemlenmediğini özetleştiren surv türünde bir nesne üretmektir. Bu nesne nihai olarak sonraki model formüllerinin sağ tarafında kullanılacaktır (bkz. belgeler).İncelemek için, burada yalnızca bazı önemli sütunları görüntüleyen linelist_surv verilerinin ilk 10 satırı verilmiştir.Burada survobjun ilk 10 unsuru izlenmektedir. Esasen bir gözlemin doğru sansürlenip sansürlenmediğini göstermek için, “+” ile birlikte izlem süresi vektörü olarak yazdırılır. Rakamların yukarıda ve aşağıda nasıl hizalandığını görülmektedir.","code":"\n# Use Suv() syntax for right-censored data\nsurvobj <- Surv(time = linelist_surv$futime,\n                event = linelist_surv$event)\nlinelist_surv %>% \n  select(case_id, date_onset, date_outcome, futime, outcome, event) %>% \n  head(10)##    case_id date_onset date_outcome futime outcome event\n## 1   8689b7 2014-05-13   2014-05-18      5 Recover     0\n## 2   11f8ea 2014-05-16   2014-05-30     14 Recover     0\n## 3   893f25 2014-05-21   2014-05-29      8 Recover     0\n## 4   be99c8 2014-05-22   2014-05-24      2 Recover     0\n## 5   07e3e8 2014-05-27   2014-06-01      5 Recover     0\n## 6   369449 2014-06-02   2014-06-07      5   Death     1\n## 7   f393b4 2014-06-05   2014-06-18     13 Recover     0\n## 8   1389ca 2014-06-05   2014-06-09      4   Death     1\n## 9   2978ac 2014-06-06   2014-06-15      9   Death     1\n## 10  fc15ef 2014-06-16   2014-07-09     23 Recover     0\n#print the 50 first elements of the vector to see how it presents\nhead(survobj, 10)##  [1]  5+ 14+  8+  2+  5+  5  13+  4   9  23+"},{"path":"sağkalım-analizi.html","id":"ilk-analizleri-çalıştırma","chapter":"27 Sağkalım Analizi","heading":"İlk analizleri çalıştırma","text":"Gözlemlenen olay zamanlarında atlamalı bir adım fonksiyonu olan genel (marjinal) hayatta kalma eğrisinin Kaplan Meier (KM) tahminleri için varsayılan hesaplamalara uyan bir survfit nesnesi üretmek için survfit() işlevini kullanarak analize başlanır. Sonuçta survfit nesnesi bir veya daha fazla sağkalım eğrisi içerir ve model formülünde bir yanıt değişkeni olarak Surv nesnesi kullanılarak oluşturulur.: Kaplan-Meier tahmini, sağkalım fonksiyonunun parametrik olmayan maksimum olabilirlik tahminidir (MLE). . (daha fazla bilgi için kaynaklara bakın).Bu survfit nesnesinin özeti, yaşam tablosu’nu verecektir. Gerçekleşen (artan şekilde) bir olayın takip edilen bir zaman adımı için (time):Olayı geliştirme riski altında olan kişi sayısı (henüz olaya sahip olmayan veya sansürlenmemiş kişiler: n.risk),Olayı geliştirenler: (n.event),Yukarıdakilerin devamı olarak: Olayın gelişmeme olasılığı (ölmeme veya belirli bir zamandan sonra sağkalım olasılığı) bulunur;Son olarak, bu olasılık için standart hata ve güven aralığı türetilir ve görüntülenir.KM tahminleri, daha önce Surv nesnesi “survobj” un yanıt değişkeni olduğu formül kullanılarak oturtulur. Genel sağkalım için modeli çalıştırılan kesinlik “~ 1” ’dir.summary() kullanılırken times seçeneği eklenebilir ve sağkalım bilgisinin görülmek istendiği zamanlar belirtilebilir.print() fonksiyonu da kullanılabilir. print.rmean = TRUE argümanı, ortalama sağkalım süresini ve standart hatayı (se) elde etmek için kullanılır.: Kısıtlı ortalama sağkalım süresi (RMST), kanser sağkalım analizinde giderek daha fazla kullanılan ve kısıtlı T süresine kadar hastaları gözlemlediğimiz, göz önüne alındığında genellikle hayatta kalma eğrisinin altındaki alan olarak tanımlanan spesifik bir hayatta kalma ölçüsüdür. (Daha fazla ayrıntı için kaynaklar bölümüne bakın).İPUCU: surv nesnesi doğrudan survfit() işlevinde oluşturulabilir ve bir kod satırı kaydedilebilir. Bu daha sonra şöyle görünecektir: linelistsurv_quick <-  survfit(Surv(futime, event) ~ 1, data=linelist_surv).","code":"\n# fit the KM estimates using a formula where the Surv object \"survobj\" is the response variable.\n# \"~ 1\" signifies that we run the model for the overall survival  \nlinelistsurv_fit <-  survival::survfit(survobj ~ 1)\n\n#print its summary for more details\nsummary(linelistsurv_fit)## Call: survfit(formula = survobj ~ 1)\n## \n##  time n.risk n.event survival std.err lower 95% CI upper 95% CI\n##     1   4539      30    0.993 0.00120        0.991        0.996\n##     2   4500      69    0.978 0.00217        0.974        0.982\n##     3   4394     149    0.945 0.00340        0.938        0.952\n##     4   4176     194    0.901 0.00447        0.892        0.910\n##     5   3899     214    0.852 0.00535        0.841        0.862\n##     6   3592     210    0.802 0.00604        0.790        0.814\n##     7   3223     179    0.757 0.00656        0.745        0.770\n##     8   2899     167    0.714 0.00700        0.700        0.728\n##     9   2593     145    0.674 0.00735        0.660        0.688\n##    10   2311     109    0.642 0.00761        0.627        0.657\n##    11   2081     119    0.605 0.00788        0.590        0.621\n##    12   1843      89    0.576 0.00809        0.560        0.592\n##    13   1608      55    0.556 0.00823        0.540        0.573\n##    14   1448      43    0.540 0.00837        0.524        0.556\n##    15   1296      31    0.527 0.00848        0.511        0.544\n##    16   1152      48    0.505 0.00870        0.488        0.522\n##    17   1002      29    0.490 0.00886        0.473        0.508\n##    18    898      21    0.479 0.00900        0.462        0.497\n##    19    798       7    0.475 0.00906        0.457        0.493\n##    20    705       4    0.472 0.00911        0.454        0.490\n##    21    626      13    0.462 0.00932        0.444        0.481\n##    22    546       8    0.455 0.00948        0.437        0.474\n##    23    481       5    0.451 0.00962        0.432        0.470\n##    24    436       4    0.447 0.00975        0.428        0.466\n##    25    378       4    0.442 0.00993        0.423        0.462\n##    26    336       3    0.438 0.01010        0.419        0.458\n##    27    297       1    0.436 0.01017        0.417        0.457\n##    29    235       1    0.435 0.01030        0.415        0.455\n##    38     73       1    0.429 0.01175        0.406        0.452\n#print its summary at specific times\nsummary(linelistsurv_fit, times = c(5,10,20,30,60))## Call: survfit(formula = survobj ~ 1)\n## \n##  time n.risk n.event survival std.err lower 95% CI upper 95% CI\n##     5   3899     656    0.852 0.00535        0.841        0.862\n##    10   2311     810    0.642 0.00761        0.627        0.657\n##    20    705     446    0.472 0.00911        0.454        0.490\n##    30    210      39    0.435 0.01030        0.415        0.455\n##    60      2       1    0.429 0.01175        0.406        0.452\n# print linelistsurv_fit object with mean survival time and its se. \nprint(linelistsurv_fit, print.rmean = TRUE)## Call: survfit(formula = survobj ~ 1)\n## \n##         n events rmean* se(rmean) median 0.95LCL 0.95UCL\n## [1,] 4539   1952   33.1     0.539     17      16      18\n##     * restricted mean with upper limit =  64"},{"path":"sağkalım-analizi.html","id":"kümülatif-risk","chapter":"27 Sağkalım Analizi","heading":"Kümülatif risk","text":"summary() işlevinin yanı sıra, survfit() nesnesinin yapısı hakkında daha fazla ayrıntı veren str() işlevi de kullanılabilir. Liste 16 unsurdan meydana gelir.Bu unsurlardan önemli bir tanesi de sayısal bir vektör olan cumhaz ’dır. Bu, kümülatif risk gösterilmesine izin verecek şekilde belirlenebilir, risk olayın anlık meydana gelme oranı dır (kaynaklara bakınız).","code":"\nstr(linelistsurv_fit)## List of 16\n##  $ n        : int 4539\n##  $ time     : num [1:59] 1 2 3 4 5 6 7 8 9 10 ...\n##  $ n.risk   : num [1:59] 4539 4500 4394 4176 3899 ...\n##  $ n.event  : num [1:59] 30 69 149 194 214 210 179 167 145 109 ...\n##  $ n.censor : num [1:59] 9 37 69 83 93 159 145 139 137 121 ...\n##  $ surv     : num [1:59] 0.993 0.978 0.945 0.901 0.852 ...\n##  $ std.err  : num [1:59] 0.00121 0.00222 0.00359 0.00496 0.00628 ...\n##  $ cumhaz   : num [1:59] 0.00661 0.02194 0.05585 0.10231 0.15719 ...\n##  $ std.chaz : num [1:59] 0.00121 0.00221 0.00355 0.00487 0.00615 ...\n##  $ type     : chr \"right\"\n##  $ logse    : logi TRUE\n##  $ conf.int : num 0.95\n##  $ conf.type: chr \"log\"\n##  $ lower    : num [1:59] 0.991 0.974 0.938 0.892 0.841 ...\n##  $ upper    : num [1:59] 0.996 0.982 0.952 0.91 0.862 ...\n##  $ call     : language survfit(formula = survobj ~ 1)\n##  - attr(*, \"class\")= chr \"survfit\""},{"path":"sağkalım-analizi.html","id":"kaplan-meier-eğrilerinin-çizilmesi","chapter":"27 Sağkalım Analizi","heading":"Kaplan-Meier eğrilerinin çizilmesi","text":"KM tahminleri yerleştirildikten sonra, “Kaplan-Meier eğrisi” ni çizen temel plot() işlevi kullanılarak belirli bir süre boyunca sağkalım olasılığı görselleştirilebilir. Başka bir deyişle, aşağıdaki eğri, tüm hasta grubunda sağkalım deneyiminin geleneksel bir gösterimidir.Eğrideki min ve max takip süresi hızlı bir şekilde doğrulanabilir.Yorumlamanın kolay bir yolu, başlangıçta tüm katılımcıların hala hayatta olduğunu ve sağkalım olasılığının %100 olduğunu söylemektir. Hastalar öldükçe bu olasılık zamanla azalır. 60 günlük izlemden sağ kalanların oranı %40 civarındadır.KM sağkalım tahminlerinin güven aralığı da varsayılan olarak çizilir ve plot() komutuna conf.int = FALSE seçeneği eklenerek reddedilebilir.İlgilenilen olay “ölüm” olduğu için, sağkalım oranlarının tamamlayıcılarını tanımlayan bir eğri çizmek, kümülatif ölüm oranlarının çizilmesini sağlayacaktır. Bu, mevcut bir çizime bilgi ekleyen lines() ile yapılabilir.","code":"\nplot(linelistsurv_fit, \n     xlab = \"Days of follow-up\",    # x-axis label\n     ylab=\"Survival Probability\",   # y-axis label\n     main= \"Overall survival curve\" # figure title\n     )\n# original plot\nplot(\n  linelistsurv_fit,\n  xlab = \"Days of follow-up\",       \n  ylab = \"Survival Probability\",       \n  mark.time = TRUE,              # mark events on the curve: a \"+\" is printed at every event\n  conf.int = FALSE,              # do not plot the confidence interval\n  main = \"Overall survival curve and cumulative mortality\"\n  )\n\n# draw an additional curve to the previous plot\nlines(\n  linelistsurv_fit,\n  lty = 3,             # use different line type for clarity\n  fun = \"event\",       # draw the cumulative events instead of the survival \n  mark.time = FALSE,\n  conf.int = FALSE\n  )\n\n# add a legend to the plot\nlegend(\n  \"topright\",                               # position of legend\n  legend = c(\"Survival\", \"Cum. Mortality\"), # legend text \n  lty = c(1, 3),                            # line types to use in the legend\n  cex = .85,                                # parametes that defines size of legend text\n  bty = \"n\"                                 # no box type to be drawn for the legend\n  )"},{"path":"sağkalım-analizi.html","id":"sağkalım-eğrilerinin-karşılaştırılması","chapter":"27 Sağkalım Analizi","heading":"27.4 Sağkalım eğrilerinin karşılaştırılması","text":"Gözlemlenen katılımcılarımızın veya hastalarımızın farklı gruplar içindeki sağkalımını karşılaştırmak için, önce ilgili sağkalım eğrilerine bakmamız ve ardından bağımsız gruplar arasındaki farkı değerlendirmek için testler yapmamız gerekebilir. Bu karşılaştırma cinsiyet, yaş, tedavi, komorbidite bazında gruplarla ilgili olabilir…","code":""},{"path":"sağkalım-analizi.html","id":"log-rank-testi","chapter":"27 Sağkalım Analizi","heading":"Log rank testi","text":"Log rank testi, iki veya daha fazla bağımsız grup arasındaki tüm sağkalım deneyimini karşılaştıran popüler bir testtir ve sağkalım eğrilerinin aynı (örtüşen) olup olmadığını gösteren bir test olarak düşünülebilir (gruplar arasında sağkalımda hiçbir farkın olmadığı sıfır hipotezi). Hayatta kalma paketi nin survdiff() işlevi, rho = 0 (varsayılan) belirttiğimizde log rank testinin çalıştırılmasına izin verir. Log rank istatistiği yaklaşık olarak bir ki-kare test istatistiği şeklinde dağıtıldığından, test sonuçları bir p-değeri ile birlikte bir ki-kare değeri verir.İlk önce sağkalım eğrileri cinsiyet grubuna göre karşılaştırılır. Bunun için eğriler önce görselleştirilmeye çalışılır (iki hayatta kalma eğrisinin örtüşüp örtüşmediğini kontrol edilir). Biraz farklı bir formülle yeni bir survfit nesnesi oluşturulup; ardından survdiff nesnesi oluşturulur.Formülün sağ tarafına ~ gender yerleştirilerek, genel sağkalıma göre değil, cinsiyete göre planlama yapılır.Şimdi sağkalım eğrileri cinsiyete göre çizilebilir. Renkler ve açıklamalar tanımlanmadan önce cinsiyet sütunundaki katman düzeylerinin sıra sına bakılır.Şimdi survdiff() kullanılarak sağkalım eğrileri arasındaki fark testi hesaplanabilir.Kadınlar ve erkekler için sağkalım eğrilerinin örtüştüğü ve log-rank testinin kadınlar ve erkekler arasında bir sağkalım farkı olduğuna dair kanıt vermediği görülmektedir.Diğer bazı R paketleri, farklı gruplar için sağkalım eğrilerinin gösterilmesine ve bir defada farkın test edilmesine izin verir. survminer paketindeki ggsurvplot() işlevi kullanılarak, eğriye grup için yazdırılmış risk tabloları ve log-rank testinden elde edilen p değeri de eklenebilir.DİKKAT: survminer işlevleri, sağkalım nesnesini * ve* sağkalım nesnesine sığdırmak için kullanılan verilerin yeniden belirtilmesini gerektirir. Spesifik olmayan hata mesajlarından kaçınmak için bu işlemin yapılması ihmal edilmemelidir. Ayrıca enfeksiyon kaynağına (kontaminasyon kaynağı) göre sağkalım farklılıkları test edilmek istenebilir.Bu durumda, Log rank testi, alfa= 0,005 değerinde sağkalım olasılıkları arasında bir fark olduğuna dair yeterli kanıt sağlar. Cenazelerde enfekte olan hastaların sağkalım olasılıkları, başka yerlerde enfekte olan hastaların sağkalım olasılıklarından daha yüksektir; bu da sağkalım avantajı olduğunu düşündürür.","code":"\n# create the new survfit object based on gender\nlinelistsurv_fit_sex <-  survfit(Surv(futime, event) ~ gender, data = linelist_surv)\n# set colors\ncol_sex <- c(\"lightgreen\", \"darkgreen\")\n\n# create plot\nplot(\n  linelistsurv_fit_sex,\n  col = col_sex,\n  xlab = \"Days of follow-up\",\n  ylab = \"Survival Probability\")\n\n# add legend\nlegend(\n  \"topright\",\n  legend = c(\"Female\",\"Male\"),\n  col = col_sex,\n  lty = 1,\n  cex = .9,\n  bty = \"n\")\n#compute the test of the difference between the survival curves\nsurvival::survdiff(\n  Surv(futime, event) ~ gender, \n  data = linelist_surv\n  )## Call:\n## survival::survdiff(formula = Surv(futime, event) ~ gender, data = linelist_surv)\n## \n## n=4321, 218 observations deleted due to missingness.\n## \n##             N Observed Expected (O-E)^2/E (O-E)^2/V\n## gender=f 2156      924      909     0.255     0.524\n## gender=m 2165      929      944     0.245     0.524\n## \n##  Chisq= 0.5  on 1 degrees of freedom, p= 0.5\nsurvminer::ggsurvplot(\n    linelistsurv_fit_sex, \n    data = linelist_surv,          # again specify the data used to fit linelistsurv_fit_sex \n    conf.int = FALSE,              # do not show confidence interval of KM estimates\n    surv.scale = \"percent\",        # present probabilities in the y axis in %\n    break.time.by = 10,            # present the time axis with an increment of 10 days\n    xlab = \"Follow-up days\",\n    ylab = \"Survival Probability\",\n    pval = T,                      # print p-value of Log-rank test \n    pval.coord = c(40,.91),        # print p-value at these plot coordinates\n    risk.table = T,                # print the risk table at bottom \n    legend.title = \"Gender\",       # legend characteristics\n    legend.labs = c(\"Female\",\"Male\"),\n    font.legend = 10, \n    palette = \"Dark2\",             # specify color palette \n    surv.median.line = \"hv\",       # draw horizontal and vertical lines to the median survivals\n    ggtheme = theme_light()        # simplify plot background\n)\nlinelistsurv_fit_source <-  survfit(\n  Surv(futime, event) ~ source,\n  data = linelist_surv\n  )\n\n# plot\nggsurvplot( \n  linelistsurv_fit_source,\n  data = linelist_surv,\n  size = 1, linetype = \"strata\",   # line types\n  conf.int = T,\n  surv.scale = \"percent\",  \n  break.time.by = 10, \n  xlab = \"Follow-up days\",\n  ylab= \"Survival Probability\",\n  pval = T,\n  pval.coord = c(40,.91),\n  risk.table = T,\n  legend.title = \"Source of \\ninfection\",\n  legend.labs = c(\"Funeral\", \"Other\"),\n  font.legend = 10,\n  palette = c(\"#E7B800\",\"#3E606F\"),\n  surv.median.line = \"hv\", \n  ggtheme = theme_light()\n)"},{"path":"sağkalım-analizi.html","id":"cox-regresyon-analizi","chapter":"27 Sağkalım Analizi","heading":"27.5 Cox regresyon analizi","text":"Cox orantılı hazards regresyonu, sağkalım analizi için en popüler regresyon tekniklerinden biridir. Cox modeli, orantılı hazards varsayımı gibi uygun bir kullanım için doğrulanması gereken önemli varsayımlar gerektirdiğinden başka modeller de kullanılabilir (kaynaklara bakın).Cox orantılı hazards regresyon modelinde, etkinin ölçüsü, katılımcının belirli bir süreye kadar yaşadığı göz önüne alındığında, başarısızlık riski (veya örneğimizde ölüm riski) olan hazard rate (HR)’dir. Genellikle, bağımsız grupları risklerine göre karşılaştırmakla ilgileniriz ve çoklu lojistik regresyon analizi ortamındaki bir olasılık oranına benzer bir tehlike oranı (HR) kullanırız. survival paketindeki cox.ph() işlevi modele uyması için kullanılır. survival paketindeki cox.zph() işlevi ise bir Cox regresyon modeli uyumu için orantılı hazards varsayımını test etmek için kullanılabilir.: Bir olasılık 0 ile 1 aralığında olmalıdır. Ancak hazard (tehlike/risk), bir zaman birimi başına beklenen olay sayısını temsil eder.Bir prediktör için tehlike oranı 1’e yakınsa, o prediktör sağkalımı etkilemez,HR 1’den küçükse, prediktör koruyucudur (yani, iyileştirilmiş sağkalım ile ilişkilidir),ve HR 1’den büyükse, prediktör risk artışı (veya azalmış sağkalım) ile ilişkilidir.","code":""},{"path":"sağkalım-analizi.html","id":"cox-modelini-uyarlama","chapter":"27 Sağkalım Analizi","heading":"Cox modelini uyarlama","text":"İlk olarak yaş ve cinsiyetin sağkalım üzerindeki etkilerini değerlendirmek için bir model uyarlanabilir. Sadece modeli yazdırarak elde edilen bilgiler:prediktörler ile sonuç arasındaki ilişkiyi ölçen tahmini regresyon katsayıları coef,hazard oranı nı üreten üstelleri (yorumlanabilirlik için exp(coef)),onların standart hatası se(coef),z-skoru: 0’dan uzakta tahmin edilen katsayının standart hata miktarı,ve p değeri: Tahmini katsayının 0 olma olasılığı.Cox model nesnesine uygulanan summary() işlevi, tahmini HR’nin güven aralığı ve farklı test puanları gibi daha fazla bilgi verir.İlk ortak değişken gender etkisi ilk satırda sunulmaktadır. genderm (erkek) yazdırılır, bu da ilk katman seviyesinin (“f”), yani kadın grubunun cinsiyet için referans grubu olduğunu gösterir. Bu nedenle, test parametresinin yorumu, kadınlara kıyasla erkeklerinkiyle aynıdır. p değeri, cinsiyetin beklenen tehlike üzerindeki etkisine veya cinsiyet ile tüm nedenlere bağlı ölüm arasındaki ilişkiye dair yeterli kanıt olmadığını gösterir.Aynı kanıt eksikliği, yaş grubuyla ilgili olarak da belirtilmiştir.Modeli çalıştırmak ve sonuçlara bakmak ilginç olsa da, orantılı hazards varsayımlarına uyulup uyulmadığını doğrulamak için göz atmak zamandan tasarruf etmenize yardımcı olabilir..: Cox modeli hesaplanırken, bağların nasıl ele alınacağını belirleyen yöntem adlı ikinci bir argüman belirtilebilir. varsayılan “efron” dur ve diğer seçenekler “breslow” ve “exact” dır.Başka bir modelde, enfeksiyonun kaynağı ve başlangıç tarihi ile kabul arasındaki gün sayısı gibi daha fazla risk faktörü eklenir. Bu sefer, ilerlemeden önce orantılı hazards varsayımını doğrularız.Bu modele sürekli bir prediktör (days_onset_hosp) eklendi. Bu durumda, parametre tahminlerini, diğer prediktörleri sabit tutarak, prediktördeki bir birimlik artış için nispi tehlikenin beklenen logundaki artış olarak yorumlanır. İlk önce orantılı hazards varsayımı doğrulanır.Bu varsayımın grafiksel doğrulaması, survminer paketindeki ggcoxzph() fonksiyonu ile gerçekleştirilebilir.Model sonuçları, başlangıçtan hastaneye başvurana kadar olan süre ile tüm nedenlere bağlı mortalite arasında negatif bir ilişki olduğunu göstermektedir. Cinsiyet sabit tutulduğunda, bir gün sonra hastaneye başvuran bir kişide beklenen risk, diğerinden 0,9 kat daha düşüktür. Ya da daha açık bir anlatımla, hastaneye başvuruya başlama süresindeki bir birimlik artış, ölüm riskinde %10,7’lik (coef *100) bir azalma ile ilişkilidir.Ayrıca sonuçlar enfeksiyon kaynağı ile tüm nedenlere bağlı ölümler arasında pozitif bir ilişki olduğunu göstermektedir. Yani cenaze dışında bir enfeksiyon kaynağı olan hastalarda ölüm riski (1.21x) artmaktadır.Bu ilişki bir tablo ile doğrulanabilir:Bu ilişkinin verilerde neden var olduğunun düşünülmesi ve araştırılması gerekir. Olası bir açıklama, daha sonra kabul edilecek kadar uzun yaşayan hastaların başlangıçta daha az şiddetli hastalığa sahip olmaları olabilir. Belki de daha olası bir başka açıklama, simüle edilmiş sahte bir veri seti kullanıldığı için bu modelin gerçeği yansıtmamasıdır!","code":"\n#fitting the cox model\nlinelistsurv_cox_sexage <-  survival::coxph(\n              Surv(futime, event) ~ gender + age_cat_small, \n              data = linelist_surv\n              )\n\n\n#printing the model fitted\nlinelistsurv_cox_sexage## Call:\n## survival::coxph(formula = Surv(futime, event) ~ gender + age_cat_small, \n##     data = linelist_surv)\n## \n##                       coef exp(coef) se(coef)      z     p\n## genderm           -0.03149   0.96900  0.04767 -0.661 0.509\n## age_cat_small5-19  0.09400   1.09856  0.06454  1.456 0.145\n## age_cat_small20+   0.05032   1.05161  0.06953  0.724 0.469\n## \n## Likelihood ratio test=2.8  on 3 df, p=0.4243\n## n= 4321, number of events= 1853 \n##    (218 observations deleted due to missingness)\n#summary of the model\nsummary(linelistsurv_cox_sexage)## Call:\n## survival::coxph(formula = Surv(futime, event) ~ gender + age_cat_small, \n##     data = linelist_surv)\n## \n##   n= 4321, number of events= 1853 \n##    (218 observations deleted due to missingness)\n## \n##                       coef exp(coef) se(coef)      z Pr(>|z|)\n## genderm           -0.03149   0.96900  0.04767 -0.661    0.509\n## age_cat_small5-19  0.09400   1.09856  0.06454  1.456    0.145\n## age_cat_small20+   0.05032   1.05161  0.06953  0.724    0.469\n## \n##                   exp(coef) exp(-coef) lower .95 upper .95\n## genderm               0.969     1.0320    0.8826     1.064\n## age_cat_small5-19     1.099     0.9103    0.9680     1.247\n## age_cat_small20+      1.052     0.9509    0.9176     1.205\n## \n## Concordance= 0.514  (se = 0.007 )\n## Likelihood ratio test= 2.8  on 3 df,   p=0.4\n## Wald test            = 2.78  on 3 df,   p=0.4\n## Score (logrank) test = 2.78  on 3 df,   p=0.4\ntest_ph_sexage <- survival::cox.zph(linelistsurv_cox_sexage)\ntest_ph_sexage##               chisq df    p\n## gender        0.454  1 0.50\n## age_cat_small 0.838  2 0.66\n## GLOBAL        1.399  3 0.71\n#fit the model\nlinelistsurv_cox <-  coxph(\n                        Surv(futime, event) ~ gender + age_years+ source + days_onset_hosp,\n                        data = linelist_surv\n                        )\n\n\n#test the proportional hazard model\nlinelistsurv_ph_test <- cox.zph(linelistsurv_cox)\nlinelistsurv_ph_test##                    chisq df       p\n## gender           0.45062  1    0.50\n## age_years        0.00199  1    0.96\n## source           1.79622  1    0.18\n## days_onset_hosp 31.66167  1 1.8e-08\n## GLOBAL          34.08502  4 7.2e-07\nsurvminer::ggcoxzph(linelistsurv_ph_test)\n#print the summary of the model\nsummary(linelistsurv_cox)## Call:\n## coxph(formula = Surv(futime, event) ~ gender + age_years + source + \n##     days_onset_hosp, data = linelist_surv)\n## \n##   n= 2772, number of events= 1180 \n##    (1767 observations deleted due to missingness)\n## \n##                      coef exp(coef)  se(coef)      z Pr(>|z|)    \n## genderm          0.004710  1.004721  0.060827  0.077   0.9383    \n## age_years       -0.002249  0.997753  0.002421 -0.929   0.3528    \n## sourceother      0.178393  1.195295  0.084291  2.116   0.0343 *  \n## days_onset_hosp -0.104063  0.901169  0.014245 -7.305 2.77e-13 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n##                 exp(coef) exp(-coef) lower .95 upper .95\n## genderm            1.0047     0.9953    0.8918    1.1319\n## age_years          0.9978     1.0023    0.9930    1.0025\n## sourceother        1.1953     0.8366    1.0133    1.4100\n## days_onset_hosp    0.9012     1.1097    0.8764    0.9267\n## \n## Concordance= 0.566  (se = 0.009 )\n## Likelihood ratio test= 71.31  on 4 df,   p=1e-14\n## Wald test            = 59.22  on 4 df,   p=4e-12\n## Score (logrank) test = 59.54  on 4 df,   p=4e-12\nlinelist_case_data %>% \n  tabyl(days_onset_hosp, outcome) %>% \n  adorn_percentages() %>%  \n  adorn_pct_formatting()##  days_onset_hosp Death Recover   NA_\n##                0 44.3%   31.4% 24.3%\n##                1 46.6%   32.2% 21.2%\n##                2 43.0%   32.8% 24.2%\n##                3 45.0%   32.3% 22.7%\n##                4 41.5%   38.3% 20.2%\n##                5 40.0%   36.2% 23.8%\n##                6 32.2%   48.7% 19.1%\n##                7 31.8%   38.6% 29.5%\n##                8 29.8%   38.6% 31.6%\n##                9 30.3%   51.5% 18.2%\n##               10 16.7%   58.3% 25.0%\n##               11 36.4%   45.5% 18.2%\n##               12 18.8%   62.5% 18.8%\n##               13 10.0%   60.0% 30.0%\n##               14 10.0%   50.0% 40.0%\n##               15 28.6%   42.9% 28.6%\n##               16 20.0%   80.0%  0.0%\n##               17  0.0%  100.0%  0.0%\n##               18  0.0%  100.0%  0.0%\n##               22  0.0%  100.0%  0.0%\n##               NA 52.7%   31.2% 16.0%"},{"path":"sağkalım-analizi.html","id":"forest-grafikleri","chapter":"27 Sağkalım Analizi","heading":"Forest grafikleri","text":"Daha sonra, survminer paketi nin ggforest() işleviyle pratik forest grafikleri kullanılarak cox modelinin sonuçları görselleştirilebilir..","code":"\nggforest(linelistsurv_cox, data = linelist_surv)"},{"path":"sağkalım-analizi.html","id":"sağkalım-modellerinde-zamana-bağlı-değişkenler","chapter":"27 Sağkalım Analizi","heading":"27.6 Sağkalım modellerinde zamana bağlı değişkenler","text":"Aşağıdaki bölümlerden bazıları, faydalı bir kaynaktan izin alınarak uyarlanmıştır introduction survival analysis R Dr. Emily ZaborSon bölümde, ilgilenilen ortak değişkenler ve sağkalım sonuçları arasındaki ilişkileri incelemek için Cox regresyonunu kullanma ele alındı. Ancak bu analizler, başlangıçta, yani olayın takip süresi başlamadan önce ölçülen ortak değişkene dayanır.Takip süresi başladıktan sonra ölçülen bir ortak değişkenle ilgileniyorsanız ne olur? Ya da zamanla değişebilen bir ortak değişkeniniz varsa?Örneğin, zaman içinde değişebilen hastane laboratuvar değerleri ölçümlerini tekrarladığınız klinik verilerle çalışıyor olabilirsiniz. Bu, bir Zaman Bağımlı Ortak Değişken örneğidir. Bunu ele almak için özel bir kuruluma ihtiyacınız var, ancak neyse ki cox modeli çok esnektir ve bu tür veriler sağkalım paketindeki araçlarla da modellenebilir.","code":""},{"path":"sağkalım-analizi.html","id":"zaman-bağımlı-ortak-değişken-kurulumu","chapter":"27 Sağkalım Analizi","heading":"Zaman bağımlı ortak değişken kurulumu","text":"R’daki zaman bağımlı ortak değişkenlerin analizi, özel bir veri setinin kurulmasını gerektirir. İlgileniyorsanız, sağkalım paketi yazarının bu konu hakkındaki daha ayrıntılı makalesine bakılabilir Cox Modelinde Zamana Bağlı Ortak Değişkenleri ve Zamana Bağlı Katsayıları Kullanma.Bunun için, 137 kemik iliği nakli hastasının verilerini içeren BMT adlı SemiCompRisks paketinden yeni bir veri seti kullanılabilir. Odaklanılacak değişkenler şunlardır:T1 - ölüme veya son takibe kadar geçen süre (gün olarak)delta1 - ölüm göstergesi; 1-Ölü, 0-CanlıTA - akut graft-versus-host hastalığına kadar geçen süre (gün olarak)deltaA - akut graft-versus-host hastalığı göstergesi;\n1 - Gelişmiş akut graft-versus-host hastalığı\n0 - Hiçbir zaman akut graft-versus-host hastalığı geliştirmedi.\n1 - Gelişmiş akut graft-versus-host hastalığı0 - Hiçbir zaman akut graft-versus-host hastalığı geliştirmedi.Bu veri seti sağkalım paketinden temel R komutu data() kullanarak yüklenir; bu, zaten yüklü olan bir R paketine dahil olan verileri yüklemek için kullanılabilir. BMT veri çerçevesi R ortamında görünecektir.","code":"\ndata(BMT, package = \"SemiCompRisks\")"},{"path":"sağkalım-analizi.html","id":"özgün-hasta-tanımlayıcısı-ekleme","chapter":"27 Sağkalım Analizi","heading":"Özgün hasta tanımlayıcısı ekleme","text":"BMT verilerinde, istenilen veri seti çeşidini oluşturmak için gerekli olan özgün bir ID sütunu yoktur. Bu nedenle, tidyverse paketinden tibble rowid_to_column() işlevini my_id adlı yeni bir ID sütunu oluşturmak için kullanılır (1’den başlayarak sıralı satır kimlikleriyle veri çerçevesinin başına sütun ekler) . Veri çerçevesi bmt olarak adlandırılır.Veri seti şimdi şöyle görünür:","code":"\nbmt <- rowid_to_column(BMT, \"my_id\")"},{"path":"sağkalım-analizi.html","id":"hasta-dizilerini-genişletme","chapter":"27 Sağkalım Analizi","heading":"Hasta dizilerini genişletme","text":"Daha sonra, yeniden yapılandırılmış veri setini oluşturmak için event() ve tdc() yardımcı işlevleriyle tmerge() işlevi kullanılır. Amaç; hasta için, farklı bir deltaA değerine sahip oldukları zaman aralığı için ayrı bir satır oluşturmak üzere veri setini yeniden yapılandırmaktır. Bu durumda, veri toplama döneminde akut graft-versus-host hastalığı geliştirip geliştirmediğine bağlı olarak hasta en fazla iki sıraya sahip olabilir. Akut graft-versus-host hastalığı gelişimi için yeni göstergeye agvhd adı verilir.tmerge(), hasta için tanımlanan farklı ortak değişken değerler için birden fazla zaman aralığı içeren uzun bir veri seti oluştururevent(), yeni oluşturulan zaman aralıklarıyla uyumlu olacak yeni olay göstergesini yaratırtdc() , yeni oluşturulan zaman aralıklarına uygun olarak zamana bağlı ortak değişken sütunu agvhd yi oluştururBunun ne işe yaradığını görmek için ilk 5 özgün hastaya ait verilere bakıldığında orijinal verilerdeki ilgili değişkenler bu şekilde görünür:Aynı hastalar için yeni veri seti şuna benzer:Şimdi bazı hastalarımızın veri setinde yeni değişkenimiz agvhd için farklı bir değere sahip oldukları aralıklara karşılık gelen iki satırı var. Örneğin, Hasta 1 artık 0 zamanından 67. zamana kadar sıfır agvhd değerine ve 67’den 2081’e kadar 1 değerine sahip iki satıra sahiptir.","code":"\ntd_dat <- \n  tmerge(\n    data1 = bmt %>% select(my_id, T1, delta1), \n    data2 = bmt %>% select(my_id, T1, delta1, TA, deltaA), \n    id = my_id, \n    death = event(T1, delta1),\n    agvhd = tdc(TA)\n    )\nbmt %>% \n  select(my_id, T1, delta1, TA, deltaA) %>% \n  filter(my_id %in% seq(1, 5))##   my_id   T1 delta1   TA deltaA\n## 1     1 2081      0   67      1\n## 2     2 1602      0 1602      0\n## 3     3 1496      0 1496      0\n## 4     4 1462      0   70      1\n## 5     5 1433      0 1433      0\ntd_dat %>% \n  filter(my_id %in% seq(1, 5))##   my_id   T1 delta1 tstart tstop death agvhd\n## 1     1 2081      0      0    67     0     0\n## 2     1 2081      0     67  2081     0     1\n## 3     2 1602      0      0  1602     0     0\n## 4     3 1496      0      0  1496     0     0\n## 5     4 1462      0      0    70     0     0\n## 6     4 1462      0     70  1462     0     1\n## 7     5 1433      0      0  1433     0     0"},{"path":"sağkalım-analizi.html","id":"zamana-bağlı-ortak-değişkenlerle-cox-regresyonu","chapter":"27 Sağkalım Analizi","heading":"Zamana bağlı ortak değişkenlerle cox regresyonu","text":"Veriler yeniden şekillendirildiğine ve yeni zamana bağlı aghvd değişkeni eklediğine göre, şimdi basit tek değişkenli bir cox regresyon modeli uygulanabilir. Daha önce olduğu gibi aynı coxph() işlevi kullanılabilir; time1 = ve time2 = bağımsız değişkenlerini kullanarak bir aralık için hem başlangıç hem de bitiş zamanını belirtmek için Surv() işlevini değiştirmek yeterlidir.Yine, survminer paketi ’nden ggforest() işlevi kullanılarak cox model sonuçları görselleştirilebilir.:Forest grafiğinden, güven aralığından ve p-değerinden görülebildiği üzere, basit modelimiz bağlamında ölüm ile akut graft-versus-host hastalığı arasında güçlü bir ilişki yok gibi görünmektedir.","code":"\nbmt_td_model = coxph(\n  Surv(time = tstart, time2 = tstop, event = death) ~ agvhd, \n  data = td_dat\n  )\n\nsummary(bmt_td_model)## Call:\n## coxph(formula = Surv(time = tstart, time2 = tstop, event = death) ~ \n##     agvhd, data = td_dat)\n## \n##   n= 163, number of events= 80 \n## \n##         coef exp(coef) se(coef)    z Pr(>|z|)\n## agvhd 0.3351    1.3980   0.2815 1.19    0.234\n## \n##       exp(coef) exp(-coef) lower .95 upper .95\n## agvhd     1.398     0.7153    0.8052     2.427\n## \n## Concordance= 0.535  (se = 0.024 )\n## Likelihood ratio test= 1.33  on 1 df,   p=0.2\n## Wald test            = 1.42  on 1 df,   p=0.2\n## Score (logrank) test = 1.43  on 1 df,   p=0.2\nggforest(bmt_td_model, data = td_dat)"},{"path":"sağkalım-analizi.html","id":"kaynaklar-20","chapter":"27 Sağkalım Analizi","heading":"27.7 Kaynaklar","text":"Sağkalım Analizi Bölüm : Temel kavramlar ve ilk analizlerR’da Sağkalım AnaliziBulaşıcı hastalık araştırmalarında sağkalım analizi: Olayları zaman içinde tanımlamaGelişmiş sağkalım modelleri Princeton ile ilgili bölümCox Modelinde Zamana Bağlı Ortak Değişkenleri ve Zamana Bağlı Katsayıları KullanmaR kopya kağıdında sağkalım analiziSurvminer kopya kağıdıEk materyal olarak sağlanan R Kodu ile kanser kayıt verileri için farklı sağkalım ölçüleri hakkında bir sayfa","code":""},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"coğrafi-bilgi-sistemleri-cbs-temelleri","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","text":"","code":""},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"genel-bakış-6","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"28.1 Genel Bakış","text":"Verilerinizin uzamsal yönleri, salgının durumuna ilişkin pek çok içgörü sağlayabilir ve aşağıdaki gibi soruları yanıtlayabilir:Mevcut hastalık noktaları nerede?Kümelenme noktaları zaman içinde nasıl değişti?Sağlık tesislerine ulaşım nasıl? Herhangi bir iyileştirme gerekli mi?Bu CBS sayfasının mevcut odak noktası, salgın yanıtında uygulamalı epidemiyologların ihtiyaçlarını ele almaktır. tmap ve ggplot2 paketlerini kullanarak temel mekansal veri görselleştirme yöntemlerini keşfedeceğiz. Ayrıca sf paketi ile bazı temel uzamsal veri yönetimi ve sorgulama yöntemlerini de inceleyeceğiz. Son olarak, spdep paketini kullanarak uzamsal ilişkiler, uzamsal otokorelasyon ve uzamsal regresyon gibi mekansal istatistik kavramlarına kısaca değineceğiz.","code":""},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"anahtar-terimler","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"28.2 Anahtar terimler","text":"Aşağıda bazı temel terminolojiyi tanıtıyoruz. CBS ve mekansal analize kapsamlı bir giriş için, Referanslar bölümünde listelenen daha uzun öğreticilerden veya kurslardan birini incelemenizi öneririz.Coğrafi Bilgi Sistemi (CBS) - CBS, mekansal verileri toplamak, yönetmek, analiz etmek ve görselleştirmek için bir çerçeve veya ortamdır.","code":""},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"cbs-yazılımı","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"CBS yazılımı","text":"Bazı popüler CBS yazılımları, harita geliştirme ve mekansal analiz için işaretle ve tıkla etkileşimine izin verir. Bu araçlar, kod öğrenmeye gerek olmaması ve simgeleri ve özellikleri bir haritaya manuel olarak seçme ve yerleştirme kolaylığı gibi avantajlarla birlikte gelir. İşte iki popüler olan:ArcGIS - ESRI şirketi tarafından geliştirilen, çok popüler ancak oldukça pahalı olan ticari bir CBS yazılımıQGIS - ArcGIS’yapabileceği hemen hemen şeyi yapabilen ücretsiz bir açık kaynaklı CBS yazılımı. QGIS’buradan indirebilirsinizR’ı bir CBS olarak kullanmak, “işaretle ve tıkla” yerine bir “komut satırı arayüzüne” sahip olduğundan (istenen sonucu elde etmek için kodlamanız gerekir) ilk başta daha korkutucu görünebilir. Ancak, tekrar tekrar haritalar üretmeniz veya tekrarlanabilir bir analiz oluşturmanız gerekiyorsa bu büyük bir avantajdır.","code":""},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"mekansal-veri","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"Mekansal veri","text":"CBS’de kullanılan iki temel konumsal veri biçimi vektör ve hücresel(raster) veridir:Vektör Verileri - CBS’de kullanılan en yaygın konumsal veri biçimi olan vektör verileri, köşelerin ve yolların geometrik özelliklerinden oluşur. Vektör uzamsal verileri ayrıca yaygın olarak kullanılan üç türe ayrılabilir:Noktalar - Bir nokta, bir koordinat sistemindeki belirli bir konumu temsil eden bir koordinat çiftinden (x,y) oluşur. Noktalar, uzamsal verilerin en temel biçimidir ve bir durumu (yani hasta evi) veya bir konumu (yani hastaneyi) bir harita üzerinde belirtmek için kullanılabilir.Noktalar - Bir nokta, bir koordinat sistemindeki belirli bir konumu temsil eden bir koordinat çiftinden (x,y) oluşur. Noktalar, uzamsal verilerin en temel biçimidir ve bir durumu (yani hasta evi) veya bir konumu (yani hastaneyi) bir harita üzerinde belirtmek için kullanılabilir.Çizgiler - Çizgi, birbirine bağlı iki noktadan oluşur. Çizgilerin bir uzunluğu vardır ve yollar veya nehirler gibi şeyleri belirtmek için kullanılabilir.Çizgiler - Çizgi, birbirine bağlı iki noktadan oluşur. Çizgilerin bir uzunluğu vardır ve yollar veya nehirler gibi şeyleri belirtmek için kullanılabilir.Çokgenler - Çokgen, noktalarla birbirine bağlanan en az üç doğru parçasından oluşur. Çokgen özellikleri bir uzunluğa (yani alanın çevresi) ve ayrıca bir alan ölçümüne sahiptir. Çokgenler bir alanı (yani bir köyü) veya bir yapıyı (yani bir hastanenin gerçek alanını) belirtmek için kullanılabilir.Çokgenler - Çokgen, noktalarla birbirine bağlanan en az üç doğru parçasından oluşur. Çokgen özellikleri bir uzunluğa (yani alanın çevresi) ve ayrıca bir alan ölçümüne sahiptir. Çokgenler bir alanı (yani bir köyü) veya bir yapıyı (yani bir hastanenin gerçek alanını) belirtmek için kullanılabilir.Hücresel Veri - Uzamsal veriler için alternatif bir format olan hücresel veriler, hücrenin yükseklik, sıcaklık, eğim, orman örtüsü vb. gibi bilgileri içeren bir hücre matrisidir (örneğin pikseller). Bunlar genellikle hava fotoğrafları, uydu görüntüler, vb. Rasterler (yani hücresel haritalar), vektör verilerinin altında “temel haritalar” olarak da kullanılabilir.","code":""},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"uzamsal-verileri-görselleştirme","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"Uzamsal verileri görselleştirme","text":"Bir harita üzerinde uzamsal verileri görsel olarak temsil etmek için, CBS yazılımı, farklı özelliklerin birbiriyle ilişkili olarak nerede olması gerektiği hakkında yeterli bilgi sağlamanızı gerektirir. Çoğu kullanım durumu için geçerli olan vektör verilerini kullanıyorsanız, bu bilgiler genellikle bir şekil dosyasında depolanır:Shapefiles - Shapefile, çizgilerden, noktalardan veya çokgenlerden oluşan “vektör” uzamsal verileri depolamak için yaygın bir veri biçimidir. Tek bir şekil dosyası aslında en az üç dosyadan oluşan bir koleksiyondur - .shp, .shx ve .dbf. Şekil dosyasının okunabilmesi için tüm bu alt bileşen dosyalarının belirli bir dizinde (klasörde) bulunması gerekir. Bu ilişkili dosyalar, e-posta yoluyla gönderilmek veya bir web sitesinden indirilmek üzere bir ZIP klasörüne sıkıştırılabilir.Şekil dosyası, özelliklerin kendileri ve bunların Dünya yüzeyinde nereye yerleştirileceği hakkında bilgi içerecektir. Bu önemlidir, çünkü Dünya bir küre iken, haritalar tipik olarak iki boyutludur; uzamsal verilerin nasıl “düzleştirileceğine” ilişkin seçimler, ortaya çıkan haritanın görünümü ve yorumlanması üzerinde büyük bir etkiye sahip olabilir.Koordinat Referans Sistemleri (CRS) - CRS, Dünya yüzeyindeki coğrafi özellikleri konumlandırmak için kullanılan koordinat tabanlı bir sistemdir. Birkaç temel bileşeni vardır:Koordinat Sistemi - Birçok farklı koordinat sistemi vardır, bu nedenle koordinatlarınızın hangi sistemden olduğunu bildiğinizden emin olun. Enlem/boylam dereceleri yaygındır, ancak UTM koordinatlarını da görebilirsiniz.Koordinat Sistemi - Birçok farklı koordinat sistemi vardır, bu nedenle koordinatlarınızın hangi sistemden olduğunu bildiğinizden emin olun. Enlem/boylam dereceleri yaygındır, ancak UTM koordinatlarını da görebilirsiniz.Birimler - Koordinat sisteminiz için birimlerin ne olduğunu öğrenin (ör. ondalık dereceler, metreler)Birimler - Koordinat sisteminiz için birimlerin ne olduğunu öğrenin (ör. ondalık dereceler, metreler)Datum - Dünya’nın belirli bir modellenmiş versiyonu. Bunlar yıllar içinde revize edilmiştir, bu nedenle harita katmanlarınızın aynı veriyi kullandığından emin olun. Özellikle herhangi bir konum verisi elde edilirken yatay ve düşey konumunu tanımlamak için başlangıç alınan bir referans yüzeyi gereklidir. Yer’şeklini ve boyutunu tanımlayan bu yüzeye Datum adı verilmektedir.Datum - Dünya’nın belirli bir modellenmiş versiyonu. Bunlar yıllar içinde revize edilmiştir, bu nedenle harita katmanlarınızın aynı veriyi kullandığından emin olun. Özellikle herhangi bir konum verisi elde edilirken yatay ve düşey konumunu tanımlamak için başlangıç alınan bir referans yüzeyi gereklidir. Yer’şeklini ve boyutunu tanımlayan bu yüzeye Datum adı verilmektedir.Projeksiyon - Gerçekten yuvarlak olan dünyayı düz bir yüzeye (harita) yansıtmak için kullanılan matematiksel denklem.Projeksiyon - Gerçekten yuvarlak olan dünyayı düz bir yüzeye (harita) yansıtmak için kullanılan matematiksel denklem.Aşağıda gösterilen haritalama araçlarını kullanmadan uzamsal verileri özetleyebileceğinizi unutmayın. Bazen coğrafyaya göre (ör. ilçe, ülke vb.) basit bir tablo yeterlidir!","code":""},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"cbsyi-kullanmaya-başlama","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"28.3 CBS’yi kullanmaya başlama","text":"Bir harita yapmak için sahip olmanız ve düşünmeniz gereken birkaç önemli öğe var. Bunlar şunları içerir:Bir veri kümesi – bu, uzamsal bir veri biçiminde olabilir (yukarıda belirtildiği gibi şekil dosyaları gibi) veya uzamsal bir biçimde olmayabilir (örneğin sadece bir csv olarak).Bir veri kümesi – bu, uzamsal bir veri biçiminde olabilir (yukarıda belirtildiği gibi şekil dosyaları gibi) veya uzamsal bir biçimde olmayabilir (örneğin sadece bir csv olarak).Veri kümeniz uzamsal biçimde değilse ayrıca bir referans veri kümesine ihtiyacınız olacaktır. Referans verileri, verilerin uzamsal temsilinden ve belirli özelliklerin konum ve adres bilgilerini içeren materyali içeren ilgili niteliklerden oluşur.\nÖnceden tanımlanmış coğrafi sınırlarla (örneğin, idari bölgeler) çalışıyorsanız, referans şekil dosyaları genellikle bir devlet kurumundan veya veri paylaşım kuruluşundan ücretsiz olarak indirilebilir. Şüpheye düştüğünüzde, Google “[bölgeler] şekil dosyası” başlamak için iyi bir yerdir.\nAdres bilginiz varsa ancak enlem ve boylam yoksa, kayıtlarınız için uzamsal referans verilerini almak için bir coğrafi kodlama motoru kullanmanız gerekebilir.\nVeri kümeniz uzamsal biçimde değilse ayrıca bir referans veri kümesine ihtiyacınız olacaktır. Referans verileri, verilerin uzamsal temsilinden ve belirli özelliklerin konum ve adres bilgilerini içeren materyali içeren ilgili niteliklerden oluşur.Önceden tanımlanmış coğrafi sınırlarla (örneğin, idari bölgeler) çalışıyorsanız, referans şekil dosyaları genellikle bir devlet kurumundan veya veri paylaşım kuruluşundan ücretsiz olarak indirilebilir. Şüpheye düştüğünüzde, Google “[bölgeler] şekil dosyası” başlamak için iyi bir yerdir.Önceden tanımlanmış coğrafi sınırlarla (örneğin, idari bölgeler) çalışıyorsanız, referans şekil dosyaları genellikle bir devlet kurumundan veya veri paylaşım kuruluşundan ücretsiz olarak indirilebilir. Şüpheye düştüğünüzde, Google “[bölgeler] şekil dosyası” başlamak için iyi bir yerdir.Adres bilginiz varsa ancak enlem ve boylam yoksa, kayıtlarınız için uzamsal referans verilerini almak için bir coğrafi kodlama motoru kullanmanız gerekebilir.Adres bilginiz varsa ancak enlem ve boylam yoksa, kayıtlarınız için uzamsal referans verilerini almak için bir coğrafi kodlama motoru kullanmanız gerekebilir.Veri kümelerinizdeki bilgileri hedef kitlenize nasıl sunmak istediğiniz hakkında fikriniz olmalı. Birçok farklı harita türü vardır ve ihtiyaçlarınıza en uygun harita türünü düşünmek önemlidir.Veri kümelerinizdeki bilgileri hedef kitlenize nasıl sunmak istediğiniz hakkında fikriniz olmalı. Birçok farklı harita türü vardır ve ihtiyaçlarınıza en uygun harita türünü düşünmek önemlidir.","code":""},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"verilerinizi-görselleştirmek-için-harita-türleri","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"Verilerinizi görselleştirmek için harita türleri","text":"Choropleth haritası - coğrafi bölgeleri bir öznitelik değerine göre temsil etmek için renklerin, gölgelerin veya desenlerin kullanıldığı bir tür tematik haritadır. Örneğin, daha büyük bir değer, daha küçük bir değerden daha koyu bir renkle gösterilebilir. Bu harita türü, bir değişkeni ve onun tanımlanmış bölgeler veya jeopolitik alanlar arasında nasıl değiştiğini görselleştirirken özellikle kullanışlıdır.Vaka yoğunluğu ısı haritası - renklerin bir değerin yoğunluğunu temsil etmek için kullanıldığı, ancak verileri gruplamak için tanımlanmış bölgeleri veya jeopolitik sınırları kullanmadığı bir tür tematik haritadır. Bu harita türü tipik olarak “sıcak noktaları” veya yüksek yoğunluklu veya nokta yoğunluğuna sahip alanları göstermek için kullanılır.Nokta yoğunluğu haritası - verilerinizdeki öznitelik değerlerini temsil etmek için noktaları kullanan tematik bir harita türüdür. Bu tür harita en iyi, verilerinizin dağılımını görselleştirmek ve kümeleri görsel olarak taramak için kullanılır.Oransal semboller haritası (dereceli semboller haritası) - bir choropleth haritasına benzer bir tematik harita, ancak bir özelliğin değerini belirtmek için renk kullanmak yerine, değere göre bir sembol (genellikle bir daire) kullanır. Örneğin, daha büyük bir değer, daha küçük bir değerden daha büyük bir sembolle gösterilebilir. Bu harita türü en iyi, coğrafi bölgelerdeki verilerinizin boyutunu veya miktarını görselleştirmek istediğinizde kullanılır.Karmaşık coğrafi kalıpları göstermek için birkaç farklı görselleştirme türünü de birleştirebilirsiniz. Örneğin aşağıdaki haritadaki vakalar (noktalar) en yakın sağlık kuruluşuna göre renklendirilmiştir (bkz. lejand). Büyük kırmızı daireler, belirli bir yarıçaptaki sağlık tesisi hizmet alanlarını ve herhangi bir hizmet alanı dışında kalan parlak kırmızı vaka noktalarını gösterir:: Bu CBS sayfasının birincil odak noktası, saha salgın yanıtı bağlamına dayanmaktadır. Bu nedenle sayfanın içeriği, temel uzamsal veri manipülasyonlarını, görselleştirmeleri ve analizleri kapsayacaktır.","code":""},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"hazırlık-19","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"28.4 Hazırlık","text":"","code":""},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"paketleri-yükleyin-6","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"Paketleri yükleyin","text":"Bu kod parçası, analizler için gereken paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() vurgusunu yapıyoruz. R tabanından library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakabilirsiniz.CRAN “Uzamsal Görev Görünümü”nde uzamsal verilerle ilgilenen tüm R paketlerinin bir özetini görebilirsiniz.","code":"\npacman::p_load(\n  rio,           # verileri içe aktarmak için\n  here,          # dosyaları bulmak için\n  tidyverse,     # verileri temizlemek, işlemek ve çizmek için (ggplot2 paketini içerir)\n  sf,            # Basit Özellik formatı kullanarak uzamsal verileri yönetmek için\n  tmap,          # basit haritalar üretmek için hem etkileşimli hem de statik haritalar için çalışır\n  janitor,       # sütun adlarını temizlemek için\n  OpenStreetMap, # ggplot haritasına OSM altlık haritası eklemek için\n  spdep          # mekansal istatistik\n  ) "},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"örnek-vaka-verileri","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"Örnek vaka verileri","text":"Gösteri amacıyla, simüle edilmiş Ebola salgını “satır listesi” veri çerçevesinden rastgele 1000 vakalık bir örneklemle çalışacağız (hesaplamalı olarak, daha az vakayla çalışmak bu el kitabında daha kolaydır). Takip etmek isterseniz, “clean” dosyasını indirmek için tıklayın. (.rds dosyası olarak).Vakaların rastgele bir örneğini aldığımız için, kodları kendi başınıza çalıştırdığınızda sonuçlarınız burada gösterilenden biraz farklı görünebilir.rio paketinden import() fonksiyonuyla verileri içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe aktarma ve dışa aktarma] sayfasına bakın).Daha sonra R tabanından sample() kullanarak 1000 satırlık rastgele bir örnek seçiyoruz.Şimdi sınıf veri çerçevesi olan bu ’linelist’“sf” (uzaysal özellikler) sınıfının bir nesnesine dönüştürmek istiyoruz. Satır listesinin, vakanın ikametgahının enlem ve boylamını temsil eden iki sütun “boy” ve “en” olduğu göz önüne alındığında, bu kolay olacaktır.sf (uzaysal özellikler) paketini ve onun ‘st_as_sf()’ fonksiyonunu ‘linelist_sf’ dediğimiz yeni nesneyi yaratmak için kullanırız. Bu yeni nesne, esasen satır listesiyle aynı görünüyor, ancak “boy” ve “enlem” sütunları koordinat sütunları olarak belirlenmiş ve noktalar görüntülendiğinde bir koordinat referans sistemi (CRS) atanmıştır. 4326, koordinatlarımızı, GPS koordinatları için standart olan World Geodetic System 1984 (WGS84) temelinde tanımlar.Orijinal “satır listesi” veri çerçevesi bu şekilde görünür. Bu gösterimde, yalnızca “date_onset” ve “geometry” (yukarıdaki boylam ve enlem alanlarından oluşturulan ve veri çerçevesindeki son sütun olan) sütununu kullanacağız.","code":"\n# temizlenmiş vaka satır listesini içe aktarmak\nlinelist <- import(\"linelist_cleaned.rds\")  \n# satır listesindeki satır sayısından 1000 rastgele satır numarası üretmek\nsample_rows <- sample(nrow(linelist), 1000)\n\n# yalnızca örnek satırları ve tüm sütunları tutmak için alt küme satır listesi üretmek\nlinelist <- linelist[sample_rows,]\n# sf nesnesi oluşturmk\nlinelist_sf <- linelist %>%\n     sf::st_as_sf(coords = c(\"lon\", \"lat\"), crs = 4326)\nDT::datatable(head(linelist_sf, 10), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )"},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"yönetici-sınır-şekil-dosyaları","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"Yönetici sınır şekil dosyaları","text":"Sierra Leone: Yönetici sınır şekil dosyalarıSierra Leone için tüm idari sınırları önceden İnsani Veri Değişimi’nden (HDX) web sitesi burada indirdik. ). Alternatif olarak, bu el kitabı için bunları ve diğer tüm örnek verileri [El kitabını ve verileri indir] sayfasında açıklandığı gibi R paketimiz aracılığıyla indirebilirsiniz.Şimdi Admin Level 3 şekil dosyasını R’kaydetmek için aşağıdakileri yapacağız:Şekil dosyasını içe aktarınSütun adlarını temizleyinYalnızca ilgi alanlarını korumak için satırları filtreleyinBir şekil dosyasını içe aktarmak için sf’den read_sf() fonksiyonunu kullanırız. Dosya yolu () ile sağlanır. - bizim durumumuzda dosya, “data”, “gis” ve “shp” alt klasörlerinde “sle_adm3.shp” dosya adıyla R projemizin içindedir (daha fazla bilgi için [İçe aktarma ve dışa aktarma] ve R projeleri sayfalarına bakabilirsiniz). Kendi dosya yolunuzu sağlamanız gerekecek.Daha sonra, şekil dosyasının sütun adlarını standartlaştırmak için janitor paketinden clean_names() kullanıyoruz. Ayrıca sadece “Western Area Urban” veya “Western Area Rural” admin2name ile satırları tutmak için filter() kullanırız.Aşağıda, içe aktarma ve temizleme işleminden sonra şekil dosyasının nasıl göründüğünü görebilirsiniz. sağa doğru kaydırın yönetici düzeyi 0 (ülke), yönetici düzeyi 1, yönetici düzeyi 2 ve son olarak yönetici düzeyi 3 olan sütunların nasıl olduğunu görmek için düzeyin bir karakter adı ve benzersiz bir “pcode” tanımlayıcısı vardır. Pcode, artan yönetici düzeyiyle birlikte genişler; SL (Sierra Leone) -> SL04 (Batı) -> SL0410 (Batı Bölgesi Kırsal) -> SL040101 (Koya Kırsal).","code":"\n# ADM3 seviyesi temizlik \nsle_adm3 <- sle_adm3_raw %>%\n  janitor::clean_names() %>% # sütun isimlerini standardize etmek\n  filter(admin2name %in% c(\"Western Area Urban\", \"Western Area Rural\")) # belirli alanları tutmak için filtrelemek"},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"nüfus-verileri","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"Nüfus verileri","text":"Sierra Leone: ADM3’e göre nüfusBu veriler tekrar HDX’ten (bağlantı buradan) veya [bu sayfada] açıklandığı gibi epirhandbook R paketimizden indirilebilir. [El kitabını ve verileri indirin]. .csv dosyasını yüklemek için import() kullanıyoruz. Ayrıca, sütun adı sözdizimini standartlaştırmak için içe aktarılan dosyayı clean_names() öğesine iletiyoruz.Popülasyon dosyası böyle görünüyor. yetki alanında “erkek” nüfus, “kadın” nüfus, “toplam” nüfus ve yaş grubuna göre nüfus dökümü sütunlarının nasıl olduğunu görmek için sağa kaydırın.","code":"\n# ADM3'e göre nüfus\nsle_adm3_pop <- import(here(\"data\", \"gis\", \"population\", \"sle_admpop_adm3_2020.csv\")) %>%\n  clean_names()"},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"sağlık-tesisleri","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"Sağlık Tesisleri","text":"Sierra Leone: OpenStreetMap’ten alınan sağlık tesisi verileriYine sağlık tesislerinin konumlarını HDX buradan veya [el kitabını ve verileri indir] sayfasındaki talimatlar aracılığıyla indirdik.Tesis noktaları şekil dosyasını read_sf() ile içe aktarıyoruz, sütun adlarını tekrar temizliyoruz ve ardından yalnızca “hastane”, “klinik” veya “doktorlar” olarak etiketlenmiş noktaları tutmak için filtreliyoruz.İşte ortaya çıkan veri çerçevesi - tesis adını ve “geometri” koordinatlarını görmek için sağa kaydırın.","code":"\n# OSM sağlık tesisi şekil dosyası\nsle_hf <- sf::read_sf(here(\"data\", \"gis\", \"shp\", \"sle_hf.shp\")) %>% \n  clean_names() %>%\n  filter(amenity %in% c(\"hospital\", \"clinic\", \"doctors\"))"},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"koordinatları-grafikleştirme","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"28.5 Koordinatları grafikleştirme","text":"Bu durumda X-Y koordinatlarını (boylam/enlem, noktalar) çizmenin en kolay yolu, bunları doğrudan hazırlık bölümünde oluşturduğumuz linelist_sf nesnesinden nokta olarak çizmektir.tmap paketi, hem statik (“çizim” modu) hem de etkileşimli (“görünüm” modu) için yalnızca birkaç satır kodla basit eşleme yetenekleri sunar. tmap sözdizimi ggplot2’ninkine benzerdir, öyle ki komutlar `+’ ile birbirine eklenir. Bu gösterimde daha fazla ayrıntı okuyabilirsiniz.tmap modunu ayarlayın. Bu durumda statik çıktılar üreten “plot” modunu kullanacağız.Aşağıda, noktalar tek başına çizilir.tm_shape()``,linelist_sfnesneleri ile sağlanır. Daha sonra boyut ve rengi belirterektm_dots()` aracılığıyla noktalar ekliyoruz. “linelist_sf” bir sf nesnesi olduğundan, enlem/boylam koordinatlarını ve koordinat referans sistemini (CRS) içeren iki sütunu zaten belirledik:Yalnız, puanlar bize fazla bir şey söylemez. Dolayısıyla idari sınırları da haritalandırmalıyız:Yine tm_shape() kullanıyoruz\n(bkz. [dokümantasyon] https://www.rdocumentation.org/packages/tmap/versions/3.3/topics/tm_shape)) ancak vaka noktaları şekil dosyası sağlamak yerine, idari sınır şekil dosyası (çokgenler) sağlıyoruz.bbox = değişkeniyle (bbox “sınırlayıcı kutu” anlamına gelir) koordinat sınırlarını belirleyebiliriz. Önce harita gösterimini bbox olmadan ve sonra onunla birlikte gösteriyoruz.Ve şimdi hem noktalar hem de çokgenler birlikte:R’daki eşleme seçeneklerinin iyi bir karşılaştırmasını okumak için bu blog gönderisine bakabilirsiniz.","code":"\ntmap_mode(\"plot\") # \"görünüm\" veya \"grafik\"i seçin\n# noktalar sadece vakalar\ntm_shape(linelist_sf) + tm_dots(size=0.08, col='blue')\n# Çokgenler sadece idari sınırlar\ntm_shape(sle_adm3) +               # yönetici sınırları şekil dosyası\n  tm_polygons(col = \"#F7F7F7\")+    # çokgenleri açık gri olarak göster\n  tm_borders(col = \"#000000\",      # renk ve çizgi ağırlığı ile sınırları göster\n             lwd = 2) +\n  tm_text(\"admin3name\")            # her çokgen için görüntülenecek sütun metni\n\n\n# Yukarıdakiyle aynı, ancak sınırlayıcı kutudan yakınlaştırma ile\ntm_shape(sle_adm3,\n         bbox = c(-13.3, 8.43,    # corner\n                  -13.2, 8.5)) +  # corner\n  tm_polygons(col = \"#F7F7F7\") +\n  tm_borders(col = \"#000000\", lwd = 2) +\n  tm_text(\"admin3name\")\n# Hepsi birlikte\ntm_shape(sle_adm3, bbox = c(-13.3, 8.43, -13.2, 8.5)) +     \n  tm_polygons(col = \"#F7F7F7\") +\n  tm_borders(col = \"#000000\", lwd = 2) +\n  tm_text(\"admin3name\")+\ntm_shape(linelist_sf) +\n  tm_dots(size=0.08, col='blue', alpha = 0.5) +\n  tm_layout(title = \"Distribution of Ebola cases\")   # haritaya isim vermek"},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"mekansal-birleşimler","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"28.6 Mekansal birleşimler","text":"Verileri bir veri kümesinden diğerine birleştirmeye aşina olabilirsiniz. Bu el kitabının [Birleştirme verileri] sayfasında çeşitli yöntemler tartışılmaktadır. Bir uzamsal birleşim benzer bir amaca hizmet eder, ancak uzamsal ilişkilerden yararlanır. Gözlemleri doğru bir şekilde eşleştirmek için sütunlardaki ortak değerlere güvenmek yerine, bir özelliğin bir diğerinin içinde olması veya bir diğerine en yakın komşu olması veya belirli bir yarıçapın tampon içinde olması gibi uzamsal ilişkilerini kullanabilirsiniz.sf paketi, uzamsal birleşimler için çeşitli yöntemler sunar. Bu başvuruda st_join yöntemi ve uzamsal birleştirme türleri hakkında daha fazla belgeye bakabilirsiniz.","code":""},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"çokgendeki-noktalar","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"Çokgendeki noktalar","text":"Mekansal olarak vakalara idari birimler atamaİşte ilginç bir muamma: vakaların satır listesi, vakaların idari birimleri hakkında herhangi bir bilgi içermiyor. İlk veri toplama aşamasında bu tür bilgileri toplamak ideal olsa da, uzamsal ilişkilerine dayalı olarak bireysel vakalara idari birimler de atayabiliriz (yani nokta bir çokgenle kesişir).Aşağıda, durum konumlarımızı (noktaları) ADM3 sınırları (poligonlar) ile uzamsal olarak keseceğiz:Satır listesi(puan) ile başlayınSınırlara uzamsal birleştirme, birleştirme türünü “st_intersects” olarak ayarlayınYeni yönetim sınırı sütunlarından yalnızca belirli bir kısmını tutmak için select() kullanın’sle_adms’deki tüm sütunlar satır listesine eklendi! Artık vaka, içinde bulunduğu idari seviyeleri detaylandıran sütunlara sahiptir. Bu örnekte, yeni sütunlardan yalnızca ikisini (yönetici düzeyi 3) tutmak istiyoruz, bu nedenle eski sütun adlarını ve yalnızca iki ek ilgiyi “select()” yapıyoruz:Aşağıda, yalnızca görüntüleme amacıyla, noktanın çokgen şekilleriyle uzamsal olarak kesiştiği yere bağlı olarak ilk vakayı ve bunların admin seviyesi 3 (ADM3) yargı yetkilerini görebilirsiniz.Şimdi durumlarımızı idari birime göre tanımlayabiliriz - uzaysal birleşmeden önce yapamadığımız bir şey!Ayrıca idari birime göre vaka sayımlarının bir çubuk grafiğini de oluşturabiliriz.Bu örnekte, ggplot()‘’linelist_adm’ ile başlıyoruz, böylece çubukları frekansa göre sıralayan ‘fct_infreq()’ gibi faktör fonksiyonlarını uygulayabiliriz (ipuçları için Faktörler sayfasına bakınız).","code":"\nlinelist_adm <- linelist_sf %>%\n  \n  # idari sınır dosyasını uzamsal kesişime dayalı olarak satır listesine ekleyin\n  sf::st_join(sle_adm3, join = st_intersects)\nlinelist_adm <- linelist_sf %>%\n  \n  # idari sınır dosyasını uzamsal kesişime dayalı olarak satır listesine ekleyin\n  sf::st_join(sle_adm3, join = st_intersects) %>% \n  \n  # Eski sütun adlarını ve ilgilendiğiniz iki yeni yönetici adlarını saklayın\n  select(names(linelist_sf), admin3name, admin3pcod)\n# Şimdi her bir vakaya eklenmiş ADM3 adlarını göreceksiniz.\nlinelist_adm %>% select(case_id, admin3name, admin3pcod)## Simple feature collection with 1000 features and 3 fields\n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: -13.27027 ymin: 8.447887 xmax: -13.20545 ymax: 8.491748\n## Geodetic CRS:  WGS 84\n## First 10 features:\n##      case_id     admin3name admin3pcod                   geometry\n## 3624  ab9826 Mountain Rural   SL040102 POINT (-13.21061 8.457991)\n## 649   d7d495        East II   SL040204 POINT (-13.21847 8.482719)\n## 3524  45e07f         East I   SL040203 POINT (-13.21468 8.485151)\n## 4111  f47241       West III   SL040208 POINT (-13.26403 8.465968)\n## 689   8c3dd9     Central II   SL040202  POINT (-13.2378 8.477501)\n## 3908  6e3138       West III   SL040208 POINT (-13.25991 8.455445)\n## 2789  339787        West II   SL040207 POINT (-13.24565 8.466582)\n## 1295  b0ea66        East II   SL040204  POINT (-13.2267 8.484219)\n## 5096  cad2c1        East II   SL040204 POINT (-13.21823 8.482735)\n## 3653  d01309      Central I   SL040201 POINT (-13.22943 8.476506)\n# İdari birime göre vaka sayılarını içeren yeni veri çerçevesi yapın\ncase_adm3 <- linelist_adm %>%          # yeni yönetici sütunlarına sahip satır listesiyle başlayın\n  as_tibble() %>%                      # daha iyi görüntü için tibble'a dönüştürün\n  group_by(admin3pcod, admin3name) %>% # admin birimine göre gruplandır, hem ada hem de pkoda göre\n  summarise(cases = n()) %>%           # satırları özetle ve say\n  arrange(desc(cases))                     # azalan sırada düzenle\n\ncase_adm3## # A tibble: 10 × 3\n## # Groups:   admin3pcod [10]\n##    admin3pcod admin3name     cases\n##    <chr>      <chr>          <int>\n##  1 SL040102   Mountain Rural   261\n##  2 SL040208   West III         215\n##  3 SL040207   West II          178\n##  4 SL040204   East II          125\n##  5 SL040203   East I            57\n##  6 SL040201   Central I         55\n##  7 SL040206   West I            52\n##  8 SL040205   East III          31\n##  9 SL040202   Central II        23\n## 10 <NA>       <NA>               3\nggplot(\n    data = linelist_adm,                       # yönetici birimi bilgilerini içeren satır listesiyle başlayın\n    mapping = aes(\n      x = fct_rev(fct_infreq(admin3name))))+ # x ekseni, frekansa göre sıralanmış (tersine çevrilmiş) yönetici birimleridir\n   geom_bar()+                      # çubuk oluştur, yükseklik satır sayısıdır\n   coord_flip()+ # adm birimlerinin daha kolay okunması için X ve Y eksenlerini çevirin\n   theme_classic()+ # arka planı basitleştirir\n   labs( # başlık ve etiket\n    x = \"Admin level 3\",\n    y = \"Number of cases\",\n    title = \"Number of cases, by adminstative unit\",\n    caption = \"As determined by a spatial join, from 1000 randomly sampled cases from linelist\"\n  )"},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"en-yakın-komşu","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"En yakın komşu","text":"En yakın sağlık kuruluşunu / toplanma alanını bulmaHastalık sıcak noktaları ile ilgili olarak sağlık tesislerinin nerede olduğunu bilmek faydalı olabilir.Bireysel vakalara en yakın sağlık tesisini görselleştirmek için st_join() fonksiyonundan (sf paketi) st_nearest_feature birleştirme yöntemini kullanabiliriz.Satır listesinin şekil dosyası linelist_sf ile başlıyoruzSağlık tesislerinin ve kliniklerin konumları olan sle_hf ile mekansal olarak birleştiriyoruz (puan)Aşağıda (ilk 50 satır) vakanın artık en yakın klinik/hastaneye ait verileri olduğunu görebiliriz.Vakaların yaklaşık %30’u için en yakın sağlık kuruluşunun “Den Clinic” olduğunu görebiliyoruz.Sonuçları görselleştirmek için tmap kullanabiliriz - bu sefer daha kolay görüntüleme için etkileşimli mod","code":"\n# Her vakaya en yakın sağlık kuruluşu\nlinelist_sf_hf <- linelist_sf %>%                  # satır listesini şekil dosyası ile başla\n  st_join(sle_hf, join = st_nearest_feature) %>%   # vaka verilerine en yakın klinikten alınan veriler\n  select(case_id, osm_id, name, amenity) %>%       # sağlık tesisinin adı, türü ve geometrisi dahil olmak üzere ilgili sütunları tutmak\n  rename(\"nearest_clinic\" = \"name\")                # netlik için yeniden adlandırın\n# Sağlık kuruluşuna göre vaka sayıları\nhf_catchment <- linelist_sf_hf %>%   # en yakın klinik verilerini içeren satır listesiyle başlayın\n  as.data.frame() %>%                # şekil dosyasından veri çerçevesine dönüştür\n  count(nearest_clinic,              # satırları \"ad\" ile sayın (kliniğin)\n        name = \"case_n\") %>%         # yeni sayım sütununu \"case_n\" olarak ata\n  arrange(desc(case_n))              # azalan sırada düzenlemek\n\nhf_catchment                         # konsola yazdırmak##                          nearest_clinic case_n\n## 1                            Den Clinic    367\n## 2       Shriners Hospitals for Children    301\n## 3         GINER HALL COMMUNITY HOSPITAL    177\n## 4                             panasonic     57\n## 5 Princess Christian Maternity Hospital     40\n## 6                     ARAB EGYPT CLINIC     30\n## 7                                  <NA>     17\n## 8                  MABELL HEALTH CENTER     11\ntmap_mode(\"view\")   # tmap modunu etkileşimli olarak ayarla\n\n# vakaları ve klinik noktaları çizin \ntm_shape(linelist_sf_hf) +            # vaka grafikleri\n  tm_dots(size=0.08,                  # en yakın klinik tarafından renklendirilen vakalar\n          col='nearest_clinic') +    \ntm_shape(sle_hf) +                    # klinik tesisleri büyük siyah noktalarla çizin\n  tm_dots(size=0.3, col='black', alpha = 0.4) +      \n  tm_text(\"name\") +                   # tesis adı ile üzerine bindirme\ntm_view(set.view = c(-13.2284, 8.4699, 13), # yakınlaştırmayı ayarla (merkez kodları, yakınlaştırma)\n        set.zoom.limits = c(13,14))+\ntm_layout(title = \"Cases, colored by nearest clinic\")"},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"tamponlar","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"Tamponlar","text":"Ayrıca en yakın sağlık kuruluşuna 2,5 km (~30 dakika) yürüme mesafesinde kaç vaka bulunduğunu da keşfedebiliriz.: Daha doğru mesafe hesaplamaları için, sf nesnenizi UTM (düzlemsel bir yüzeye yansıtılan Dünya) gibi ilgili yerel harita projeksiyon sistemine yeniden yansıtmak daha iyidir. Bu örnekte, basit olması için Dünya Jeodezi Sistemi (WGS84) Coğrafi koordinat sistemine bağlı kalacağız (Dünya küresel / yuvarlak bir yüzeyde temsil edilir, bu nedenle birimler ondalık derece cinsindendir). Genel bir dönüşüm kullanacağız: 1 ondalık derece = ~111km.Bu esri makalesinde harita projeksiyonları ve koordinat sistemleri hakkında daha fazla bilgi bulabilirsiniz. Bu blog harita projeksiyonu ve ilgi alanına ve haritanızın / analizinizin içeriğine bağlı olarak uygun bir projeksiyonun nasıl seçilebileceği gibi farklı türlerden bahsetmektedir.İlkin, sağlık tesisinin çevresinde ~2,5 km yarıçaplı dairesel bir tampon oluşturun. Bu, tmap’teki st_buffer() fonksiyonuyla yapılır. Haritanın birimi enlem/boylam ondalık derece cinsinden olduğundan, “0,02” bu şekilde yorumlanır. Harita koordinat sisteminiz metre cinsinden ise sayının metre cinsinden verilmesi gerekir.Aşağıda, tampon bölgeleri şu şekilde çiziyoruz:**İkinci olarak, bu arabellekleri ‘st_join()’ ve st_intersects* birleştirme türünü kullanarak durumlar (noktalar) ile kesiştiririz. Yani tamponlardan gelen veriler kesiştikleri noktalara birleştirilir.Şimdi sonuçları sayabiliriz: nrow(linelist_sf_hf_2k[.na(linelist_sf_hf_2k$osm_id.y),]) 1000 vakadan herhangi biri arabellekle kesişmedi (bu değer eksik) ve bu yüzden en yakın sağlık kuruluşundan 30 dakikadan fazla yürüyün.Sonuçları, herhangi bir arabellekle kesişmeyen vakaların kırmızı görüneceği şekilde görselleştirebiliriz.","code":"\nsle_hf_2k <- sle_hf %>%\n  st_buffer(dist=0.02)       # ondalık derece, yaklaşık 2,5 km'ye eşittir \ntmap_mode(\"plot\")\n# Create circular buffers\ntm_shape(sle_hf_2k) +\n  tm_borders(col = \"black\", lwd = 2)+\ntm_shape(sle_hf) +                    # klinik tesislerini büyük kırmızı noktalarla çizin\n  tm_dots(size=0.3, col='black')      \n# Vakaları arabelleklerle kesiştirin\nlinelist_sf_hf_2k <- linelist_sf_hf %>%\n  st_join(sle_hf_2k, join = st_intersects, left = TRUE) %>%\n  filter(osm_id.x==osm_id.y | is.na(osm_id.y)) %>%\n  select(case_id, osm_id.x, nearest_clinic, amenity.x, osm_id.y)\n# Sağlık tesisi tamponlarından herhangi biriyle kesişmeyen vakalar\nlinelist_sf_hf_2k %>% \n  filter(is.na(osm_id.y)) %>%\n  nrow()## [1] 1000\ntmap_mode(\"view\")\n\n# İlk önce vakaları puan olarak görüntüleyin\ntm_shape(linelist_sf_hf) +\n  tm_dots(size=0.08, col='nearest_clinic') +\n\n# klinik tesisleri büyük siyah noktalarla çizin\ntm_shape(sle_hf) +                    \n  tm_dots(size=0.3, col='black')+   \n\n# Ardından sağlık tesisi arabelleklerini çoklu çizgilerle kaplayın\ntm_shape(sle_hf_2k) +\n  tm_borders(col = \"black\", lwd = 2) +\n\n# Herhangi bir sağlık tesisi tamponunun parçası olmayan vakaları vurgulayın\n# kırmızı noktalarda\ntm_shape(linelist_sf_hf_2k %>%  filter(is.na(osm_id.y))) +\n  tm_dots(size=0.1, col='red') +\ntm_view(set.view = c(-13.2284,8.4699, 13), set.zoom.limits = c(13,14))+\n\n# Başlık ekleyin\ntm_layout(title = \"Cases by clinic catchment area\")"},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"diğer-uzamsal-birleşimler","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"Diğer uzamsal birleşimler","text":"“Birleştirme” bağımsız değişkeni için alternatif değerler şunları içerir (belgelerden)\n* st_contains_properly\n* st_contains\n* st_covered_by\n* st_covers\n* st_crosses\n* st_disjoint\n* st_equals_exact\n* st_equals\n* st_is_within_distance\n* st_nearest_feature\n* st_overlaps\n* st_touches\n* st_within","code":""},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"choropleth-haritaları","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"28.7 Choropleth haritaları","text":"Choropleth haritaları, verilerinizi önceden tanımlanmış alan, genellikle idari birim veya sağlık alanı ile görselleştirmek için faydalı olabilir. Salgın müdahalesinde bu, örneğin yüksek insidans oranlarına sahip belirli alanlar için kaynak tahsisinin hedeflenmesine yardımcı olabilir.Artık tüm vakalara atanan idari birim adlarına sahip olduğumuza göre (yukarıdaki uzamsal birleştirmeler bölümüne bakın), vaka sayılarını alana göre eşleştirmeye başlayabiliriz (choropleth haritaları).ADM3’e göre popülasyon verisi de elimizde olduğundan, bu bilgiyi daha önce oluşturulan case_adm3 tablosuna ekleyebiliriz.bir idari birimin ve vaka sayısının bir özet tablosu olan önceki ‘case_adm3’ adımında oluşturulan veri çerçevesi ile başlıyoruz.“sle_adm3_pop” popülasyon verileri, “case_adm3” veri çerçevesindeki “admin3pcod” sütunundaki ve “sle_adm3_pop içindeki”adm_pcode” sütunundaki ortak değerler temelinde dplyr’den bir “left_join()” kullanılarak birleştirilir `. [Birleştirme verileri] ile ilgili sayfaya bakın).Yalnızca yararlı sütunları tutmak için yeni veri çerçevesine “select()” uygulanır - “toplam” toplam nüfustur10.000 nüfus başına vaka sayısı, mutate() ile yeni bir sütun olarak hesaplanır.Eşleme için bu tabloya ADM3 çokgen şekil dosyasıyla katılınSonuçların haritalanmasıİnsidans oranlarını da haritalayabiliriz","code":"\n# Nüfus verilerini ekleyin ve 10.000 nüfus başına vakaları hesaplayın\ncase_adm3 <- case_adm3 %>% \n     left_join(sle_adm3_pop,                             # pop veri kümesinden sütunlar ekle\n               by = c(\"admin3pcod\" = \"adm3_pcode\")) %>%  # bu iki sütundaki ortak değerlere dayalı olarak birleştir\n     select(names(case_adm3), total) %>%                 # toplam nüfus da dahil olmak üzere yalnızca önemli sütunları tut\n     mutate(case_10kpop = round(cases/total * 10000, 3)) # 3 ondalık basamağa yuvarlanmış 10.000 başına büyük/küçük harf oranıyla yeni sütun oluştur\n\ncase_adm3                                                # izlemek için konsola yazdır## # A tibble: 10 × 5\n## # Groups:   admin3pcod [10]\n##    admin3pcod admin3name     cases  total case_10kpop\n##    <chr>      <chr>          <int>  <int>       <dbl>\n##  1 SL040102   Mountain Rural   261  33993       76.8 \n##  2 SL040208   West III         215 210252       10.2 \n##  3 SL040207   West II          178 145109       12.3 \n##  4 SL040204   East II          125  99821       12.5 \n##  5 SL040203   East I            57  68284        8.35\n##  6 SL040201   Central I         55  69683        7.89\n##  7 SL040206   West I            52  60186        8.64\n##  8 SL040205   East III          31 500134        0.62\n##  9 SL040202   Central II        23  23874        9.63\n## 10 <NA>       <NA>               3     NA       NA\ncase_adm3_sf <- case_adm3 %>%                 #vakalarla başlayın ve yönetici birimine göre puan verin\n  left_join(sle_adm3, by=\"admin3pcod\") %>%    # ortak sütunla şekil dosyası verilerine katıl\n  select(objectid, admin3pcod,                # yalnızca belirli ilgi sütunlarını tut\n         admin3name = admin3name.x,           # bir sütunun adını temizle\n         admin2name, admin1name,\n         cases, total, case_10kpop,\n         geometry) %>%                        # geometriyi koru, böylece çokgenler çizilebilir\n  drop_na(objectid) %>%                       # drop empty rows\n  st_as_sf()                                  # şekil dosyasına çevir\n# tmap modu\ntmap_mode(\"plot\")               # statik haritayı görüntüle\n\n# poligonları çiz\ntm_shape(case_adm3_sf) + \n        tm_polygons(\"cases\") +  # vaka sayısına göre renk sütunu\n        tm_text(\"admin3name\")   # ismi göster\n# 10.000 nüfus başına vakalar\ntmap_mode(\"plot\")             # statik görüntüleme modu\n\n# çizim\ntm_shape(case_adm3_sf) +                # polygonlqrı çiz\n  tm_polygons(\"case_10kpop\",            # vaka oranını içeren sütuna göre renklendir\n              breaks=c(0, 10, 50, 100), # renkler için kırılma noktaları tanımlayın\n              palette = \"Purples\"       # mor renk paleti kullanın\n              ) +\n  tm_text(\"admin3name\")                 # metni göster"},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"ggplot2-ile-haritalandırma","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"28.8 ggplot2 ile haritalandırma","text":"ggplot2 kullanımına zaten aşina iseniz, verilerinizin statik haritalarını oluşturmak için bu paketi kullanabilirsiniz. ‘geom_sf()’ fonksiyonu, verilerinizdeki hangi özelliklerin (noktalar, çizgiler veya çokgenler) olduğuna bağlı olarak farklı nesneler çizecektir. Örneğin, bir choropleth haritası oluşturmak için çokgen geometrili “sf” verilerini kullanarak bir “ggplot()” içinde “geom_sf()” kullanabilirsiniz.Bunun nasıl çalıştığını göstermek için daha önce kullandığımız ADM3 çokgen şekil dosyasıyla başlayabiliriz. Bunların Sierra Leone’deki Yönetici Düzey 3 bölgeleri olduğunu hatırlayın:Eşlemek istediğimiz verileri şekil dosyası nesnesine eklemek için dplyr’deki left_join() fonksiyonunu kullanabiliriz. Bu durumda, daha önce oluşturduğumuz ‘case_adm3’ veri çerçevesini, idari bölgelere göre vaka sayılarını özetlemek için kullanacağız; ancak, bir veri çerçevesinde depolanan herhangi bir veriyi eşlemek için aynı yaklaşımı kullanabiliriz.Bölgeye göre vaka sayımlarının sütun grafiğini yapmak için, ggplot2 kullanarak, geom_col()u şu şekilde çağırabiliriz:Bunun yerine vaka sayımlarının bir choropleth haritası yapmak için ggplot2 kullanmak istiyorsak, geom_sf() fonksiyonunu çağırmak için benzer sözdizimini kullanabiliriz:Ardından, ggplot2 genelinde tutarlı olan dilbilgisini kullanarak haritamızın görünümünü özelleştirebiliriz, örneğin:ggplot2 ile rahat çalışan R kullanıcıları için, geom_sf(), temel harita görselleştirmeleri için uygun olan basit ve doğrudan bir uygulama sunar. Daha fazla bilgi edinmek için geom_sf() gösterimi veya ggplot2 kitabını okuyabilirsiniz.","code":"\nsle_adm3## Simple feature collection with 12 features and 19 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -13.29894 ymin: 8.094272 xmax: -12.91333 ymax: 8.499809\n## Geodetic CRS:  WGS 84\n## # A tibble: 12 × 20\n##    objectid admin3name admin…¹ admin…² admin…³ admin…⁴ admin…⁵ admin…⁶ admin…⁷ admin…⁸ date       valid_on   valid_to\n##  *    <dbl> <chr>      <chr>   <chr>   <chr>   <chr>   <chr>   <chr>   <chr>   <chr>   <date>     <date>     <date>  \n##  1      155 Koya Rural SL0401… Koya R… Wester… SL0401  Western SL04    Sierra… SL      2016-08-01 2016-10-17 NA      \n##  2      156 Mountain … SL0401… Mounta… Wester… SL0401  Western SL04    Sierra… SL      2016-08-01 2016-10-17 NA      \n##  3      157 Waterloo … SL0401… Waterl… Wester… SL0401  Western SL04    Sierra… SL      2016-08-01 2016-10-17 NA      \n##  4      158 York Rural SL0401… York R… Wester… SL0401  Western SL04    Sierra… SL      2016-08-01 2016-10-17 NA      \n##  5      159 Central I  SL0402… Centra… Wester… SL0402  Western SL04    Sierra… SL      2016-08-01 2016-10-17 NA      \n##  6      160 East I     SL0402… East I  Wester… SL0402  Western SL04    Sierra… SL      2016-08-01 2016-10-17 NA      \n##  7      161 East II    SL0402… East II Wester… SL0402  Western SL04    Sierra… SL      2016-08-01 2016-10-17 NA      \n##  8      162 Central II SL0402… Centra… Wester… SL0402  Western SL04    Sierra… SL      2016-08-01 2016-10-17 NA      \n##  9      163 West III   SL0402… West I… Wester… SL0402  Western SL04    Sierra… SL      2016-08-01 2016-10-17 NA      \n## 10      164 West I     SL0402… West I  Wester… SL0402  Western SL04    Sierra… SL      2016-08-01 2016-10-17 NA      \n## 11      165 West II    SL0402… West II Wester… SL0402  Western SL04    Sierra… SL      2016-08-01 2016-10-17 NA      \n## 12      167 East III   SL0402… East I… Wester… SL0402  Western SL04    Sierra… SL      2016-08-01 2016-10-17 NA      \n## # … with 7 more variables: shape_leng <dbl>, shape_area <dbl>, rowcacode0 <chr>, rowcacode1 <chr>, rowcacode2 <chr>,\n## #   rowcacode3 <chr>, geometry <MULTIPOLYGON [°]>, and abbreviated variable names ¹​admin3pcod, ²​admin3ref_n,\n## #   ³​admin2name, ⁴​admin2pcod, ⁵​admin1name, ⁶​admin1pcod, ⁷​admin0name, ⁸​admin0pcod\nsle_adm3_dat <- sle_adm3 %>% \n  inner_join(case_adm3, by = \"admin3pcod\") # iç birleştirme = yalnızca her iki veri nesnesinde de tutuluyorsa\n\nselect(sle_adm3_dat, admin3name.x, cases) # seçili değişkenleri konsola yazdır## Simple feature collection with 9 features and 2 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -13.29894 ymin: 8.384533 xmax: -13.12612 ymax: 8.499809\n## Geodetic CRS:  WGS 84\n## # A tibble: 9 × 3\n##   admin3name.x   cases                                                                                geometry\n##   <chr>          <int>                                                                      <MULTIPOLYGON [°]>\n## 1 Mountain Rural   261 (((-13.21496 8.474341, -13.21479 8.474289, -13.21465 8.474296, -13.21455 8.474298, -...\n## 2 Central I         55 (((-13.22646 8.489716, -13.22648 8.48955, -13.22644 8.489513, -13.22663 8.489229, -1...\n## 3 East I            57 (((-13.2129 8.494033, -13.21076 8.494026, -13.21013 8.494041, -13.2096 8.494025, -13...\n## 4 East II          125 (((-13.22653 8.491883, -13.22647 8.491853, -13.22642 8.49186, -13.22633 8.491814, -1...\n## 5 Central II        23 (((-13.23154 8.491768, -13.23141 8.491566, -13.23144 8.49146, -13.23131 8.491294, -1...\n## 6 West III         215 (((-13.28529 8.497354, -13.28456 8.496497, -13.28403 8.49621, -13.28338 8.496086, -1...\n## 7 West I            52 (((-13.24677 8.493453, -13.24669 8.493285, -13.2464 8.493132, -13.24627 8.493131, -1...\n## 8 West II          178 (((-13.25698 8.485518, -13.25685 8.485501, -13.25668 8.485505, -13.25657 8.485504, -...\n## 9 East III          31 (((-13.20465 8.485758, -13.20461 8.485698, -13.20449 8.485757, -13.20431 8.485577, -...\nggplot(data=sle_adm3_dat) +\n  geom_col(aes(x=fct_reorder(admin3name.x, cases, .desc=T),   # 'vakaları' azaltarak x eksenini yeniden sıralayın\n               y=cases)) +                                  # y ekseni bölgeye göre vaka sayısıdır\n  theme_bw() +\n  labs(                                                     # şekil metnini ayarla\n    title=\"Number of cases, by administrative unit\",\n    x=\"Admin level 3\",\n    y=\"Number of cases\"\n  ) + \n  guides(x=guide_axis(angle=45))                            # açı x ekseni etiketleri daha iyi sığdırmak için 45 derecedir\nggplot(data=sle_adm3_dat) + \n  geom_sf(aes(fill=cases))    # dolguyu vaka sayısı değişkenine göre değiştirecek şekilde ayarla\nggplot(data=sle_adm3_dat) +                           \n  geom_sf(aes(fill=cases)) +                        \n  scale_fill_continuous(high=\"#54278f\", low=\"#f2f0f7\") +    # renk derecesini değiştir\n  theme_bw() +\n  labs(title = \"Number of cases, by administrative unit\",   # şekil metnini ayarla\n       subtitle = \"Admin level 3\"\n  )"},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"altlık-haritalar","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"28.9 Altlık Haritalar","text":"","code":""},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"openstreetmap","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"OpenStreetMap","text":"Aşağıda, OpenStreetMap özelliklerini kullanarak ggplot2 haritası için bir altlık haritanın nasıl elde edileceğini açıklıyoruz. Alternatif yöntemler arasında, Google’ücretsiz kayıt gerektiren ggmap kullanımı yer almaktadır (detaylar) .OpenStreetMap, ücretsiz düzenlenebilir bir dünya haritası oluşturmaya yönelik ortak bir projedir. Temel coğrafi konum verileri (örneğin şehirlerin konumları, yollar, doğal özellikler, havaalanları, okullar, hastaneler, yollar vb.), projenin birincil çıktısı olarak kabul edilir.Öncelikle altlık haritamızı alacağımız OpenStreetMap paketini yüklüyoruz.Ardından, OpenStreetMap paketinden (dosyalar ‘openmap()’ fonksiyonunu kullanarak tanımladığımız ‘harita’ nesnesini oluşturuyoruz). Aşağıdakileri sağlıyoruz:‘upperLeft’ ve ‘lowRight’ altlık harita döşemesinin sınırlarını belirten iki koordinat çifti\nBu durumda, satır listesinin satırlarından max ve min’koyuyoruz, böylece harita verilere dinamik olarak yanıt verecek\nBu durumda, satır listesinin satırlarından max ve min’koyuyoruz, böylece harita verilere dinamik olarak yanıt verecekzoom = (null ise otomatik olarak belirlenir)type = hangi tür altlık harita - burada birkaç olasılık listeledik ve kod şu anda ilkini ([1]) “osm” kullanıyormergeTiles = DOĞRU seçtik, böylece temel döşemeler tek bir yerde birleştirildi.Bu altlık haritasını OpenStreetMap paketinden autoplot.OpenStreetMap() kullanarak şimdi çizersek, eksenlerdeki birimlerin enlem/boylam koordinatları olmadığını görürsünüz. Farklı bir koordinat sistemi kullanıyor. Vaka konutlarını (enlem/boylamda depolanan) doğru bir şekilde görüntülemek için bunun değiştirilmesi gerekir.Bu nedenle OpenStreetMap paketindeki openproj() fonksiyonu ile haritayı enlem/boylam şekline dönüştürmek istiyoruz. Altlık harita olarak ’map’ve ayrıca istediğimiz Koordinat Referans Sistemini (CRS) sağlıyoruz. Bunu, WGS 1984 projeksiyonu için “proj.4” karakter dizisini sağlayarak yapıyoruz, ancak CRS’yi başka şekillerde de sağlayabilirsiniz. (bir proj.4 dizesinin ne olduğunu anlamak için bkz. bu sayfaŞimdi grafiği oluşturduğumuzda eksenler boyunca enlem ve boylam koordinatları olduğunu görüyoruz. Koordinat sistemi dönüştürüldü. Artık vakalarımız üst üste bindirilirse doğru şekilde çizilecek!Daha fazla bilgi için Eğitimlere buradan ve buradan bakın Konular/autoplot.OpenStreetMap) ulaşabilirsiniz.","code":"\n# paketi yükle\npacman::p_load(OpenStreetMap)\n\n# Enlem/boylam koordinat aralığına göre altlık haritayı sığdır. Döşeme türünü seç.\nmap <- openmap(\n  upperLeft = c(max(linelist$lat, na.rm=T), max(linelist$lon, na.rm=T)),   # altlık harita döşemelerinin sınırı\n  lowerRight = c(min(linelist$lat, na.rm=T), min(linelist$lon, na.rm=T)),\n  zoom = NULL,\n  type = c(\"osm\", \"stamen-toner\", \"stamen-terrain\", \"stamen-watercolor\", \"esri\",\"esri-topo\")[1])\nautoplot.OpenStreetMap(map)\n# WGS84 projeksiyonu\nmap_latlon <- openproj(map, projection = \"+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs\")\n# Grafik haritası. ggplot ile çalışmak için \"autoplot\" kullanılmalıdır\nautoplot.OpenStreetMap(map_latlon)"},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"konturlu-yoğunluk-ısı-haritaları","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"28.10 Konturlu yoğunluk ısı haritaları","text":"Aşağıda, bir satır listesiyle (vaka başına bir satır) başlayarak, bir altlık harita üzerinde vakaların konturlu bir yoğunluk ısı haritasının nasıl elde edileceğini açıklıyoruz.Yukarıda açıklandığı gibi OpenStreetMap’ten altlık harita döşemesi oluşturunEnlem ve boylam sütunlarını kullanarak durumları ’linelist’ten çizinNoktaları ggplot2’den stat_density_2d() ile bir yoğunluk ısı haritasına dönüştürün,Enlem/boylam koordinatlarına sahip bir altlık haritamız olduğunda, yerleşim yerlerinin enlem/boylam koordinatlarını kullanarak durumlarımızı en üste çizebiliriz.Altlık haritayı oluşturmak için “autoplot.OpenStreetMap()” fonksiyonunu temel alan ggplot2 fonksiyonları, aşağıda “geom_point()” ile gösterildiği gibi, kolayca en üste eklenecektir:Yukarıdaki haritanın yorumlanması zor olabilir, özellikle de noktalar çakışıyorsa. Bunun yerine ggplot2 stat_density_2d() fonksiyonunu kullanarak 2 boyutlu bir yoğunluk haritası çizebilirsiniz. Hala satır listesi enlem/boylam koordinatlarını kullanıyorsunuz, ancak 2B çekirdek yoğunluğu tahmini yapılıyor ve sonuçlar kontur çizgileriyle - bir topografik harita gibi - gösteriliyor. Belgelerin tamamını buradan okuyabilirsiniz","code":"\n# Grafik haritası. ggplot ile çalışmak için \"autoplot\" kullanılmalıdır\nautoplot.OpenStreetMap(map_latlon)+                 # altlık haritası ile başla\n  geom_point(                                       # satır listesinin enlem ve boylam sütunlarından xy noktaları ekleyin \n    data = linelist,                                \n    aes(x = lon, y = lat),\n    size = 1, \n    alpha = 0.5,\n    show.legend = FALSE) +                          # göstergeleri tamamen bırak\n  labs(x = \"Longitude\",                             # başlıklar ve etiketler\n       y = \"Latitude\",\n       title = \"Cumulative cases\")\n# altlık haritası ile başla\nautoplot.OpenStreetMap(map_latlon)+\n  \n  # yoğunluk grafiğine ekle\n  ggplot2::stat_density_2d(\n        data = linelist,\n        aes(\n          x = lon,\n          y = lat,\n          fill = ..level..,\n          alpha = ..level..),\n        bins = 10,\n        geom = \"polygon\",\n        contour_var = \"count\",\n        show.legend = F) +                          \n  \n  # renk dağılımını belirle\n  scale_fill_gradient(low = \"black\", high = \"red\")+\n  \n  # etiketler \n  labs(x = \"Longitude\",\n       y = \"Latitude\",\n       title = \"Distribution of cumulative cases\")"},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"zaman-serisi-ısı-haritası","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"Zaman serisi ısı haritası","text":"Yukarıdaki yoğunluk ısı haritası kümülatif durumları gösterir. Satır listesinden türetilen semptom başlangıç ayına dayalı olarak ısı haritasını şekillendirerek salgını zaman ve mekan içinde inceleyebiliriz.Başlangıç Yılı ve Ayı ile yeni bir sütun oluşturarak “satır listesi” ile başlıyoruz. R tabanındaki ‘format()’ fonksiyonu, bir tarihin görüntülenme şeklini değiştirir. Bu durumda “YYYY-AA” istiyoruz.Şimdi, yoğunluk ısı haritasına ggplot2 aracılığıyla yüzey oluşturmayı tanıtıyoruz. Yeni sütun satır olarak kullanılarak facet_wrap() uygulanır. Anlaşılır olması için yüzey sütunlarının sayısını 3 olarak ayarladık.","code":"\n# başlangıç ayını dışa aktar\nlinelist <- linelist %>% \n  mutate(date_onset_ym = format(date_onset, \"%Y-%m\"))\n\n# Değerleri inceleyin\ntable(linelist$date_onset_ym, useNA = \"always\")## \n## 2014-04 2014-05 2014-06 2014-07 2014-08 2014-09 2014-10 2014-11 2014-12 2015-01 2015-02 2015-03 2015-04    <NA> \n##       2      11      19      34      92     183     169     140      95      72      52      51      29      51\n# paketler\npacman::p_load(OpenStreetMap, tidyverse)\n\n# altlık haritası ile başlayın\nautoplot.OpenStreetMap(map_latlon)+\n  \n  # yoğunluk grafiği ekleyin\n  ggplot2::stat_density_2d(\n        data = linelist,\n        aes(\n          x = lon,\n          y = lat,\n          fill = ..level..,\n          alpha = ..level..),\n        bins = 10,\n        geom = \"polygon\",\n        contour_var = \"count\",\n        show.legend = F) +                          \n  \n  # renk dağılımını belirle\n  scale_fill_gradient(low = \"black\", high = \"red\")+\n  \n  # etiketler \n  labs(x = \"Longitude\",\n       y = \"Latitude\",\n       title = \"Distribution of cumulative cases over time\")+\n  \n  # grafiği başlangıç ayı-yılına göre şekillendirin\n  facet_wrap(~ date_onset_ym, ncol = 4)               "},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"mekansal-istatistikler","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"28.11 Mekansal istatistikler","text":"Şimdiye kadarki tartışmalarımızın çoğu, mekansal verilerin görselleştirilmesine odaklandı. Bazı durumlarda, verilerinizdeki özniteliklerin uzamsal ilişkilerini ölçmek için mekansal istatistikler kullanmak da ilginizi çekebilir. Bu bölüm uzamsal istatistikteki bazı temel kavramlara çok kısa bir genel bakış sunacak ve daha kapsamlı uzamsal analizler yapmak istiyorsanız keşfetmenize yardımcı olacak bazı kaynaklar önerecektir.","code":""},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"mekansal-ilişkiler","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"Mekansal ilişkiler","text":"Herhangi bir uzamsal istatistiği hesaplamadan önce, verilerimizdeki özellikler arasındaki ilişkileri belirlememiz gerekir. Mekansal ilişkileri kavramsallaştırmanın birçok yolu vardır, ancak kullanımı basit ve yaygın olarak uygulanabilir bir model bitişiklik modelidir. Bu modelde, bir sınırı veya “komşuluğu” paylaşan alanlar arasında coğrafi bir ilişki beklemekteyiz.spdep paketi ile kullandığımız sle_adm3 datasında yönetim bölgesi poligonları arasındaki komşuluk ilişkilerini ölçebiliyoruz. vezir bitişikliğini belirleyeceğiz, bu, bölgelerin sınırları boyunca en az bir noktayı paylaştıkları takdirde komşu olacağı anlamına gelmektedir. Alternatif olarak, bölgelerin bir kenarı paylaşmasını gerektiren kale bitişikliği olacaktır - bizim durumumuzda, düzensiz çokgenlerle, ayrım önemsizdir, ancak bazı durumlarda vezir ve kale arasındaki seçim etkili olabilir.Yukarıda yazdırılan matris, ‘sle_adm3’ verilerimizdeki 9 bölge arasındaki ilişkileri göstermektedir. 0 puan, iki bölgenin komşu olmadığını gösterirken, 0 dışında herhangi bir değer, bir komşu ilişkisini gösterir. Matristeki değerler, bölgenin toplam satır ağırlığı 1 olacak şekilde ölçeklendirilir.Bu komşu ilişkileri görselleştirmenin daha iyi bir yolu, onları çizmektir:Komşu çokgenleri tanımlamak için bir bitişiklik yaklaşımı kullandık; tanımladığımız komşulara bazen bitişiklik tabanlı komşular da denir. Ancak bu, coğrafi bir ilişkiye sahip olması beklenen bölgeleri seçmenin sadece bir yoludur. Coğrafi ilişkileri belirlemeye yönelik en yaygın alternatif yaklaşımı mesafeye dayalı komşular oluşturur; kısaca bunlar:K-en yakın komşular - Merkezler (çokgen bölgesinin coğrafi ağırlıklı merkezi) arasındaki mesafeye bağlı olarak, komşu olarak n en yakın bölgeleri seçin. Bir maksimum mesafe yakınlık eşiği de belirtilebilir. spdep’te “knearneigh()” kullanabilirsiniz (bkz. belgeler).K-en yakın komşular - Merkezler (çokgen bölgesinin coğrafi ağırlıklı merkezi) arasındaki mesafeye bağlı olarak, komşu olarak n en yakın bölgeleri seçin. Bir maksimum mesafe yakınlık eşiği de belirtilebilir. spdep’te “knearneigh()” kullanabilirsiniz (bkz. belgeler).Mesafe eşiği komşuları - Bir mesafe eşiği içindeki tüm komşuları seçin. spdep’te, bu komşu ilişkiler “dnearneigh()” kullanılarak tanımlanabilir (bkz. belgeler) .Mesafe eşiği komşuları - Bir mesafe eşiği içindeki tüm komşuları seçin. spdep’te, bu komşu ilişkiler “dnearneigh()” kullanılarak tanımlanabilir (bkz. belgeler) .","code":"\nsle_nb <- spdep::poly2nb(sle_adm3_dat, queen=T) # komşuluklar yaratın \nsle_adjmat <- spdep::nb2mat(sle_nb)    # komşu ilişkilerini özetleyen matris oluşturun\nsle_listw <- spdep::nb2listw(sle_nb)   # listw (ağırlık listesi) nesnesi oluştur -- buna daha sonra ihtiyacımız olacak\n\nsle_nb## Neighbour list object:\n## Number of regions: 9 \n## Number of nonzero links: 30 \n## Percentage nonzero weights: 37.03704 \n## Average number of links: 3.333333\nround(sle_adjmat, digits = 2)##   [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\n## 1 0.00 0.20 0.00 0.20 0.00  0.2 0.00 0.20 0.20\n## 2 0.25 0.00 0.00 0.25 0.25  0.0 0.00 0.25 0.00\n## 3 0.00 0.00 0.00 0.50 0.00  0.0 0.00 0.00 0.50\n## 4 0.25 0.25 0.25 0.00 0.00  0.0 0.00 0.00 0.25\n## 5 0.00 0.33 0.00 0.00 0.00  0.0 0.33 0.33 0.00\n## 6 0.50 0.00 0.00 0.00 0.00  0.0 0.00 0.50 0.00\n## 7 0.00 0.00 0.00 0.00 0.50  0.0 0.00 0.50 0.00\n## 8 0.20 0.20 0.00 0.00 0.20  0.2 0.20 0.00 0.00\n## 9 0.33 0.00 0.33 0.33 0.00  0.0 0.00 0.00 0.00\n## attr(,\"call\")\n## spdep::nb2mat(neighbours = sle_nb)\nplot(sle_adm3_dat$geometry) +                                           # alan sınırlarını grafikleştir\n  spdep::plot.nb(sle_nb,as(sle_adm3_dat, 'Spatial'), col='grey', add=T) # komşuluk ilişkileri ekle"},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"mekansal-otokorelasyon","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"Mekansal otokorelasyon","text":"Tobler’sık sık alıntılanan birinci coğrafya yasası, “şey diğer şeyle ilişkilidir, ancak yakın şeyler uzaktaki şeylerden daha fazla ilişkilidir” der. Epidemiyolojide bu genellikle, belirli bir bölgedeki belirli bir sağlık sonucu riskinin, uzaktaki bölgelere kıyasla komşu bölgelere daha benzer olduğu anlamına gelir. Bu kavram, uzaysal otokorelasyon olarak resmileştirilmiştir. Benzer değerlere sahip coğrafi özelliklerin uzayda bir araya toplandığı istatistiksel özellik olarak tanımlanır. Uzamsal otokorelasyonun istatistiksel ölçüleri, verilerinizdeki mekansal kümelemenin kapsamını ölçmek, kümelemenin nerede gerçekleştiğini belirlemek ve verilerinizdeki farklı değişkenler arasındaki paylaşılan uzamsal otokorelasyon modellerini belirlemek için kullanılabilir. Bu bölüm, bazı yaygın uzamsal otokorelasyon ölçülerine ve bunların R’da nasıl hesaplanacağına genel bir bakış sunar.Moran’ın İ İstatistiği - Bu, bir bölgedeki bir değişkenin değeri ile komşu bölgelerdeki aynı değişkenin değerleri arasındaki korelasyonun genel bir özet istatistiğidir. Moran’ın istatistiği tipik olarak -1 ile 1 arasındadır. 0 değeri uzamsal korelasyon modeli olmadığını gösterirken 1 veya -1’e yakın değerler sırasıyla daha güçlü uzamsal otokorelasyonu (benzer değerler birbirine yakındır) veya uzamsal dağılımı (benzersiz değerler birbirine yakındır) gösterir.Örnek olarak, daha önce haritalandırdığımız Ebola vakalarındaki uzamsal otokorelasyonu ölçmek için Moran’ın İ istatistiğini hesaplayacağız (unutmayın, bu simüle edilmiş salgın “satır listesi” veri çerçevesinden vakaların bir alt kümesidir). spdep paketinde bu hesaplamayı bizim için yapabilen “moran.test” fonskiyonu vardır:‘moran.test()’ fonksiyonunun çıktısı bize ‘round(moran_i$estimate[1],2)’ Moran istatistiğini gösterir. Bu, verilerimizde uzamsal otokorelasyonun varlığını gösterir - özellikle, benzer sayıda Ebola vakası olan bölgelerin birbirine yakın olması muhtemeldir. “moran.test()” tarafından sağlanan p değeri, uzaysal otokorelasyonun olmadığı sıfır hipotezi altındaki beklentiyle karşılaştırılarak oluşturulur ve resmi bir hipotez testinin sonuçlarını bildirmeniz gerekiyorsa kullanılabilir.Yerel Moran - yerelleştirilmiş uzamsal otokorelasyonu tanımlamak için yukarıda hesaplanan (küresel) Moran istatistiğini ayrıştırabiliriz; bu durum verilerimizdeki belirli kümeleri tanımlamamızı sağlar. Bazen Yerel Mekansal İlişki Göstergesi (LISA) istatistiği olarak adlandırılan bu istatistik, bir bölge etrafındaki mekansal otokorelasyonun kapsamını özetler. Haritada “sıcak” ve “soğuk” noktaları bulmak için faydalı olabilir.Bir örnek göstermek için, yukarıda kullanılan Ebola vaka sayıları için Yerel Moran’ın istatistiğini spdep’ten local_moran() fonksiyonuyla hesaplayabilir ve eşleyebiliriz:**Getis-Ord Gi** - Bu, etkin nokta analizi için yaygın olarak kullanılan başka bir istatistiktir. Bu istatistiğin popülaritesi büyük ölçüde ArcGIS’teki Sıcak Nokta Analizi aracındaki kullanımıyla ilgilidir. Tipik olarak, komşu bölgeler arasındaki bir değişkenin değerindeki farkın normal bir dağılım izlemesi gerektiği varsayımına dayanır. Komşularına kıyasla, belirli bir değişkenin önemli ölçüde daha yüksek (sıcak nokta) veya önemli ölçüde daha düşük (soğuk nokta) değerlerine sahip bölgeleri belirlemek için bir z-skoru yaklaşımı kullanır.spdep’teki localG() fonksiyonunu kullanarak Gi istatistiğini hesaplayabilir ve eşleyebiliriz:Gördüğünüz gibi Getis-Ord Gi haritası daha önce hazırladığımız Yerel Moran’ın İ haritasından biraz farklı görünüyor. Bu, iki istatistiği hesaplamak için kullanılan yöntemin biraz farklı olduğunu yansıtır; hangisini kullanmanız gerektiği, özel kullanım durumunuza ve ilgilendiğiniz araştırma sorusuna bağlıdır.Lee’s L testi - İki değişkenli uzamsal korelasyon için istatistiksel bir testtir. Belirli bir x değişkeni için uzamsal kalıbın, uzamsal olarak x ile ilişkili olduğu varsayılan başka bir değişken olan y’nin uzamsal kalıbına benzer olup olmadığını test etmenizi sağlar.Bir örnek vermek gerekirse, simüle edilmiş salgındaki Ebola vakalarının mekansal düzeninin, nüfusun mekansal düzeniyle ilişkili olup olmadığını test edelim. Başlamak için, ‘sle_adm3’ verilerimizde bir ‘population’ değişkenine ihtiyacımız var. Daha önce yüklediğimiz ‘sle_adm3_pop’ veri çerçevesinden ‘total’ değişkenini kullanabiliriz.Benzer görünüp görünmediklerini görmek için iki değişkenin uzamsal modellerini yan yana hızlı bir şekilde görselleştirebiliriz:Görsel olarak, desenler farklı görünüyor. İki değişkendeki uzamsal otokorelasyon modelinin ilişkili olup olmadığını istatistiksel olarak test etmek için spdep içindeki lee.test() fonksiyonunu kullanabiliriz. Modeller arasında korelasyon yoksa L istatistiği 0’yakın, güçlü bir pozitif korelasyon varsa 1’e yakın (yani modeller benzer) ve güçlü bir negatif korelasyon varsa -1’e yakındır (örn. desenler terstir).Yukarıdaki çıktı, iki değişkenimiz için Lee’nin L istatistiğinin, zayıf negatif korelasyonu gösteren `round(lee_test$estimate[1],2)’ olduğunu göstermektedir. Vaka ve nüfus düzeninin birbiriyle ilişkili olmadığına dair görsel değerlendirmemizi doğrular ve vakaların mekânsal düzeninin kesinlikle yüksek riskli bölgelerdeki nüfus yoğunluğunun bir sonucu olmadığına dair kanıt sağlar.Lee L istatistiği, uzamsal olarak dağılmış değişkenler arasındaki ilişki hakkında bu tür çıkarımlar yapmak için faydalı olabilir; ancak, iki değişken arasındaki ilişkinin doğasını daha ayrıntılı olarak tanımlamak veya kafa karıştırıcı duruma göre ayarlamak için uzaysal regresyon tekniklerine ihtiyaç duyulacaktır. Bunlar aşağıdaki bölümde kısaca açıklanmıştır.","code":"\nmoran_i <-spdep::moran.test(sle_adm3_dat$cases,    # ilgilenilen değişken içim sayısal vektör\n                            listw=sle_listw)       # komşu ilişkilerini özetleyen listw nesnesi\n\nmoran_i                                            # yazdırma sonuçları## \n##  Moran I test under randomisation\n## \n## data:  sle_adm3_dat$cases  \n## weights: sle_listw    \n## \n## Moran I statistic standard deviate = 1.5214, p-value = 0.06408\n## alternative hypothesis: greater\n## sample estimates:\n## Moran I statistic       Expectation          Variance \n##        0.19781540       -0.12500000        0.04502393\n# yereli hesapla\nlocal_moran <- spdep::localmoran(                  \n  sle_adm3_dat$cases,                              # ilgi değişkeni\n  listw=sle_listw                                  # komşu ağırlıkları ile listw nesnesi\n)\n\n# sf verilerine sonuçları birleştirme\nsle_adm3_dat<- cbind(sle_adm3_dat, local_moran)    \n\n# harita grafiği\nggplot(data=sle_adm3_dat) +\n  geom_sf(aes(fill=Ii)) +\n  theme_bw() +\n  scale_fill_gradient2(low=\"#2c7bb6\", mid=\"#ffffbf\", high=\"#d7191c\",\n                       name=\"Local Moran's I\") +\n  labs(title=\"Local Moran's I statistic for Ebola cases\",\n       subtitle=\"Admin level 3 regions, Sierra Leone\")\n# Yerel G analizi gerçekleştir\ngetis_ord <- spdep::localG(\n  sle_adm3_dat$cases,\n  sle_listw\n)\n\n# sf verisine sonuçları ekleme\nsle_adm3_dat$getis_ord <- getis_ord\n\n# harita grafiği\nggplot(data=sle_adm3_dat) +\n  geom_sf(aes(fill=getis_ord)) +\n  theme_bw() +\n  scale_fill_gradient2(low=\"#2c7bb6\", mid=\"#ffffbf\", high=\"#d7191c\",\n                       name=\"Gi*\") +\n  labs(title=\"Getis-Ord Gi* statistic for Ebola cases\",\n       subtitle=\"Admin level 3 regions, Sierra Leone\")\nsle_adm3_dat <- sle_adm3_dat %>% \n  rename(population = total)                          # toplamı nüfus olarak yeniden adlandır\ntmap_mode(\"plot\")\n\ncases_map <- tm_shape(sle_adm3_dat) + tm_polygons(\"cases\") + tm_layout(main.title=\"Cases\")\npop_map <- tm_shape(sle_adm3_dat) + tm_polygons(\"population\") + tm_layout(main.title=\"Population\")\n\ntmap_arrange(cases_map, pop_map, ncol=2)   # 2x1 yönlerine göre düzenleyin\nlee_test <- spdep::lee.test(\n  x=sle_adm3_dat$cases,          # karşılaştırılacak değişken 1\n  y=sle_adm3_dat$population,     # karşılaştırılacak değişken 2\n  listw=sle_listw                # komşu ağırlıkları ile listw nesnesi\n)\n\nlee_test## \n##  Lee's L statistic randomisation\n## \n## data:  sle_adm3_dat$cases ,  sle_adm3_dat$population \n## weights: sle_listw  \n## \n## Lee's L statistic standard deviate = -0.86712, p-value = 0.8071\n## alternative hypothesis: greater\n## sample estimates:\n## Lee's L statistic       Expectation          Variance \n##       -0.13314070       -0.03681518        0.01234040"},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"mekansal-regresyon","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"Mekansal regresyon","text":"Uzamsal verilerinizdeki değişkenler arasındaki ilişkiler hakkında istatistiksel çıkarımlar yapmak isteyebilirsiniz. Bu durumlarda, uzaysal regresyon tekniklerini, yani verilerinizdeki birimlerin uzamsal organizasyonunu açıkça dikkate alan regresyon yaklaşımlarını anlamak yararlıdır. Genel Lineer Modeller (GLM) gibi standart regresyon modelleri yerine uzamsal regresyon modellerini dikkate almanız gerekebilecek bazı nedenler şunlardır:Standart regresyon modelleri, artıkların birbirinden bağımsız olduğunu varsayar. Güçlü bir uzaysal otokorelasyon varlığında, standart bir regresyon modelinin artıklarının da uzaysal olarak otokorelasyona sahip olması muhtemeldir, dolayısıyla bu varsayımı ihlal eder. Bu, model sonuçlarının yorumlanmasında sorunlara yol açabilir, bu durumda uzamsal bir model tercih edilir.Standart regresyon modelleri, artıkların birbirinden bağımsız olduğunu varsayar. Güçlü bir uzaysal otokorelasyon varlığında, standart bir regresyon modelinin artıklarının da uzaysal olarak otokorelasyona sahip olması muhtemeldir, dolayısıyla bu varsayımı ihlal eder. Bu, model sonuçlarının yorumlanmasında sorunlara yol açabilir, bu durumda uzamsal bir model tercih edilir.Regresyon modelleri ayrıca tipik olarak x değişkeninin etkisinin tüm gözlemlerde sabit olduğunu varsayar. Mekansal heterojenlik durumunda, tahmin etmek istediğimiz etkiler uzaya göre değişebilir ve bu farklılıkları ölçmekle ilgilenebiliriz. Bu durumda, uzamsal regresyon modelleri, etkileri tahmin etmek ve yorumlamak için daha fazla esneklik sunar.Regresyon modelleri ayrıca tipik olarak x değişkeninin etkisinin tüm gözlemlerde sabit olduğunu varsayar. Mekansal heterojenlik durumunda, tahmin etmek istediğimiz etkiler uzaya göre değişebilir ve bu farklılıkları ölçmekle ilgilenebiliriz. Bu durumda, uzamsal regresyon modelleri, etkileri tahmin etmek ve yorumlamak için daha fazla esneklik sunar.Mekansal regresyon yaklaşımlarının ayrıntıları bu el kitabının kapsamı dışındadır. Bu bölüm bunun yerine en yaygın uzamsal regresyon modellerine ve kullanımlarına genel bir bakış sunacak ve bu alanı daha fazla araştırmak isterseniz kullanılabilecek referanslara yönlendirecektir.Uzamsal hata modelleri - Bu modeller, uzamsal birimler arasındaki hata terimlerinin ilişkili olduğunu varsayar; bu durumda veriler, standart bir “Ordinary Least Squares (OLS)” modelinin varsayımlarını ihlal eder. Uzamsal hata modellerine bazen eşzamanlı otoregresif (SAR) modeller de denir. spatialreg paketindeki ‘errorsarlm()’ fonksiyonu kullanılarak sığdırılabilirler (eskiden spdep’bir parçası olan uzamsal regresyon fonksiyonları).Uzamsal gecikme modelleri - Bu modeller, bölgesi için bağımlı değişkenin yalnızca içindeki bağımsız değişkenlerin değerinden değil, aynı zamanda ’ye komşu bölgelerdeki bu değişkenlerin değerlerinden de etkilendiğini varsayar. Uzamsal hata modelleri gibi, uzaysal gecikme modelleri de bazen eşzamanlı otoregresif (SAR) modeller olarak tanımlanır. spatialreg paketindeki lagsarlm() fonskiyonu kullanılarak sığdırılabilirler.spdep paketi, standart OLS, uzamsal gecikme ve uzamsal hata modelleri arasında karar vermek için birkaç faydalı tanı testi içerir. Lagrange Çarpanı teşhisleri olarak adlandırılan bu testler, verilerinizdeki uzamsal bağımlılığın türünü belirlemek ve hangi modelin en uygun olduğunu seçmek için kullanılabilir. lm.LMtests() fonksiyonu, tüm Lagrange Çarpan testlerini hesaplamak için kullanılabilir. Anselin (1988) ayrıca Lagrange Çarpan testlerinin sonuçlarına dayanarak hangi uzaysal regresyon modelinin kullanılacağına karar vermek için kullanışlı bir akış şeması aracı sağlar:Bayesin hiyerarşik modelleri - Bayes yaklaşımları, uzaysal analizdeki bazı uygulamalar için yaygın olarak kullanılır, en yaygın olarak hastalık haritalama. Vaka verilerinin seyrek olarak dağıtıldığı (örneğin, nadir bir sonuç durumunda) veya istatistiksel olarak “gürültülü” olduğu durumlarda tercih edilirler, çünkü altta yatan gizli mekansal verileri hesaba katarak hastalık riskinin “düzeltilmiş” tahminlerini oluşturmak için kullanılabilirler. Bu, tahminlerin kalitesini artırabilir. Bunlar ayrıca, hem bağımsız hem de bağımlı değişkenlerde uzamsal olarak bağımlı ve bağımsız varyasyonu açıklayabilen, verilerde bulunabilen karmaşık uzamsal korelasyon modellerinin araştırmacı tarafından önceden belirlenmesine (önceki seçim yoluyla) izin verir. R’da, Bayesin hiyerarşik modelleri CARbayes paketi kullanılarak sığdırılabilir (bkz. gösterim) veya R -INLA (bkz. web sitesi ve ders kitabı). R ayrıca JAGS veya WinBUGS gibi Bayes tahmini yapan harici yazılımları çağırmak için de kullanılabilir.","code":""},{"path":"coğrafi-bilgi-sistemleri-cbs-temelleri.html","id":"kaynaklar-21","chapter":"28 Coğrafi Bilgi Sistemleri (CBS) Temelleri","heading":"28.12 Kaynaklar","text":"R’ın Basit Özellikleri ve sf paketi gösterimR’ın Basit Özellikleri ve sf paketi gösterimR tmap paketi gösterimR tmap paketi gösterimggmap: ggplot2 ile Mekansal Görselleştirmeggmap: ggplot2 ile Mekansal GörselleştirmeR ile harita oluşturmaya giriş, farklı paketlere genel bakışR ile harita oluşturmaya giriş, farklı paketlere genel bakışR’da Mekansal Veriler (EarthLab kursu)R’da Mekansal Veriler (EarthLab kursu)R’da Uygulamalı Uzamsal Veri Analizi ders kitabıR’da Uygulamalı Uzamsal Veri Analizi ders kitabıSpatialEpiApp - R paketi olarak indirilebilen bir Shiny uygulaması, kendi verilerinizi sağlamanıza ve haritalama, küme analizi ve mekansal istatistikleri sağlar.SpatialEpiApp - R paketi olarak indirilebilen bir Shiny uygulaması, kendi verilerinizi sağlamanıza ve haritalama, küme analizi ve mekansal istatistikleri sağlar.R’da Mekansal Ekonometriye Giriş atölyeR’da Mekansal Ekonometriye Giriş atölye","code":""},{"path":"sunum-için-tablolar.html","id":"sunum-için-tablolar","chapter":"29 Sunum için tablolar","heading":"29 Sunum için tablolar","text":"HospitalTotal cases known outcomeRecoveredDiedTotal% casesMedian CT valuesTotal% casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22Bu sayfa, flextable paketi ile özet veri çerçevelerinin sunuma hazır tablolara nasıl dönüştürüleceğini göstermektedir. Bu tablolar powerpoint slaytlarına, HTML sayfalarına, PDF veya Word belgelerine vb. eklenebilir.flextable’ı kullanmadan önce, özet tablosunu veri çerçevesi olarak oluşturmanız gerekmektedir. Tablolar, çapraz tablolar, özetler ve açıklayıcı istatistiklerin hesaplanması gibi Tanımlayıcı tablolar ve [Özetleme verileri] sayfalarındaki yöntemleri kullanabilirsiniz. Veri çerçevesine uygulanan flextable daha sonraki sunumlara uygulanabilir.Tablo oluşturmak için kullanılabilecek birçok R paketi vardır - bu sayfada flextable’ı vurgulamak istedik. knitr paketini ve onun kable() fonksiyonunu kullanan bir örnek Temaslı takibi sayfasında bulunabilir. Benzer şekilde, DT paketi [Shiny Gösterge Tabloları] sayfasında vurgulanmıştır. GT ve huxtable gibi diğerleri Önerilen paketler sayfasında bahsedilmiştir.","code":""},{"path":"sunum-için-tablolar.html","id":"hazırlık-20","chapter":"29 Sunum için tablolar","heading":"29.1 Hazırlık","text":"","code":""},{"path":"sunum-için-tablolar.html","id":"paketleri-yükleme-7","chapter":"29 Sunum için tablolar","heading":"Paketleri yükleme","text":"flextable’ı kurun ve yükleyin. Bu el kitabında, paketi kuran ve kullanım için yükleyen pacman’dan p_load() kullanacağız. R tabanından library() içeren paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] sayfasına bakabilirsiniz.","code":"\npacman::p_load(\n  rio,            # içe/dışa aktar\n  here,           # dosya yolağı\n  flextable,      # HTML tablosu oluştur \n  officer,        # tablolar için yardımcı fonksiyonlar\n  tidyverse)      # veri yönetimi, özetlemesi ve görselleştirilmesi"},{"path":"sunum-için-tablolar.html","id":"verileri-içe-aktarma-4","chapter":"29 Sunum için tablolar","heading":"Verileri içe aktarma","text":"Başlamak için, simüle edilmiş bir Ebola salgınından temizlenmiş vaka listesini içe aktarıyoruz. Takip etmek isterseniz, “temiz satır listesi” dosyasını indirmek için tıklayın. (.rds dosyası olarak). rio paketinden import() fonksiyonuyla verileri içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe aktarma ve dışa aktarma] sayfasına bakın).Çizgi listesinin ilk 50 satırı aşağıda görüntülenmektedir:","code":"\n# satır listesini içe aktar\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"sunum-için-tablolar.html","id":"tabloyu-hazırlama","chapter":"29 Sunum için tablolar","heading":"Tabloyu hazırlama","text":"flextable kullanmaya başlamadan önce tablonuzu veri çerçevesine dönüştürmeniz gerekecektir. janitor ve dplyr gibi paketleri kullanarak bir veri çerçevesinin nasıl oluşturulacağını öğrenmek için Tanımlayıcı tablolar ve [Veri pivotlama] sayfalarına bakabilirsiniz. İçeriği, görüntülenmesini istediğiniz gibi satırlar ve sütunlar halinde düzenlemelisiniz. Ardından, veri çerçevesinin rengi, başlığı, yazı tipleri vb. ile görüntülemek için flextable’e geçirilecektir.Aşağıda, Tanımlayıcı tablolar sayfasından, vaka satır listesi örnek olarak kullanılmıştır. Hazırlanan tabloda toplamlar satırı ile hastaneye göre hasta sonuçları ve CT değerlerini özetlenmiştir.","code":"\ntable <- linelist %>% \n  \n  # Hastane sonuç grubu başına özet değerleri al\n  ###############################################\n  group_by(hospital, outcome) %>%                      # Grup verisi\n  summarise(                                           # İlgilenilen göstergelerin yeni özet sütunları oluştur\n    N = n(),                                            # Hastane-sonuç grubu başına satır sayısı   \n    ct_value = median(ct_blood, na.rm=T)) %>%           # Grup başına medyan CT değeri\n  \n  # Toplamları ekle\n  ############\n  bind_rows(                                           # Önceki tabloyu mini toplamlar tablosuyla birleştir\n    linelist %>% \n      filter(!is.na(outcome) & hospital != \"Missing\") %>%\n      group_by(outcome) %>%                            # Hastaneye göre değil, yalnızca sonuca göre gruplandır  \n      summarise(\n        N = n(),                                       # Tüm veri kümesi için satır sayısı    \n        ct_value = median(ct_blood, na.rm=T))) %>%     # Tüm veri seti için medyan CT değeri\n  \n  # Geniş pivotlama ve format\n  ########################\n  mutate(hospital = replace_na(hospital, \"Total\")) %>% \n  pivot_wider(                                         # uzundan genişe pivotla\n    values_from = c(ct_value, N),                       # yeni değerler ct ve count sütunlarından alınır\n    names_from = outcome) %>%                           # yeni sütun adları sonuçlardan alınır\n  mutate(                                              # yeni sütun ekle\n    N_Known = N_Death + N_Recover,                               # sonucu bilinen sayı\n    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # ölen vakaların yüzdesi (1 ondalık basamağa kadar)\n    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # iyileşen vakaların yüzdesi (1 ondalık basamağa kadar)\n  select(                                              # Sütunları yeniden sırala\n    hospital, N_Known,                                   # Giriş sütunları\n    N_Recover, Pct_Recover, ct_value_Recover,            # İyileşen vaka sütunları\n    N_Death, Pct_Death, ct_value_Death)  %>%             # Ölen vaka sütunları\n  arrange(N_Known)                                     # Satırları en düşükten en yükseğe doğru düzenle (Toplam satırı en altta)\n\ntable  # yazdır## # A tibble: 7 × 8\n## # Groups:   hospital [7]\n##   hospital                             N_Known N_Recover Pct_Recover ct_value_Recover N_Death Pct_Death ct_value_Death\n##   <chr>                                  <int>     <int> <chr>                  <dbl>   <int> <chr>              <dbl>\n## 1 St. Mark's Maternity Hospital (SMMH)     325       126 38.8%                     22     199 61.2%                 22\n## 2 Central Hospital                         358       165 46.1%                     22     193 53.9%                 22\n## 3 Other                                    685       290 42.3%                     21     395 57.7%                 22\n## 4 Military Hospital                        708       309 43.6%                     22     399 56.4%                 21\n## 5 Missing                                 1125       514 45.7%                     21     611 54.3%                 21\n## 6 Port Hospital                           1364       579 42.4%                     21     785 57.6%                 22\n## 7 Total                                   3440      1469 42.7%                     22    1971 57.3%                 22"},{"path":"sunum-için-tablolar.html","id":"temel-flextable","chapter":"29 Sunum için tablolar","heading":"29.2 Temel flextable","text":"","code":""},{"path":"sunum-için-tablolar.html","id":"flextable-oluşturma","chapter":"29 Sunum için tablolar","heading":"Flextable oluşturma","text":"flextable nesnelerini oluşturmak ve yönetmek için, önce veri çerçevesini flextable() fonksiyonundan geçirilir. Sonuç my_table olarak kaydedilir.hospitalN_KnownN_RecoverPct_Recoverct_value_RecoverN_DeathPct_Deathct_value_DeathSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22Bu yapıldıktan sonra, daha fazla flextable biçimlendirme fonksiyonları aracılığıyla my_table nesnesi aşamalı olarak yönlendirilebilir.Bu sayfada, anlaşılır olması için ara adımlarda tablo my_table olarak kaydedilecek ve flextable fonksiyonları bit-bit eklenecektir. Kodun başından sonuna kadar tümünü tek bir yığın halinde yazılmış olarak görmek isterseniz, aşağıdaki Bütün kodlar bölümünü ziyaret edebilirsiniz.flextable koduna ait bir satırının genel sözdizimi aşağıdaki gibidir:function(table, = X, j = X, part = \"X\"), burada:\nfunction, sütun genişliklerini belirlemek için width(), arka plan renklerini ayarlamak için bg(), metnin merkeze/sağa/sola hizalı olup olmadığını ayarlamak için align() gibi birçok farklı fonksiyondan biri olabilir.\ntable = veri çerçevesinin adıdır, ancak veri çerçevesi fonksiyona aktarılıyorsa belirtilmesine gerek yoktur.\npart = fonksiyonun tablonun hangi bölümüne uygulandığını belirtir. Örneğin. “başlık”, “gövde” veya “tümü”.\n= fonksiyonun uygulanacağı satırı belirtir, burada X satır numarasıdır. Birden fazla satır varsa, ör. birinci ila üçüncü satırlar arasında şu şekilde yazılabilir: = c(1:3). ‘Gövde’ seçiliyse, ilk satırın başlık bölümünün altından başladığını unutmayın.\nj = fonksiyonun uygulanacağı sütununu belirtir, burada X sütun numarası veya adıdır. Birden çok sütun varsa, ör. beşinci ve altıncı, şu şekilde yazılabilir: j = c(5,6).\nfunction, sütun genişliklerini belirlemek için width(), arka plan renklerini ayarlamak için bg(), metnin merkeze/sağa/sola hizalı olup olmadığını ayarlamak için align() gibi birçok farklı fonksiyondan biri olabilir.table = veri çerçevesinin adıdır, ancak veri çerçevesi fonksiyona aktarılıyorsa belirtilmesine gerek yoktur.part = fonksiyonun tablonun hangi bölümüne uygulandığını belirtir. Örneğin. “başlık”, “gövde” veya “tümü”.= fonksiyonun uygulanacağı satırı belirtir, burada X satır numarasıdır. Birden fazla satır varsa, ör. birinci ila üçüncü satırlar arasında şu şekilde yazılabilir: = c(1:3). ‘Gövde’ seçiliyse, ilk satırın başlık bölümünün altından başladığını unutmayın.j = fonksiyonun uygulanacağı sütununu belirtir, burada X sütun numarası veya adıdır. Birden çok sütun varsa, ör. beşinci ve altıncı, şu şekilde yazılabilir: j = c(5,6).flextable biçimlendirme fonksiyonlarına ait tam listeyi burada bulabilir veya ?flextable komutunu girerek belgeleri inceleyebilirsiniz.","code":"\nmy_table <- flextable(table) \nmy_table"},{"path":"sunum-için-tablolar.html","id":"sütun-genişliği","chapter":"29 Sunum için tablolar","heading":"Sütun genişliği","text":"hücrede yalnızca bir metin satırı olacak şekilde tabloyu güzelce genişleten autofit() fonksiyonunu kullanabiliriz. qflextable() fonksiyonu, flextable() ve autofit() için uygun bir kısayoldur.hospitalN_KnownN_RecoverPct_Recoverct_value_RecoverN_DeathPct_Deathct_value_DeathSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22Ancak, özellikle hücreler içinde çok uzun değerler varsa, bu fonksiyon zaman uygun olmayabilir, tablo sayfaya sığmayabilir.Bunun yerine genişlikleri width() fonksiyonu ile belirtebilir. Hangi genişlik değerini koyacağınızı bilmek biraz zaman alabilir. Aşağıdaki örnekte, sütun 1, 2, 4 ve 8 için farklı genişlikler belirlenmiştir.hospitalN_KnownN_RecoverPct_Recoverct_value_RecoverN_DeathPct_Deathct_value_DeathSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22","code":"\nmy_table %>% autofit()\nmy_table <- my_table %>% \n  width(j=1, width = 2.7) %>% \n  width(j=2, width = 1.5) %>% \n  width(j=c(4,5,7,8), width = 1)\n\nmy_table"},{"path":"sunum-için-tablolar.html","id":"sütun-başlıkları","chapter":"29 Sunum için tablolar","heading":"Sütun başlıkları","text":"Tablo içeriklerinin daha kolay yorumlanması için daha net başlıklar istenir.Bu tablo için, aynı alt grupları kapsayan sütunların birlikte gruplanabilmesi için ikinci bir başlık katmanı eklemek istiyoruz. Bu top = TRUE argümanı ve add_header_row() fonksiyonu ile yapılmaktadır. Daha sonra birleştirilecek sütunlar için \"\" boş değer bırakılarak, sütunun yeni adı values = argümanıyla verilmektedir.İkinci başlıktaki başlık adları ayrı bir set_header_labels() komutuyla yeniden adlandırılır.Son olarak, üst başlıktaki belirli sütun başlıklarını “birleştirmek” için, merge_at() fonksiyonu kullanılır.HospitalTotal cases known outcomeRecoveredDiedTotal% casesMedian CT valuesTotal% casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22","code":"\nmy_table <- my_table %>% \n  \n  add_header_row(\n    top = TRUE,                # Yeni başlık, mevcut başlık satırının üstüne eklenir\n    values = c(\"Hospital\",     # Aşağıdaki her sütun için başlık değerleri\n               \"Total cases with known outcome\", \n               \"Recovered\",    # Bu, bunun ve sonraki iki sütunun en üst düzey başlığı olacak\n               \"\",\n               \"\",\n               \"Died\",         # Bu, bunun ve sonraki iki sütunun en üst düzey başlığı olacak\n               \"\",             # \"Öldü\" ile birleştirileceği için boş bırak\n               \"\")) %>% \n    \n  set_header_labels(         # Orijinal başlık satırındaki sütunları yeniden adlandır\n      hospital = \"\", \n      N_Known = \"\",                  \n      N_Recover = \"Total\",\n      Pct_Recover = \"% of cases\",\n      ct_value_Recover = \"Median CT values\",\n      N_Death = \"Total\",\n      Pct_Death = \"% of cases\",\n      ct_value_Death = \"Median CT values\")  %>% \n  \n  merge_at(i = 1, j = 3:5, part = \"header\") %>% # Yeni başlık satırında 3 ile 5 arasındaki sütunları yatay olarak birleştir\n  merge_at(i = 1, j = 6:8, part = \"header\")     # HYeni başlık satırında 6 ile 8 arasındaki sütunları yatay olarak birleştir\n\nmy_table  # print"},{"path":"sunum-için-tablolar.html","id":"kenarlıklar-ve-arka-plan","chapter":"29 Sunum için tablolar","heading":"Kenarlıklar ve arka plan","text":"Çeşitli flextable fonksiyonlarıyla kenarlıkları, iç çizgileri vb. ayarlayabilirsiniz. border_remove() ile mevcut tüm sınırları kaldırarak başlamak genellikle daha kolaydır.Ardından, tabloyu theme_box(), theme_booktabs() veya theme_alafoli() öğelerine geçirerek varsayılan kenarlık temalarını uygulayabilirsiniz.Çeşitli fonksiyonlara dikey ve yatay çizgiler ekleyebilirsiniz. hline() ve vline() sırasıyla belirli bir satıra veya sütuna satır ekler. birinin içinde “part =” öğesini “tümü”, “gövde” veya “başlık” olarak belirtmelisiniz. Dikey çizgiler için sütunu j = ve yatay çizgiler için satırı = olarak belirtmelisiniz. vline_right(), vline_left(), hline_top() ve hline_bottom() gibi diğer işlevler yalnızca dış taraflara satır ekler.Tüm bu fonksiyonlarda, çizgi stili border = olarak belirtilmelidir ayrıca officer paketinden fp_border() fonksiyonunu kullanan ayrı bir komutun çıktısı şeklinde olmalıdır. Bu fonksiyon, çizginin genişliğini ve rengini tanımlamanıza yardımcı olur. Bunu aşağıda gösterildiği gibi tablo komutlarının üzerinde tanımlayabilirsiniz.HospitalTotal cases known outcomeRecoveredDiedTotal% casesMedian CT valuesTotal% casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22","code":"\n# sınır çizgisi için stil tanımla\nborder_style = officer::fp_border(color=\"black\", width=1)\n\n# tabloya sınır çizgileri ekle\nmy_table <- my_table %>% \n\n  # Mevcut tüm sınırları kaldır\n  border_remove() %>%  \n  \n  # önceden belirlenmiş bir tema ayarıyla yatay çizgiler ekle\n  theme_booktabs() %>% \n  \n  # İyileşen ve Ölen bölümleri ayırmak için dikey çizgiler ekleyin\n  vline(part = \"all\", j = 2, border = border_style) %>%   # sütun 2'de \n  vline(part = \"all\", j = 5, border = border_style)       # sütun 5'de\n\nmy_table"},{"path":"sunum-için-tablolar.html","id":"yazı-tipi-ve-hizalama","chapter":"29 Sunum için tablolar","heading":"Yazı tipi ve hizalama","text":"flextable’daki align() fonksiyonunu kullanarak en soldaki sütun dışındaki tüm sütunlar hastane adlarıyla ortalayarak hizalanabilir.HospitalTotal cases known outcomeRecoveredDiedTotal% casesMedian CT valuesTotal% casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22Ek olarak, başlık yazı tipi boyutunu artırabilir ve ardından kalın olarak değiştirebilir. Toplam satırı da kalın olarak değiştirebilir.HospitalTotal cases known outcomeRecoveredDiedTotal% casesMedian CT valuesTotal% casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22colformat_num() fonksiyonunu kullanarak orantı sütunlarının yalnızca bir ondalık basamak göstermesi sağlanabilir. Bunun, round() fonksiyonuyla veri yönetimi aşamasında da yapılabileceğini unutmayın.HospitalTotal cases known outcomeRecoveredDiedTotal% casesMedian CT valuesTotal% casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22","code":"\nmy_table <- my_table %>% \n   flextable::align(align = \"center\", j = c(2:8), part = \"all\") \nmy_table\nmy_table <-  my_table %>%  \n  fontsize(i = 1, size = 12, part = \"header\") %>%   # başlığın font büyüklüğünü değiştir\n  bold(i = 1, bold = TRUE, part = \"header\") %>%     # başlığın kalınlığını ayarla\n  bold(i = 7, bold = TRUE, part = \"body\")           # toplam satırın kalınlığını ayarla (gövdenin 7. satırı)\n\nmy_table\nmy_table <- colformat_num(my_table, j = c(4,7), digits = 1)\nmy_table"},{"path":"sunum-için-tablolar.html","id":"hücreleri-birleştirme","chapter":"29 Sunum için tablolar","heading":"Hücreleri birleştirme","text":"Başlık satırındaki hücreler yatay olarak birleştirilebileciği gibi, merge_at() kullanılarak ve satırları () ve sütunu (j) belirtilerek hücreler dikey olarak da birleştirebilir. Burada daha fazla yer açmak için “Hastane” ve “Sonucu bilinen toplam vaka” değerleri dikey olarak birleştirilmektedir.HospitalTotal cases known outcomeRecoveredDiedTotal% casesMedian CT valuesTotal% casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22","code":"\nmy_table <- my_table %>% \n  merge_at(i = 1:2, j = 1, part = \"header\") %>% \n  merge_at(i = 1:2, j = 2, part = \"header\")\n\nmy_table"},{"path":"sunum-için-tablolar.html","id":"arka-plan-rengi","chapter":"29 Sunum için tablolar","heading":"Arka plan rengi","text":"Tablonun içeriğini başlıklardan ayırt etmek için ek biçimlendirme eklemek istenebilir. Örneğin, arka plan rengini değiştirme. Bu örnekte tablo gövdesini gri olarak değiştirmekteyiz.HospitalTotal cases known outcomeRecoveredDiedTotal% casesMedian CT valuesTotal% casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22","code":"\nmy_table <- my_table %>% \n    bg(part = \"body\", bg = \"gray95\")  \n\nmy_table "},{"path":"sunum-için-tablolar.html","id":"koşullu-biçimlendirme","chapter":"29 Sunum için tablolar","heading":"29.3 Koşullu biçimlendirme","text":"Belirli bir kuralı karşılayan bir sütundaki tüm değerler vurgulanabilir. Örneğin, vakaların %55’inden fazlasının öldüğü yer. Ölçütleri = veya j = argümanına, önünde bir tilde ~ gelecek şekilde koyulması yeterlidir. Değerler görüntülenen başlığa değil, veri çerçevesindeki sütununa refere edilmelidir.HospitalTotal cases known outcomeRecoveredDiedTotal% casesMedian CT valuesTotal% casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22Veya, ilgilenilen bir hastane gibi belirli bir kriteri karşılayan tüm satır vurgulanabilir. Ölçütlerin tüm sütunlara uygulanabilmesi için sütun (j) argümanının kaldırılması yeterlidir.HospitalTotal cases known outcomeRecoveredDiedTotal% casesMedian CT valuesTotal% casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22","code":"\nmy_table %>% \n  bg(j = 7, i = ~ Pct_Death >= 55, part = \"body\", bg = \"red\") \nmy_table %>% \n  bg(., i= ~ hospital == \"Military Hospital\", part = \"body\", bg = \"#91c293\") "},{"path":"sunum-için-tablolar.html","id":"tbl_pres_all","chapter":"29 Sunum için tablolar","heading":"29.4 Bütün kodlar","text":"Aşağıda, yukarıdaki bölümlerdeki bahsi geçen bütün kodlar paylaşılmaktadır.HospitalTotal cases known outcomeRecoveredDiedTotal% casesMedian CT valuesTotal% casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22","code":"\nborder_style = officer::fp_border(color=\"black\", width=1)\n\npacman::p_load(\n  rio,            # içe/dışa aktar\n  here,           # dosya yolağı\n  flextable,      # HTML tablosu oluştur \n  officer,        # tablolar için yardımcı fonksiyonlar\n  tidyverse)      # veri yönetimi, özetlemesi ve görselleştirilmesi\n\ntable <- linelist %>% \n\n  # Hastane sonuç grubu başına özet değerleri al\n  ###############################################\n  group_by(hospital, outcome) %>%                      # Grup verisi\n  summarise(                                           # İlgilenilen göstergelerin yeni özet sütunları oluştur\n    N = n(),                                            # Hastane-sonuç grubu başına satır sayısı   \n    ct_value = median(ct_blood, na.rm=T)) %>%           # Grup başına medyan CT değeri\n  \n  # Toplamları ekle\n  ############\n  bind_rows(                                           # Önceki tabloyu mini toplamlar tablosuyla birleştir\n    linelist %>% \n      filter(!is.na(outcome) & hospital != \"Missing\") %>%\n      group_by(outcome) %>%                            # Hastaneye göre değil, yalnızca sonuca göre gruplandır  \n      summarise(\n        N = n(),                                       # Tüm veri kümesi için satır sayısı    \n        ct_value = median(ct_blood, na.rm=T))) %>%     # Tüm veri seti için medyan CT değeri\n  \n  # Geniş pivotlama ve format\n  ########################\n  mutate(hospital = replace_na(hospital, \"Total\")) %>% \n  pivot_wider(                                         # uzundan genişe pivotla\n    values_from = c(ct_value, N),                       # yeni değerler ct ve count sütunlarından alınır\n    names_from = outcome) %>%                           # yeni sütun adları sonuçlardan alınır\n  mutate(                                              # yeni sütun ekle\n    N_Known = N_Death + N_Recover,                               # sonucu bilinen satırların sayısı\n    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # ölen vakaların yüzdesi (1 ondalık basamağa kadar)\n    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # iyileşen vakaların yüzdesi (1 ondalık basamağa kadar)\n  select(                                              # Sütunları yeniden sırala\n    hospital, N_Known,                                   # Giriş sütunları\n    N_Recover, Pct_Recover, ct_value_Recover,            # İyileşen vaka sütunları\n    N_Death, Pct_Death, ct_value_Death)  %>%             # Ölen vaka sütunları\n  arrange(N_Known) %>%                                 # Satırları en düşükten en yükseğe doğru düzenle (Toplam satırı en altta)\n\n  # formatlama\n  ############\n  flextable() %>%              # tablo yukarıdan aktarılır\n  add_header_row(\n    top = TRUE,                # Yeni başlık, mevcut başlık satırının üstüne eklenir\n    values = c(\"Hospital\",     # Aşağıdaki her sütun için başlık değerleri\n               \"Total cases with known outcome\", \n               \"Recovered\",    # Bu, bunun ve sonraki iki sütunun en üst düzey başlığı olacak\n               \"\",\n               \"\",\n               \"Died\",         # Bu, bunun ve sonraki iki sütunun en üst düzey başlığı olacak\n               \"\",             # \"Öldü\" ile birleştirileceği için boş bırak\n               \"\")) %>% \n    set_header_labels(         # Orijinal başlık satırındaki sütunları yeniden adlandır\n      hospital = \"\", \n      N_Known = \"\",                  \n      N_Recover = \"Total\",\n      Pct_Recover = \"% of cases\",\n      ct_value_Recover = \"Median CT values\",\n      N_Death = \"Total\",\n      Pct_Death = \"% of cases\",\n      ct_value_Death = \"Median CT values\")  %>% \n  merge_at(i = 1, j = 3:5, part = \"header\") %>% # Yeni başlık satırında 3 ile 5 arasındaki sütunları yatay olarak birleştir\n  merge_at(i = 1, j = 6:8, part = \"header\") %>%  \n  border_remove() %>%  \n  theme_booktabs() %>% \n  vline(part = \"all\", j = 2, border = border_style) %>%   # at column 2 \n  vline(part = \"all\", j = 5, border = border_style) %>%   # at column 5\n  merge_at(i = 1:2, j = 1, part = \"header\") %>% \n  merge_at(i = 1:2, j = 2, part = \"header\") %>% \n  width(j=1, width = 2.7) %>% \n  width(j=2, width = 1.5) %>% \n  width(j=c(4,5,7,8), width = 1) %>% \n  flextable::align(., align = \"center\", j = c(2:8), part = \"all\") %>% \n  bg(., part = \"body\", bg = \"gray95\")  %>% \n  bg(., j=c(1:8), i= ~ hospital == \"Military Hospital\", part = \"body\", bg = \"#91c293\") %>% \n  colformat_num(., j = c(4,7), digits = 1) %>%\n  bold(i = 1, bold = TRUE, part = \"header\") %>% \n  bold(i = 7, bold = TRUE, part = \"body\")## `summarise()` has grouped output by 'hospital'. You can override using the `.groups` argument.\ntable"},{"path":"sunum-için-tablolar.html","id":"tablonun-kaydedilmesi","chapter":"29 Sunum için tablolar","heading":"29.5 Tablonun kaydedilmesi","text":"Tablonun nihai çıktınıza entegre edilmesinin farklı yolları vardır.","code":""},{"path":"sunum-için-tablolar.html","id":"tek-bir-tablonun-kaydedilmesi","chapter":"29 Sunum için tablolar","heading":"Tek bir tablonun kaydedilmesi","text":"Tabloları Word, PowerPoint, HTML veya görüntü (PNG) dosyaları olarak dışa aktarabilirsiniz. Bunu yapmak için aşağıdaki fonksiyonlardan uygun olanı kullanın:save_as_docx()save_as_pptx()save_as_image()save_as_html()Örnek olarak aşağıda tablo word belgesi olarak kaydedilmektedir. İlk argümanın sözdizimine dikkat edilirse - sadece **flextable* nesnesinin adı verilebilir, ör. my_table veya aşağıda gösterildiği gibi bir “ad” da verilebilir (“table”). Ad, Word’deki tablonun başlığı olarak görünecektir. Aşağıda ayrıca PNG olarak kaydetme kodu da paylaşılmıştır.Bir flextable tablosunu resim olarak kaydetmek için webshot veya webshot2 paketlerinin gerekli olduğunu unutmayın. Görüntüler şeffaf arka planla çıkartılabilir.flextable çıktının ‘canlı’ bir sürümü belge biçiminde görüntülemek istenirse, print() fonksiyonu kullanılabilir. preview = argümanı için aşağıdakilerden birini belirtmek gerekmektedir. Belge, bilgisayarınızda tanımlanan yazılım programında “açılır” ancak kaydedilmez. Bu durum, tablonun bir sayfaya / slayda sığıp sığmadığını kontrol etmek için yararlı olabilir böylece onu başka bir belgeye hızlı bir şekilde kopyalayabilirsiniz. Bağımsız değişken önizlemesini “pptx” veya “docx” olarak ayarlayabilirsiniz.","code":"\n# Tablo başlığını 'my table' olarak düzenle  \nsave_as_docx(\"my table\" = my_table, path = \"file.docx\")\n\nsave_as_image(my_table, path = \"file.png\")\nprint(my_table, preview = \"docx\") # Word örneği\nprint(my_table, preview = \"pptx\") # Powerpoint örneği "},{"path":"sunum-için-tablolar.html","id":"tabloyu-r-markdownda-yazdırma","chapter":"29 Sunum için tablolar","heading":"Tabloyu R markdown’da yazdırma","text":"Tablo nesnesi otomatik olarak bir belgenize veya R markdown çıktısına entegre edilebilir. Bu, değişen verilerle tablonun güncellenebileceği ve böylece sayıların yenilenebileceği anlamına gelmektedir.Bu el kitabının R Markdown ile Raporlar sayfasındaki ayrıntılara bakın.","code":""},{"path":"sunum-için-tablolar.html","id":"kaynaklar-22","chapter":"29 Sunum için tablolar","heading":"29.6 Kaynaklar","text":"Tam flextable kitabı\nİlgili Github sayfasıTüm flextable fonksiyonlarının bir kılavuzu burada bulunabilir\nÖrnek flextable tablolardan oluşan bir galeriye buradan erişilebilir","code":""},{"path":"ggplot-temelleri.html","id":"ggplot-temelleri","chapter":"30 ggplot temelleri","heading":"30 ggplot temelleri","text":"ggplot2 en popüler veri görselleştirme R paketidir. ggplot() fonksiyonu bu paketin merkezindedir ve tüm bu yaklaşım akademik camiada “ggplot” olarak; ortaya çıkan grafikler de sevgi dolu bir ifade ile “ggplots” olarak adlandırılır. Bu isimlerdeki “gg”, şekilleri oluşturmak için kullanılan “grammar graphics” (grafiklerin grameri) kalıbının kısaltmasıdır. ggplot2, işlevselliğini daha da artıran pek çok tamamlayıcı R paketlerinden yararlanmaktadır.Sözdizimi, R tabanındaki fonksiyon ve komutlardan önemli ölçüde farklıdır ve öğrenmesi de bununla ilişkili olarak daha zordur. ggplot2 fonksiyonlarını doğru kullanabilmek için genellikle, kullanıcılar verilerini, tidyversee yüksek düzeyde uyumlu bir şekilde biçimlendirmek gerekir, bu da pek çok paketi birlikte kullanmayı zorunlu kılar.Bu sayfada ggplot2 ile çizim yapmanın temellerini ele alacağız. Planlarınızın gerçekten güzel görünmesini sağlayacak öneriler ve gelişmiş teknikler için ggplot ipuçları sayfasına bakabilirsiniz.Kaynaklar bölümünde bağlantılı birkaç kapsamlı ggplot2 rehberi bulabilirsiniz. Ayrıca RStudio web sitesinden ggplot ile veri görselleştirme kopya kağıdını indirebilirsiniz. Veri görselleştirmelerinizi daha yaratıcı bir şekilde yaparken birkaç ilham almak isterseniz, R grafiği galerisi ve Data--viz gibi web sitelerini incelemenizi öneririz.","code":""},{"path":"ggplot-temelleri.html","id":"hazırlık-21","chapter":"30 ggplot temelleri","heading":"30.1 Hazırlık","text":"","code":""},{"path":"ggplot-temelleri.html","id":"paketlerin-yüklenmesi-4","chapter":"30 ggplot temelleri","heading":"Paketlerin yüklenmesi","text":"Aşağıdaki bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() fonksiyonunu kullanacağız. R tabanından library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] sayfasına bakabilirsiniz.","code":"\npacman::p_load(\n  tidyverse,      # ggplot2 ve diğer veri yönetim paketlerini içerir\n  rio,            # içe / dışa aktarma\n  here,           # dosya lokasyonu bulma\n  stringr         # metinle çalışmak için   \n)"},{"path":"ggplot-temelleri.html","id":"verileri-içe-aktarma-5","chapter":"30 ggplot temelleri","heading":"Verileri içe aktarma","text":"Örnek için Ebola salgınını simüle vakaların veri setini içe aktaracağız. Örneği takip etmek isterseniz, “temiz satır listesi” dosyasını indirmek için tıklayın. (.rds dosyası olarak). Verilerinizi rio paketinden import() işleviyle içe aktarabilirsiniz (.xlsx, .rds, .csv gibi birçok dosya türünü kabul eder - ayrıntılar için [İçe aktarma ve dışa aktarma] sayfasına bakabilirsiniz).Satır listesinin ilk 50 satırı aşağıda gösterilmiştir. “age” (yaş), “wt_kg” (kilo cinsinden ağırlık), “ct_blood” (CT değerleri) ve “days_onset_hosp” (başlangıç tarihi ile hastaneye yatış arasındaki fark) sürekli değişkenlerine odaklanacağız.","code":"\nlinelist <- rio::import(\"linelist_cleaned.rds\")"},{"path":"ggplot-temelleri.html","id":"genel-temizleme","chapter":"30 ggplot temelleri","heading":"Genel temizleme","text":"Çizilecek verileri hazırlarken, verilerin mümkün olduğunca “tidy” veri standartlarına uygun düzenlemek gerekir. Bunun nasıl yapılacağı, bu el kitabının [Verileri temizleme ve temel işlevler] gibi veri yönetimi sayfalarında ayrıntılı olarak açıklanmıştır.Verileri çizim için daha iyi hale getirmek için kullanılan bazı basit yollar, verilerin içeriğini görüntüleme için daha iyi hale getirmeyi içerebilir. Bu yolların, veri işlemeyi zaman daha da kolaylaştıracağı anlamına gelmez. Örneğin:Bir karakter sütunundaki NA değerlerini “Bilinmeyen” karakter dizesiyle değiştirmeSütunu faktör sınıfına çevirerek, değerleri sıralı düzeylere dönüştürmeBazı sütunları, alt çizgi vb. içeren “veri dostu” değerlerinin normal metin veya büyük/küçük harfe dönüştürülmesi (bkz. Karakterler ve dizeler)İşte bu yolların bazı örnekleri:","code":"\n# sütunların görüntü sürümünü daha kolay adlara değiştirme\nlinelist <- linelist %>%\n  mutate(\n    gender_disp = case_when(gender == \"m\" ~ \"Male\",        # m'den Male'e çevirme \n                            gender == \"f\" ~ \"Female\",      # f'den Female'e çevirme\n                            is.na(gender) ~ \"Unknown\"),    # NA'dan Unknown'a çevirme\n    \n    outcome_disp = replace_na(outcome, \"Unknown\")          # replace NA outcome with \"unknown\"\n  )"},{"path":"ggplot-temelleri.html","id":"uzun-formata-döndürme","chapter":"30 ggplot temelleri","heading":"Uzun formata döndürme","text":"Veri yapısıyla ilgili olarak, ggplot2 için genellikle verilerimizi daha uzun biçimlere döndürmek isteyebiliriz. Bununla ilgili daha fazla bilgiyi Verilerin Pivotlanması sayfasında bulabilirsiniz.Örneğin, satır listesindeki bir vaka ve ilişkili verilerini “geniş” bir biçimde çizmek istediğimizi varsayalım. Aşağıda, yalnızca case_id ve semptomların sütunlarını içeren symptoms_data adlı bir mini satır listesi oluşturuyoruz.Bu mini-satır listesinin ilk 50 satırı aşağıdaki şekilde görünür - bir semptomun sütunda nasıl “geniş” olarak biçimlendirildiklerini görebilirsiniz:Spesifik semptomları olan vakaların sayısını çizmek istersek, semptomun belirli bir sütunda olması gerçeğiyle sınırlıyız. Ancak, semptom sütunlarını aşağıdaki gibi daha uzun bir biçime pivotlayabiliriz:İşte ilk 50 satır. Burada vakaların 5 satırı olduğunu unutmayın - olası semptom için bir tane. Yeni symptom_name ve symptom_is_present sütunları, pivotlamanın sonucudur. Bu formatın diğer işlemler için çok yararlı olmayabileceğini, ancak çizim için faydalı olduğunu unutmayın.","code":"\nsymptoms_data <- linelist %>% \n  select(c(case_id, fever, chills, cough, aches, vomit))\nsymptoms_data_long <- symptoms_data %>%    # symptoms_data adlı \"mini\" satır listesiyle başla\n  \n  pivot_longer(\n    cols = -case_id,                       # case_id dışındaki tüm sütunları döndür (tüm belirti sütunları)\n    names_to = \"symptom_name\",             # semptomları içeren yeni sütun için ad ata\n    values_to = \"symptom_is_present\") %>%  # değerleri tutan yeni sütun için ad ata (evet/hayır)\n  \n  mutate(symptom_is_present = replace_na(symptom_is_present, \"unknown\")) # NA'yı \"unknown\"a dönüştür"},{"path":"ggplot-temelleri.html","id":"ggplot-temelleri-1","chapter":"30 ggplot temelleri","heading":"30.2 ggplot temelleri","text":"“Grafiklerin grameri” - ggplot2ggplot2 ile çizim, çizim katmanları ve tasarım öğelerinin birbirinin üzerine “eklenmesi” prensibine dayanır. komut bir öncekine bir artı sembolü (+) ile eklenir. Sonuç, kaydedilebilen, değiştirilebilen, yazdırılabilen, dışa aktarılabilen vb. çok katmanlı bir çizim nesnesidir.ggplot nesneleri oldukça karmaşık olabilir, ancak katmanların temel sırası genellikle şöyle görünür:Başta temel ggplot() komutuyla başlayın - bu, ggplot fonksiyonunu “açar” ve sonraki işlevlerin “+” ile eklenmesine izin verir. Tipik olarak veri kümesi de bu komutta belirtilir.“Geom” katmanlarını ekleyin - bu işlevler verileri geometriler (şekiller) olarak görselleştirir, ör. çubuk grafik, çizgi grafiği, dağılım grafiği, histogram (veya bir kombinasyon!) olarak. Bu işlevlerin tümü, önek olarak “geom_” ile başlar.Eksen etiketleri, başlık, yazı tipleri, boyutlar, renk şemaları, göstergeler veya eksen dönüşü gibi tasarım öğelerini çizime ekleyinBasit bir kod dizilim örneği aşağıdaki gibidir. bir bileşeni aşağıdaki bölümlerde açıklayacağız.","code":"\n# my_data sütunlarındaki verileri kırmızı noktalar olarak çiz\nggplot(data = my_data)+                   # \"my_data\" veri kümesini kullan\n  geom_point(                             # bir nokta katmanı ekle (noktalar)\n    mapping = aes(x = col1, y = col2),    # veri sütununu eksene \"haritala\"\n    color = \"red\")+                       # geom için diğer özellikler\n  labs()+                                 # buraya başlıklar, eksen etiketleri vb. eklenir\n  theme()                                 # burada veri olmayan çizim öğelerinin (eksenler, başlık vb.) rengi, yazı tipi, boyutu vb. ayarlanır "},{"path":"ggplot-temelleri.html","id":"ggplot","chapter":"30 ggplot temelleri","heading":"30.3 ggplot()","text":"Herhangi bir ggplot2 grafiğinin açılış komutu ggplot() şeklindedir. Bu komut, üzerine katmanların ekleneceği boş bir arka plan oluşturur. Bir + sembolü ile ek katmanların eklenmesinin yolunu “açar”.Tipik olarak, ggplot() komutu, çizim için gerekli olan data = argümanını içerir. Bu, grafiğin sonraki katmanları için kullanılacak varsayılan veri kümesini ayarlar.Bu komut, kapanış parantezlerinden sonra bir + ile bitecektir. Bu, komutu “açık” bırakır. ggplot yalnızca, tam komut sonunda bir + olmadan son bir katman içerdiğinde yürütülür/görünür.","code":"\n# Bu komut, boş bir arka planı olan bir grafik yaratacaktır.\nggplot(data = linelist)"},{"path":"ggplot-temelleri.html","id":"geomlar","chapter":"30 ggplot temelleri","heading":"30.4 Geomlar","text":"Boş bir arka plan kesinlikle yeterli değildir - verilerden (örneğin çubuk grafikler, histogramlar, dağılım grafikleri, kutu grafikleri) geometriler (şekiller) oluşturmanız gerekir.Grafikler, ilk ggplot() komutuna geom katmanları eklenerek yapılır. Geom oluşturabilen birçok ggplot2 fonksiyonu mevcuttur. Bu fonksiyonların biri geom_ ile başlar, bu nedenle onlardan genel olarak geom_XXXX() olarak bahsedeceğiz. ggplot2’de gönüllüler tarafından oluşturulmuş 40’tan fazla geoms bulunmaktadır. Bunları ggplot2 galerisinden görüntüleyebilirsiniz. Bazı yaygın geomlar aşağıda listelenmiştir:Histogramlar - geom_histogram()Çubuk grafikler - geom_bar() yada geom_col() (“Çubuk grafikleri” bölümüne bakabilirsiniz)Kutu grafiği - geom_boxplot()Noktalar (örn. dağılım grafikleri) - geom_point()Çizgi grafikler - geom_line() yada geom_path()Trend eğrileri - geom_smooth()Bir çizimde bir veya birden fazla geom görüntüleyebilirsiniz. biri önceki ggplot2 komutlarına bir `+’ ile eklenir ve sonraki coğrafi konumlar öncekilerin üzerine yerleştirilecek şekilde sırayla çizilir.","code":""},{"path":"ggplot-temelleri.html","id":"ggplot_basics_mapping","chapter":"30 ggplot temelleri","heading":"30.5 Verileri grafiğe eşleme","text":"Çoğu geom fonksiyonunda şekilleri oluştururken ne için kullanacakları söylenmelidir - bu nedenle fonksiyonda verilerinizdeki sütunları ilgili grafikle eşleştirerek eksenini, şeklini, rengini, boyutunu vb. tanımlamalısınız. vb. Çoğu grafik konum verileri için, eşlenmesi gereken temel bileşenler x ekseni ve (gerekirse) y eksenidir.Bu “eşleme”, mapping = argümanıyla gerçekleşir. mapping için sağladığınız eşlemeler aes() fonksiyonunda sarılmalıdır, bu nedenle aşağıda gösterildiği gibi mapping = aes(x = col1, y = col2) şeklinde yazabilirsiniz.Aşağıda, ggplot() komutunda veriler linelist durumu olarak ayarlanır. mapping = aes() argümanında age sütunu x eksenine, wt_kg sütunu ise y eksenine eşlenir.+ işaretinden sonra çizim komutları devam eder. geom fonksiyonu olan geom_point() ile bir şekil oluşturulur. Bu geom, yukarıdaki ggplot() komutundan eşlemeleri devralır - eksen-sütun atamalarını bilir ve bu ilişkileri alan üzerinde noktalar olarak görselleştirmeye devam eder.Başka bir örnek olarak, aşağıdaki komutlar aynı verileri, biraz farklı bir eşlemeyi ve farklı bir geom’u kullanır. geom_histogram() fonksiyonu, sayımlar y ekseni otomatik olarak oluşturulduğundan, yalnızca x eksenine eşlenmiş bir sütun gerektirir.","code":"\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+\n  geom_point()\nggplot(data = linelist, mapping = aes(x = age))+\n  geom_histogram()"},{"path":"ggplot-temelleri.html","id":"grafik-estetiği","chapter":"30 ggplot temelleri","heading":"Grafik estetiği","text":"ggplot terminolojisinde “estetik” konusunun belirli bir anlamı vardır. Burada estetik, çizilmiş verinin görsel bir özelliğini ifade eder. Buradaki “estetik” ifadesinin geomlarda/şekillerde çizilen verileri de kapsadığını unutmayın - başlıklar, eksen etiketleri, arka plan rengi gibi genel İngilizcede “estetik” kelimesiyle ilişkilendirebileceğiniz çevredeki görüntü değil. ggplot’ta bu ayrıntılara “temalar” denir ve bir theme() komutuyla ayarlanır (bkz. bu bölüm).Bu nedenle, çizim nesnesinin estetiği, çizilen verilerin renkleri, boyutları, asetatları, yerleşimi vb. olabilir. Tüm geomlar aynı estetik seçeneklere sahip değildir, ancak çoğu geom tarafından kullanılabilir. İşte bazı örnekler:shape = Bir noktayı nokta, yıldız, üçgen veya kare olarak geom_point() ile gösterme…fill = İç renk (örneğin bir çubuk veya kutu grafiği)color = Bir çubuğun, kutu grafiğinin vb. dış çizgisi veya geom_point() kullanılıyorsa noktanın rengisize = Boyut (ör. çizgi kalınlığı, nokta boyutu)alpha = Şeffaflık (1 = opak, 0 = görünmez)binwidth = Histogram bölmelerinin genişliğiwidth = “Çubuk grafiği” sütunlarının genişliğilinetype = Çizgi türü (ör. düz, kesikli, noktalı)Bu çizim nesnesi estetiğine değerler iki şekilde atanabilir:Tüm çizilen gözlemlere uygulanacak statik bir değer (ör. `color = \"blue\") atanmasıHer bir gözlemin görüntülenmesi o sütundaki değerine bağlı olacak şekilde bir veri sütununa (ör. color = hospital) atanması","code":""},{"path":"ggplot-temelleri.html","id":"statik-bir-değer-ayarlama","chapter":"30 ggplot temelleri","heading":"Statik bir değer ayarlama","text":"Çizim nesnesine ait estetik değerlerin statik olmasını istiyorsanız, yani - verilerdeki gözlem için aynı olmasını istiyorsanız, atamasını geom içine, ancak herhangi bir mapping = aes() ifadesinin dışına yazmalısınız. Bu atamalar size = 1 veya color = \"blue\" gibi görünebilir. İşte iki örnek:İlk örnekte, mapping = aes(), ggplot() komutunun içindedir ve eksenler, verilerdeki yaş ve ağırlık sütunlarına eşlenir. Çizim estetiğindeki color =, size = ve alpha =(saydamlık) parametrelerine statik değerler atanır. Anlaşılır olması için, bu, daha sonra çizim estetiği için farklı değerler alacak başka geom’lar ekleyebileceğiniz için ‘geom_point()’ işlevinde yapılmıştır.İkinci örnekte, histogram yalnızca bir sütuna eşlenen x eksenini gerektirmektedir. binwidth =, color =, fill = (iç renk) ve alpha = parametreleri geom içinde tekrar statik değerlere ayarlanır.","code":"\n# dağılım grafiği\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  # veri ve eksen eşlemesini ayarla\n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)         # statik nokta estetiğini ayarla\n\n# histogram\nggplot(data = linelist, mapping = aes(x = age))+       # veri ve eksenleri ayarla\n  geom_histogram(                # histogramı göster\n    binwidth = 7,                # kutuların genişliği\n    color = \"red\",               # sınır çizgi rengi\n    fill = \"blue\",               # kutu iç rengi\n    alpha = 0.1)                 # kutu şeffaflığı"},{"path":"ggplot-temelleri.html","id":"sütun-değerlerine-ölçekleme","chapter":"30 ggplot temelleri","heading":"Sütun değerlerine ölçekleme","text":"Alternatif olarak, çizim nesnesi estetiğini bir sütundaki değerlerle ölçekleyebiliriz. Bu yaklaşımda, estetiğin görüntüsü, o veri sütunundaki gözlemin değerine bağlı olacaktır. Sütun değerleri sürekli ise, o estetik için görüntü ölçeği de (açıklama) sürekli olacaktır. Sütun değerleri ayrıysa, gösterge bir değeri görüntüleyecek ve çizilen veriler belirgin bir şekilde “gruplanmış” olarak görünecektirr (bu sayfanın gruplandırma bölümünde daha fazlasını okuyabilirsiniz).Bunu başarmak için, estetiği bir sütun adına eşlemeniz gerekmektedir (tırnak içinde değil). Bu eşleme, mapping  = aes() fonksiyonu içinde yapılmalıdır (: aşağıda tartışıldığı gibi kodda bu eşleme atamalarını yapabileceğiniz birkaç yer vardır).İki örnek aşağıda verilmiştir.İlk örnekte, color = parametresi (noktanın) age sütununa eşlenir - açıklamada bir ölçek belirir! Şimdilik ölçeğin var olduğuna dikkat etmeniz yeterlidir- sonraki bölümlerde nasıl değiştirileceğini paylaşcağız.İkinci örnekte, iki yeni çizim estetiği de sütunlarla eşlenir (color = ve size =), shape = ve alpha = parametreleri herhangi bir mapping = aes() fonksiyonu dışındaki statik değerlere eşlenir.: Eksen atamaları zaman verilerdeki sütunlara atanır (statik değerlere değil) ve bu zaman mapping = aes() içinde yapılır.Daha karmaşık grafikler oluştururken çizim katmanlarınızı ve estetiğinizi takip etmek daha da önemli hale gelir - örneğin birden fazla geom içeren grafikler. Aşağıdaki örnekte, size = parametresi iki kez atanır - bir kez geom_point() için ve bir kez de geom_smooth() için - ikisi de statik bir değer olarak.","code":"\n# dağılım grafiği\nggplot(data = linelist,   # veri ayarla\n       mapping = aes(     # estetiği sütun değerlerine eşle\n         x = age,           # x eksenini yaşa eşle          \n         y = wt_kg,         # y eksenini ağırlıkla eşle\n         color = age)\n       )+     # yaşa göre rengi eşle\n  geom_point()         # verileri nokta olarak göster\n\n# dağılım grafiği\nggplot(data = linelist,   # veri ayarla\n       mapping = aes(     # estetiği sütun değerlerine eşle\n         x = age,           # x eksenini yaşa eşle           \n         y = wt_kg,         # y eksenini ağırlıkla eşle\n         color = age,       # yaşa göre rengi eşle\n         size = age))+      # yaşa göre boyutu eşle\n  geom_point(             # verileri nokta olarak göster\n    shape = \"diamond\",      # noktalar elmas olarak görüntülenir\n    alpha = 0.3)            # nokta şeffaflığı 30%\nggplot(data = linelist,\n       mapping = aes(           # estetiği sütunlara eşle\n         x = age,\n         y = wt_kg,\n         color = age_years)\n       ) + \n  geom_point(                   # her veri satırı için puan ekle\n    size = 1,\n    alpha = 0.5) +  \n  geom_smooth(                  # trend eğrisi ekle\n    method = \"lm\",              # linear metodla\n    size = 2)                   # çizgi boyutunu (çizgi genişliği) 2 yap"},{"path":"ggplot-temelleri.html","id":"ggplot_basics_map_loc","chapter":"30 ggplot temelleri","heading":"Harita atamaları nerede yapılır","text":"mapping = aes() içindeki estetik haritalama, çizim komutlarınızda birden fazla kez yazılabilir. Bu argüman, en üstteki ggplot() komutuna ve/veya altındaki bir geoma yazılabilir. Nüanslar şunları içerir:En üstteki ggplot() komutunda yapılan eşleme atamaları (x = ve y = öğelerinin nasıl devralındığı gibi atamalar) aşağıdaki herhangi bir geomda varsayılan olarak devralınır.Bir geom içinde yapılan eşleme atamaları yalnızca o geom için geçerlidirBenzer şekilde, en üstteki ggplot() içinde belirtilen data = aşağıdaki herhangi bir geomda varsayılan olarak geçerli olacaktır, ancak bir geom için farklı veri de belirtebilirsiniz (ancak bu daha zordur).Böylece, aşağıdaki komutların biri aynı grafiği oluşturacaktır:","code":"\n# Bu komutlar tam olarak aynı grafiği üretecek\nggplot(data = linelist, mapping = aes(x = age))+\n  geom_histogram()\n\nggplot(data = linelist)+\n  geom_histogram(mapping = aes(x = age))\n\nggplot()+\n  geom_histogram(data = linelist, mapping = aes(x = age))"},{"path":"ggplot-temelleri.html","id":"ggplotgroups","chapter":"30 ggplot temelleri","heading":"Grouplar","text":"Verileri kolayca gruplayabilir ve “gruba göre çizebilirsiniz”. Aslında, bunu zaten yaptınız!Bir mapping = aes() argümanı içinde “grouping” sütununu uygun çizim estetiğine atayın. Yukarıda, age sütununa size = argümanını atadığımızda sürekli değerler kullanarak bunu gösterdik. Ancak bu, ayrık/kategorik sütunlar için aynı şekilde çalışır.Örneğin, puanların cinsiyete göre görüntülenmesini istiyorsanız, mapping = aes(color = gender) değerini ayarlamanız gerekmektedir. Otomatik olarak bir açıklama belirir. Bu atama, en üstteki ggplot() komutundaki mapping = aes() argümanı içinde yapılabilir (ve geom tarafından miras alınabilir) veya geom içinde ayrı bir mapping = aes() içinde ayarlanabilir. Aşağıdaki iki yaklaşım da aşağıda gösterilmiştir:Geom değerlerine bağlı olarak, verileri gruplamak için farklı argümanlar kullanmanız gerekeceğini unutmayın. geom_point() için büyük olasılıkla color =, shape = veya size = kullanacaksınız. Oysa geom_bar() için fill = argümanını kullanmanız daha olasıdır. Bu sadece geoma ve gruplamaları yansıtmak istediğiniz grafik estetiğine bağlıdır.Bilginize - verileri gruplandırmanın en temel yolu, yalnızca mapping = aes() içindeki group = argümanını kullanmaktır. Ancak, bu tek başına renkleri, dolguyu veya şekilleri değiştirmeyecektir. Ayrıca yeni bir açıklama oluşturacaktır. Yine de veriler gruplandırılmıştır, bu nedenle istatistiksel görüntüler etkilenebilir.Bir grafikteki grupların sırasını ayarlamak için ggplot ipuçları sayfasına veya Faktörler sayfasına bakabilirsiniz. Aşağıdaki bölümlerde, sürekli ve kategorik verilerin çizilmesine ilişkin birçok gruplanmış grafik örneği bulunmaktadır.","code":"\nggplot(data = linelist,\n       mapping = aes(x = age, y = wt_kg, color = gender))+\n  geom_point(alpha = 0.5)\n# Bu alternatif kod aynı grafiği üretir\nggplot(data = linelist,\n       mapping = aes(x = age, y = wt_kg))+\n  geom_point(\n    mapping = aes(color = gender),\n    alpha = 0.5)"},{"path":"ggplot-temelleri.html","id":"ggplot_basics_facet","chapter":"30 ggplot temelleri","heading":"30.6 Yüzeyler / Küçük katlar","text":"Yüzeyler veya “küçük katlar”, bir grafiği, veri grubu başına bir panel (“yüzey”) olacak şekilde çok panelli bir şekle bölmek için kullanılır. Aynı tip çizim, biri aynı veri setinin bir alt grubunu kullanarak, birden çok kez oluşturulabilir.Yüzey ekleme, ggplot2 ile birlikte gelen bir fonksiyondur, bu nedenle model “panellerinin” açıklamaları ve eksenleri otomatik olarak hizalanır. ggplot ipuçları sayfasında tartışılan ve tamamen farklı çizimleri (cowplot ve patchwork) tek bir şekilde birleştirmek için kullanılan başka paketler de vardır.Yüzey ekleme, aşağıdaki ggplot2 işlevlerinden biriyle yapılır:facet_wrap() tek değişkenin düzeyine ait farklı bir panel oluşturmak için kullanılır. Örnek olarak, bir bölgedeki hastane için farklı bir salgın eğrisi gösteriyor olabilir. Değişken, tanımlanmış başka bir sıralamaya sahip bir faktör olmadığı sürece, yönler alfabetik olarak sıralanır.Yüzeylerin düzenini belirlemek için belirli seçenekleri çağırabilirsiniz, örn. Yönlü grafiklerin düzenlendiği satır veya sütun sayısını kontrol etmek için nrow = 1 veya ncol = 1.facet_grid() yüzey düzenlemesine ikinci bir değişken getirmek istediğinizde kullanılır. Burada bir alan, iki sütundaki değerler arasındaki kesişimi gösterir. Örneğin, bir hastane-yaş grubu için salgın eğrileri, hastaneler üstte (sütunlar) ve yaş grupları yanda (sıralar) bulunur.alt gruplar bir dizilimde gösterildiğinden nrow ve ncol ile alakalı değildirBu fonksiyonların biri, yüzey eklemek için sütunları belirten bir söz dizimini kabul eder. ikisi de bir tilde ~ işaretinin iki tarafında birer tane olmak üzere en fazla iki sütunu kabul eder.facet_wrap() için genellikle, facet_wrap(~hospital) gibi önüne bir tilde (~) gelen sütunun adını yazarsınız. Ancak iki sütunu facet_wrap(outcome ~ hospital) şeklinde yazabilirsiniz - benzersiz kombinasyon ayrı bir panelde görüntülenecektir. Ancak bir dizilim halinde düzenlenmeyecektir. Başlıklar birleşik terimleri gösterecek ve bunlar sütunlara karşılık satırları özel olarak göstermeyecektir. Yalnızca bir yönlü değişken sağlıyorsanız, formülün diğer tarafında yer tutucu olarak nokta . kullanabilirsiniz - aşağıdaki kod örneklerine bakın.facet_wrap() için genellikle, facet_wrap(~hospital) gibi önüne bir tilde (~) gelen sütunun adını yazarsınız. Ancak iki sütunu facet_wrap(outcome ~ hospital) şeklinde yazabilirsiniz - benzersiz kombinasyon ayrı bir panelde görüntülenecektir. Ancak bir dizilim halinde düzenlenmeyecektir. Başlıklar birleşik terimleri gösterecek ve bunlar sütunlara karşılık satırları özel olarak göstermeyecektir. Yalnızca bir yönlü değişken sağlıyorsanız, formülün diğer tarafında yer tutucu olarak nokta . kullanabilirsiniz - aşağıdaki kod örneklerine bakın.facet_grid() için formülde bir veya iki sütun da belirtebilirsiniz (dizilim ‘satırlar ~ sütunlar’ şeklindedir). Yalnızca birini belirtmek istiyorsanız, tildenin diğer tarafına facet_grid(. ~ hospital) veya facet_grid(hospital ~ .) gibi bir nokta . koyabilirsiniz.facet_grid() için formülde bir veya iki sütun da belirtebilirsiniz (dizilim ‘satırlar ~ sütunlar’ şeklindedir). Yalnızca birini belirtmek istiyorsanız, tildenin diğer tarafına facet_grid(. ~ hospital) veya facet_grid(hospital ~ .) gibi bir nokta . koyabilirsiniz.Yüzeyler, hızlı bir şekilde karmaşıklaşabilir - yüzey eklemeyi seçtiğiniz bir değişkenin çok fazla düzeye sahip olmadığından emin olmalısınız. Tesislerin yaş grubuna göre günlük sıtma vaka sayılarından oluşan sıtma veri seti ile ilgili bazı örnekler için El kitabı ve verileri indirme sayfasına bakabilirsiniz.Aşağıda, basit örnek için bazı değişiklikleri içe aktarıp düzenliyoruz:Sıtma verilerinin ilk 50 satırı aşağıdadır. malaria_tot sütununun yanı sıra yaş grubuna göre sayımları içeren sütunlar olduğunu unutmayın (bunlar ikinci, facet_grid() örneğinde kullanılacaktır).","code":"\n# Bu veriler, tesis-gününe göre günlük sıtma vakası sayılarıdır.\nmalaria_data <- import(here(\"data\", \"malaria_facility_count_data.rds\")) %>%  # içe aktar\n  select(-submitted_date, -Province, -newid)                                 # gereksiz sütunları kaldır"},{"path":"ggplot-temelleri.html","id":"facet_wrap","chapter":"30 ggplot temelleri","heading":"facet_wrap()","text":"malaria_tot ve District sütunlarına odaklanalım. Şimdilik yaşa özel sayım sütunlarını yok sayabilirsiniz. malaria_tot sütununda verilen belirtilen y ekseni yüksekliğinde gün için bir sütun üreten geom_col() ile salgın eğrileri çizeceğiz (veriler zaten günlük sayılardır, bu nedenle geom_col() kullanıyoruz - bkz. aşağıdaki “Çubuk grafiği” bölümü).facet_wrap() komutunu eklediğimizde, bir tilde ve sonra yüzey üzerinde sütunu tanımlarız (bu durumda District). Yaklaşık işaretinin sol tarafına başka bir sütun yerleştirebilirsiniz, - bu kombinasyon için bir yüzey oluşturacaktır - ancak bunu bunun yerine facet_grid() ile yapmanızı öneririz. Bu kullanım örneğinde, “Bölge”nin benzersiz değeri için bir yüzey oluşturulur.","code":"\n# Bölgelere göre yüzeyleri olan bir grafik\nggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +\n  geom_col(width = 1, fill = \"darkred\") +       # sayım verilerini sütun olarak çiz\n  theme_minimal()+                              # arka plan panellerini basitleştir\n  labs(                                         # grafik etiketleri, başlık vb. ekle\n    x = \"Date of report\",\n    y = \"Malaria cases\",\n    title = \"Malaria cases by district\") +\n  facet_wrap(~District)                       # yüzeyler oluşturuldu"},{"path":"ggplot-temelleri.html","id":"facet_grid","chapter":"30 ggplot temelleri","heading":"facet_grid()","text":"İki değişkeni çaprazlamak için facet_grid() yaklaşımını kullanabiliriz. Diyelim ki District verilerini yaşa göre gruplandırmak istiyoruz. Bu verileri ggplot tarafından tercih edilen “long” formatına sokmak için yaş sütunlarında bazı verileri dönüştürmemiz gerekiyor. Yaş gruplarının hepsinin kendine ait sütunları mevcut - biz onları age_group ve num_cases adlı sütunlarda toplamak istiyoruz. Bu işlem hakkında daha fazla bilgi için [Pivoting data] sayfasına bakabilirsiniz.İlk 50 veri satırı aşağıdaki gibi görünmektedir:İki değişkeni facet_grid() öğesine ilettiğinizde, en kolay yöntem, x’satır ve y’nin sütun olduğu formül gösterimini (örneğin x ~ y) kullanmak olacaktır. Burada, age_group ve District sütunlarının bir kombinasyonunun çizimlerinde facet_grid() kullanılımı gösterilmiştir.","code":"\nmalaria_age <- malaria_data %>%\n  select(-malaria_tot) %>% \n  pivot_longer(\n    cols = c(starts_with(\"malaria_rdt_\")),  # sütunları long formatına çevir\n    names_to = \"age_group\",      # sütun adları yaş grubu olacak\n    values_to = \"num_cases\"      # tek bir sütuna sayılar aktarılacak (num_cases)\n  ) %>%\n  mutate(\n    age_group = str_replace(age_group, \"malaria_rdt_\", \"\"),\n    age_group = forcats::fct_relevel(age_group, \"5-14\", after = 1))\nggplot(malaria_age, aes(x = data_date, y = num_cases)) +\n  geom_col(fill = \"darkred\", width = 1) +\n  theme_minimal()+\n  labs(\n    x = \"Date of report\",\n    y = \"Malaria cases\",\n    title = \"Malaria cases by district and age group\"\n  ) +\n  facet_grid(District ~ age_group)"},{"path":"ggplot-temelleri.html","id":"serbest-veya-sabit-eksenler","chapter":"30 ggplot temelleri","heading":"Serbest veya sabit eksenler","text":"Yüzey düzenlemesi sırasında görüntülenen eksen ölçekleri, varsayılan olarak tüm yüzeylerde aynıdır (sabit). Bu, çapraz karşılaştırma için yararlıyken zaman uygun format olmayabilir.facet_wrap() veya facet_grid() kullanırken, “serbest” eksenleri belirlemek için scales = \"free_y\" argümanını kullanabilir veya panellerin y eksenlerini veri alt kümelerine uygun bir şekilde ölçeklendirmesi için serbest bırakabiliriz. Bu, özellikle alt kategorilerden biri için gerçek sayıların küçük olması ve eğilimlerin görülmesinin zorlaşması durumunda işe yarayabilir. “free_y” yerine, x eksenini serbest kılmak için (örneğin tarihlerde) “free_x” veya iki eksen için “serbest” yazabiliriz. facet_grid fonksiyonunda, aynı satırdaki yüzeyler için y ölçeğinin ve aynı sütundaki yüzeyler için x ölçeğinin aynı olacağına dikkat etmelisiniz.Yalnızca facet_grid kullanıldığı durumlarda, space = \"free_y\" veya space = \"free_x\" argümanlarını ekleyebiliriz. Böylece yüzeyin gerçek yüksekliği veya genişliği, içindeki şeklin değerlerine göre ağırlıklandırılır. Bu, yalnızca scales = \"free\" (y veya x) argümanı mevcutsa çalışır.","code":"\n# Serbest y ekseni\nggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +\n  geom_col(width = 1, fill = \"darkred\") +       # sayım verilerini sütun olarak çiz\n  theme_minimal()+                              # arka plan panellerini basitleştir\n  labs(                                         # grafik etiketleri, başlık vb. ekle\n    x = \"Date of report\",\n    y = \"Malaria cases\",\n    title = \"Malaria cases by district - 'free' x and y axes\") +\n  facet_wrap(~District, scales = \"free\")        # yüzeyler oluşturuldu"},{"path":"ggplot-temelleri.html","id":"yüzeylerde-faktör-düzeyi-sırası","chapter":"30 ggplot temelleri","heading":"Yüzeylerde faktör düzeyi sırası","text":"Faktör seviyelerinin yüzeyler içinde nasıl yeniden sıralanacağını öğrenmek için bu blog yazısına bakabilirsiniz.","code":""},{"path":"ggplot-temelleri.html","id":"grafikleri-depolama","chapter":"30 ggplot temelleri","heading":"30.7 Grafikleri depolama","text":"","code":""},{"path":"ggplot-temelleri.html","id":"grafikleri-kaydetme-1","chapter":"30 ggplot temelleri","heading":"Grafikleri kaydetme","text":"Varsayılan olarak bir ggplot() komutunu çalıştırdığınızda, grafik Plots RStudio bölmesinde görüntülenecektir. Ancak, <- atama operatörünü kullanarak ve ona bir isim vererek grafiği bir nesne olarak da kaydedebilirsiniz. Bundan sonra, nesne adının kendisi çalıştırılmadıkça grafik yazdırılmayacaktır. Ek olarak, nesne adını print() ile sararak da yazdırabilirsiniz, ancak bu bir kerede birden çok grafiği yazdırmak için kullanılan bir döngüsü gibi belirli durumlarda gereklidir (bkz. Yineleme, döngüler ve listeler sayfası).","code":"\n# grafiği tanımla\nage_by_wt <- ggplot(data = linelist, mapping = aes(x = age_years, y = wt_kg, color = age_years))+\n  geom_point(alpha = 0.1)\n\n# yazdır\nage_by_wt    "},{"path":"ggplot-temelleri.html","id":"kayıtlı-grafikleri-değiştirme","chapter":"30 ggplot temelleri","heading":"Kayıtlı grafikleri değiştirme","text":"ggplot2 ile ilgili güzel bir şey de, bir grafiği (yukarıdaki gibi) tanımlayabilmeniz ve ardından buna adından başlayarak yeni katmanlar ekleyebilmenizdir. Orijinal grafiği oluşturan tüm komutları tekrarlamanız gerekmez!Örneğin, yukarıda tanımlanan age_by_wt grafiğini 50 yaş sütununda dikey bir çizgi içerecek şekilde değiştirmek için, sadece bir ‘+’ ile ek katmanlar eklemeye başlarız.","code":"\nage_by_wt+\n  geom_vline(xintercept = 50)"},{"path":"ggplot-temelleri.html","id":"grafikleri-dışa-aktarma","chapter":"30 ggplot temelleri","heading":"Grafikleri dışa aktarma","text":"ggplot2’den ggsave() fonksiyonuyla grafikleri dışa kolayca aktarabiliriz. Bunu iki şekilde de yapabiliriz:Grafik nesnesinin adını, ardından dosya yolunu ve uzantılı adı belirterek\nÖrnek: ggsave(my_plot, (\"plots\", \"my_plot.png\"))\nÖrnek: ggsave(my_plot, (\"plots\", \"my_plot.png\"))Yazdırılan son grafiği kaydetmek için komutu bir dosya yolu ile çalıştırarak\nÖrnek: ggsave((\"plots\", \"my_plot.png\"))\nÖrnek: ggsave((\"plots\", \"my_plot.png\"))Dosya yolunda dosya uzantısını tanımlayarak; png, pdf, jpeg, tiff, bmp, svg gibi pek çok formatta dışarı aktarabilirsiniz.Ayrıca width =, height = ve units = (“”, “cm” veya “mm”) bağımsız değişkenlerini de tanımlayabilirsiniz. Çizim çözünürlüğü için bir sayı ile dpi = argümanını ekleyebilirsiniz (ör. 300). “?ggsave” komutunu girerek veya çevrimiçi belgeleri okuyarak fonksiyonu daha ayrıntılı inceleyebilirsiniz.İstediğiniz dosya yolunu sağlamak için burada() sözdizimini kullanabileceğinizi unutmayın. Daha fazla bilgi için İçe ve dışa aktar sayfasına bakabilirsiniz.","code":""},{"path":"ggplot-temelleri.html","id":"etiketler-1","chapter":"30 ggplot temelleri","heading":"30.8 Etiketler","text":"Elbette grafik etiketlerini eklemek veya ayarlamak isteyeceksiniz. Bunlar en kolay şekilde, tıpkı geom’larda olduğu gibi + ile grafiğe eklenen ‘labs()’ fonksiyonu ile düzenlenir.labs() fonksiyonu içinde aşağıdaki argümanları kullanabilirsiniz:x = ve y = x ve y ekseni başlığı (etiketler)title = Ana grafik başlığısubtitle = Grafiğin alt başlığı, başlığın altında daha küçük metinlecaption = Grafik başlığı, varsayılan olarak sağ alttaİşte daha önce yaptığımız, ancak daha güzel etiketlerle bir grafik:Dize metnine dinamik R kodunu yerleştirmek için altyazı atamasında stringr paketinden str_glue() fonksiyonunu nasıl kullandığımıza dikkat edin. Başlık, ilgili tarihteki maksimum hastane yatış süresini yansıtan “verileri” gösterecektir. Daha fazla bilgiyi Karakterler ve dizeler sayfasından okuyabilirsiniz.Açıklama başlığının belirlenmesine ilişkin bir : Açıklamalarda birden fazla skalanız olabileceğinden, tek bir “açıklama başlığı” argümanı yoktur. labs() içinde, açıklamayı oluşturmak için kullanılan çizim estetiğinde gerekli argümanı kullanarak başlığı tanımlayabilirsiniz. Örneğin, açıklama oluşturmak için yukarıda color = age argümanını kullandık. Bu nedenle, labs() fonksiyonuna color = argümanını ekler ve istediğimiz açıklama başlığını yazarız (büyük Y ile “Yaş”). Açıklamayı aes(fill = COLUMN) ile oluşturursanız, labs() içinde bu açıklamanın başlığını ayarlamak için fill = yazmak zorundasınız. ggplot ipuçları sayfasındaki renk ölçekleriyle ilgili bölüm, açıklamaları düzenleme hakkında daha fazla ayrıntı ve scales_() fonksiyonuyla alternatif yaklaşımları içermektedir.","code":"\nage_by_wt <- ggplot(\n  data = linelist,   # veriyi belirle\n  mapping = aes(     # estetiği sütun değerlerine eşle\n         x = age,           # x eksenini yaşa eşle           \n         y = wt_kg,         # y eksenini ağırlıkla eşle\n         color = age))+     # rengi yaşla eşle\n  geom_point()+           # verileri nokta olarak göster\n  labs(\n    title = \"Age and weight distribution\",\n    subtitle = \"Fictional Ebola outbreak, 2014\",\n    x = \"Age in years\",\n    y = \"Weight in kilos\",\n    color = \"Age\",\n    caption = stringr::str_glue(\"Data as of {max(linelist$date_hospitalisation, na.rm=T)}\"))\n\nage_by_wt"},{"path":"ggplot-temelleri.html","id":"ggplot_basics_themes","chapter":"30 ggplot temelleri","heading":"30.9 Temalar","text":"ggplot2’nin en iyi yanlarından biri, grafik üzerinde sahip olduğunuz kontrol düzeyidir - şeyi tanımlayabilirsiniz! Yukarıda bahsedilen, veri şekilleri/geometrileri ile ilgili olmayan tasarım özellikleri theme() fonksiyonu içerisinde düzenlenir. Örneğin, arka plan rengi, kılavuz çizgilerinin varlığı/yokluğu ve metnin yazı tipi/boyutu/renk/hizalaması (başlıklar, alt yazılar, açıklamalar, eksen başlıkları…). Bu düzenlemeler iki yolla yapılabilir:Kapsamlı ayarlamalar yapmak için bir tam tema “theme_()” fonksiyonu kullanma - örn. theme_classic(), theme_minimal(), theme_dark(), theme_light() theme_grey(), theme_bw()theme() içinde grafiğin yönünü ayrı ayrı düzenleme","code":""},{"path":"ggplot-temelleri.html","id":"tam-temalar","chapter":"30 ggplot temelleri","heading":"Tam temalar","text":"Oldukça basit oldukları için, aşağıda tüm tema işlevlerini göstereceğiz ve burada daha fazla açıklamayacağız. theme() ile yapılan tüm mikro ayarlamaların, tam bir tema kullanıldıktan sonra yapılması gerektiğini unutmamalısınız.Bunları boş parantez ile yazınız.","code":"\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Theme classic\")+\n  theme_classic()\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Theme bw\")+\n  theme_bw()\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Theme minimal\")+\n  theme_minimal()\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Theme gray\")+\n  theme_gray()"},{"path":"ggplot-temelleri.html","id":"temayı-düzenleme","chapter":"30 ggplot temelleri","heading":"Temayı düzenleme","text":"theme() fonksiyonu, biri grafiğin çok özel bir yönünü düzenleyen pek çok sayıda argüman alabilir. Tüm argümanları ele almamız mümkün değil, ancak onların tamamı geçerli olan genel kalıbı tanımlayacağız. İhtiyacınız olan argüman adını nasıl bulacağınızı göstereceğiz. Bu fonksiyonun temel sözdizimi aşağıdaki gibidir:theme() fonksiyonu içinde, düzenlemek istediğiniz grafiğin argüman adını plot.title = olarak yazın.Argümana bir element_() fonksiyonu ekleyinÇoğu zaman element_text() fonksiyonu kullanılır, ancak sık kullanılan diğerleri de arka plan renkleri için element_rect() veya grafik öğelerini kaldırmak için element_blank()element_() fonksiyonu içinde, istediğiniz ince ayarları yapmak için argümanlar kullanın.Biliyoruz, bu açıklama oldukça soyuttu. Daha iyi açıklamak adına bir kaç örnek paylaşacağız.Aşağıdaki grafiğin oldukça saçma bir örnek olduğunun farkındayız, ancak size grafikleri nasıl ayarlayabileceğinizi göstermekte bize yardımcı olacak.İlk olarak tanımlanan age_by_wt grafiğiyle başlayıp theme_classic() fonksiyonunu ekliyoruzDaha ince ayarlamalar için theme() fonksiyonu ve ayarlanacak grafik öğesi için bir argüman ekleriz.Argümanları mantıksal bir şekilde düzenlemek güzel olabilir. Aşağıda bir kaçını tanımladık:legend.position = “alt”, “üst”, “sol” ve “sağ” gibi basit değerleri kabul etmesi bakımından benzersizdir. Ancak genellikle metinle ilgili argümanlar, ayrıntıları element_text() içine yerleştirmenizi gerektirir.element_text(size = 30) ile başlık boyutuelement_text(hjust = 0) ile yazıyı yatay olarak hizalama (sağdan sola)Altyazı, element_text(face = \"italic\") ile italik yazılırBurada özellikle yaygın olan bazı tema() argümanları verilmiştir. Değişikliği yalnızca bir eksene uygulamak için “.x” veya “.y” ekini ekleyebilirsiniz.Daha pek çok tema argümanı mevcuttur! Hepsini nasıl hatırlayabilirim diye endişelenmenize gerek yok - hepsini hatırlamanız imkansız. Neyse ki size yardımcı olacak birkaç araç var:Tam bir liste içeren tema değiştirme hakkındaki tidyverse belgeleri.İPUCU: Konsola 90’dan fazla theme() argümanının listesini yazdırmak için ggplot2 paketinden theme_get() fonksiyonunu çalıştırın.İPUCU: Grafiğin bir öğesini kaldırmak isterseniz, bunu theme() aracılığıyla da yapabilirsiniz. Tamamen kaybolması için bir argümana element_blank()ı eklemeniz yeterlidir. Açıklamalar için de legend.position = \"none\" argümanını kullanabilirsiniz.","code":"\nage_by_wt + \n  theme_classic()+                                 # önceden tanımlanmış tema ayarlamaları\n  theme(\n    legend.position = \"bottom\",                    # açıklamayı aşağıya taşı\n    \n    plot.title = element_text(size = 30),          # başlığın boyutu 30\n    plot.caption = element_text(hjust = 0),        # sola hizalı başlık\n    plot.subtitle = element_text(face = \"italic\"), # italik alt başlık\n    \n    axis.text.x = element_text(color = \"red\", size = 15, angle = 90), # yalnızca x ekseni metnini ayarlar\n    axis.text.y = element_text(size = 15),         # yalnızca y ekseni metnini ayarlar\n    \n    axis.title = element_text(size = 20)           # her iki eksen başlığını da ayarlar\n    )     "},{"path":"ggplot-temelleri.html","id":"renkler","chapter":"30 ggplot temelleri","heading":"30.10 Renkler","text":"Lütfen ggplot ipuçları sayfasının renk skalalarıyla ilgili bölüme bakın.","code":""},{"path":"ggplot-temelleri.html","id":"ggplot2-içine-tünelleme","chapter":"30 ggplot temelleri","heading":"30.11 ggplot2 içine tünelleme","text":"Verilerinizi temizlemek ve dönüştürmek için tünelleme metodunu kullandıysanız, dönüştürülmüş bu verileri ggplot()kolayca geçirebilirsiniz.Veri kümesini fonksiyondan fonksiyona taşıma işlemi, ggplot() kullanımında “+” eklenmiş gibi davranacaktır. Bu durumda, otomatik olarak iletilen veri kümesi olarak tanımlandığından, data = argümanını kullanmaya gerek olmadığını unutmayın.Kodun söz dizimi aşağıdaki gibi görülebilir:","code":"\nlinelist %>%                                                     # satır listesiyle başla\n  select(c(case_id, fever, chills, cough, aches, vomit)) %>%     # sütunları seç\n  pivot_longer(                                                  # long formatına dönüştür\n    cols = -case_id,                                  \n    names_to = \"symptom_name\",\n    values_to = \"symptom_is_present\") %>%\n  mutate(                                                        # eksik verileri düzenle\n    symptom_is_present = replace_na(symptom_is_present, \"unknown\")) %>% \n  \n  ggplot(                                                        # ggplot'u başlat\n    mapping = aes(x = symptom_name, fill = symptom_is_present))+\n  geom_bar(position = \"fill\", col = \"black\") +                    \n  theme_classic() +\n  labs(\n    x = \"Symptom\",\n    y = \"Symptom status (proportion)\"\n  )"},{"path":"ggplot-temelleri.html","id":"sürekli-verilere-ait-grafikler","chapter":"30 ggplot temelleri","heading":"30.12 Sürekli verilere ait grafikler","text":"Bu sayfa boyunca, sürekli veri grafiklerine ait birçok örneği zaten gördünüz. Burada bunları kısaca tekrarlayıp birkaç varyasyonu paylaşacağız.Burada kapsanan görselleştirmeler aşağıda listelenmiştir:Bir sürekli değişken için grafikler:\nHistogram, sürekli bir değişkenin dağılımını sunar\nKutu grafiği 25., 50. ve 75. yüzdelikleri, dağılımın uçlarını ve aykırı değerleri gösterir (önemli kısıtlamaları öğrenmek için linke tıklaın).\nJitter grafiği, tüm değerleri ‘titreyen’ noktalar olarak gösterir, böylece ikisi aynı değere sahip olsa bile (çoğunlukla) bütün noktalar görülebilir.\nViolin grafiği, ‘kemanın’ simetrik genişliğine dayalı sürekli bir değişkenin dağılımını gösterir\nSina grafiği, tek tek noktaları ve dağılımı simetrik şekilde (ggforce paketi aracılığıyla) gösterir. Jitter ve Violin grafiklerinin bir kombinasyonudur.\nHistogram, sürekli bir değişkenin dağılımını sunarKutu grafiği 25., 50. ve 75. yüzdelikleri, dağılımın uçlarını ve aykırı değerleri gösterir (önemli kısıtlamaları öğrenmek için linke tıklaın).Jitter grafiği, tüm değerleri ‘titreyen’ noktalar olarak gösterir, böylece ikisi aynı değere sahip olsa bile (çoğunlukla) bütün noktalar görülebilir.Violin grafiği, ‘kemanın’ simetrik genişliğine dayalı sürekli bir değişkenin dağılımını gösterirSina grafiği, tek tek noktaları ve dağılımı simetrik şekilde (ggforce paketi aracılığıyla) gösterir. Jitter ve Violin grafiklerinin bir kombinasyonudur.İki sürekli değişken için Dağılım grafiği.Üç sürekli değişken için Isı grafikleri (Isı grafikleri sayfasına bağlantılı)","code":""},{"path":"ggplot-temelleri.html","id":"histogramlar","chapter":"30 ggplot temelleri","heading":"Histogramlar","text":"Histogramlar çubuk grafikler gibi görünebilir, ancak farklıdır çünkü sürekli bir değişkenin dağılımını ölçerler. “Çubuklar” arasında boşluk yoktur ve geom_histogram() fonksiyonu için yalnızca bir sütun sağlanır.Aşağıda, sürekli verileri aralık halinde gruplayan ve değişen yükseklikteki bitişik çubuklarda görüntüleyen histogram kodları paylaşılmıştır. Grafik çizimi, geom_histogram() kullanılarak yapılır. geom_histogram(), geom_bar() ve geom_col() arasındaki farkı anlamak için ggplot temelleri sayfasının “Çubuk grafiği” bölümüne bakabilirsiniz.Aşağıdaki örnekte vakaların yaş dağılımını göstereceğiz. mapping = aes() argümanı içinde, dağılımını görmek istediğiniz sütunu tanımlamanız gerekmektedir. Bu sütunu x veya y eksenine atayabilirsiniz.Satırlar, sayısal yaşlarına göre “bin”lere atanacak ve bunlar, çubuklarla temsil edilecektir. bins = argümanıyla çubuk sayısını belirtirseniz, kırılma noktaları, histogramın minimum ve maksimum değerleri arasında eşit aralıklarla yerleştirilir. bins = argümanı belirtilmemişse, uygun sayıdaki bin değeri tahmin edilir ve çizimden sonra bu aşağıdaki mesaj görüntülenir:bins = için bir sayı belirtmek istemiyorsanız, alternatif olarak ilgili eksenin birimlerini binwidth = argümanıyla tanımlayabilirsiniz. Aşağıda farklı “bin” sayısı ve genişliklerini gösteren birkaç örnek veriyoruz:Düzleştirilmiş oranlar elde etmek için geom_density() fonksiyonunu kullanabilirsiniz:“Yığılmış” bir histogram (sürekli bir veri sütunundan) oluşturmak için aşağıdakilerden birini yapabilirsiniz:‘aes()’ fonksiyonu içindeki ‘fill =’ argümanına atanmış bir gruplandırma sütununu ‘geom_histogram()’ fonksiyonuyla birlikte kullanma,Muhtemelen okunması daha kolay olan geom_freqpoly() fonksiyonunu kullanma (binwidth = argümanını kullanmaya devam edebilirsiniz),Tüm değerlerin oranlarını görmek için y = after_stat(yoğunluk) değerini ayarlama (bu sözdizimini tam olarak kullanın - verileriniz değişmedi). : grup başına oranları gösterecektir.bir seçenek aşağıda gösterilmiştir (*kodlardaki color = vs fill = kullanımına dikkat edin):Biraz eğlenmek istiyorsanız, ggridges paketinden “geom_density_ridges”deneyebilirsiniz .tidyverse geom_histogram() sayfasındaki histogramlar hakkında daha fazla bilgi edinebilirsiniz.","code":"\n## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n# A) Normal histogram\nggplot(data = linelist, aes(x = age))+  # x parametresi tanımla\n  geom_histogram()+\n  labs(title = \"A) Default histogram (30 bins)\")\n\n# B) Daha çok bin\nggplot(data = linelist, aes(x = age))+  # x parametresi tanımla\n  geom_histogram(bins = 50)+\n  labs(title = \"B) Set to 50 bins\")\n\n# C) Daha az \"bin\"\nggplot(data = linelist, aes(x = age))+  # x parametresi tanımla\n  geom_histogram(bins = 5)+\n  labs(title = \"C) Set to 5 bins\")\n\n# D) Çok bin\nggplot(data = linelist, aes(x = age))+  # x parametresi tanımla\n  geom_histogram(binwidth = 1)+\n  labs(title = \"D) binwidth of 1\")\n# Oran eksenli frekans, düzleştirilmiş\nggplot(data = linelist, mapping = aes(x = age)) +\n  geom_density(size = 2, alpha = 0.2)+\n  labs(title = \"Proportional density\")\n\n# Oran ekseni ile yığılmış frekans, düzleştirilmiş\nggplot(data = linelist, mapping = aes(x = age, fill = gender)) +\n  geom_density(size = 2, alpha = 0.2, position = \"stack\")+\n  labs(title = \"'Stacked' proportional densities\")\n# \"Yığılmış\" histogram\nggplot(data = linelist, mapping = aes(x = age, fill = gender)) +\n  geom_histogram(binwidth = 2)+\n  labs(title = \"'Stacked' histogram\")\n\n# Sıklık \nggplot(data = linelist, mapping = aes(x = age, color = gender)) +\n  geom_freqpoly(binwidth = 2, size = 2)+\n  labs(title = \"Freqpoly\")\n\n# Oran eksenli frekans\nggplot(data = linelist, mapping = aes(x = age, y = after_stat(density), color = gender)) +\n  geom_freqpoly(binwidth = 5, size = 2)+\n  labs(title = \"Proportional freqpoly\")\n\n# Oran eksenli frekans, düzleştirilmiş\nggplot(data = linelist, mapping = aes(x = age, y = after_stat(density), fill = gender)) +\n  geom_density(size = 2, alpha = 0.2)+\n  labs(title = \"Proportional, smoothed with geom_density()\")"},{"path":"ggplot-temelleri.html","id":"çubuk-grafikleri","chapter":"30 ggplot temelleri","heading":"Çubuk grafikleri","text":"Çubuk grafikleri yaygındır, ancak önemli kısıtlamalara sahiptir. İlk olarak gerçek dağılımı gizleyebilirler - ör. iki modlu bir dağıtım. Detaylı bilgi için R grafiği galerisine ve bu data--viz makalesine bakabilirsiniz. Bununla birlikte, çeyrekler arasındaki mesafeyi ve aykırı değerleri güzel bir şekilde gösterirler - böylece dağılımı daha ayrıntılı gösteren diğer grafik türlerinin üzerine eklenebilirler.Aşağıda size bir kutu grafiğinin çeşitli bileşenlerini hatırlatıyoruz:Bir çubuk grafiği oluşturmak için geom_boxplot() fonksiyonunu kullanırken, genellikle aes() içinde yalnızca bir ekseni (x veya y) eşlersiniz. Tanımlanan eksen, grafiklerin yatay mı yoksa dikey mi olduğunu belirler.Çoğu geomlarda, color = veya fill = gibi bir estetiği aes() içindeki bir sütuna eşleyerek grup başına bir çizim oluşturursunuz. Bununla birlikte, çubuk grafiğinde sütunu boş bir eksene (x veya y) atayarak elde edebilirsiniz. Aşağıda, kod örneklerinin ilkinde tüm yaş değerlerinin çubuk grafiği kodlanmıştır. İkincisinde ise veri kümesindeki (eksik olmayan) cinsiyet için bir çubuk grafiği kodlanmıştır. Kaldırılmadığı sürece NA (eksik) değerlerin ayrı bir kutu grafiği olarak görüneceğini unutmayın. Bu örnekte, grafiğin farklı bir renk olması için outcome sütununa farklı bir fill argümanı tanımladık - ancak rutinde bu gerekli değildir.Bir dağılım grafiğinin (“marjinal” grafikler) kenarına kutu grafiği eklemenin nasıl yapıldığını görmek için ggplot ipuçları sayfasına bakabilirsiniz.","code":"\n# A) Genel yaş grafiği\nggplot(data = linelist)+  \n  geom_boxplot(mapping = aes(y = age))+   # only y axis mapped (not x)\n  labs(title = \"A) Overall boxplot\")\n\n# B) Cinsiyete göre çubuk grafiği\nggplot(data = linelist, mapping = aes(y = age, x = gender, fill = gender)) + \n  geom_boxplot()+                     \n  theme(legend.position = \"none\")+   # remove legend (redundant)\n  labs(title = \"B) Boxplot by gender\")      "},{"path":"ggplot-temelleri.html","id":"violin-jitter-ve-sina-grafikleri","chapter":"30 ggplot temelleri","heading":"Violin, jitter ve sina grafikleri","text":"Aşağıda, dağılımları göstermek için violin (geom_violin) ve jitter grafiklerinin (geom_jitter) nasıl kodlandığı gösterilmiştir. Bu seçenekleri aes() içine ekleyerek dolgu veya rengin de veriler tarafından belirlenmesini sağlayabilirsiniz.ggforce paketindeki geom_sina() fonksiyonunu kullanarak iki grafiği birleştirebilirsiniz. Sina, jitter noktalarını violin grafiği şeklinde çizer. Violin grafiği üzerine eklendiğinde (şeffaflığı düzenlenerek), oluşan yeni grafiğin görsel olarak yorumlanması daha kolay olabilir.","code":"\n# A) Jitter grafiği\nggplot(data = linelist %>% drop_na(outcome),      # Eksik değerleri kaldır\n       mapping = aes(y = age,                     # Sürekli değişken\n           x = outcome,                           # Gruplama değişkeni\n           color = outcome))+                     # Renk değişkeni\n  geom_jitter()+                                  # Jitter grafiği oluştur\n  labs(title = \"A) jitter plot by gender\")     \n\n\n\n# B) Violin grafiği\nggplot(data = linelist %>% drop_na(outcome),       # Eksik değerleri kaldır\n       mapping = aes(y = age,                      # Sürekli değişken\n           x = outcome,                            # Gruplama değişkeni\n           fill = outcome))+                       # Dolgu değişkeni (renk)\n  geom_violin()+                                   # Violin grafiği oluştur\n  labs(title = \"B) violin plot by gender\")    \n# A) Sina grafiği\nggplot(\n  data = linelist %>% drop_na(outcome), \n  aes(y = age,           # numerik değişken\n      x = outcome)) +    # grup değişkeni\n  geom_violin(\n    aes(fill = outcome), # dolgu (violin grafiğinin arka planının rengi)\n    color = \"white\",     # beyaz anahat\n    alpha = 0.2)+        # şefaflık\n  geom_sina(\n    size=1,                # jitter noktalarının boyutunu değiştir\n    aes(color = outcome))+ # renk (noktaların rengi)\n  scale_fill_manual(       # Death/recovery violin grafiği arka planı için dolguyu tanımla\n    values = c(\"Death\" = \"#bf5300\", \n              \"Recover\" = \"#11118c\")) + \n  scale_color_manual(      # death/recover noktaları için renkleri tanımla\n    values = c(\"Death\" = \"#bf5300\", \n              \"Recover\" = \"#11118c\")) + \n  theme_minimal() +                                # Gri arka planı kaldır\n  theme(legend.position = \"none\") +                # Gereksiz açıklamayı kaldır\n  labs(title = \"B) violin and sina plot by gender, with extra formatting\")      "},{"path":"ggplot-temelleri.html","id":"iki-sürekli-değişken","chapter":"30 ggplot temelleri","heading":"İki sürekli değişken","text":"Benzer sözdizimini takip ederek, geom_point(), bir dağılım grafiğinde iki sürekli değişkeni birbirine karşı çizmenize izin verir. Bu, dağılımlarından ziyade gerçek değerleri göstermek için kullanışlıdır. Yaş ve kilonun temel bir dağılım grafiği ()’da gösterilmektedir. (B)’de, satır listesindeki iki sürekli değişken arasındaki ilişkiyi göstermek için yine facet_grid() fonksiyonunu kullanıyoruz.","code":"\n# Ağırlık ve yaşın temel dağılım grafiği\nggplot(data = linelist, \n       mapping = aes(y = wt_kg, x = age))+\n  geom_point() +\n  labs(title = \"A) Scatter plot of weight and age\")\n\n# Cinsiyete ve Ebola sonucuna göre ağırlık ve yaş dağılım grafiği\nggplot(data = linelist %>% drop_na(gender, outcome), # filtre eksik olmayan cinsiyeti/sonucu korur\n       mapping = aes(y = wt_kg, x = age))+\n  geom_point() +\n  labs(title = \"B) Scatter plot of weight and age faceted by gender and outcome\")+\n  facet_grid(gender ~ outcome) "},{"path":"ggplot-temelleri.html","id":"üç-sürekli-değişken","chapter":"30 ggplot temelleri","heading":"Üç sürekli değişken","text":"Bir ısı grafiği oluşturmak için fill = argümanını kullanarak üç sürekli değişkeni görüntüleyebilirsiniz. “hücrenin” rengi, üçüncü sürekli veri sütununun değerini yansıtacaktır. Daha fazla ayrıntı ve birkaç örnek için ggplot ipuçları ve Isı grafikleri hakkındaki sayfaya bakabilirsiniz.R’da 3D grafikler oluşturmanın yolları vardır, ancak uygulamalı epidemiyoloji için bunların yorumlanması genellikle zordur ve bu nedenle karar verme süreçlerinde daha az kullanılırlar.","code":""},{"path":"ggplot-temelleri.html","id":"kategorik-verilere-ait-grafikler","chapter":"30 ggplot temelleri","heading":"30.13 Kategorik verilere ait grafikler","text":"Kategorik veriler karakter değerleri, mantıksal (DOĞRU/YANLIŞ) veya faktör olabilir (Faktörler sayfasına bakınız).","code":""},{"path":"ggplot-temelleri.html","id":"hazırlık-22","chapter":"30 ggplot temelleri","heading":"Hazırlık","text":"","code":""},{"path":"ggplot-temelleri.html","id":"veri-yapısı","chapter":"30 ggplot temelleri","heading":"Veri yapısı","text":"Kategorik verileriniz hakkında anlamanız gereken ilk şey, verilerin bir satır listesi gibi ham gözlemler olarak mı yoksa sayıları veya oranları tutan bir özet veya toplu veri çerçevesi olarak mı var olduğudur. Verilerinizin durumu, kullandığınız çizim fonksiyonunu etkiler:Verileriniz gözlem başına bir satır içeren ham gözlemlerse, büyük olasılıkla geom_bar() fonksiyonunu kullanacaksınız.Verileriniz zaten sayılar veya oranlar halinde toplanmışsa, büyük olasılıkla ‘geom_col()’ fonksiyonunu kullanacaksınız.","code":""},{"path":"ggplot-temelleri.html","id":"sütun-sınıfı-ve-değer-sıralaması","chapter":"30 ggplot temelleri","heading":"Sütun sınıfı ve değer sıralaması","text":"Bu aşamadan sonra, çizmek istediğiniz sütunların sınıfını incelemelisiniz. Önce R tabanından class() ve janitor paketinden tabyl() fonksiyonuyla hospital sütununa bakıyoruz.Hastane adları olduğu ve varsayılan olarak alfabetik olarak sıralandığı için içindeki değerlerin karakter olduğunu görebiliriz. Kırılımları sunarken en son sırada olmasını tercih edeceğimiz ‘’ ve ‘Missing’ değerleri de mevcuttur. Bu yüzden bu sütunu bir faktöre değiştirip yeniden sıralıyoruz. Konu, Faktörler sayfasında daha ayrıntılı olarak ele alınmaktadır.","code":"\n# Hastane sütununun sınıfını görüntüleyin - bunun bir karakter olduğunu görebiliriz\nclass(linelist$hospital)## [1] \"character\"\n# Hastane sütunundaki değerlere ve oranlara bakın\nlinelist %>% \n  tabyl(hospital)##                              hospital    n    percent\n##                      Central Hospital  454 0.07710598\n##                     Military Hospital  896 0.15217391\n##                               Missing 1469 0.24949049\n##                                 Other  885 0.15030571\n##                         Port Hospital 1762 0.29925272\n##  St. Mark's Maternity Hospital (SMMH)  422 0.07167120\n# Faktöre dönüştürün ve seviye sırasını \"Other\" ve \"Missing\" en son olacak şekilde tanımlayın\nlinelist <- linelist %>% \n  mutate(\n    hospital = fct_relevel(hospital, \n      \"St. Mark's Maternity Hospital (SMMH)\",\n      \"Port Hospital\", \n      \"Central Hospital\",\n      \"Military Hospital\",\n      \"Other\",\n      \"Missing\"))\nlevels(linelist$hospital)## [1] \"St. Mark's Maternity Hospital (SMMH)\" \"Port Hospital\"                       \n## [3] \"Central Hospital\"                     \"Military Hospital\"                   \n## [5] \"Other\"                                \"Missing\""},{"path":"ggplot-temelleri.html","id":"ggplot_basics_bars","chapter":"30 ggplot temelleri","heading":"geom_bar()","text":"Çubuk yüksekliğinin (veya yığılmış çubuk bileşenlerinin yüksekliğinin) verilerdeki ilgili satırların sayısını yansıtmasını istiyorsanız, geom_bar() fonksiyonunu kullanmalısınız. width = çizim estetiği ayarlanmadığı sürece, bu çubukların aralarında boşluklar olacaktır.Yalnızca bir eksene sütun atayın (tipik olarak x ekseni). x ve y eksenlerinin ikisine de sütun tanımlarsanız, Error: stat_count() can x y aesthetic. hatasını alırsınız.mapping = aes() içinde bir fill = argümanına sütun ekleyerek yığılmış çubuk grafiği oluşturabilirsiniz.Karşı eksen, satır sayısını temsil ettiği için varsayılan olarak “count” olarak adlandırılacaktır.Aşağıda, sonucu y eksenine atadık, ancak bu aynı kolaylıkla x ekseni de olabilirdi. Daha uzun karakter değerleriniz varsa, bazen çubukları yana çevirip açıklamayı en alta koymak iyi bir seçenek olabilir. Bu, faktör seviyelerinizin nasıl sıralandığını etkileyebilir - bu durumda, “missing” ve “” değerlerini en alta koymak için sıralamayı fct_rev() ile tersine çeviriyoruz.","code":"\n# A) Tüm vakaların çıktıları\nggplot(linelist %>% drop_na(outcome)) + \n  geom_bar(aes(y = fct_rev(hospital)), width = 0.7) +\n  theme_minimal()+\n  labs(title = \"A) Number of cases by hospital\",\n       y = \"Hospital\")\n\n\n# B) Tüm vakaların hastaneye göre çıktıları\nggplot(linelist %>% drop_na(outcome)) + \n  geom_bar(aes(y = fct_rev(hospital), fill = outcome), width = 0.7) +\n  theme_minimal()+\n  theme(legend.position = \"bottom\") +\n  labs(title = \"B) Number of recovered and dead Ebola cases, by hospital\",\n       y = \"Hospital\")"},{"path":"ggplot-temelleri.html","id":"geom_col","chapter":"30 ggplot temelleri","heading":"geom_col()","text":"Çubuk yüksekliğinin (veya yığılmış çubuk bileşenlerinin yüksekliğinin) verilerde bulunan önceden hesaplanmış değerleri yansıtmasını istiyorsanız, geom_col() fonksiyonunu kullanmalısınız. Bunlar genellikle özet, “toplanmış” sayılar veya oranlardır.geom_col() fonksiyonunda iki eksen için de sütun atamalısınız. Tipik olarak x ekseni sütununuz ayrık verilerden oluşurken y ekseni sütununuz sayısaldır.Diyelim ki outcomes veri setimiz var:Aşağıda, Ebola hasta sonuçlarının dağılımını gösteren basit bir çubuk grafiği oluşturmak için geom_col fonksiyonu kullanılmıştır. geom_col fonksiyonunda hem x hem de y tanımlanmalıdır. Burada x kategorik değişkendir ve y “oran”dır.Hastanelere göre dağılımları göstermek için tablomuzun daha fazla bilgi içermesi ve “long” formatında olması gerekir. Bu tabloyu outcome ve hospital birleşik kategorilerinin frekanslarıyla oluşturuyoruz (gruplandırma ipuçları için [Gruplama verileri] sayfasına bakabilirsiniz).Daha sonra bazı ek biçimlendirmelerle ggplot’u oluştururuz:Axis flip: Hastane isimlerini okuyabilmemiz için ekseni coord_flip() fonksiyonu ile değiştirdik.Columns side--side: Ölüm ve iyileşme çubuklarının yığılması yerine yan yana sunulması için bir position = \"dodge\" argümanı eklendi. yığılmış çubuklar varsayılandır.Column width: ‘Genişlik’ tanımlanır, bu nedenle sütunlar mümkün olan tam genişliğin yarısı kadar incelir.Column order: ‘’ ve ‘Missing’ altta olacak şekilde, scale_x_discrete(limits=rev) ile kategorilerin sırasını y ekseninde tersine çevrildi. scale_y_discrete yerine x kullandığımıza dikkat edin, çünkü hastane aes()’x argümanında tanımlanmıştır. (görsel olarak y ekseninde olsa bile). Bunu yapıyoruz çünkü Ggplot, biz tersini söylemedikçe kategorileri geriye doğru sıralamaktadır.details: Sırasıyla labs ve scale_fill_color argümanları içine eklenen etiket/başlık ve renkler.Oranların ikili olduğuna dikkat edin, bu nedenle ‘recover’ verilerini bırakıp sadece ölen oranını göstermeyi tercih edebiliriz. Bu sadece örnekleme amaçlıdır.Tarih verilerinde geom_col() fonksiyonunu kullanıyorsanız (örneğin, toplu verilerden bir dış eğri) - çubuklar arasındaki “boşluğu” kaldırmak için width = argümanını ayarlamalısınız. Günlük veri seti kullanılıyorsa width = 1. Haftalık ise, width = 7. Ayların düzgün bir şekilde gösterilmesi mümkün değildir çünkü ayın gün sayısı bir diğerinden farklıdır.","code":"## # A tibble: 2 × 3\n##   outcome     n proportion\n##   <chr>   <int>      <dbl>\n## 1 Death    1022       56.2\n## 2 Recover   796       43.8\n# Tüm vakaların çıktıları\nggplot(outcomes) + \n  geom_col(aes(x=outcome, y = proportion)) +\n  labs(subtitle = \"Number of recovered and dead Ebola cases\")\noutcomes2 <- linelist %>% \n  drop_na(outcome) %>% \n  count(hospital, outcome) %>%  # hastaneye ve sonuca göre sayımları al\n  group_by(hospital) %>%        # Oranlar hastane toplamı dışında olacak şekilde gruplandır\n  mutate(proportion = n/sum(n)*100) # hastane toplamının oranlarını hesapla\n\nhead(outcomes2) # verili göster## # A tibble: 6 × 4\n## # Groups:   hospital [3]\n##   hospital                             outcome     n proportion\n##   <fct>                                <chr>   <int>      <dbl>\n## 1 St. Mark's Maternity Hospital (SMMH) Death     199       61.2\n## 2 St. Mark's Maternity Hospital (SMMH) Recover   126       38.8\n## 3 Port Hospital                        Death     785       57.6\n## 4 Port Hospital                        Recover   579       42.4\n## 5 Central Hospital                     Death     193       53.9\n## 6 Central Hospital                     Recover   165       46.1\n# Tüm vakaların hastaneye göre çıktıları\nggplot(outcomes2) +  \n  geom_col(\n    mapping = aes(\n      x = proportion,                 # önceden hesaplanmış orantı değerlerini göster\n      y = fct_rev(hospital),          # missing/other altta kalması için ters çevir\n      fill = outcome),                # sonuca göre yığılmış\n    width = 0.5)+                    # daha ince çubuklar (max: 1)\n  theme_minimal() +                  # Minimal tema \n  theme(legend.position = \"bottom\")+\n  labs(subtitle = \"Number of recovered and dead Ebola cases, by hospital\",\n       fill = \"Outcome\",             # açıklama başlığı\n       y = \"Count\",                  # y ekseni başlığı\n       x = \"Hospital of admission\")+ # x ekseni başlığı\n  scale_fill_manual(                 # renkleri manuel ekle\n    values = c(\"Death\"= \"#3B1c8C\",\n               \"Recover\" = \"#21908D\" )) "},{"path":"ggplot-temelleri.html","id":"geom_histogram","chapter":"30 ggplot temelleri","heading":"geom_histogram()","text":"Histogramlar çubuk grafikler gibi görünebilir, ancak farklıdır çünkü sürekli bir değişkenin dağılımını ölçerler. “Çubuklar” arasında boşluk yoktur ve geom_histogram() fonksiyonu için yalnızca bir sütun gerekir. Verilerin nasıl gruplanacağını belirtmek için bin_width = ve breaks = gibi histograma özgü argümanlar vardır. Yukarıdaki sürekli verilerle ilgili bölüm ve Salgın eğrileri sayfasaında daha detaylı bilgi bulabilirsiniz.","code":""},{"path":"ggplot-temelleri.html","id":"kaynaklar-23","chapter":"30 ggplot temelleri","heading":"30.14 Kaynaklar","text":"Özellikle ggplot ile ilgili çevrimiçi olarak çok miktarda kaynak mevcuttur. Bunlardan bazıları:ggplot2 kopya kağıdıbaşka bir kopya kağıdıtidyverse ggplot temelleri sayfasısürekli değişkenleri çizmekVeri Bilimi için R’da veri görselleştirme bölümüiletişim için grafikler","code":""},{"path":"ggplot-ipuçları.html","id":"ggplot-ipuçları","chapter":"31 ggplot ipuçları","heading":"31 ggplot ipuçları","text":"Bu sayfada, ggplot’larınızı keskin ve gösterişli hale getirmek için ipuçlarını ve püf noktalarını ele alacağız. Temel bilgiler için ggplot temelleri sayfasına bakabilirsiniz.Kaynaklar bölümünde bağlantılı birkaç kapsamlı ggplot2 eğitimi vardır. Bu ggplot hatırlatma sayfası ile veri görselleştirmeyi RStudio web sitesinden de indirebilirsiniz. İlham almak için R grafiği galerisi ve Data--viz sayfalarını incelemenizi şiddetle tavsiye ederiz.","code":""},{"path":"ggplot-ipuçları.html","id":"hazırlık-23","chapter":"31 ggplot ipuçları","heading":"31.1 Hazırlık","text":"","code":""},{"path":"ggplot-ipuçları.html","id":"paketleri-yükleme-8","chapter":"31 ggplot ipuçları","heading":"Paketleri yükleme","text":"Bu kod parçası, analizler için gereken paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan ‘p_load()’ vurgusunu yapıyoruz. R tabanından library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakabilirsiniz.","code":"\npacman::p_load(\n  tidyverse,      # ggplot2 ve diğerlerini içerir\n  rio,            # içe / dışa aktar\n  here,           # dosyayı bul\n  stringr,        # karakterlerle çalışmak   \n  scales,         # sayıları çevirmek\n  ggrepel,        # akıllıca yerleştirilmiş etiketler\n  gghighlight,    # arsanın bir bölümünü vurgula\n  RColorBrewer    # renk skalaları\n)"},{"path":"ggplot-ipuçları.html","id":"verileri-içe-aktarma-6","chapter":"31 ggplot ipuçları","heading":"Verileri içe aktarma","text":"Bu sayfa için, simüle edilmiş bir Ebola salgınından vakaların veri setini içe aktarıyoruz. Takip etmek isterseniz, “clean” dosyasını indirmek için tıklayın. (.rds dosyası olarak). rio paketinden import() fonksiyonuyla verileri içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe aktarma ve dışa aktarma] sayfasına bakabilirsiniz).Satır listesinin ilk 50 satırı aşağıda görüntülenir.","code":"\nlinelist <- rio::import(\"linelist_cleaned.rds\")"},{"path":"ggplot-ipuçları.html","id":"ggplot_tips_colors","chapter":"31 ggplot ipuçları","heading":"31.2 Renk, dolgu, eksen vb. için ölçekler","text":"ggplot2’de, çizilen verilerin estetiği (ör. boyut, renk, şekil, dolgu, çizim ekseni) verilerdeki sütunlarla eşlendiğinde, tam görüntü ilgili “ölçek” komutuyla ayarlanabilir. Bu bölümde bazı yaygın ölçek ayarlamalarını açıklıyoruz.","code":""},{"path":"ggplot-ipuçları.html","id":"renk-şemaları","chapter":"31 ggplot ipuçları","heading":"31.2.1 Renk şemaları","text":"ggplot2 ile başlangıçta anlaşılması zor olabilecek bir şey, renk şemalarının kontrolüdür. Bu bölümün noktalar, çubuklar, çizgiler, döşemeler vb. çizim nesnelerinin (geomlar/şekiller) rengini tartıştığını unutmayın. Aksesuar metninin, başlıkların veya arka plan renginin rengini ayarlamak için ggplot temelleri sayfasının bölümü olan Temalar bölümüne bakınız.Arsa nesnelerinin “rengini” kontrol etmek için, ya renk = estetiğini (dış renk) ya da dolgu = estetiğini (iç renk) ayarlayacaksınız. Bu modelin bir istisnası, gerçekten yalnızca noktanın rengini (iç ve dış) kontrol eden ‘color =’ öğesini kontrol edebileceğiniz ‘geom_point()’ fonksiyonudur.Renk veya dolguyu ayarlarken “kırmızı” gibi R tarafından tanınan renk adlarını kullanabilir (bkz. tam liste veya ?colors) veya “#ff0505”` gibi belirli bir onaltılık renkler kullanılabilir.[Gggplot temelleri] bölümünde verileri çizime eşleme ile ilgili olarak açıklandığı gibi, ‘fill =’ ve ‘color =’ gibi estetikler bir ‘mapping = aes()’ ifadesinin dışında veya birinin içinde tanımlanabilir. “aes()” * dışında* ise, atanan değer statik olmalıdır (ör. ‘color= “mavi”’) ve geom tarafından çizilen tüm veriler için geçerli olacaktır. içeride ise, estetik, ‘renk = hastane”’ gibi bir sütuna eşlenmelidir ve ifade, verilerdeki o satırın değerine göre değişecektir. Birkaç örnek:","code":"\n# histogram - \nggplot(data = linelist, mapping = aes(x = age))+       # veri ve eksenleri ayarla\n  geom_histogram(                # histogram göster\n    binwidth = 7,                # kutu genişliği\n    color = \"red\",               # kutu çizgi rengi\n    fill = \"lightblue\")          # kutu iç rengi (dolgu) \n# Noktalar ve çizgi için statik renk\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     \n  geom_point(color = \"purple\")+\n  geom_vline(xintercept = 50, color = \"orange\")+\n  labs(title = \"Static color for points and line\")\n\n# Sürekli sütuna eşlenen renk\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     \n  geom_point(mapping = aes(color = temp))+         \n  labs(title = \"Color mapped to continuous column\")\n\n# Ayrık sütuna eşlenen renk\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     \n  geom_point(mapping = aes(color = gender))+         \n  labs(title = \"Color mapped to discrete column\")\n\n# çubuk grafiği, ayrı sütuna doldur, statik değere renk\nggplot(data = linelist, mapping = aes(x = hospital))+     \n  geom_bar(mapping = aes(fill = gender), color = \"yellow\")+         \n  labs(title = \"Fill mapped to discrete column, static color\")"},{"path":"ggplot-ipuçları.html","id":"ggplot_tips_scales","chapter":"31 ggplot ipuçları","heading":"Ölçekler","text":"Bir sütunu bir çizim estetiğine eşlediğinizde (örneğin, x =, y =, fill =, color =…), grafiğiniz bir ölçek/lejand kazanacaktır. Yukarıda, atanan sütunun sınıfına bağlı olarak ölçeğin sürekli, ayrık, tarih vb. değerlerinin nasıl olabileceğini görün. Sütunlara eşlenmiş birden fazla estetiğiniz varsa, arsanızın birden çok ölçeği olacaktır.Uygun scales_() fonksiyonu ile terazileri kontrol edebilirsiniz. ggplot()’un ölçek fonksiyonlarının şu şekilde yazılmış 3 bölümü vardır: scale_AESTHETIC_METHOD().İlk kısım olan scale_() düzeltildi.İkinci kısım olan ESTETİK, ölçeği ayarlamak istediğiniz estetik olmalıdır (_fill_, _shape_, _color_, _size_, _alpha_…) - buradaki seçenekler de ‘x’ ve ‘y’ içerir.Üçüncü kısım olan YÖNTEM, sütunun sınıfına ve nasıl kontrol etmek istediğine bağlı olarak _discrete(), continuous(), _date(), _gradient() veya _manual() olacaktır. Başkaları da var, ancak bunlar en sık kullanılanlardır.Tartı için doğru işlevi kullandığınızdan emin olun! Aksi takdirde, ölçek komutunuz hiçbir şeyi değiştirmiş gibi görünmeyecektir. Birden fazla teraziniz varsa, bunları ayarlamak için birden fazla terazi işlevi kullanabilirsiniz! Örneğin:","code":""},{"path":"ggplot-ipuçları.html","id":"ölçek-değişkenleri","chapter":"31 ggplot ipuçları","heading":"Ölçek değişkenleri","text":"Bazı örtüşmeler olsa da, tür ölçeğin kendi değişkenleri vardır. Fonksiyon değişkeni belgelerini görmek için R konsolunda ?scale_color_discrete gibi fonksiyonu sorgulayabilirsiniz.Sürekli ölçekler için, ‘seq()’ ile bir değerler dizisi sağlamak için ‘breaks =’ kullanın (aşağıdaki örnekte gösterildiği gibi ‘=’, ‘=’ ve ‘=’ alın. Eksenlerin etrafındaki dolgu alanını ortadan kaldırmak için “expand= c(0,0)” değerini ayarlayın (bu herhangi bir “x” veya “y” ölçeğinde kullanılabilir.Ayrık ölçekler için, seviye görünümünün sırasını breaks = ile ve değerlerin nasıl görüntüleneceğini labels = değişkeniyle ayarlayabilirsiniz. Bunların birine bir karakter vektörü sağlayın (aşağıdaki örneğe bakın). Ayrıca, “na.translate = FALSE” ayarını yaparak “NA”yı kolayca bırakabilirsiniz.Tarih ölçeklerinin nüansları, Salgın eğrileri sayfasında daha kapsamlı bir şekilde ele alınmaktadır.","code":""},{"path":"ggplot-ipuçları.html","id":"manuel-ayarlamalar","chapter":"31 ggplot ipuçları","heading":"Manuel ayarlamalar","text":"En kullanışlı püf noktalardan biri, renkleri açıkça istediğiniz gibi atamak için “manuel” ölçekleme fonksiyonlarını kullanmaktır. Bunlar, “scale_xxx_manual()” sözdizimine sahiptir(ör. “scale_colour_manual()” veya “scale_fill_manual()”). Aşağıdaki bağımsız değişkenlerin biri aşağıdaki kod örneğinde gösterilmiştir.values = değişkeniyle veri değerlerine renkler atayın‘NA’ için ‘na.value =’ ile bir renk belirtinGöstergede değerlerin nasıl yazılacağını labels = değişkeni ile değiştirinGösterge başlığını name = ile değiştirinAşağıda, bir çubuk grafiği oluşturuyoruz ve varsayılan olarak nasıl göründüğünü gösteriyoruz ve ardından üç ölçek ayarlıyoruz - sürekli y ekseni ölçeği, ayrık x ekseni ölçeği ve dolgunun manuel olarak ayarlanması (iç çubuk rengi).","code":"\n# TEMEL - ölçek ayarı yok\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = outcome, fill = gender))+\n  labs(title = \"Baseline - no scale adjustments\")\n# AYARLANAN ÖLÇEKLER\nggplot(data = linelist)+\n  \n  geom_bar(mapping = aes(x = outcome, fill = gender), color = \"black\")+\n  \n  theme_minimal()+                   # arka planı basitleştir\n  \n  scale_y_continuous(                # y ekseni için sürekli ölçek (sayılar)\n    expand = c(0,0),                 # dolgu yok\n    breaks = seq(from = 0,\n                 to = 3000,\n                 by = 500))+\n  \n  scale_x_discrete(                   # x ekseni için ayrık ölçek (cinsiyet)\n    expand = c(0,0),                  # dolgu yok\n    drop = FALSE,                     # tüm faktör seviyelerini göster (verilerde olmasa bile)\n    na.translate = FALSE,             # Boş sonuçlarını grafikten kaldır\n    labels = c(\"Died\", \"Recovered\"))+ # Değerlerin gösterimini değiştir\n    \n  \n  scale_fill_manual(                  # Dolguyu manuel olarak belirtin (çubuk iç rengi)\n    values = c(\"m\" = \"violetred\",     # renk atamak için verilerdeki referans değerleri\n               \"f\" = \"aquamarine\"),\n    labels = c(\"m\" = \"Male\",          # lejandı yeniden etiketleyin (hataları önlemek için \"=\" atamasını kullanın)\n              \"f\" = \"Female\",\n              \"Missing\"),\n    name = \"Gender\",                  # lejand başlığı\n    na.value = \"grey\"                 # eksik değerler için bir renk atama\n  )+\n  labs(title = \"Adjustment of scales\") # Doldurma açıklamasının başlığını ayarlayın"},{"path":"ggplot-ipuçları.html","id":"sürekli-eksen-ölçekleri","chapter":"31 ggplot ipuçları","heading":"Sürekli eksen ölçekleri","text":"Veriler çizim eksenlerine eşlendiğinde, bunlar da ölçek komutlarıyla ayarlanabilir. Yaygın bir örnek, sürekli veriler içeren bir sütuna eşlenen bir eksenin (ör. y ekseni) görüntüsünü ayarlamaktır.scale_y_continuous() kullanarak ggplot’taki değerlerin kesintilerini veya gösterimini ayarlamak isteyebiliriz. Yukarıda belirtildiği gibi, ölçek boyunca “kesmeler” olarak hizmet edecek bir değerler dizisi sağlamak için “kesmeler =” bağımsız değişkenini kullanın. Bunlar sayıların görüntüleneceği değerlerdir. Bu bağımsız değişkene, istenen kesme değerlerini içeren bir “c()” vektörü sağlayabilir veya R tabanı fonksiyonu “seq()” kullanarak düzenli bir sayı dizisi sağlayabilirsiniz. Bu ‘seq()’ fonksiyonu ‘=’, ‘=’ ve ‘=’ kabul eder.","code":"\n# TEMEL - ölçek ayarı yok\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = outcome, fill = gender))+\n  labs(title = \"Baseline - no scale adjustments\")\n\n\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = outcome, fill = gender))+\n  scale_y_continuous(\n    breaks = seq(\n      from = 0,\n      to = 3000,\n      by = 100)\n  )+\n  labs(title = \"Adjusted y-axis breaks\")"},{"path":"ggplot-ipuçları.html","id":"yüzdeleri-göster","chapter":"31 ggplot ipuçları","heading":"Yüzdeleri göster","text":"Orijinal veri değerleriniz oranlarsa, aşağıda gösterildiği gibi ölçekler komutunuzda labels = scales::percent sağlayarak bunları kolayca “%” ile yüzdeler olarak görüntüleyebilirsiniz.Bir alternatif, değerleri karaktere dönüştürmek ve sona “%” karakteri eklemek olsa da, verileriniz artık sürekli sayısal değerler olmayacağından bu yaklaşım sorunlara yol açacaktır.","code":"\n# Orjinal y ekseni oranları\n#############################\nlinelist %>%                                   # satır listesi ile başlama\n  group_by(hospital) %>%                       # veriyi hastaneye göre gruplandırma\n  summarise(                                   # özet kolonlar oluşturma\n    n = n(),                                     # gruptaki toplam satır sayısı\n    deaths = sum(outcome == \"Death\", na.rm=T),   # gruptaki ölüm sayısı\n    prop_death = deaths/n) %>%                   # gruptaki ölüm oranı\n  ggplot(                                      # çizime başlama\n    mapping = aes(\n      x = hospital,\n      y = prop_death))+ \n  geom_col()+\n  theme_minimal()+\n  labs(title = \"Display y-axis original proportions\")\n\n\n\n# Y ekseni oranlarını yüzdelik olarak gösterme\n########################################\nlinelist %>%         \n  group_by(hospital) %>% \n  summarise(\n    n = n(),\n    deaths = sum(outcome == \"Death\", na.rm=T),\n    prop_death = deaths/n) %>% \n  ggplot(\n    mapping = aes(\n      x = hospital,\n      y = prop_death))+\n  geom_col()+\n  theme_minimal()+\n  labs(title = \"Display y-axis as percents (%)\")+\n  scale_y_continuous(\n    labels = scales::percent                   \n  )"},{"path":"ggplot-ipuçları.html","id":"logaritmik-ölçeği","chapter":"31 ggplot ipuçları","heading":"Logaritmik ölçeği","text":"Sürekli bir ekseni logaritmik ölçeğine dönüştürmek için, ölçek komutuna trans = \"log2\" ekleyin. Örnek olarak, ilgili ‘preparedness_index’ ve kümülatif vaka değerleri ile bölgelerin bir veri çerçevesini oluşturuyoruz.“” bölgesi için kümülatif vakalar, diğer tüm bölgelerden çarpıcı biçimde daha fazladır. Bunun gibi durumlarda, okuyucunun daha az kümülatif vaka ile bölgeler arasındaki farklılıkları görebilmesi için bir logaritmik ölçeği kullanarak y eksenini görüntülemeyi seçebilirsiniz.","code":"\nplot_data <- data.frame(\n  region = c(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\"),\n  preparedness_index = c(8.8, 7.5, 3.4, 3.6, 2.1, 7.9, 7.0, 5.6, 1.0),\n  cases_cumulative = c(15, 45, 80, 20, 21, 7, 51, 30, 1442)\n)\n\nplot_data##   region preparedness_index cases_cumulative\n## 1      A                8.8               15\n## 2      B                7.5               45\n## 3      C                3.4               80\n## 4      D                3.6               20\n## 5      E                2.1               21\n## 6      F                7.9                7\n## 7      G                7.0               51\n## 8      H                5.6               30\n## 9      I                1.0             1442\n# Orijinal y ekseni\npreparedness_plot <- ggplot(data = plot_data,  \n       mapping = aes(\n         x = preparedness_index,\n         y = cases_cumulative))+\n  geom_point(size = 2)+            # her bölgeye nokta \n  geom_text(\n    mapping = aes(label = region),\n    vjust = 1.5)+                  # yazı etiketleri ekleme\n  theme_minimal()\n\npreparedness_plot                  # orijinal grafiği yazdıe\n\n\n# dönüştürülmüş y ekseni ile yazdır\npreparedness_plot+                   # yukarıda kaydedilen grafik ile başlayın\n  scale_y_continuous(trans = \"log2\") # y ekseni için dönüşüm ekle"},{"path":"ggplot-ipuçları.html","id":"gradyan-ölçekleri","chapter":"31 ggplot ipuçları","heading":"Gradyan ölçekleri","text":"Dolgu gradyan ölçekleri ek nüanslar içerebilir. Varsayılanlar genellikle oldukça hoştur, ancak değerleri, kesmeleri vb. ayarlamak isteyebilirsiniz.Sürekli bir renk skalasının nasıl ayarlanacağını göstermek için, vakaların yaşlarını ve kaynak vakalarını içeren Temaslı izlemi sayfasından bir veri seti kullanacağız.Aşağıda, bir “hücresel” ısı karosu yoğunluk grafiği üretiyoruz. Nasıl olduğunu detaylandırmayacağız (yukarıdaki paragraftaki bağlantıya bakabilirsiniz) ancak renk skalasını nasıl ayarlayabileceğimize odaklanacağız. stat_density2d() ggplot2 fonksiyonu hakkında buradan daha fazla bilgi edinebilirsiniz. fill ölçeğinin nasıl sürekli olduğuna dikkat edin.Şimdi doldurma ölçeğinde bazı varyasyonlar gösteriyoruz:Şimdi ölçeğin kırılma noktalarını ayarlamanın bazı örneklerini gösteriyoruz:scale_fill_gradient() iki rengi kabul eder (yüksek/düşük)scale_fill_gradientn() herhangi bir uzunluktaki bir renk vektörünü “değerler =” olarak kabul eder (ara değerler eklemlenmiş olacaktır)scales::rescale() renklerin gradyan boyunca nasıl konumlandırılacağını ayarlamak için kullanılır. Konum vektörünüzü 0 ile 1 arasında olacak şekilde yeniden ölçeklendirir.","code":"\ncase_source_relationships <- rio::import(here::here(\"data\", \"godata\", \"relationships_clean.rds\")) %>% \n  select(source_age, target_age) \ntrans_matrix <- ggplot(\n    data = case_source_relationships,\n    mapping = aes(x = source_age, y = target_age))+\n  stat_density2d(\n    geom = \"raster\",\n    mapping = aes(fill = after_stat(density)),\n    contour = FALSE)+\n  theme_minimal()\ntrans_matrix\ntrans_matrix + scale_fill_viridis_c(option = \"plasma\")\ntrans_matrix + \n  scale_fill_gradient(     # Çift taraflı gradyan ölçeği\n    low = \"aquamarine\",    # düşük değer\n    high = \"purple\",       # yüksek değer\n    na.value = \"grey\",     # Boş için değer\n    name = \"Density\")+     # Lejand Başlığı\n  labs(title = \"Manually specify high/low colors\")\n\n# Ölçeklendirmek 3+ renk\ntrans_matrix + \n  scale_fill_gradientn(    # 3 renkli ölçek (low/mid/high)\n    colors = c(\"blue\", \"yellow\",\"red\") # y dönüş için yeterli\n  )+\n  labs(title = \"3-color scale\")\n\n# Ölçek boyunca renklerin yerleşimini ayarlamak için rescale() kullanımı\ntrans_matrix + \n  scale_fill_gradientn(    # herhangi bir sayıda rengi sağlamak\n    colors = c(\"blue\", \"yellow\",\"red\", \"black\"),\n    values = scales::rescale(c(0, 0.05, 0.07, 0.10, 0.15, 0.20, 0.3, 0.5)) # renkler için konumlar 0 ile 1 arasında yeniden ölçeklenir\n    )+\n  labs(title = \"Colors not evenly positioned\")\n\n# dolgu rengini alan kesme değerleri için sınırların kullanılması\ntrans_matrix + \n  scale_fill_gradientn(    \n    colors = c(\"blue\", \"yellow\",\"red\"),\n    limits = c(0, 0.0002))+\n  labs(title = \"Restrict value limits, resulting in grey space\")"},{"path":"ggplot-ipuçları.html","id":"paletler","chapter":"31 ggplot ipuçları","heading":"Paletler","text":"","code":""},{"path":"ggplot-ipuçları.html","id":"colorbrewer-ve-viridis","chapter":"31 ggplot ipuçları","heading":"Colorbrewer ve Viridis","text":"Daha genel olarak, önceden tanımlanmış paletler istiyorsanız, “scale_xxx_brewer” veya “scale_xxx_viridis_y” fonksiyonlarını kullanabilirsiniz.‘brewer’ fonksiyonları colorbrewer.org paletlerinden çizim yapabilir.‘viridis’ fonksiyonları, viridis (renk körü dostu!) paletlerinden alınmıştır, bunlar “hem renkli hem de siyah-beyaz olarak algısal olarak tek biçimli renk haritaları sağlar. Ayrıca, yaygın renk körlüğü biçimlerine sahip izleyiciler tarafından algılanmak üzere tasarlanmıştır. (daha fazlasını buradan ve buradan okuyabilirsiniz). Fonksiyonun sonunda bunu belirterek paletin ayrık, sürekli veya ikili olup olmadığını tanımlayın (örneğin ayrık ‘scale_xxx_viridis_d’ dir).Grafiğinizi bu renk körlüğü simülatöründe test etmeniz önerilir. Kırmızı/yeşil renk düzeniniz varsa, bunun yerine soğuk (kırmızı-mavi) bir şema deneyin buradaİşte çeşitli renk şemaları kullanan [ggplot basics] sayfasından bir örnek.","code":"\nsymp_plot <- linelist %>%                                         # satırlistesi ile başla\n  select(c(case_id, fever, chills, cough, aches, vomit)) %>%     # sütunları seç\n  pivot_longer(                                                  # daha uzun döndür\n    cols = -case_id,                                  \n    names_to = \"symptom_name\",\n    values_to = \"symptom_is_present\") %>%\n  mutate(                                                        # eksik verileri tamamla\n    symptom_is_present = replace_na(symptom_is_present, \"unknown\")) %>% \n  ggplot(                                                        # ggplot'a başla\n    mapping = aes(x = symptom_name, fill = symptom_is_present))+\n  geom_bar(position = \"fill\", col = \"black\") +                    \n  theme_classic() +\n  theme(legend.position = \"bottom\")+\n  labs(\n    x = \"Symptom\",\n    y = \"Symptom status (proportion)\"\n  )\n\nsymp_plot  # kendinden olan renkleri yazdır\n\n#################################\n# el ile özelleştirdiğin renkleri yazdır\nsymp_plot +\n  scale_fill_manual(\n    values = c(\"yes\" = \"black\",         # renkleri açıkça tanımla\n               \"no\" = \"white\",\n               \"unknown\" = \"grey\"),\n    breaks = c(\"yes\", \"no\", \"unknown\"), # faktörleri doğru sırala\n    name = \"\"                           # lejandı başlıksız olarak ayarla\n\n  ) \n\n#################################\n# viridis ile ayrık renklerle yazdırın\nsymp_plot +\n  scale_fill_viridis_d(\n    breaks = c(\"yes\", \"no\", \"unknown\"),\n    name = \"\"\n  )"},{"path":"ggplot-ipuçları.html","id":"ayrık-değişkenlerin-sırasını-değiştirmek","chapter":"31 ggplot ipuçları","heading":"31.3 Ayrık değişkenlerin sırasını değiştirmek","text":"Kesikli değişkenlerin göründüğü sırayı değiştirmek, genellikle “ggplot2” grafiklerinde yeni olan kişiler için anlaşılması zordur. Bunu nasıl yapacağınızı anlamak kolaydır, ancak ’ggplot2’nin başlık altında ayrık değişkenleri nasıl ele aldığını anladıktan sonra. Genel olarak konuşursak, ayrı bir değişken kullanılıyorsa, otomatik olarak bir “faktör” türüne dönüştürülür - bu, faktörleri varsayılan olarak alfabetik sıraya göre sıralar. Bunu halletmek için, grafikte görünmesini istediğiniz sırayı yansıtacak şekilde faktör düzeylerini yeniden sıralamanız yeterlidir. “Faktör” nesnelerinin nasıl yeniden sıralanacağı hakkında daha ayrıntılı bilgi için kılavuzun faktör bölümüne bakabilirsiniz.Yaş gruplarını kullanarak yaygın bir örneğe bakabiliriz - varsayılan olarak 5-9 yaş grubu yaş gruplarının ortasına yerleştirilir (alfanumerik sıra verilir), ancak faktörleri yeniden seviyelendirerek onu 0-4 yaş grubunun arkasına taşıyabiliriz.","code":"\nggplot(\n  data = linelist %>% drop_na(age_cat5),                         # age_cat5'in eksik olduğu satırları kaldırın\n  mapping = aes(x = fct_relevel(age_cat5, \"5-9\", after = 1))) +  # faktörü yeniden seviyelendirin\n\n  geom_bar() +\n  \n  labs(x = \"Age group\", y = \"Number of hospitalisations\",\n       title = \"Total hospitalisations by age group\") +\n  \n  theme_minimal()"},{"path":"ggplot-ipuçları.html","id":"ggthemr","chapter":"31 ggplot ipuçları","heading":"31.3.0.1 ggthemr","text":"Ayrıca ggthemr paketini kullanmayı düşünün. Bu paketi buradaki talimatları kullanarak Github’dan indirebilirsiniz. Estetik açıdan çok hoş paletler sunar, ancak bunların tipik olarak 7 veya 8’den fazla renk istiyorsanız sınırlayıcı olabilecek maksimum sayıda değere sahip olduğunu unutmayın.","code":""},{"path":"ggplot-ipuçları.html","id":"kontur-çizgileri","chapter":"31 ggplot ipuçları","heading":"31.4 Kontur çizgileri","text":"Kontur grafikleri, birbirini kapsayabilecek birçok noktanız olduğunda (“üst çizim”) yardımcı olur. Yukarıda kullanılan durum-kaynak verileri tekrar çizilir, ancak daha basit bir şekilde ‘stat_density2d()’ ve ‘stat_density2d_filled()’ kullanılarak - bir topografik harita gibi - ayrı kontur seviyeleri elde edilir. İstatistikler hakkında daha fazla bilgiyi buradan okuyabilirsiniz.","code":"\ncase_source_relationships %>% \n  ggplot(aes(x = source_age, y = target_age))+\n  stat_density2d()+\n  geom_point()+\n  theme_minimal()+\n  labs(title = \"stat_density2d() + geom_point()\")\n\n\ncase_source_relationships %>% \n  ggplot(aes(x = source_age, y = target_age))+\n  stat_density2d_filled()+\n  theme_minimal()+\n  labs(title = \"stat_density2d_filled()\")"},{"path":"ggplot-ipuçları.html","id":"marjinal-dağılımlar","chapter":"31 ggplot ipuçları","heading":"31.5 Marjinal dağılımlar","text":"Bir “geom_point()” dağılım grafiğinin kenarlarındaki dağılımları göstermek için, ggExtra paketini ve onun “ggMarginal()” fonksiyonunu kullanabilirsiniz. Orijinal ggplot’unuzu bir nesne olarak kaydedin, ardından aşağıda gösterildiği gibi ggMarginal() öğesine iletin. İşte temel değikenler:type = değerini “histogram”, “density” “boxplot”, “violin” veya “densigram” olarak belirtmelisiniz.Varsayılan olarak, iki eksen için de marjinal grafikler görünecektir. Yalnızca bir tane istiyorsanız, margins = öğesini “x” veya “y” olarak ayarlayabilirsiniz.Diğer isteğe bağlı argümanlar arasında fill = (çubuk rengi), color = (çizgi rengi), size = (sınır boyutuna göre grafik boyutu, dolayısıyla daha büyük sayı marjinal grafiği küçültür).xparams = ve yparams = için eksene özel başka değişkenler sağlayabilirsiniz. Örneğin, aşağıda gösterildiği gibi farklı histogram kutusu boyutlarına sahip olunablir.Marjinal grafiklerin grupları yansıtmasını sağlayabilirsiniz (“ggplot()” eşleme estetiğinizde “color =” atanan sütunlar). Bu durumda, “ggMarginal()” bağımsız değişkeni “groupColour =” veya “groupFill =” aşağıda gösterildiği gibi “TRUE” olarak ayarlayın.Detaylı bilgiye R fonksiyonu ?ggMarginal veya Bu gösterim, R Graph Gallery yoluyla erişebilirsiniz.Marjinal histogramlar eklemek için type = \"histogram\" kullanın. Sıralanmış histogramları almak için isteğe bağlı olarak “groupFill = TRUE” ayarını yapabilirsiniz.Gruplandırılmış/renkli değerlerle marjinal yoğunluk grafiği:Marjinal grafiğin göreli boyutunu ayarlamak için size = değişkenini ayarlayın. Daha küçük sayı, daha büyük bir marjinal grafik yapar. Ayrıca color= ve aşağıda, yalnızca bir eksende görünmesi için “margins =” değişkeni gösterimi ile bir marjinal kutu grafiği verilmiştir:","code":"\n# ggExtra'yı kurun/yükleyin\npacman::p_load(ggExtra)\n\n# Ağırlık ve yaşın temel saçılım grafiği\nscatter_plot <- ggplot(data = linelist)+\n  geom_point(mapping = aes(y = wt_kg, x = age)) +\n  labs(title = \"Scatter plot of weight and age\")\n# histogramlar ile\nggMarginal(\n  scatter_plot,                     # marjinal histogramlar ekle\n  type = \"histogram\",               # histogramları belirtmek\n  fill = \"lightblue\",               # çubuk doldurma\n  xparams = list(binwidth = 10),    # x ekseni marjinali için diğer parametreler\n  yparams = list(binwidth = 5))     # y ekseni marjinal için diğer parametreler\n# Sonuca göre renklendirilmiş dağılım grafiği\n# Sonuç sütunu ggplot'ta renk olarak atanır. (groupFill in ggMarginal TRUE olarak ayarlandı)\nscatter_plot_color <- ggplot(data = linelist %>% drop_na(gender))+\n  geom_point(mapping = aes(y = wt_kg, x = age, color = gender)) +\n  labs(title = \"Scatter plot of weight and age\")+\n  theme(legend.position = \"bottom\")\n\nggMarginal(scatter_plot_color, type = \"density\", groupFill = TRUE)\n# kutu grafiği ile \nggMarginal(\n  scatter_plot,\n  margins = \"x\",      # sadece x ekseni marjinal grafiğini göster\n  type = \"boxplot\")   "},{"path":"ggplot-ipuçları.html","id":"akıllı-etiketleme","chapter":"31 ggplot ipuçları","heading":"31.6 Akıllı Etiketleme","text":"ggplot2’de çizimlere metin eklemek de mümkündür. Bununla birlikte, metin etiketlerinin genellikle bir grafikteki veri noktalarıyla çatıştığı, dağınık veya okunması zor görünmelerine neden olan dikkate değer bir sınırlama mevcuttur. Temel pakette bununla başa çıkmanın ideal bir yolu yoktur, ancak bununla uğraşmayı çok basit hale getiren ggrepel olarak bilinen bir ggplot2 eklentisi vardır.ggrepel paketi, “geom_label()” ve “geom_text()” fonksiyonlarının yerine geçen “geom_label_repel()” ve “geom_text_repel()” adlı iki yeni fonksiyon sağlar. Düzgün etiketler üretmek için bunları kullanabilirsiniz. Fonksiyon içinde, “aes()” estetiğini zaman olduğu gibi eşleştirin, ancak görüntülemek istediğiniz değerleri (örneğin hasta kimliği veya adı vb.) içeren bir sütun adı sağladığınız “label =” bağımsız değişkenini eklemiş olun. Aşağıda gösterildiği gibi str_glue() içindeki sütunları ve yeni satırları (\\n) birleştirerek daha karmaşık etiketler oluşturabilirsiniz.Birkaç ipucu:zaman çizgi parçaları çizmek için “min.segment.length = 0” veya onları asla çizmemek için “min.segment.length = Inf” kullanınMetin boyutunu ayarlamak için aes() dışında size = kullanınEtiketler ve ilgili noktaları arasındaki itme derecesini değiştirmek için force = kullanın (varsayılan 1’dir)Etiketin değere göre renklendirilmesi için ‘aes()’ içine ‘fill =’ ekleyin\nLejandda bir “” harfi görünebilir - onu kaldırmak için guides(fill = guide_legend(override.aes ​​= aes(color = NA)))+ ekleyin\nLejandda bir “” harfi görünebilir - onu kaldırmak için guides(fill = guide_legend(override.aes ​​= aes(color = NA)))+ ekleyinDaha fazlası için ayrıntılı şu eğitime başvurabilirsiniz. eğitim.Grafiğin bir “geom” katmanı için farklı “data =” sağlamak üzere standart “ggplot()” sözdizimini kullanarak, veri noktalarının yalnızca bir alt kümesini etiketleyebilirsiniz. Aşağıda, tüm durumlar çizilmiştir, ancak yalnızca birkaçı etiketlenmiştir.","code":"\npacman::p_load(ggrepel)\n\nlinelist %>%                                               # vaka listesi ile başla\n  group_by(hospital) %>%                                   # hastaneye göre gruplandır\n  summarise(                                               # hastane başına özet değerlerle yeni veri seti oluşturun\n    n_cases = n(),                                           # hastane başına vaka sayısı\n    delay_mean = round(mean(days_onset_hosp, na.rm=T),1),    # hastane başına ortalama gecikme\n  ) %>% \n  ggplot(mapping = aes(x = n_cases, y = delay_mean))+      # veri çerçevesini ggplot'a gönder\n  geom_point(size = 2)+                                    # puan ekle\n  geom_label_repel(                                        # nokta etiketleri ekle\n    mapping = aes(\n      label = stringr::str_glue(\n        \"{hospital}\\n{n_cases} cases, {delay_mean} days\")  # etiket nasıl görüntülenir\n      ), \n    size = 3,                                              # etiketlerdeki metin boyutu\n    min.segment.length = 0)+                               # tüm çizgi parçalarını göster              \n  labs(                                                    # eksen etiketleri ekle\n    title = \"Mean delay to admission, by hospital\",\n    x = \"Number of cases\",\n    y = \"Mean delay (days)\")\nggplot()+\n  # Tüm noktalar gri\n  geom_point(\n    data = linelist,                                   # bu katmana sağlanan tüm veriler\n    mapping = aes(x = ht_cm, y = wt_kg),\n    color = \"grey\",\n    alpha = 0.5)+                                              # gri ve yarı şeffaf\n  \n  # Birkaç nokta siyah\n  geom_point(\n    data = linelist %>% filter(days_onset_hosp > 15),  # bu katmana sağlanan filtrelenmiş veriler\n    mapping = aes(x = ht_cm, y = wt_kg),\n    alpha = 1)+                                                # varsayılan siyah, şeffaf değil\n  \n  # birkaç nokta için nokta etiketleri\n  geom_label_repel(\n    data = linelist %>% filter(days_onset_hosp > 15),  # etiketler için verileri filtreleyin\n    mapping = aes(\n      x = ht_cm,\n      y = wt_kg,\n      fill = outcome,                                          # sonuca göre etiket rengi\n      label = stringr::str_glue(\"Delay: {days_onset_hosp}d\")), # str_glue() ile oluşturulan etiket\n    min.segment.length = 0) +                                  # hepsi için çizgi parçalarını göster\n  \n  # \"a\" harfini gösterge kutularından çıkarın\n  guides(fill = guide_legend(override.aes = aes(color = NA)))+\n  \n  # eksen etiketleri\n  labs(\n    title = \"Cases with long delay to admission\",\n    y = \"weight (kg)\",\n    x = \"height(cm)\")"},{"path":"ggplot-ipuçları.html","id":"zaman-eksenleri","chapter":"31 ggplot ipuçları","heading":"31.7 Zaman eksenleri","text":"ggplot’ta zaman eksenleriyle çalışmak göz korkutucu görünebilir, ancak birkaç temel fonksiyonla çok kolay hale getirilmiştir. Saat veya tarihle çalışırken, doğru değişkenlerin tarih veya tarih-saat sınıfı olarak biçimlendirildiğinden emin olmanız gerektiğini unutmayın - bu konuda daha fazla bilgi için Tarihlerle çalışma sayfasına veya örnekler için Salgın eğrileri sayfasına (ggplot bölümü) bakabilirsiniz.“ggplot2”de tarihlerle çalışmak için en kullanışlı fonksiyon kümesi, ölçeklerdir (‘scale_x_date()’, ‘scale_x_datetime()’) ve bunların aynı kökteki y ekseni fonksiyonları). Eksen etiketlerine ne sıklıkla sahip olduğunuzu ve eksen etiketlerinin nasıl biçimlendirileceğini tanımlamanıza olanak tanır. Tarihlerin nasıl biçimlendirileceğini öğrenmek için tarihlerle çalışma bölümüne tekrar bakın! Tarihlerin nasıl görüneceğini belirtmek için “date_breaks” ve “date_labels” bağımsız değişkenlerini kullanabilirsiniz:“date_breaks”, eksen kırılmalarının ne sıklıkta gerçekleşeceğini belirlemenize olanak tanır - buraya bir dize iletebilirsiniz (örneğin ““3 ay”” veya “2 gün”’)“date_breaks”, eksen kırılmalarının ne sıklıkta gerçekleşeceğini belirlemenize olanak tanır - buraya bir dize iletebilirsiniz (örneğin ““3 ay”” veya “2 gün”’)“date_labels”, tarihlerin gösterildiği biçimi tanımlamanıza olanak tanır. Bu bağımsız değişkenlere bir tarih biçimi dizesi iletebilirsiniz (örneğin ““%b-%d-%Y”`):“date_labels”, tarihlerin gösterildiği biçimi tanımlamanıza olanak tanır. Bu bağımsız değişkenlere bir tarih biçimi dizesi iletebilirsiniz (örneğin ““%b-%d-%Y”`):","code":"\n# mevcut olduğunda başlangıç tarihine göre salgın eğrisi yapın\nggplot(linelist, aes(x = date_onset)) +\n  geom_histogram(binwidth = 7) +\n  scale_x_date(\n    # 1 ayda 1 mola\n    date_breaks = \"1 months\",\n    # etiketler aydan sonra tarihi göstermelidir\n    date_labels = \"%b %d\"\n  ) +\n  theme_classic()"},{"path":"ggplot-ipuçları.html","id":"vurgulama","chapter":"31 ggplot ipuçları","heading":"31.8 Vurgulama","text":"Bir grafikteki belirli öğelerin vurgulanması, bir değişkenin belirli bir örneğine dikkat çekmenin ve aynı zamanda tüm veri kümesinin dağılımı hakkında bilgi sağlamanın yararlı bir yoludur. Bu, ggplot2 tabanında kolayca yapılmasa da, bunu yapmanıza yardımcı olabilecek gghighlight olarak bilinen harici bir paket vardır. Bunun ggplot sözdizimi içinde kullanımı kolaydır.gghighlight paketi, bu efekti elde etmek için ‘gghighlight()’ fonksiyonunu kullanır. Kullanmak için, fonksiyona mantıklı bir ifade sağlayın - bunun oldukça esnek sonuçları olabilir, ancak burada satır listemizdeki vakaların yaş dağılımının bir örneğini sonuca göre vurgulayarak göstereceğiz.Bu aynı zamanda faset fonksiyonları ile de iyi çalışır - kullanıcının, faset için geçerli olmayan vurgulanmış arka plan verileriyle faset grafikleri oluşturmasını sağlar! Aşağıda vakaları haftaya göre sayıyor ve hastaneye göre salgın eğrilerini çiziyoruz (“color =” ve “facet_wrap()”, “hastane” sütununa ayarlı).","code":"\n# gghighlight yükle\nlibrary(gghighlight)\n\n# sonuç değişkeninde NA değerlerini bilinmeyenle değiştirin\nlinelist <- linelist %>%\n  mutate(outcome = replace_na(outcome, \"Unknown\"))\n\n# yaşa göre tüm vakaların bir histogramını üretmek\nggplot(\n  data = linelist,\n  mapping = aes(x = age_years, fill = outcome)) +\n  geom_histogram() + \n  gghighlight::gghighlight(outcome == \"Death\")     # Hastanın öldüğü durumları vurgulayın.\n# yaşa göre tüm vakaların bir histogramını üretmek\nlinelist %>% \n  count(week = lubridate::floor_date(date_hospitalisation, \"week\"),\n        hospital) %>% \n  ggplot()+\n  geom_line(aes(x = week, y = n, color = hospital))+\n  theme_minimal()+\n  gghighlight::gghighlight() +                      # Hastanın öldüğü örnekleri vurgulayın\n  facet_wrap(~hospital)                              # sonuca göre yönler yapmak"},{"path":"ggplot-ipuçları.html","id":"birden-çok-veri-kümesini-çizme","chapter":"31 ggplot ipuçları","heading":"31.9 Birden çok veri kümesini çizme","text":"Aynı çizimdeki birden çok veri kümesinden çizim yapmak için eksenleri düzgün şekilde hizalamanın zor olabileceğini unutmayın. Aşağıdaki stratejilerden birini düşünün:Çizimden önce verileri birleştirin ve veri kümesini yansıtan bir sütunla “uzun” biçime dönüştürünİki grafiği birleştirmek için cowplot veya benzer bir paket kullanın (aşağıya bakın)","code":""},{"path":"ggplot-ipuçları.html","id":"grafikleri-birleştirmek","chapter":"31 ggplot ipuçları","heading":"31.10 Grafikleri birleştirmek","text":"Grafikleri birleştirmek için çok yararlı olan iki paket cowplot ve patchwork’tür. Bu sayfada, ara sıra patchwork kullanımıyla çoğunlukla cowplot’odaklanacağız.İşte çevrimiçi cowplot’giriş. fonksiyon için daha kapsamlı belgeleri çevrimiçi olarak buradan okuyabilirsiniz. Aşağıda en yaygın kullanım durumlarından ve fonksiyonlarından birkaçını ele alacağız.cowplot paketi ggplot2 ile birlikte çalışır - temel olarak, onu ggplot’ları ve açıklamalarını bileşik rakamlarda düzenlemek ve birleştirmek için kullanırsınız. Ayrıca R tabanı grafiklerini de kabul edebilir.Yönlendirme (ggplot temelleri sayfasında açıklanmıştır) çizim için uygun bir yaklaşım olsa da, bazen nispeten kısıtlayıcı yaklaşımından istediğiniz sonuçları elde etmek mümkün değildir. Burada, grafikleri daha büyük bir alana yapıştırarak birleştirmeyi seçebilirsiniz. Bunun için çok iyi bilinen üç paket vardır - cowplot, gridExtra ve patchwork. Ancak, bu paketler büyük ölçüde aynı şeyleri yapar, bu nedenle bu bölüm için cowplot üzerine odaklanacağız.","code":"\npacman::p_load(\n  tidyverse,      # veri işleme ve görselleştirme\n  cowplot,        # grafikleri birleştir\n  patchwork       # grafikleri birleştir\n)"},{"path":"ggplot-ipuçları.html","id":"plot_grid","chapter":"31 ggplot ipuçları","heading":"plot_grid()","text":"cowplot paketi oldukça geniş bir fonksiyon yelpazesine sahiptir, ancak bunun en kolay kullanımı plot_grid() kullanılarak elde edilebilir. Bu, bir ızgara oluşumunda önceden tanımlanmış grafikleri düzenlemenin etkili bir yoludur. Sıtma veri seti ile başka bir örnek üzerinde çalışabiliriz - burada toplam vakaları bölgeye göre çizebilir ve ayrıca zaman içindeki salgın eğrisini gösterebiliriz.","code":"\nmalaria_data <- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\")) \n\n# ilçeye göre toplam vakaların çubuk grafiği\np1 <- ggplot(malaria_data, aes(x = District, y = malaria_tot)) +\n  geom_bar(stat = \"identity\") +\n  labs(\n    x = \"District\",\n    y = \"Total number of cases\",\n    title = \"Total malaria cases by district\"\n  ) +\n  theme_minimal()\n\n# zamanla salgın eğrisi\np2 <- ggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +\n  geom_col(width = 1) +\n  labs(\n    x = \"Date of data submission\",\n    y =  \"number of cases\"\n  ) +\n  theme_minimal()\n\ncowplot::plot_grid(p1, p2,\n                  # 1 sütun ve iki satır - üst üste yığılmış\n                   ncol = 1,\n                   nrow = 2,\n                   # üst arsa, saniyenin 2/3'ü kadar uzun\n                   rel_heights = c(2, 3))"},{"path":"ggplot-ipuçları.html","id":"göstergeleri-birleştir","chapter":"31 ggplot ipuçları","heading":"Göstergeleri birleştir","text":"Grafikleriniz aynı göstergelere sahipse, bunları birleştirmek nispeten basittir. Grafikleri birleştirmek için yukarıdaki cowplot yaklaşımını kullanın, ancak göstergeyi bunlardan birinden kaldırın (tekrarlanacaktır).Grafikleriniz farklı göstergelere sahipse, alternatif bir yaklaşım kullanmalısınız:theme(legend.position = \"none\") kullanarak grafiklerinizi göstergeler olmadan oluşturun ve kaydedinAşağıda gösterildiği gibi get_legend() kullanarak bir grafikten göstergeleri ayıklayın - ancak lejantı gerçekten göstermek için değiştirilmiş grafiklerden lejantları çıkarınGöstergeleri bir gösterge panelinde birleştirinGrafikler ve göstergeler panelini birleştirinÖrnek için iki grafiği ayrı ayrı gösteriyoruz ve sonra kendi açıklamaları (çirkin ve verimsiz alan kullanımı) gösteren bir ızgarada düzenliyoruz:İki grafik, lejantlarını/göstergelerini birleştirmeden “plot_grid()” kullanılarak birleştirildiğinde şöyle görünür:Ve şimdi göstergeleri nasıl birleştireceğimizi gösteriyoruz. Esasen yaptığımız şey, bir grafiği açıklaması olmadan tanımlamaktır (theme(legend.position = \"none\") ve sonra get_legend() fonksiyonunu kullanarak bir grafiğin göstergesini ayrı ayrı cowplot dan tanımlarız. Kaydedilen çizimden lejandı çıkardığımızda, lejandı tekrar `+’ eklememiz gerekiyor, buna yerleşimi belirtmek (“sağ”) ve lejandların ve başlıklarının hizalanması için daha küçük ayarlamalar da dahildir. Lejandları dikey olarak bir araya getirin ve ardından iki grafiği yeniden birleştirin.Bu çözüm, bu gönderiden öğrenildi ve lejandları bu gönderiden hizalamak için küçük bir düzeltme yapıldı.İPUCU: Eğlenceli - cowplot’taki “inek-COW”, yaratıcının adından gelir - Claus O. Wilke.","code":"\np1 <- linelist %>% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %>% \n  count(hospital, outcome) %>% \n  ggplot()+\n  geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+\n  scale_fill_brewer(type = \"qual\", palette = 4, na.value = \"grey\")+\n  coord_flip()+\n  theme_minimal()+\n  labs(title = \"Cases by outcome\")\n\n\np2 <- linelist %>% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %>% \n  count(hospital, age_cat) %>% \n  ggplot()+\n  geom_col(mapping = aes(x = hospital, y = n, fill = age_cat))+\n  scale_fill_brewer(type = \"qual\", palette = 1, na.value = \"grey\")+\n  coord_flip()+\n  theme_minimal()+\n  theme(axis.text.y = element_blank())+\n  labs(title = \"Cases by age\")\ncowplot::plot_grid(p1, p2, rel_widths = c(0.3))\n# Açıklama olmadan grafik 1'i tanımlayın\np1 <- linelist %>% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %>% \n  count(hospital, outcome) %>% \n  ggplot()+\n  geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+\n  scale_fill_brewer(type = \"qual\", palette = 4, na.value = \"grey\")+\n  coord_flip()+\n  theme_minimal()+\n  theme(legend.position = \"none\")+\n  labs(title = \"Cases by outcome\")\n\n\n# Açıklama olmadan grafik 2'yi tanımlayın\np2 <- linelist %>% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %>% \n  count(hospital, age_cat) %>% \n  ggplot()+\n  geom_col(mapping = aes(x = hospital, y = n, fill = age_cat))+\n  scale_fill_brewer(type = \"qual\", palette = 1, na.value = \"grey\")+\n  coord_flip()+\n  theme_minimal()+\n  theme(\n    legend.position = \"none\",\n    axis.text.y = element_blank(),\n    axis.title.y = element_blank()\n  )+\n  labs(title = \"Cases by age\")\n\n\n# p1'den lejandı çıkar (p1'den + lejand)\nleg_p1 <- cowplot::get_legend(p1 +\n                                theme(legend.position = \"right\",        # dikey lejandı çıkar\n                                      legend.justification = c(0,0.5))+ # böylece lejandlar hizalanır\n                                labs(fill = \"Outcome\"))                 # lejand başlığı\n# p2'den lejandı çıkar (p2'den + lejand)\nleg_p2 <- cowplot::get_legend(p2 + \n                                theme(legend.position = \"right\",            \n                                      legend.justification = c(0,0.5))+  \n                                labs(fill = \"Age Category\"))             \n\n# lejand hizalaması için boş bir grafik oluşturun\n#blank_p <- patchwork::plot_spacer() + theme_void()\n\n# lejand paneli oluşturun, üst üste olabilir (veya yukarıda yorumlanan aralayıcıyı kullanın)\nlegends <- cowplot::plot_grid(leg_p1, leg_p2, nrow = 2, rel_heights = c(.3, .7))\n\n# iki grafiği ve birleştirilmiş lejand panelini birleştirin\ncombined <- cowplot::plot_grid(p1, p2, legends, ncol = 3, rel_widths = c(.4, .4, .2))\n\ncombined  # yazdır"},{"path":"ggplot-ipuçları.html","id":"ek-grafikler","chapter":"31 ggplot ipuçları","heading":"Ek grafikler","text":"cowplot kullanarak bir grafiği diğerine yerleştirebilirsiniz. İşte dikkat edilmesi gerekenler:Ana grafiği cowplot’tan theme_half_open() ile tanımlayın; lejandın üstte veya altta olması en iyisi olabilirİç metin grafiğini tanımlayın. En iyisi, bir lejanda ihtiyacınız olmayan bir grafiğe sahip olmaktır. Aşağıda gösterildiği gibi element_blank() ile çizim teması öğelerini kaldırabilirsiniz.Bunları ana çizime ggdraw()’ uygulayarak birleştirin, ardından içteki çizime ‘draw_plot()’ ekleyerek ve koordinatları (sol alt köşenin x ve y), tüm ana grafiğin oranı olarak yüksekliği ve genişliği belirterek birleştirin .Bu teknik, bu iki gösterim içinde daha fazla açıklanmıştır:Wilke laboratuvarı\ndraw_plot() belgeleri","code":"\n# Ana grafiği tanımla\nmain_plot <- ggplot(data = linelist)+\n  geom_histogram(aes(x = date_onset, fill = hospital))+\n  scale_fill_brewer(type = \"qual\", palette = 1, na.value = \"grey\")+ \n  theme_half_open()+\n  theme(legend.position = \"bottom\")+\n  labs(title = \"Epidemic curve and outcomes by hospital\")\n\n\n# İç metin grafiğini tanımlayın\ninset_plot <- linelist %>% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %>% \n  count(hospital, outcome) %>% \n  ggplot()+\n    geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+\n    scale_fill_brewer(type = \"qual\", palette = 4, na.value = \"grey\")+\n    coord_flip()+\n    theme_minimal()+\n    theme(legend.position = \"none\",\n          axis.title.y = element_blank())+\n    labs(title = \"Cases by outcome\") \n\n\n# Ana öğeyi iç metinle birleştirin\ncowplot::ggdraw(main_plot)+\n     draw_plot(inset_plot,\n               x = .6, y = .55,    #x = .07, y = .65,\n               width = .4, height = .4)"},{"path":"ggplot-ipuçları.html","id":"çift-eksen","chapter":"31 ggplot ipuçları","heading":"31.11 Çift eksen","text":"İkincil bir y ekseni genellikle bir “ggplot2” grafiğine istenen bir ektir. Veri görselleştirme topluluğunda bu tür grafiklerin geçerliliği hakkında güçlü bir tartışma olsa da ve bunlar genellikle önerilmese de, yöneticiniz yine de bunları isteyebilir. Aşağıda, bunları elde etmek için bir yöntem sunuyoruz: iki ayrı grafiği birleştirmek için cowplot paketini kullanmak.Bu yaklaşım, biri solda y ekseni ve diğeri sağda y ekseni olan iki ayrı grafik oluşturmayı içerir. ikisi de belirli bir “theme_cowplot()” kullanır ve aynı x eksenine sahip olmalıdır. Daha sonra üçüncü bir komutta iki grafik hizalanır ve üst üste bindirilir. Bu cowplot’un özelliği sitede ayrıntılı olarak açıklanmaktadır.Bu tekniği göstermek için, salgın eğrisini, ölen hastaların haftalık yüzdesinin bir çizgisiyle kaplayacağız. Bu örneği, x eksenindeki tarihlerin hizalanmasını, bir çubuk grafiği başka bir grafikle hizalamaktan daha karmaşık olduğu için kullanıyoruz. Dikkat edilmesi gereken bazı şeyler:Salgın eğrisi ve çizgi, çizimden önceki haftalarda toplanır ve “tarih_araları” ve “tarih_etiketleri” aynıdır - bunu, üst üste bindirildiklerinde iki grafiğin x-eksenlerinin aynı olması için yaparız.y ekseni, ‘scale_y_continuous()’ un ‘position =’ değişkeni ile 2. grafik için sağ tarafa taşınır.iki grafik de theme_cowplot() fonksiyonunu kullanırSalgın eğrileri sayfasında bu tekniğin başka bir örneğine dikkat çekilmiştir - kümülatif insidansı eğri üzerine bindirerek.** 1. Grafiği Üretmek**\nBu aslında salgın eğrisidir. Sadece kullanımını göstermek için geom_area() kullanıyoruz (varsayılan olarak bir çizginin altındaki alan)2. Grafiği Üretmek\nÖlen vakaların haftalık yüzdesinin bir satırını gösteren ikinci grafiği oluşturun.Şimdi yatay ve dikey hizalamayı (“hv”, “h”, “v”, “none” da olabilir) belirterek, align_plots() fonksiyonunu kullanarak grafiği hizalıyoruz. “tblr” ile tüm eksenlerin (üst, alt, sol ve sağ) hizalamasını da belirtiyoruz. Çıktı sınıf listesidir (2 eleman).Ardından, ggdraw()‘ı (cowplot’tan) kullanarak ve ’aligned_plots’ nesnesinin iki parçasına atıfta bulunarak iki grafiği birlikte çiziyoruz.","code":"\npacman::p_load(cowplot)            # Cowplot'u yükle/kur\n\np1 <- linelist %>%                 # grafiği nesne olarak kaydet\n     count(\n       epiweek = lubridate::floor_date(date_onset, \"week\")) %>% \n     ggplot()+\n          geom_area(aes(x = epiweek, y = n), fill = \"grey\")+\n          scale_x_date(\n               date_breaks = \"month\",\n               date_labels = \"%b\")+\n     theme_cowplot()+\n     labs(\n       y = \"Weekly cases\"\n     )\n\np1                                      # grafiği göster\np2 <- linelist %>%         # grafiği nesne olarak kaydet\n     group_by(\n       epiweek = lubridate::floor_date(date_onset, \"week\")) %>% \n     summarise(\n       n = n(),\n       pct_death = 100*sum(outcome == \"Death\", na.rm=T) / n) %>% \n     ggplot(aes(x = epiweek, y = pct_death))+\n          geom_line()+\n          scale_x_date(\n               date_breaks = \"month\",\n               date_labels = \"%b\")+\n          scale_y_continuous(\n               position = \"right\")+\n          theme_cowplot()+\n          labs(\n            x = \"Epiweek of symptom onset\",\n            y = \"Weekly percent of deaths\",\n            title = \"Weekly case incidence and percent deaths\"\n          )\n\np2     # grafiği göster\naligned_plots <- cowplot::align_plots(p1, p2, align=\"hv\", axis=\"tblr\")         # iki grafiği hizalayın ve liste olarak kaydedin\naligned_plotted <- ggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])  # üst üste bindirin ve görsel grafiği kaydedin\naligned_plotted                                                                # bindirilmiş grafikleri yazdır"},{"path":"ggplot-ipuçları.html","id":"size-yardımcı-olacak-paketler","chapter":"31 ggplot ipuçları","heading":"31.12 Size yardımcı olacak paketler","text":"ggplot2’de gezinmenize yardımcı olmak için özel olarak tasarlanmış gerçekten anlaşılır bazı R paketleri vardır:","code":""},{"path":"ggplot-ipuçları.html","id":"işaretle-ve-tıkla-ggplot2-ile-equisse","chapter":"31 ggplot ipuçları","heading":"İşaretle ve tıkla ggplot2 ile equisse","text":"“Bu eklenti, verilerinizi ggplot2 paketi ile görselleştirerek etkileşimli olarak keşfetmenizi sağlar. Çubuk grafikler, eğriler, dağılım grafikleri, histogramlar, kutu grafiği ve sf nesneleri çizmenize, ardından grafiği dışa aktarmanıza veya grafiği yeniden oluşturmak için kodu almanıza olanak tanır.”Eklentiyi RStudio menüsü veya esquisse::esquisser() ile kurun ve başlatın.Github sayfasına bakabilirsiniz.Belgeler","code":""},{"path":"ggplot-ipuçları.html","id":"çeşitli","chapter":"31 ggplot ipuçları","heading":"31.13 Çeşitli","text":"","code":""},{"path":"ggplot-ipuçları.html","id":"sayısal-ekran","chapter":"31 ggplot ipuçları","heading":"Sayısal ekran","text":"Çizimden önce bu komutu çalıştırarak bilimsel gösterimi devre dışı bırakabilirsiniz.Veya scales paketinden number_format() öğesini aşağıda gösterildiği gibi belirli bir değere veya sütuna uygulayın.Sayıların nasıl görüntüleneceğini kolayca ayarlamak için scales paketindeki fonksiyonları kullanın. Bunlar, veri çerçevenizdeki sütunlara uygulanabilir, ancak örnek olarak tek tek sayılarda gösterilir.","code":"\noptions(scipen=999)\nscales::number(6.2e5)## [1] \"620 000\"\nscales::number(1506800.62,  accuracy = 0.1,)## [1] \"1 506 800.6\"\nscales::comma(1506800.62, accuracy = 0.01)## [1] \"1,506,800.62\"\nscales::comma(1506800.62, accuracy = 0.01,  big.mark = \".\" , decimal.mark = \",\")## [1] \"1.506.800,62\"\nscales::percent(0.1)## [1] \"10%\"\nscales::dollar(56)## [1] \"$56\"\nscales::scientific(100000)## [1] \"1e+05\""},{"path":"ggplot-ipuçları.html","id":"kaynaklar-24","chapter":"31 ggplot ipuçları","heading":"31.14 Kaynaklar","text":"Esinlenme\nggplot grafik galerisiVerilerin sunumu\nAvrupa Hastalık Önleme ve Kontrol Merkezi Sürveyans verilerinin sunumuna ilişkin kılavuzlarYönler ve etiketleyiciler\nYüz şeritleri için etiketleyici kullanma\nEtiketçilerFaktörlerle sıralamayı ayarlama\nfct_reorder\nfct_inorder\nBir kutu grafiği nasıl yeniden sıralanır\nggplot2’de bir değişkeni yeniden sıralayın\nVeri Bilimi için R - FaktörlerGöstergeler\nLejand sırasını ayarlayınAltyazılar\nAltyazı hizalamasıEtiketler\nggrepelYardımcı sayfaları\nggplot2 ile güzel çizim","code":""},{"path":"salgın-eğrileri.html","id":"salgın-eğrileri","chapter":"32 Salgın eğrileri","heading":"32 Salgın eğrileri","text":"Bir salgın eğrisi (“epi curve” olarak da bilinir), tipik olarak bir vaka kümesi veya salgın arasında geçici hastalık başlangıcı modelini görselleştirmek için kullanılan temel bir epidemiyolojik çizelgedir.Salgın eğrisi analizi, zamansal eğilimleri, aykırı değerleri, salgının büyüklüğünü, en olası maruz kalma süresini, vaka nesilleri arasındaki zaman sonlarını ortaya çıkarabilir ve hatta tanımlanamayan bir hastalığın bulaşma şeklini belirlemeye yardımcı olabilir (örn. nokta kaynak, sürekli ortak kaynak, kişiden kişiye yayılma). [ABD CDC]’nin web sitesinde(https://www.cdc.gov/training/quicklearns/epimode/index.html) salgın eğrilerinin yorumlanmasıyla ilgili bir online ders bulunabilir.Bu sayfada, R’da salgın eğrilerini üretmeye yönelik iki yaklaşım gösterilmektedir:Basit komutlarla bir salgın eğrisi oluşturabilen insidans2 paketiDaha karmaşık komutlar aracılığıyla gelişmiş özelleştirilebilirlik sağlayan ggplot2 paketiAyrıca aşağıdakiler gibi özel kullanım durumları da ele alınmaktadır:Toplu sayım verilerini çizmeKüçük-katları kaplama veya üretmeHareketli ortalamaları uygulamaHangi verilerin “geçici” olduğunu veya raporlama gecikmelerine tabi olduğunu göstermeİkinci bir eksen kullanarak kümülatif vaka insidansını bindirme","code":""},{"path":"salgın-eğrileri.html","id":"hazırlık-24","chapter":"32 Salgın eğrileri","heading":"32.1 Hazırlık","text":"","code":""},{"path":"salgın-eğrileri.html","id":"paketler-3","chapter":"32 Salgın eğrileri","heading":"Paketler","text":"Bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’ın p_load()işlevini vurguluyoruz. Ayrıca, R tabanı’ndan library()ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] ile ilgili sayfaya bakın.","code":"\npacman::p_load(\n  rio,          # file import/export\n  here,         # relative filepaths \n  lubridate,    # working with dates/epiweeks\n  aweek,        # alternative package for working with dates/epiweeks\n  incidence2,   # epicurves of linelist data\n  i2extras,     # supplement to incidence2\n  stringr,      # search and manipulate character strings\n  forcats,      # working with factors\n  RColorBrewer, # Color palettes from colorbrewer2.org\n  tidyverse     # data management + ggplot2 graphics\n) "},{"path":"salgın-eğrileri.html","id":"verileri-içe-aktarma-7","chapter":"32 Salgın eğrileri","heading":"Verileri içe aktarma","text":"Bu bölümde iki örnek veri seti kullanılmıştır:Simüle edilmiş bir salgından bireysel vakaların sıra listesiAynı simüle edilmiş salgından hastaneye göre toplu sayımlarVeri setleri, rio paketinden import()fonksiyonu kullanılarak içe aktarılır. Verileri içe aktarmanın çeşitli yolları için [İçe ve dışa aktarma] sayfasına bakın.Vaka satır listesiSimüle edilmiş bir Ebola salgınından vakaların veri setini içe aktarıyoruz. Adım adım izlenecek verileri indirmek istiyorsanız, [El kitabını ve verileri indir] sayfasındaki talimata bakın. Dosyanın çalışma dizininde olduğunu varsayıyoruz, bu nedenle bu dosya yolunda hiçbir alt klasör belirtilmemiştir.İlk 50 satır aşağıda gösterilmiştir.Hastane tarafından toplanan vaka sayılarıEl kitabının amaçları doğrultusunda, hastane tarafından haftalık toplu sayımların veri seti, aşağıdaki kodla linelist ’den oluşturulur.İlk 50 satır aşağıda görüntülenir:","code":"\nlinelist <- import(\"linelist_cleaned.xlsx\")\n# import the counts data into R\ncount_data <- linelist %>% \n  group_by(hospital, date_hospitalisation) %>% \n  summarize(n_cases = dplyr::n()) %>% \n  filter(date_hospitalisation > as.Date(\"2013-06-01\")) %>% \n  ungroup()"},{"path":"salgın-eğrileri.html","id":"parametreleri-ayarlamak","chapter":"32 Salgın eğrileri","heading":"Parametreleri ayarlamak","text":"Bir raporun hazırlanması için, verilerin güncel olduğu tarih (“veri tarihi”) gibi düzenlenebilir parametreleri ayarlamak isteyebilirsiniz. Ardından, filtre uygularken veya dinamik altyazılarda kodunuzdaki data_date nesnesine başvurabilirsiniz.","code":"\n## set the report date for the report\n## note: can be set to Sys.Date() for the current date\ndata_date <- as.Date(\"2015-05-15\")"},{"path":"salgın-eğrileri.html","id":"tarihleri-doğrulama","chapter":"32 Salgın eğrileri","heading":"Tarihleri doğrulama","text":"ilgili tarih sütununun Date sınıfı olduğunu ve uygun bir değer aralığına sahip olduğunu doğrulayın. Bunu, histogramlar için hist()’veya na.rm=TRUE ile range()’veya aşağıdaki gibi ggplot()’u kullanarak yapabilirsiniz.","code":"\n# check range of onset dates\nggplot(data = linelist)+\n  geom_histogram(aes(x = date_onset))"},{"path":"salgın-eğrileri.html","id":"incidence2-paketi-ile-salgın-eğrileri","chapter":"32 Salgın eğrileri","heading":"32.2 incidence2 paketi ile salgın eğrileri","text":"Aşağıda, insidans2 paketini kullanarak epi eğrilerinin nasıl yapıldığını gösteriyoruz. Bu paketin yazarları, kullanıcının ggplot2 sözdizimini bilmesine gerek kalmadan salgın eğrilerinin oluşturmasına ve değiştirmesine izin vermeye çalıştılar. Bu sayfanın çoğu, insidans2 github sayfası’nda bulunabilen paket gösterimlerinden uyarlanmıştır.","code":""},{"path":"salgın-eğrileri.html","id":"basit-örnek","chapter":"32 Salgın eğrileri","heading":"Basit örnek","text":"İnsidans2 paketiyle bir salgın eğrisi çizmek için 2 adım gereklidir:\n1) Bir olay nesnesi oluşturun (incidence()fonksiyonunu kullanarak)\n+ Verileri sağlayın\n+ date_index = için tarih sütununu belirtin\n+ Vakaların toplanacağı interval = belirtin (günlük, haftalık, aylık..)\n+ Herhangi bir gruplandırma sütununu belirtin (ör. cinsiyet, hastane, sonuç)\n2) Olay nesnesini grafiklendirin\n+ Etiketleri, renkleri, başlıkları vb. belirtin.Aşağıda, incidence2 paketini yüklüyoruz, date_onset sütunundaki linelist’den incidence nesnesini oluşturuyoruz ve günlük vakaları topluyoruz. Daha sonra olay nesnesinin bir özetini yazdırıyoruz.incidence2 nesnesinin kendisi bir tibble (veri çerçevesi gibi) gibi görünür ve bir veri çerçevesi gibi yazdırılabilir veya daha fazla manipüle edilebilir.Yazdırıldığında date_index sütunu ve bir count sütunu olduğu görülmektedir.Ayrıca nesnenin bir özetini yazdırabilirsiniz:incidence nesnesini grafiklendirmek için, incidence nesnesinin adında plot()kullanın. Arka planda, plot.incidence2()fonksiyonu çağrılır, bu nedenle incidence2’ye özgü belgeleri okumak için ?plot.incidence2’yi çalıştırırsınız.Çok sayıda küçük beyaz dikey çizgi fark ederseniz, resminizin boyutunu ayarlamaya çalışın. Örneğin, grafiğinizi ggsave()ile dışa aktarırsanız, width = ve height = sayıları sağlayabilirsiniz. Grafiği genişletirseniz bu çizgiler kaybolabilir.","code":"\n# load incidence2 package\npacman::p_load(incidence2)\n\n# create the incidence object, aggregating cases by day\nepi_day <- incidence(       # create incidence object\n  x = linelist,             # dataset\n  date_index = date_onset,  # date column\n  interval = \"day\"          # date grouping interval\n  )\nclass(epi_day)## [1] \"incidence2\"   \"incidence_df\" \"tbl_df\"       \"tbl\"          \"data.frame\"\nepi_day## An incidence object: 367 x 2\n## date range: [2014-04-07] to [2015-04-30]\n## cases: 5632\n## interval: 1 day\n## cumulative: FALSE\n## \n##    date_index count\n##    <date>     <int>\n##  1 2014-04-07     1\n##  2 2014-04-15     1\n##  3 2014-04-21     2\n##  4 2014-04-25     1\n##  5 2014-04-26     1\n##  6 2014-04-27     1\n##  7 2014-05-01     2\n##  8 2014-05-03     1\n##  9 2014-05-04     1\n## 10 2014-05-05     1\n## # … with 357 more rows\n# print summary of the incidence object\nsummary(epi_day)## date range: [2014-04-07] to [2015-04-30]\n## cases: 5632\n## interval: 1 day\n## cumulative: FALSE\n## timespan: 389 days\n# plot the incidence object\nplot(epi_day)"},{"path":"salgın-eğrileri.html","id":"vaka-toplamanın-zaman-aralığını-değiştirmek","chapter":"32 Salgın eğrileri","heading":"Vaka toplamanın zaman aralığını değiştirmek","text":"incidence()’ın interval = bağımsız değişkeni, gözlemlerin dikey çubuklar halinde nasıl gruplandırıldığını tanımlar.Aralığı belirtinincidence2, vakalarınızı salgın eğrisi çubuklarında nasıl birleştirmek istediğinizi belirtmek için esneklik ve anlaşılır sözdizimi sağlar. interval = bağımsız değişkeni aşağıdaki gibi bir değer girin. Aşağıdakilerden herhangi birini çoğul olarak yazabilirsiniz (ör. “haftalar”) ve öncesinde sayıları ekleyebilirsiniz (ör. “3 ay”).Aşağıda, satır listesine uygulandığında farklı aralıkların nasıl göründüğüne ilişkin örnekler verilmiştir. Tarih aralığı değiştikçe x eksenindeki tarih etiketlerinin varsayılan biçiminin ve sıklığının nasıl değiştiğine dikkat edin.İlk tarihİsteğe bağlı olarak, incidence() komutunda firstdate =olarak tarih sınıfının bir değerini (ör. .Date(\"2016-05-01\")) belirtebilirsiniz. Verilirse, veriler bu aralığa kırpılacak ve aralıklar bu tarihte başlayacaktır.","code":"\n# Create the incidence objects (with different intervals)\n##############################\n# Weekly (Monday week by default)\nepi_wk      <- incidence(linelist, date_onset, interval = \"Monday week\")\n\n# Sunday week\nepi_Sun_wk  <- incidence(linelist, date_onset, interval = \"Sunday week\")\n\n# Three weeks (Monday weeks by default)\nepi_2wk     <- incidence(linelist, date_onset, interval = \"2 weeks\")\n\n# Monthly\nepi_month   <- incidence(linelist, date_onset, interval = \"month\")\n\n# Quarterly\nepi_quarter   <- incidence(linelist, date_onset, interval = \"quarter\")\n\n# Years\nepi_year   <- incidence(linelist, date_onset, interval = \"year\")\n\n\n# Plot the incidence objects (+ titles for clarity)\n############################\nplot(epi_wk)+      labs(title = \"Monday weeks\")\nplot(epi_Sun_wk)+  labs(title = \"Sunday weeks\")\nplot(epi_2wk)+     labs(title = \"2 (Monday) weeks\")\nplot(epi_month)+   labs(title = \"Months\")\nplot(epi_quarter)+ labs(title = \"Quarters\")\nplot(epi_year)+    labs(title = \"Years\")"},{"path":"salgın-eğrileri.html","id":"gruplar","chapter":"32 Salgın eğrileri","heading":"Gruplar","text":"Gruplar incidence()komutunda belirtilir ve çubukları renklendirmek veya verileri yönlendirmek için kullanılabilir. Verilerinizdeki grupları belirtmek için, incidence() komutunda groups = bağımsız değişkenine sütun adlarını sağlayın (sütun adının çevresinde tırnak işareti yok). Birden fazla sütun belirtiyorsanız, adlarını c() içine koyun.na_as_group = TRUE ayarını yaparak gruplandırma sütunlarında eksik değerleri olan durumların ayrı bir NA grubu olarak listelenmesini sağlayabilirsiniz. Aksi takdirde, grafikten hariç tutulurlar.Çubukları bir gruplama sütununa göre renklendirmek için, plot() komutunda, doldurmak/ fill = için sütun adını tekrar temin etmeniz gerekir.Çubukları bir gruplama sütununa göre renklendirmek için, plot() komutunda, doldurmak/ fill = için sütun adını tekrar temin etmeniz gerekir.Gruplandırma sütununu temel alan yönlendirmeler için, incidence2 ile ilgili görünümlerde aşağıdaki bölüme bakın.Gruplandırma sütununu temel alan yönlendirmeler için, incidence2 ile ilgili görünümlerde aşağıdaki bölüme bakın.Aşağıdaki örnekte, tüm salgındaki vakalar yaş kategorilerine göre gruplandırılmıştır. Eksik değerler grup olarak dahil edilir. Salgın eğrisi aralığı hafta olarak alınır.İPUCU: Göstergenin başlığını, incidence2 grafiğinize + ggplot2 komut labs(fill = \"title\") ekleyerek değiştirin.Ayrıca, aşağıda gösterildiği gibi plot() içinde stack = FALSE ayarını yaparak gruplandırılmış çubukların yan yana görüntülenmesini sağlayabilirsiniz:Eksik değerlere sahip satırları grafikten çıkarmak için na_as_group = bağımsız değişkenini incidence() komutunda FALSE olarak ayarlayabilirsiniz.","code":"\n# Create incidence object, with data grouped by age category\nage_outbreak <- incidence(\n  linelist,                # dataset\n  date_index = date_onset, # date column\n  interval = \"week\",       # Monday weekly aggregation of cases\n  groups = age_cat,        # age_cat is set as a group\n  na_as_group = TRUE)      # missing values assigned their own group\n\n# plot the grouped incidence object\nplot(\n  age_outbreak,             # incidence object with age_cat as group\n  fill = age_cat)+          # age_cat is used for bar fill color (must have been set as a groups column above)\nlabs(fill = \"Age Category\") # change legend title from default \"age_cat\" (this is a ggplot2 modification)\n# Make incidence object of monthly counts. \nmonthly_gender <- incidence(\n linelist,\n date_index = date_onset,\n interval = \"month\",\n groups = gender            # set gender as grouping column\n)\n\nplot(\n  monthly_gender,   # incidence object\n  fill = gender,    # display bars colored by gender\n  stack = FALSE)    # side-by-side (not stacked)"},{"path":"salgın-eğrileri.html","id":"filtrelenmiş-veri","chapter":"32 Salgın eğrileri","heading":"Filtrelenmiş veri","text":"Bir veri alt kümesinin salgın eğrisini çizmek için:Satır listesi verilerini filtreleyinincidence() komutuna filtrelenmiş verileri sağlayınİnsidans nesnesini grafiklendirinAşağıdaki örnek, yalnızca Central Hospital’daki vakaları göstermek için filtrelenmiş verileri kullanır.","code":"\n# filter the linelist\ncentral_data <- linelist %>% \n  filter(hospital == \"Central Hospital\")\n\n# create incidence object using filtered data\ncentral_outbreak <- incidence(central_data, date_index = date_onset, interval = \"week\")\n\n# plot the incidence object\nplot(central_outbreak, title = \"Weekly case incidence at Central Hospital\")"},{"path":"salgın-eğrileri.html","id":"toplu-sayımlar","chapter":"32 Salgın eğrileri","heading":"Toplu sayımlar","text":"Orijinal verileriniz toplanmışsa (sayımlar), incidence() ile insidans nesnesini oluştururken count = bağımsız değişkenine vaka sayılarını içeren sütunun adını girin.Örneğin, bu veri çerçevesi count_data, hastane tarafından günlük sayımlarda toplanan satır listesidir. İlk 50 satır şöyle görünür:ScriptIf Analizinize yukarıdaki veri kümesi gibi günlük sayım verileriyle başlıyorsanız, bunu hastaneye göre haftalık bir salgın eğrisi dönüştürmek için incidence() komutunuz şöyle görünür:","code":"\nepi_counts <- incidence(              # create weekly incidence object\n  count_data,                         # dataset with counts aggregated by day\n  date_index = date_hospitalisation,  # column with dates\n  count = n_cases,                    # column with counts\n  interval = \"week\",                  # aggregate daily counts up to weeks\n  groups = hospital                   # group by hospital\n  )\n\n# plot the weekly incidence epi curve, with stacked bars by hospital\nplot(epi_counts,                      # incidence object\n     fill = hospital)                 # color the bars by hospital"},{"path":"salgın-eğrileri.html","id":"yönlendirmelerküçük-katlar","chapter":"32 Salgın eğrileri","heading":"Yönlendirmeler/küçük katlar","text":"Verileri gruba göre biçimlendirmek için (yani “küçük katlar” üretin):insidans nesnesini oluşturduğunuzda groups = için yönlendirme sütununu belirtin,plot() yerine facet_plot() komutunu kullanın,Hangi gruplandırma sütunlarının fill = ve hangilerinin facets = olarak kullanılacağını belirtin.Aşağıda, incidence() komutunda hem hospital hem de outcome sütunlarını gruplandırma sütunları olarak ayarladık. Daha sonra, facet_plot()içinde, hastane için farklı bir salgın eğrisi istediğimizi ve bir salgın eğrisi içindeki çubukların sonuca göre yığıp renklendirilmesi gerektiğini belirterek, salgın eğrisi çizeriz.ggtree paketinin (filogenetik ağaçları görüntülemek için kullanılır) ayrıca bir facet_plot()fonksiyonu sahip olduğuna dikkat edin - bu nedenle yukarıda incidence2::facet_plot() belirtilmiştir.","code":"\nepi_wks_hosp_out <- incidence(\n  linelist,                      # dataset\n  date_index = date_onset,       # date column\n  interval = \"month\",            # monthly bars  \n  groups = c(outcome, hospital)  # both outcome and hospital are given as grouping columns\n  )\n\n# plot\nincidence2::facet_plot(\n  epi_wks_hosp_out,      # incidence object\n  facets = hospital,     # facet column\n  fill = outcome)        # fill column"},{"path":"salgın-eğrileri.html","id":"plot-ile-yapılan-değişiklikler","chapter":"32 Salgın eğrileri","heading":"plot() ile yapılan değişiklikler","text":"incidence2 tarafından üretilen bir salgın eğrisi, plot()fonksiyonu içindeki bu bağımsız değişkenler aracılığıyla değiştirilebilir.Çubukların görünümünü değiştiren plot()bağımsız değişkenleri şunlardır:Tarih eksenini değiştiren plot()bağımsız değişkenleri şunlardır:date_breaks = bağımsız değişkenlerinin yalnızca centre_dates = FALSE olduğunda çalıştığını unutmayın. [Tarihlerle çalışma sayfasında] ayrıntılı olarak açıklandığı gibi, aşağıdaki strptime sözdizimini kullanarak tırnak içinde bir karakter değeri girin. “yeni satır” için \\n kullanabilirsiniz.%d = Ayın gün sayısı (5, 17, 28, v.b.)\n%j = Yılın gün sayısı (Julian günü 001-366)\n%= Kısaltılmış hafta içi (Pzt, Slı, Çrşb, v.b.)\n%= Tam hafta içi (Pazartesi, Salı, v.b.)\n%w = Hafta içi numarası (0-6, Pazar için 0)\n%u = Hafta içi numarası (1-7, Pazartesi için 1)\n%W = Hafta numarası (00-53, Pazartesi hafta başlangıcıdır)\n%U = Hafta numarası (01-53, Pazar hafta başlangıcıdır)\n%m = Hafta numarası (Örneğin 01, 02, 03, 04)\n%b = Kısaltılmış ay (Ock, Şbt, v.b.)\n%B = Tam ay (Ocak, Şubat, v.b.)\n%y = 2 basamaklı yıl (örneğin 89)\n%Y = 4 basamaklı yıl (örneğin 1989)\n%h = saatler (24 saatlik saat)\n%m = dakikalar\n%s = saniyeler\n%z = GMT’den karşılığı\n%Z = Saat dilimi (karakter)Grafik etiketlerini değiştiren plot()argümanları şunlardır:Yukarıdaki argümanların çoğunu kullanan bir örnek:Grafiğin görünümünü daha fazla ayarlamak için, ggplot() ile yapılan değişikliklerle ilgili aşağıdaki bölüme bakın.","code":"\n# filter the linelist\ncentral_data <- linelist %>% \n  filter(hospital == \"Central Hospital\")\n\n# create incidence object using filtered data\ncentral_outbreak <- incidence(\n  central_data,\n  date_index = date_onset,\n  interval = \"week\",\n  groups = outcome)\n\n# plot incidence object\nplot(\n  central_outbreak,\n  fill = outcome,                       # box/bar color\n  legend = \"top\",                       # legend on top\n  title = \"Cases at Central Hospital\",  # title\n  xlab = \"Week of onset\",               # x-axis label\n  ylab = \"Week of onset\",               # y-axis label\n  show_cases = TRUE,                    # show each case as an individual box\n  alpha = 0.7,                          # transparency \n  border = \"grey\",                      # box border\n  angle = 30,                           # angle of date labels\n  centre_dates = FALSE,                 # date labels at edge of bar\n  date_format = \"%a %d %b %Y\\n(Week %W)\" # adjust how dates are displayed\n  )"},{"path":"salgın-eğrileri.html","id":"ggplot2-ile-değişiklikler","chapter":"32 Salgın eğrileri","heading":"ggplot2 ile değişiklikler","text":"Aşağıda gösterildiği gibi, insidans plot()fonksiyonunun kapanışından sonra + ile ggplot2 değişiklikleri ekleyerek bir insidans2 grafiğini daha fazla değiştirebilirsiniz.Aşağıda, incidence2 grafiklendirme sona erer ve ardından eksenleri değiştirmek, başlık eklemek ve kalın yazı tipini ve metin boyutunu ayarlamak için ggplot2 komutları kullanılır.scale_x_date()öğesini eklerseniz, plot()öğesindeki çoğu tarih biçimlendirmesinin üzerine yazılacağını unutmayın. Daha fazla seçenek için ggplot()salgın eğrisi bölümüne ve El Kitabı sayfası ggplot ipuçlarına bakın.","code":"\n# filter the linelist\ncentral_data <- linelist %>% \n  filter(hospital == \"Central Hospital\")\n\n# create incidence object using filtered data\ncentral_outbreak <- incidence(\n  central_data,\n  date_index = date_onset,\n  interval = \"week\",\n  groups = c(outcome))\n\n# plot incidence object\nplot(\n  central_outbreak,\n  fill = outcome,                       # box/bar color\n  legend = \"top\",                       # legend on top\n  title = \"Cases at Central Hospital\",  # title\n  xlab = \"Week of onset\",               # x-axis label\n  ylab = \"Week of onset\",               # y-axis label\n  show_cases = TRUE,                    # show each case as an individual box\n  alpha = 0.7,                          # transparency \n  border = \"grey\",                      # box border\n  centre_dates = FALSE,                   \n  date_format = \"%a %d %b\\n%Y (Week %W)\", \n  angle = 30                           # angle of date labels\n  )+\n  \n  scale_y_continuous(\n    breaks = seq(from = 0, to = 30, by = 5),  # specify y-axis increments by 5\n    expand = c(0,0))+                         # remove excess space below 0 on y-axis\n  \n  # add dynamic caption\n  labs(\n    fill = \"Patient outcome\",                               # Legend title\n    caption = stringr::str_glue(                            # dynamic caption - see page on characters and strings for details\n      \"n = {central_cases} from Central Hospital\n      Case onsets range from {earliest_date} to {latest_date}. {missing_onset} cases are missing date of onset and not shown\",\n      central_cases = nrow(central_data),\n      earliest_date = format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y'),\n      latest_date = format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y'),      \n      missing_onset = nrow(central_data %>% filter(is.na(date_onset)))))+\n  \n  # adjust bold face, and caption position\n  theme(\n    axis.title = element_text(size = 12, face = \"bold\"),    # axis titles larger and bold\n    axis.text = element_text(size = 10, face = \"bold\"),     # axis text size and bold\n    plot.caption = element_text(hjust = 0, face = \"italic\") # move caption to left\n  )"},{"path":"salgın-eğrileri.html","id":"renkleri-değiştirmek","chapter":"32 Salgın eğrileri","heading":"Renkleri değiştirmek","text":"","code":""},{"path":"salgın-eğrileri.html","id":"bir-palet-belirtin","chapter":"32 Salgın eğrileri","heading":"Bir palet belirtin","text":"plot()içindeki col_pal = argümanına önceden tanımlanmış bir paletin adını sağlayın. incidence2 paketi, önceden tanımlanmış 2 paletle gelir: “canlı” ve “sessiz”. “Canlı”da ilk 6 renk belirgin ve “sessiz”de ilk 9 renk farklıdır. Bu sayılardan sonra renkler, diğer renklerin interpolasyonları/aracılarıdır. Bu önceden tanımlanmış paletler bu web sitesinde bulunabilir. Paletler, eksik veriler için ayrılan gri rengi hariç tutar (bu varsayılanı değiştirmek için na_color = kullanın).Ayrıca R tabanı paletlerinden birini de kullanabilirsiniz (palet adını tırnak işaretleri olmadan yazın).Ayrıca viridis paketinden veya RColorBrewer paketinden bir renk paleti ekleyebilirsiniz. Önce bu paketler yüklenmelidir, ardından aşağıda gösterildiği gibi ilgili scale_fill_*() fonksiyonlarını bir + ile ekleyin.","code":"\n# Create incidence object, with data grouped by age category  \nage_outbreak <- incidence(\n  linelist,\n  date_index = date_onset,   # date of onset for x-axis\n  interval = \"week\",         # weekly aggregation of cases\n  groups = age_cat)\n\n# plot the epicurve with default palette\nplot(age_outbreak, fill = age_cat, title = \"'vibrant' default incidence2 palette\")\n\n# plot with different color palette\n#plot(age_outbreak, fill = age_cat, col_pal = muted, title = \"'muted' incidence2 palette\")\n# plot with base R palette\nplot(age_outbreak, fill = age_cat, col_pal = heat.colors, title = \"base R heat.colors palette\")\n\n# plot with base R palette\nplot(age_outbreak, fill = age_cat, col_pal = rainbow, title = \"base R rainbow palette\")\npacman::p_load(RColorBrewer, viridis)\n\n# plot with color palette\nplot(age_outbreak, fill = age_cat, title = \"Viridis palette\")+\n  scale_fill_viridis_d(\n    option = \"inferno\",     # color scheme, try also \"plasma\" or the default\n    name = \"Age Category\",  # legend name\n    na.value = \"grey\")      # for missing values\n\n# plot with color palette\nplot(age_outbreak, fill = age_cat, title = \"RColorBrewer palette\")+\n  scale_fill_brewer(\n    palette = \"Dark2\",      # color palette, try also Accent, Dark2, Paired, Pastel1, Pastel2, Set1, Set2, Set3\n    name = \"Age Category\",  # legend name\n    na.value = \"grey\")      # for missing values"},{"path":"salgın-eğrileri.html","id":"manuel-olarak-belirtin","chapter":"32 Salgın eğrileri","heading":"Manuel olarak belirtin","text":"Renkleri manuel olarak belirtmek için, ggplot2 işlevini scale_fill_manual()ile plot()öğesine bir + ekleyin ve renk adlarının vektörünü veya HEX kodlarını bağımsız değişken values = sağlayın. Listelenen renk sayısı, grup sayısına eşit olmalıdır. Eksik değerlerin bir grup olup olmadığına dikkat edin - Faktörler sayfasında açıklandığı gibi fct_explicit_na()işleviyle veri hazırlamanız sırasında “Missing” gibi bir karakter değerine dönüştürülebilirler.Ggplot ipuçları sayfasında belirtildiği gibi, bir renk vektörü üzerinde colorRampPalette() kullanarak ve karşılığında istediğiniz renk sayısını belirterek kendi paletlerinizi oluşturabilirsiniz. Bu, birkaçını belirterek bir rampada birçok rengi elde etmenin iyi bir yoludur.","code":"\n# manual colors\nplot(age_outbreak, fill = age_cat, title = \"Manually-specified colors\")+\n  scale_fill_manual(\n    values = c(\"darkgreen\", \"darkblue\", \"purple\", \"grey\", \"yellow\", \"orange\", \"red\", \"lightblue\"),  # colors\n    name = \"Age Category\")      # Name for legend\nmy_cols <- c(\"darkgreen\", \"darkblue\", \"purple\", \"grey\", \"yellow\", \"orange\")\nmy_palette <- colorRampPalette(my_cols)(12)  # expand the 6 colors above to 12 colors\nmy_palette##  [1] \"#006400\" \"#00363F\" \"#00097E\" \"#3A0BAF\" \"#821ADD\" \"#A84BE2\" \"#B592CB\" \"#C9C99B\" \"#E7E745\" \"#FFF600\" \"#FFCD00\"\n## [12] \"#FFA500\""},{"path":"salgın-eğrileri.html","id":"seviye-sırasını-ayarla","chapter":"32 Salgın eğrileri","heading":"Seviye sırasını ayarla","text":"Grup görünüm sırasını ayarlamak için (grafikte ve göstergede), gruplandırma sütunu sınıf Faktörü olmalıdır. Daha fazla bilgi için Faktörler sayfasına bakın.İlk olarak, varsayılan sıralamayla hastaneye göre haftalık bir salgın eğrisini görelim:Şimdi sırayı “Eksik” ve “Diğer” salgın eğrisinin en üstünde olacak şekilde ayarlamak için aşağıdakileri yapabiliriz:Faktörlerle çalışmak için forcats paketini yükleyin.Veri kümesini ayarlayın - bu durumda aşağıdakileri içeren yeni bir veri kümesi (plot_data) tanımlayacağız:\ngender sütunu bir faktör olarak tanımlanır, seviyelerin sırası fct_relevel() ile ayarlanır, böylece “Diğer” ve “Eksik” ilk olur, böylece çubukların en üstünde görünürler.\ngender sütunu bir faktör olarak tanımlanır, seviyelerin sırası fct_relevel() ile ayarlanır, böylece “Diğer” ve “Eksik” ilk olur, böylece çubukların en üstünde görünürler.İnsidans nesnesi daha önce olduğu gibi oluşturulur ve grafiklendirilirggplot2 değişiklikleri ekliyoruz;\n“Eksik” gri ve “Diğer” bej olacak şekilde renkleri manuel olarak atamak için scale_fill_manual()\n“Eksik” gri ve “Diğer” bej olacak şekilde renkleri manuel olarak atamak için scale_fill_manual()İPUCU: Yalnızca göstergenin sırasını tersine çevirmek istiyorsanız, bu ggplot2 komut kılavuzlarını ekleyin guides(fill = guide_legend(reverse = TRUE)).","code":"\n# ORIGINAL - hospital NOT as factor\n###################################\n\n# create weekly incidence object, rows grouped by hospital and week\nhospital_outbreak <- incidence(\n  linelist,\n  date_index = date_onset, \n  interval = \"week\", \n  groups = hospital)\n\n# plot incidence object\nplot(hospital_outbreak, fill = hospital, title = \"ORIGINAL - hospital not a factor\")\n# MODIFIED - hospital as factor\n###############################\n\n# load forcats package for working with factors\npacman::p_load(forcats)\n\n# Convert hospital column to factor and adjust levels\nplot_data <- linelist %>% \n  mutate(hospital = fct_relevel(hospital, c(\"Missing\", \"Other\"))) # Set \"Missing\" and \"Other\" as top levels\n\n\n# Create weekly incidence object, grouped by hospital and week\nhospital_outbreak_mod <- incidence(\n  plot_data,\n  date_index = date_onset, \n  interval = \"week\", \n  groups = hospital)\n\n# plot incidence object\nplot(hospital_outbreak_mod, fill = hospital)+\n  \n  # manual specify colors\n  scale_fill_manual(values = c(\"grey\", \"beige\", \"darkgreen\", \"green2\", \"orange\", \"red\", \"pink\"))+                      \n\n  # labels added via ggplot\n  labs(\n      title = \"MODIFIED - hospital as factor\",   # plot title\n      subtitle = \"Other & Missing at top of epicurve\",\n      y = \"Weekly case incidence\",               # y axis title  \n      x = \"Week of symptom onset\",               # x axis title\n      fill = \"Hospital\")                         # title of legend     "},{"path":"salgın-eğrileri.html","id":"dikey-klavuz-çizgileri","chapter":"32 Salgın eğrileri","heading":"Dikey klavuz çizgileri","text":"Varsayılan incidence2 ayarlarıyla çizerseniz, dikey kılavuz çizgilerinin tarih etiketinde ve tarih etiketi arasında bir kez göründüğünü fark edebilirsiniz. Bu, ızgara çizgilerinin bazı çubukların üst kısmıyla kesişmesine neden olabilir.ggplot2 komutunu theme_classic()ekleyerek tüm kılavuz çizgilerini kaldırabilirsiniz.Bununla birlikte, haftalar kullanılıyorsa, date_breaks ve date_minor_breaks argümanlarının yalnızca Pazartesi haftaları için çalıştığını unutmayın. Haftalarınız haftanın başka bir günüyse, bunun yerine breaks = ve minor_breaks = argümanlarına manuel olarak bir tarih vektörü sağlamanız gerekir. seq.Date()kullanarak bunun örnekleri için ggplot2 bölümüne bakın.","code":"\n# make incidence object\na <- incidence(\n  central_data,\n  date_index = date_onset,\n  interval = \"Monday weeks\"\n)\n\n# Default gridlines\nplot(a, title = \"Default lines\")\n\n# Specified gridline intervals\n# NOT WORKING WITH INCIDENCE2 1.0.0\n# plot(a, title = \"Weekly lines\")+\n#   scale_x_date(\n#     date_breaks = \"4 weeks\",      # major vertical lines align on weeks\n#     date_minor_breaks = \"weeks\",  # minor vertical lines every week\n#     date_labels = \"%a\\n%d\\n%b\")   # format of date labels\n\n# No gridlines\nplot(a, title = \"No lines\")+\n  theme_classic()                 # remove all gridlines"},{"path":"salgın-eğrileri.html","id":"kümülatif-insidans","chapter":"32 Salgın eğrileri","heading":"Kümülatif insidans","text":"İnsidans nesnesini incidence2 cumulate() komutuna ve ardından plot() komutuna ileterek, kümülatif insidansın bir grafiğini kolaylıkla üretebilirsiniz. Bu aynı zamanda facet_plot() ile de çalışır.ggplot2 ile kümülatif insidansı çizmek için alternatif yöntem için bu sayfanın ilerisindeki bölüme bakın - örneğin, bir salgın eğrisi üzerine kümülatif bir insidans çizgisini bindirmek gibi.","code":"\n# make weekly incidence object\nwkly_inci <- incidence(\n  linelist,\n  date_index = date_onset,\n  interval = \"week\"\n)\n\n# plot cumulative incidence\nwkly_inci %>% \n  cumulate() %>% \n  plot()"},{"path":"salgın-eğrileri.html","id":"ortalama-yuvarlama","chapter":"32 Salgın eğrileri","heading":"Ortalama yuvarlama","text":"i2extras paketindeki add_rolling_average()ile kolayca bir incidence2 grafiğine hareketli bir ortalama ekleyebilirsiniz. İnsidans2 nesnenizi bu işleve ve ardından plot() öğesine iletin. = olarak ayarlayın, dönen ortalamaya dahil edilmesini istediğiniz önceki günlerin sayısı (varsayılan 2’dir). Verileriniz gruplandırılmışsa, hareketli ortalama grup başına hesaplanacaktır.Verilere daha genel olarak yuvarlanan ortalamaların nasıl uygulanacağını öğrenmek için Hareketli ortalamalar hakkındaki El Kitabı sayfasına bakın.","code":"\nrolling_avg <- incidence(                    # make incidence object\n  linelist,\n  date_index = date_onset,\n  interval = \"week\",\n  groups = gender) %>% \n  \n  i2extras::add_rolling_average(before = 6)  # add rolling averages (in this case, by gender)\n\n# plot\nplot(rolling_avg) # faceted automatically because rolling average on groups"},{"path":"salgın-eğrileri.html","id":"ggplot2-ile-salgın-eğrileri","chapter":"32 Salgın eğrileri","heading":"32.3 ggplot2 ile salgın eğrileri","text":"Salgın eğrinizi oluşturmak için ggplot()’u kullanmak daha fazla esneklik ve özelleştirme sağlar, ancak ggplot()’un nasıl çalıştığına dair daha fazla çaba ve anlayış gerektirir.incidence2 paketini kullanmaktan farklı olarak, vakaların zamana (haftalara, aylara vb.) göre toplanmasını ve tarih eksenindeki etiketlerin sonlanmalarını manuel olarak kontrol etmelisiniz. Bu dikkatle yönetilmelidir.Bu örnekler, linelist veri kümesinin bir alt kümesini kullanır - yalnızca Central Hospital’daki vakalar.ggplot() ile bir salgın eğrisi oluşturmak için üç ana unsur vardır:Belirli “sonlanlanma” noktalarıyla ayırt edilen “bölmelere” toplanmış satır listesi vakaları içeren bir histogram,Eksenler ve etiketleri için ölçekler,Başlıklar, etiketler, altyazılar vb. dahil olmak üzere grafik görünümü için temalar.","code":"\ncentral_data <- linelist %>% \n  filter(hospital == \"Central Hospital\")"},{"path":"salgın-eğrileri.html","id":"vaka-bölmelerini-belirtin","chapter":"32 Salgın eğrileri","heading":"Vaka bölmelerini belirtin","text":"Burada, vakaların histogram bölmelerinde (“çubuklar”) nasıl toplanacağını belirteceğiz. Vakaların histogram bölmelerinde toplanmasının, x ekseninde görünecek tarihlerle mutlaka aynı sonlanmalar olmadığını bilmek önemlidir.Aşağıda, günlük ve haftalık salgın eğrileri üretmek için belki de en basit kod verilmiştir.Aşırı kemerli ggplot() komutunda, veri kümesi data = olarak sağlanır. Bu temel üzerine, bir histogramın geometrisi + ile eklenir. geom_histogram() içinde, date_onset sütunu x eksenine eşlenecek şekilde estetiği eşleriz. Ayrıca geom_histogram() içinde ama aes() içinde değil, histogram bölmelerinin binwidth = değerini gün olarak ayarladık. Bu ggplot2 sözdizimi kafa karıştırıcıysa, ggplot temelleri hakkındaki sayfayı inceleyin.DİKKAT: binwidth = 7 kullanarak haftalık vakaları grafiklendirmek, ilk durumda ilk 7 günlük bölmeyi başlatır, bu haftanın herhangi bir günü olabilir! Belirli haftalar oluşturmak için aşağıdaki bölüme bakın. Bu Central Hopital veri setindeki ilk vakanın aşağıdakilerde semptom başlangıcı olduğunu edelim:Histogram bölme kesmelerini manuel olarak belirtmek için bölme binwidth = argümanını kullanmayın ve bunun yerine breaks = için bir tarih vektörü sağlayın.R tabanı işlevi seq.Date()ile tarihlerin vektörünü oluşturun. Bu fonksiyon =, = ve = argümanlarını bekler. Örneğin, aşağıdaki komut, 15 Ocak’ta başlayan ve 28 Haziran’kadar biten aylık tarihleri döndürür.Bu vektör geom_histogram()’breaks = olarak sağlanabilir:Basit bir haftalık tarih dizisi, = \"week\" ile ayarlanarak döndürülebilir. Örneğin:Belirli başlangıç ve bitiş tarihlerini sağlamaya bir alternatif, haftalık bölmelerin ilk durumdan önceki Pazartesi günü başlaması için dinamik kod yazmaktır. Aşağıdaki örneklerde bu tarih vektörlerini kullanacağız.Yukarıdaki oldukça göz korkutucu kodu açalım:“” değeri (dizinin en erken tarihi) şu şekilde oluşturulur: date_onset sütunundaki minimum tarih değeri (min() ile na.rm=TRUE) lubridate paketinden floor_date() öğesine beslenir. floor_date() “hafta” olarak ayarlandığında, haftanın başlangıç gününün Pazartesi olması koşuluyla (week_start = 1) bu vakaların “hafta”sının başlangıç tarihini döndürür.Benzer şekilde, “” değeri (dizinin bitiş tarihi), son vakadan sonraki Pazartesi gününü döndürmek için ceiling_date() ters işlevi kullanılarak oluşturulur.seq.Date() öğesinin “” argümanı herhangi bir sayıda gün, hafta veya aya ayarlanabilir.Pazar haftaları için week_start = 7 kullanın.Bu sayfa boyunca bu veri vektörlerini kullanacağımız için, tüm salgın için bir tane de tanımladık (yukarıdakiler sadece Central Hospital içindir).Bu seq.Date()çıktıları, histogram bölme sonlanmalarını oluşturmak için kullanılabilir, ancak aynı zamanda bölmelerden bağımsız olabilen tarih etiketleri için sonlanmalar da kullanılabilir. Sonraki bölümlerde tarih etiketleri hakkında daha fazla bilgi edinin.İPUCU: Daha basit bir ggplot() komutu için, bölme sonlanmalarını ve etiket sonlanmalarını önceden adlandırılmış vektörler olarak kaydedin ve yalnızca adlarını breaks = olarak değiştirin.","code":"\n# daily \nggplot(data = central_data) +          # set data\n  geom_histogram(                      # add histogram\n    mapping = aes(x = date_onset),     # map date column to x-axis\n    binwidth = 1)+                     # cases binned by 1 day \n  labs(title = \"Central Hospital - Daily\")                # title\n\n# weekly\nggplot(data = central_data) +          # set data \n  geom_histogram(                      # add histogram\n      mapping = aes(x = date_onset),   # map date column to x-axis\n      binwidth = 7)+                   # cases binned every 7 days, starting from first case (!) \n  labs(title = \"Central Hospital - 7-day bins, starting at first case\") # title\nformat(min(central_data$date_onset, na.rm=T), \"%A %d %b, %Y\")## [1] \"Thursday 01 May, 2014\"\nmonthly_breaks <- seq.Date(from = as.Date(\"2014-02-01\"),\n                           to = as.Date(\"2015-07-15\"),\n                           by = \"months\")\n\nmonthly_breaks   # print##  [1] \"2014-02-01\" \"2014-03-01\" \"2014-04-01\" \"2014-05-01\" \"2014-06-01\" \"2014-07-01\" \"2014-08-01\" \"2014-09-01\"\n##  [9] \"2014-10-01\" \"2014-11-01\" \"2014-12-01\" \"2015-01-01\" \"2015-02-01\" \"2015-03-01\" \"2015-04-01\" \"2015-05-01\"\n## [17] \"2015-06-01\" \"2015-07-01\"\n# monthly \nggplot(data = central_data) +  \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    breaks = monthly_breaks)+         # provide the pre-defined vector of breaks                    \n  labs(title = \"Monthly case bins\")   # title\nweekly_breaks <- seq.Date(from = as.Date(\"2014-02-01\"),\n                          to = as.Date(\"2015-07-15\"),\n                          by = \"week\")\n# Sequence of weekly Monday dates for CENTRAL HOSPITAL\nweekly_breaks_central <- seq.Date(\n  from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 1), # monday before first case\n  to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 1), # monday after last case\n  by   = \"week\")\n# Sequence for the entire outbreak\nweekly_breaks_all <- seq.Date(\n  from = floor_date(min(linelist$date_onset, na.rm=T),   \"week\", week_start = 1), # monday before first case\n  to   = ceiling_date(max(linelist$date_onset, na.rm=T), \"week\", week_start = 1), # monday after last case\n  by   = \"week\")"},{"path":"salgın-eğrileri.html","id":"haftalık-salgın-eğrisi-örneği","chapter":"32 Salgın eğrileri","heading":"Haftalık salgın eğrisi örneği","text":"Aşağıda, hizalanmış çubuklar, tarih etiketleri ve dikey kılavuz çizgileri ile Pazartesi haftaları için haftalık salıgın eğrileri oluşturmak için ayrıntılı örnek kod verilmiştir. Bu bölüm, hızlı bir şekilde koda ihtiyaç duyan kullanıcı içindir. yönü (temalar, tarih etiketleri vb.) derinlemesine anlamak için sonraki bölümlere geçin. Önemli:Histogram bölme araları, en erken vakadan önceki Pazartesi günü başlayacak ve son vakadan sonraki Pazartesi günü sona erecek şekilde yukarıda açıklandığı gibi seq.Date()ile tanımlanır.Tarih etiketlerinin aralığı, scale_x_date() içinde date_breaks = ile belirtilir.Tarih etiketleri arasındaki küçük dikey kılavuz çizgilerinin aralığı, date_minor_breaks = olarak belirtilir.x ve y ölçeklerinde expand = c(0,0)eksenlerin iki yanındaki fazla boşluğu kaldırır, bu da tarih etiketlerinin ilk çubuktan başlamasını sağlar.","code":"\n# TOTAL MONDAY WEEK ALIGNMENT\n#############################\n# Define sequence of weekly breaks\nweekly_breaks_central <- seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 1), # Monday before first case\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 1), # Monday after last case\n      by   = \"week\")    # bins are 7-days \n\n\nggplot(data = central_data) + \n  \n  # make histogram: specify bin break points: starts the Monday before first case, end Monday after last case\n  geom_histogram(\n    \n    # mapping aesthetics\n    mapping = aes(x = date_onset),  # date column mapped to x-axis\n    \n    # histogram bin breaks\n    breaks = weekly_breaks_central, # histogram bin breaks defined previously\n    \n    # bars\n    color = \"darkblue\",     # color of lines around bars\n    fill = \"lightblue\"      # color of fill within bars\n  )+ \n    \n  # x-axis labels\n  scale_x_date(\n    expand            = c(0,0),           # remove excess x-axis space before and after case bars\n    date_breaks       = \"4 weeks\",        # date labels and major vertical gridlines appear every 3 Monday weeks\n    date_minor_breaks = \"week\",           # minor vertical lines appear every Monday week\n    date_labels       = \"%a\\n%d %b\\n%Y\")+ # date labels format\n  \n  # y-axis\n  scale_y_continuous(\n    expand = c(0,0))+             # remove excess y-axis space below 0 (align histogram flush with x-axis)\n  \n  # aesthetic themes\n  theme_minimal()+                # simplify plot background\n  \n  theme(\n    plot.caption = element_text(hjust = 0,        # caption on left side\n                                face = \"italic\"), # caption in italics\n    axis.title = element_text(face = \"bold\"))+    # axis titles in bold\n  \n  # labels including dynamic caption\n  labs(\n    title    = \"Weekly incidence of cases (Monday weeks)\",\n    subtitle = \"Note alignment of bars, vertical gridlines, and axis labels on Monday weeks\",\n    x        = \"Week of symptom onset\",\n    y        = \"Weekly incident cases reported\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown\"))"},{"path":"salgın-eğrileri.html","id":"pazar-haftaları","chapter":"32 Salgın eğrileri","heading":"Pazar haftaları","text":"Pazar haftaları için yukarıdaki grafiği elde etmek için birkaç değişiklik gereklidir, çünkü date_breaks = \"weeks\" sadece Pazartesi haftaları için çalışır.Histogram bölmelerinin sonlanma noktaları Pazar günleri olarak ayarlanmalıdır (week_start = 7).scale_x_date() içinde, tarih etiketlerinin ve dikey kılavuz çizgilerinin Pazar günleri hizalanmasını sağlamak için breaks = ve minor_breaks = için benzer tarih sonlanmaları sağlanmalıdır.Örneğin, Pazar haftaları için scale_x_date() komutu şöyle görünebilir:","code":"scale_x_date(\n    expand = c(0,0),\n    \n    # specify interval of date labels and major vertical gridlines\n    breaks = seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7), # Sunday before first case\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7), # Sunday after last case\n      by   = \"4 weeks\"),\n    \n    # specify interval of minor vertical gridline \n    minor_breaks = seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7), # Sunday before first case\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7), # Sunday after last case\n      by   = \"week\"),\n   \n    # date label format\n    date_labels = \"%a\\n%d %b\\n%Y\")+         # day, above month abbrev., above 2-digit year"},{"path":"salgın-eğrileri.html","id":"değere-göre-gruprenk","chapter":"32 Salgın eğrileri","heading":"Değere göre grup/renk","text":"Histogram çubukları, grup ve “yığılmış” olarak renklendirilebilir. Gruplandırma sütununu atamak için aşağıdaki değişiklikleri yapın. Ayrıntılar için ggplot temelleri sayfasına bakın.Histogram estetik haritalama aes()içinde, sütun adını group = ve fill = bağımsız değişkenini eşleştirin.aes() dışındaki herhangi bir fill = argümanını kaldırın, çünkü içindekini geçersiz kılar.aes() içindeki argümanlar gruba göre uygulanırken, dışındaki herhangi bir argüman tüm çubuklara uygulanacaktır (örneğin, yine de color = dışarıda isteyebilirsiniz, böylece çubuk aynı kenarlığa sahip olur).Çubukları cinsiyete göre gruplamak ve renklendirmek için aes()komutu şöyle görünür:Burada uygulanır:","code":"\naes(x = date_onset, group = gender, fill = gender)\nggplot(data = linelist) +     # begin with linelist (many hospitals)\n  \n  # make histogram: specify bin break points: starts the Monday before first case, end Monday after last case\n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = hospital,       # set data to be grouped by hospital\n      fill = hospital),       # bar fill (inside color) by hospital\n    \n    # bin breaks are Monday weeks\n    breaks = weekly_breaks_all,   # sequence of weekly Monday bin breaks for whole outbreak, defined in previous code       \n    \n    # Color around bars\n    color = \"black\")"},{"path":"salgın-eğrileri.html","id":"renkleri-ayarlamak","chapter":"32 Salgın eğrileri","heading":"Renkleri ayarlamak","text":"grup için dolguyu manuel olarak ayarlamak için scale_fill_manual() öğesini kullanın (: scale_color_manual() farklıdır!).\nBir renk vektörü uygulamak için values = argümanını kullanın.\nNA değerleri için bir renk belirtmek için na.value = kullanın.\nGösterge öğelerinin metnini değiştirmek için labels = argümanını kullanın. Güvende olmak için, c(\"old\" = \"new\", \"old\" = \"new\") gibi adlandırılmış bir vektör sağlayın veya verilerin kendisindeki değerleri ayarlayın.\nAçıklamaya uygun bir başlık koymak için name = kullanın.\nBir renk vektörü uygulamak için values = argümanını kullanın.NA değerleri için bir renk belirtmek için na.value = kullanın.Gösterge öğelerinin metnini değiştirmek için labels = argümanını kullanın. Güvende olmak için, c(\"old\" = \"new\", \"old\" = \"new\") gibi adlandırılmış bir vektör sağlayın veya verilerin kendisindeki değerleri ayarlayın.Açıklamaya uygun bir başlık koymak için name = kullanın.Renk ölçekleri ve paletler hakkında daha fazla ipucu için ggplot temelleri sayfasına bakın.","code":"\nggplot(data = linelist)+           # begin with linelist (many hospitals)\n  \n  # make histogram\n  geom_histogram(\n    mapping = aes(x = date_onset,\n        group = hospital,          # cases grouped by hospital\n        fill = hospital),          # bar fill by hospital\n    \n    # bin breaks\n    breaks = weekly_breaks_all,        # sequence of weekly Monday bin breaks, defined in previous code\n    \n    # Color around bars\n    color = \"black\")+              # border color of each bar\n  \n  # manual specification of colors\n  scale_fill_manual(\n    values = c(\"black\", \"orange\", \"grey\", \"beige\", \"blue\", \"brown\"),\n    labels = c(\"St. Mark's Maternity Hospital (SMMH)\" = \"St. Mark's\"),\n    name = \"Hospital\") # specify fill colors (\"values\") - attention to order!"},{"path":"salgın-eğrileri.html","id":"seviye-sırasını-ayarlamak","chapter":"32 Salgın eğrileri","heading":"Seviye sırasını ayarlamak","text":"Gruplandırılmış çubukların istiflendiği sıra, en iyi şekilde gruplandırma sütununu sınıf Faktörü olarak sınıflandırarak ayarlanır. Daha sonra faktör düzeyi sırasını (ve bunların görüntü etiketlerini) belirleyebilirsiniz. Ayrıntılar için Faktörler veya ggplot ipuçları sayfasına bakın.Grafiği yapmadan önce, gruplandırma sütununu sınıf faktörüne dönüştürmek için forcats paketindeki fct_relevel() işlevini kullanın ve Faktörler sayfasında ayrıntılı olarak açıklandığı gibi seviye sırasını manuel olarak ayarlayın.Aşağıdaki çizimde, öncekinden tek fark, hospital sütununu yukarıdaki gibi konsolide edilmiş olmasıdır ve gösterge sırasını tersine çevirmek için guides()kullanıyoruz, böylece “Eksik” göstergenin alt kısmındadır.İPUCU: Yalnızca göstergenin sırasını tersine çevirmek için bu ggplot2 komutunu ekleyin: guides(fill = guide_legend(reverse = TRUE)).","code":"\n# load forcats package for working with factors\npacman::p_load(forcats)\n\n# Define new dataset with hospital as factor\nplot_data <- linelist %>% \n  mutate(hospital = fct_relevel(hospital, c(\"Missing\", \"Other\"))) # Convert to factor and set \"Missing\" and \"Other\" as top levels to appear on epicurve top\n\nlevels(plot_data$hospital) # print levels in order## [1] \"Missing\"                              \"Other\"                               \n## [3] \"Central Hospital\"                     \"Military Hospital\"                   \n## [5] \"Port Hospital\"                        \"St. Mark's Maternity Hospital (SMMH)\"\nggplot(plot_data) +                     # Use NEW dataset with hospital as re-ordered factor\n  \n  # make histogram\n  geom_histogram(\n    mapping = aes(x = date_onset,\n        group = hospital,               # cases grouped by hospital\n        fill = hospital),               # bar fill (color) by hospital\n    \n    breaks = weekly_breaks_all,         # sequence of weekly Monday bin breaks for whole outbreak, defined at top of ggplot section\n    \n    color = \"black\")+                   # border color around each bar\n    \n  # x-axis labels\n  scale_x_date(\n    expand            = c(0,0),         # remove excess x-axis space before and after case bars\n    date_breaks       = \"3 weeks\",      # labels appear every 3 Monday weeks\n    date_minor_breaks = \"week\",         # vertical lines appear every Monday week\n    date_labels       = \"%d\\n%b\\n'%y\")+ # date labels format\n  \n  # y-axis\n  scale_y_continuous(\n    expand = c(0,0))+                   # remove excess y-axis space below 0\n  \n  # manual specification of colors, ! attention to order\n  scale_fill_manual(\n    values = c(\"grey\", \"beige\", \"black\", \"orange\", \"blue\", \"brown\"),\n    labels = c(\"St. Mark's Maternity Hospital (SMMH)\" = \"St. Mark's\"),\n    name = \"Hospital\")+ \n  \n  # aesthetic themes\n  theme_minimal()+                      # simplify plot background\n  \n  theme(\n    plot.caption = element_text(face = \"italic\", # caption on left side in italics\n                                hjust = 0), \n    axis.title = element_text(face = \"bold\"))+   # axis titles in bold\n  \n  # labels\n  labs(\n    title    = \"Weekly incidence of cases by hospital\",\n    subtitle = \"Hospital as re-ordered factor\",\n    x        = \"Week of symptom onset\",\n    y        = \"Weekly cases\")"},{"path":"salgın-eğrileri.html","id":"göstergeyi-ayarlamak","chapter":"32 Salgın eğrileri","heading":"Göstergeyi ayarlamak","text":"ggplot ipuçları sayfasında göstergeler ve ölçekler hakkında daha fazla bilgi edinin. İşte birkaç önemli nokta:Gösterge başlığını ölçek işlevinde veya labs(fill = \"Legend title\") ile düzenleyin (color = estetik kullanıyorsanız, labs(color = \"\") kullanın)Gösterge başlığının olmaması için theme(legend.title = element_blank()) kulanın.theme(legend.position = \"top\") (göstergeyi kaldırmak için “alt”, “sol”, “sağ” veya “yok”) kullanın.Yatay gösterge için theme(legend.direction = \"horizontal\") kullanın.Göstergenin sırasını tersine çevirmek için guides(fill = guide_legend(reverse = TRUE)) kullanın.","code":""},{"path":"salgın-eğrileri.html","id":"yan-yana-çubuklar","chapter":"32 Salgın eğrileri","heading":"Yan yana çubuklar","text":"Grup çubuklarının yan yana gösterimi (yığılmışın aksine) geom_histogram()içinde, position = \"dodge\" aes() dışına yerleştirilerek belirtilir.İkiden fazla değer grubu varsa, bunların okunması zorlaşabilir. Bunun yerine fasetli bir grafik (küçük katlar) kullanmayı düşünün. Bu örnekte okunabilirliği artırmak için eksik cinsiyet değerleri kaldırılmıştır.","code":"\nggplot(central_data %>% drop_na(gender))+   # begin with Central Hospital cases dropping missing gender\n    geom_histogram(\n        mapping = aes(\n          x = date_onset,\n          group = gender,         # cases grouped by gender\n          fill = gender),         # bars filled by gender\n        \n        # histogram bin breaks\n        breaks = weekly_breaks_central,   # sequence of weekly dates for Central outbreak - defined at top of ggplot section\n        \n        color = \"black\",          # bar edge color\n        \n        position = \"dodge\")+      # SIDE-BY-SIDE bars\n                      \n  \n  # The labels on the x-axis\n  scale_x_date(expand            = c(0,0),         # remove excess x-axis space below and after case bars\n               date_breaks       = \"3 weeks\",      # labels appear every 3 Monday weeks\n               date_minor_breaks = \"week\",         # vertical lines appear every Monday week\n               date_labels       = \"%d\\n%b\\n'%y\")+ # date labels format\n  \n  # y-axis\n  scale_y_continuous(expand = c(0,0))+             # removes excess y-axis space between bottom of bars and the labels\n  \n  #scale of colors and legend labels\n  scale_fill_manual(values = c(\"brown\", \"orange\"),  # specify fill colors (\"values\") - attention to order!\n                    na.value = \"grey\" )+     \n\n  # aesthetic themes\n  theme_minimal()+                                               # a set of themes to simplify plot\n  theme(plot.caption = element_text(face = \"italic\", hjust = 0), # caption on left side in italics\n        axis.title = element_text(face = \"bold\"))+               # axis titles in bold\n  \n  # labels\n  labs(title    = \"Weekly incidence of cases, by gender\",\n       subtitle = \"Subtitle\",\n       fill     = \"Gender\",                                      # provide new title for legend\n       x        = \"Week of symptom onset\",\n       y        = \"Weekly incident cases reported\")"},{"path":"salgın-eğrileri.html","id":"eksen-sınırları","chapter":"32 Salgın eğrileri","heading":"Eksen sınırları","text":"Eksen değerlerinin kapsamını sınırlamanın iki yolu vardır:Genellikle tercih edilen yol, xlim = c(min, max) ve ylim = c(min, max) (min ve max değerlerini sağladığınız) kabul eden coord_cartesian()komutunu kullanmaktır. Bu, istatistikler ve özet ölçümler için önemli olan herhangi bir veriyi fiilen kaldırmadan bir “yakınlaştırma” görevi görür.Alternatif olarak, scale_x_date()içinde limits = c() kullanarak maksimum ve minimum tarih değerlerini ayarlayabilirsiniz. Örneğin:Benzer şekilde, x ekseninin belirli bir tarihe (örn. geçerli tarih) uzanmasını istiyorsanız, yeni vaka bildirilmemiş olsa bile şunları kullanabilirsiniz:TEHLİKE: y ekseni ölçek sonları veya sınırlarını ayarlarken dikkatli olun (örn. 0 ila 30 5: seq(0, 30, 5)). Bu tür statik sayılar, veriler sınırı aşacak şekilde değişirse grafiğinizi çok kısa kesebilir!.","code":"\nscale_x_date(limits = c(as.Date(\"2014-04-01\"), NA)) # sets a minimum date but leaves the maximum open.  scale_x_date(limits = c(NA, Sys.Date()) # ensures date axis will extend until current date  "},{"path":"salgın-eğrileri.html","id":"tarih-ekseni-etiketlerikılavuz-çizgileri","chapter":"32 Salgın eğrileri","heading":"Tarih ekseni etiketleri/kılavuz çizgileri","text":"İPUCU: Tarih ekseni etiketlerinin verilerin çubuklar halinde toplanmasından bağımsız olduğunu, ancak görsel olarak bölmeleri, tarih etiketlerini ve dikey kılavuz çizgilerini hizalamanın önemli olabileceğini unutmayın.Tarih etiketlerini ve kılavuz çizgilerini değiştirmek için, şu yollardan biriyle scale_x_date() kullanın:Histogram bölmeleriniz günler, Pazartesi haftaları, aylar veya yıllar ise:\nEtiketlerin ve ana kılavuz çizgilerinin aralığını belirtmek için date_breaks = kullanın (ör. “gün”, “hafta”, “3 hafta”, “ay” veya “yıl”).\nKüçük dikey kılavuz çizgilerinin aralığını belirtmek için date_minor_breaks = kullanın (tarih etiketleri arasında).\nEtiketlere ilk çubuktan başlamak için expand = c(0,0) ekleyin.\nTarih etiketlerinin biçimini belirtmek için date_labels = kullanın - ipuçları için tarihler sayfasına bakın (yeni bir satır için \\n kullanın).\nEtiketlerin ve ana kılavuz çizgilerinin aralığını belirtmek için date_breaks = kullanın (ör. “gün”, “hafta”, “3 hafta”, “ay” veya “yıl”).Küçük dikey kılavuz çizgilerinin aralığını belirtmek için date_minor_breaks = kullanın (tarih etiketleri arasında).Etiketlere ilk çubuktan başlamak için expand = c(0,0) ekleyin.Tarih etiketlerinin biçimini belirtmek için date_labels = kullanın - ipuçları için tarihler sayfasına bakın (yeni bir satır için \\n kullanın).Histogram bölmeleriniz Pazar haftalarıysa:\nbiri için bir tarih sonları dizisi sağlayarak breaks = ve minor_breaks = kullanın.\nYukarıda açıklandığı gibi biçimlendirme için hala ddate_labels = ve expand = kullanabilirsiniz.\nbiri için bir tarih sonları dizisi sağlayarak breaks = ve minor_breaks = kullanın.Yukarıda açıklandığı gibi biçimlendirme için hala ddate_labels = ve expand = kullanabilirsiniz.Bazı notlar:seq.Date() kullanarak bir tarih dizisinin nasıl oluşturulacağına ilişkin talimatlar için açılış ggplot bölümüne bakın.Tarih etiketleri oluşturmaya ilişkin ipuçları için bu sayfaya veya [Tarihlerle çalışma sayfasına] bakın.","code":""},{"path":"salgın-eğrileri.html","id":"sunumlar","chapter":"32 Salgın eğrileri","heading":"Sunumlar","text":"Aşağıda, bölmeler ve grafik etiketlerinin/kılavuz çizgilerinin hizalandığı ve hizalanmadığı grafiklerin bir gösterimi bulunmaktadır:","code":"\n# 7-day bins + Monday labels\n#############################\nggplot(central_data) +\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    binwidth = 7,                 # 7-day bins with start at first case\n    color = \"darkblue\",\n    fill = \"lightblue\") +\n  \n  scale_x_date(\n    expand = c(0,0),               # remove excess x-axis space below and after case bars\n    date_breaks = \"3 weeks\",       # Monday every 3 weeks\n    date_minor_breaks = \"week\",    # Monday weeks\n    date_labels = \"%a\\n%d\\n%b\\n'%y\")+  # label format\n  \n  scale_y_continuous(\n    expand = c(0,0))+              # remove excess space under x-axis, make flush\n  \n  labs(\n    title = \"MISALIGNED\",\n    subtitle = \"! CAUTION: 7-day bars start Thursdays at first case\\nDate labels and gridlines on Mondays\\nNote how ticks don't align with bars\")\n\n\n\n# 7-day bins + Months\n#####################\nggplot(central_data) +\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    binwidth = 7,\n    color = \"darkblue\",\n    fill = \"lightblue\") +\n  \n  scale_x_date(\n    expand = c(0,0),                  # remove excess x-axis space below and after case bars\n    date_breaks = \"months\",           # 1st of month\n    date_minor_breaks = \"week\",       # Monday weeks\n    date_labels = \"%a\\n%d %b\\n%Y\")+    # label format\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remove excess space under x-axis, make flush \n  \n  labs(\n    title = \"MISALIGNED\",\n    subtitle = \"! CAUTION: 7-day bars start Thursdays with first case\\nMajor gridlines and date labels at 1st of each month\\nMinor gridlines weekly on Mondays\\nNote uneven spacing of some gridlines and ticks unaligned with bars\")\n\n\n# TOTAL MONDAY ALIGNMENT: specify manual bin breaks to be mondays\n#################################################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # histogram breaks set to 7 days beginning Monday before first case\n    breaks = weekly_breaks_central,    # defined earlier in this page\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),                   # remove excess x-axis space below and after case bars\n    date_breaks = \"4 weeks\",           # Monday every 4 weeks\n    date_minor_breaks = \"week\",        # Monday weeks \n    date_labels = \"%a\\n%d %b\\n%Y\")+      # label format\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remove excess space under x-axis, make flush \n  \n  labs(\n    title = \"ALIGNED Mondays\",\n    subtitle = \"7-day bins manually set to begin Monday before first case (28 Apr)\\nDate labels and gridlines on Mondays as well\")\n\n\n# TOTAL MONDAY ALIGNMENT WITH MONTHS LABELS:\n############################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # histogram breaks set to 7 days beginning Monday before first case\n    breaks = weekly_breaks_central,            # defined earlier in this page\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),                   # remove excess x-axis space below and after case bars\n    date_breaks = \"months\",            # Monday every 4 weeks\n    date_minor_breaks = \"week\",        # Monday weeks \n    date_labels = \"%b\\n%Y\")+          # label format\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remove excess space under x-axis, make flush \n  \n  theme(panel.grid.major = element_blank())+  # Remove major gridlines (fall on 1st of month)\n          \n  labs(\n    title = \"ALIGNED Mondays with MONTHLY labels\",\n    subtitle = \"7-day bins manually set to begin Monday before first case (28 Apr)\\nDate labels on 1st of Month\\nMonthly major gridlines removed\")\n\n\n# TOTAL SUNDAY ALIGNMENT: specify manual bin breaks AND labels to be Sundays\n############################################################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # histogram breaks set to 7 days beginning Sunday before first case\n    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                      by   = \"7 days\"),\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),\n    # date label breaks and major gridlines set to every 3 weeks beginning Sunday before first case\n    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                      by   = \"3 weeks\"),\n    \n    # minor gridlines set to weekly beginning Sunday before first case\n    minor_breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                            to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                            by   = \"7 days\"),\n    \n    date_labels = \"%a\\n%d\\n%b\\n'%y\")+  # label format\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remove excess space under x-axis, make flush \n  \n  labs(title = \"ALIGNED Sundays\",\n       subtitle = \"7-day bins manually set to begin Sunday before first case (27 Apr)\\nDate labels and gridlines manually set to Sundays as well\")"},{"path":"salgın-eğrileri.html","id":"toplu-veri","chapter":"32 Salgın eğrileri","heading":"Toplu veri","text":"Genellikle bir satır listesi yerine tesislerden, bölgelerden vb. toplu sayımlarla başlarsınız. ggplot() ile bir salgın eğrisi oluşturabilirsiniz ancak kod biraz farklı olacaktır. Bu bölüm, veri hazırlama bölümünde daha önce içe aktarılan count_data veri setini kullanacaktır. Bu veri seti, günlük hastane sayımlarına göre toplanan linelist’dir. İlk 50 satır aşağıda gösterilmiştir.","code":""},{"path":"salgın-eğrileri.html","id":"komut-dosyası-çizimi-günlük-sayımlar","chapter":"32 Salgın eğrileri","heading":"Komut Dosyası Çizimi günlük sayımlar","text":"Bu günlük sayımlardan günlük bir salgın eğrisi çizebiliriz. İşte koddaki farklar:Estetik haritalama aes() içinde, sayımlar sütunu olarak y = belirtin (bu durumda, sütun adı n_cases ’dir).stat = \"identity\" argümanını geom_histogram()içine ekleyin; bu, çubuk yüksekliğinin varsayılan olarak satır sayısı değil, y = değeri olması gerektiğini belirtir.Çubuklar arasında dikey beyaz çizgileri önlemek için width = argümanını ekleyin. 1’e ayarlanmış günlük veriler için 7’ye ayarlanmış haftalık sayım verileri için Aylık sayım verileri için beyaz çizgiler bir sorundur (ayın farklı gün sayısı vardır) - x ekseninizi kategorik sıralı bir faktöre (aylar) dönüştürmeyi ve geom_col()kullanmayı düşünün.","code":"\nggplot(data = count_data)+\n  geom_histogram(\n   mapping = aes(x = date_hospitalisation, y = n_cases),\n   stat = \"identity\",\n   width = 1)+                # for daily counts, set width = 1 to avoid white space between bars\n  labs(\n    x = \"Date of report\", \n    y = \"Number of cases\",\n    title = \"Daily case incidence, from daily count data\")"},{"path":"salgın-eğrileri.html","id":"haftalık-sayıların-çizilmesi","chapter":"32 Salgın eğrileri","heading":"Haftalık sayıların çizilmesi","text":"Verileriniz zaten haftaya göre vaka sayılarıysa, bu veri kümesine benzeyebilirler (count_data_weekly olarak adlandırılır):count_data_weekly ’nin ilk 50 satırı aşağıda gösterilmiştir. Sayıların haftalar halinde toplandığını görebilirsiniz. hafta, haftanın ilk gününe göre görüntülenir (varsayılan olarak Pazartesi).Şimdi x = salgın haftası sütunu olacak şekilde çizin. Estetik haritalamaya y = sayı sütununu eklemeyi ve yukarıda açıklandığı gibi stat = \"identity\" eklemeyi unutmayın.","code":"\nggplot(data = count_data_weekly)+\n  \n  geom_histogram(\n    mapping = aes(\n      x = epiweek,           # x-axis is epiweek (as class Date)\n      y = n_cases_weekly,    # y-axis height in the weekly case counts\n      group = hospital,      # we are grouping the bars and coloring by hospital\n      fill = hospital),\n    stat = \"identity\")+      # this is also required when plotting count data\n     \n  # labels for x-axis\n  scale_x_date(\n    date_breaks = \"2 months\",      # labels every 2 months \n    date_minor_breaks = \"1 month\", # gridlines every month\n    date_labels = '%b\\n%Y')+       #labeled by month with year below\n     \n  # Choose color palette (uses RColorBrewer package)\n  scale_fill_brewer(palette = \"Pastel2\")+ \n  \n  theme_minimal()+\n  \n  labs(\n    x = \"Week of onset\", \n    y = \"Weekly case incidence\",\n    fill = \"Hospital\",\n    title = \"Weekly case incidence, from aggregated count data by hospital\")"},{"path":"salgın-eğrileri.html","id":"hareketli-ortalamalar-1","chapter":"32 Salgın eğrileri","heading":"Hareketli ortalamalar","text":"Ayrıntılı bir açıklama ve çeşitli seçenekler için Hareketli ortalamalar sayfasına bakın. Aşağıda, slider paketi ile hareketli ortalamaları hesaplamak için bir seçenek bulunmaktadır. Bu yaklaşımda, hareketli ortalama, çizimden önce veri setinde hesaplanır:Verileri gerektiği gibi sayımlar halinde toplayın (günlük, haftalık vb.) (bkz. [Verileri gruplandırma] sayfası).slider paketinden slide_index() ile oluşturulan hareketli ortalamayı tutmak için yeni bir sütun oluşturun.Hareketli ortalamayı, salgın eğrisi histogramının üstüne (sonra) bir geom_line()olarak çizin.Yararlı çevrimiçi slider paketi için belirtece bakın.","code":"\n# load package\npacman::p_load(slider)  # slider used to calculate rolling averages\n\n# make dataset of daily counts and 7-day moving average\n#######################################################\nll_counts_7day <- linelist %>%    # begin with linelist\n  \n  ## count cases by date\n  count(date_onset, name = \"new_cases\") %>%   # name new column with counts as \"new_cases\"\n  drop_na(date_onset) %>%                     # remove cases with missing date_onset\n  \n  ## calculate the average number of cases in 7-day window\n  mutate(\n    avg_7day = slider::slide_index(    # create new column\n      new_cases,                       # calculate based on value in new_cases column\n      .i = date_onset,                 # index is date_onset col, so non-present dates are included in window \n      .f = ~mean(.x, na.rm = TRUE),    # function is mean() with missing values removed\n      .before = 6,                     # window is the day and 6-days before\n      .complete = FALSE),              # must be FALSE for unlist() to work in next step\n    avg_7day = unlist(avg_7day))       # convert class list to class numeric\n\n\n# plot\n######\nggplot(data = ll_counts_7day) +  # begin with new dataset defined above \n    geom_histogram(              # create epicurve histogram\n      mapping = aes(\n        x = date_onset,          # date column as x-axis\n        y = new_cases),          # height is number of daily new cases\n        stat = \"identity\",       # height is y value\n        fill=\"#92a8d1\",          # cool color for bars\n        colour = \"#92a8d1\",      # same color for bar border\n        )+ \n    geom_line(                   # make line for rolling average\n      mapping = aes(\n        x = date_onset,          # date column for x-axis\n        y = avg_7day,            # y-value set to rolling average column\n        lty = \"7-day \\nrolling avg\"), # name of line in legend\n      color=\"red\",               # color of line\n      size = 1) +                # width of line\n    scale_x_date(                # date scale\n      date_breaks = \"1 month\",\n      date_labels = '%d/%m',\n      expand = c(0,0)) +\n    scale_y_continuous(          # y-axis scale\n      expand = c(0,0),\n      limits = c(0, NA)) +       \n    labs(\n      x=\"\",\n      y =\"Number of confirmed cases\",\n      fill = \"Legend\")+ \n    theme_minimal()+\n    theme(legend.title = element_blank())  # removes title of legend"},{"path":"salgın-eğrileri.html","id":"fasetlemeküçük-katlar","chapter":"32 Salgın eğrileri","heading":"Fasetleme/küçük-katlar","text":"Diğer ggplot’larda olduğu gibi, fasetli grafikler (“küçük katlar”) oluşturabilirsiniz. Bu el kitabının ggplot ipuçları sayfasında açıklandığı gibi, ya facet_wrap() ya da facet_grid()kullanabilirsiniz. Burada facet_wrap()ile gösteriyoruz. Salgın eğrileri için, facet_wrap()genellikle daha kolaydır, çünkü muhtemelen yalnızca bir sütunda fasetleme yapmanız gerekir.Genel sözdizimi facet_wrap(rows ~ cols)şeklindedir; burada yaklaşık işaretinin (~) solunda fasetli grafiğin “satırları”na yayılacak bir sütunun adı ve yaklaşık işaretinin sağında, fasetli grafiğin “sütunlarına” yayılacak bir sütunun adı bulunur. En basitinden, yaklaşık işaretinin sağındaki bir sütun adı kullanın: facet_wrap(~age_cat).Serbest eksenler\nbir faset için eksenlerin ölçeklerinin aynı boyutlara “sabit” (varsayılan) veya “serbest” (yani, faset içindeki verilere göre değişecekleri) olup olmadığına karar vermeniz gerekecektir. Bunu, “free_x” veya “free_y” veya “free” belirterek facet_wrap() içindeki scales = argümanı ile yapın.Fasetlerin sütun ve satır sayısı\nBu, facet_wrap()içinde ncol = ve nrow = ile belirtilebilir.Panellerin sırası\nGörünüm sırasını değiştirmek için, fasetleri oluşturmak için kullanılan faktör sütununun düzeylerinin temel sırasını değiştirin.Estetik\nYazı tipi boyutu ve yüzü, şerit rengi vb., theme() aracılığıyla aşağıdaki gibi argümanlarla değiştirilebilir:strip.text = element_text() (boyut, renk, yüz, açı…)strip.background = element_rect() (ör. element_rect(dolgu=“gri”))strip.position = ((“alt”, “üst”, “sol” veya “sağ” şeridin konumu)Şerit etiketleri\nFaset grafiklerinin etiketleri, bir faktör olarak sütunun “etiketleri” aracılığıyla veya bir “etiketleyici” kullanılarak değiştirilebilir.ggplot2’deki as_labeller()işlevini kullanarak böyle bir etiketleyici yapın. Ardından, etiketleyiciyi, aşağıda gösterildiği gibi facet_wrap()öğesinin labeller = argümanına yerleştirin.Örnek bir fasetli grafik  - age_cat sütunu ile fasetli.Etiketleyiciler hakkında daha fazla bilgi için bu bağlantıya bakın.","code":"\nmy_labels <- as_labeller(c(\n     \"0-4\"   = \"Ages 0-4\",\n     \"5-9\"   = \"Ages 5-9\",\n     \"10-14\" = \"Ages 10-14\",\n     \"15-19\" = \"Ages 15-19\",\n     \"20-29\" = \"Ages 20-29\",\n     \"30-49\" = \"Ages 30-49\",\n     \"50-69\" = \"Ages 50-69\",\n     \"70+\"   = \"Over age 70\"))\n# make plot\n###########\nggplot(central_data) + \n  \n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = age_cat,\n      fill = age_cat),    # arguments inside aes() apply by group\n      \n    color = \"black\",      # arguments outside aes() apply to all data\n        \n    # histogram breaks\n    breaks = weekly_breaks_central)+  # pre-defined date vector (see earlier in this page)\n                      \n  # The labels on the x-axis\n  scale_x_date(\n    expand            = c(0,0),         # remove excess x-axis space below and after case bars\n    date_breaks       = \"2 months\",     # labels appear every 2 months\n    date_minor_breaks = \"1 month\",      # vertical lines appear every 1 month \n    date_labels       = \"%b\\n'%y\")+     # date labels format\n  \n  # y-axis\n  scale_y_continuous(expand = c(0,0))+                       # removes excess y-axis space between bottom of bars and the labels\n  \n  # aesthetic themes\n  theme_minimal()+                                           # a set of themes to simplify plot\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # caption on left side in italics\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\",\n    strip.text = element_text(face = \"bold\", size = 10),\n    strip.background = element_rect(fill = \"grey\"))+         # axis titles in bold\n  \n  # create facets\n  facet_wrap(\n    ~age_cat,\n    ncol = 4,\n    strip.position = \"top\",\n    labeller = my_labels)+             \n  \n  # labels\n  labs(\n    title    = \"Weekly incidence of cases, by age category\",\n    subtitle = \"Subtitle\",\n    fill     = \"Age category\",                                      # provide new title for legend\n    x        = \"Week of symptom onset\",\n    y        = \"Weekly incident cases reported\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown\"))"},{"path":"salgın-eğrileri.html","id":"faset-arka-planında-toplam-salgın","chapter":"32 Salgın eğrileri","heading":"Faset arka planında toplam salgın","text":"fasetin arka planında toplam salgını göstermek için, ggplot’boş parantezlerle gghighlight() işlevini ekleyin. Bu, gghighlight paketinden bir komuttur. Tüm yönlerdeki maksimum y ekseninin artık tüm salgının zirvesine dayandığını unutmayın. ggplot ipuçları sayfasında bu paketin daha fazla örneği mevcuttur.","code":"\nggplot(central_data) + \n  \n  # epicurves by group\n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = age_cat,\n      fill = age_cat),  # arguments inside aes() apply by group\n    \n    color = \"black\",    # arguments outside aes() apply to all data\n    \n    # histogram breaks\n    breaks = weekly_breaks_central)+     # pre-defined date vector (see top of ggplot section)                \n  \n  # add grey epidemic in background to each facet\n  gghighlight::gghighlight()+\n  \n  # labels on x-axis\n  scale_x_date(\n    expand            = c(0,0),         # remove excess x-axis space below and after case bars\n    date_breaks       = \"2 months\",     # labels appear every 2 months\n    date_minor_breaks = \"1 month\",      # vertical lines appear every 1 month \n    date_labels       = \"%b\\n'%y\")+     # date labels format\n  \n  # y-axis\n  scale_y_continuous(expand = c(0,0))+  # removes excess y-axis space below 0\n  \n  # aesthetic themes\n  theme_minimal()+                                           # a set of themes to simplify plot\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # caption on left side in italics\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\",\n    strip.text = element_text(face = \"bold\", size = 10),\n    strip.background = element_rect(fill = \"white\"))+        # axis titles in bold\n  \n  # create facets\n  facet_wrap(\n    ~age_cat,                          # each plot is one value of age_cat\n    ncol = 4,                          # number of columns\n    strip.position = \"top\",            # position of the facet title/strip\n    labeller = my_labels)+             # labeller defines above\n  \n  # labels\n  labs(\n    title    = \"Weekly incidence of cases, by age category\",\n    subtitle = \"Subtitle\",\n    fill     = \"Age category\",                                      # provide new title for legend\n    x        = \"Week of symptom onset\",\n    y        = \"Weekly incident cases reported\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown\"))"},{"path":"salgın-eğrileri.html","id":"veri-içeren-bir-faset","chapter":"32 Salgın eğrileri","heading":"Veri içeren bir faset","text":"Tüm verileri içeren bir model kutusuna sahip olmak istiyorsanız, tüm veri setini çoğaltın ve kopyaları tek bir model değeri olarak değerlendirin. Aşağıdaki bir “yardımcı” işlevi CreateAllFacet() bu konuda yardımcı olabilir (bu blog yazısı sayesinde). Çalıştırıldığında, satır sayısı iki katına çıkar ve yinelenen satırların “tümü” değerine sahip olacağı ve orijinal satırların faset sütununun orijinal değerine sahip olacağı, facet adlı yeni bir sütun olacaktır. Şimdi sadece facet sütununda faset yapmanız gerekiyor.Kullanabilmeniz için çalıştırılması gereken yardımcı fonksiyon buradadır:Şimdi yardımcı işlevi veri setine age_cat sütununda uygulayın:ggplot() komutundaki dikkate değer değişiklikler şunlardır:Kullanılan veriler artık central_data2’dir (yeni “facet” sütunu ile satırları ikiye katlayın).Etiketleyici kullanılıyorsa güncellenmesi gerekecek.● İsteğe bağlı: dikey olarak yığılmış yüzeyler elde etmek için: model sütunu denklemin satır tarafına taşınır ve sağdaki “.” ile değiştirilir. (facet_wrap(facet~.)) ve ncol = 1. Kaydedilmiş png çizim görüntüsünün genişliğini ve yüksekliğini de ayarlamanız gerekebilir ([ggplot ipuçlarında] ggsave()’e bakın).","code":"\n# Define helper function\nCreateAllFacet <- function(df, col){\n     df$facet <- df[[col]]\n     temp <- df\n     temp$facet <- \"all\"\n     merged <-rbind(temp, df)\n     \n     # ensure the facet value is a factor\n     merged[[col]] <- as.factor(merged[[col]])\n     \n     return(merged)\n}\n# Create dataset that is duplicated and with new column \"facet\" to show \"all\" age categories as another facet level\ncentral_data2 <- CreateAllFacet(central_data, col = \"age_cat\") %>%\n  \n  # set factor levels\n  mutate(facet = fct_relevel(facet, \"all\", \"0-4\", \"5-9\",\n                             \"10-14\", \"15-19\", \"20-29\",\n                             \"30-49\", \"50-69\", \"70+\"))## Warning: 1 unknown level in `f`: 70+\n# check levels\ntable(central_data2$facet, useNA = \"always\")## \n##   all   0-4   5-9 10-14 15-19 20-29 30-49 50-69  <NA> \n##   454    84    84    82    58    73    57     7     9\nggplot(central_data2) + \n  \n  # actual epicurves by group\n  geom_histogram(\n        mapping = aes(\n          x = date_onset,\n          group = age_cat,\n          fill = age_cat),  # arguments inside aes() apply by group\n        color = \"black\",    # arguments outside aes() apply to all data\n        \n        # histogram breaks\n        breaks = weekly_breaks_central)+    # pre-defined date vector (see top of ggplot section)\n                     \n  # Labels on x-axis\n  scale_x_date(\n    expand            = c(0,0),         # remove excess x-axis space below and after case bars\n    date_breaks       = \"2 months\",     # labels appear every 2 months\n    date_minor_breaks = \"1 month\",      # vertical lines appear every 1 month \n    date_labels       = \"%b\\n'%y\")+     # date labels format\n  \n  # y-axis\n  scale_y_continuous(expand = c(0,0))+  # removes excess y-axis space between bottom of bars and the labels\n  \n  # aesthetic themes\n  theme_minimal()+                                           # a set of themes to simplify plot\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # caption on left side in italics\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\")+               \n  \n  # create facets\n  facet_wrap(facet~. ,                            # each plot is one value of facet\n             ncol = 1)+            \n\n  # labels\n  labs(title    = \"Weekly incidence of cases, by age category\",\n       subtitle = \"Subtitle\",\n       fill     = \"Age category\",                                      # provide new title for legend\n       x        = \"Week of symptom onset\",\n       y        = \"Weekly incident cases reported\",\n       caption  = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown\"))"},{"path":"salgın-eğrileri.html","id":"geçici-veriler","chapter":"32 Salgın eğrileri","heading":"32.4 Geçici veriler","text":"Salgın eğrilerinde gösterilen en son veriler genellikle geçici olarak işaretlenmeli veya raporlama gecikmelerine tabi olmalıdır. Bu, belirli sayıda gün boyunca dikey bir çizgi ve/veya dikdörtgen eklenerek yapılabilir. İşte iki seçenek:annotate() kullanın:\nBir satır için annotate(geom = \"segment\") kullanın. x, xend, y, ve yend’temin edin. Boyutu, çizgi tipini (lty) ve rengi ayarlayın.\nDikdörtgen için annotate(geom = \"rect\") kullanın. xmin/xmax/ymin/ymax’ı temin edin. Rengi ve alfayı ayarlayın.\nBir satır için annotate(geom = \"segment\") kullanın. x, xend, y, ve yend’temin edin. Boyutu, çizgi tipini (lty) ve rengi ayarlayın.Dikdörtgen için annotate(geom = \"rect\") kullanın. xmin/xmax/ymin/ymax’ı temin edin. Rengi ve alfayı ayarlayın.Verileri geçici duruma göre gruplandırın ve bu çubukları farklı şekilde renklendirin.DİKKAT: Bir dikdörtgen çizmek için geom_rect()’deneyebilirsiniz, ancak şeffaflığı ayarlamak bir satır listesi bağlamında çalışmaz. Bu işlev, gözlem/sıra için bir dikdörtgeni kaplar!. Çok düşük bir alfa (ör. 0.01) veya başka bir yaklaşım kullanın. ","code":""},{"path":"salgın-eğrileri.html","id":"annotate-kullanma","chapter":"32 Salgın eğrileri","heading":"annotate() kullanma","text":"annotate(geom = \"rect\") içinde, xmin ve xmax argümanlarına Date sınıfının girdileri verilmelidir.Bu veriler haftalık çubuklar halinde toplandığından ve son çubuk, son veri noktasından sonraki Pazartesi gününe kadar uzandığından, gölgeli bölgenin 4 haftayı kapsıyor gibi görünebileceğini unutmayın.İşte bir annotate() online örneği.Aynı siyah dikey çizgi aşağıdaki kodla da elde edilebilir, ancak geom_vline() fonksiyonunu kullanarak yüksekliği kontrol etme yeteneğinizi kaybedersiniz:","code":"\nggplot(central_data) + \n  \n  # histogram\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    breaks = weekly_breaks_central,   # pre-defined date vector - see top of ggplot section\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") +\n\n  # scales\n  scale_y_continuous(expand = c(0,0))+\n  scale_x_date(\n    expand = c(0,0),                   # remove excess x-axis space below and after case bars\n    date_breaks = \"1 month\",           # 1st of month\n    date_minor_breaks = \"1 month\",     # 1st of month\n    date_labels = \"%b\\n'%y\")+          # label format\n  \n  # labels and theme\n  labs(\n    title = \"Using annotate()\\nRectangle and line showing that data from last 21-days are tentative\",\n    x = \"Week of symptom onset\",\n    y = \"Weekly case indicence\")+ \n  theme_minimal()+\n  \n  # add semi-transparent red rectangle to tentative data\n  annotate(\n    \"rect\",\n    xmin  = as.Date(max(central_data$date_onset, na.rm = T) - 21), # note must be wrapped in as.Date()\n    xmax  = as.Date(Inf),                                          # note must be wrapped in as.Date()\n    ymin  = 0,\n    ymax  = Inf,\n    alpha = 0.2,          # alpha easy and intuitive to adjust using annotate()\n    fill  = \"red\")+\n  \n  # add black vertical line on top of other layers\n  annotate(\n    \"segment\",\n    x     = max(central_data$date_onset, na.rm = T) - 21, # 21 days before last data\n    xend  = max(central_data$date_onset, na.rm = T) - 21, \n    y     = 0,         # line begins at y = 0\n    yend  = Inf,       # line to top of plot\n    size  = 2,         # line size\n    color = \"black\",\n    lty   = \"solid\")+   # linetype e.g. \"solid\", \"dashed\"\n\n  # add text in rectangle\n  annotate(\n    \"text\",\n    x = max(central_data$date_onset, na.rm = T) - 15,\n    y = 15,\n    label = \"Subject to reporting delays\",\n    angle = 90)\ngeom_vline(xintercept = max(central_data$date_onset, na.rm = T) - 21,\n           size = 2,\n           color = \"black\")"},{"path":"salgın-eğrileri.html","id":"çubukların-rengi","chapter":"32 Salgın eğrileri","heading":"Çubukların rengi","text":"Alternatif bir yaklaşım, geçici veri çubuklarının rengini veya görüntüsünü ayarlamak olabilir. Veri hazırlama aşamasında yeni bir sütun oluşturabilir ve bunu, geçici verilerin aes(fill = )değeri diğer çubuklardan farklı bir renk veya alfa olacak şekilde verileri gruplamak için kullanabilirsiniz.","code":"\n# add column\n############\nplot_data <- central_data %>% \n  mutate(tentative = case_when(\n    date_onset >= max(date_onset, na.rm=T) - 7 ~ \"Tentative\", # tenative if in last 7 days\n    TRUE                                       ~ \"Reliable\")) # all else reliable\n\n# plot\n######\nggplot(plot_data, aes(x = date_onset, fill = tentative)) + \n  \n  # histogram\n  geom_histogram(\n    breaks = weekly_breaks_central,   # pre-defined data vector, see top of ggplot page\n    color = \"black\") +\n\n  # scales\n  scale_y_continuous(expand = c(0,0))+\n  scale_fill_manual(values = c(\"lightblue\", \"grey\"))+\n  scale_x_date(\n    expand = c(0,0),                   # remove excess x-axis space below and after case bars\n    date_breaks = \"3 weeks\",           # Monday every 3 weeks\n    date_minor_breaks = \"week\",        # Monday weeks \n    date_labels = \"%d\\n%b\\n'%y\")+      # label format\n  \n  # labels and theme\n  labs(title = \"Show days that are tentative reporting\",\n    subtitle = \"\")+ \n  theme_minimal()+\n  theme(legend.title = element_blank())                 # remove title of legend"},{"path":"salgın-eğrileri.html","id":"çok-seviyeli-tarih-etiketleri","chapter":"32 Salgın eğrileri","heading":"32.5 Çok seviyeli tarih etiketleri","text":"Alt etiket düzeylerini çoğaltmadan çok düzeyli tarih etiketleri (ör. ay ve yıl) istiyorsanız, aşağıdaki yaklaşımlardan birini göz önünde bulundurun:Unutmayın - bir etiketin parçalarını aşağıdaki yeni bir satıra koymak için date_labels veya labels argümanları içinde \\n gibi araçları kullanabilirsiniz. Bununla birlikte, aşağıdaki kod, daha düşük bir satırda ve yalnızca bir kez yıllar veya aylar (örneğin) almanıza yardımcı olur. Aşağıdaki kodla ilgili birkaç :Vaka sayıları estetik nedenlerle haftalar halinde toplanır. Ayrıntılar için salgın eğrisi sayfasına (toplanmış veri sekmesi) bakın..Aşağıdaki yüzey oluşturma yaklaşımı histogramlarla iyi çalışmadığından, histogram yerine geom_area()çizgisi kullanılır.Haftalık sayımlara toplayınGrafik yapınYukarıdaki teknikler bu ve stackoverflow.com’daki bu gönderiden uyarlanmıştır.","code":"\n# Create dataset of case counts by week\n#######################################\ncentral_weekly <- linelist %>%\n  filter(hospital == \"Central Hospital\") %>%   # filter linelist\n  mutate(week = lubridate::floor_date(date_onset, unit = \"weeks\")) %>%  \n  count(week) %>%                              # summarize weekly case counts\n  drop_na(week) %>%                            # remove cases with missing onset_date\n  complete(                                    # fill-in all weeks with no cases reported\n    week = seq.Date(\n      from = min(week),   \n      to   = max(week),\n      by   = \"week\"),\n    fill = list(n = 0))                        # convert new NA values to 0 counts\n# plot with box border on year\n##############################\nggplot(central_weekly) +\n  geom_area(aes(x = week, y = n),    # make line, specify x and y\n            stat = \"identity\") +             # because line height is count number\n  scale_x_date(date_labels=\"%b\",             # date label format show month \n               date_breaks=\"month\",          # date labels on 1st of each month\n               expand=c(0,0)) +              # remove excess space on each end\n  scale_y_continuous(\n    expand  = c(0,0))+                       # remove excess space below x-axis\n  facet_grid(~lubridate::year(week), # facet on year (of Date class column)\n             space=\"free_x\",                \n             scales=\"free_x\",                # x-axes adapt to data range (not \"fixed\")\n             switch=\"x\") +                   # facet labels (year) on bottom\n  theme_bw() +\n  theme(strip.placement = \"outside\",         # facet labels placement\n        strip.background = element_rect(fill = NA, # facet labels no fill grey border\n                                        colour = \"grey50\"),\n        panel.spacing = unit(0, \"cm\"))+      # no space between facet panels\n  labs(title = \"Nested year labels, grey label border\")\n# plot with no box border on year\n#################################\nggplot(central_weekly,\n       aes(x = week, y = n)) +              # establish x and y for entire plot\n  geom_line(stat = \"identity\",              # make line, line height is count number\n            color = \"#69b3a2\") +            # line color\n  geom_point(size=1, color=\"#69b3a2\") +     # make points at the weekly data points\n  geom_area(fill = \"#69b3a2\",               # fill area below line\n            alpha = 0.4)+                   # fill transparency\n  scale_x_date(date_labels=\"%b\",            # date label format show month \n               date_breaks=\"month\",         # date labels on 1st of each month\n               expand=c(0,0)) +             # remove excess space\n  scale_y_continuous(\n    expand  = c(0,0))+                      # remove excess space below x-axis\n  facet_grid(~lubridate::year(week),        # facet on year (of Date class column)\n             space=\"free_x\",                \n             scales=\"free_x\",               # x-axes adapt to data range (not \"fixed\")\n             switch=\"x\") +                  # facet labels (year) on bottom\n  theme_bw() +\n  theme(strip.placement = \"outside\",                     # facet label placement\n          strip.background = element_blank(),            # no facet lable background\n          panel.grid.minor.x = element_blank(),          \n          panel.border = element_rect(colour=\"grey40\"),  # grey border to facet PANEL\n          panel.spacing=unit(0,\"cm\"))+                   # No space between facet panels\n  labs(title = \"Nested year labels - points, shaded, no label border\")"},{"path":"salgın-eğrileri.html","id":"çift-eksen-1","chapter":"32 Salgın eğrileri","heading":"32.6 Çift eksen","text":"Veri görselleştirme topluluğu içinde ikili eksenlerin geçerliliği hakkında şiddetli tartışmalar olmasına rağmen, birçok salgın süpervizör hala ikinci bir eksenle kaplanmış yüzde içeren bir salgın eğrisi veya benzer bir grafik görmek istiyor. Bu, ggplot ipuçları sayfasında daha kapsamlı bir şekilde tartışılmıştır, ancak cowplot yöntemini kullanan bir örnek aşağıda gösterilmiştir:İki farklı grafik yapılır ve daha sonra cowplot paketi ile birleştirilir.Grafikler tam olarak aynı x eksenine (belirlenen sınırlar) sahip olmalıdır, aksi takdirde veriler ve etiketler hizalanmayacaktır.biri theme_cowplot()kullanır ve birinin y ekseni grafiğin sağ tarafına hareket ettirilir.Şimdi iki grafiiği kaplamak için cowplot kullanın. x ekseni hizalamasına, y ekseninin yanına ve theme_cowplot()kullanımına dikkat edin.","code":"\n#load package\npacman::p_load(cowplot)\n\n# Make first plot of epicurve histogram\n#######################################\nplot_cases <- linelist %>% \n  \n  # plot cases per week\n  ggplot()+\n  \n  # create histogram  \n  geom_histogram(\n    \n    mapping = aes(x = date_onset),\n    \n    # bin breaks every week beginning monday before first case, going to monday after last case\n    breaks = weekly_breaks_all)+  # pre-defined vector of weekly dates (see top of ggplot section)\n        \n  # specify beginning and end of date axis to align with other plot\n  scale_x_date(\n    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # min/max of the pre-defined weekly breaks of histogram\n  \n  # labels\n  labs(\n      y = \"Daily cases\",\n      x = \"Date of symptom onset\"\n    )+\n  theme_cowplot()\n\n\n# make second plot of percent died per week\n###########################################\nplot_deaths <- linelist %>%                        # begin with linelist\n  group_by(week = floor_date(date_onset, \"week\")) %>%  # create week column\n  \n  # summarise to get weekly percent of cases who died\n  summarise(n_cases = n(),\n            died = sum(outcome == \"Death\", na.rm=T),\n            pct_died = 100*died/n_cases) %>% \n  \n  # begin plot\n  ggplot()+\n  \n  # line of weekly percent who died\n  geom_line(                                # create line of percent died\n    mapping = aes(x = week, y = pct_died),  # specify y-height as pct_died column\n    stat = \"identity\",                      # set line height to the value in pct_death column, not the number of rows (which is default)\n    size = 2,\n    color = \"black\")+\n  \n  # Same date-axis limits as the other plot - perfect alignment\n  scale_x_date(\n    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # min/max of the pre-defined weekly breaks of histogram\n  \n  \n  # y-axis adjustments\n  scale_y_continuous(                # adjust y-axis\n    breaks = seq(0,100, 10),         # set break intervals of percent axis\n    limits = c(0, 100),              # set extent of percent axis\n    position = \"right\")+             # move percent axis to the right\n  \n  # Y-axis label, no x-axis label\n  labs(x = \"\",\n       y = \"Percent deceased\")+      # percent axis label\n  \n  theme_cowplot()                   # add this to make the two plots merge together nicely\naligned_plots <- cowplot::align_plots(plot_cases, plot_deaths, align=\"hv\", axis=\"tblr\")\nggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])"},{"path":"salgın-eğrileri.html","id":"kümülatif-insidans-1","chapter":"32 Salgın eğrileri","heading":"32.7 Kümülatif İnsidans","text":": incidence2 kullanıyorsanız, basit bir fonksiyonla kümülatif insidansı nasıl üretebileceğinize ilişkin bölüme bakın. Bu sayfa, kümülatif insidansın nasıl hesaplanacağını ve ggplot()ile nasıl çizileceğini ele alacaktır.Bir vaka satır listesiyle başlıyorsanız, R tabanından cumsum() kullanarak bir salgındaki günlük kümülatif vaka sayısını içeren yeni bir sütun oluşturun:İlk 10 satır aşağıda gösterilmiştir:Bu kümülatif sütun daha sonra geom_line()kullanılarak date_onset’e göre çizilebilir:Ayrıca yukarıda ve ggplot ipuçları sayfasında açıklanan cowplot yöntemi kullanılarak çift eksenli salgın eğrisi üzerine bindirilebilir:Şimdi iki grafiği kaplamak için cowplot kullanın. x ekseni hizalamasına, y ekseninin kenarına ve theme_cowplot()kullanımına dikkat edildi.","code":"\ncumulative_case_counts <- linelist %>% \n  count(date_onset) %>%                # count of rows per day (returned in column \"n\")   \n  mutate(                         \n    cumulative_cases = cumsum(n)       # new column of the cumulative number of rows at each date\n    )\nplot_cumulative <- ggplot()+\n  geom_line(\n    data = cumulative_case_counts,\n    aes(x = date_onset, y = cumulative_cases),\n    size = 2,\n    color = \"blue\")\n\nplot_cumulative\n#load package\npacman::p_load(cowplot)\n\n# Make first plot of epicurve histogram\nplot_cases <- ggplot()+\n  geom_histogram(          \n    data = linelist,\n    aes(x = date_onset),\n    binwidth = 1)+\n  labs(\n    y = \"Daily cases\",\n    x = \"Date of symptom onset\"\n  )+\n  theme_cowplot()\n\n# make second plot of cumulative cases line\nplot_cumulative <- ggplot()+\n  geom_line(\n    data = cumulative_case_counts,\n    aes(x = date_onset, y = cumulative_cases),\n    size = 2,\n    color = \"blue\")+\n  scale_y_continuous(\n    position = \"right\")+\n  labs(x = \"\",\n       y = \"Cumulative cases\")+\n  theme_cowplot()+\n  theme(\n    axis.line.x = element_blank(),\n    axis.text.x = element_blank(),\n    axis.title.x = element_blank(),\n    axis.ticks = element_blank())\naligned_plots <- cowplot::align_plots(plot_cases, plot_cumulative, align=\"hv\", axis=\"tblr\")\nggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])"},{"path":"salgın-eğrileri.html","id":"kaynaklar-25","chapter":"32 Salgın eğrileri","heading":"32.8 Kaynaklar","text":"","code":""},{"path":"demografik-piramidler-ve-likert-ölçekler.html","id":"demografik-piramidler-ve-likert-ölçekler","chapter":"33 Demografik piramidler ve likert ölçekler","heading":"33 Demografik piramidler ve likert ölçekler","text":"Demografik piramitler, yaş ve cinsiyet dağılımlarını göstermek için kullanışlıdır. Benzer kod, Likert tarzı anket sorularının sonuçlarını görselleştirmek için de kullanılabilir (örneğin, “Kesinlikle katılıyorum”, “Katılıyorum”, “Nötr”, “Katılıyorum”, “Kesinlikle katılmıyorum”). Bu sayfada aşağıdaki başlıkları ele alacağız:apyramid paketini kullanarak hızlı ve kolay piramit grafiği oluşturmaggplot() kullanarak daha fazla özelleştirilebilir piramit grafiği oluşturmaPiramidin arka planında “temel” demografik bilgileri görüntülemeDiğer veri türlerini görselleştirmek için piramit tarzı grafikler kullanma (ör. Likert tarzı anket sorularına verilen yanıtlar)","code":""},{"path":"demografik-piramidler-ve-likert-ölçekler.html","id":"hazırlık-25","chapter":"33 Demografik piramidler ve likert ölçekler","heading":"33.1 Hazırlık","text":"","code":""},{"path":"demografik-piramidler-ve-likert-ölçekler.html","id":"paketleri-yükleme-9","chapter":"33 Demografik piramidler ve likert ölçekler","heading":"Paketleri yükleme","text":"Aşağıdaki kod parçası, analizler için gerekli olan paketlerin yüklenmesini göstermektedir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() fonksiyonunu ön plana çıkardık. R tabanından library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] sayfasına bakınız.","code":"\npacman::p_load(rio,       # verileri içe aktarmak için\n               here,      # dosyaları bulmak için\n               tidyverse, # verileri temizlemek, işlemek ve çizmek için (ggplot2 paketini içerir)\n               apyramid,  # yaş piramitleri oluşturmak için\n               janitor,   # tablo ve veri temizlemek için\n               stringr)   # başlık, alt yazı vb. dizelerle çalışmak için"},{"path":"demografik-piramidler-ve-likert-ölçekler.html","id":"veriyi-içe-aktarma-1","chapter":"33 Demografik piramidler ve likert ölçekler","heading":"Veriyi içe aktarma","text":"Başlamak için, Ebola salgını simulasyonuna ait temizlenmiş vaka listesini içe aktarıyoruz. Takip etmek isterseniz, “temiz satır listesi” dosyasını indirmek için tıklayınız. (.rds dosyası olarak). rio paketinden import() fonksiyonu ile veriler içe aktarılmalıdır (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe ve dışa aktarma] sayfasına bakınız).Satır listesinin ilk 50 satırı aşağıda gösterilmiştir.","code":"\n# vaka satır listesini içe aktar \nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"demografik-piramidler-ve-likert-ölçekler.html","id":"temizleme","chapter":"33 Demografik piramidler ve likert ölçekler","heading":"Temizleme","text":"Geleneksel bir yaş/cinsiyet demografik piramidi oluşturmak için verilerin öncelikle aşağıda tanımlandığı gibi temizlenmesi gerekir:Cinsiyet sütunu temizlenmelidir.Kullanmak istediğiniz yönteme bağlı olarak yaş, sayısal olarak veya yaş kategorisi sütununda saklanmalıdır.Eğer Yaş kategorileri kullanılacaksa, sütun değerleri varsayılan olarak alfasayısal olarak veya sınıf faktörüne dönüştürülerek düzeltilmelidir.Aşağıda, gender ve age_cat5 sütunlarını incelemek için janitor paketinden tabyl() fonksiyonunu kullanıyoruz.Ayrıca, temiz ve doğru şekilde sınıflandırıldığından emin olmak için “age” sütununu hızlıca histograma dönüştürüyoruz:","code":"\nlinelist %>% \n  tabyl(age_cat5, gender)##  age_cat5   f   m NA_\n##       0-4 640 416  39\n##       5-9 641 412  42\n##     10-14 518 383  40\n##     15-19 359 364  20\n##     20-24 305 316  17\n##     25-29 163 259  13\n##     30-34 104 213   9\n##     35-39  42 157   3\n##     40-44  25 107   1\n##     45-49   8  80   5\n##     50-54   2  37   1\n##     55-59   0  30   0\n##     60-64   0  12   0\n##     65-69   0  12   1\n##     70-74   0   4   0\n##     75-79   0   0   1\n##     80-84   0   1   0\n##       85+   0   0   0\n##      <NA>   0   0  86\nhist(linelist$age)"},{"path":"demografik-piramidler-ve-likert-ölçekler.html","id":"apyramid-paketi","chapter":"33 Demografik piramidler ve likert ölçekler","heading":"33.2 apyramid paketi","text":"apyramid paketi R4Epis projesinin bir ürünüdür. Bu paket hakkında daha fazla bilgiyi buradan okuyabilirsiniz. Paket, hızlı bir şekilde bir yaş piramidi yapmanızı sağlar. Daha ayrıntılı durumlar için aşağıdaki bölüme bakabilirsiniz ggplot() kullanarak. R konsolunuza ?age_pyramid girerek yardım sayfasında apyramid paketi hakkında daha fazla bilgi edinebilirsiniz.","code":""},{"path":"demografik-piramidler-ve-likert-ölçekler.html","id":"linelist-data","chapter":"33 Demografik piramidler ve likert ölçekler","heading":"Linelist data","text":"Temizlenmiş ‘satır listesi’ veri setini kullanarak, age_pyramid() komutuyla basit bir yaş piramidi oluşturabiliriz. Bu komutta:data = argümanı “satır listesi” veri çerçevesi olarak ayarlanırage_group = argümanı (y ekseni için) kategorik yaş sütununun adına ayarlanır (tırnak içinde)split_by = argüman (x ekseni için) cinsiyet sütununa ayarlanırPiramit, proportional = TRUE argümanı dahil edilerek, sayılar yerine x eksenindeki tüm verileri yüzdesi ile görüntülenebilir.agepyramid paketini kullanırken, split_by sütunu ikili ise (ör. erkek/dişi veya evet/hayır), sonuç bir piramit olarak görünecektir. Bununla birlikte, split_by sütununda ikiden fazla değer varsa (NA dahil değildir), piramit “arka planda” gri çubuklar olan yönlü bir çubuk grafiği olarak görünecektir. Bu durum yaş grubu gibi yönlü olmayan verilerin aralığını gösterir. Bu durumda, split_by = değerleri yön panelinin üstünde etiketler olarak görünecektir. Örneğin, split_by =, hospital sütununa atanırsa kodun nasıl yazılacağı aşağıda belirtilmiştir.","code":"\napyramid::age_pyramid(data = linelist,\n                      age_group = \"age_cat5\",\n                      split_by = \"gender\")\napyramid::age_pyramid(data = linelist,\n                      age_group = \"age_cat5\",\n                      split_by = \"gender\",\n                      proportional = TRUE)\napyramid::age_pyramid(data = linelist,\n                      age_group = \"age_cat5\",\n                      split_by = \"hospital\")  "},{"path":"demografik-piramidler-ve-likert-ölçekler.html","id":"eksik-veriler","chapter":"33 Demografik piramidler ve likert ölçekler","heading":"Eksik veriler","text":"Eğer eksik veriler NA olarak kodlanmışsa, split_by = veya age_group = sütunlarındaki eksik veri olan satırlar, grafiğin oluşmasını etkilemez. Varsayılan olarak bu satırlar gösterilmeyecektir. Bununla birlikte, na.rm = FALSE argümanıyla üstte, ayrı bir bitişik çubuk grafiğinde görünmelerini sağlayabilirsiniz.","code":"\napyramid::age_pyramid(data = linelist,\n                      age_group = \"age_cat5\",\n                      split_by = \"gender\",\n                      na.rm = FALSE)         # show patients missing age or gender"},{"path":"demografik-piramidler-ve-likert-ölçekler.html","id":"oranlar-renkler-ve-estetik","chapter":"33 Demografik piramidler ve likert ölçekler","heading":"Oranlar, renkler ve estetik","text":"Varsayılan olarak, çubuklar sayılarını belirtmektedir (yüzdelerini değil). grup kesikli bir orta çizgi ile gösterilir ve rengi yeşil/mordur. Bu parametrelerin biri aşağıda gösterildiği gibi ayarlanabilir:İstediğiniz estetik ve etiket ayarlamalarını standart ggplot() fonksiyonu ve “+” argümanını kullanarak ek ggplot() komutlarıyla belirleyebilirsiniz:","code":"\napyramid::age_pyramid(\n  data = linelist,\n  age_group = \"age_cat5\",\n  split_by = \"gender\",\n  proportional = TRUE,              # yüzdeyi göster, sayıları değil\n  show_midpoint = FALSE,            # orta nokta çizgisini kaldır\n  #pal = c(\"orange\", \"purple\")      # burada alternatif renkler belirtebilirsiniz (ancak etiketleri değil)\n  )+                 \n  \n  # additional ggplot commands\n  theme_minimal()+                               # arka planı basitleştir\n  scale_fill_manual(                             # renkleri VE etiketleri belirtin\n    values = c(\"orange\", \"purple\"),              \n    labels = c(\"m\" = \"Male\", \"f\" = \"Female\"))+\n  labs(y = \"Percent of all cases\",              # x ve y laboratuvarları değiştirildiğine dikkat edin\n       x = \"Age categories\",                          \n       fill = \"Gender\", \n       caption = \"My data source and caption here\",\n       title = \"Title of my plot\",\n       subtitle = \"Subtitle with \\n a second line...\")+\n  theme(\n    legend.position = \"bottom\",                          # açıklama aşağıya\n    axis.text = element_text(size = 10, face = \"bold\"),  # font ve boyut\n    axis.title = element_text(size = 12, face = \"bold\"))"},{"path":"demografik-piramidler-ve-likert-ölçekler.html","id":"toplu-veri-1","chapter":"33 Demografik piramidler ve likert ölçekler","heading":"Toplu veri","text":"Yukarıdaki örnekler, verilerinizin gözlem başına bir satır olacak şekilde bir satır listesi biçiminde olduğunu varsaymaktadır. Verileriniz zaten yaş kategorisine göre sayılar halinde toplanmışsa, aşağıda gösterildiği gibi apyramid paketini kullanmaya devam edebilirsiniz.Örnek olması için, satır listesi verilerini yaş kategorisine ve cinsiyete göre sayımlar halinde “geniş” bir formatta topluyoruz. Burada, verileriniz başlangıçta sayıymış gibi simüle edilecektir. İlgili sayfalarında [Gruplama verileri] ve [Özetleme verileri] hakkında daha fazla bilgi edinebilirsiniz.…bu da veri setinin şu şekilde görünmesini sağlar: yaş kategorisi, erkek sayısı, kadın sayısı ve eksik veri sütunları.Bu verileri yaş piramidine uyarlamak için, veriler dplyr paketinden pivot_longer() fonksiyonuyla “long” formatına döndürülecektir. Bunun nedeni, ggplot() fonksiyonunun genellikle “long” verileri tercih etmesi ve apyramid paketinin ggplot()u kullanmasıdır.Ardından, verilerdeki ilgili sütunları belirtmek için age_pyramid() fonksiyonunun split_by = ve count = argümanını kullanın:Yukarıda “m” ve “f” faktör sırasının farklı olduğuna dikkat edin (ters piramit). Sıralamayı ayarlamak için, toplu verilerde cinsiyeti Faktör olarak yeniden tanımlamalı ve seviyeleri istediğiniz gibi sıralamalısınız. Faktörler sayfasına bakınız.","code":"\ndemo_agg <- linelist %>% \n  count(age_cat5, gender, name = \"cases\") %>% \n  pivot_wider(\n    id_cols = age_cat5,\n    names_from = gender,\n    values_from = cases) %>% \n  rename(`missing_gender` = `NA`)\n# Toplu veriyi long formatına döndür\ndemo_agg_long <- demo_agg %>% \n  pivot_longer(\n    col = c(f, m, missing_gender),            # long formatına çevrilecek sütunlar\n    names_to = \"gender\",                # kategori sütunu için yeni ad\n    values_to = \"counts\") %>%           # sayım sütunları için yeni ad\n  mutate(\n    gender = na_if(gender, \"missing_gender\")) # \"missing_gender\"ı NA'ya çevir\napyramid::age_pyramid(data = demo_agg_long,\n                      age_group = \"age_cat5\",# yaş kategorisi sütunu için yeni ad\n                      split_by = \"gender\",   # cinsiyet sütunu için yeni ad\n                      count = \"counts\")      # vaka sayıları sütunu için yeni ad"},{"path":"demografik-piramidler-ve-likert-ölçekler.html","id":"demo_pyr_gg","chapter":"33 Demografik piramidler ve likert ölçekler","heading":"33.3 ggplot()","text":"Yaş piramidinizi oluşturmak için ggplot()u kullanmak daha fazla esneklik sağlar, ancak ggplot()un nasıl çalıştığına dair daha fazla bilgi sahibi olmanız gerekmektedir. Çünkü bu pakette hata yapmak da daha kolaydır.Demografik piramitler yapmak üzere ggplot()u kullanmak için, iki çubuk grafiği (cinsiyet için bir tane) oluşturursunuz, bir grafikteki değerleri negatife çevirirsiniz ve son olarak çubuk grafiklerini dikey olarak, tabanlarını görüntülemek için x ve y eksenlerini çevirirsiniz.","code":""},{"path":"demografik-piramidler-ve-likert-ölçekler.html","id":"hazırlık-26","chapter":"33 Demografik piramidler ve likert ölçekler","heading":"Hazırlık","text":"Bu yaklaşım, age_cat5 verilerinin kategorik değil, sayısal yaş sütununu kullanır. Bu yüzden bu sütunun sınıfının gerçekten sayısal olup olmadığını kontrol edeceğiz.Aşağıdaki mantığı, geom_histogram() yerine geom_col() kullanarak kategorik verilerden bir piramit oluşturmak için de kullanabilirsiniz.","code":"\nclass(linelist$age)## [1] \"numeric\""},{"path":"demografik-piramidler-ve-likert-ölçekler.html","id":"grafiği-oluşturma","chapter":"33 Demografik piramidler ve likert ölçekler","heading":"Grafiği oluşturma","text":"İlk olarak, ggplot() kullanarak bir piramit yapmak için aşağıdaki yaklaşımı anlamanız gerekmektedir:ggplot() içinde, sayısal yaş sütununu kullanarak iki histogram oluşturun: İki gruplama değerinin biri için bir tane (bu durumda cinsiyetler erkek ve kadın). Bunu yapmak için, bir histogram için veriler, ilgili filtreler “satır listesine” uygulanarak ilgili geom_histogram() komutlarında tanımlanır.ggplot() içinde, sayısal yaş sütununu kullanarak iki histogram oluşturun: İki gruplama değerinin biri için bir tane (bu durumda cinsiyetler erkek ve kadın). Bunu yapmak için, bir histogram için veriler, ilgili filtreler “satır listesine” uygulanarak ilgili geom_histogram() komutlarında tanımlanır.Bir grafik pozitif değerlere sahip olacak, diğeri ise negatif değerlere dönüştürülecek - bu, grafiğin ortasında “0” değeri olan bir “piramit” yaratır. Negatif değerler, özel bir ggplot2 terimi ..count.. kullanılarak ve -1 ile çarpılarak oluşturulur.Bir grafik pozitif değerlere sahip olacak, diğeri ise negatif değerlere dönüştürülecek - bu, grafiğin ortasında “0” değeri olan bir “piramit” yaratır. Negatif değerler, özel bir ggplot2 terimi ..count.. kullanılarak ve -1 ile çarpılarak oluşturulur.coord_flip() komutu X ve Y eksenlerini değiştirerek grafiklerin 90 derece dönmesine ve piramidin oluşturulmasına neden olur.coord_flip() komutu X ve Y eksenlerini değiştirerek grafiklerin 90 derece dönmesine ve piramidin oluşturulmasına neden olur.Son olarak, sayım ekseni değer etiketleri, piramidin iki tarafında “pozitif” sayımlar olarak görünecek şekilde değiştirilmelidir (bir taraftaki temel değerlerin negatif olmasına rağmen).Son olarak, sayım ekseni değer etiketleri, piramidin iki tarafında “pozitif” sayımlar olarak görünecek şekilde değiştirilmelidir (bir taraftaki temel değerlerin negatif olmasına rağmen).geom_histogram() fonksiyonu kullanılarak hazırlanan basit bir versiyonu aşağıdadır:TEHLİKE: Sayım ekseninizin sınırları çok düşük ayarlanmışsa ve bir sayım çubuğu bunları aşarsa, çubuk tamamen kaybolur veya yapay olarak kısaltılır! Rutin olarak güncellenen verileri analiz ediyorsanız buna dikkat etmelisiniz. Sayım ekseni sınırlarınızın aşağıdaki gibi verilerinize göre otomatik olarak ayarlanmasını sağlayarak bunu önleyebilirsiniz.Bu basit versiyonda değiştirebileceğiniz/ekleyebileceğiniz pek çok şey vardır:Sayım ekseni ölçeğini verilerinize göre otomatik olarak ayarlama (aşağıdaki uyarıda açıklanan hatalardan kaçınmalısınız)Renkleri ve gösterge etiketlerini manuel olarak belirtmeSayıları yüzdelere dönüştürmeSayıları yüzdelere (toplamına göre) dönüştürmek için, hazırlıklarınızı çizimden önce yapmanız gerekmektedir. Aşağıda, yeni yüzde sütunları oluşturmak için yaş-cinsiyet sayılarını, ungroup() ve ardından mutate() fonksiyonlarını kullanıyoruz. Cinsiyete göre yüzdeleri istiyorsanız, ungroup() adımını atlayabilirsiniz.Daha da önemlisi, maksimum ve minimum değerleri kaydederek ölçeğin sınırlarının ne olması gerektiğini biliriz. Bunlar aşağıdaki ggplot() komutunda kullanılacaktır.Son olarak yüzde verisi üzerinde ggplot() komutunu kullanıyoruz. Önceden tanımlı uzunlukları yönde (pozitif ve “negatif”) uzatmak için scale_y_continuous() fonksiyonunu tanımlıyoruz. Ondalık sayıları eksenin kenarı için uygun yöne (aşağı veya yukarı) yuvarlamak için floor() ve ceiling() argümanlarını kullanırız.","code":"\n  # ggplotu başlat\n  ggplot(mapping = aes(x = age, fill = gender)) +\n  \n  # kadın histogram\n  geom_histogram(data = linelist %>% filter(gender == \"f\"),\n                 breaks = seq(0,85,5),\n                 colour = \"white\") +\n  \n  # erkek histogram (veriler negatife çevrilecek)\n  geom_histogram(data = linelist %>% filter(gender == \"m\"),\n                 breaks = seq(0,85,5),\n                 mapping = aes(y = ..count..*(-1)),\n                 colour = \"white\") +\n  \n  # X ve Y eksenlerini çevir\n  coord_flip() +\n  \n  # sayım ekseni ölçeğini ayarla\n  scale_y_continuous(limits = c(-600, 900),\n                     breaks = seq(-600,900,100),\n                     labels = abs(seq(-600, 900, 100)))\n# toplama göre oranlamak için veri kümesi oluştur\npyramid_data <- linelist %>%\n  count(age_cat5,\n        gender,\n        name = \"counts\") %>% \n  ungroup() %>%                 # grubu çöz, böylece yüzdeler gruba göre belirlenmesin\n  mutate(percent = round(100*(counts / sum(counts, na.rm=T)), digits = 1), \n         percent = case_when(\n            gender == \"f\" ~ percent,\n            gender == \"m\" ~ -percent,     # erkeği negatife çevir\n            TRUE          ~ NA_real_))    # NA değeri de sayısal olmalıdır\nmax_per <- max(pyramid_data$percent, na.rm=T)\nmin_per <- min(pyramid_data$percent, na.rm=T)\n\nmax_per## [1] 10.9\nmin_per## [1] -7.1\n# ggplot başlangıcı\n  ggplot()+  # varsayılan x ekseni, yıl cinsinden yaştır;\n\n  # vaka veri grafiği\n  geom_col(data = pyramid_data,\n           mapping = aes(\n             x = age_cat5,\n             y = percent,\n             fill = gender),         \n           colour = \"white\")+       # her çubuğun etrafı beyaz\n  \n  # piramidi dikey yapmak için X ve Y eksenlerini çevir\n  coord_flip()+\n  \n\n  # eksen boyunu düzenle\n  # scale_x_continuous(breaks = seq(0,100,5), labels = seq(0,100,5)) +\n  scale_y_continuous(\n    limits = c(min_per, max_per),\n    breaks = seq(from = floor(min_per),                # 2s ile değer dizisi\n                 to = ceiling(max_per),\n                 by = 2),\n    labels = paste0(abs(seq(from = floor(min_per),     # mutlak değerler dizisi, 2s ile, \"%\" ile\n                            to = ceiling(max_per),\n                            by = 2)),\n                    \"%\"))+  \n\n  #renkleri ve açıklama etiketlerini manuel olarak belirle\n  scale_fill_manual(\n    values = c(\"f\" = \"orange\",\n               \"m\" = \"darkgreen\"),\n    labels = c(\"Female\", \"Male\")) +\n  \n  # etiket değerleri (şimdi X ve Y'nin çevrildiğini unutmayın)\n  labs(\n    title = \"Age and gender of cases\",\n    x = \"Age group\",\n    y = \"Percent of total\",\n    fill = NULL,\n    caption = stringr::str_glue(\"Data are from linelist \\nn = {nrow(linelist)} (age or sex missing for {sum(is.na(linelist$gender) | is.na(linelist$age_years))} cases) \\nData as of: {format(Sys.Date(), '%d %b %Y')}\")) +\n  \n  # temayı görüntüle\n  theme(\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    axis.line = element_line(colour = \"black\"),\n    plot.title = element_text(hjust = 0.5), \n    plot.caption = element_text(hjust=0, size=11, face = \"italic\")\n    )"},{"path":"demografik-piramidler-ve-likert-ölçekler.html","id":"baz-değerleriyle-ile-karşılaştırma","chapter":"33 Demografik piramidler ve likert ölçekler","heading":"Baz değerleriyle ile karşılaştırma","text":"ggplot()un esnekliğiyle, arka planda “gerçek” veya “baz” nüfus piramidini temsil eden ikinci bir çubuk katmanına sahip olabilirsiniz. Bu, gözlemlenenleri taban çizgisiyle karşılaştırmak için güzel bir görselleştirme sağlayabilir.Nüfus verilerini içe aktarın ve görüntüleyin (bkz. [El kitabını ve verileri indirin] sayfası):İlk önce bazı veri yönetimi adımları:Burada görünmesini istediğimiz yaş kategorilerinin sırasını kaydediyoruz. ggplot()un uygulanma biçimindeki bazı tuhaflıklar nedeniyle, bu özel senaryoda bunları bir karakter vektörü olarak saklamak ve daha sonra çizim işlevinde kullanmak en kolay yoldur.Popülasyon ve vaka verilerini dplyr paketinden bind_rows() fonksiyonu aracılığıyla birleştirin:İlk olarak, tam olarak aynı sütun adlarına, yaş kategorisi değerlerine ve cinsiyet değerlerine sahip olduklarından emin olmalısınızVerilerin aynı veri yapısına sahip olmalarını sağlayın: yaş kategorisi sütunları, cinsiyet, sayılar ve toplamın yüzdesiBunları üst üste gelecek şekilde birbirine bağlayın (bind_rows())Değiştirilen nüfus veri kümesini gözden geçirinŞimdi aynısını vaka satır listesi için uygulayın. Burada durum biraz farklıdır çünkü veriler vaka satırlarıyla başlıyor, sayılarla değil.Değiştirilen vaka veri kümesini gözden geçirinŞimdi iki veri çerçevesi, biri diğerinin üzerinde olacak şekilde birleştirilmiştir (aynı sütun adlarına sahiptirler). Veri çerçevesinin birini yeniden “adlandırabiliriz” ve satırın hangi veri çerçevesinden kaynaklandığını gösterecek yeni bir “veri_kaynağı” sütunu oluşturmak için .id = argümanını kullanabiliriz. Bu sütunu daha sonrasında ggplot() içinde filtrelemek için kullanabiliriz.Çizimin kapsamını tanımlamak için çizim işlevinde kullanılan maksimum ve minimum yüzde değerlerini saklayabilirsiniz (ve herhangi bir çubuğu daha kısa kesmeyin!)Şimdi grafik ggplot() ile hazırlanabilir:Nüfus verilerinin bir çubuk grafiği (daha geniş, daha şeffaf çubuklar)Vaka verilerinin bir çubuk grafiği (küçük, daha opak çubuk)","code":"\n# nüfus demografisi verilerini içe aktar\npop <- rio::import(\"country_demographics.csv\")\n# doğru yaş kategorisi seviyelerini kaydedin\nage_levels <- c(\"0-4\",\"5-9\", \"10-14\", \"15-19\", \"20-24\",\n                \"25-29\",\"30-34\", \"35-39\", \"40-44\", \"45-49\",\n                \"50-54\", \"55-59\", \"60-64\", \"65-69\", \"70-74\",\n                \"75-79\", \"80-84\", \"85+\")\n# toplamın yüzdesi ile nüfus verilerini oluştur/dönüştür\n########################################################\npop_data <- pop %>% \n  pivot_longer(      # cinsiyet sütunlarını long formatına döndür\n    cols = c(m, f),\n    names_to = \"gender\",\n    values_to = \"counts\") %>% \n  \n  mutate(\n    percent  = round(100*(counts / sum(counts, na.rm=T)),1),  # % of total\n    percent  = case_when(                                                        \n     gender == \"f\" ~ percent,\n     gender == \"m\" ~ -percent,               # erkek ise, %'yi negatife çevir\n     TRUE          ~ NA_real_))\n# toplamın yüzdesi ile yaşa/cinsiyete göre vaka verileri oluştur\n#######################################################\ncase_data <- linelist %>%\n  count(age_cat5, gender, name = \"counts\") %>%  # yaş-cinsiyet gruplarına göre say\n  ungroup() %>% \n  mutate(\n    percent = round(100*(counts / sum(counts, na.rm=T)),1),  # yaş-cinsiyet grupları için toplamın yüzdesini hesapla\n    percent = case_when(                                     # erkek ise %'yi negatife çevir\n      gender == \"f\" ~ percent,\n      gender == \"m\" ~ -percent,\n      TRUE          ~ NA_real_))\n# vaka ve popülasyon verilerini birleştir (aynı sütun adları, age_cat değerleri ve cinsiyet değerleri)\npyramid_data <- bind_rows(\"cases\" = case_data, \"population\" = pop_data, .id = \"data_source\")\n# Çizim sınırları için kullanılan yüzde ekseninin kapsamını tanımla\nmax_per <- max(pyramid_data$percent, na.rm=T)\nmin_per <- min(pyramid_data$percent, na.rm=T)\n# ggplot'u başlat\n##############\nggplot()+  # varsayılan x ekseni, yıl cinsinden yaştır;\n\n  # nüfus veri grafiği\n  geom_col(\n    data = pyramid_data %>% filter(data_source == \"population\"),\n    mapping = aes(\n      x = age_cat5,\n      y = percent,\n      fill = gender),\n    colour = \"black\",                               # çubukların etrafındaki siyah renk\n    alpha = 0.2,                                    # daha şeffaf\n    width = 1)+                                     # tam genişlik\n  \n  # vaka veri grafiği\n  geom_col(\n    data = pyramid_data %>% filter(data_source == \"cases\"), \n    mapping = aes(\n      x = age_cat5,                               # orijinal X ekseni olarak yaş kategorileri\n      y = percent,                                # orijinal Y ekseni olarak %\n      fill = gender),                             # cinsiyete göre çubukların doldurulması\n    colour = \"black\",                               # çubukların etrafındaki siyah renk\n    alpha = 1,                                      # opak \n    width = 0.3)+                                   # yarım genişlik\n  \n  # piramidi dikey yapmak için X ve Y eksenlerini çevir\n  coord_flip()+\n  \n  # yaş ekseninin doğru sıralandığından manuel olarak emin ol\n  scale_x_discrete(limits = age_levels)+     # yukarıdaki parçada tanımlanmış\n  \n  # yüzde ekseni ayarla\n  scale_y_continuous(\n    limits = c(min_per, max_per),                                          # yukarıda tanımlanan min ve max\n    breaks = seq(floor(min_per), ceiling(max_per), by = 2),                # min%'den maksimum% 2'ye\n    labels = paste0(                                                       # etiketler için birlikte yapıştır...\n              abs(seq(floor(min_per), ceiling(max_per), by = 2)), \"%\"))+                                                  \n\n  # renkleri ve açıklama etiketlerini manuel olarak belirle\n  scale_fill_manual(\n    values = c(\"f\" = \"orange\",         # verilerdeki değerlere renk ata\n               \"m\" = \"darkgreen\"),\n    labels = c(\"f\" = \"Female\",\n               \"m\"= \"Male\"),      # göstergede görünen etiketleri değiştir, not sırası\n  ) +\n\n  # grafik etiketleri, başlıklar, başlık  \n  labs(\n    title = \"Case age and gender distribution,\\nas compared to baseline population\",\n    subtitle = \"\",\n    x = \"Age category\",\n    y = \"Percent of total\",\n    fill = NULL,\n    caption = stringr::str_glue(\"Cases shown on top of country demographic baseline\\nCase data are from linelist, n = {nrow(linelist)}\\nAge or gender missing for {sum(is.na(linelist$gender) | is.na(linelist$age_years))} cases\\nCase data as of: {format(max(linelist$date_onset, na.rm=T), '%d %b %Y')}\")) +\n  \n  # opsiyonel estetik ayarlamalar\n  theme(\n    legend.position = \"bottom\",                             # açıklamayı aşağıya taşı\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    axis.line = element_line(colour = \"black\"),\n    plot.title = element_text(hjust = 0), \n    plot.caption = element_text(hjust=0, size=11, face = \"italic\"))"},{"path":"demografik-piramidler-ve-likert-ölçekler.html","id":"likert-ölçek","chapter":"33 Demografik piramidler ve likert ölçekler","heading":"33.4 Likert ölçek","text":"‘ggplot()’ ile bir nüfus piramidi yapmak için kullanılan teknikler, Likert ölçekli anket verilerinin çizimlerini yapmak için de kullanılabilir.Verileri içe aktarın ([El kitabını ve verileri indir] sayfasına bakabilirsiniz).katılımcının kategorik bir sınıflandırması (status) ve 4 puanlı Likert tipi bir ölçekte 8 soruya verdikleri yanıtlara (“Çok kötü”, “Kötü”, “İyi”, “Çok iyi”) ait verileri ele alacağız.İlk olarak, veri yönetimi adımları:Verileri pivot_longer fonksiyonuyla alt gruplarına döndürmeYanıtın genellikle “olumlu” veya “olumsuz” olmasına bağlı olarak yeni bir direction sütunu oluşturmastatus sütunu ve Response sütunu için Faktör düzeyi sırasını ayarlamaMaksimum sayım değerini, çizim sınırlarının uygun olması için saklamaŞimdi grafiği hazırlayabiliriz. Yukarıdaki yaş piramitlerinde olduğu gibi iki çubuk grafiği oluşturuyoruz ve bunlardan birinin değerlerini negatife çeviriyoruz.geom_bar() fonksiyonunu kullanıyoruz çünkü verilerimiz toplu sayı olarak değil, gözlem başına bir satır olacak şekilde düzenlendi. Negatif değerleri (-1) tersine çevirmek için çubuk grafiklerden birinde özel ggplot2 terimi olan ..count..u ve değerlerin üstüne eklenmesi için position = \"stack\" argümanını kullanıyoruz.","code":"\n# likert anketi yanıt verilerini içe aktar\nlikert_data <- rio::import(\"likert_data.csv\")\nmelted <- likert_data %>% \n  pivot_longer(\n    cols = Q1:Q8,\n    names_to = \"Question\",\n    values_to = \"Response\") %>% \n  mutate(\n    \n    direction = case_when(\n      Response %in% c(\"Poor\",\"Very Poor\")  ~ \"Negative\",\n      Response %in% c(\"Good\", \"Very Good\") ~ \"Positive\",\n      TRUE                                 ~ \"Unknown\"),\n    \n    status = fct_relevel(status, \"Junior\", \"Intermediate\", \"Senior\"),\n    \n    # çalışması için 'Çok Zayıf' ve 'Zayıf' kelimeleri tersine çevirilmelidir\n    Response = fct_relevel(Response, \"Very Good\", \"Good\", \"Very Poor\", \"Poor\")) \n\n# ölçek limitleri için en büyük değeri al\nmelted_max <- melted %>% \n  count(status, Question) %>% # sayıları al\n  pull(n) %>%                 # sütunu 'n'i\n  max(na.rm=T)                # maksimumu al\n# garfiği hazırla\nggplot()+\n     \n  # \"olumsuz\" yanıtların çubuk grafiği \n     geom_bar(\n       data = melted %>% filter(direction == \"Negative\"),\n       mapping = aes(\n         x = status,\n         y = ..count..*(-1),    # negatife çevrilen sayımlar\n         fill = Response),\n       color = \"black\",\n       closed = \"left\",\n       position = \"stack\")+\n     \n     # \"olumlu\" yanıtların çubuk grafiği\n     geom_bar(\n       data = melted %>% filter(direction == \"Positive\"),\n       mapping = aes(\n         x = status,\n         fill = Response),\n       colour = \"black\",\n       closed = \"left\",\n       position = \"stack\")+\n     \n     # X ve Y eksenlerini çevirin\n     coord_flip()+\n  \n     # 0'da siyah dikey çizgi\n     geom_hline(yintercept = 0, color = \"black\", size=1)+\n     \n    # etiketlerin tümünü pozitif sayılara dönüştür\n    scale_y_continuous(\n      \n      # x ekseni ölçeğinin sınırları\n      limits = c(-ceiling(melted_max/10)*11,    # 10 ile negatiften pozitife doğru sıra, kenarlar dışa doğru en yakın 5'e yuvarlanır\n                 ceiling(melted_max/10)*10),   \n      \n      # x ekseni ölçeğinin değerleri\n      breaks = seq(from = -ceiling(melted_max/10)*10,\n                   to = ceiling(melted_max/10)*10,\n                   by = 10),\n      \n      # x ekseni ölçeğinin etiketleri\n      labels = abs(unique(c(seq(-ceiling(melted_max/10)*10, 0, 10),\n                            seq(0, ceiling(melted_max/10)*10, 10))))) +\n     \n    # manuel olarak atanan renk skalaları\n    scale_fill_manual(\n      values = c(\"Very Good\"  = \"green4\", # renk ata\n                \"Good\"      = \"green3\",\n                \"Poor\"      = \"yellow\",\n                \"Very Poor\" = \"red3\"),\n      breaks = c(\"Very Good\", \"Good\", \"Poor\", \"Very Poor\"))+ # açıklamanın sırası\n     \n    \n     \n    # tüm grafiği şekillendirin, böylece her soru bir alt grafik olur\n    facet_wrap( ~ Question, ncol = 3)+\n     \n    # etiketler, başlıklar, başlık\n    labs(\n      title = str_glue(\"Likert-style responses\\nn = {nrow(likert_data)}\"),\n      x = \"Respondent status\",\n      y = \"Number of responses\",\n      fill = \"\")+\n\n     # görselin ayarları \n     theme_minimal()+\n     theme(axis.text = element_text(size = 12),\n           axis.title = element_text(size = 14, face = \"bold\"),\n           strip.text = element_text(size = 14, face = \"bold\"),  # alt başlıklar\n           plot.title = element_text(size = 20, face = \"bold\"),\n           panel.background = element_rect(fill = NA, color = \"black\")) # her metin etrafındaki siyah çerçeve"},{"path":"demografik-piramidler-ve-likert-ölçekler.html","id":"kaynaklar-26","chapter":"33 Demografik piramidler ve likert ölçekler","heading":"33.5 Kaynaklar","text":"apyramid dokümantasyonu","code":""},{"path":"isı-grafikleri.html","id":"isı-grafikleri","chapter":"34 Isı grafikleri","heading":"34 Isı grafikleri","text":"“Isı haritaları” veya “ısı karoları” olarak da bilinen ısı grafikleri, 3 değişkeni (x ekseni, y ekseni ve dolgu) görüntülemeye çalışırken yararlı görselleştirmeler olabilir. Aşağıda iki örnek gösteriliyor:Yaşa göre bulaşma olaylarının görsel bir matrisi (“kim kime bulaştırdı”)Zaman içinde birçok tesis/yetki alanı genelinde raporlama ölçümlerini izleme","code":""},{"path":"isı-grafikleri.html","id":"hazırlık-27","chapter":"34 Isı grafikleri","heading":"34.1 Hazırlık","text":"","code":""},{"path":"isı-grafikleri.html","id":"paketleri-yükle","chapter":"34 Isı grafikleri","heading":"Paketleri yükle","text":"Bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’ın p_load() fonksiyonunu vurguluyoruz. Ayrıca, R tabanı’ndan library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] sayfasına bakın.Veri setleriBu sayfa, iletim matrisi bölümü için simüle edilmiş bir salgının vaka satır listesini ve ölçüm izleme bölümü için tesise göre günlük sıtma vaka sayımlarının ayrı bir veri setini kullanır. Ayrı bölümlerine yüklenir ve temizlenirler.","code":"\npacman::p_load(\n  tidyverse,       # data manipulation and visualization\n  rio,             # importing data \n  lubridate        # working with dates\n  )"},{"path":"isı-grafikleri.html","id":"geçiş-matrisi","chapter":"34 Isı grafikleri","heading":"34.2 Geçiş matrisi","text":"Isı karoları, matrisleri görselleştirmek için faydalı olabilir. Örnek olarak, bir salgında “kimin kime bulaştığını” göstermektir. Bu, aktarım olayları hakkında bilgi sahibi olduğunuzu varsayar.[Temaslı izleme] sayfasının, vakaların yaşlarının ve kaynaklarının veri çerçevesinin aynı satırında düzgün bir şekilde hizalandığı farklı (belki de daha basit) bir veri kümesi kullanarak bir ısı karosu temas matrisi oluşturmanın başka bir örneğini içerdiğine dikkat edin. Bu aynı veriler, ggplot ipuçları sayfasında bir yoğunluk haritası yapmak için kullanılır. Aşağıdaki bu örnek, bir durum satır listesinden başlar ve bu nedenle, çizilebilir bir veri çerçevesi elde etmeden önce önemli miktarda veri işlemeyi içerir. Yani seçebileceğiniz birçok senaryo var…Simüle edilmiş bir Ebola salgınının vaka listesiyle başlıyoruz. Devam etmek istiyorsanız,  “temiz” satır listesini (.rds dosyası olarak) indirmek için tıklayın. Verilerinizi rio paketinden import() fonksiyonuyla içe aktarın (.xlsx, .rds, .csv gibi birçok dosya türünü kabul eder - ayrıntılar için [İçe Aktarma ve Dışa Aktarma] sayfasına bakın).Çizgi listesinin ilk 50 satırı, gösterim için aşağıda gösterilmiştir:Bu satır listesinde:case_id ile tanımlandığı gibi, vaka başına bir satır vardırSatır listesinde de bir vaka olan bulaştırıcı’nın case_id’sini içeren daha sonraki bir sütun olan infector vardır.","code":"\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"isı-grafikleri.html","id":"veri-hazırlama","chapter":"34 Isı grafikleri","heading":"Veri Hazırlama","text":"Amaç: Olası yaştan yaşa iletim yolu başına bir satır içeren ve satır listesindeki tüm gözlenen iletim olaylarının o satırın oranını kapsayan sayısal bir sütun içeren “uzun” tarzda bir veri çerçevesi elde etmemiz gerekiyor.Bu, aşağıdakileri elde etmek için birkaç veri işleme adımı alacaktır:","code":""},{"path":"isı-grafikleri.html","id":"vaka-veri-çerçevesi-yapmak","chapter":"34 Isı grafikleri","heading":"Vaka veri çerçevesi yapmak","text":"Başlamak için, vakaların, yaşlarının ve bulaştırıcılarının bir veri çerçevesini oluşturuyoruz - veri çerçevesine case_ages diyoruz. İlk 50 satır aşağıda gösterilmiştir.","code":"\ncase_ages <- linelist %>% \n  select(case_id, infector, age_cat) %>% \n  rename(\"case_age_cat\" = \"age_cat\")"},{"path":"isı-grafikleri.html","id":"bulaştırıcıların-veri-çerçevesini-yapmak","chapter":"34 Isı grafikleri","heading":"Bulaştırıcıların veri çerçevesini yapmak","text":"Ardından, bulaşıcıların veri çerçevesini oluşturuyoruz - şu anda tek bir sütundan oluşuyor. Bunlar, satır listesindeki bulaştırıcı kimlikleridir. vakanın bilinen bir bulaştırıcısı yoktur, bu nedenle eksik değerleri kaldırıyoruz. İlk 50 satır aşağıda gösterilmiştir.Daha sonra, bulaştırıcıların yaşlarını elde etmek için birleşimleri kullanırız. Bu basit değil, çünkü linelist’de, bulaştırıcının yaşları bu şekilde listelenmiyor. Bu sonuca, linelist’bulaştırıcılara ekleyerek ulaşıyoruz. Bulaştırıcılarla başlıyoruz ve vaka linelist’ne left_join() (ekliyoruz), öyle ki infector kimliği sütunu sol taraftaki “temel” veri çerçevesi sağ taraftaki linelist veri çerçevesindeki case_id sütunuyla birleşiyor.Böylece satır listesindeki (yaş dahil) bulaştırıcının vaka kaydındaki veriler bulaştırıcı satırına eklenir. İlk 50 satır aşağıda gösterilmiştir.Daha sonra vakaları ve yaşlarını bulaştırıcılar ve yaşları ile birleştiriyoruz. Bu veri çerçevelerinin biri sütun infector’e sahiptir, bu nedenle birleştirme için kullanılır. İlk satırlar aşağıda görüntülenir:Aşağıda, vaka ve enfeksiyon etkeni yaş grupları arasındaki sayıların basit bir çapraz tablosu. Netlik için etiketler eklendi.Bu tabloyu, R tabanından data.frame() ile bir veri çerçevesine dönüştürebiliriz, bu da onu otomatik olarak ggplot() için istenen “uzun” biçime dönüştürür. İlk satırlar aşağıda gösterilmiştir.Şimdi biz de aynısını yapıyoruz, ancak tabloya R tabanından prop.table() uygularız, böylece sayımlar yerine toplamın oranlarını elde ederiz. İlk 50 satır aşağıda gösterilmiştir.","code":"\ninfectors <- linelist %>% \n  select(infector) %>% \n  drop_na(infector)\ninfector_ages <- infectors %>%             # begin with infectors\n  left_join(                               # add the linelist data to each infector  \n    linelist,\n    by = c(\"infector\" = \"case_id\")) %>%    # match infector to their information as a case\n  select(infector, age_cat) %>%            # keep only columns of interest\n  rename(\"infector_age_cat\" = \"age_cat\")   # rename for clarity\nages_complete <- case_ages %>%  \n  left_join(\n    infector_ages,\n    by = \"infector\") %>%        # each has the column infector\n  drop_na()                     # drop rows with any missing data\ntable(cases = ages_complete$case_age_cat,\n      infectors = ages_complete$infector_age_cat)##        infectors\n## cases   0-4 5-9 10-14 15-19 20-29 30-49 50-69 70+\n##   0-4   105 156   105   114   143   117    13   0\n##   5-9   102 132   110   102   117    96    12   5\n##   10-14 104 109    91    79   120    80    12   4\n##   15-19  85 105    82    39    75    69     7   5\n##   20-29 101 127   109    80   143   107    22   4\n##   30-49  72  97    56    54    98    61     4   5\n##   50-69   5   6    15     9     7     5     2   0\n##   70+     1   0     2     0     0     0     0   0\nlong_counts <- data.frame(table(\n    cases     = ages_complete$case_age_cat,\n    infectors = ages_complete$infector_age_cat))\nlong_prop <- data.frame(prop.table(table(\n    cases = ages_complete$case_age_cat,\n    infectors = ages_complete$infector_age_cat)))"},{"path":"isı-grafikleri.html","id":"isı-grafiği-oluşturmak","chapter":"34 Isı grafikleri","heading":"Isı grafiği oluşturmak","text":"Şimdi nihayet geom_tile() fonksiyonunu kullanarak ggplot2 paketi ile ısı grafiğini oluşturabiliriz. Renk/dolgu ölçekleri, özellikle de scale_fill_gradient() fonksiyonu hakkında daha kapsamlı bilgi edinmek için ggplot ipuçları sayfasına bakın.geom_tile() estetik aes()’inde x ve y’yi vaka yaşı ve bulaştırıcı yaşı olarak ayarlayınAyrıca aes() içinde fill = argümanını Freq sütununa ayarlayın - bu, kutucuk rengine dönüştürülecek değerdirscale_fill_gradient() ile bir ölçek rengi ayarlayın - yüksek/düşük renkleri belirleyebilirsiniz\nscale_color_gradient() öğesinin farklı olduğuna dikkat edin! Bu durumda doldurmak istersiniz\nscale_color_gradient() öğesinin farklı olduğuna dikkat edin! Bu durumda doldurmak istersinizRenk “doldurma” yoluyla yapıldığından, gösterge başlığını değiştirmek için labs() içindeki fill = bağımsız değişkenini kullanabilirsiniz.","code":"\nggplot(data = long_prop)+       # use long data, with proportions as Freq\n  geom_tile(                    # visualize it in tiles\n    aes(\n      x = cases,         # x-axis is case age\n      y = infectors,     # y-axis is infector age\n      fill = Freq))+            # color of the tile is the Freq column in the data\n  scale_fill_gradient(          # adjust the fill color of the tiles\n    low = \"blue\",\n    high = \"orange\")+\n  labs(                         # labels\n    x = \"Case age\",\n    y = \"Infector age\",\n    title = \"Who infected whom\",\n    subtitle = \"Frequency matrix of transmission events\",\n    fill = \"Proportion of all\\ntranmsission events\"     # legend title\n  )"},{"path":"isı-grafikleri.html","id":"zaman-içinde-raporlama-metrikleri","chapter":"34 Isı grafikleri","heading":"34.3 Zaman içinde raporlama metrikleri","text":"Halk sağlığında genellikle bir amaç, birçok kuruluş (tesisler, yargı alanları, vb.) için zaman içindeki eğilimleri değerlendirmektir. Bu tür eğilimleri zaman içinde görselleştirmenin bir yolu, x ekseninin zaman olduğu ve y ekseninde birçok öğenin bulunduğu bir ısı grafiğidir.","code":""},{"path":"isı-grafikleri.html","id":"veri-hazırlama-1","chapter":"34 Isı grafikleri","heading":"Veri Hazırlama","text":"Birçok tesisten günlük sıtma raporlarının bir veri setini içe aktararak başlıyoruz. Raporlar bir tarih, il, ilçe ve sıtma sayılarını içerir. Bu verilerin nasıl indirileceği hakkında bilgi için El kitabı ve verileri indirme sayfasına bakın. İlk 30 satır aşağıdadır:","code":"\nfacility_count_data <- import(\"malaria_facility_count_data.rds\")"},{"path":"isı-grafikleri.html","id":"toplama-ve-özetleme","chapter":"34 Isı grafikleri","heading":"Toplama ve özetleme","text":"Bu örnekteki amaç, günlük tesis toplam sıtma vakası sayılarını (önceki sekmede görülen) tesis raporlama performansının haftalık özet istatistiklerine dönüştürmektir - bu durum için tesisin herhangi bir veriyi bildirdiği haftadaki günlerin oranıdır. Bu örnek için sadece Spring District için veri göstereceğiz.Bunu başarmak için aşağıdaki veri yönetimi adımlarını uygulayacağız:Verileri uygun şekilde filtreleyin (yere, tarihe göre)lubridate paketinden floor_date() kullanarak bir hafta sütunu oluşturun\nBu fonksiyon, haftanın belirli bir başlangıç tarihini (ör. “Pazartesileri”) kullanarak belirli bir tarihteki haftanın başlangıç tarihini döndürür.\nBu fonksiyon, haftanın belirli bir başlangıç tarihini (ör. “Pazartesileri”) kullanarak belirli bir tarihteki haftanın başlangıç tarihini döndürür.Veriler, “tesis-hafta” analiz birimlerini oluşturmak için “konum” ve “hafta” sütunlarına göre gruplandırılır.summarise() işlevi, tesis-hafta grubu başına özet istatistikleri yansıtmak için yeni sütunlar oluşturur:\nHaftada gün sayısı (7 - statik bir değer)\nTesis-haftadan alınan rapor sayısı (7’den fazla olabilir!)\nTesis haftası tarafından bildirilen sıtma vakalarının toplamı (sadece merak için)\nTesis-haftadaki verilerin raporlandığı özel günlerin sayısı\nVerilerin rapor edildiği tesis-hafta başına 7 günün yüzdesi\nHaftada gün sayısı (7 - statik bir değer)Tesis-haftadan alınan rapor sayısı (7’den fazla olabilir!)Tesis haftası tarafından bildirilen sıtma vakalarının toplamı (sadece merak için)Tesis-haftadaki verilerin raporlandığı özel günlerin sayısıVerilerin rapor edildiği tesis-hafta başına 7 günün yüzdesiVeri setini tamamlamak için tüm olası tesis-hafta kombinasyonlarının kapsamlı bir listesi için veri çerçevesi right_join() ile birleştirilir. Tüm olası kombinasyonların matrisi, veri çerçevesinin bu iki sütununa veri tüneli akışı o anda olduğu gibi (. ile temsil edilir) expand() uygulanarak oluşturulur. Bir right_join() kullanıldığından, expand() veri çerçevesindeki tüm satırlar tutulur ve gerekirse agg_weeks’e eklenir. Bu yeni satırlar, NA (eksik) özetlenmiş değerlerle görünür.Aşağıda adım adım gösteriyoruz:Şimdi veri setinde, daha önce nrow(facility_count_data) olduğunda, nrow(agg_weeks) satırı vardır.Ardından, kayıt için haftanın başlangıç tarihini yansıtan bir week sütunu oluştururuz. Bu, lubridate paketi ve “hafta” olarak ayarlanan ve haftaların Pazartesi gününden itibaren başlayacağı (haftanın 1. günü - Pazar 7 olacaktır) floor_date() fonksiyonuyla elde edilir. Üst sıralar aşağıda gösterilmiştir.Yeni hafta sütunu, veri çerçevesinin en sağında görülebilirŞimdi veriler tesis-haftalar halinde gruplandırılır ve tesis-hafta başına istatistik üretmek için bunlar özetlenir. İpuçları için [Açıklayıcı tablolar] sayfasına bakın. Gruplandırmanın kendisi veri çerçevesini değiştirmez, ancak sonraki özet istatistiklerin nasıl hesaplandığını etkiler.Üst sıralar aşağıda gösterilmiştir. Sütunların, istenen özet istatistikleri yansıtacak şekilde nasıl tamamen değiştiğine dikkat edin. satır bir tesis-haftayı yansıtır.Son olarak, daha önce eksik olsalar bile, olası TÜM tesis-haftalarının verilerde mevcut olduğundan emin olmak için aşağıdaki komutu çalıştırılır.Kendi üzerinde bir right_join() kullanıyoruz (veri seti “.” ile temsil edilir), ancak week ve location_name sütunlarının tüm olası kombinasyonlarını içerecek şekilde genişletildi. [Pivoting] sayfasındaki expand() işleviyle ilgili belgelere bakın. Bu kodu çalıştırmadan önce veri seti nrow(agg_weeks) satırlarını içerir.expanded_weeks burada:Bu kodu çalıştırmadan önce agg_weeks, nrow(agg_weeks) satırlarını içerir.Bu kodu çalıştırdıktan sonra agg_weeks, nrow(agg_weeks) satırlarını içerir.","code":"\n# Create weekly summary dataset\nagg_weeks <- facility_count_data %>% \n  \n  # filter the data as appropriate\n  filter(\n    District == \"Spring\",\n    data_date < as.Date(\"2020-08-01\")) \nagg_weeks <- agg_weeks %>% \n  # Create week column from data_date\n  mutate(\n    week = lubridate::floor_date(                     # create new column of weeks\n      data_date,                                      # date column\n      unit = \"week\",                                  # give start of the week\n      week_start = 1))                                # weeks to start on Mondays \nagg_weeks <- agg_weeks %>%   \n\n  # Group into facility-weeks\n  group_by(location_name, week) %>%\n  \n  # Create summary statistics columns on the grouped data\n  summarize(\n    n_days          = 7,                                          # 7 days per week           \n    n_reports       = dplyr::n(),                                 # number of reports received per week (could be >7)\n    malaria_tot     = sum(malaria_tot, na.rm = T),                # total malaria cases reported\n    n_days_reported = length(unique(data_date)),                  # number of unique days reporting per week\n    p_days_reported = round(100*(n_days_reported / n_days))) %>%  # percent of days reporting\n     \n  ungroup(location_name, week)\n# Create data frame of every possible facility-week\nexpanded_weeks <- agg_weeks %>% \n     tidyr::expand(location_name, week)\n# Use a right-join with the expanded facility-week list to fill-in the missing gaps in the data\nagg_weeks <- agg_weeks %>%      \n  right_join(expanded_weeks) %>%                            # Ensure every possible facility-week combination appears in the data\n  mutate(p_days_reported = replace_na(p_days_reported, 0))  # convert missing values to 0                           ## Joining, by = c(\"location_name\", \"week\")"},{"path":"isı-grafikleri.html","id":"isı-grafiği-oluştur","chapter":"34 Isı grafikleri","heading":"Isı grafiği oluştur","text":"ggplot(), ggplot2 paketindeki geom_tile() kullanılarak yapılır:x eksenindeki haftalar tarihlere dönüştürülerek scale_x_date() kullanımına izin verilir,y eksenindeki location_name tüm tesis adlarını gösterecek,fill, p_days_reported, o tesisin haftalık performansı (sayısal),scale_fill_gradient() yüksek, düşük ve NA için renkleri belirterek sayısal dolguda kullanılır,scale_x_date(), 2 haftada bir etiketleri ve formatlarını belirten x ekseninde kullanılır,Ekran temaları ve etiketleri gerektiği gibi ayarlanabilir.","code":""},{"path":"isı-grafikleri.html","id":"temel","chapter":"34 Isı grafikleri","heading":"Temel","text":"Aşağıda, varsayılan renkler, ölçekler vb. kullanılarak temel bir ısı grafiği üretilmiştir.Yukarıda açıklandığı gibi, geom_tile() için aes() içinde bir x ekseni sütunu, y ekseni sütunu ve fill = için bir sütun sağlamalısınız. Dolgu, kutucuk rengi olarak sunulan sayısal değerdir.","code":"\nggplot(data = agg_weeks)+\n  geom_tile(\n    aes(x = week,\n        y = location_name,\n        fill = p_days_reported))"},{"path":"isı-grafikleri.html","id":"temizlenmiş-grafik","chapter":"34 Isı grafikleri","heading":"Temizlenmiş grafik","text":"Aşağıda gösterildiği gibi ek ggplot2 işlevleri ekleyerek bu grafiğin daha iyi görünmesini sağlayabiliriz. Ayrıntılar için ggplot ipuçları sayfasına bakın.","code":"\nggplot(data = agg_weeks)+ \n  \n  # show data as tiles\n  geom_tile(\n    aes(x = week,\n        y = location_name,\n        fill = p_days_reported),      \n    color = \"white\")+                 # white gridlines\n  \n  scale_fill_gradient(\n    low = \"orange\",\n    high = \"darkgreen\",\n    na.value = \"grey80\")+\n  \n  # date axis\n  scale_x_date(\n    expand = c(0,0),             # remove extra space on sides\n    date_breaks = \"2 weeks\",     # labels every 2 weeks\n    date_labels = \"%d\\n%b\")+     # format is day over month (\\n in newline)\n  \n  # aesthetic themes\n  theme_minimal()+                                  # simplify background\n  \n  theme(\n    legend.title = element_text(size=12, face=\"bold\"),\n    legend.text  = element_text(size=10, face=\"bold\"),\n    legend.key.height = grid::unit(1,\"cm\"),           # height of legend key\n    legend.key.width  = grid::unit(0.6,\"cm\"),         # width of legend key\n    \n    axis.text.x = element_text(size=12),              # axis text size\n    axis.text.y = element_text(vjust=0.2),            # axis text alignment\n    axis.ticks = element_line(size=0.4),               \n    axis.title = element_text(size=12, face=\"bold\"),  # axis title size and bold\n    \n    plot.title = element_text(hjust=0,size=14,face=\"bold\"),  # title right-aligned, large, bold\n    plot.caption = element_text(hjust = 0, face = \"italic\")  # caption right-aligned and italic\n    )+\n  \n  # plot labels\n  labs(x = \"Week\",\n       y = \"Facility name\",\n       fill = \"Reporting\\nperformance (%)\",           # legend title, because legend shows fill\n       title = \"Percent of days per week that facility reported data\",\n       subtitle = \"District health facilities, May-July 2020\",\n       caption = \"7-day weeks beginning on Mondays.\")"},{"path":"isı-grafikleri.html","id":"sıralı-y-ekseni","chapter":"34 Isı grafikleri","heading":"Sıralı y ekseni","text":"Şu anda tesisler, aşağıdan yukarıya doğru “alfa-nümerik olarak” sıralanmıştır. Eğer y ekseni tesislerinin sırasını ayarlamak istiyorsanız, bunları sınıf faktörüne dönüştürün ve sırayı sağlayın. İpuçları için Faktörler sayfasına bakın.Pek çok tesis olduğundan ve hepsini yazmak istemediğimizden, başka bir yaklaşım deneyeceğiz bu da tesisleri bir veri çerçevesinde sıralamak ve sonuç sütununu faktör düzeyi sırası olarak kullanmak olacak. Aşağıda, location_name sütunu bir faktöre dönüştürülür ve düzeylerinin sırası, tüm zaman aralığında tesis tarafından dosyalanan toplam raporlama günü sayısına göre belirlenir.Bunu yapmak için, artan düzende düzenlenmiş, tesis başına toplam rapor sayısını temsil eden bir veri çerçevesi oluşturuyoruz. Grafikteki faktör seviyelerini sıralamak için bu vektör kullanılabilir.Aşağıdaki veri çerçevesine bakın:Şimdi, agg_weeks veri çerçevesindeki location_name faktör düzeylerinin sırası olmak için yukarıdaki veri çerçevesinden (facility_order$location_name) bir sütun kullanın:Ve şimdi, location_name sıralı bir faktör olacak şekilde veriler yeniden çizilir:","code":"\nfacility_order <- agg_weeks %>% \n  group_by(location_name) %>% \n  summarize(tot_reports = sum(n_days_reported, na.rm=T)) %>% \n  arrange(tot_reports) # ascending order\n# load package \npacman::p_load(forcats)\n\n# create factor and define levels manually\nagg_weeks <- agg_weeks %>% \n  mutate(location_name = fct_relevel(\n    location_name, facility_order$location_name)\n    )\nggplot(data = agg_weeks)+ \n  \n  # show data as tiles\n  geom_tile(\n    aes(x = week,\n        y = location_name,\n        fill = p_days_reported),      \n    color = \"white\")+                 # white gridlines\n  \n  scale_fill_gradient(\n    low = \"orange\",\n    high = \"darkgreen\",\n    na.value = \"grey80\")+\n  \n  # date axis\n  scale_x_date(\n    expand = c(0,0),             # remove extra space on sides\n    date_breaks = \"2 weeks\",     # labels every 2 weeks\n    date_labels = \"%d\\n%b\")+     # format is day over month (\\n in newline)\n  \n  # aesthetic themes\n  theme_minimal()+                                  # simplify background\n  \n  theme(\n    legend.title = element_text(size=12, face=\"bold\"),\n    legend.text  = element_text(size=10, face=\"bold\"),\n    legend.key.height = grid::unit(1,\"cm\"),           # height of legend key\n    legend.key.width  = grid::unit(0.6,\"cm\"),         # width of legend key\n    \n    axis.text.x = element_text(size=12),              # axis text size\n    axis.text.y = element_text(vjust=0.2),            # axis text alignment\n    axis.ticks = element_line(size=0.4),               \n    axis.title = element_text(size=12, face=\"bold\"),  # axis title size and bold\n    \n    plot.title = element_text(hjust=0,size=14,face=\"bold\"),  # title right-aligned, large, bold\n    plot.caption = element_text(hjust = 0, face = \"italic\")  # caption right-aligned and italic\n    )+\n  \n  # plot labels\n  labs(x = \"Week\",\n       y = \"Facility name\",\n       fill = \"Reporting\\nperformance (%)\",           # legend title, because legend shows fill\n       title = \"Percent of days per week that facility reported data\",\n       subtitle = \"District health facilities, May-July 2020\",\n       caption = \"7-day weeks beginning on Mondays.\")"},{"path":"isı-grafikleri.html","id":"değerleri-göster","chapter":"34 Isı grafikleri","heading":"Değerleri göster","text":"kutucuğun gerçek sayılarını görüntülemek için kutucukların üzerine bir geom_text() katmanı ekleyebilirsiniz. Çok sayıda küçük kutucuğunuz varsa, bunun hoş görünmeyebileceğini unutmayın!Şu kod eklendi: geom_text(aes(label = p_days_reported)). Bu, döşemeye metin ekler. Görüntülenen metin, bu durumda renk gradyanını oluşturmak için kullanılan p_days_reported ile aynı sayısal sütuna ayarlanmış olan label = bağımsız değişkenine atanan değerdir.","code":"\nggplot(data = agg_weeks)+ \n  \n  # show data as tiles\n  geom_tile(\n    aes(x = week,\n        y = location_name,\n        fill = p_days_reported),      \n    color = \"white\")+                 # white gridlines\n  \n  # text\n  geom_text(\n    aes(\n      x = week,\n      y = location_name,\n      label = p_days_reported))+      # add text on top of tile\n  \n  # fill scale\n  scale_fill_gradient(\n    low = \"orange\",\n    high = \"darkgreen\",\n    na.value = \"grey80\")+\n  \n  # date axis\n  scale_x_date(\n    expand = c(0,0),             # remove extra space on sides\n    date_breaks = \"2 weeks\",     # labels every 2 weeks\n    date_labels = \"%d\\n%b\")+     # format is day over month (\\n in newline)\n  \n  # aesthetic themes\n  theme_minimal()+                                    # simplify background\n  \n  theme(\n    legend.title = element_text(size=12, face=\"bold\"),\n    legend.text  = element_text(size=10, face=\"bold\"),\n    legend.key.height = grid::unit(1,\"cm\"),           # height of legend key\n    legend.key.width  = grid::unit(0.6,\"cm\"),         # width of legend key\n    \n    axis.text.x = element_text(size=12),              # axis text size\n    axis.text.y = element_text(vjust=0.2),            # axis text alignment\n    axis.ticks = element_line(size=0.4),               \n    axis.title = element_text(size=12, face=\"bold\"),  # axis title size and bold\n    \n    plot.title = element_text(hjust=0,size=14,face=\"bold\"),  # title right-aligned, large, bold\n    plot.caption = element_text(hjust = 0, face = \"italic\")  # caption right-aligned and italic\n    )+\n  \n  # plot labels\n  labs(x = \"Week\",\n       y = \"Facility name\",\n       fill = \"Reporting\\nperformance (%)\",           # legend title, because legend shows fill\n       title = \"Percent of days per week that facility reported data\",\n       subtitle = \"District health facilities, May-July 2020\",\n       caption = \"7-day weeks beginning on Mondays.\")"},{"path":"isı-grafikleri.html","id":"kaynaklar-27","chapter":"34 Isı grafikleri","heading":"34.4 Kaynaklar","text":"scale_fill_gradient()R grafik galerisi - ısı haritası","code":""},{"path":"diyagramlar-ve-çizelgeler.html","id":"diyagramlar-ve-çizelgeler","chapter":"35 Diyagramlar ve çizelgeler","heading":"35 Diyagramlar ve çizelgeler","text":"Bu sayfa, aşağıdaki başlıkları kapsamaktadır:**DiagrammeR* ve DOT dilini kullanan akış şemalarıAlluvial/Sankey diyagramlarıEtkinlik zaman çizelgeleri","code":""},{"path":"diyagramlar-ve-çizelgeler.html","id":"hazırlık-28","chapter":"35 Diyagramlar ve çizelgeler","heading":"35.1 Hazırlık","text":"","code":""},{"path":"diyagramlar-ve-çizelgeler.html","id":"paketleri-yükleme-10","chapter":"35 Diyagramlar ve çizelgeler","heading":"Paketleri yükleme","text":"Bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman paketinin p_load() işlevini vurguluyoruz. Ayrıca, R tabanından library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R temelleri sayfasına bakabilirsiniz.","code":"\npacman::p_load(\n  DiagrammeR,     # akış diyagramları için\n  networkD3,      # Alluvial/Sankey diyagramları için\n  tidyverse)      # veri yönetimi ve görselleştirme"},{"path":"diyagramlar-ve-çizelgeler.html","id":"verileri-içe-aktarma-8","chapter":"35 Diyagramlar ve çizelgeler","heading":"Verileri içe aktarma","text":"Bu sayfadaki içeriğin çoğu bir veri seti gerektirmez. Ancak, Sankey diyagramı bölümünde, simüle edilmiş bir Ebola salgınından vaka satır listesini kullanacağız. Bu bölümü takip etmek isterseniz, “temiz satır listesini” indirmek (.rds dosyası olarak) için tıklayabilirsiniz. rio paketinden import() fonksiyonuyla verileri içe aktarabilirsiniz (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe ve Dışa Aktarma] sayfasına bakınız).Çizgi listesinin ilk 50 satırı aşağıda gösterilmiştir.","code":"\n# satır listesini içe aktar\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"diyagramlar-ve-çizelgeler.html","id":"akış-diyagramları","chapter":"35 Diyagramlar ve çizelgeler","heading":"35.2 Akış diyagramları","text":"Grafikler/akış şemaları oluşturmak için R paketi olan DiagrammeR kullanılabilir. Akış şemaları ister statik olabilirler veya isterse bir veri kümesindeki değişikliklere göre kısıtlı bir şekilde dinamik olarak ayarlanabilirler.AraçlargrViz() fonksiyonu bir “Graphviz” diyagramı oluşturmak için kullanılır. Bu fonksiyon, diyagramı oluşturmak için talimatlar içeren bir karakter dizisi girişini kabul eder. Bu dizi içinde, talimatlar DOT adı verilen farklı bir dilde yazılmıştır - temel bilgileri öğrenmek oldukça kolaydır.Temel yapıgrViz(\" talimatlarını açınGrafiğin yönlülüğünü ve adını belirtin ve parantezleri açın, örn. digraph my_flow_chart {Grafik ifadesi (düzen, sıralama yönü)Düğüm ifadeleri (düğüm oluşturma)Kenar ifadeleri (düğümler arasında bağlantılar verir)Talimatları kapatın }\")","code":""},{"path":"diyagramlar-ve-çizelgeler.html","id":"basit-örnekler","chapter":"35 Diyagramlar ve çizelgeler","heading":"Basit örnekler","text":"Aşağıda iki basit örnek verilmiştirÇok minimal bir örnek:Biraz daha uygulamalı halk sağlığı bağlamına sahip bir örnek:","code":"\n# Minimal bir grafik\nDiagrammeR::grViz(\"digraph {\n  \ngraph[layout = dot, rankdir = LR]\n\na\nb\nc\n\na -> b -> c\n}\")\ngrViz(\"                           # Tüm talimatlar büyük bir karakter dizisi içindedir\ndigraph surveillance_diagram {    # digraph', 'yönlü grafik' anlamına gelir, ardından grafik adı\n  \n  # grafik ifadesi\n  #################\n  graph [layout = dot,\n         rankdir = TB,\n         overlap = true,\n         fontsize = 10]\n  \n  # düğümler\n  #######\n  node [shape = circle,           # shape = circle\n       fixedsize = true\n       width = 1.3]               # width of circles\n  \n  Primary                         # names of nodes\n  Secondary\n  Tertiary\n\n  # kenarlar\n  #######\n  Primary   -> Secondary [label = ' case transfer']\n  Secondary -> Tertiary [label = ' case transfer']\n}\n\")"},{"path":"diyagramlar-ve-çizelgeler.html","id":"sözdizimi","chapter":"35 Diyagramlar ve çizelgeler","heading":"Sözdizimi","text":"Temel sözdizimiDüğüm adları veya kenar ifadeleri boşluk, noktalı virgül veya yeni satırlarla ayrılabilir.Sıra yönüGrafik ifadesi içindeki rankdir argümanı ayarlanarak bir çizim soldan sağa hareket edecek şekilde yeniden yönlendirilebilir. Varsayılan değer TB’dir (yukarıdan aşağıya), ancak LR (soldan sağa), RL (sağdan sola) veya BT (aşağıdan yukarıya) olabilir.Düğüm adlarıDüğüm adları, yukarıdaki basit örnekte olduğu gibi tek kelime olabilir. Çok kelimeli adları veya özel karakterleri (örneğin parantezler, tireler) kullanmak için düğüm adını tek tırnak (’ ’) içine koyun. Kısa bir düğüm adına sahip olmak ve aşağıda köşeli parantez [ ] içinde gösterildiği gibi bir etiket atamak daha kolay olabilir. Düğümün adında yeni bir satır olmasını istiyorsanız, bunu bir etiket aracılığıyla yapmalısınız - aşağıda gösterildiği gibi düğüm etiketinde tek tırnak içinde \\n kullanmalısınız.Alt gruplar\nKenar ifadeleri içinde, küme parantezleri ({ }) ile kenarın iki tarafında alt gruplar oluşturulabilir. Kenar daha sonra parantez içindeki tüm düğümlere uygulanır - bu bir kısa gösterimdir.Düzenlerdot (rankdir argümanını TB, LR, RL, BT seçeneklerinden biri olarak belirleyin)neatotwopicircoDüğümler - düzenlenebilir niteliklerlabel (metin, çok kelimeli ise tek tırnak içinde)fillcolor (birçok olası renk)fontcoloralpha (şeffaflık 0-1)shape (elips, oval, elmas, yumurta, düz metin, nokta, kare, üçgen)stylesidesperipheriesfixedsize (h x w)heightwidthdistortionpenwidth (şekil kenarlığının genişliği)x (sola/sağa yer değiştirme)y (yukarı/aşağı yer değiştirme)fontnamefontsizeiconKenarlar - düzenlenebilir niteliklerarrowsizearrowhead (normal, kutu, karga, eğri, elmas, nokta, inv, yok, tee, vee)arrowtaildir (yön, )style (kesik çizgili, …)coloralphaheadport (ok başının önündeki metin)tailport (ok kuyruğunun arkasındaki metin)fontnamefontsizefontcolorpenwidth (ok genişliği)minlen (minimum uzunluk)Renk adları: onaltılık değerler veya ‘X11’ renk adları, X11 ayrıntıları için buraya bakabilirsiniz.","code":""},{"path":"diyagramlar-ve-çizelgeler.html","id":"karmaşık-örnekler","chapter":"35 Diyagramlar ve çizelgeler","heading":"Karmaşık örnekler","text":"Aşağıdaki örnek, gsurveillance_diagram genişleterek karmaşık düğüm adları, gruplandırılmış kenarlar, renkler ve stil eklerAlt grafik kümeleriDüğümleri kutulu kümeler halinde gruplamak için, onları aynı adlandırılmış alt grafik (subgraph name {}) içine koyun. bir alt grafiğin bir sınırlayıcı kutu içinde tanımlanmasını sağlamak için, aşağıdaki 4 kutu ile gösterildiği gibi alt grafiğin adına “küme” ile başlayın.Düğüm şekilleriLinkteki rehberden alınan aşağıdaki örnek, uygulanan düğüm şekillerini ve seri kenar bağlantıları için bir kısayol gösterir.","code":"DiagrammeR::grViz(\"               # Tüm talimatlar büyük bir karakter dizisi\ndigraph surveillance_diagram {    # digraph', 'yönlü grafik' anlamına gelir, ardından grafik adı\n  \n  # grafik ifadesi\n  #################\n  graph [layout = dot,\n         rankdir = TB,            # yukarıdan aşağıya düzen\n         fontsize = 10]\n  \n\n  # düğümler (daireler)\n  #################\n  node [shape = circle,           # shape = daire\n       fixedsize = true\n       width = 1.3]                      \n  \n  Primary   [label = 'Primary\\nFacility'] \n  Secondary [label = 'Secondary\\nFacility'] \n  Tertiary  [label = 'Tertiary\\nFacility'] \n  SC        [label = 'Surveillance\\nCoordination',\n             fontcolor = darkgreen] \n  \n  # kenarlar\n  #######\n  Primary   -> Secondary [label = ' case transfer',\n                          fontcolor = red,\n                          color = red]\n  Secondary -> Tertiary [label = ' case transfer',\n                          fontcolor = red,\n                          color = red]\n  \n  # gruplanmış kenar\n  {Primary Secondary Tertiary} -> SC [label = 'case reporting',\n                                      fontcolor = darkgreen,\n                                      color = darkgreen,\n                                      style = dashed]\n}\n\")DiagrammeR::grViz(\"             # Tüm talimatlar büyük bir karakter dizisi içindedir\ndigraph surveillance_diagram {  # 'digraph', 'yönlü grafik' anlamına gelir, ardından grafik adı\n  \n  # grafik ifadesi\n  #################\n  graph [layout = dot,\n         rankdir = TB,            \n         overlap = true,\n         fontsize = 10]\n  \n\n  # düğümler (daireler)\n  #################\n  node [shape = circle,                  # shape = daire\n       fixedsize = true\n       width = 1.3]                      # dairelerin genişliği\n  \n  subgraph cluster_passive {\n    Primary   [label = 'Primary\\nFacility'] \n    Secondary [label = 'Secondary\\nFacility'] \n    Tertiary  [label = 'Tertiary\\nFacility'] \n    SC        [label = 'Surveillance\\nCoordination',\n               fontcolor = darkgreen] \n  }\n  \n  # düğümler (kutular)\n  ###############\n  node [shape = box,                     # düğüm şekli\n        fontname = Helvetica]            # düğümdeki metin yazı tipi\n  \n  subgraph cluster_active {\n    Active [label = 'Active\\nSurveillance'] \n    HCF_active [label = 'HCF\\nActive Search']\n  }\n  \n  subgraph cluster_EBD {\n    EBS [label = 'Event-Based\\nSurveillance (EBS)'] \n    'Social Media'\n    Radio\n  }\n  \n  subgraph cluster_CBS {\n    CBS [label = 'Community-Based\\nSurveillance (CBS)']\n    RECOs\n  }\n\n  \n  # kenarlar\n  #######\n  {Primary Secondary Tertiary} -> SC [label = 'case reporting']\n\n  Primary   -> Secondary [label = 'case transfer',\n                          fontcolor = red]\n  Secondary -> Tertiary [label = 'case transfer',\n                          fontcolor = red]\n  \n  HCF_active -> Active\n  \n  {'Social Media' Radio} -> EBS\n  \n  RECOs -> CBS\n}\n\")\n\nDiagrammeR::grViz(\"digraph {\n\ngraph [layout = dot, rankdir = LR]\n\n# düğümlerin global stillerini tanımlar. İstersek bunları kutuda geçersiz kılabiliriz\nnode [shape = rectangle, style = filled, fillcolor = Linen]\n\ndata1 [label = 'Dataset 1', shape = folder, fillcolor = Beige]\ndata2 [label = 'Dataset 2', shape = folder, fillcolor = Beige]\nprocess [label =  'Process \\n Data']\nstatistical [label = 'Statistical \\n Analysis']\nresults [label= 'Results']\n\n# düğüm kimlikleri ile kenar tanımları\n{data1 data2}  -> process -> statistical -> results\n}\")"},{"path":"diyagramlar-ve-çizelgeler.html","id":"çıktılar","chapter":"35 Diyagramlar ve çizelgeler","heading":"Çıktılar","text":"Çıktılar nasıl işlenir ve kaydedilir:Çıktılar, varsayılan olarak Dosyalar, Grafikler, Paketler ve Yardım’ın yanında sağ altta RStudio’nun Görüntüleyici bölmesinde görünecektir.Dışa aktarmak için Görüntüleyiciden “Görüntü olarak kaydet” veya “Panoya kopyala” yapabilirsiniz. Grafik belirtilen boyuta ayarlanacaktır.","code":""},{"path":"diyagramlar-ve-çizelgeler.html","id":"parametreli-şekiller","chapter":"35 Diyagramlar ve çizelgeler","heading":"Parametreli şekiller","text":"Size önerebileceğimiz güzel bir rehberden bir alıntı ile başlamak istiyoruz: https://mikeyharper.uk/flowcharts--r-using-diagrammer/“Parametreli şekiller: Rakamları R içinde tasarlamanın büyük bir yararı, R değerlerini doğrudan akış şemalarımıza okuyarak rakamları doğrudan analizimizle bağlayabilmemizdir. Örneğin, bir işlemin aşamasından sonra değerleri kaldıran bir filtreleme işlemi oluşturduğunuzu varsayalım, işleminizin aşamasından sonra veri kümesinde kalan değerlerin sayısını gösteren bir şekle sahip olabilirsiniz. Bunu yapmak için, @@X sembolünü doğrudan şeklin içinde kullanabilir, ardından grafiğin alt bilgisinde [X]: kullanarak buna başvurabilirsiniz, burada X benzersiz bir sayısal dizindir.”Parametrelendirme ilgilendiğiniz bir şeyse, bu rehberi incelemenizi öneririz.","code":""},{"path":"diyagramlar-ve-çizelgeler.html","id":"alluvialsankey-diyagramları","chapter":"35 Diyagramlar ve çizelgeler","heading":"35.3 Alluvial/Sankey Diyagramları","text":"","code":""},{"path":"diyagramlar-ve-çizelgeler.html","id":"paketleri-yükleme-11","chapter":"35 Diyagramlar ve çizelgeler","heading":"Paketleri yükleme","text":"Bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman paketinin p_load() işlevini vurguluyoruz. Ayrıca, R tabanından library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R temelleri sayfasına bakabilirsiniz.Diyagramı oluşturmak için networkD3 paketini ve ayrıca veri hazırlama adımları için tidyverse’yüklüyoruz.","code":"\npacman::p_load(\n  networkD3,\n  tidyverse)"},{"path":"diyagramlar-ve-çizelgeler.html","id":"veri-kümesinden-grafik-yapma","chapter":"35 Diyagramlar ve çizelgeler","heading":"Veri kümesinden grafik yapma","text":"Bağlantıları bir veri kümesinde çizme. Aşağıda bu paketi vaka satırı listesinde kullanmayı gösteriyoruz. Çevrimiçi bir eğitime ulaşmak için bu linke tıklayabilirsiniz..benzersiz yaş kategorisi ve hastane kombinasyonu için vaka sayılarını alarak başlıyoruz. Anlaşılır olması için yaş kategorisine ait eksik değerleri kaldırdık. Ayrıca hospital ve age_cat sütunlarını sırasıyla source ve target olarak yeniden etiketliyoruz. Bunlar alluvial diyagramının iki yüzü olacaktır.Veri kümesi şimdi şöyle görünmektedir:Şimdi sütun adı altında tüm diyagram düğümlerinin bir veri çerçevesini oluşturuyoruz. Bu, hospital ve age_cat’e ait bütün değerlerden oluşmaktadır. Birleştirmeden önce hepsinin karakter sınıfı olduğundan emin olmalı ve kimlik sütunlarını etiketler yerine sayı olacak şekilde ayarlamalıyız:Yukarıda oluşturduğumuz link veri çerçevesini count() ile düzenliyoruz. Düğümler arasındaki bağlantıları gerçekten yansıtacak/oluşturacak iki sayısal sütun IDsource ve IDtarget ekliyoruz. Bu sütunlar, kaynak ve hedef düğümlerin satır numaralarını (konumunu) tutacaktır. 1 çıkarılır, böylece bu konum numaraları 0’dan başlar (1 değil).Bağlantı veri kümesi şimdi şöyle görünür:Şimdi Sankey diyagramını sankeyNetwork() ile çizebiliriz. Konsolda ?sankeyNetwork komutunu çalıştırarak bir bağımsız değişkeni hakkında daha fazla bilgi edinebilirsiniz. iterations = 0 olarak ayarlamadığınız sürece düğümlerinizin sırasının beklendiği gibi olmayabileceğini unutmayın.Burada hasta çıktısının da dahil edildiği bir örnek verilmiştir. Veri hazırlama adımında, yaş ile hastane arasındaki ve hastane ile sonuç arasındaki vaka sayılarını ayrı ayrı hesaplamamız gerektiğine ve ardından tüm bu sayıları bind_rows() ile birbirine bağlamamız gerektiğine dikkat etmelisiniz.https://www.displayr.com/sankey-diagrams-r/","code":"\n# hastane ve yaş kategorisine göre sayımlar\nlinks <- linelist %>% \n  drop_na(age_cat) %>% \n  select(hospital, age_cat) %>%\n  count(hospital, age_cat) %>% \n  rename(source = hospital,\n         target = age_cat)\n# Benzersiz düğüm adları\nnodes <- data.frame(\n  name=c(as.character(links$source), as.character(links$target)) %>% \n    unique()\n  )\n\nnodes  # yazdır##                                    name\n## 1                      Central Hospital\n## 2                     Military Hospital\n## 3                               Missing\n## 4                                 Other\n## 5                         Port Hospital\n## 6  St. Mark's Maternity Hospital (SMMH)\n## 7                                   0-4\n## 8                                   5-9\n## 9                                 10-14\n## 10                                15-19\n## 11                                20-29\n## 12                                30-49\n## 13                                50-69\n## 14                                  70+\n# isimlerle değil sayılarla eşleştirir\nlinks$IDsource <- match(links$source, nodes$name)-1 \nlinks$IDtarget <- match(links$target, nodes$name)-1\n# grafik\n######\np <- sankeyNetwork(\n  Links = links,\n  Nodes = nodes,\n  Source = \"IDsource\",\n  Target = \"IDtarget\",\n  Value = \"n\",\n  NodeID = \"name\",\n  units = \"TWh\",\n  fontSize = 12,\n  nodeWidth = 30,\n  iterations = 0)        # düğüm sırasının verilerdeki gibi olduğundan emin olun\np\n# hastane ve yaş kategorisine göre sayımlar\nage_hosp_links <- linelist %>% \n  drop_na(age_cat) %>% \n  select(hospital, age_cat) %>%\n  count(hospital, age_cat) %>% \n  rename(source = age_cat,          # yeniden adlandır\n         target = hospital)\n\nhosp_out_links <- linelist %>% \n    drop_na(age_cat) %>% \n    select(hospital, outcome) %>% \n    count(hospital, outcome) %>% \n    rename(source = hospital,       # yeniden adlandır\n           target = outcome)\n\n# bağlantıları birleştir\nlinks <- bind_rows(age_hosp_links, hosp_out_links)\n\n# Benzersiz düğüm adları\nnodes <- data.frame(\n  name=c(as.character(links$source), as.character(links$target)) %>% \n    unique()\n  )\n\n# Kimlik numaraları oluştur\nlinks$IDsource <- match(links$source, nodes$name)-1 \nlinks$IDtarget <- match(links$target, nodes$name)-1\n\n# grafik\n######\np <- sankeyNetwork(Links = links,\n                   Nodes = nodes,\n                   Source = \"IDsource\",\n                   Target = \"IDtarget\",\n                   Value = \"n\",\n                   NodeID = \"name\",\n                   units = \"TWh\",\n                   fontSize = 12,\n                   nodeWidth = 30,\n                   iterations = 0)\np"},{"path":"diyagramlar-ve-çizelgeler.html","id":"etkinlik-zaman-çizelgeleri","chapter":"35 Diyagramlar ve çizelgeler","heading":"35.4 Etkinlik zaman çizelgeleri","text":"Belirli olayları gösteren bir zaman çizelgesi oluşturmak için vistime paketini kullanabilirsiniz.Linkteki bu gösterimi inceleyebilirsinizİşte kodladığımız olaylar veri seti:","code":"\n# paketi yükle\npacman::p_load(vistime,  # zaman çizelgesini hazırla\n               plotly    # etkileşimli görselleştirme için\n               )\np <- vistime(data)    # vistime'ı uygula\n\nlibrary(plotly)\n\n# 1. adım: bir listeye dönüştür\npp <- plotly_build(p)\n\n# 2. adım: İşaretleyici boyutu\nfor(i in 1:length(pp$x$data)){\n  if(pp$x$data[[i]]$mode == \"markers\") pp$x$data[[i]]$marker$size <- 10\n}\n\n# 3. adım: metin boyutu\nfor(i in 1:length(pp$x$data)){\n  if(pp$x$data[[i]]$mode == \"text\") pp$x$data[[i]]$textfont$size <- 10\n}\n\n\n# 4. adım: metin konumu\nfor(i in 1:length(pp$x$data)){\n  if(pp$x$data[[i]]$mode == \"text\") pp$x$data[[i]]$textposition <- \"right\"\n}\n\n#yazdır\npp"},{"path":"diyagramlar-ve-çizelgeler.html","id":"dagler","chapter":"35 Diyagramlar ve çizelgeler","heading":"35.5 DAG’ler","text":"Yukarıda açıklandığı gibi DiagammeR paketini ve DOT dilini kullanarak manuel olarak bir DAG oluşturabilirsiniz.Alternatif olarak, ggdag ve dagitty gibi paketler de var.DAG’lere giriş ggdag gösterimiR’deki dag’lere nedensellik","code":""},{"path":"diyagramlar-ve-çizelgeler.html","id":"kaynaklar-28","chapter":"35 Diyagramlar ve çizelgeler","heading":"35.6 Kaynaklar","text":"DOT diliyle ilgili yukarıdakilerin çoğu bu sitedeki öğreticiden uyarlanmıştır.DiagammeR hakkında daha ayrıntılı bir eğitim dahaSankey diagramları hakkında bu sayfa","code":""},{"path":"kombinasyon-analizi.html","id":"kombinasyon-analizi","chapter":"36 Kombinasyon analizi","heading":"36 Kombinasyon analizi","text":"Bu analiz grafikleri, değerlerin/yanıtların farklı kombinasyonlarının sıklığını gösterir. Bu örnekte, vakaların çeşitli semptom kombinasyonları sergilediği sıklığı çiziyoruz.Bu analize genellikle şu ad verilir:“Çoklu yanıt analizi”“Küme analizi”“Kombinasyon analizi”Yukarıdaki örnek çizimde, beş belirti gösterilmektedir. dikey çubuğun altında, yukarıdaki çubuk tarafından yansıtılan semptomların kombinasyonunu gösteren bir çizgi ve noktalar bulunur. Sağda, yatay çubuklar bir semptomun sıklığını yansıtır.Gösterdiğimiz ilk yöntem ggupset paketini, ikincisi ise UpSetR paketini kullanmaktadır.","code":""},{"path":"kombinasyon-analizi.html","id":"hazırlık-29","chapter":"36 Kombinasyon analizi","heading":"36.1 Hazırlık","text":"","code":""},{"path":"kombinasyon-analizi.html","id":"paketleri-yükleyin-7","chapter":"36 Kombinasyon analizi","heading":"Paketleri yükleyin","text":"Bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() vurgusu yapıyoruz. R tabanından library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakabilirsiniz.","code":"\npacman::p_load(\n  tidyverse,     # veri yönetimi ve görselleştirme\n  UpSetR,        # kombinasyon grafikleri için özel paket\n  ggupset)       # kombinasyon grafikleri için özel paket"},{"path":"kombinasyon-analizi.html","id":"verileri-içe-aktar-6","chapter":"36 Kombinasyon analizi","heading":"Verileri içe aktar","text":"Başlamak için, simüle edilmiş bir Ebola salgınından temizlenmiş vaka listesini içe aktarıyoruz. Takip etmek isterseniz, “clean” dosyasını indirmek için tıklayın.  (.rds dosyası olarak). rio paketinden import() fonksiyonuyla verileri içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe aktarma ve dışa aktarma] sayfasına bakın).Bu satır listesi, bildirilen semptomlarla ilgili beş “evet/hayır” değişkeni içerir. Grafiğimizi oluşturmak için ggupset paketini kullanmak için bu değişkenleri biraz dönüştürmemiz gerekecek. Verileri görüntüleyin (semptom değişkenlerini görmek için sağa kaydırın).","code":"\n# Vaka satırlistesini içe aktarın\nlinelist_sym <- import(\"linelist_cleaned.rds\")"},{"path":"kombinasyon-analizi.html","id":"değerleri-yeniden-biçimlendir","chapter":"36 Kombinasyon analizi","heading":"Değerleri yeniden biçimlendir","text":"ggupset tarafından beklenen formata uyum sağlamak için dplyr’den case_while() kullanarak gerçek semptom adını “evet” ve “hayır”dönüştürürüz. “Hayır” ise, değeri boş olarak ayarlarız, bu nedenle değerler “NA” veya semptomdur.Şimdi iki son sütun yapıyoruz:Hastanın tüm semptomlarını birleştirmek (birbirine yapıştırmak) (bir karakter sütunu)Yukarıdaki sütunu list sınıfına dönüştürmek, böylece grafik yapmak için ggupset tarafından kabul edilebilir.stringr’den unite() fonksiyonu hakkında daha fazla bilgi edinmek için Karakterler ve dizeler hakkındaki sayfaya bakabilirsiniz.Yeni verileri görüntüleyin. Sağ uca doğru iki sütuna dikkat edin - yapıştırılan birleştirilmiş değerler ve liste","code":"\n# noktalı virgülle ayrılmış olarak adlandırılmış belirtilerle sütun oluşturun\nlinelist_sym_1 <- linelist_sym %>% \n  \n  # \"evet\" ve \"hayır\" değerlerini semptom adının kendisine dönüştürün\n  mutate(fever = ifelse(fever == \"yes\", \"fever\", NA), \n       chills = ifelse(chills == \"yes\", \"chills\", NA),\n       cough = ifelse(cough == \"yes\", \"cough\", NA),\n       aches = ifelse(aches == \"yes\", \"aches\", NA),\n       vomit = ifelse(vomit == \"yes\", \"vomit\", NA))\nlinelist_sym_1 <- linelist_sym_1 %>% \n  unite(col = \"all_symptoms\",\n        c(fever, chills, cough, aches, vomit), \n        sep = \"; \",\n        remove = TRUE,\n        na.rm = TRUE) %>% \n  mutate(\n    # all_symptoms sütununun, \"list\" sınıfının (bir sonraki adımda ggupset() kullanmak için gereklidir) bir kopyasını yapın\n    all_symptoms_list = as.list(strsplit(all_symptoms, \"; \"))\n    )"},{"path":"kombinasyon-analizi.html","id":"ggupset","chapter":"36 Kombinasyon analizi","heading":"36.2 ggupset","text":"Paketi yüklemeGrafik oluşturun. Bir ggplot() ve geom_bar() ile başlıyoruz, ancak sonra ggupset’ten scale_x_upset() özel fonksiyonunu ekliyoruz.ggupset hakkında daha fazla bilgiyi çevrimiçi veya çevrimdışı olarak RStudio Yardım sekmeniz ?ggupset içindeki paket belgelerinde bulabilirsiniz.","code":"\npacman::p_load(ggupset)\nggplot(\n  data = linelist_sym_1,\n  mapping = aes(x = all_symptoms_list)) +\ngeom_bar() +\nscale_x_upset(\n  reverse = FALSE,\n  n_intersections = 10,\n  sets = c(\"fever\", \"chills\", \"cough\", \"aches\", \"vomit\"))+\nlabs(\n  title = \"Signs & symptoms\",\n  subtitle = \"10 most frequent combinations of signs and symptoms\",\n  caption = \"Caption here.\",\n  x = \"Symptom combination\",\n  y = \"Frequency in dataset\")"},{"path":"kombinasyon-analizi.html","id":"upsetr","chapter":"36 Kombinasyon analizi","heading":"36.3 UpSetR","text":"UpSetR paketi grafiğin daha fazla özelleştirilmesine izin verir, ancak yürütülmesi daha zor olabilir:Paketi yüklemekVeri temizliği‘satırlistesi’ semptom değerlerini 1 / 0’çevirmeliyiz.Daha verimli bir komutla ilgileniyorsanız, mantıksal bir ifadeye dayalı olarak 1’lere ve 0’lara dönüştüren +() işlevinden yararlanabilirsiniz. Bu komut, aynı anda birden fazla sütunu değiştirmek için across() fonksiyonunu kullanır (daha fazla bilgi için Veri temizleme ve temel fonksiyonlar).Şimdi ‘upset()’ özel fonksiyonunu kullanarak grafiği yapın - yalnızca belirtiler sütunlarını kullanarak. Hangi “kümelerin” karşılaştırılacağını belirlemelisiniz (semptom sütunlarının adları). Alternatif olarak, yalnızca en iyi X kombinasyonlarını göstermek için nsets = ve order.= \"freq\" kullanın.","code":"\npacman::p_load(UpSetR)\n# upSetR kullanarak yapın\n\nlinelist_sym_2 <- linelist_sym %>% \n  \n  # \"evet\" ve \"hayır\" değerlerini semptom adının kendisine dönüştürün\n     mutate(fever = ifelse(fever == \"yes\", 1, 0), \n            chills = ifelse(chills == \"yes\", 1, 0),\n            cough = ifelse(cough == \"yes\", 1, 0),\n            aches = ifelse(aches == \"yes\", 1, 0),\n            vomit = ifelse(vomit == \"yes\", 1, 0))\n# Efficiently convert \"yes\" to 1 and 0\nlinelist_sym_2 <- linelist_sym %>% \n  \n  # convert the \"yes\" and \"no\" values into 1s and 0s\n  mutate(across(c(fever, chills, cough, aches, vomit), .fns = ~+(.x == \"yes\")))\n# Grafiği çizin\nlinelist_sym_2 %>% \n     UpSetR::upset(\n       sets = c(\"fever\", \"chills\", \"cough\", \"aches\", \"vomit\"),\n       order.by = \"freq\",\n       sets.bar.color = c(\"blue\", \"red\", \"yellow\", \"darkgreen\", \"orange\"), # optional colors\n       empty.intersections = \"on\",\n       # nsets = 3,\n       number.angles = 0,\n       point.size = 3.5,\n       line.size = 2, \n       mainbar.y.label = \"Symptoms Combinations\",\n       sets.x.label = \"Patients with Symptom\")"},{"path":"kombinasyon-analizi.html","id":"kaynaklar-29","chapter":"36 Kombinasyon analizi","heading":"36.4 Kaynaklar","text":"UpSetR üzerine github sayfasıA Shiny uygulama versiyonu - kendi verinizi yükleyebilirsiniz*belgeler - yorumlanması zor","code":""},{"path":"iletim-zincirleri.html","id":"iletim-zincirleri","chapter":"37 İletim Zincirleri","heading":"37 İletim Zincirleri","text":"","code":""},{"path":"iletim-zincirleri.html","id":"genel-bakış-7","chapter":"37 İletim Zincirleri","heading":"37.1 Genel Bakış","text":"İletim zincirlerini ve temas izleme verilerini işlemek, analiz etmek ve görselleştirmek için birincil araç, RECON tarafından geliştirilen epicontacts paketidir. Daha fazla bilgi için imleci nodların üzerine getirerek, taşımak için sürükleyerek ve aşağı akış durumlarını vurgulamak için üzerlerine tıklayarak aşağıdaki etkileşimli grafiği deneyin","code":""},{"path":"iletim-zincirleri.html","id":"hazırlık-30","chapter":"37 İletim Zincirleri","heading":"37.2 Hazırlık","text":"","code":""},{"path":"iletim-zincirleri.html","id":"paketlerin-yüklenmesi-5","chapter":"37 İletim Zincirleri","heading":"Paketlerin yüklenmesi","text":"Önce verilerin içe aktarılması ve işlenmesi için gereken standart paketleri yükleyin. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’ın ‘p_load()’ fonksiyonunu vurguluyoruz. Ayrıca R tabanı’ndan ‘library()’ ile paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R’ın temelleri[R Basics] sayfasına bakın.Pacman’ın p_install_github() fonksiyonu kullanılarak github’dan yüklenebilen epicontacts’ın geliştirme sürümüne ihtiyacınız olacak. Aşağıdaki komutu yalnızca bir kez çalıştırmanız gerekir, paketi kullandığınızda değil (bundan sonra zamanki gibi p_load() kullanabilirsiniz).","code":"\npacman::p_load(\n   rio,          # Dosyanın içe aktarımı \n   here,         # Dosyanın konumlandırılması \n   tidyverse,    # Veri yönetimi + ggplot2 grafikleri\n   remotes       # github’dan paketlerin kurulumu  \n)\npacman::p_install_gh(\"reconhub/epicontacts@timeline\")"},{"path":"iletim-zincirleri.html","id":"verinin-içeri-aktarımı-2","chapter":"37 İletim Zincirleri","heading":"Verinin içeri aktarımı","text":"Simüle edilmiş bir Ebola salgını vakalarından oluşan veri setini içe aktarıyoruz. Adım adım verileri indirmek istiyorsanız, el kitabı ve verilerin indirilmesi sayfasındaki talimatlara [Download handbook data] bakın. Veri seti, rio paketinden import() fonkisyonu kullanılarak içe aktarılır. Verileri içe aktarmanın çeşitli yolları için İçe ve dışa aktarma sayfasına [Import export] bakın.Çizgi listesinin ilk 50 satırı aşağıda gösterilmiştir. Özellikle ilgi çekici olan sütunlar : ‘case_id’, ‘generation’, ‘infector’ ve ‘source’.","code":"\n# satır listesini içe aktarın\nlinelist <- import(\"linelist_cleaned.xlsx\")"},{"path":"iletim-zincirleri.html","id":"epicontacts-nesnesi-oluşturma","chapter":"37 İletim Zincirleri","heading":"Epicontacts nesnesi oluşturma","text":"Daha sonra iki tür veri gerektiren bir epicontacts nesnesi oluşturmamız gerekiyor:\n• Sütunların değişken olduğu ve satırların benzersiz durumlara karşılık geldiği bir satır listesi\n• Benzersiz kimliklerle vakalar arasındaki bağlantıları tanımlayan kenarların bir listesi (bunlar kişiler, aktarım olayları vb. olabilir)Halihazırda bir satır listemiz olduğundan, vakalar arasında, daha spesifik olarak kimlikleri arasında bir kenar listesi oluşturmamız gerekiyor. Enfektör sütununu ‘case_id’ sütununa bağlayarak satır listesinden iletim bağlantılarını çıkarabiliriz. Bu noktada, vakaların kendilerini değil, iki durum arasındaki bağlantıyı tanımlayan herhangi bir değişkeni gösterdiğimiz kenar özelliklerini (edge properties) de ekleyebiliriz. Örnek olarak, iletim olayının konumunu tanımlayan bir konum değişkeni ve gün cinsinden temasın süresini tanımlayan bir süre değişkeni ekleyeceğiz.Aşağıdaki kodda, dplyr fonksiyonu transmut’e, yalnızca fonksiyon içinde belirttiğimiz sütunları tutması dışında mutate’e benzer. drop_na fonksiyonu, belirtilen sütunlarda bir NA değeri olan tüm satırları filtreleyecektir; bu durumda, yalnızca bulaştırıcının bilindiği satırları tutmak istiyoruz.Artık ‘make_epicontacts’ fonksiyonunu kullanarak epicontacts nesnesini oluşturabiliriz. Satır listesindeki hangi sütunun benzersiz vaka tanımlayıcısına işaret ettiğini ve ayrıca ilgili kişilerdeki hangi sütunların bağlantıda yer alan vakaların benzersiz tanımlayıcılarına işaret ettiğini belirtmemiz gerekir. Bu bağlantılar, enfeksiyonun bulaştırıcıdan vakaya gittiği yöndedir, bu nedenle başlangıç ve sonuç değişkenlerini belirtmemiz gerekir. Bu sebeple, gelecekteki işlemleri etkileyecek olan yönlendirilmiş (directed) değişkenini TRUE olarak ayarladık.Epicontacts nesnelerini inceledikten sonra, satır listesindeki case_id sütununun id olarak yeniden adlandırıldığını ve temaslılardaki case_id ve infector sütunlarının (-den) ve (-e) olarak yeniden adlandırıldığını görebiliriz. Bu adım, sonraki işleme, görselleştirme ve analiz işlemlerinde tutarlılık sağlar.","code":"\n## kişileri oluştur\ncontacts <- linelist %>%\n  transmute(\n    infector = infector,\n    case_id = case_id,\n    location = sample(c(\"Community\", \"Nosocomial\"), n(), TRUE),\n    duration = sample.int(10, n(), TRUE)\n  ) %>%\n  drop_na(infector)\n## epicontacts nesnesi oluştur \nepic <- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts,\n  id = \"case_id\",\n  from = \"infector\",\n  to = \"case_id\",\n  directed = TRUE\n)\n##  epicontacts nesnesini göster\nepic## \n## /// Epidemiological Contacts //\n## \n##   // class: epicontacts\n##   // 5,888 cases in linelist; 3,800 contacts; directed \n## \n##   // linelist\n## \n## # A tibble: 5,888 × 30\n##    id     generation date_infec…¹ date_onset date_hos…² date_out…³ outcome gender   age age_u…⁴ age_y…⁵ age_cat age_c…⁶\n##    <chr>       <dbl> <date>       <date>     <date>     <date>     <chr>   <chr>  <dbl> <chr>     <dbl> <fct>   <fct>  \n##  1 5fe599          4 2014-05-08   2014-05-13 2014-05-15 NA         <NA>    m          2 years         2 0-4     0-4    \n##  2 8689b7          4 NA           2014-05-13 2014-05-14 2014-05-18 Recover f          3 years         3 0-4     0-4    \n##  3 11f8ea          2 NA           2014-05-16 2014-05-18 2014-05-30 Recover m         56 years        56 50-69   55-59  \n##  4 b8812a          3 2014-05-04   2014-05-18 2014-05-20 NA         <NA>    f         18 years        18 15-19   15-19  \n##  5 893f25          3 2014-05-18   2014-05-21 2014-05-22 2014-05-29 Recover m          3 years         3 0-4     0-4    \n##  6 be99c8          3 2014-05-03   2014-05-22 2014-05-23 2014-05-24 Recover f         16 years        16 15-19   15-19  \n##  7 07e3e8          4 2014-05-22   2014-05-27 2014-05-29 2014-06-01 Recover f         16 years        16 15-19   15-19  \n##  8 369449          4 2014-05-28   2014-06-02 2014-06-03 2014-06-07 Death   f          0 years         0 0-4     0-4    \n##  9 f393b4          4 NA           2014-06-05 2014-06-06 2014-06-18 Recover m         61 years        61 50-69   60-64  \n## 10 1389ca          4 NA           2014-06-05 2014-06-07 2014-06-09 Death   f         27 years        27 20-29   25-29  \n## # … with 5,878 more rows, 17 more variables: hospital <chr>, lon <dbl>, lat <dbl>, infector <chr>, source <chr>,\n## #   wt_kg <dbl>, ht_cm <dbl>, ct_blood <dbl>, fever <chr>, chills <chr>, cough <chr>, aches <chr>, vomit <chr>,\n## #   temp <dbl>, time_admission <chr>, bmi <dbl>, days_onset_hosp <dbl>, and abbreviated variable names\n## #   ¹​date_infection, ²​date_hospitalisation, ³​date_outcome, ⁴​age_unit, ⁵​age_years, ⁶​age_cat5\n## \n##   // contacts\n## \n## # A tibble: 3,800 × 4\n##    from   to     location   duration\n##    <chr>  <chr>  <chr>         <int>\n##  1 f547d6 5fe599 Nosocomial        3\n##  2 f90f5f b8812a Nosocomial        2\n##  3 11f8ea 893f25 Community        10\n##  4 aec8ec be99c8 Community         6\n##  5 893f25 07e3e8 Nosocomial        8\n##  6 133ee7 369449 Nosocomial        8\n##  7 996f3a 2978ac Community         7\n##  8 133ee7 57a565 Community         8\n##  9 37a6f6 fc15ef Nosocomial        8\n## 10 9f6884 2eaa9a Community        10\n## # … with 3,790 more rows"},{"path":"iletim-zincirleri.html","id":"idare","chapter":"37 İletim Zincirleri","heading":"37.3 İdare","text":"","code":""},{"path":"iletim-zincirleri.html","id":"altkümeleme","chapter":"37 İletim Zincirleri","heading":"Altkümeleme","text":"epicontacts nesneleri için subset() yöntemi, diğer nesnelerin yanı sıra, satır listesinin (“düğüm(nod) öznitelikleri”) ve kişiler veritabanının (“kenar öznitelikleri”) özelliklerine dayalı olarak ağların filtrelenmesine olanak tanır. Bu değerler, ilgili bağımsız değişkene adlandırılmış listeler olarak iletilmelidir. Örneğin, aşağıdaki kodda sadece Nisan-Temmuz 2014 arasında enfeksiyonu olan (tarihler aralık olarak belirtilmiştir) erkek vakaları ve hastanede meydana gelen bulaşma bağlantılarını satır listesinde tutuyoruz.thin fonksiyonunu, ‘= “linelist”’ değişkeniyle temaslılarda bulunan vakaları dahil etmek için satır listesini filtrelemek veya ‘= “contacts”’ değişkeniyle satır listesinde bulunan vakaları dahil etmek için kullanabiliriz. Aşağıdaki kodda, yukarıda filtrelediğimiz Nisan ve Temmuz ayları arasında enfekte olan erkek vakaları içeren iletim bağlantılarını tutmak için epicontacts nesnesini ayrıca filtreliyoruz. Sadece iki bilinen iletim bağlantısının bu filtreye uyduğunu görebiliriz.Nod ve kenar özniteliklerine göre alt kümelemeye ek olarak, ağlar yalnızca belirli nodlara bağlı bileşenleri içerecek şekilde budanabilir. ‘Cluster_id’ değişkeni, vaka kimliklerinin bir vektörünü alır ve doğrudan veya dolaylı olarak bu kimliklere bağlı bireylerin satır listesini getirir. Aşağıdaki kodda, ‘2ae019’ ve ‘71577a’ içeren kümelerde toplam 13 satır listesi vakasının yer aldığını görebiliriz.epicontacts nesneleri için subset() yöntemi ayrıca cs, cs_min ve cs_max değişkenlerini kullanarak küme boyutuna göre filtrelemeye izin verir. Aşağıdaki kodda, yalnızca 10 vaka veya daha büyük kümelere dahil olan vakaları tutuyoruz ve bu kümelerde 271 satır listesi vakasının yer aldığını görebiliriz.","code":"\nsub_attributes <- subset(\n  epic,\n  node_attribute = list(\n    gender = \"m\",\n    date_infection = as.Date(c(\"2014-04-01\", \"2014-07-01\"))\n  ), \n  edge_attribute = list(location = \"Nosocomial\")\n)\nsub_attributes## \n## /// Epidemiological Contacts //\n## \n##   // class: epicontacts\n##   // 69 cases in linelist; 1,951 contacts; directed \n## \n##   // linelist\n## \n## # A tibble: 69 × 30\n##    id     generation date_infec…¹ date_onset date_hos…² date_out…³ outcome gender   age age_u…⁴ age_y…⁵ age_cat age_c…⁶\n##    <chr>       <dbl> <date>       <date>     <date>     <date>     <chr>   <chr>  <dbl> <chr>     <dbl> <fct>   <fct>  \n##  1 5fe599          4 2014-05-08   2014-05-13 2014-05-15 NA         <NA>    m          2 years         2 0-4     0-4    \n##  2 893f25          3 2014-05-18   2014-05-21 2014-05-22 2014-05-29 Recover m          3 years         3 0-4     0-4    \n##  3 2978ac          4 2014-05-30   2014-06-06 2014-06-08 2014-06-15 Death   m         12 years        12 10-14   10-14  \n##  4 57a565          4 2014-05-28   2014-06-13 2014-06-15 NA         Death   m         42 years        42 30-49   40-44  \n##  5 fc15ef          6 2014-06-14   2014-06-16 2014-06-17 2014-07-09 Recover m         19 years        19 15-19   15-19  \n##  6 99e8fa          7 2014-06-24   2014-06-28 2014-06-29 2014-07-09 Recover m         19 years        19 15-19   15-19  \n##  7 f327be          6 2014-06-14   2014-07-12 2014-07-13 2014-07-14 Death   m         31 years        31 30-49   30-34  \n##  8 90e5fe          5 2014-06-18   2014-07-13 2014-07-14 2014-07-16 <NA>    m         67 years        67 50-69   65-69  \n##  9 a47529          5 2014-06-13   2014-07-17 2014-07-18 2014-07-26 Death   m         45 years        45 30-49   45-49  \n## 10 da8ecb          5 2014-06-20   2014-07-18 2014-07-20 2014-08-01 <NA>    m         12 years        12 10-14   10-14  \n## # … with 59 more rows, 17 more variables: hospital <chr>, lon <dbl>, lat <dbl>, infector <chr>, source <chr>,\n## #   wt_kg <dbl>, ht_cm <dbl>, ct_blood <dbl>, fever <chr>, chills <chr>, cough <chr>, aches <chr>, vomit <chr>,\n## #   temp <dbl>, time_admission <chr>, bmi <dbl>, days_onset_hosp <dbl>, and abbreviated variable names\n## #   ¹​date_infection, ²​date_hospitalisation, ³​date_outcome, ⁴​age_unit, ⁵​age_years, ⁶​age_cat5\n## \n##   // contacts\n## \n## # A tibble: 1,951 × 4\n##    from   to     location   duration\n##    <chr>  <chr>  <chr>         <int>\n##  1 f547d6 5fe599 Nosocomial        3\n##  2 f90f5f b8812a Nosocomial        2\n##  3 893f25 07e3e8 Nosocomial        8\n##  4 133ee7 369449 Nosocomial        8\n##  5 37a6f6 fc15ef Nosocomial        8\n##  6 4802b1 bbfa93 Nosocomial        3\n##  7 a75c7f 7f5a01 Nosocomial        6\n##  8 a2086d a47529 Nosocomial        6\n##  9 eb2277 da8ecb Nosocomial        2\n## 10 d6584f f5c142 Nosocomial        4\n## # … with 1,941 more rows\nsub_attributes <- thin(sub_attributes, what = \"contacts\")\nnrow(sub_attributes$contacts)## [1] 4\nsub_id <- subset(epic, cluster_id = c(\"2ae019\",\"71577a\"))\nnrow(sub_id$linelist)## [1] 13\nsub_cs <- subset(epic, cs_min = 10)\nnrow(sub_cs$linelist)## [1] 271"},{"path":"iletim-zincirleri.html","id":"idlere-ulaşmak","chapter":"37 İletim Zincirleri","heading":"ID’lere ulaşmak","text":"get_id() fonksiyonu, veri setindeki vaka kimlikleri hakkında bilgi toplar ve aşağıdaki gibi parametrelenebilir:\n• linelist: satır listesi verilerindeki kimlikler\n• contacts: temaslı veri setindeki kimlikler (“-kimden” ve “-kime” birleşik)\n• : temaslı veri setinin “kimden” sütunundaki kimlikler\n• : temaslı veri setinin “” sütunundaki kimliklere\n• : iki veri kümesinde de herhangi bir yerde görünen kimlikler\n• common: Hem temaslı veri setinde hem de satır listesinde görünen kimliklerÖrneğin, veri kümesindeki ilk kimlik nedir?Hem satır listesinde hem de temaslılarda kaç kimlik var?","code":"\ncontacts_ids <- get_id(epic, \"contacts\")\nhead(contacts_ids, n = 10)##  [1] \"f547d6\" \"f90f5f\" \"11f8ea\" \"aec8ec\" \"893f25\" \"133ee7\" \"996f3a\" \"37a6f6\" \"9f6884\" \"4802b1\"\nlength(get_id(epic, \"common\"))## [1] 4352"},{"path":"iletim-zincirleri.html","id":"görselleştirme","chapter":"37 İletim Zincirleri","heading":"37.4 Görselleştirme","text":"","code":""},{"path":"iletim-zincirleri.html","id":"temel-grafik-oluşturma","chapter":"37 İletim Zincirleri","heading":"Temel grafik oluşturma","text":"Epicontacts nesnelerinin tüm görselleştirmeleri, plot fonksiyonu tarafından gerçekleşitirilr. İlk önce epicontacts nesnesini subset fonksiyonunu kullanarak yalnızca Haziran 2014 başlangıç tarihine sahip vakaları içerecek şekilde filtreleyeceğiz ve thin fonksiyonu kullanarak bu vakalarla bağlantılı kişileri dahil edeceğiz.Daha sonra basit bir etkileşimli grafiği aşağıdaki gibi kolay şekilde oluşturabiliriz:Bu grafiği daha da değiştirmek için çok sayıda değişken bulunur. Esas olanları burada ele alacağız, ancak fonksiyonun tam bir açıklamasını elde etmek için ?vis_epicontacts (bir epicontacts nesnesi üzerinde çizim kullanılırken çağrılan fonksiyon) aracılığıyla belgelere bakın.####Nod özelliklerinin görselleştirilmesi {.unnumbered}Nod rengi, şekli ve boyutu, node_color, node_shape ve node_size bağımsız değişkenleri kullanılarak satır listesindeki belirli bir sütuna eşlenebilir. Bu, ggplot2’den tanıyabileceğiniz aes sözdizimine benzer.Nodların belirli renkleri, şekilleri ve boyutları aşağıdaki gibi belirlenebilir:\n• Col_pal değişkeni aracılığıyla, aşağıda yapıldığı gibi rengin manuel olarak belirtilmesi için bir ad listesi yazarak ya da colorRampPalette(c(“siyah”, “kırmızı”, “turuncu”) gibi bir renk paleti fonksiyonu ile sağlayarak), belirtilenler arasında bir renk gradyanı oluşturulabilir.\n• Shapes (Şekiller) adlandırılmış bir liste ileterek, node_shape tarafından belirtilen satır listesi sütunundaki benzersiz öğe için bir şekil belirtilebilir. Kullanılabilir şekiller için codeawesome’bakın.\n• Size_range nodların boyut aralığını ileterek boyutlandırma.\nRengin sonucu, cinsiyetin şekli ve yaşın ise boyutu temsil ettiği bir örnek:","code":"\n## epicontacts nesnesi alt kümesi \nsub <- epic %>%\n  subset(\n    node_attribute = list(date_onset = c(as.Date(c(\"2014-06-30\", \"2014-06-01\"))))\n  ) %>%\n thin(\"contacts\")\n## epicontacts nesne grafiği\nplot(\n  sub,\n  width = 700,\n  height = 700\n)\nplot(\n  sub, \n  node_color = \"outcome\",\n  node_shape = \"gender\",\n  node_size = 'age',\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  shapes = c(f = \"female\", m = \"male\"),\n  size_range = c(40, 60),\n  height = 700,\n  width = 700\n)"},{"path":"iletim-zincirleri.html","id":"kenar-özelliklerinin-görselleştirilmesi","chapter":"37 İletim Zincirleri","heading":"Kenar özelliklerinin görselleştirilmesi","text":"Kenar rengi, genişliği ve çizgi tipi, edge_color, edge_width ve edge_linetype değişkenleri kullanılarak temasların veri çerçevesindeki belirli bir sütuna eşlenebilir. Kenarların belirli renkleri ve genişlikleri aşağıdaki gibi belirtilebilir:• Col_pal için kullanılanla aynı şekilde edge_col_pal aracılığıyla renkler.\n• Genişlik_aralığı argümanına nodların boyut aralığını ileterek genişlik belirlenirİşte bir örnek:","code":"\nplot(\n  sub, \n  node_color = \"outcome\",\n  node_shape = \"gender\",\n  node_size = 'age',\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  shapes = c(f = \"female\", m = \"male\"),\n  size_range = c(40, 60),\n  edge_color = 'location',\n  edge_linetype = 'location',\n  edge_width = 'duration',\n  edge_col_pal = c(Community = \"orange\", Nosocomial = \"purple\"),\n  width_range = c(1, 3),\n  height = 700,\n  width = 700\n)"},{"path":"iletim-zincirleri.html","id":"temporal-eksen","chapter":"37 İletim Zincirleri","heading":"Temporal eksen","text":"x_axis değişkeni satır listesindeki bir sütuna eşleyerek ağı zamansal bir eksen boyunca görselleştirebiliriz. Aşağıdaki örnekte, x ekseni, semptom başlangıç tarihini temsil eder. Ayrıca okların çok büyük olmamasını sağlamak için arrow_size (ok boyutu) değişkenini belirledik ve şekli daha az karmaşık hale getirmek için label değişkenini = YANLIŞ olarak ayarladık.Bu ağın zamansal bir eksen boyunca nasıl görselleştirildiğini daha ayrıntılı olarak göstermek için çok sayıda ek argüman vardır; bunları ?vis_temporal_interactive (bir epicontacts nesnesi üzerinde çizimi x_axis üzerinden belirtilen şekilde göstermek çağrılan fonkisyon) aracılığıyla inceleyebilirsiniz. Aşağıda bazılarını gözden geçireceğiz.","code":"\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)"},{"path":"iletim-zincirleri.html","id":"iletim-ağacı-şeklinin-belirlenmesi","chapter":"37 İletim Zincirleri","heading":"İletim ağacı şeklinin belirlenmesi","text":"Network_shape değişkeni kullanılarak belirtilen, iletim ağacının alabileceği iki ana şekil vardır. Birincisi, düz bir kenarın herhangi iki düğümü birleştirdiği, yukarıda gösterildiği gibi bir dallanma şeklidir. Bu en iyi anlaşılan temsildir, ancak yoğun bir şekilde bağlantılar içeren bir ağda üst üste binen kenarlara neden olabilir. İkinci şekil, bir filogenik ağaca benzeyen bir ağaç oluşturan dikdörtgendir. Örneğin:durum nodunda, position_dodge değişkeni değiştirilerek benzersiz bir dikey konum atanabilir. Bağlantısız vakaların konumu (yani, bildirilen herhangi bir kişi olmadan), unlinked_pos değişkeni kullanılarak belirtilir.Üst nodun alt nodlara göre konumu, ‘parent_pos’ değişkeni kullanılarak belirlenebilir. Varsayılan seçenek, üst nodu ortaya yerleştirmektir, ancak altta (parent_pos = ‘alt’) veya üstte (parent_pos = ‘üst’) yerleştirilebilir.","code":"\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  position_dodge = TRUE,\n  unlinked_pos = \"bottom\",\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  parent_pos = \"top\",\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)"},{"path":"iletim-zincirleri.html","id":"şekil-ve-grafiklerin-kaydedilmesi","chapter":"37 İletim Zincirleri","heading":"Şekil ve grafiklerin kaydedilmesi","text":"VisNetwork paketindeki ‘visSave’ fonksiyonuyla bir grafiği etkileşimli, bağımsız bir html dosyası olarak kaydedebilirsiniz:Bu ağ çıktılarını bir görüntü olarak kaydetmek ne yazık ki zordur ve dosyayı bir html olarak kaydetmenizi ve ardından ‘webshot’ paketini kullanarak bu dosyanın ekran görüntüsünü almanızı gerektirir. Aşağıdaki kodda, yukarıda kaydedilen html dosyasını PNG’ye dönüştürüyoruz:","code":"plot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  parent_pos = \"top\",\n  arrow_size = 0.5,\n  node_size = 13,\n\"\"  label = FALSE,\n  height = 700,\n  width = 700\n) %>%\n  visNetwork::visSave(\"network.html\")\nwebshot(url = \"network.html\", file = \"network.png\")"},{"path":"iletim-zincirleri.html","id":"zaman-çizelgeleri","chapter":"37 İletim Zincirleri","heading":"Zaman Çizelgeleri","text":"Ayrıca, bir vakanın x ekseninde temsil edildiği zaman çizelgeleri de verebilirsiniz. Zaman çizergeleri, vaka konumlarını veya sonuca ulaşma zamanını görselleştirmek için kullanılabilir. Bir zaman çizelgesi oluşturmak için, vaka kimliğini, “olay”ın başlangıç tarihini ve “olay”ın bitiş tarihini gösteren en az üç sütundan oluşan bir veri çerçevesi oluşturmamız gerekiyor. Ayrıca, zaman çizelgesinin nod ve kenar özelliklerine eşlenebilecek başka bir sütun da ekleyebilirsiniz. Aşağıdaki kodda, semptom başlangıcından sonuç tarihine kadar bir zaman çizelgesi oluşturuyoruz ve nod şeklini ve rengini tanımlamak için kullandığımız sonuç ve hastane değişkenlerini veri tabanımızda tutuyoruz. Örneğin, bir vaka birden fazla hastane arasında sevk ediliyorsa, vaka başına birden fazla zaman çizelgesi satırına/olayına sahip olabileceğinizi unutmayın.Daha sonra zaman çizelgesi öğesini ‘timeline’ değişkenine iletiriz. Zaman çizelgesi özniteliklerini zaman çizelgesi nod renklerine, şekillerine ve boyutlarına önceki bölümlerde tanımlandığı şekilde eşleyebiliriz, ancak iki nodumuz vardır: Bir zaman çizelgesinin ayrı ayrı değişkenleri olan başlangıç ve bitiş nodları. Örneğin, ‘tl_start_node_color’, hangi zaman çizelgesi sütununun başlangıç nodunun rengiyle eşlendiğini tanımlarken ‘tl_end_node_shape’, hangi zaman çizelgesi sütununun bitiş nodunun şekliyle eşlendiğini tanımlar. Ayrıca ’tl_edge_*’ değişkenleri aracılığıyla renk, genişlik, çizgi tipi ve etiketleri zaman çizelgesi kenarına eşleyebiliriz.Değişkenlerle ilgili ayrıntılı belgeler için ‘?vis_temporal_interactive’ e (bir epicontacts nesnesi çizilirken çağrılan fonksiyon) bakın. değişken aşağıdaki kodda da açıklanmıştır:","code":"\n## zaman çizelgesini oluştur\ntimeline <- linelist %>%\n  transmute(\n    id = case_id,\n    start = date_onset,\n    end = date_outcome,\n    outcome = outcome,\n    hospital = hospital\n  )\n## şekilleri tanımla\nshapes <- c(\n  f = \"female\",\n  m = \"male\",\n  Death = \"user-times\",\n  Recover = \"heartbeat\",\n  \"NA\" = \"question-circle\"\n)\n\n## renkleri tanımla\ncolours <- c(\n  Death = \"firebrick\",\n  Recover = \"green\",\n  \"NA\" = \"grey\"\n)\n\n## grafiği oluştur\nplot(\n  sub,\n  ## başlangıç tarihi için maksimum x koordinatı \n  x_axis = \"date_onset\",\n  ## dikdörtgen ağ şeklini kullan \n  network_shape = \"rectangle\",\n  ## nod şekillerini cinsiyet sütununa göre şekillendir \n  node_shape = \"gender\",\n  ## nod rengini herhangi bir sütun ile eşleştirmiyoruz çünkü varsayılan değeri id sütunudur bu da renk şemamızı bozar\n  node_color = NULL,\n  ## nod büyüklüğünü 30’a ayarla (nod büyüklüğü herhangi bir karakter değildir, herhangi bir sütuna eşleştirilmez, doğrudan nod büyüklüğü belirtilir\n  node_size = 30,\n  ## iletim bağlantısı kalınlığını 4’e ayarla (bu kalınlık bir karakter ile eşleşmemiştir) \n  edge_width = 4,\n  ## zaman çizelgesi nesnesi sağla \n  timeline = timeline,\n  ## bitiş nodunun şeklini zaman çizelgesi nesnesindeki sonuç sütununa eşle\n  tl_end_node_shape = \"outcome\",\n  ## son nodun boyutunu 15'e ayarla (bir karakter olmadığından, bu argüman bir sütuna eşlenmez, bunun yerine gerçek nod boyutu olarak yorumlanır)\n  tl_end_node_size = 15,\n  ## zaman çizelgesi kenarının rengini hastane sütununa eşle\n  tl_edge_color = \"hospital\",\n  ## zaman çizelgesi kenarının genişliğini 2'ye ayarla (bu bir karakter olmadığından, bu değişken bir sütuna eşlenmez, bunun yerine gerçek kenar genişliği olarak yorumlanır)\n  tl_edge_width = 2,\n  ## kenar etiketlerini hastane değişkenine eşleyin\n  tl_edge_label = \"hospital\",\n  ## nod şeklini belirt (yukarıda tanımlanmıştır)\n  shapes = shapes,\n  ## renk paletini belirt (yukarıda tanımlanmıştır)\n  col_pal = colours,\n  ## ok büyüklüğünü 0.5’e ayarla \n  arrow_size = 0.5,\n  ## lejantta iki sütun olsun \n  legend_ncol = 2,\n  ## font büyüklüğünü ayarla \n  font_size = 15,\n  ## tarih formatı ayarla \n  date_labels = c(\"%d %b %Y\"),\n  ## nodların altında ID etiketini grafik olarak gösterme\n  label = FALSE,\n  ## yüksekliği belirt \n  height = 1000,\n  ## genişliği belirt\n  width = 1200,\n  ## her vaka nodunun benzersiz bir y koordinatına sahip olduğundan emin olun - zaman çizelgelerini kullanırken bu çok önemlidir, aksi takdirde farklı vakalarda çakışan zaman çizelgeleriniz olur \n  position_dodge = TRUE\n)## Warning in assert_timeline(timeline, x, x_axis): 5865 timeline row(s) removed as ID not found in linelist or start/end\n## date is NA"},{"path":"iletim-zincirleri.html","id":"analiz","chapter":"37 İletim Zincirleri","heading":"37.5 Analiz","text":"","code":""},{"path":"iletim-zincirleri.html","id":"özetleme","chapter":"37 İletim Zincirleri","heading":"Özetleme","text":"‘summary’ fonkisyonunu kullanarak bazı ağ özelliklerine genel bir bakış elde edebiliriz.Örneğin, temaslıların yalnızca %57’sinin satır listesinde iki vakaya da sahip olduğunu görebiliriz. Bu iletim zincirlerine dahil olan önemli sayıda vaka hakkında linelist veriye sahip olmadığımız anlamına gelir.","code":"\n## epicontacts nesnesini özetle \nsummary(epic)## \n## /// Overview //\n##   // number of unique IDs in linelist: 5888\n##   // number of unique IDs in contacts: 5511\n##   // number of unique IDs in both: 4352\n##   // number of contacts: 3800\n##   // contacts with both cases in linelist: 56.868 %\n## \n## /// Degrees of the network //\n##   // in-degree summary:\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##  0.0000  0.0000  1.0000  0.5392  1.0000  1.0000 \n## \n##   // out-degree summary:\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##  0.0000  0.0000  0.0000  0.5392  1.0000  6.0000 \n## \n##   // in and out degree summary:\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##   0.000   1.000   1.000   1.078   1.000   7.000 \n## \n## /// Attributes //\n##   // attributes in linelist:\n##  generation date_infection date_onset date_hospitalisation date_outcome outcome gender age age_unit age_years age_cat age_cat5 hospital lon lat infector source wt_kg ht_cm ct_blood fever chills cough aches vomit temp time_admission bmi days_onset_hosp\n## \n##   // attributes in contacts:\n##  location duration"},{"path":"iletim-zincirleri.html","id":"çift-özellikleri","chapter":"37 İletim Zincirleri","heading":"Çift Özellikleri","text":"‘get_pairwise()’ fonkisyonu, temaslı veri kümesindeki bir çifte göre satır listesindeki değişken(ler)işlenmesine izin verir. Aşağıdaki örnekte, bir çift için hastalık başlangıç tarihi arasındaki farkı hesaplamak için, hastalık başlangıç tarihi satır listesinden çıkarılır. Bu karşılaştırmadan üretilen değer, seri aralığını (serial interval-si) temsil eder.‘get_pairwise()’, karşılaştırma için kullanılan sütunun sınıfını yorumlayacak ve buna göre değerleri karşılaştırma yöntemini ayarlayacaktır. Sayılar ve tarihler için (yukarıdaki si örneğinde olduğu gibi) fonksiyon, değerleri çıkaracaktır. Karakter içeren veya kategorik sütunlara uygulandığında, get_pairwise() fonksiyonu değerleri birbirine yapıştırır. Fonksiyon aynı zamanda keyfi işlemeye de izin verdiğinden (bkz. “f” değişkeni), bu ayrık kombinasyonlar kolayca tablo haline getirilebilir ve analiz edilebilir.Burada, iletim bağlantıları ve cinsiyet arasında önemli bir ilişki görüyoruz.","code":"\nsi <- get_pairwise(epic, \"date_onset\")   \nsummary(si)##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n##    0.00    5.00    9.00   11.01   15.00   99.00    1820\ntibble(si = si) %>%\n  ggplot(aes(si)) +\n  geom_histogram() +\n  labs(\n    x = \"Serial interval\",\n    y = \"Frequency\"\n  )## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.## Warning: Removed 1820 rows containing non-finite values (`stat_bin()`).\nhead(get_pairwise(epic, \"gender\"), n = 10)##  [1] \"f -> m\" NA       \"m -> m\" NA       \"m -> f\" \"f -> f\" NA       \"f -> m\" NA       \"m -> f\"\nget_pairwise(epic, \"gender\", f = table)##            values.to\n## values.from   f   m\n##           f 464 516\n##           m 510 468\nfisher.test(get_pairwise(epic, \"gender\", f = table))## \n##  Fisher's Exact Test for Count Data\n## \n## data:  get_pairwise(epic, \"gender\", f = table)\n## p-value = 0.03758\n## alternative hypothesis: true odds ratio is not equal to 1\n## 95 percent confidence interval:\n##  0.6882761 0.9892811\n## sample estimates:\n## odds ratio \n##  0.8252575"},{"path":"iletim-zincirleri.html","id":"kümelerin-tanımlanması","chapter":"37 İletim Zincirleri","heading":"Kümelerin tanımlanması","text":"get_clusters() fonksiyonu, bir epicontacts nesnesindeki bağlı bileşenleri tanımlamak için kullanılabilir. İlk olarak, küme bilgisini içeren bir veri çerçevesi elde etmek için kullanırız:En büyük kümelere bakalım. Bunun için epicontacts nesnesine küme bilgisi ekliyoruz ve ardından yalnızca en büyük kümeleri içerecek şekilde alt kümelerini oluşturuyoruz:","code":"\nclust <- get_clusters(epic, output = \"data.frame\")\ntable(clust$cluster_size)## \n##    1    2    3    4    5    6    7    8    9   10   11   12   13   14 \n## 1536 1680 1182  784  545  342  308  208  171  100   99   24   26   42\nggplot(clust, aes(cluster_size)) +\n  geom_bar() +\n  labs(\n    x = \"Cluster size\",\n    y = \"Frequency\"\n  )\nepic <- get_clusters(epic)\nmax_size <- max(epic$linelist$cluster_size)\nplot(subset(epic, cs = max_size))"},{"path":"iletim-zincirleri.html","id":"derecelerin-hesaplanması","chapter":"37 İletim Zincirleri","heading":"Derecelerin hesaplanması","text":"Bir nodun derecesi, kenar sayısına veya diğer nodlarla olan bağlantılarına karşılık gelir. ‘get_degree()’, epicontacts ağları için bu değeri hesaplamakta kolay bir yöntem sağlar. Bu bağlamda yüksek bir derece, başkalarıyla temas halinde olan bir kişiyi gösterir. ‘type’ değişkeni hem dereceyi hem de dereceyi saymak istediğimizi belirtir, ‘only_linelist’ değişkeni sadece satır listesindeki vakalar için dereceyi hesaplamak istediğimizi belirtir.Hangi kişiler en fazla temasa sahip?Ortalama temaslı sayısı nedir?","code":"\ndeg_both <- get_degree(epic, type = \"both\", only_linelist = TRUE)\nhead(sort(deg_both, decreasing = TRUE), 10)## 916d0a 858426 6833d7 f093ea 11f8ea 3a4372 38fc71 c8c4d5 a127a7 02d8fd \n##      7      6      6      6      5      5      5      5      5      5\nmean(deg_both)## [1] 1.078473"},{"path":"iletim-zincirleri.html","id":"kaynaklar-30","chapter":"37 İletim Zincirleri","heading":"37.6 Kaynaklar","text":"epicontacts page\nEpicontacts sayfası, paket fonksiyonlarına genel bir bakış sağlar ve bazı daha ayrıntılı gösterimler içerir.github page\nGithub sayfası, sorunları dile getirmek ve yeni özellikler talep etmek için kullanılabilir.","code":""},{"path":"filogenetik-ağaçlar-1.html","id":"filogenetik-ağaçlar-1","chapter":"38 Filogenetik ağaçlar","heading":"38 Filogenetik ağaçlar","text":"","code":""},{"path":"filogenetik-ağaçlar-1.html","id":"genel-bakış-8","chapter":"38 Filogenetik ağaçlar","heading":"38.1 Genel Bakış","text":"Filogenetik ağaçlar, organizmaların genetik kodlarının sekansına göre akrabalıklarını ve evrimlerini görselleştirmek ve tanımlamak için kullanılır.\nUzaklığa dayalı yöntemler (komşu birleştirme yöntemi gibi) veya karakter tabanlı yöntemler (maksimum olabilirlik ve Bayesian Markov Zinciri Monte Carlo yöntemi gibi) kullanılarak genetik sekanslardan oluşturulabilirler. Yeni nesil sekanslama (NGS) daha uygun fiyatlı hale gelerek bulaşıcı hastalıklara neden olan patojenleri tanımlamak için halk sağlığında daha yaygın olarak kullanılmaya başlandı. Taşınabilir sekanslama cihazları, bekleme süresini azaltır ve verileri gerçek zamanlı olarak salgın araştırmasını desteklemek için kullanılabilir hale getirir. NGS verileri, bir salgın suşunun kökenini, kaynağını ve yayılımını belirlemek ve ayrıca antimikrobiyal direnç genlerinin varlığını göstermek için kullanılabilir. Örnekler arasındaki genetik ilişkiyi görselleştirmek için bir filogenetik ağaç oluşturulur.\nBu sayfada, filogenetik ağaçların bir veri çerçevesiyle birleştirilmiş halde görselleştirilmesine izin veren ggtree paketinin nasıl kullanılacağını öğreneceğiz. Bu, motifleri gözlemlememizi ve salgın dinamiğinin anlaşılmasını geliştirmemizi sağlayacaktır.","code":""},{"path":"filogenetik-ağaçlar-1.html","id":"hazırlık-31","chapter":"38 Filogenetik ağaçlar","heading":"38.2 Hazırlık","text":"","code":""},{"path":"filogenetik-ağaçlar-1.html","id":"paketlerin-yüklenmesi-6","chapter":"38 Filogenetik ağaçlar","heading":"Paketlerin yüklenmesi","text":"Bu kod parçası, gerekli paketlerin yüklenmesini göstermektedir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’ın p_load() fonksiyonunu vurguluyoruz. Ayrıca, temel R’dan library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R’ın temelleri sayfasına bakın.","code":"\npacman::p_load(\n  rio,             # içe/dışa aktarım \n  here,            # ilişkili dosya yolları\n  tidyverse,       # genel veri yönetimi ve görselleştirme\n  ape,             # filogenetik dosyaları içe ve dışa aktarmak için\n  ggtree,          # filogenetik dosyaları görselleştirmek için\n  treeio,          # filogenetik dosyaları görselleştirmek için\n  ggnewscale)      # ek renk şema katmanları eklemek için"},{"path":"filogenetik-ağaçlar-1.html","id":"verilerin-içe-aktarımı","chapter":"38 Filogenetik ağaçlar","heading":"Verilerin içe aktarımı","text":"Bu sayfadaki veriler, El kitabı ve verilerin indirilmesi sayfasındaki talimatlarla indirilebilir.Bir filogenetik ağacın saklanabileceği birkaç farklı format vardır (örn. Newick, NEXUS, Phylip). Yaygın olanlardan biri, ağaçların bilgisayar tarafından okunabilir biçimde gösterimi için standart olan Newic dosya biçimidir (.nwk).Bu, tüm ağacın “((t2:0.04,t1:0.34):0.89,(t5:0.37,(t4:0.03,t3:0.67):0.9):0.59);” gibi bir dize biçiminde ifade edilebileceği anlamına gelir. Bu dize tüm nodları ve uçları ve bunların birbirleriyle olan ilişkilerini (dal uzunluğu) listeler.: Filogenetik ağaç dosyasının kendi içinde sekans verileri içermediğini, yalnızca sekanslar arasındaki genetik mesafelerin bir sonucu olduğunu anlamak önemlidir. Bu nedenle, bir ağaç dosyasından sekanslama verilerini çıkaramıyoruz.İlk olarak, bir Newick filogenetik ağaç dosyasını .txt formatında içe aktarmak için ape paketinden read.tree() fonksiyonunu kullanırız ve “phylo” sınıfı bir liste nesnesinde saklarız. Gerekirse, ilgili dosya yolunu belirtmek için paketindeki () fonksiyonunu kullanın.: Bu durumda newick ağacı, Github’dan daha kolay kullanım ve indirme için bir .txt dosyası olarak kaydedilir.Ağaç nesnemizi inceliyoruz ve 299 uç (veya örnek) ve 236 nod içerdiğini görüyoruz.İkinci olarak, rio paketindeki import() fonksiyonunu kullanarak cinsiyet, menşe ülke ve antimikrobiyal direnç özellikleri gibi numune için ek bilgiler içeren bir .csv dosyası olarak saklanan tabloyu içe aktarırız:Aşağıda verilerin ilk 50 satırı verilmiştir:","code":"\ntree <- ape::read.tree(\"Shigella_tree.txt\")\ntree## \n## Phylogenetic tree with 299 tips and 236 internal nodes.\n## \n## Tip labels:\n##   SRR5006072, SRR4192106, S18BD07865, S18BD00489, S17BD08906, S17BD05939, ...\n## Node labels:\n##   17, 29, 100, 67, 100, 100, ...\n## \n## Rooted; includes branch lengths.\nsample_data <- import(\"sample_data_Shigella_tree.csv\")"},{"path":"filogenetik-ağaçlar-1.html","id":"temizleme-ve-inceleme","chapter":"38 Filogenetik ağaçlar","heading":"Temizleme ve inceleme","text":"Verilerimizi temizler ve inceleriz: Filogenetik ağaca doğru örnek verilerini atamak için, sample_data veri çerçevesindeki Sample_ID sütunundaki değerlerin ağaç dosyasındaki tip.labels değerleriyle eşleşmesi gerekir:Ağaç dosyasındaki tip.labels formatını, R tabanından head() ile ilk 6 girişe bakarak kontrol ederiz.Ayrıca sample_data veri çerçevemizdeki ilk sütunun Sample_ID olduğundan emin oluruz. Temel R’dan colnames() kullanarak veri çerçevemizin sütun adlarına bakarız.Biçimlendirmenin tip.label’dekiyle aynı olduğundan emin olmak için veri çerçevesindeki Sample_ID’lere bakarız (örneğin, harflerin tümü büyük harf olması, harfler ve sayılar arasında fazladan alt çizgi olmaması, vb.)Ayrıca tüm örneklerin ağaç dosyasında bulunup bulunmadığını, eşleşip eşleşmedikleri bir DOĞRU veya YANLIŞ mantıksal vektörü oluşturarak karşılaştırabiliriz. (Basitleştirmek için burada gösterilmemiştir).Bu vektörleri ağaçta olmayan herhangi bir örnek kimliğini göstermek için kullanabiliriz (hiçbiri yoktur).İnceleme sonucu, veri çerçevesindeki Sample_ID formatının tip.labels’deki örnek isimlerine karşılık geldiğini görebiliriz. Bunların eşleşmesi için aynı sırada sıralanması gerekmez.Devam etmeye hazırız!","code":"\nhead(tree$tip.label) ## [1] \"SRR5006072\" \"SRR4192106\" \"S18BD07865\" \"S18BD00489\" \"S17BD08906\" \"S17BD05939\"\ncolnames(sample_data)   ##  [1] \"Sample_ID\"                  \"serotype\"                   \"Country\"                   \n##  [4] \"Continent\"                  \"Travel_history\"             \"Year\"                      \n##  [7] \"Belgium\"                    \"Source\"                     \"Gender\"                    \n## [10] \"gyrA_mutations\"             \"macrolide_resistance_genes\" \"MIC_AZM\"                   \n## [13] \"MIC_CIP\"\nhead(sample_data$Sample_ID) # we again inspect only the first 6 using head()## [1] \"S17BD05944\" \"S15BD07413\" \"S18BD07247\" \"S19BD07384\" \"S18BD07338\" \"S18BD02657\"\nsample_data$Sample_ID %in% tree$tip.label\n\ntree$tip.label %in% sample_data$Sample_ID\nsample_data$Sample_ID[!tree$tip.label %in% sample_data$Sample_ID]## character(0)"},{"path":"filogenetik-ağaçlar-1.html","id":"temel-ağaç-görselleştirmesi","chapter":"38 Filogenetik ağaçlar","heading":"38.3 Temel ağaç görselleştirmesi","text":"","code":""},{"path":"filogenetik-ağaçlar-1.html","id":"farklı-ağaç-düzenlemeleri","chapter":"38 Filogenetik ağaçlar","heading":"Farklı ağaç düzenlemeleri","text":"ggtree birçok farklı düzen formatı sunar ve bazıları özel amacınız için diğerlerinden daha uygun olabilir. Aşağıda birkaç gösterim var. Diğer seçenekler için bu çevrimiçi kitaba bakabilirsiniz.İşte bazı örnek ağaç düzenleri:","code":"\nggtree(tree)                                            # basit doğrusal ağaç\nggtree(tree, branch.length = \"none\")                    # uçların hizalandığı basit doğrusal ağaç \nggtree(tree, layout=\"circular\")                         # basit dairesel ağaç\nggtree(tree, layout=\"circular\", branch.length = \"none\") # uçların hizalandığı basit dairesel ağaç "},{"path":"filogenetik-ağaçlar-1.html","id":"örnek-veriyi-içeren-basit-ağaç","chapter":"38 Filogenetik ağaçlar","heading":"Örnek veriyi içeren basit ağaç","text":"%<+% operatörü, sample_data veri çerçevesini ağaç dosyasına bağlamak için kullanılır. Ağacınızın en basit gösterimi, uçlara örnek isimlerin eklenmesi, ayrıca uç noktalarının ve istenirse dalların renklendirilmesidir:İşte dairesel bir ağaç örneği:Diğer herhangi bir ggplot nesnesinde yaptığınız gibi, ağaç grafiğinizi ggsave() ile dışa aktarabilirsiniz. Bu şekilde yazıldığında, ggsave(), üretilen son grafiği belirttiğiniz dosya yoluna kaydeder. Alt klasörlere vb. kolayca kaydetmek için () ve ilgili dosya yollarını kullanabileceğinizi unutmayın.","code":"\nggtree(tree, layout = \"circular\", branch.length = 'none') %<+% sample_data + #%<+%, ağaca örnek verilerle veri çerçevesi ekler\n  aes(color = I(Belgium))+                       # dalları veri çerçevenizdeki bir değişkene göre renklendirin\n  scale_color_manual(\n    name = \"Sample Origin\",                      # renk düzeninizin adı (lejantta bu şekilde görünecektir)\n    breaks = c(\"Yes\", \"No\"),                     # değişkeninizdeki farklı seçenekler\n    labels = c(\"NRCSS Belgium\", \"Other\"),        # lejandınızda adı geçen farklı seçenekleri biçimlendirmenize olanak sağlar\n    values = c(\"blue\", \"black\"),                  # değişkene atamak istediğiniz renk\n    na.value = \"black\") +                        # renkli NA değerleri siyahtır\n  new_scale_color()+                             # başka bir değişken için ek bir renk şeması eklemeye izin verir\n  geom_tippoint(\n      mapping = aes(color = Continent),          # kıtaya göre uç rengi. \"shape =\" ekleyerek şekli değiştirebilirsiniz.\n      size = 1.5)+                               # uçtaki noktanın boyutunu tanımlayın\n  scale_color_brewer(\n    name = \"Continent\",                    # renk şemanızın adı (lejantta bu şekilde görünecektir)\n    palette = \"Set1\",                      # brewer paketiyle birlikte gelen bir dizi renk seçiyoruz\n    na.value = \"grey\") +                    # NA değerleri için gri rengi seçiyoruz\n  geom_tiplab2(                             # dalının ucuna numunenin adını ekler\n    color = 'black',                       # (+ ile istediğiniz kadar metin satırı ekleyin, ancak bunları yan yana yerleştirmek için ofset değerini ayarlamanız gerekebilir)\n    offset = 1,\n    size = 1,\n    geom = \"text\",\n    #align = TRUE\n    )+    \n  ggtitle(\"Phylogenetic tree of Shigella sonnei\")+       # grafiğinizin başlığı\n  theme(\n    axis.title.x = element_blank(), # x ekseni başlığını kaldırır\n    axis.title.y = element_blank(), # y ekseni başlığını kaldırır\n    legend.title = element_text(    # açıklama başlığının yazı tipi boyutunu ve biçimini tanımlar\n      face = \"bold\",\n      size = 12),   \n    legend.text=element_text(       # gösterge metninin yazı tipi boyutunu ve biçimini tanımlar\n      face = \"bold\",\n      size = 10),  \n    plot.title = element_text(      # grafik başlığının yazı tipi boyutunu ve biçimini tanımlar\n      size = 12,\n      face = \"bold\"),  \n    legend.position = \"bottom\",     # lejant yerleşimini tanımlar\n    legend.box = \"vertical\",        # lejant yerleşimini tanımlar\n    legend.margin = margin())   \nggsave(\"example_tree_circular_1.png\", width = 12, height = 14)"},{"path":"filogenetik-ağaçlar-1.html","id":"ağacın-manipülasyonu","chapter":"38 Filogenetik ağaçlar","heading":"38.4 Ağacın Manipülasyonu","text":"Bazen çok büyük bir filogenetik ağacınız olabilir ve ağacın sadece bir kısmıyla ilgilenirsiniz. Örneğin, veri kümenizin büyük resimde nereye sığabileceğine dair geniş bir genel bakış elde etmek için tarihsel veya uluslararası örnekler içeren bir ağaç oluşturup daha sonra verilerinize daha yakından bakmak için daha büyük olan ağacın yalnızca o ilgilendiğiniz kısmını incelemek istersiniz.Filogenetik ağaç dosyası yalnızca sekanslama veri analizinin çıktısı olduğundan, dosyanın kendisindeki nodların ve dalların sırasını değiştiremeyiz. Bunlar, ham NGS verilerinden önceki analizlerde zaten belirlenmiştir. Yine de parçaları yakınlaştırabiliyor, parçaları gizleyebiliyor ve hatta ağacın parçalarını alt kümelere ayırabiliyoruz.","code":""},{"path":"filogenetik-ağaçlar-1.html","id":"yakınlaştırmak","chapter":"38 Filogenetik ağaçlar","heading":"Yakınlaştırmak","text":"Ağacınızı “kesmek” istemiyorsanız ve sadece bir kısmını daha yakından incelemek istiyorsanız, belirli bir kısmı görüntülemek için yakınlaştırabilirsiniz.İlk olarak, tüm ağacı doğrusal biçimde çiziyoruz ve ağaçtaki bir noda sayısal etiketler ekliyoruz.Belirli bir dalı yakınlaştırmak için (sağa doğru uzanarak), ggtree p nesnesinde viewClade() fonkisyonunu kullanın ve daha yakından bakmak için nod numarasını sağlayın:","code":"\np <- ggtree(tree,) %<+% sample_data +\n  geom_tiplab(size = 1.5) +                # ağaç dosyasındaki örnek adıyla tüm dalların uçlarını etiketler\n  geom_text2(\n    mapping = aes(subset = !isTip,\n                  label = node),\n    size = 5,\n    color = \"darkred\",\n    hjust = 1,\n    vjust = 1)                            # ağaçtaki tüm nodları etiketler\n\np  # çıktı alın\nviewClade(p, node = 452)"},{"path":"filogenetik-ağaçlar-1.html","id":"daralan-dallar","chapter":"38 Filogenetik ağaçlar","heading":"Daralan dallar","text":"Ancak, bu dalı yok saymak isteyebiliriz ve aynı noddaki (nod nr. 452) collapse() fonksiyonunu kullanarak dalı daraltabiliriz. Bu ağaç p_collapsed olarak tanımlanır.Anlaşılır olması için, p_collapsed’ı yazdırdığımızda, daraltılmış dalın noduna geom_point2() ile mavi elmas şekli ekleriz.","code":"\np_collapsed <- collapse(p, node = 452)\np_collapsed\np_collapsed + \ngeom_point2(aes(subset = (node == 452)),  # we assign a symbol to the collapsed node\n            size = 5,                     # define the size of the symbol\n            shape = 23,                   # define the shape of the symbol\n            fill = \"steelblue\")           # define the color of the symbol## Warning in geom_point(stroke = stroke, shape = shape, ...): Ignoring unknown aesthetics: subset## Warning: Removed 83 rows containing missing values (`geom_point()`)."},{"path":"filogenetik-ağaçlar-1.html","id":"ağacın-alt-kümelere-ayrılması","chapter":"38 Filogenetik ağaçlar","heading":"Ağacın alt kümelere ayrılması","text":"Daha kalıcı bir değişiklik yapmak ya da çalışma için yeni ve küçültülmüş bir ağaç oluşturmak istiyorsak, ağacın bir kısmının tree_subset() ile alt kümesini alabiliriz. Ardından bu alt kümeyi yeni bir newick ağaç dosyası veya .txt dosyası olarak kaydedebilirsiniz.İlk olarak, neyin altküme olacağına karar vermek için ağaç nodlarını ve uç etiketlerini inceleriz.Şimdi, ağacın 528 numaralı nodundan alt küme oluşturmaya karar verdiğimizi varsayalım (sadece bu dalda 528 nodundan sonraki uçlarını tutalım) ve onu yeni bir sub_tree1 nesnesi olarak kaydedelim:1 numaralı alt küme ağacına bir göz atalım:Ayrıca, “geriye” kaç tane nod eklemek istediğinizi belirterek belirli bir örneğe dayalı olarak alt kümeler oluşturabilirsiniz. Ağacın aynı kısmını bir örneğe dayanarak alt kümelendirelim, bu durumda S17BD07692 için 9 nod geriye giderek ve onu yeni bir sub_tree2 nesnesi olarak kaydedelim:Şimdi alt küme ağacına bir göz atalım:Yeni ağacınızı, ape paketindeki write.tree() fonksiyonunu kullanarak bir Newick formatında veya hatta bir metin dosyası olarak da kaydedebilirsiniz","code":"\nggtree(\n  tree,\n  branch.length = 'none',\n  layout = 'circular') %<+% sample_data +               # %<+% operatörünü kullanarak örnek verileri ekliyoruz\n  geom_tiplab(size = 1)+                                # ağaç dosyasında örnek adıyla tüm dalların uçlarını etiketliyoruz \n  geom_text2(\n    mapping = aes(subset = !isTip, label = node),\n    size = 3,\n    color = \"darkred\") +                                # ağaçtaki tüm nodları etiketler\n theme(\n   legend.position = \"none\",                            # lejantı uzaklaştırır\n   axis.title.x = element_blank(),\n   axis.title.y = element_blank(),\n   plot.title = element_text(size = 12, face=\"bold\"))\nsub_tree1 <- tree_subset(\n  tree,\n  node = 528)                                            # ağacın 528 nodundan alt kümesini oluşturuyoruz\nggtree(sub_tree1) +\n  geom_tiplab(size = 3) +\n  ggtitle(\"Subset tree 1\")\nsub_tree2 <- tree_subset(\n  tree,\n  \"S17BD07692\",\n  levels_back = 9) # geri seviye sayısı, örnek ucundan geriye kaç nod gideceğinizi tanımlar.\nggtree(sub_tree2) +\n  geom_tiplab(size =3)  +\n  ggtitle(\"Subset tree 2\")\n# .nwk formatında kaydetmek için\nape::write.tree(sub_tree2, file='data/phylo/Shigella_subtree_2.nwk')\n\n# .txt formatında kaydetmek için\nape::write.tree(sub_tree2, file='data/phylo/Shigella_subtree_2.txt')"},{"path":"filogenetik-ağaçlar-1.html","id":"ağaçtaki-nodları-döndürmek","chapter":"38 Filogenetik ağaçlar","heading":"Ağaçtaki nodları döndürmek","text":"Daha önce de belirtildiği gibi, ağaçtaki uçların veya nodların sırasını değiştiremeyiz, çünkü bu onların genetik akrabalıklarına dayanır ve görsel manipülasyona izin yoktur. Ancak, görselleştirmemizi kolaylaştıracaksa, dalları nodların etrafında döndürebiliriz.İlk olarak, işlemek istediğimiz nodu seçmek için yeni alt küme ağacımızı (alt küme 2) nod etiketleriyle çizeriz ve bir ggtree çizim nesnesi ‘p’ olarak saklarız.Ardından, ggtree::rotate() veya ggtree::flip() fonksiyonlarını uygulayarak nodları değiştirebiliriz: : Hangi nodları manuple ettiğimizi göstermek için, ilgilendiğimiz noddaki örnekleri vurgulamak için önce ggtree’den geom_hilight() fonksiyonunu uygularız. ggtree çizim nesnesini yeni bir nesne olarak (p1) saklayın.Şimdi p1 nesnesindeki nod 37’yi döndürebiliriz, böylece nod 38’deki örnekler en üste hareket eder. Döndürülen ağacı yeni bir p2 nesnesi olarak saklıyoruz.Ya da p1 nesnesindeki 36 nolu nodu döndürmek ve 37 nolu nodu yukarı ve 39 nolu nodu aşağıya çevirmek için flip (çevirme= komutunu kullanabiliriz. Ters çevrilmiş ağacı yeni bir p3 nesnesi olarak saklıyoruz.","code":"\np <- ggtree(sub_tree2) +  \n  geom_tiplab(size = 4) +\n  geom_text2(aes(subset=!isTip, label=node), # ağaçtaki tüm nodları etiketler\n             size = 5,\n             color = \"darkred\", \n             hjust = 1, \n             vjust = 1) \np\np1 <- p + geom_hilight(  # nod 39'u mavi olarak vurgular, \"extend =\" renk bloğunun uzunluğunu tanımlamamızı sağlar\n  node = 39,\n  fill = \"steelblue\",\n  extend = 0.0017) +  \ngeom_hilight(            # 37 numaralı düğümü sarı renkle vurgular\n  node = 37,\n  fill = \"yellow\",\n  extend = 0.0017) +               \nggtitle(\"Original tree\")\n\n\np1 # çıktı alın\np2 <- ggtree::rotate(p1, 37) + \n      ggtitle(\"Rotated Node 37\")\n\n\np2   # çıktı alın\np3 <-  flip(p1, 39, 37) +\n      ggtitle(\"Rotated Node 36\")\n\n\np3   # çıktı alın"},{"path":"filogenetik-ağaçlar-1.html","id":"numune-verilerini-içeren-açıklamalı-örnek-alt-ağaç","chapter":"38 Filogenetik ağaçlar","heading":"Numune verilerini içeren açıklamalı örnek alt ağaç","text":"2017 ve 2018’de alt ağacımızda 39. nodda meydana gelen klonal genişlemeli vaka kümesini araştırdığımızı varsayalım. Yakın ilişkili diğer suşların kökenini görmek için suş izolasyonunun yanı sıra ülkeye göre seyahat geçmişi ve rengi de ekliyoruz:Gözlemimiz, yıllar içinde Belçika’da dolaşan ve en son salgınımıza neden olan Asya’dan kaynaklanan suşa işaret ediyor.","code":"\nggtree(sub_tree2) %<+% sample_data +     # sample_data'ya bağlanmak için %<+% operatörünü kullanırız\n  geom_tiplab(                          # ağaç dosyasındaki numune adıyla tüm dalların uçlarını etiketler\n    size = 2.5,\n    offset = 0.001,\n    #align = TRUE\n    ) + \n  theme_tree2()+\n  xlim(0, 0.015)+                       # ağacımızın x ekseni sınırlarını ayarlar\n  geom_tippoint(aes(color=Country),     # uç noktasını kıtaya göre renklendir\n                size = 1.5)+ \n  scale_color_brewer(\n    name = \"Country\", \n    palette = \"Set1\", \n    na.value = \"grey\")+\n  geom_tiplab(                          # uçlara bir metin etiketi olarak izolasyon yılı ekleyin\n    aes(label = Year),\n    color = 'blue',\n    offset = 0.0045,\n    size = 3,\n    linetype = \"blank\" ,\n    geom = \"text\",\n    #align = TRUE\n    )+ \n  geom_tiplab(                          # uçlara kırmızı renkte bir metin etiketi olarak seyahat geçmişi ekleyin\n    aes(label = Travel_history),\n    color = 'red',\n    offset = 0.006,\n    size = 3,\n    linetype = \"blank\",\n    geom = \"text\",\n    #align = TRUE\n    )+ \n  ggtitle(\"Phylogenetic tree of Belgian S. sonnei strains with travel history\")+  # grafik başlığı ekle\n  xlab(\"genetic distance (0.001 = 4 nucleotides difference)\")+                    # x eksenine bir etiket ekleyin\n  theme(\n    axis.title.x = element_text(size = 10),\n    axis.title.y = element_blank(),\n    legend.title = element_text(face = \"bold\", size = 12),\n    legend.text = element_text(face = \"bold\", size = 10),\n    plot.title = element_text(size = 12, face = \"bold\"))"},{"path":"filogenetik-ağaçlar-1.html","id":"daha-karmaşık-ağaçlar-örnek-verilerin-ısı-haritalarını-ekleme","chapter":"38 Filogenetik ağaçlar","heading":"Daha karmaşık ağaçlar: Örnek verilerin ısı haritalarını ekleme","text":"ggtree::gheatmap() fonksiyonunu kullanarak bir ısı haritası biçiminde antimikrobiyal direnç genlerinin kategorik olarak varlığı ve antimikrobiyallere karşı ölçülen direnç için sayısal değerler gibi daha karmaşık bilgiler de ekleyebiliriz.İlk önce ağacımızı çizmemiz gerekiyor (bu doğrusal veya dairesel olabilir) ve ağacı yeni bir ggtree çizim nesnesi p’de saklamamız gerekiyor: Bölüm 3’teki sub_tree’yi kullanacağız.)İkinci olarak verilerimizi hazırlıyoruz. Farklı değişkenleri yeni renk şemaları ile görselleştirmek için veri çerçevemizi istenen değişkene göre alt gruplara ayırıyoruz. Sample_ID’yi satır adları olarak eklemek önemlidir, aksi takdirde verileri ağaç tip.labels ile eşleştiremez:Örneğimizde Shigella enfeksiyonlarını tedavi etmek için kullanılan önemli bir birinci basamak antibiyotik olan siprofloksasine direnç kazandırabilecek mutasyonlara ve cinsiyete bakmak istiyoruz.Cinsiyet için bir veri çerçevesi oluşturuyoruz:Siprofloksasin direncine nede olan gyrA genindeki mutasyonlar için bir veri çerçevesi oluşturuyoruz:Siprofloksasin için ölçülen minimum inhibitör konsantrasyonu (MIC) için bir veri çerçevesi oluşturuyoruz:Filogenetik ağaca cinsiyet için ikili bir ısı haritası ekleyen ve onu yeni bir ggtree grafi nesnesi h1’de saklayan bir ilk grafik oluşturuyoruz:Ardından, gyrA genindeki siprofloksasine direnç sağlayan mutasyonlar hakkında bilgi ekliyoruz:: WGS verilerinde kromozomal nokta mutasyonlarının varlığı, Zankari ve arkadaşları tarafından geliştirilen PointFinder aracı kullanılarak önceden belirlenmiştir. (referanslar bölümündeki referansa bakın)İlk olarak, mevcut çizim nesnemiz h1’e yeni bir renk şeması atarız ve onu nesne h2’de saklarız. Bu, ısı haritasındaki ikinci değişkenimizin renklerini tanımlamamızı ve değiştirmemizi sağlar.Ardından ikinci ısı haritası katmanını h2’ye ekler ve birleştirilmiş grafikleri yeni bir nesne h3’te saklarız:İlk önce mevcut nesne h3’e yeni bir renk ölçeği katmanı ekleyerek ve ardından nihai nesne h5’üretmek için elde edilen h4 nesnesine suş için siprofloksasin için minimum inhibitör konsantrasyonu (MIC) verilerini ekleyerek yukarıdaki işlemi tekrarlıyoruz. :Aynı alıştırmayı doğrusal bir ağaç için de yapabiliriz:Öncelikle cinsiyeti giriyoruzArdından, başka bir renk şeması katmanı ekledikten sonra siprofloksasine direnç mutasyonlarını ekliyoruz:Ardından laboratuvar tarafından belirlenen minimum engelleyici konsantrasyonu (MIC) ekliyoruz:","code":"\np <- ggtree(sub_tree2, branch.length='none', layout='circular') %<+% sample_data +\n geom_tiplab(size =3) + \n theme(\n   legend.position = \"none\",\n    axis.title.x = element_blank(),\n    axis.title.y = element_blank(),\n    plot.title = element_text(\n      size = 12,\n      face = \"bold\",\n      hjust = 0.5,\n      vjust = -15))\np\ngender <- data.frame(\"gender\" = sample_data[,c(\"Gender\")])\nrownames(gender) <- sample_data$Sample_ID\ncipR <- data.frame(\"cipR\" = sample_data[,c(\"gyrA_mutations\")])\nrownames(cipR) <- sample_data$Sample_ID\nMIC_Cip <- data.frame(\"mic_cip\" = sample_data[,c(\"MIC_CIP\")])\nrownames(MIC_Cip) <- sample_data$Sample_ID\nh1 <-  gheatmap(p, gender,                                 # ağaç grafiğimize cinsiyet veri çerçevesinin ısı haritası katmanını ekliyoruz\n                offset = 10,                               # ofset, ısı haritasını sağa kaydırır,\n                width = 0.10,                              # genişlik, ısı haritası sütununun genişliğini tanımlar,\n                color = NULL,                              # renk, ısı haritası sütunlarının kenarlığını tanımlar\n         colnames = FALSE) +                               # ısı haritası için sütun adlarını gizler\n  scale_fill_manual(name = \"Gender\",                       # cinsiyet için renklendirme şemasını ve lejandı tanımlayın\n                    values = c(\"#00d1b1\", \"purple\"),\n                    breaks = c(\"Male\", \"Female\"),\n                    labels = c(\"Male\", \"Female\")) +\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())## Scale for y is already present.\n## Adding another scale for y, which will replace the existing scale.\n## Scale for fill is already present.\n## Adding another scale for fill, which will replace the existing scale.\nh1\nh2 <- h1 + new_scale_fill() \nh3 <- gheatmap(h2, cipR,         # Siprofloksasine direnç mutasyonlarını tanımlayan ikinci ısı haritası satırını ekler\n               offset = 12, \n               width = 0.10, \n               colnames = FALSE) +\n  scale_fill_manual(name = \"Ciprofloxacin resistance \\n conferring mutation\",\n                    values = c(\"#fe9698\",\"#ea0c92\"),\n                    breaks = c( \"gyrA D87Y\", \"gyrA S83L\"),\n                    labels = c( \"gyrA d87y\", \"gyrA s83l\")) +\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())+\n  guides(fill = guide_legend(nrow = 2,byrow = TRUE))## Scale for y is already present.\n## Adding another scale for y, which will replace the existing scale.\n## Scale for fill is already present.\n## Adding another scale for fill, which will replace the existing scale.\nh3\n# İlk önce yeni renklendirme şemasını ekliyoruz:\nh4 <- h3 + new_scale_fill()\n\n# sonra ikisini yeni bir grafikte birleştiriyoruz:\nh5 <- gheatmap(h4, MIC_Cip,  \n               offset = 14, \n               width = 0.10,\n                colnames = FALSE)+\n  scale_fill_continuous(name = \"MIC for Ciprofloxacin\",  # burada MIC'in sürekli değişkeni için bir gradyan renk şeması tanımlıyoruz\n                      low = \"yellow\", high = \"red\",\n                      breaks = c(0, 0.50, 1.00),\n                      na.value = \"white\") +\n   guides(fill = guide_colourbar(barwidth = 5, barheight = 1))+\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())## Scale for y is already present.\n## Adding another scale for y, which will replace the existing scale.\n## Scale for fill is already present.\n## Adding another scale for fill, which will replace the existing scale.\nh5\np <- ggtree(sub_tree2) %<+% sample_data +\n  geom_tiplab(size = 3) + # labels the tips\n  theme_tree2()+\n  xlab(\"genetic distance (0.001 = 4 nucleotides difference)\")+\n  xlim(0, 0.015)+\n theme(legend.position = \"none\",\n      axis.title.y = element_blank(),\n      plot.title = element_text(size = 12, \n                                face = \"bold\",\n                                hjust = 0.5,\n                                vjust = -15))\np\nh1 <-  gheatmap(p, gender, \n                offset = 0.003,\n                width = 0.1, \n                color=\"black\", \n         colnames = FALSE)+\n  scale_fill_manual(name = \"Gender\",\n                    values = c(\"#00d1b1\", \"purple\"),\n                    breaks = c(\"Male\", \"Female\"),\n                    labels = c(\"Male\", \"Female\"))+\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())## Scale for y is already present.\n## Adding another scale for y, which will replace the existing scale.\n## Scale for fill is already present.\n## Adding another scale for fill, which will replace the existing scale.\nh1\nh2 <- h1 + new_scale_fill()\nh3 <- gheatmap(h2, cipR,   \n               offset = 0.004, \n               width = 0.1,\n               color = \"black\",\n                colnames = FALSE)+\n  scale_fill_manual(name = \"Ciprofloxacin resistance \\n conferring mutation\",\n                    values = c(\"#fe9698\",\"#ea0c92\"),\n                    breaks = c( \"gyrA D87Y\", \"gyrA S83L\"),\n                    labels = c( \"gyrA d87y\", \"gyrA s83l\"))+\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())+\n  guides(fill = guide_legend(nrow = 2,byrow = TRUE))## Scale for y is already present.\n## Adding another scale for y, which will replace the existing scale.\n## Scale for fill is already present.\n## Adding another scale for fill, which will replace the existing scale.\n h3\nh4 <- h3 + new_scale_fill()\nh5 <- gheatmap(h4, MIC_Cip, \n               offset = 0.005,  \n               width = 0.1,\n               color = \"black\", \n                colnames = FALSE)+\n  scale_fill_continuous(name = \"MIC for Ciprofloxacin\",\n                      low = \"yellow\", high = \"red\",\n                      breaks = c(0,0.50,1.00),\n                      na.value = \"white\")+\n   guides(fill = guide_colourbar(barwidth = 5, barheight = 1))+\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 10),\n        legend.text = element_text(size = 8),\n        legend.box = \"horizontal\", legend.margin = margin())+\n  guides(shape = guide_legend(override.aes = list(size = 2)))## Scale for y is already present.\n## Adding another scale for y, which will replace the existing scale.\n## Scale for fill is already present.\n## Adding another scale for fill, which will replace the existing scale.\nh5"},{"path":"filogenetik-ağaçlar-1.html","id":"kaynaklar-31","chapter":"38 Filogenetik ağaçlar","heading":"38.5 Kaynaklar","text":"http://hydrodictyon.eeb.uconn.edu/eebedia/index.php/Ggtree# Clade_Colors\nhttps://bioconductor.riken.jp/packages/3.2/bioc/vignettes/ggtree/inst/doc/treeManipulation.html\nhttps://guangchuangyu.github.io/ggtree-book/chapter-ggtree.html\nhttps://bioconductor.riken.jp/packages/3.8/bioc/vignettes/ggtree/inst/doc/treeManipulation.htmlEa Zankari, Rosa Allesøe, Katrine G Joensen, Lina M Cavaco, Ole Lund, Frank M Aarestrup, PointFinder: novel web tool WGS-based detection antimicrobial resistance associated chromosomal point mutations bacterial pathogens, Journal Antimicrobial Chemotherapy, Volume 72, Issue 10, October 2017, Pages 2764–2768, https://doi.org/10.1093/jac/dkx217","code":""},{"path":"interactive-plots.html","id":"interactive-plots","chapter":"39 Interactive plots","heading":"39 Interactive plots","text":"Data visualisation increasingly required interrogable audience. Consequently, becoming common create interactive plots. several ways include two common plotly shiny.page focus converting existing ggplot() plot interactive plot plotly. can read shiny [Dashboards Shiny] page. worth mentioning interactive plots useable HTML format R markdown documents, PDF Word documents.basic epicurve transformed interactive using integration ggplot2 plotly (hover mouse plot, zoom , click items legend).","code":""},{"path":"interactive-plots.html","id":"preparation","chapter":"39 Interactive plots","heading":"39.1 Preparation","text":"","code":""},{"path":"interactive-plots.html","id":"load-packages","chapter":"39 Interactive plots","heading":"Load packages","text":"code chunk shows loading packages required analyses. handbook emphasize p_load() pacman, installs package necessary loads use. can also load installed packages library() base R. See page [R basics] information R packages.","code":"\npacman::p_load(\n  rio,       # import/export\n  here,      # filepaths\n  lubridate, # working with dates\n  plotly,    # interactive plots\n  scales,    # quick percents\n  tidyverse  # data management and visualization\n  ) "},{"path":"interactive-plots.html","id":"start-with-a-ggplot","chapter":"39 Interactive plots","heading":"Start with a ggplot()","text":"page assume beginning ggplot() plot want convert interactive. build several plots page, using case linelist used many pages handbook.","code":""},{"path":"interactive-plots.html","id":"import-data","chapter":"39 Interactive plots","heading":"Import data","text":"begin, import cleaned linelist cases simulated Ebola epidemic. want follow along, click download “clean” linelist (.rds file). Import data import() function rio package (handles many file types like .xlsx, .csv, .rds - see [Import export] page details).first 50 rows linelist displayed .","code":"\n# import case linelist \nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"interactive-plots.html","id":"plot-with-ggplotly","chapter":"39 Interactive plots","heading":"39.2 Plot with ggplotly()","text":"function ggplotly() plotly package makes easy convert ggplot() interactive. Simply save ggplot() pipe ggplotly() function., plot simple line representing proportion cases died given week:begin creating summary dataset epidemiological week, percent cases known outcome died.first 50 rows weekly_deaths dataset.create plot ggplot2, using geom_line().can make interactive simply passing plot ggplotly(), . Hover mouse line show x y values. can zoom plot, drag around. can also see icons upper-right plot. order, allow :Download current view PNG imageZoom select box“Pan”, move across plot clicking dragging plotZoom , zoom , return default zoomReset axes defaultsToggle /“spike lines” dotted lines interactive point extending x y axesAdjustments whether data show hovering lineGrouped data work ggplotly() well. , weekly epicurve made, grouped outcome. stacked bars interactive. Try clicking different items legend (appear/disappear).","code":"\nweekly_deaths <- linelist %>%\n  group_by(epiweek = floor_date(date_onset, \"week\")) %>%  # create and group data by epiweek column\n  summarise(                                              # create new summary data frame:\n    n_known_outcome = sum(!is.na(outcome), na.rm=T),      # number of cases per group with known outcome\n    n_death  = sum(outcome == \"Death\", na.rm=T),          # number of cases per group who died\n    pct_death = 100*(n_death / n_known_outcome)           # percent of cases with known outcome who died\n  )\ndeaths_plot <- ggplot(data = weekly_deaths)+            # begin with weekly deaths data\n  geom_line(mapping = aes(x = epiweek, y = pct_death))  # make line \n\ndeaths_plot   # print\ndeaths_plot %>% plotly::ggplotly()\n# Make epidemic curve with incidence2 pacakge\np <- incidence2::incidence(\n  linelist,\n  date_index = date_onset,\n  interval = \"weeks\",\n  groups = outcome) %>% plot(fill = outcome)\n# Plot interactively  \np %>% plotly::ggplotly()"},{"path":"interactive-plots.html","id":"modifications","chapter":"39 Interactive plots","heading":"39.3 Modifications","text":"","code":""},{"path":"interactive-plots.html","id":"file-size","chapter":"39 Interactive plots","heading":"File size","text":"exporting R Markdown generated HTML (like book!) want make plot small data size possible (negative side effects cases). , just pipe interactive plot partial_bundle(), also plotly.","code":"\np <- p %>% \n  plotly::ggplotly() %>%\n  plotly::partial_bundle()"},{"path":"interactive-plots.html","id":"buttons","chapter":"39 Interactive plots","heading":"Buttons","text":"buttons standard plotly superfluous can distracting, can remove . can simply piping output config() plotly specifying buttons remove. example specify advance names buttons remove, provide argument modeBarButtonsToRemove =. also set displaylogo = FALSE remove plotly logo.","code":"\n## these buttons are distracting and we want to remove them\nplotly_buttons_remove <- list('zoom2d','pan2d','lasso2d', 'select2d','zoomIn2d',\n                              'zoomOut2d','autoScale2d','hoverClosestCartesian',\n                              'toggleSpikelines','hoverCompareCartesian')\n\np <- p %>%          # re-define interactive plot without these buttons\n  plotly::config(displaylogo = FALSE, modeBarButtonsToRemove = plotly_buttons_remove)"},{"path":"interactive-plots.html","id":"heat-tiles","chapter":"39 Interactive plots","heading":"39.4 Heat tiles","text":"can make almost ggplot() plot interactive, including heat tiles. page [Heat plots] can read make plot, displays proportion days per week certain facilities reported data province.code, although describe depth ., make interactive modify simple buttons file size.–>\n","code":"\n# import data\nfacility_count_data <- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\"))\n\n# aggregate data into Weeks for Spring district\nagg_weeks <- facility_count_data %>% \n  filter(District == \"Spring\",\n         data_date < as.Date(\"2020-08-01\")) %>% \n  mutate(week = aweek::date2week(\n    data_date,\n    start_date = \"Monday\",\n    floor_day = TRUE,\n    factor = TRUE)) %>% \n  group_by(location_name, week, .drop = F) %>%\n  summarise(\n    n_days          = 7,\n    n_reports       = n(),\n    malaria_tot     = sum(malaria_tot, na.rm = T),\n    n_days_reported = length(unique(data_date)),\n    p_days_reported = round(100*(n_days_reported / n_days))) %>% \n  ungroup(location_name, week) %>% \n  right_join(tidyr::expand(., week, location_name)) %>% \n  mutate(week = aweek::week2date(week))\n\n# create plot\nmetrics_plot <- ggplot(agg_weeks,\n       aes(x = week,\n           y = location_name,\n           fill = p_days_reported))+\n  geom_tile(colour=\"white\")+\n  scale_fill_gradient(low = \"orange\", high = \"darkgreen\", na.value = \"grey80\")+\n  scale_x_date(expand = c(0,0),\n               date_breaks = \"2 weeks\",\n               date_labels = \"%d\\n%b\")+\n  theme_minimal()+ \n  theme(\n    legend.title = element_text(size=12, face=\"bold\"),\n    legend.text  = element_text(size=10, face=\"bold\"),\n    legend.key.height = grid::unit(1,\"cm\"),\n    legend.key.width  = grid::unit(0.6,\"cm\"),\n    axis.text.x = element_text(size=12),\n    axis.text.y = element_text(vjust=0.2),\n    axis.ticks = element_line(size=0.4),\n    axis.title = element_text(size=12, face=\"bold\"),\n    plot.title = element_text(hjust=0,size=14,face=\"bold\"),\n    plot.caption = element_text(hjust = 0, face = \"italic\")\n    )+\n  labs(x = \"Week\",\n       y = \"Facility name\",\n       fill = \"Reporting\\nperformance (%)\",\n       title = \"Percent of days per week that facility reported data\",\n       subtitle = \"District health facilities, April-May 2019\",\n       caption = \"7-day weeks beginning on Mondays.\")\n\nmetrics_plot # print\nmetrics_plot %>% \n  plotly::ggplotly() %>% \n  plotly::partial_bundle() %>% \n  plotly::config(displaylogo = FALSE, modeBarButtonsToRemove = plotly_buttons_remove)"},{"path":"interactive-plots.html","id":"resources","chapter":"39 Interactive plots","heading":"39.5 Resources","text":"Plotly just R, also works well Python (really data science language ’s built JavaScript). can read plotly website","code":""},{"path":"r-markdown-ile-raporlar.html","id":"r-markdown-ile-raporlar","chapter":"40 R Markdown ile Raporlar","heading":"40 R Markdown ile Raporlar","text":"R Markdown, raporlar gibi otomatik, tekrarlanabilir ve paylaşılabilir çıktılar oluşturmak için yaygın olarak kullanılan bir araçtır. Word, pdf, html, powerpoint ve diğer formatlarda statik veya etkileşimli çıktılar üretebilir.Bir R Markdown betiği, R kodunu metnin arasına serpiştirir, böylece betik aslında çıktı belgeniz olur. Anlatım metni (verilerinize göre dinamik olarak değişebilir), tablolar, şekiller, madde işaretleri/sayılar, bibliyografyalar vb. dahil olmak üzere biçimlendirilmiş bir belgenin tamamını oluşturabilirsiniz.\nBu tür belgeler, rutin güncelleme (örneğin, günlük gözetim raporları) ve/veya veri alt kümeleri (örneğin, yargı raporları) üzerinde çalışmak amacıyla üretilebilir.Bu el kitabındaki diğer sayfalarda bu konu detaylı olarak anlatılmaktadır:\n• Rutin raporları organize etme sayfası, otomatik oluşturulan zaman damgalı klasörlerle rapor üretiminizin nasıl otomatik hale getirileceğini gösterir.\n• R Markdown içeren Panolar sayfası, bir R Markdown raporunun pano olarak nasıl biçimlendirileceğini açıklar.: R4Epis projesi, MSF proje lokasyonlarında karşılaşılan yaygın salgın ve çalışma senaryoları için şablon olan R Markdown komut dosyaları geliştirmiştir.","code":""},{"path":"r-markdown-ile-raporlar.html","id":"hazırlık-32","chapter":"40 R Markdown ile Raporlar","heading":"40.1 Hazırlık","text":"R Markdown arkaplanıİlgili bazı kavram ve paketleri açıklamak için:\n• Markdown, html ve diğer formatlara dönüştürülebilen, düz metin kullanarak bir belge yazmanıza izin veren bir “dildir”. R’ye özgü değildir. Markdown’da yazılan dosyalar ‘.md’ uzantısına sahiptir.\n• R Markdown, R’ye özgü bir markdown varyasyonudur - metin üretmek, R kodunu gömmek ve çıktılarını görüntülemek için markdown kullanarak belge yazmanızı sağlar. R Markdown dosyaları “.Rmd” uzantısına sahiptir.\n• rmarkdown - paketi: Bu, R tarafından .Rmd dosyasını istenen çıktıya dönüştürmek için kullanılır. Odak noktası, dosyayı markdown (metin) sözdizimini dönüştürmektir.\n• knitr: Bu R paketi kod parçalarını okur, yürütür ve belgeye geri “örer”. Tablolar ve grafikler bu şekilde metnin yanına eklenir.\n• Pandoc: Son olarak, pandoc çıktıyı word/pdf/powerpoint vb.’ye dönüştürür. R’den ayrı bir yazılımdır ancak RStudio ile otomatik olarak yüklenir.\n• Özetle, arka planda gerçekleşen süreç (tüm bu adımları bilmenize gerek yoktur!), .Rmd dosyasının knitr’yi beslemesini içerir. Bu paket R kodu parçalarını yürütür ve yeni bir .md (markdown) dosyası oluşturur. R kodu ve işlenmiş çıktısı. .md dosyası daha sonra bitmiş ürünü oluşturmak için pandoc tarafından işlenir: bir Microsoft Word belgesi, HTML dosyası, powerpoint belgesi, pdf, vb. oluşturulur(kaynak: https://rmarkdown.rstudio.com/authoring_quick_tour.html):YüklemeBir R Markdown çıktısı oluşturmak için aşağıdakilerin kurulu olması gerekir:• rmarkdown paketi (knitr ayrıca otomatik olarak kurulacaktır)\n• RStudio ile birlikte gelmesi gereken Pandoc. RStudio kullanmıyorsanız, Pandoc’u buradan indirebilirsiniz: http://pandoc.org.\n• PDF çıktısı oluşturmak istiyorsanız (biraz daha zor), LaTeX’kurmanız gerekecek. Daha önce LaTeX yüklememiş olan R Markdown kullanıcıları için TinyTeX’(https://yihui.name/tinytex/) yüklemenizi öneririz. Aşağıdaki komutları kullanabilirsiniz:","code":"\npacman::p_load(tinytex)     # tinytex paketini yükleyin \ntinytex::install_tinytex()  # TinyTeX yazılımını yüklemek için R komutu "},{"path":"r-markdown-ile-raporlar.html","id":"başlangıç","chapter":"40 R Markdown ile Raporlar","heading":"40.2 Başlangıç","text":"","code":""},{"path":"r-markdown-ile-raporlar.html","id":"rmarkdown-r-paketini-yükleme","chapter":"40 R Markdown ile Raporlar","heading":"rmarkdown R paketini yükleme","text":"rmarkdown R paketini kurun. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’ın p_load() işlevini vurguluyoruz. Ayrıca, temel R’dan library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R temelleri ile ilgili sayfaya bakın.","code":"\npacman::p_load(rmarkdown)"},{"path":"r-markdown-ile-raporlar.html","id":"yeni-bir-rmd-dosyası-başlatmak","chapter":"40 R Markdown ile Raporlar","heading":"Yeni bir Rmd dosyası başlatmak","text":"RStudio’da, ‘Dosya’, ardından ‘Yeni dosya’ ve ardından ‘R markdown…’ ile başlayan yeni bir R markdown dosyası açın.R Studio size bazı çıktı seçenekleri sunacaktır. Aşağıdaki örnekte bir html belgesi oluşturmak istediğimiz için “HTML”yi seçiyoruz. Başlık ve yazar isimleri önemli değildir. İstediğiniz çıktı belgesi türü bunlardan biri değilse endişelenmeyin - herhangi birini seçip daha sonra komut dosyasında değiştirebilirsiniz.Bu, yeni bir .Rmd betiği açacaktır.","code":""},{"path":"r-markdown-ile-raporlar.html","id":"bilinmesi-önemli-noktalar","chapter":"40 R Markdown ile Raporlar","heading":"Bilinmesi önemli noktalar","text":"Çalışma diziniBir markdown dosyasının çalışma dizini, Rmd dosyasının kendisinin kaydedildiği yerdir. Örneğin, R projesi ‘~/Documents/projectX’ içindeyse ve Rmd dosyasının kendisi ‘~/Documents/projectX/markdownfiles/markdown.Rmd’ alt klasöründeyse, markdown içindeki read.csv(“data.csv”) kodu projelerdeki komut dosyalarının normalde otomatik olarak bakacağı kök proje klasöründe değil, ‘markdownfiles’ klasöründe bir csv dosyası arayacaktır.Başka bir yerde dosyalara başvurmak için ya tam dosya dizinini kullanmanız ya da buradaki paketi kullanmanız gerekecektir. Buradaki paket, çalışma dizinini R projesinin kök klasörü olarak ayarlar. Bu işlem el kitabının R projeleri ve içe ve dışa aktarma sayfalarında ayrıntılı olarak açıklanmıştır. Örneğin, projeX klasöründen “data.csv” adlı bir dosyayı içe aktarmak için kod import((“data.csv”) olacaktır).R Markdown komut dosyalarında ‘setwd()’ fonksiyonunun kullanımının önerilmediğini unutmayın - yalnızca yazıldığı kod parçası için geçerlidir.Bilgisayarınızda bir sürücü üzerinde çalışmakR Markdown, paylaşılan bir ağ sürücüsünde çalışırken pandoc sorunlarıyla karşılaşabileceğinden, klasörünüzün yerel makinenizde olması önerilir, örn. ‘Belgelerim’ içindeki bir projede. Git kullanıyorsanız (çok tavsiye edilir!), size tanıdık gelecektir. Daha fazla ayrıntı için, ağ sürücülerinde R’deki el kitabı sayfalarına ve [Hatalar ve yardım]’bakın.","code":""},{"path":"r-markdown-ile-raporlar.html","id":"r-markdown-bileşenleri","chapter":"40 R Markdown ile Raporlar","heading":"40.3 R Markdown bileşenleri","text":"Bir R Markdown belgesi, standart bir R betiği gibi RStudio’da düzenlenebilir. Yeni bir R Markdown komut dosyası başlattığınızda, RStudio, R Markdown komut dosyasının farklı bölümlerini açıklayan bir şablon göstererek destek sağlar.Aşağıdaki, bir html çıktısı oluşturmayı amaçlayan yeni bir Rmd betiğinin başlatıldığında izlenen bileşenler görülmektedir. (önceki bölüme göre).Gördüğünüz gibi, bir Rmd dosyasının üç temel bileşeni vardır: YAML, Markdown metni ve R kodu parçaları.Bunlar, belge çıktınızı oluşturacaktır. Aşağıdaki şemaya bakın:","code":""},{"path":"r-markdown-ile-raporlar.html","id":"yaml-metadatası","chapter":"40 R Markdown ile Raporlar","heading":"YAML metadatası","text":"“YAML meta verileri” veya yalnızca “YAML” olarak anılan bu bileşen, R Markdown belgesinin en üstündedir. Komut dosyasının bu bölümü, Rmd dosyanız için ne tür bir çıktı üretileceğini, biçimlendirme tercihlerini ve belge başlığı, yazar ve tarih gibi diğer meta verileri gösterecektir. Burada belirtilmeyen başka kullanımlar da vardır (Çıktı oluşturma’ bölümünde anlatılmaktadır). Girintilerin önemli olduğunu unutmayın; sekmeler kabul edilmez ancak boşluklar kabul edilir.Bu bölüm yalnızca üç tire (—) içeren bir satırla başlamalı ve yalnızca üç tire içeren bir satırla kapatılmalıdır. YAML parametreleri anahtar:değer (key:value) çiftleri halinde kodlanır. YAML’de iki nokta üst üste işareti (:) yerleşimi önemlidir - anahtar:değer çiftleri iki nokta üst üste işareti ile ayrılır (eşittir işaretleriyle değil!).YAML, belge için meta verilerle başlamalıdır. Bu birincil YAML parametrelerinin (girintisiz) sırası önemli değildir. Örneğin:R kodunu YAML değerleri içinde satır içi kod olarak (ters tikler içinde, r önce gelir) veya tırnak işaretleri içinde yazarak kullanabilirsiniz (tarih için yukarıdaki örneğe bakın:).Yukarıdaki resimde, varsayılan çıktımızın bir html dosyası olacağını seçtiğimiz için, YAML’nin çıktı: html_document olarak kodlandığını görebiliriz. Ancak bunu powerpoint_presentation veya word_document veya hatta pdf_document olarak değiştirebiliriz.","code":"title: \"My document\"\nauthor: \"Me\"\ndate: \"2022-11-20\""},{"path":"r-markdown-ile-raporlar.html","id":"metin","chapter":"40 R Markdown ile Raporlar","heading":"Metin","text":"Metin, başlıklar da dahil olmak üzere belgenizin anlatımıdır. Birçok farklı yazılımda kullanılan “markdown” dilinde yazılmıştır.Aşağıda bu metni yazmanın temel yolları bulunmaktadır. RStudio web sitesindeki R Markdown “cheatsheet”te bulunan daha kapsamlı belgelere bakın.\nRStudio website.","code":""},{"path":"r-markdown-ile-raporlar.html","id":"yeni-satırlar","chapter":"40 R Markdown ile Raporlar","heading":"Yeni Satırlar","text":"Benzersiz bir şekilde R Markdown’da yeni bir satır başlatmak için önceki satırın sonuna *iki boşluk** girin ve ardından Enter/Return uygulayın","code":""},{"path":"r-markdown-ile-raporlar.html","id":"metin-karakteri","chapter":"40 R Markdown ile Raporlar","heading":"Metin Karakteri","text":"Çıktıda nasıl görüneceğini değiştirmek için normal metninizi bu karakterlerle çevreleyin.• İtalik yapmak için alt çizgi (metin) veya tek bir yıldız (metin)\n• Kalın metin için çift yıldız (metin)\n• Metni kod olarak görüntülemek için ters tik (metin)Yazı tipinin gerçek görünümü, belirli şablonlar kullanılarak ayarlanabilir (YAML meta verilerinde belirtilir; örnek sekmelere bakın).","code":""},{"path":"r-markdown-ile-raporlar.html","id":"renk","chapter":"40 R Markdown ile Raporlar","heading":"Renk","text":"R Markdown’da metnin rengini değiştirmek için basit bir mekanizma yoktur. Çıktınız bir HTML dosyasıysa, geçici bir çözüm, işaretleme metnine bir HTML satırı eklemektir. Aşağıdaki HTML kodu, kalın kırmızı renkte bir metin satırı yazdıracaktır.**__TEHLİKE:_** Bu bir uyarıdır.","code":"<span style=\"color: red;\">**_DANGER:_** This is a warning.<\/span>  "},{"path":"r-markdown-ile-raporlar.html","id":"başlıklar","chapter":"40 R Markdown ile Raporlar","heading":"Başlıklar","text":"Bir R Markdown betiğinin metin bölümündeki hash (#) sembolü, bir başlık oluşturur. Bu, normal bir R betiğinde olduğu gibi, bir hash sembolünün yorum yapma/açıklama ekleme/devre dışı bırakma mekanizması olduğu komut dosyasındaki bir R kodundan farklıdır.Yeni bir satırın başlangıcında farklı sayıda hash sembolü ile farklı başlık seviyeleri oluşturulur. Bir hash sembolü, bir başlık veya birincil başlıktır. İki hash sembol, ikinci düzey bir başlıktır. Üçüncü ve dördüncü seviye başlıklar, art arda daha fazla hash sembolü ile yapılabilir.","code":"# Birinci düzey başlık / Genel başlık\n\n## İkinci seviye başlık\n\n### Üçüncü seviye başlık "},{"path":"r-markdown-ile-raporlar.html","id":"madde-işaretleri-ve-numaralandırma","chapter":"40 R Markdown ile Raporlar","heading":"Madde İşaretleri ve Numaralandırma","text":"Bir madde işareti listesi oluşturmak için yıldız işaretlerini (*) kullanın. Önceki cümleyi bitirin, iki boşluk bırakın, iki kez Enter/Return yapın ve ardından madde işaretlerinizi başlatın. Yıldız işareti ile madde işareti ile metniniz arasına bir boşluk ekleyin. madde işaretinden sonra iki boşluk girin ve ardından Enter/Return yapın. Alt madde işaretleri aynı şekilde çalışır ancak girintilidir. Sayılar aynı şekilde çalışır, ancak yıldız işareti yerine 1), 2) vb. yazın. Aşağıda R Markdown komut dosyası metninizin nasıl görünebileceği açıklanmıştır.","code":"Madde işaretlerim (bu kolondan sonra iki boşluk var):\n\n* Madde 1 (ardından iki boşluk ve Enter/Return)\n* Madde 2 (ardından iki boşluk ve Enter/Return)\n   * Alt madde işareti 1 (ardından iki boşluk ve Enter/Return)\n   * Alt madde 2 (ardından iki boşluk ve Enter/Return)\n \n  "},{"path":"r-markdown-ile-raporlar.html","id":"metne-yorum-yapılması","chapter":"40 R Markdown ile Raporlar","heading":"Metne yorum yapılması","text":"Tıpkı bir R parçasındaki bir R kodu satırını yorumlamak için “#” kullanabildiğiniz gibi, R İşaretleme metnini “yorumlayabilirsiniz”. Metni seçip ve Ctrl+Shift+c (Mac için Cmd+Shift+c) tuşlarına basın. Metin oklarla çevrelenecek ve yeşil renk alacaktır. Çıktınızda görünmeyecektir.","code":""},{"path":"r-markdown-ile-raporlar.html","id":"kod-parçaları","chapter":"40 R Markdown ile Raporlar","heading":"Kod parçaları","text":"Komut dosyasının R kodunu çalıştırmaya ayrılmış bölümlerine “parçalar” denir. Bu parçalar, paketleri yükleyebileceğiniz, verileri içe aktarabileceğiniz ve veri yönetimi ve görselleştirmesini gerçekleştirebileceğiniz yerlerdir. Çok sayıda kod parçası olabilir ve bu parçalar R kodunuzu metne serpiştirerek parçalar halinde organize etmenize yardımcı olabilir. : Bu “parçalar”, belgenin anlatım kısmından farklı bir arka plan rengine sahiptir.\nparça, üç ters tik ile başlayan bir satır ve parça için parametreleri içeren küme parantezleri ({ }) ile açılır. Parça üç tane daha geri tik ile sona erer.“Ctrl + Alt + ” (veya Mac’te Cmd + Shift + r) klavye kısa yollarını kullanarak veya komut dosyası düzenleyicinizin en üstünde ‘yeni bir kod parçası ekle’ simgesini tıklayarak yeni bir parça oluşturabilirsiniz.\n{ } küme parantezlerinin içeriği hakkında bazı notlar:• Parça içindeki kodlama dilinin R olduğunu belirtmek için ‘r’ ile başlarlar.\n• r’den sonra isteğe bağlı olarak bir kod parçası “adı” yazabilirsiniz – bu ad gerekli değildir ancak işinizi organize etmenize yardımcı olabilir. Parçalarınızı adlandırırsanız, ZAMAN benzersiz adlar kullanmanız gerektiğini unutmayın, aksi takdirde R, oluşturmayı denediğinizde hata verir.• Kıvrımlı parantezler, etiket=değer olarak yazılan diğer seçenekleri de içerebilir, örneğin:\n• eval = FALSE R kodunu çalıştırmamak için\n• echo = FALSE parçayı R kaynak kodunu çıktı belgesine yazdırmamak için\n• warning =FALSE R kodu tarafından üretilen uyarıları yazdırmamak için\n• message = FALSE R kodu tarafından üretilen hiçbir mesajı yazdırmamak için\n• include = TRU/FALSE, parça çıktılarının (ör. grafikler) belgeye dahil edilip edilmeyeceği\n• .width = ve .height = … tarzında oluşturma için .width = “%75”\n• fig.align = “center” şeklin sayfa boyunca nasıl hizalanacağını ayarlar\n• fig.show=‘hold’ parçanız birden fazla şekil yazdırıyorsa ve bunların yan yana yazdırılmasını istiyorsanız (.width = c(“%33”, “%67”) ile eşleştirin. Fig.show =‘asis’, kendilerini oluşturan kodun altında şekilleri göstermek için, ‘hide’ gizlemek için veya ‘animate’.bir animasyonda birden çok şekli birleştirmek için\n• Bir satırda bir parça başlığı yazılmalıdır\n• Noktalardan, alt çizgilerden ve boşluklardan kaçınmaya çalışın. Ayırıcıya ihtiyacınız varsa bunun yerine kısa çizgi (hyphens) ( - ) kullanın.\nBuradan knitr özellikleri hakkında daha fazla bilgi edinin.Yukarıdaki seçeneklerden bazıları, parçanın sağ üst köşesindeki ayar düğmeleri yapılandırılabilir. Burada, işlenen belgenin kodu, çıktıları ve uyarıları içermesini istediğiniz parçalarını belirtebilirsiniz. Bu, küme parantezleri içinde yazılı tercihler olarak görünecektir, örn. echo=FALSE ‘Yalnızca çıktıyı göster’ istediğinizi belirtir.Ayrıca parçanın sağ üst tarafında, kodu bir parça içinde veya tüm kodu önceki parçalarda çalıştırmak için yararlı olan iki ok vardır. Ne yaptıklarını görmek için üzerinde gezinin.Komut dosyasındaki tüm parçalara uygulanacak genel seçenekleri komut dosyasındaki ilk R kodu parçasında ayarlayabilirsiniz. Örneğin, kod parçası için yalnızca çıktıların gösterilmesi ve kodun kendisinin gösterilmemesi için, bu komutu R kod parçasına dahil edebilirsiniz:","code":"\nknitr::opts_chunk$set(echo = FALSE) "},{"path":"r-markdown-ile-raporlar.html","id":"metin-içinde-r-kodu","chapter":"40 R Markdown ile Raporlar","heading":"Metin İçinde R Kodu","text":"Geri tiklere minimum R kodunu da dahil edebilirsiniz. Geri tikler içinde, koda “r” ve bir boşluk ile başlayın, böylece RStudio, kodu R kodu olarak değerlendireceğini bilir. Aşağıdaki örneğe bakın.Aşağıdaki örnek, birden çok seviyedeki başlıkları ve madde işaretlerini gösterir, geçerli tarihi çıktı olarak kullanmak için (Sys.Date()) için R kodunu kullanır.Yukarıdaki örnek basittir (geçerli tarihi gösterir), ancak aynı sintaksı kullanarak daha karmaşık R kodu tarafından üretilen değerleri görüntüleyebilirsiniz (örneğin, bir sütunun min, medyan, maks. değerini hesaplamak gibi). Ayrıca, komut dosyasına daha önce R kodu parçalarında oluşturulmuş R nesnelerini veya değerlerini de entegre edebilirsiniz.Örnek olarak, aşağıdaki komut dosyası, 18 yaşından küçük vakaların oranını tidyverse işlevlerini kullanarak hesaplar ve 18altı (less18), toplam (total) ve 18altıoran (less18prop) nesnelerini oluşturur. Bu dinamik değer sonraki metne eklenir. Bir word belgesine nasıl çıktı alındığını (örüldüğünü) görüyoruz.","code":""},{"path":"r-markdown-ile-raporlar.html","id":"görseller","chapter":"40 R Markdown ile Raporlar","heading":"Görseller","text":"Görüntüleri R Markdown’ınıza iki yoldan biriyle dahil edebilirsiniz:Yukarıdakiler işe yaramazsa, knitr::include_graphics() kullanmayı deneyin.(unutmayın, dosya yolunuz buradaki paket kullanılarak yazılabilir)","code":"![](\"path/to/image.png\")  \nknitr::include_graphics(\"path/to/image.png\")\nknitr::include_graphics(here::here(\"path\", \"to\", \"image.png\"))"},{"path":"r-markdown-ile-raporlar.html","id":"tablolar","chapter":"40 R Markdown ile Raporlar","heading":"Tablolar","text":"Kısa çizgi ( - ) ve çubuklar ( | ) kullanarak bir tablo oluşturun. Çubukların önündeki/arasındaki kısa çizgi sayısı, metin yazılmaya başlamadan önceki boş karakter sayısını belirtir.Yukarıdaki kod aşağıdaki tabloyu oluşturur:","code":"Column 1 |Column  2 |Column 3\n---------|----------|--------\nCell A   |Cell B    |Cell C\nCell D   |Cell E    |Cell F"},{"path":"r-markdown-ile-raporlar.html","id":"sekmeli-bölümler","chapter":"40 R Markdown ile Raporlar","heading":"Sekmeli Bölümler","text":"HTML çıktılarında bölümleri “sekmeler” halinde düzenleyebilirsiniz. Bunun için bir başlıktan sonra gelen küme parantezleri { } içine .tabset’eklemeniz yeterlidir. Bu başlığın altındaki herhangi bir alt başlık (aynı seviyedeki başka bir başlığa kadar), kullanıcının tıklayabileceği sekmeler olarak görünecektir. Daha fazlasını buradan okuyabilirsiniz.Sekmelere kendilerine özgü bir görünüm vermek için .tabset’ten sonra ek olarak ‘.tabset-pills’ seçeneği ekleyebilirsiniz. Sekmeli HTML çıktısını görüntülerken, Ctrl+f arama işlevinin gizli sekmeleri değil, yalnızca “etkin” sekmeleri arayacağını unutmayın.","code":""},{"path":"r-markdown-ile-raporlar.html","id":"dosya-yapısı","chapter":"40 R Markdown ile Raporlar","heading":"40.4 Dosya yapısı","text":"R Markdown’unuzu ve ilişkili R komut dosyalarını yapılandırmanın birkaç yolu vardır. birinin avantajları ve dezavantajları vardır:• Kendine yeten R Markdown - rapor için gereken şey R Markdown içinde içe aktarılır veya oluşturulur\n• Diğer dosyaları kaynak olarak kullanma - source() komutuyla harici R komut dosyalarını çalıştırabilir ve çıktılarını Rmd’de kullanabilirsiniz.\n• Alt komut dosyaları - source() için alternatif bir mekanizma\n• Bir “runfile” kullanın - R Markdown’ı oluşturmadan önce komutları bir R betiğinde çalıştırın","code":""},{"path":"r-markdown-ile-raporlar.html","id":"kendine-yeten-rmd","chapter":"40 R Markdown ile Raporlar","heading":"Kendine yeten Rmd","text":"Nispeten basit bir rapor için, R Markdown komut dosyanızı “kendi kendine yeterli” olacak ve herhangi bir harici komut dosyası içermeyecek şekilde düzenlemeyi seçebilirsiniz.R markdown’ı çalıştırmak için ihtiyacınız olan şey, tüm kod parçaları ve paket yüklenmesi dahil olmak üzere, Rmd dosyası içinde gerçekleşir. Bu “kendi kendine yeten” yaklaşım, çok fazla veri işleme yapmanız gerekmediğinde (örneğin, temiz veya yarı temiz bir veri dosyası getirdiğinde) uygundur ve R Markdown’ın oluşturulması çok uzun sürmez.Bu senaryoda, R Markdown betiğinin bir mantıksal organizasyonu şöyle olabilir:\n1. Küresel knitr seçeneklerini ayarlayın\n2. Paketleri yükleyin\n3. Verileri içe aktarın\n4. Veriyi işleyin\n5. Çıktılar (tablolar, grafikler, vb.)\n6. Varsa çıktıları kaydedin (.csv, .png, vb.)","code":""},{"path":"r-markdown-ile-raporlar.html","id":"diğer-dosyaları-kaynak-olarak-kullanma","chapter":"40 R Markdown ile Raporlar","heading":"Diğer dosyaları kaynak olarak kullanma","text":"“Kendi kendine yeterli” yaklaşımın bir varyasyonu, R Markdown kod parçalarının diğer R komut dosyalarını “kaynak” olarak kullanmasıdır (çalıştırma-run). Bu yaklaşım R Markdown betiğinizi daha az karmaşık, daha basit ve organize edilmesi daha kolay hale getirebilir. Son çıktıları raporun başında görüntülemek isterseniz de bu yaklaşım yardımcı olabilir. Bu yaklaşımda, son R Markdown betiği, önceden işlenmiş çıktıları bir belgede birleştirir.Bunu yapmanın yolu, temel R ‘source()’ fonksiyonuna R komut dosyalarını (dosya yolu ve uzantılı ad) sağlamaktır.R Markdown içinde source() kullanılırken, Rmd dosyanızın oluşturulması sırasında harici dosyaların çalışmaya devam edeceğini unutmayın. Bu nedenle, raporu oluşturduğunuzda komut dosyası çalıştırılır. Bu nedenle, bu source() komutlarının R Markdown içinde olması çalışma sürenizi hızlandırmaz ve hata ayıklamaya büyük ölçüde yardımcı olmaz, çünkü üretilen hata R Markdown üretilirken yazdırılmaya devam eder.Bir alternatif, child = knitr seçeneğini kullanmaktır.Farklı R ortamlarının farkında olmalısınız. Bir ortamda oluşturulan nesneler, R Markdown tarafından kullanılan ortamda bulunmayabilir.","code":"\nsource(\"your-script.R\", local = knitr::knit_global())\n# or sys.source(\"your-script.R\", envir = knitr::knit_global())"},{"path":"r-markdown-ile-raporlar.html","id":"runfile","chapter":"40 R Markdown ile Raporlar","heading":"Runfile","text":"Bu yaklaşım, R markdown ile beslenen nesneleri önceden işlemek için render() komutlarını içeren R betiğinin kullanılmasını içerir.Bu yaklaşımla, paketleri yükleyebilir, verileri yükleyebilir ve temizleyebilir ve hatta render()’dan önce ilgilendiğiniz grafikleri oluşturabilirsiniz. Bu adımlar, R komut dosyasında veya kaynaklı diğer komut dosyalarında ortaya çıkabilir. Bu komutlar aynı RStudio oturumunda gerçekleştiği ve nesneler ortama kaydedildiği sürece, nesneler daha sonra Rmd içeriği içinde çağrılabilir. Ardından, R markdown tüm önceden işlenmiş nesnelerle çıktı üretmek için yalnızca son adım için kullanılacaktır. Bu yöntemde bir şeyler ters giderse hata ayıklamak için çok daha kolaydır.Bu yaklaşım aşağıdaki nedenlerle yararlıdır:\n• Daha bilgilendirici hata mesajları - bu mesajlar R Markdown’dan değil, R betiğinden oluşturulacaktır. R markdown hataları, hangi parçada sorun olduğunu söyleme eğilimindedir, ancak hangi satırda olduğunu söylemez.\n• Uygunsa, uzun işleme adımlarını render() komutundan önce çalıştırabilirsiniz (yalnızca bir kez çalışır).Aşağıdaki örnekte, bir veri nesnesini R ortamında önceden işlediğimiz ve ardından render() kullanarak “create_output.Rmd”yi oluşturduğumuz ayrı bir R betiğine sahibiz.","code":"\ndata <- import(\"datafile.csv\") %>%       # veriyi yükle ve ortama kaydet \n  select(age, hospital, weight)          # kısıtlı sütunları seç \n\nrmarkdown::render(input = \"create_output.Rmd\")   # Rmd dosyası oluştur"},{"path":"r-markdown-ile-raporlar.html","id":"dosya-yapısı-1","chapter":"40 R Markdown ile Raporlar","heading":"Dosya yapısı","text":"İş akışı, oluşturulan belgeler ve şekiller için bir “çıktı” klasörüne ve temizlenmiş veriler için “veri” veya “girişler” klasörlerini içeren genel klasör yapısıyla da ilgilidir. Burada daha fazla ayrıntıya girmiyoruz, ancak Rutin raporların düzenlenmesi sayfasına göz atın.","code":""},{"path":"r-markdown-ile-raporlar.html","id":"belgenin-oluşturulması","chapter":"40 R Markdown ile Raporlar","heading":"40.5 Belgenin oluşturulması","text":"Belgeyi aşağıdaki şekillerde oluşturabilirsiniz:\n• RStudio komut dosyası düzenleyicisinin üst kısmındaki “Knit” düğmesine manuel olarak basarak (hızlı ve kolay)\n• render() komutunu çalıştırın (R Markdown betiğinin dışında yürütülür)","code":""},{"path":"r-markdown-ile-raporlar.html","id":"seçenek-1-knit-butonu","chapter":"40 R Markdown ile Raporlar","heading":"Seçenek 1: “Knit” butonu","text":"Rmd dosyasını açtığınızda, dosyanın üstündeki ‘Knit’ simgesine/düğmesine basın.R Studio, ilerlemeyi R konsolunuzun yakınındaki ’R markdown sekmesinde gösterecektir. Belge tamamlandığında otomatik olarak açılır.Belge, R işaretleme betiğinizle aynı klasöre ve aynı dosya adıyla (uzantı dışında) kaydedilecektir. Bu yaklaşım sürüm kontrolü için ideal değildir (manuel olarak taşınmadıkça dosya oluşturmada var olan dosyanın üzerine yazılır), çünkü daha sonra dosyayı kendiniz yeniden adlandırmanız gerekebilir (örneğin dosya ismine bir tarih ekleyin).Bu, rmarkdown’dan render() işlevi için RStudio’nun kısayol düğmesidir. Bu yaklaşım, yalnızca gerekli tüm bileşenlerin bulunduğu veya dosya içinden kaynaklandığı kendi kendine yeten bir R markdown ile uyumludur.","code":""},{"path":"r-markdown-ile-raporlar.html","id":"seçenek-2-render-komutu","chapter":"40 R Markdown ile Raporlar","heading":"Seçenek 2: render() komutu","text":"R Markdown çıktınızı üretmenin başka bir yolu da render() işlevini çalıştırmaktır (rmarkdown paketinden). Bu komutu R Markdown betiğinin dışında yürütmelisiniz - yani ya ayrı bir R betiğinde (genellikle “run dosyası” olarak adlandırılır) ya da R Konsolunda bağımsız bir komut olarak.“knit” ile olduğu gibi, varsayılan ayarlar Rmd çıktısını aynı dosya adıyla (dosya uzantısı dışında) Rmd komut dosyasıyla aynı klasöre kaydeder. Örneğin “my_report.Rmd” örüldüğünde bir word belgesine örüyorsanız “my_report.docx” dosyasını oluşturacaktır. Ancak render() kullanarak farklı ayarlar kullanma seçeneğiniz vardır. render() aşağıdaki argümanları kabul eder:• output_format = Bu, dönüştürülecek çıktı biçimidir (ör. “html_document”, “pdf_document”, “word_document” veya “”). Bunu, R Markdown betiği içindeki YAML’de de belirtebilirsiniz.\n• output_file = Bu, çıktı dosyasının (ve dosya yolunun) adıdır. Bu, aşağıda gösterildiği gibi () veya str_glue() gibi R işlevleri aracılığıyla oluşturulabilir.\n• output_dir = Bu, dosyayı kaydetmek için bir çıktı dizinidir (klasör). Bu, Rmd dosyasının kaydedildiği dizinden başka bir alternatif seçmenize olanak tanır.\n• output_options = YAML komut dosyasındakileri geçersiz kılacak bir seçenekler listesi elde edebilirsiniz (ör. )\n• output_yaml = YAML özelliklerini içeren bir .yml dosyasının yolağını sağlayabilirsiniz\n• params = Aşağıdaki parametrelerle ilgili bölüme bakın\n• Tam listeye buradan bakınBir örnek olarak, sürüm kontrolünü iyileştirmek için aşağıdaki komut, çıktı dosyasını dosya adı ve geçerli tarihle birlikte bir “çıktılar” alt klasörüne kaydeder. Dosya adını oluşturmak için, stringr paketindeki str_glue() fonkisyonu, statik dizelerle (açıkça yazılır) dinamik R kodunu (kıvrımlı parantezler içinde yazılır) birbirine ‘yapıştırmak’ için kullanılır. Örneğin 10 Nisan 2021 ise dosya adı “Report_2021-04-10.docx” olacaktır. str_glue() hakkında daha fazla ayrıntı için Karakterler ve dizeler sayfasına bakın.Dosya işlenirken, RStudio Konsolu size %100’e kadar işlemeninm ilerlemesini ve işlemenin tamamlandığını belirten son bir mesaj gösterecektir.","code":"\nrmarkdown::render(input = \"my_report.Rmd\")\nrmarkdown::render(\n  input = \"create_output.Rmd\",\n  output_file = stringr::str_glue(\"outputs/Report_{Sys.Date()}.docx\")) "},{"path":"r-markdown-ile-raporlar.html","id":"seçenek-3-reportfactory-paketi","chapter":"40 R Markdown ile Raporlar","heading":"Seçenek 3: reportfactory paketi","text":"R reportfactory paketi, raporları rutin olarak çalıştırdığınız senaryolara göre (örneğin günlük, haftalık…) R Markdown raporlarını düzenlemek ve derlemek için alternatif bir yöntem sunar. Birden çok R Markdown dosyasının derlenmesini ve çıktılarının organizasyonunu kolaylaştırır. Özünde, R Markdown raporlarını çalıştırabileceğiniz, çıktılar için otomatik olarak tarih ve zaman damgalı klasörler oluşturabileceğiniz ve “hafif” sürüm kontrolüne sahip olabileceğiniz bir “fabrika” sağlar.Rutin raporları organize etme sayfasında bu iş akışı hakkında daha fazla bilgi edinebilirsiniz.","code":""},{"path":"r-markdown-ile-raporlar.html","id":"parametreli-raporlar","chapter":"40 R Markdown ile Raporlar","heading":"40.6 Parametreli Raporlar","text":"Belirli bir ayarla (örneğin belirli bir tarih veya yer veya belirli örgü seçenekleriyle) çalıştırılabilmesi için bir raporu dinamik hale getirmek için parametreleştirmeyi kullanabilirsiniz. Aşağıda, temel bilgilere odaklanıyoruz, ancak parametreli raporlar hakkında çevrimiçi olarak daha fazla bilgi bulabilirsiniz.Ebola vaka listesini örnek olarak kullanarak, hastane için gün standart bir gözetim raporu oluşturmak istediğimizi varsayalım. Bunun parametreleri kullanarak nasıl yapılabileceğini gösteriyoruz.Önemli: Bitişik bir R komut dosyasında basit R nesneleri kullanarak resmi parametre yapısı (params) olmadan da dinamik raporlar oluşturmak mümkündür. Bu durum, bu bölümün sonunda açıklanmıştır.","code":""},{"path":"r-markdown-ile-raporlar.html","id":"parametrelerin-ayarlanması","chapter":"40 R Markdown ile Raporlar","heading":"Parametrelerin ayarlanması","text":"R Markdown çıktınız için parametre değerleri belirlemek için birkaç seçeneğiniz vardır.","code":""},{"path":"r-markdown-ile-raporlar.html","id":"seçenek-1-yaml-içinde-parametrelerin-ayarlanması","chapter":"40 R Markdown ile Raporlar","heading":"Seçenek 1: YAML içinde parametrelerin ayarlanması","text":"Tanımlamak istediğiniz parametre için girintili ifadeler içeren bir params: seçeneği eklemek için YAML’yi düzenleyin. Bu örnekte, değerlerini belirttiğimiz tarih ve hastane parametrelerini oluşturuyoruz. Bu değerler, rapor çalıştırıldığında değişebilir. Çıktıyı üretmek için “Knit” düğmesini kullanırsanız, parametreler bu varsayılan değerlere sahip olacaktır. Benzer şekilde, render() komutunu kullanırsanız, render() komutunda aksi belirtilmedikçe parametreler bu varsayılan değerlere sahip olacaktır.Arka planda, bu parametre değerleri, params adı verilen salt okunur bir listede bulunur. Böylece, ortamınızdaki başka bir R nesnesi/değeri gibi parametre değerlerini R koduna ekleyebilirsiniz. Params$ yazıp ardından parametre adını yazmanız yeterlidir. Örneğin, hastane adını temsil etmek için params$hospital (varsayılan olarak “Merkez Hastane- Central Hospital”).Parametrelerin doğru veya yanlış değerleri de tutabileceğini ve bu nedenle bunların bir R kod parçası için knitr seçeneklerinize dahil edilebileceğini unutmayın. Örneğin, {r, eval=FALSE} yerine {r, eval=params$run} ayarını yapabilirsiniz, bu durumda kod parçasının çalışıp çalışmaması parametre çalıştırma: değerine bağlıdır.Tarih olan parametrelerin bir dize olarak girileceğini unutmayın. Bu nedenle, params$date’R kodunda yorumlanması için muhtemelen Date sınıfına dönüştürmek için .Date() veya benzer bir fonksiyonla sarılması gerekir.","code":"---\ntitle: Surveillance report\noutput: html_document\nparams:\n date: 2021-04-10\n hospital: Central Hospital\n---"},{"path":"r-markdown-ile-raporlar.html","id":"seçenek-2-parametrelerin-render-ile-ayarlanması","chapter":"40 R Markdown ile Raporlar","heading":"Seçenek 2: Parametrelerin render() ile ayarlanması","text":"Yukarıda bahsedildiği gibi, çıktı üretmek için “Ör-Knit” düğmesine basmaya alternatif olarak, ayrı bir komut dosyasından render() fonksiyonunu yürütmektir. Bu durumda, bu fonksiyonda kullanılacak parametreleri render()’ın params = argümanında belirtebilirsiniz.Burada sağlanan herhangi bir parametre değerinin, YAML içinde yazılan varsayılan değerlerin üzerine yazılacağını unutmayın. Değerleri tırnak içinde yazıyoruz çünkü karakter/string değerleri olarak tanımlanmaları gerekiyor.Aşağıdaki komut, “surveillance_report.Rmd” dosyasını işler; dinamik bir çıktı dosyası adı ve klasörü belirtir. Ayrıca params = argümanına iki parametre sağlayan bir list() içerir.","code":"\nrmarkdown::render(\n  input = \"surveillance_report.Rmd\",  \n  output_file = stringr::str_glue(\"outputs/Report_{Sys.Date()}.docx\"),\n  params = list(date = \"2021-04-10\", hospital  = \"Central Hospital\"))"},{"path":"r-markdown-ile-raporlar.html","id":"seçenek-3-bir-görsel-kullanıcı-arayüzü-kullanarak-parametreleri-ayarlayın","chapter":"40 R Markdown ile Raporlar","heading":"Seçenek 3: Bir Görsel Kullanıcı Arayüzü kullanarak parametreleri ayarlayın","text":"Daha iyi etkileşim için, parametreler için değerleri manuel olarak seçebildiğiniz Grafik Kullanıcı Arayüzü’nü (GUI) da kullanabilirsiniz. Bunu yapmak için ‘Ör-Knit’ düğmesinin yanındaki açılır menüyü tıklayıp ’Parametrelerle ör- Knit parameters’seçebiliriz.Belgenin YAML’sinde oluşturulan parametreler için değerleri yazmanıza izin veren bir açılır pencere görünecektir.Aynı sonucu, aşağıda gösterildiği gibi params = “ask” argümanını belirterek bir render() komutuyla da elde edebilirsiniz.Ancak bu açılır pencereye değerlerin girilmesi hata ve yazım hatalarına tabidir. Açılır menülerden girilebilecek değerlere kısıtlamalar eklemeyi tercih edebilirsiniz. Bunu, bir parametre için YAML’ye birkaç belirtim ekleyerek yapabilirsiniz params: entrylabel: söz konusu açılır menünün başlığıvalue: varsayılan (başlangıç) değerdirinput: açılır menü için select şekilde ayarlayınchoices: Açılır menüden uygun değerleri verinAşağıda hastane parametresi için bu özellikler yazılmıştır.Örürken (‘parametrelerle ör(Knit)’ düğmesi aracılığıyla veya render() yoluyla), açılır pencerede seçim yapabileceğiniz seçenekler bulunur.","code":"rmarkdown::render(\n  input = \"surveillance_report.Rmd\",  \n  output_file = stringr::str_glue(\"outputs/Report_{Sys.Date()}.docx\"),\n  params = “ask”)---\ntitle: Surveillance report\noutput: html_document\nparams:\n date: 2021-04-10\n hospital: \n  label: “Town:”\n  value: Central Hospital\n  input: select\n  choices: [Central Hospital, Military Hospital, Port Hospital, St. Mark's Maternity Hospital (SMMH)]\n---"},{"path":"r-markdown-ile-raporlar.html","id":"parametreli-örnek","chapter":"40 R Markdown ile Raporlar","heading":"Parametreli örnek","text":"Aşağıdaki kod, R Markdown’da sırasıyla params\\(date ve params\\)hospital olarak kullanılan tarih ve hastane için parametreler oluşturur.Ortaya çıkan rapor çıktısında, verilerin belirli bir hastaneye nasıl filtrelendiğini ve grafik başlığının doğru hastane ve tarihi ifade ettiğini görün. Burada “linelist_cleaned.rds” dosyasını kullanıyoruz, ancak satır listesinin parametreli tarihle uyumlu olması için bir tarih damgası olması uygun olacaktır.Örme işlemi sonrası, varsayılan yazı tipi ve düzen ile son çıktı üretilir.","code":""},{"path":"r-markdown-ile-raporlar.html","id":"params-olmadan-parametreli-hale-getirme","chapter":"40 R Markdown ile Raporlar","heading":"params olmadan parametreli hale getirme","text":"Ayrı bir komut dosyasından render() ile bir R Markdown dosyası oluşturuyorsanız, params: kullanmadan parametreleştirmenin etkisini yaratabilirsiniz.Örneğin, render() komutunu içeren R betiğinde, render() komutundan önce hastane ve tarihi iki R nesnesi (değeri) olarak basitçe tanımlayabilirsiniz. R Markdown’da, YAML’de bir params: bölümüne sahip olmanız gerekmez ve params\\(date yerine tarih nesnesine ve params\\)hospital yerine hastaneye başvururuz.Bu yaklaşımı takip etmek, “parametrelerle öremeyeceğiniz”, GUI’yi kullanamayacağınız veya parametreler içinde örgü seçeneklerini ekleyemeyeceğiniz anlamına gelir. Bununla birlikte, avantajlı olabilecek daha basit koda izin verir.","code":"\n# Bu, R Markdown'dan ayrı bir R betiğidir.\n\n# R nesnelerini tanımlayın\nhospital <- \"Central Hospital\"\ndate <- \"2021-04-10\"\n\n# R markdown oluşturun\nrmarkdown::render(input = \"create_output.Rmd\") "},{"path":"r-markdown-ile-raporlar.html","id":"döngülü-raporlar","chapter":"40 R Markdown ile Raporlar","heading":"40.7 Döngülü raporlar","text":"yetki alanı/birim için bir rapor üretmek için girdi parametrelerini değiştirerek bir raporu birden çok kez çalıştırmak isteyebiliriz. Bu, yineleme, döngü ve listeler sayfasında ayrıntılı olarak açıklanan yineleme araçları kullanılarak yapılabilir. Seçenekler, purrr paketini veya aşağıda açıklandığı gibi bir döngüsünün kullanımını içerir.Aşağıda, ilgili tüm hastaneler için bir gözetim raporu oluşturmak için basit bir döngüsü kullanıyoruz. Bu, tek bir komutla yapılır (hastane parametresini hastaneler için birer birer manuel olarak değiştirmek yerine). Raporları işleme komutu, Rmd raporunun dışında ayrı bir komut dosyasında bulunmalıdır. Bu komut dosyası aynı zamanda “dönüştürülecek” tanımlanmış nesneleri - bugünün tarihini ve döngünün uygulanacağı hastane adları vektörünü içerecektir.Daha sonra, hastane vektöründeki değer için komut çalıştıran bir döngü kullanarak bu değerlere render() fonksiyonunu uygularız. harfi, yinelemede kullanılmakta olan hastanenin dizin konumunu (1 ila 4) temsil eder, öyle ki hospital_list[1] “Merkez Hastane” olur. Bu bilgi, render() komutunda iki yerde sağlanır:Dosya adında. 10 Nisan 2021’de oluşturulan ilk yinelemenin dosya adı, çalışma dizininin ‘çıktı’ alt klasörüne kaydedilen “Report_Central Hospital_2021-04-10.docx” olacak şekilde belirlenmiştir.Dosya adında. 10 Nisan 2021’de oluşturulan ilk yinelemenin dosya adı, çalışma dizininin ‘çıktı’ alt klasörüne kaydedilen “Report_Central Hospital_2021-04-10.docx” olacak şekilde belirlenmiştir.params = argümanına. Rmd, params$hospital değeri çağrıldığında dahili olarak hastane adını kullanır (veri setini yalnızca belirli bir hastaneye filtrelemek amacıyla). Bu örnekte, hastane için bir tane olmak üzere dört dosya oluşturulacaktır.params = argümanına. Rmd, params$hospital değeri çağrıldığında dahili olarak hastane adını kullanır (veri setini yalnızca belirli bir hastaneye filtrelemek amacıyla). Bu örnekte, hastane için bir tane olmak üzere dört dosya oluşturulacaktır.","code":"\nhospitals <- c(\"Central Hospital\",\n                \"Military Hospital\", \n                \"Port Hospital\",\n                \"St. Mark's Maternity Hospital (SMMH)\") \nfor(i in 1:length(hospitals)){\n  rmarkdown::render(\n    input = \"surveillance_report.Rmd\",\n    output_file = str_glue(\"output/Report_{hospitals[i]}_{Sys.Date()}.docx\"),\n    params = list(hospital  = hospitals[i]))\n}       "},{"path":"r-markdown-ile-raporlar.html","id":"şablonlar","chapter":"40 R Markdown ile Raporlar","heading":"40.8 Şablonlar","text":"İstediğiniz biçimlendirmeyi içeren bir şablon belge kullanarak, Rmd çıktısının nasıl görüneceğinin estetiğini ayarlayabilirsiniz. Örneğin, istenen boyutlara, filigranlara (watermark), arka planlara ve yazı tiplerine sahip sayfaları/slaytları içeren bir MS Word veya Powerpoint dosyası oluşturabilirsiniz.","code":""},{"path":"r-markdown-ile-raporlar.html","id":"word-belgeleri","chapter":"40 R Markdown ile Raporlar","heading":"Word belgeleri","text":"Bir şablon oluşturmak için, yeni bir kelime word başlatın (veya size uygun formatta mevcut bir çıktıyı kullanın) ve stilleri tanımlayarak yazı tiplerini düzenleyin. Stillerde, Başlık 1, 2 ve 3 çeşitli markdown başlık seviyelerine atıfta bulunur (sırasıyla # Başlık 1, ## Başlık 2 ve ### Başlık 3). Paragrafın yanı sıra yazı tipi biçimlendirmesini de değiştirmek için stile sağ tıklayın ve ’değiştir’e tıklayın (örneğin, boşluk bırakmaya yardımcı olabilecek belirli stillerden önce sayfa ayrımları ekleyebilirsiniz). Kenar boşlukları, sayfa boyutu, başlıklar vb. gibi Word belgesinin diğer ayarları, üzerinde çalıştığınız normal bir kelime belgesi gibi doğrudan değiştirilebilir.","code":""},{"path":"r-markdown-ile-raporlar.html","id":"powerpoint-belgeleri","chapter":"40 R Markdown ile Raporlar","heading":"Powerpoint belgeleri","text":"Yukarıdaki gibi, yeni bir slayt seti oluşturun veya istenen formatta mevcut bir powerpoint dosyasını kullanın. Daha fazla düzenleme için, ‘Görünüm’ ve ‘Asıl Slaytın’ üzerine tıklayın. Buradan, metin kutularındaki metin biçimlendirmesini ve ayrıca genel sayfa için arka plan/sayfa boyutlarını düzenleyerek “ana” slayt görünümünü değiştirebilirsiniz.Ne yazık ki, powerpoint dosyalarını düzenlemek biraz daha az esnektir:\n• Birinci düzey başlık (# Başlık 1) otomatik olarak yeni bir slaydın başlığı olur,\n• Bir ## Başlık 2 metni altyazı olarak değil, slaydın ana metin kutusundaki metin olarak görünecektir (Ana görünümü değiştirmenin bir yolunu bulamazsanız).\n• Çıktı alınan grafikler ve tablolar otomatik olarak yeni slaytlara geçecektir. Bunları birleştirmeniz gerekecektir, örneğin ggplot’ları birleştirmek için patchwork fonksiyonu, aynı sayfada görünmelerini sağlar. Birden çok görüntüyü tek bir slayta yerleştirmek için patchwork paketini kullanma hakkında [blog post] (https://mattherman.info/blog/ppt-patchwork/) gönderisine bakın.\nPowerpoint sunumlarıyla daha derinlemesine çalışacak bir araç için officer paketine officer package bakın.","code":""},{"path":"r-markdown-ile-raporlar.html","id":"şablonların-yamle-entegrasyonu","chapter":"40 R Markdown ile Raporlar","heading":"Şablonların YAML’e entegrasyonu","text":"Bir şablon hazırlandıktan sonra, ilgili detaylar Rmd’nin YAML’sine ‘çıktı’ satırının altına ve belge tipinin belirtildiği yerin altına (ayrı bir satır olarak) eklenebilir. referans_doc, powerpoint slayt şablonları için kullanılabilir.Şablonu Rmd dosyasının bulunduğu klasöre (aşağıdaki örnekte olduğu gibi) veya içindeki bir alt klasöre kaydetmek en kolay yoldur.","code":"---\ntitle: Surveillance report\noutput: \n word_document:\n  reference_docx: \"template.docx\"\nparams:\n date: 2021-04-10\n hospital: Central Hospital\ntemplate:\n \n---"},{"path":"r-markdown-ile-raporlar.html","id":"html-dosyalarının-formatlanması","chapter":"40 R Markdown ile Raporlar","heading":"HTML dosyalarının formatlanması","text":"HTML dosyaları şablon kullanmaz, ancak YAML içinde yapılandırılmış stiller içerebilir. HTML’ler etkileşimli ve esnek belgelerdir. Burada bazı temel seçenekleri ele alıyoruz.• Table contents-İçindekiler): Aşağıda toc: true ile bir içindekiler tablosu ekleyebilir ve ayrıca toc_float: true ile siz kaydırdıkça görüntülenebilir formda olmasını (“kayan-floats”) belirtebiliriz.• Themes-Temalar: Bootswatch tema kitaplığından gelen önceden hazırlanmış bazı temalara başvurabiliriz. Aşağıdaki örnekte cerulean kullanıyoruz. Diğer seçenekler şunlardır: ournal, flatly, darkly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex ve yeti.• Highlight-Vurgula: Bu seçeneği yapılandırmak, vurgulanan metnin görünümünü değiştirir (örneğin, kod parçaları). Desteklenen stiller arasında default, tango, pygments, kate, monochrome, espresso, zenburn, haddock, breezedark ve textmate. bulunur.Yukarıdaki seçeneklerin YAML’ye nasıl entegre edileceğine dair bir örnek.Aşağıda, ikisi de kayan formda içindekiler tablolarına sahip, ancak farklı tema ve vurgulama stilleri seçilen iki HTML çıktısı örneği verilmiştir:","code":"---\ntitle: \"HTML example\"\noutput:\n  html_document:\n    toc: true\n    toc_float: true\n    theme: cerulean\n    highlight: kate\n    \n---"},{"path":"r-markdown-ile-raporlar.html","id":"dinamik-içerik","chapter":"40 R Markdown ile Raporlar","heading":"40.9 Dinamik içerik","text":"Bir HTML çıktısında, rapor içeriğiniz dinamik olabilir. Aşağıda bazı örnekler verilmiştir:","code":""},{"path":"r-markdown-ile-raporlar.html","id":"tablolar-1","chapter":"40 R Markdown ile Raporlar","heading":"Tablolar","text":"Bir HTML raporunda, içeriğin dinamik olması için filtreler ve kaydırma çubukları ile veri çerçevesi / tibble yazdırabilirsiniz. Bu özelliği sunan birkaç paket mevcuttur.Bunu DT paketiyle yapmak için, bu el kitabında kullanıldığı gibi, şöyle bir kod parçası ekleyebilirsiniz:datatable() fonksiyonu, sağlanan veri çerçevesini okuyucu için dinamik bir tablo olarak yazdıracaktır. Tablonun en sol tarafını basitleştirmek için satır adları için rownames = argümanını FALSE-YANLIŞ olarak ayarlayabilirsiniz. filter = “top”, sütun üzerinde bir filtre sağlar. option() fonksiyonunun argümanlar kısmına diğer özelliklerin bir listesini girin. Aşağıda iki tane argüman yer almaktadır: pageLength = 5, görünen satır sayısını 5 olarak ayarlar (kalan satırlar oklar arasında gezinerek görüntülenebilir) ve scrollX=TRUE tablonun altında bir kaydırma çubuğu etkinleştirir (sağa çok fazla uzanan sütunlar için).Veri setiniz çok büyükse, veri çerçevesini head() içine sararak yalnızca en üstteki X sayıdaki satırları görüntülemeyi düşünün.","code":""},{"path":"r-markdown-ile-raporlar.html","id":"html-araçları","chapter":"40 R Markdown ile Raporlar","heading":"HTML araçları","text":"HTML widgets R R için HTML widget’ları, JavaScript kitaplıklarını kullanarak artırılmış etkileşim sağlayan özel bir R paketleri sınıfıdır. Bu paketleri HTML R Markdown çıktılarına gömebilirsiniz.Bu widget’ların bazı yaygın örnekleri şunları içerir:• Plotly (bu el kitabı sayfasında ve İnteraktif grafikler sayfasında kullanılır)\n• visNetwork (bu el kitabının İletim Zincirleri sayfasında kullanılır)\n• Leaflet (bu el kitabının GIS Temelleri sayfasında kullanılır)\n• dygraphs (zaman serisi verilerini etkileşimli olarak göstermek için kullanılır)\n• DT (datatable()) (filtre, sıralama vb. ile dinamik tabloları göstermek için kullanılır)Plotly’den ggplotly() fonksiyonunun kullanımı özellikle kolaydır. Etkileşimli grafikler sayfasına bakın.","code":""},{"path":"r-markdown-ile-raporlar.html","id":"kaynaklar-32","chapter":"40 R Markdown ile Raporlar","heading":"40.10 Kaynaklar","text":"Daha fazla bilgi şuralarda bulunabilir:https://bookdown.org/yihui/rmarkdown/https://rmarkdown.rstudio.com/articles_intro.html• Markdown vs knitr vs R markdown’ın için iyi bir açıklama: https://stackoverflow.com/questions/40563479/relationship--r-markdown-knitr-pandoc--bookdown","code":""},{"path":"rutin-raporların-düzenlenmesi.html","id":"rutin-raporların-düzenlenmesi","chapter":"41 Rutin raporların düzenlenmesi","heading":"41 Rutin raporların düzenlenmesi","text":"Bu sayfa, raporlar için R Markdown kullanımına eşlik eden reportfactory paketini kapsamaktadır.Raporları rutin olarak çalıştırdığınız senaryolarda (günlük, haftalık vb.), birden çok R Markdown dosyasının derlenmesini ve çıktılarının organizasyonunu kolaylaştırır. Özünde, R Markdown raporlarını çalıştırabileceğiniz, çıktılar için otomatik olarak tarih ve zaman damgalı klasörler alabileceğiniz ve “hafif” sürüm kontrolüne sahip olabileceğiniz bir “fabrika” sağlar.reportfactory, RECON (R Epidemics Consortium) tarafından geliştirilen paketlerden biridir. İşte onların web sitesi ve Github.","code":""},{"path":"rutin-raporların-düzenlenmesi.html","id":"hazırlık-33","chapter":"41 Rutin raporların düzenlenmesi","heading":"41.1 Hazırlık","text":"","code":""},{"path":"rutin-raporların-düzenlenmesi.html","id":"paketleri-yüklemek-1","chapter":"41 Rutin raporların düzenlenmesi","heading":"Paketleri yüklemek","text":"RStudio içinden, Github’dan reportfactory paketinin en son sürümünü yükleyin.Bunu, Github’dan en son sürümün yüklenmesini zorlayacak olan p_load_current_gh() ile pacman paketi aracılığıyla yapabilirsiniz. Github organizasyonunu (reconverse) ve veri havuzunu (rapor fabrikası) belirten “reconverse/reportfactory” karakter dizisini sağlayın. Alternatif olarak remotes paketinden install_github() da kullanabilirsiniz.","code":"\n# Paketin en son sürümünü Github'dan yükleyin ve kurun\npacman::p_load_current_gh(\"reconverse/reportfactory\")\n# remotes::install_github(\"reconverse/reportfactory\") # alternatif yöntem"},{"path":"rutin-raporların-düzenlenmesi.html","id":"yeni-fabrika","chapter":"41 Rutin raporların düzenlenmesi","heading":"41.2 Yeni fabrika","text":"Yeni bir fabrika oluşturmak için new_factory() fonksiyonunu çalıştırın. Bu, yeni bir bağımsız R proje klasörü oluşturacaktır. Varsayılan olarak:Fabrika çalışma dizininize eklenecektir.Fabrika R projesinin adı “new_factory.Rproj” olarak adlandırılacaktır.RStudio oturumunuz bu R projesine “taşınacak”tırFabrikanın içine baktığınızda, alt klasörlerin ve bazı dosyaların otomatik olarak oluşturulduğunu görebilirsiniz.report_sources klasörü, raporlarınızı oluşturan R Markdown komut dosyalarınızı tutacaktır.outputs klasörü, rapor çıktılarını tutmak için(ör. HTML, Word, PDF, vb.)scripts klasörü, diğer R komut dosyalarını depolamak için kullanılabilir (örneğin, Rmd komut dosyalarınız tarafından sağlananlar)data klasörü verilerinizi tutmak için kullanılabilir (“ham” ve “temiz” alt klasörler dahildir)Bir .dosyası, böylece alt klasörlerdeki dosyaları bu kök klasörle ilişkilerine göre çağırmak için paketini kullanabilirsiniz (ayrıntılar için R projeleri sayfasına bakabilirsiniz)Bu R projesini bir Github deposuna bağlamanız durumunda bir gitignore dosyası oluşturulur (bkz. [Sürüm kontrolü ve Github ile işbirliği])Github deposu kullanıyorsanız, boş bir BENİOKU dosyası oluşur.UYARI: bilgisayarınızın ayarına bağlı olarak, “.” gibi dosyalar var olabilir ancak görünmez olabilir.Varsayılan ayarlardan, ‘new_factory()’ komutuyla ayarlamak isteyebileceğiniz birkaç tanesi aşağıdadır:factory = - Fabrika klasörü için bir ad girin (varsayılan “new_factory”)path = - Yeni fabrika için bir dosya yolu belirleyin (varsayılan çalışma dizinidir)report_sources = R Markdown komut dosyalarını içeren alt klasör için alternatif bir ad sağlayın (varsayılan “report_sources”)outputs = Rapor çıktılarını tutan klasör için alternatif bir ad sağlayın (varsayılan “outputs”)Değişkenlerin tam listesi için “?new_factory” konusuna bakabilirsiniz.Yeni fabrika oluşturduğunuzda, R oturumunuz yeni R projesine aktarılır, bu nedenle reportfactory paketini tekrar yüklemelisiniz.Artık fabrikadaki iç yapıyı (tüm klasörler ve dosyalar) görmek için factory_overview() komutunu çalıştırabilirsiniz.Fabrika klasörlerinin ve dosyalarının aşağıdaki “ağacı” R konsoluna yazdırılır. “Veri” klasöründe “ham” ve “temiz” veriler ve örnek CSV verileri için alt klasörler bulunduğunu unutmayın. Ayrıca “report_sources” klasöründe “example_report.Rmd” vardır.","code":"\n# Bu, fabrikayı çalışma dizininde yaratacaktır.\nnew_factory()\npacman::p_load(reportfactory)\nfactory_overview()            # fabrikaya genel bakışı konsola yazdır"},{"path":"rutin-raporların-düzenlenmesi.html","id":"bir-rapor-oluşturun","chapter":"41 Rutin raporların düzenlenmesi","heading":"41.3 Bir rapor oluşturun","text":"Fabrika R projesinin içinden, normalde yaptığınız gibi bir R Markdown raporu oluşturun ve bunu “report_sources” klasörüne kaydedin. Talimatlar için R Markdown sayfasına bakabilirsiniz. Örnek olması açısından, fabrikaya aşağıdakileri ekledik:“report_sources” klasörüne kaydedilen “daily_sitrep.Rmd” başlıklı yeni bir R işaretleme komut dosyasıRapor (“linelist_cleaned.rds”) verileri, “data” klasörü içindeki “clean” alt klasörüne kaydedilirfactory_overview() kullanarak “report_sources” klasöründeki R Markdown’ımızı ve “clean” veri klasöründeki (vurgulanan) veri dosyasını görebiliriz:Aşağıda, R Markdown “daily_sitrep.Rmd” başlangıcının bir ekran görüntüsü bulunmaktadır. YAML başlığı “output: html_document” aracılığıyla çıktı biçiminin HTML olarak ayarlandığını görebilirsiniz.Bu basit komut dosyasında şu komutlar vardır:Gerekli paketleri yükleyinhere paketindeki bir dosya yolunu kullanarak satır listesi verilerini içe aktarın (daha fazlasını [İçe aktarma ve dışa aktarma] sayfasından okuyun)Vakaların bir özet tablosunu yazdırın ve bunu bir .csv dosyası olarak export() ile dışa aktarınBir salgın eğrisi yazdırın ve ggsave() ile .png dosyası olarak dışa aktarınBu komutla “report_sources” klasöründeki yalnızca R Markdown raporlarının listesini inceleyebilirsiniz:","code":"\nlinelist <- import(here(\"data\", \"clean\", \"linelist_cleaned.rds\"))\nlist_reports()"},{"path":"rutin-raporların-düzenlenmesi.html","id":"derlemek-compile","chapter":"41 Rutin raporların düzenlenmesi","heading":"41.4 Derlemek (Compile)","text":"Bir rapor fabrikasında, bir R Markdown raporunu “derlemek”, .Rmd komut dosyasının çalıştırılacağı ve çıktının üretileceği anlamına gelir (YAML komut dosyasında belirtildiği gibi, örneğin HTML, Word, PDF, vb. olarak).Fabrika, “outputs” klasöründeki çıktılar için otomatik olarak tarih ve zaman damgalı bir klasör oluşturacaktır.Raporun kendisi ve komut dosyası tarafından üretilen tüm dışa aktarılan dosyalar (örn. csv, png, xlsx) bu klasöre kaydedilecektir. Ek olarak, Rmd betiğinin kendisi bu klasöre kaydedilecektir, böylece betiğin o sürümünün bir kaydı olur.Bu, çıktıları Rmd komut dosyasının konumuna kaydeden “örülmüş” bir R Markdown’ın normal davranışıyla çelişir. Bu varsayılan davranış, kalabalık, dağınık klasörlere neden olabilir. Fabrika, sık sık rapor çalıştırması gerektiğinde organizasyonu iyileştirmeyi amaçlar.","code":""},{"path":"rutin-raporların-düzenlenmesi.html","id":"adına-göre-derleyin","chapter":"41 Rutin raporların düzenlenmesi","heading":"Adına göre derleyin","text":"Belirli bir raporu ‘compile_reports()’ çalıştırarak ve Rmd komut dosyası adını (.Rmd uzantısı olmadan) ‘reports =’ olarak sağlayarak derleyebilirsiniz. Basit olması için, reports = kısmını atlayabilir ve R Markdown adını aşağıdaki gibi tırnak işaretleri içinde yazabilirsiniz.Bu komut, yalnızca “daily_sitrep.Rmd” raporunu derleyerek, HTML raporunu ve .csv tablosunu ve .png epicurve dışa aktarmalarını, “outputs” klasörü içinde, rapora özel tarih ve zaman damgalı bir alt klasöre kaydeder..Rmd uzantısını sağlamayı seçerseniz, uzantıyı dosya adına kaydedilirken doğru şekilde yazmanız gerektiğini unutmayın (.rmd ve .Rmd).Ayrıca, derlerken, “report_sources” klasöründe geçici olarak birkaç dosyanın görünebileceğini unutmayın - ancak doğru “outputs” klasörüne aktarıldıkları için kısa sürede kaybolacaklardır.","code":""},{"path":"rutin-raporların-düzenlenmesi.html","id":"numarasına-göre-derleyin","chapter":"41 Rutin raporların düzenlenmesi","heading":"Numarasına göre derleyin","text":"Ayrıca, reports = için bir sayı veya sayı vektörü sağlayarak derlenecek Rmd betiğini de belirtebilirsiniz. Rakamlar, list_reports() çalıştırdığınızda raporların göründüğü sıraya göre hizalanmalıdır.","code":"\n# İkinci ve dördüncü Rmds'yi \"report_sources\" klasöründe derleyin\ncompile_reports(reports = c(2, 4))"},{"path":"rutin-raporların-düzenlenmesi.html","id":"tümünü-derleyin","chapter":"41 Rutin raporların düzenlenmesi","heading":"Tümünü Derleyin","text":"“report_sources” klasöründeki tüm R Markdown raporlarını, reports = değişkenini TRUE olarak ayarlayarak derleyebilirsiniz.","code":""},{"path":"rutin-raporların-düzenlenmesi.html","id":"alt-klasöründen-derleyin","chapter":"41 Rutin raporların düzenlenmesi","heading":"Alt klasöründen derleyin","text":"“report_sources” klasörüne alt klasörler ekleyebilirsiniz. Bir alt klasörden R Markdown raporu çalıştırmak için, klasörün adını subfolder = olarak sağlamanız yeterlidir. Aşağıda, “report_sources” alt_klasöründe yaşayan bir Rmd raporunu derlemek için bir kod örneği verilmiştir.Aşağıdaki gibi sonunda bir eğik çizgi ile reports = alt klasör adını sağlayarak bir alt klasör içindeki tüm Rmd raporlarını derleyebilirsiniz.","code":"\ncompile_reports(\n     reports = \"summary_for_partners.Rmd\",\n     subfolder = \"for_partners\")\ncompile_reports(reports = \"for_partners/\")"},{"path":"rutin-raporların-düzenlenmesi.html","id":"parametrelendirme","chapter":"41 Rutin raporların düzenlenmesi","heading":"Parametrelendirme","text":"R Markdown ile Raporlar sayfasında belirtildiği gibi, belirtilen parametrelerle raporlar çalıştırabilirsiniz. Bu parametreleri, ‘params =’ değişkeni aracılığıyla ‘compile_reports()’ öğesine bir liste olarak iletebilirsiniz. Örneğin, bu kurgusal raporda, R Markdown raporlarına sağlanan üç parametre vardır.","code":"\ncompile_reports(\n  reports = \"daily_sitrep.Rmd\",\n  params = list(most_recent_data = TRUE,\n                region = \"NORTHERN\",\n                rates_denominator = 10000),\n  subfolder = \"regional\"\n)"},{"path":"rutin-raporların-düzenlenmesi.html","id":"çalışma-dosyası-kullanma","chapter":"41 Rutin raporların düzenlenmesi","heading":"“Çalışma dosyası” kullanma","text":"Çalıştırılacak birden fazla raporunuz varsa, tüm ‘compile_reports()’ komutlarını içeren bir R betiği oluşturmayı düşünün. Bir kullanıcı bu R betiğindeki tüm komutları basitçe çalıştırabilir ve tüm raporlar derlenecektir. Bu “run-file” dosyasını “scripts” klasörüne kaydedebilirsiniz.","code":""},{"path":"rutin-raporların-düzenlenmesi.html","id":"çıktılar-1","chapter":"41 Rutin raporların düzenlenmesi","heading":"41.5 Çıktılar","text":"Raporları birkaç kez derledikten sonra, “outputs” klasörü şöyle görünebilir (açıklık için vurgular eklendi):“Outputs” içerisinde bir Rmd raporu için alt klasörler oluşturulmuştur.Bunların içinde, benzersiz derleme için başka alt klasörler oluşturulmuştur.\nBunlar tarih ve zaman damgalıdır (“2021-04-23_T11-07-36”, 23 Nisan 2021, 11:07:36 anlamına gelir)\nTarih/zaman damgası biçimini düzenleyebilirsiniz. ?compile_reports konusuna bakabilirsiniz.\nBunlar tarih ve zaman damgalıdır (“2021-04-23_T11-07-36”, 23 Nisan 2021, 11:07:36 anlamına gelir)Tarih/zaman damgası biçimini düzenleyebilirsiniz. ?compile_reports konusuna bakabilirsiniz.bir tarih/saat derlenmiş klasöründe, rapor çıktısı (ör. HTML, PDF, Word) Rmd betiği (sürüm kontrolü!) ve dışa aktarılan diğer dosyalar (ör. table.csv, epidemi_curve.png) ile birlikte depolanır.“daily_sitrep” raporu için tarih/saat damgalı klasörlerden birinin içindeki bir görünüm buradadır. Dosya yolu, vurgu için sarı renkle vurgulanmıştır.Son olarak, aşağıda HTML rapor çıktısının bir ekran görüntüsü bulunmaktadır.Çıktıların listesini gözden geçirmek için list_outputs() kullanabilirsiniz.","code":""},{"path":"rutin-raporların-düzenlenmesi.html","id":"muhtelif-içerikler","chapter":"41 Rutin raporların düzenlenmesi","heading":"41.6 Muhtelif İçerikler","text":"","code":""},{"path":"rutin-raporların-düzenlenmesi.html","id":"knit","chapter":"41 Rutin raporların düzenlenmesi","heading":"Knit","text":"İsterseniz “knit” düğmesine basarak R Markdown raporlarınızdan birini hala “örebilirsiniz”. Bunu yaparsanız, varsayılan olarak, çıktılar Rmd’nin kaydedildiği klasörde - “report_sources” klasöründe görünecektir. reportfactory’nin önceki sürümlerinde, “report_sources” içinde Rmd olmayan dosyaların bulunması derlemeyi engellerdi, ancak artık durum böyle değil. compile_reports() komutunu çalıştırabilirsiniz ve herhangi bir hata oluşmaz.","code":""},{"path":"rutin-raporların-düzenlenmesi.html","id":"betikler","chapter":"41 Rutin raporların düzenlenmesi","heading":"Betikler","text":".Rmd komut dosyalarınız tarafından sağlanan “runfiles” veya .R komut dosyalarını depolamak için “scripts” klasörünü kullanmanızı öneririz. Kodunuzu birkaç dosyada nasıl yapılandıracağınıza ilişkin ipuçları için R Markdown hakkındaki sayfaya bakabilirsiniz.","code":""},{"path":"rutin-raporların-düzenlenmesi.html","id":"ekstralar","chapter":"41 Rutin raporların düzenlenmesi","heading":"Ekstralar","text":"reportfactory ile, tüm fabrikadaki tüm raporlarda gerekli tüm paketleri listelemek için ‘list_deps()’ fonksiyonunu kullanabilirsiniz.reportfactory ile, tüm fabrikadaki tüm raporlarda gerekli tüm paketleri listelemek için ‘list_deps()’ fonksiyonunu kullanabilirsiniz.Geliştirme aşamasında, raporların oluşturulmasında size yardımcı olacak daha fazla yardımcı fonksiyon sunan rfextras adlı bir paket vardır, örneğin:\nload_scripts() - belirli bir klasördeki tüm .R komut dosyalarını kaynaklar/yükler (varsayılan olarak “scripts” klasörü)\nfind_latest() - bir dosyanın en son sürümünü bulur (örneğin, en son veri kümesi)\nGeliştirme aşamasında, raporların oluşturulmasında size yardımcı olacak daha fazla yardımcı fonksiyon sunan rfextras adlı bir paket vardır, örneğin:load_scripts() - belirli bir klasördeki tüm .R komut dosyalarını kaynaklar/yükler (varsayılan olarak “scripts” klasörü)find_latest() - bir dosyanın en son sürümünü bulur (örneğin, en son veri kümesi)","code":""},{"path":"rutin-raporların-düzenlenmesi.html","id":"kaynaklar-33","chapter":"41 Rutin raporların düzenlenmesi","heading":"41.7 Kaynaklar","text":"reportfactory paketleri Github sayfasırfextras paketleri Github sayfası","code":""},{"path":"r-markdown-ile-gösterge-panelleri.html","id":"r-markdown-ile-gösterge-panelleri","chapter":"42 R Markdown ile gösterge panelleri","heading":"42 R Markdown ile gösterge panelleri","text":"Bu sayfa, flexdashboard paketinin temel kullanımını kapsayacaktır. Bu paket, R Markdown çıktısını paneller ve sayfalar içeren bir pano olarak kolayca biçimlendirmenize olanak tanır. Pano içeriği metin, istatistik şekiller/tablolar veya etkileşimli grafikler olabilir.Flexdashboard’un avantajları:\n• Minimum düzeyde standart dışı R kodlaması gerektirir - çok az pratikle hızlı bir şekilde bir gösterge paneli oluşturabilirsiniz\n• Kontrol panelini genellikle bağımsız bir HTML dosyası olarak e-postayla gönderilebilirsiniz - sunucu gerekmez\n• Etkileşim eklemek için flexdashboard’u shiny, ggplotly ve diğer “html widget’ları” ile birleştirebilirsinizFlexdashboard’un dezavantajları:\n• Bir gösterge paneli oluşturmak için tek başına shiny kullanmaya kıyasla daha az özelleştirmeBu sayfadaki bilgilerin esas kaynağı olan, esnek panel kullanımına ilişkin çok kapsamlı bilgileri kaynaklar bölümünde bulunabilir. Aşağıda, paketin temel özelliklerini açıklıyoruz ve vaka satır listesi verilerini kullanarak salgını araştırmak için bir gösterge paneli oluşturmaya ilişkin bir örnek veriyoruz.","code":""},{"path":"r-markdown-ile-gösterge-panelleri.html","id":"hazırlık-34","chapter":"42 R Markdown ile gösterge panelleri","heading":"42.1 Hazırlık","text":"","code":""},{"path":"r-markdown-ile-gösterge-panelleri.html","id":"paketlerin-yüklenmesi-7","chapter":"42 R Markdown ile gösterge panelleri","heading":"Paketlerin yüklenmesi","text":"Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’ın p_load() fonksiyonunu vurguluyoruz. Ayrıca, temel R’dan library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R’ın temelleri sayfasına bakın.","code":"\npacman::p_load(\n  rio,             # verinin içe / dışa aktarımı   \n  here,            # dosyaları bul\n  tidyverse,       # veri yönetimi ve görselleştirme\n  flexdashboard,   # R Markdown raporlarının panel sürümleri\n  shiny,           # interaktif figürler\n  plotly           # interaktif figürler\n)"},{"path":"r-markdown-ile-gösterge-panelleri.html","id":"verileri-içe-aktarın","chapter":"42 R Markdown ile gösterge panelleri","heading":"Verileri içe aktarın","text":"Simüle edilmiş bir Ebola salgını vakalarının veri setini içe aktarıyoruz. Devam etmek istiyorsanız, “temiz” satır listesini (.rds dosyası olarak) indirmek için tıklayın. Verileri rio paketinden import() fonksiyonuyla içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için İçe Aktarma ve Dışa Aktarma sayfasına bakabilirsiniz).click download “clean” linelistSatır listesinin ilk 50 satırı aşağıda gösterilmiştir.","code":"\n# satır listesini içe aktarma\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"r-markdown-ile-gösterge-panelleri.html","id":"yeni-bir-r-markdown-oluştur","chapter":"42 R Markdown ile gösterge panelleri","heading":"42.2 Yeni bir R Markdown oluştur","text":"Paketi kurduktan sonra, Dosya > Yeni dosya > R Markdown yolunu kullanarak yeni bir R Markdown dosyası oluşturun.Açılan pencerede “Template-Şablondan”ı seçin ve “Flex Dashboard” şablonunu seçin. Daha sonra belgeyi adlandırmanız istenecektir. Bu sayfanın örneğinde, R Markdown’ımızı “outbreak_dashboard.Rmd” olarak adlandıracağız.","code":""},{"path":"r-markdown-ile-gösterge-panelleri.html","id":"komutlar","chapter":"42 R Markdown ile gösterge panelleri","heading":"42.3 Komutlar","text":"Komut dosyası bir R Markdown komut dosyasıdır ve bu nedenle R Markdown ile Raporlar sayfasında açıklananla aynı bileşenlere ve organizasyona sahiptir. Bunları kısaca yeniden inceleyeceğiz ve diğer R Markdown çıktı biçimlerinden farklılıklarını vurgulayacağız.","code":""},{"path":"r-markdown-ile-gösterge-panelleri.html","id":"yaml","chapter":"42 R Markdown ile gösterge panelleri","heading":"YAML","text":"Komut dosyasının en üstünde “YAML” başlığı bulunur. Bu kısım, üç tire ile başlamalı — ve üç tire ile kapatılmalıdır —. YAML parametreleri anahtar:değer çiftleri halinde gelir. YAML’de iki nokta üst üste işaretinin girintisi ve yerleşimi önemlidir - anahtar:değer çiftleri iki nokta üst üste ile ayrılır (eşittir işaretleri değil!).YAML, belge için meta verilerle başlamalıdır. Bu birincil YAML parametrelerinin (girintisiz) sırası önemli değildir. Örneğin:YAML değerlerinde R kodunu, satır içi kod gibi (backticks içinde r’den önce gelir) veya tırnak işaretleri içine koyarak (Tarih için yukarıya bakın) kullanabilirsiniz. Üretilecek dosyanın türünü bir YAML parametresi çıktısı belirtir. (ör. html_document, pdf_document, word_document veya powerpoint_presentation).Flexdashboard için bu parametre değeri biraz kafa karıştırıcıdır - output:flexdashboard::flex_dashboard olarak ayarlanmalıdır. Tek ve çift sayıda iki nokta üst üste ve alt çizgiye noktalama işaretlerine dikkat edin. Bu YAML çıktı parametresini genellikle ek bir iki nokta üst üste ve girintili alt parametreler izler (aşağıdaki orientation:-oryantasyon: ve vertical_layout: -dikey_düzen: parametrelere bakın).Yukarıda gösterildiği gibi, alt parametreler için girintiler (2 boşluk) kullanılır. Bu durumda, birincilden sonra anahtar:değer: gibi ek bir iki nokta üst üste koymayı unutmayın.Uygunsa, mantık değerleri YAML’de küçük harfle (true, false, null) verilmelidir. İki nokta üst üste karakteri değerinizin bir parçasıysa (örneğin başlıkta), değeri tırnak içine alın. Aşağıdaki bölümlerdeki örneklere bakın.","code":"\ntitle: \"My document\"\nauthor: \"Me\"\ndate: \"`r Sys.Date()`\"\ntitle: \"My dashboard\"\nauthor: \"Me\"\ndate: \"`r Sys.Date()`\"\noutput:\n  flexdashboard::flex_dashboard:\n    orientation: rows\n    vertical_layout: scroll"},{"path":"r-markdown-ile-gösterge-panelleri.html","id":"kod-parçaları-1","chapter":"42 R Markdown ile gösterge panelleri","heading":"Kod parçaları","text":"Bir R Markdown komut dosyası birden çok kod “parçası” içerebilir - bunlar komut dosyasının çok satırlı R kodu yazabileceğiniz alanlarıdır ve tıpkı mini R komut dosyaları gibi çalışırlar.Kod parçaları, içinde küçük bir “r” harfi bulunan üç ters tik işareti ve küme parantezleri ile oluşturulur. Kod parçası, üç ters tik ile kapatılır. Kendiniz yazarak, “Ctrl + Alt + ” (veya Mac’te Cmd + Shift + r) klavye kısayolunu kullanarak veya komut dosyası düzenleyicinizin en üstünde ‘yeni bir kod parçası ekle’ simgesini tıklayarak yeni bir kod parçası oluşturabilirsiniz.. Aşağıda birçok örnek verilmiştir.","code":""},{"path":"r-markdown-ile-gösterge-panelleri.html","id":"anlatı-metni","chapter":"42 R Markdown ile gösterge panelleri","heading":"Anlatı metni","text":"Bir R kodu “parçası” dışında, anlatı metni de yazabilirsiniz. R Markdown ile Raporlar sayfasında açıklandığı gibi, metni bir yıldız işaretiyle (*) çevreleyerek italik veya iki yıldız işaretiyle (**) çevreleyerek kalın yazabilirsiniz. Madde işaretleri ve numaralandırma düzenlerinin yeni satırlara, girintilere ve iki boşlukla bir satırı bitirmeye duyarlı olduğunu hatırlayın.Ayrıca satır içi R kodunu, R Markdown ile Raporlar sayfasında açıklandığı gibi, kodu ters tiklerle çevreleyerek ve komutu “r”: 1+1 ile başlatarak metne ekleyebilirsiniz (yukarıdaki tarih içeren örneğe bakın).","code":""},{"path":"r-markdown-ile-gösterge-panelleri.html","id":"başlıklar-1","chapter":"42 R Markdown ile gösterge panelleri","heading":"Başlıklar","text":"R Markdown ile Raporlar sayfasında açıklandığı gibi, farklı sayıda hash sembolü ile farklı başlık seviyeleri oluşturulur.Flexdashboard’da, birincil başlık (#) gösterge tablosunun bir “sayfasını” oluşturur. İkinci düzey başlıklar (##), oryantasyonunuza bağlı olarak bir sütun veya satır oluşturur: Parametre (aşağıdaki ayrıntılara bakın). Üçüncü düzey başlıklar (###) çizimler, çizelgeler, tablolar, metin vb. için paneller oluşturur.","code":"# Birinci düzey başlık (sayfa)\n\n## İkinci düzey başlık (satır veya sütun)\n\n### Üçüncü düzey başlık (çizim, çizelge vb. için bölme) "},{"path":"r-markdown-ile-gösterge-panelleri.html","id":"bölüm-özellikleri","chapter":"42 R Markdown ile gösterge panelleri","heading":"42.4 Bölüm Özellikleri","text":"Normal bir R Markdown dosyasında olduğu gibi, bir başlıktan sonra, küme parantezleri { } içinde anahtar=değer seçeneklerini ekleyerek gösterge tablonuzun bölümlerine uygulanacak özellikleri belirleyebilirsiniz. Örneğin, tipik bir HTML R Markdown raporunda, ## Başlığım {.tabset} ile alt başlıkları sekmeler halinde düzenleyebilirsiniz. Bu niteliklerin, komut dosyasının metin bölümünde bir başlıktan sonra yazıldığını unutmayın. Bunlar, .height = gibi R kodu parçalarının üstüne eklenen knitr seçeneklerinden farklıdır.Flexdashboard’özgü bölüm özellikleri şunları içerir:\n• {data-orientation=} Satırlara veya sütunlara göre ayarlama. Gösterge panelinizde birden fazla sayfa varsa, oryantasyonu belirtmek için bu özelliği sayfaya ekleyin (düzen bölümünde daha ayrıntılı açıklanmıştır).\n• {data-width=} ve {data-height=}, aynı boyutta (yatay veya dikey) düzenlenen grafiklerin, sütunların, satırların göreli boyutunu ayarlar. Flexbox motoru sayesinde mutlak boyutlar, herhangi bir görüntüleme cihazındaki alanı en iyi şekilde dolduracak şekilde ayarlanır.\n• Grafiklerin yüksekliği, YAML parametresini vertical_layout: fill (dolgu) olarak mı yoksa vertical_layout: scroll (kaydırma) olarak mı ayarladığınıza da bağlıdır. Kaydırılacak şekilde ayarlanırsa, şekil yüksekliği, R kodu öbeğindeki geleneksel fig.height = seçeneğini yansıtacaktır.\n• flexdashboard web sitesindeki tam boyut belgelerine bakın\n• {.hidden} Belirli bir sayfayı gezinme çubuğundan hariç tutmak için bunu kullanın\n• {data-navbar=} Bunu, bir gezinme çubuğu açılır menüsü içine yerleştirmek için sayfa düzeyinde bir başlıkta kullanın. Açılır menünün adını (tırnak içinde) belirtin. Aşağıdaki örneğe bakın.","code":""},{"path":"r-markdown-ile-gösterge-panelleri.html","id":"layout","chapter":"42 R Markdown ile gösterge panelleri","heading":"42.5 Yerleşim Düzeni","text":"Kontrol panelinizin düzenini aşağıdaki şekillerde ayarlayın:\n• R Markdown başlıklarına sahip sayfalar, sütunlar/satırlar ve grafikler ekleyin (ör. #, ## veya ###)\n• YAML parametre yönünü ayarlayın: Satırlara veya sütunlara\n• Düzenin tarayıcıyı dolduracağını ya da kaydırmaya mı izin vereceğini belirtin\n• Belirli bir bölüm başlığına sekmeler ekleyin","code":""},{"path":"r-markdown-ile-gösterge-panelleri.html","id":"sayfalar","chapter":"42 R Markdown ile gösterge panelleri","heading":"Sayfalar","text":"R Markdown’daki birinci düzey başlıklar (#), gösterge tablosunun “sayfalarını” temsil edecektir.\nVarsayılan olarak sayfalar, gösterge tablosunun üst kısmındaki bir gezinme çubuğunda görünür.Sayfa başlığına {data-navmenu=} özelliğini ekleyerek sayfaları üst gezinme çubuğunda bir “menü” halinde gruplayabilirsiniz. Dikkatli olun - eşittir işaretinin etrafına boşluk eklemeyin, aksi takdirde çalışmaz!İşte betiğin ürettiği:{.sidebar} özelliği ekleyerek, bir sayfayı veya sütunu kontrol panelinin sol tarafında bir “kenar çubuğuna” da dönüştürebilirsiniz. Metni (herhangi bir sayfadan görüntülenebilir) veya entegre shiny etkileşiminiz varsa, kaydırıcılar veya açılır menüler gibi kullanıcı giriş kontrollerini eklemek faydalı olabilir.İşte betiğin ürettiği:","code":""},{"path":"r-markdown-ile-gösterge-panelleri.html","id":"oryantasyon","chapter":"42 R Markdown ile gösterge panelleri","heading":"Oryantasyon","text":"İkinci düzey (##) R Markdown başlıklarınızın nasıl yorumlanması gerektiğini belirtmek için oryantasyon: yaml parametresini ayarlayın - oryantasyon: sütunlar (orientation: columns) veya oryantasyon: satırlar (orientation: rows) olarak.İkinci düzey başlıklar (##), bu yönlendirme ayarına göre yeni sütunlar veya satırlar olarak yorumlanacaktır.Oryantasyon: sütunlar (orientation: columns) olarak ayarlarsanız, ikinci düzey başlıklar gösterge tablosunda yeni sütunlar oluşturur. Aşağıdaki gösterge paneli, toplam üç panel içeren iki sütun içeren bir sayfaya sahiptir. Sütunların göreli genişliğini aşağıda gösterildiği gibi {data-width=} ile ayarlayabilirsiniz.İşte betiğin ürettiği:Oryantasyon: satırlar (orientation: rows)olarak ayarlarsanız, ikinci düzey başlıklar sütunlar yerine yeni satırlar oluşturur. Aşağıda, yukarıdakiyle aynı komut dosyası vardır, ancak oryantasyon: satırlar olarak ayarlanmıştır, böylece ikinci düzey başlıklar sütunlar yerine satırlar oluşturur. {data-height=} ile satırların göreli yüksekliğini aşağıda gösterildiği gibi ayarlayabilirsiniz.İşte betiğin ürettiği:Kontrol panelinizde birden fazla sayfa varsa, sayfanın başlığına {data-orientation=} özniteliğini ekleyerek (tırnak işaretleri olmadan satırları veya sütunları belirtin) seçili sayfanın yönünü belirleyebilirsiniz.","code":""},{"path":"r-markdown-ile-gösterge-panelleri.html","id":"sekmeler","chapter":"42 R Markdown ile gösterge panelleri","heading":"Sekmeler","text":"Diğer HTML R Markdown çıktılarında olduğu gibi içeriği {.tabset} özniteliği ile sekmelere bölebilirsiniz.Bu özelliği istediğiniz başlıktan sonra eklemeniz yeterlidir. Bu başlığın altındaki alt başlıklar sekmeler halinde görüntülenecektir. Örneğin, aşağıdaki örnek komut dosyasında sağdaki 2. sütun (##), salgın eğrisi ve tablo bölmeleri (###) sekmelerde görüntülenecek şekilde değiştirilir.Oryantasyonunuz satırlarsa, aynısını satırlarla da yapabilirsiniz.İşte betiğin ürettiği:","code":""},{"path":"r-markdown-ile-gösterge-panelleri.html","id":"içerik-ekleme","chapter":"42 R Markdown ile gösterge panelleri","heading":"42.6 İçerik Ekleme","text":"Bir kontrol paneli oluşturmaya başlayalım. Basit panomuz 1 sayfa, 2 sütun ve 4 panelden oluşacaktır. Gösteri için panelleri parça parça inşa edeceğiz.Metin, ggplot’lar ve tablolar gibi standart R çıktılarını kolayca dahil edebilirsiniz (Sunum için Tablolar sayfasına bakın). Bunları, diğer herhangi bir R Markdown betiğinde yaptığınız gibi, bir R kod parçası içinde kodlayın.: Tamamlanmış Rmd komut dosyasını ve HTML gösterge tablosu çıktısını indirebilirsiniz - El kitabı ve verilerin indirilmesi sayfasına bakın.","code":""},{"path":"r-markdown-ile-gösterge-panelleri.html","id":"metin-1","chapter":"42 R Markdown ile gösterge panelleri","heading":"Metin","text":"Markdown metnini yazabilir ve diğer herhangi bir R Markdown çıktısında olduğu gibi satır içi kod ekleyebilirsiniz. Ayrıntılar için R Markdown ile Raporlar sayfasına bakın.Bu panele, en son hastaneye yatış tarihini ve salgında bildirilen vaka sayısını gösteren dinamik metin içeren bir özet metin paneli ekledik.","code":""},{"path":"r-markdown-ile-gösterge-panelleri.html","id":"tablo","chapter":"42 R Markdown ile gösterge panelleri","heading":"Tablo","text":"Tablolar gibi çıktıları yazdıran R kodu parçalarını dahil edebilirsiniz. Ancak, tablolarınızı görüntülemek için knitr’den kable() fonksiyonunu kullanırsanız, çıktı en iyi şekilde görünecek ve pencere boyutuna yanıt verecektir. Flextable fonksiyonları, kısaltılmış/kesilmiş tablolar üretebilir.\nÖrneğin, hastaneye göre vakaların özet bir tablosunu oluşturmak için aşağıda linelist()’bir count() komutuyla besliyoruz. Sonuç olarak, tablo knitr::kable()’yönlendirilir ve sağ tarafında bir kaydırma çubuğu bulunur. Panelinizi kable() ve kableExtra ile özelleştirme hakkında daha fazla bilgiyi burada bulabilirsiniz. buradan.İşte betiğin ürettiği:Kullanıcının veri çerçevesinin “sayfalarını” filtrelemesine, sıralamasına ve/veya tıklamasına izin veren dinamik bir tablo oluşturmak istiyorsanız, aşağıdaki kodda olduğu gibi DT paketini ve onun datatable() fonksiyonunu kullanın.Aşağıdaki örnek kod, veri çerçevesi satır listesi yazdırılır. Yatay alanı korumak için rownames = FALSE ve sütunun üstünde filtreler olması için filter = “top” argümanını ayarlayabilirsiniz. options = argümanı diğer özelliklerin bir listesi verebilir. Aşağıda, 5 satır görünecek şekilde pageLength = argümanını ve kullanıcının yatay olarak kaydırmak için alttaki kaydırma çubuğunu kullanabilmesi için scrollX = argümanını ayarladık. class = ‘white-space: nowrap’ argümanı, satırın yalnızca bir satır (birden çok satır değil) içermesini sağlar. Diğer olası argümanlar ve değerler hakkında buradan veya ?datatable komutunu girerek bilgi edinebilirsiniz.","code":"\nDT::datatable(linelist, \n              rownames = FALSE, \n              options = list(pageLength = 5, scrollX = TRUE), \n              class = 'white-space: nowrap' )"},{"path":"r-markdown-ile-gösterge-panelleri.html","id":"grafikler","chapter":"42 R Markdown ile gösterge panelleri","heading":"Grafikler","text":"Grafikleri, bir R komut dosyasında olduğu gibi bir panel bölmesine yazdırabilirsiniz. Örneğimizde, iki basit komutla yaş grubuna göre bir “salgın eğrisi” oluşturmak için incidence2 paketini kullanıyoruz (bkz. Salgın eğriler sayfası). Ancak, ggplot()’u kullanabilir ve aynı şekilde bir grafik oluşturabilirsiniz.İşte betiğin ürettiği:","code":""},{"path":"r-markdown-ile-gösterge-panelleri.html","id":"interaktif-grafikler","chapter":"42 R Markdown ile gösterge panelleri","heading":"İnteraktif grafikler","text":"Ayrıca standart bir ggplot veya başka bir grafik nesnesini plotly paketinden ggplotly() fonksiyonuna iletebilirsiniz (İnteraktif grafikler sayfasına bakabilirsiniz). Bu, grafiğinizi interaktif hale getirecek, okuyucunun “yaklaştırmasına” ve veri noktasının değerinin (bu senaryoda eğrideki haftalık vaka sayısı ve yaş grubu) üzerinde fareyle gezinerek göstermesine izin verecektir.Gösterge panelinde bunun nasıl göründüğü aşağıda açıklanmıştır(gif). Bu interaktif fonksiyon, paneli statik bir dosya olarak e-posta olarak gönderseniz bile (bir sunucuda çevrimiçi değil) çalışmaya devam edecektir.","code":"\nage_outbreak <- incidence(linelist, date_onset, \"week\", groups = age_cat)\nplot(age_outbreak, fill = age_cat, col_pal = muted, title = \"\") %>% \n  plotly::ggplotly()"},{"path":"r-markdown-ile-gösterge-panelleri.html","id":"html-araçları-1","chapter":"42 R Markdown ile gösterge panelleri","heading":"HTML Araçları","text":"R için HTML widget’ları, JavaScript kitaplıklarını kullanarak etkileşimi artıran özel bir R paketi sınıfıdır. Bunları R Markdown çıktılarına (bir flexdashboard gibi) ve shiny panolara gömebilirsiniz.Bu widget’ların bazı yaygın örnekleri şunları içerir:• Plotly (Bu el kitabı sayfasında ve İnteraktif grafikler sayfasında kullanılır)\n• visNetwork (Bu el kitabının İletim Zincirleri sayfasında kullanılır)\n• Leaflet (Bu el kitabının GIS Temelleri sayfasında kullanılır)\n• dygraphs (Zaman serisi verilerini etkileşimli olarak göstermek için kullanışlıdır)\n• DT (datatable()) (filtre, sıralama vb. ile dinamik tabloları göstermek için kullanılır)Aşağıda, gösterge paneline visNetwork kullanan bir salgın iletim zinciri eklemeyi gösteriyoruz. Komut dosyası, yalnızca R Markdown komut dosyasının “Sütun 2” bölümüne eklenen yeni kodu gösterir. Kodu, bu el kitabının İletim zincirleri sayfasında bulabilirsiniz.İşte betiğin ürettiği:","code":""},{"path":"r-markdown-ile-gösterge-panelleri.html","id":"kodun-düzenlenmesi","chapter":"42 R Markdown ile gösterge panelleri","heading":"42.7 Kodun düzenlenmesi","text":"Tüm kodun R Markdown flexdashboard komut dosyası içinde olmasını seçebilirsiniz. Alternatif olarak, daha temiz ve yoğun bir pano komut dosyasına sahip olmak için, harici R komut dosyalarında bulunan veya oluşturulan kod/şekilleri çağırmayı seçebilirsiniz. R Markdown ile Raporlar sayfasında daha ayrıntılı olarak açıklanmaktadır.","code":""},{"path":"r-markdown-ile-gösterge-panelleri.html","id":"shiny","chapter":"42 R Markdown ile gösterge panelleri","heading":"42.8 Shiny","text":"Shiny R paketini entegre etmek, gösterge panellerini kullanıcı girdilerine karşı daha da reaktif hale getirebilir. Örneğin, kullanıcının bir yetki alanı veya bir tarih aralığı seçmesini ve panellerin seçimlerine tepki vermesini sağlayabilirsiniz (örneğin, görüntülenen verileri filtreleme). Shiny’nin reaktif özelliklerini flexdashboard’gömmek için, flexdashboard R Markdown betiğinizde sadece birkaç değişiklik yapmanız yeterlidir.flexdashboard olmadan da uygulamalar/gösterge panoları oluşturmak için shiny’kullanabilirsiniz. Shiny ile gösterge panelleri sayfası, shiny sintaksı, uygulama dosyası yapısı ve paylaşım/yayınlama seçenekleri (ücretsiz sunucu seçenekleri dahil) ile ilgili temel bilgiler dahil olmak üzere bu yaklaşıma genel bir bakış sunar. Bu sintaks ve genel ipuçları, flexdashboard bağlamında da düşünülebilir.Ancak, flexdashboard’shiny’yerleştirmek, flexdashboard’unuz için temel bir değişikliktir. Artık e-posta ile gönderebileceğiniz ve herkesin açıp görüntüleyebileceği bir HTML çıktısı üretmeyecektir. Bunun yerine, bir “uygulama” olacaktır. Komut dosyasının üstündeki “Knit-Ör” düğmesinin yerini, etkileşimli panelin bir örneğini bilgisayarınızda yerel olarak açacak olan bir ” Run document- Belgeyi çalıştır” simgesi alacaktır.Kontrol panelinizi paylaşmak artık şunları yapmanızı gerektirecek:• Rmd komut dosyasını görüntüleyiciye gönderin, bilgisayarlarınızda R’da açın ve uygulamayı çalıştırın veya\n• Uygulama/pano, izleyicinin erişebileceği bir sunucuda saklanmalıdırBu nedenle, shiny entegrasyonun faydaları vardır, aynı zamanda komplikasyonları da vardır. E-posta ile kolay paylaşım bir öncelikse ve shiny’nin reaktif özelliklerine ihtiyacınız yoksa, yukarıda gösterildiği gibi ggplotly() tarafından sunulan azaltılmış etkileşimli versiyonu düşünün.Aşağıda, yukarıdakiyle aynı “outbreak_dashboard.Rmd”yi kullanarak çok basit bir örnek veriyoruz. Shiny’yi flexdashboard’entegre etmeye ilişkin kapsamlı belgeleri buradan çevrimiçi olarak okuyabilirsiniz.","code":""},{"path":"r-markdown-ile-gösterge-panelleri.html","id":"ayarlar-2","chapter":"42 R Markdown ile gösterge panelleri","heading":"Ayarlar","text":"Aşağıdaki gibi çıktı (output:) ile aynı girinti düzeyinde YAML parametresi ekleyerek (runtime: shiny) flexdashboard‘da shiny özelliğini etkinleştirin:Kullanıcıdan bilgi toplayacak shiny giriş widget’larını tutmak için bir “kenar çubuğunu-side bar” etkinleştirmek de uygundur. Yukarıda açıklandığı gibi, bir sütun oluşturun ve sol tarafta bir kenar çubuğu oluşturmak için {.sidebar} seçeneğini belirtin. Bu sütuna shiny giriş komutlarını içeren metin ve R parçaları ekleyebilirsiniz.Uygulamanız/gösterge tablonuz bir sunucudaysa ve aynı anda birden çok kullanıcıya sahipse, ilk R kodu parçasına “global” adını verin. Verilerinizi içe aktarmak/yüklemek için bu kod parçasına gereken komutları ekleyin. Bu özel adlandırılmış kod parçası farklı şekilde ele alınır ve içine aktarılan veriler yalnızca bir kez içe aktarılır (sürekli değil) ve tüm kullanıcılar tarafından kullanılabilir. Bu, uygulamanın başlatma hızını artırır.","code":"---\ntitle: \"Outbreak dashboard (Shiny demo)\"\noutput: \n  flexdashboard::flex_dashboard:\n    orientation: columns\n    vertical_layout: fill\nruntime: shiny\n---"},{"path":"r-markdown-ile-gösterge-panelleri.html","id":"üzerinde-çalışılmış-örnek","chapter":"42 R Markdown ile gösterge panelleri","heading":"Üzerinde çalışılmış örnek","text":"Burada, “outbreak_dashboard.Rmd” flexdashboard komut dosyasını shiny’içerecek şekilde uyarlıyoruz. Kullanıcıya açılır menüden bir hastane seçme yeteneği ekleyeceğiz ve salgın eğrisinin dinamik bir grafik başlığı ile yalnızca o hastaneden vakaları yansıtmasını sağlayacağız. Aşağıdakileri yapıyoruz:• YAML ’e runtime: shiny ekleyin\n• Kurulum yığınını global şeklinde yeniden adlandırın\n• Bir kenar çubuğu oluşturun\n• Benzersiz hastane adlarından oluşan vektörü oluşturmak için kod\n• Hastane isimleri seçimi ile bir selectInput() komutu (shiny açılır menüsü). Seçim, daha sonraki kodda input\\(hospital_choice olarak başvurulabilecek olan hospital_choice olarak kaydedilir. • Salgın eğrisi kodu (sütun 2) renderPlot({ })ile sarılmıştır ve bunları içerir: • Hastane sütununu input\\)hospital_choice’geçerli değeriyle sınırlayan veri kümesindeki bir filtre\n• input$hospital_choice içeren dinamik bir grafik başlığıBir input$ değerine başvuran herhangi bir kodun (reaktif olması için) render({}) fonkisyonu içinde olması gerektiğini unutmayın.YAML, global kod parçası ve kenar çubuğu da dahil olmak üzere betiğin üst kısmı:Reaktif eğri grafiğiyle birlikte 2. Sütun:Ve işte kontrol paneli:","code":""},{"path":"r-markdown-ile-gösterge-panelleri.html","id":"diğer-örnekler","chapter":"42 R Markdown ile gösterge panelleri","heading":"Diğer Örnekler","text":"Shiny etkileşimi ve broşür haritalama widget’ını kullanan bir Shiny-flexdashboard’un sağlıkla ilgili bir örneğini incelemek için Geospatial Health Data: R-INLA ve Shiny ile Modelleme ve Görselleştirme çevrimiçi kitabının bu bölümüne bakabilirsiniz.","code":""},{"path":"r-markdown-ile-gösterge-panelleri.html","id":"paylaşım","chapter":"42 R Markdown ile gösterge panelleri","heading":"42.9 Paylaşım","text":"Shiny öğeleri içermeyen panolar, boyutu izin veriyorsa e-postayla gönderilebilecek bir HTML dosyası (.html) verir. “Gösterge paneli” raporunu gönderebildiğiniz için ve bir web sitesi olarak saklamak için bir sunucu kurmanız gerekmediği için bu yararlıdır.Shiny öğelerini yerleştirdiyseniz, e-posta ile çıktı gönderemezsiniz, ancak komut dosyasının kendisini bir R kullanıcısına gönderebilir veya yukarıda açıklandığı gibi gösterge panelini bir sunucuda saklayabilirsiniz.","code":""},{"path":"r-markdown-ile-gösterge-panelleri.html","id":"kaynaklar-34","chapter":"42 R Markdown ile gösterge panelleri","heading":"42.10 Kaynaklar","text":"Bu sayfanın referans aldığı mükemmel eğitimleri aşağıda bulunabilir. Bunları gözden geçirirseniz, büyük olasılıkla bir saat içinde kendi gösterge tablonuzu hazırlayabilirsiniz.https://bookdown.org/yihui/rmarkdown/dashboards.htmlhttps://rmarkdown.rstudio.com/flexdashboard/https://rmarkdown.rstudio.com/flexdashboard/using.htmlhttps://rmarkdown.rstudio.com/flexdashboard/examples.html","code":""},{"path":"shiny-ile-gösterge-panelleri.html","id":"shiny-ile-gösterge-panelleri","chapter":"43 Shiny ile Gösterge Panelleri","heading":"43 Shiny ile Gösterge Panelleri","text":"Gösterge paneli, genellikle analizlerden elde edilen sonuçları başkalarıyla paylaşmanın iyi bir yoludur. Kaliteli bir gösterge paneli üretmek, nispeten ileri düzeyde R dili bilgisi gerektirir, ancak inanılmaz özelleştirme seçenekleri sunar.Shiny ile gösterge tablolarını öğrenen birinin, veri dönüştürme ve görselleştirme konusunda iyi bilgiye sahip olması ve kod hatalarını ayıklama ve kod işlevleri konularında bilgili olması önerilir. Gösterge panelleriyle çalışmak, başladığınızda sezgisel değildir ve bazen anlaşılması zordur, ancak öğrenmesi harika bir beceridir ve pratikle çok daha kolay hale gelir!Bu sayfa, shiny ve uzantıları olan panellerin nasıl oluşturulacağına dair kısa bir genel bakış sağlayacaktır. Panelleri daha hızlı, daha kolay, ancak daha az özelleştirilebilir hale getirmenin alternatif bir yöntemi için, flextable R Markdown ile gösterge panelleri sayfasına bakabilirsiniz.","code":""},{"path":"shiny-ile-gösterge-panelleri.html","id":"hazırlık-35","chapter":"43 Shiny ile Gösterge Panelleri","heading":"43.1 Hazırlık","text":"","code":""},{"path":"shiny-ile-gösterge-panelleri.html","id":"paketleri-yükleme-12","chapter":"43 Shiny ile Gösterge Panelleri","heading":"Paketleri yükleme","text":"Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’ın p_load() fonkisyonunu vurguluyoruz. Ayrıca, temel R’dan library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R temelleri sayfasına bakın.shiny R paketini kurarak başlıyoruz:","code":"\npacman::p_load(\"shiny\")"},{"path":"shiny-ile-gösterge-panelleri.html","id":"verileri-içe-aktarma-9","chapter":"43 Shiny ile Gösterge Panelleri","heading":"Verileri içe aktarma","text":"Bu sayfayı takip etmek isterseniz, el kitabının ve verilerin indirilmesi bölümüne bakabilirsiniz. Güncel Shiny uygulamasını oluşturan R komut dosyalarını ve veri dosyalarını indirmek için bağlantılar burada mevcuttur.Uygulamayı bu dosyaları kullanarak yeniden oluşturmaya çalışırsanız, lütfen kurs için oluşturulan R projesi klasör yapısının (örneğin, “veri” ve “işlevler” için klasörler) farkında olun.","code":""},{"path":"shiny-ile-gösterge-panelleri.html","id":"shiny-uygulamasının-yapısı","chapter":"43 Shiny ile Gösterge Panelleri","heading":"43.2 Shiny uygulamasının yapısı","text":"","code":""},{"path":"shiny-ile-gösterge-panelleri.html","id":"temel-dosya-yapıları","chapter":"43 Shiny ile Gösterge Panelleri","heading":"Temel dosya yapıları","text":"Shiny’yi anlamak için önce uygulamanın dosya yapısının nasıl çalıştığını anlamamız gerekir! Başlamadan önce yepyeni bir dizin oluşturmalıyız. Bu aslında Rstudio’da yeni projeden Shiny Web Application seçilerek daha kolay hale getirilebilir. Bu, sizin için shiny uygulamasının temel yapısını oluşturacaktır.Bu projeyi açarken, zaten app.R adında bir .R dosyası olduğunu fark edeceksiniz. İki temel dosya yapısından birine sahip olmamız önemlidir:app.R adında bir dosya veyaBiri ui.R ve diğeri server.R olarak adlandırılan iki dosyaBu sayfada, app.R adında bir dosyaya sahip olduğunuz ilk yaklaşımı kullanacağız. İşte örnek bir komut dosyası:Bu dosyayı açarsanız, biri kullanıcı arayüzü ve diğeri sunucu olarak adlandırılan iki nesnenin tanımlandığını fark edeceksiniz. Bu nesneler shiny uygulamasında tanımlanmalıdır ve uygulamanın kendi yapısının merkezinde yer alırlar! Aslında, yukarıda açıklanan iki dosya yapısı arasındaki tek fark, yapı 1’de hem kullanıcı arayüzünün hem de sunucunun tek bir dosyada tanımlanması, yapı 2’de ise ayrı dosyalarda tanımlanmalarıdır. : Ayrıca, uygulamamızda source() fonksiyonunu uygulayabileceğimiz başka .R dosyalarına da sahip olabiliriz (Daha büyük bir uygulamamız varsa bu şekilde yapmalıyız).","code":"\n#  app.R örneği\n\nlibrary(shiny)\n\nui <- fluidPage(\n\n    # Uygulama başlığı\n    titlePanel(\"My app\"),\n\n    # Kaydırıcı giriş araçlı kenar çubuğu\n    sidebarLayout(\n        sidebarPanel(\n            sliderInput(\"input_1\")\n        ),\n\n        # Grafiği göster   \n        mainPanel(\n           plotOutput(\"my_plot\")\n        )\n    )\n)\n\n# Bir histogram çizmek için gereken sunucu mantığını tanımlayın\nserver <- function(input, output) {\n     \n     plot_1 <- reactive({\n          plot_func(param = input_1)\n     })\n     \n    output$my_plot <- renderPlot({\n       plot_1()\n    })\n}\n\n\n# Uygulamayı çalıştırın\nshinyApp(ui = ui, server = server)"},{"path":"shiny-ile-gösterge-panelleri.html","id":"sunucu-ve-kullanıcı-arayüzü-ui","chapter":"43 Shiny ile Gösterge Panelleri","heading":"Sunucu ve kullanıcı arayüzü (ui)","text":"Daha sonra sunucu ve ‘ui’ nesnelerinin gerçekte ne yaptığını anlamamız gerekiyor. Basitçe söylemek gerekirse, bunlar, kullanıcı shiny uygulamasıyla etkileşime girdiğinde birbirleriyle etkileşime giren iki nesnedir.Shiny bir uygulamasının UI öğesi, temel düzeyde bir HTML arayüzü oluşturan R kodudur. Bu, bir uygulamanın kullanıcı arayüzünde görüntülenen şey anlamına gelir. Bu genellikle şunları içerir:• “Widget’lar” - kullanıcı tarafından etkileşime geçilebilecek açılır menüler, onay kutuları, kaydırıcılar vb.\n• Grafikler, tablolar, vb - R koduyla oluşturulan çıktılar\n• Bir uygulamanın gezinme yönleri - sekmeler, bölmeler, vb.\n• Genel metin, köprüler vb.\n• HTML ve CSS öğeleri (daha sonra ele alınacaktır)UI hakkında anlaşılması gereken en önemli şey, kullanıcıdan girdi alması ve sunucudan kaynaklanan çıktıları göstermesidir. Kullanıcı arabiriminde herhangi bir zamanda çalışan aktif kod yoktur - kullanıcı arabiriminde görülen tüm değişiklikler (az ya da çok) sunucudan geçirilir. Bu yüzden grafiklerimizi, dosya indirmelerimizi vb. sunucuda gerçekleştirmeliyiz.Shiny uygulamasının sunucusu, uygulama başlatıldığında tüm kodun çalıştırıldığı yerdir. Sunucunun çalışma şekli biraz kafa karıştırıcı. Sunucu işlevi, kullanıcı arayüzüyle etkileşen kullanıcıya etkin bir şekilde tepki verir ve yanıt olarak kod parçalarını çalıştırır. Sunucuda bir şeyler değişirse, bunlar değişikliklerin görülebileceği kullanıcı arayüzüne geri iletilecektir. Daha da önemlisi, sunucudaki kod ardışık olmayan bir şekilde yürütülecektir (veya bu şekilde düşünmek en iyisidir). Temel olarak, kullanıcı arayüzünden veri girişi sunucudaki bir kod parçasını etkilediğinde, otomatik olarak çalışır ve bu çıktı üretilir ve görüntülenir.Bunların hepsi muhtemelen şimdilik çok soyut geliyor, bu yüzden bunun gerçekte nasıl çalıştığına dair net bir fikir edinmek için bazı örnekler üzerinden anlatacağız.","code":""},{"path":"shiny-ile-gösterge-panelleri.html","id":"bir-uygulama-oluşturmadan-önce","chapter":"43 Shiny ile Gösterge Panelleri","heading":"Bir uygulama oluşturmadan önce","text":"Bir uygulama oluşturmaya başlamadan önce, ne oluşturmak istediğinizi bilmek son derece yararlıdır. Kullanıcı arayüzünüz kodla yazılacağından, ne inşa ettiğinizi görselleştiremezsiniz önemlidir. Bu nedenle, neler yapabileceğiniz hakkında bir fikir edinmek için önceden shiny uygulama örneklerine bakmak son derece yararlıdır - bu uygulamaların arkasındaki kaynak koduna bakabilirseniz daha da iyi olur! Bunun için bazı harika kaynaklar şunlardır:Rstudio uygulama galerisiNeyin mümkün olduğuna dair bir fikir edindikten sonra, sizinkinin nasıl görünmesini istediğinizi haritalamak da yararlıdır - bunu kağıt üzerinde veya herhangi bir çizim yazılımında (PowerPoint, MS paint, vb.) yapabilirsiniz. İlk uygulamanız için basit bir başlangıç yapmanız faydalı olacaktır! Ayrıca internette bulduğunuz güzel bir uygulamanın kodunu işiniz için şablon olarak kullanmaktan çekinmeyin- sıfırdan uygulama oluşturmaktan çok daha kolaydır!","code":""},{"path":"shiny-ile-gösterge-panelleri.html","id":"kullanıcı-arayüzü-iu-oluşturmak","chapter":"43 Shiny ile Gösterge Panelleri","heading":"43.3 Kullanıcı Arayüzü (IU) Oluşturmak","text":"Uygulamamızı oluştururken, ne yaptığımızı görebilmemiz ve herhangi bir sunucu hatası nedeniyle uygulamanın başarısız olma riskini almamamız için önce kullanıcı arayüzü üzerinde çalışmak daha kolaydır. Daha önce de belirtildiği gibi, kullanıcı arayüzü üzerinde çalışırken bir şablon kullanmak genellikle iyidir. Temel shiny paketinde bulunan ve shiny ile kullanılabilecek bir dizi standart şablon vardır, ancak shinydashboard gibi bir dizi paket uzantısının da bulunduğunu belirtmekte fayda var. Başlangıç için temel shiny’den bir örnek kullanacağız.Shiny kullanıcı arayüzü genellikle aşağıdaki sırayla bir dizi iç içe fonksiyon olarak tanımlanır.Genel düzeni tanımlayan bir fonkisyon (en temel olanı fluidPage()’dir, ancak daha fazlası mevcuttur)Şablon içindeki paneller, örneğin:\n• bir kenar çubuğu (sidebarPanel())\n• bir “ana” panel (mainPanel())\n• bir sekme (tabPanel())\n• genel bir “sütun” (sütun())Widget’lar ve çıktılar - bunlar sunucuya girdiler (widget’lar) veya sunucudan çıktılar (çıkışlar) verebilir\n• Widget’lar genellikle xxxInput() olarak biçimlendirilir, ör. selectInput()\n• Çıktılar genellikle xxxOutput() olarak biçimlendirilir, ör. plotÇıkış()Bu yapıların soyut bir şekilde kolayca anlaşılmayacağını bir kez daha belirtmekte fayda var, bu yüzden bir örneğe bakmak en iyisi! Bölgeye göre sıtmayla savaş dispanseri sayım verilerini görselleştiren basit bir uygulama yapmayı düşünelim. Bu verinin birçok farklı parametresi vardır, bu nedenle son kullanıcının verileri uygun gördükleri şekilde yaş grubuna/bölgeye göre tabaklamak için bazı filtreler uygulayabilmesi harika olur! Başlangıç için çok basit bir shiny şablonu kullanabiliriz: Bir kenar çubuğu şablonu. Bu şablon, widget’ların soldaki bir kenar çubuğuna yerleştirildiği ve grafiğin sağ tarafa yerleştirildiği bir şablondur.Uygulamamızı planlayalım - verileri görselleştirmek istediğimiz bölgeyi seçmemize izin veren bir seçiciyle ve ilgilendiğimiz yaş grubunu görselleştirmemize izin veren bir seçiciyle başlayabiliriz. Bu filtreleri bir salgın eğrisi (epicurve) çizmek için kullanacağız. Bunun için:İstediğimiz bölgeyi ve ilgilendiğimiz yaş grubunu seçmemizi sağlayan iki açılır menü.Ortaya çıkan salgın eğrimizi gösterebileceğimiz bir alan.Bu şöyle görünebilir:app.R yukarıdaki UI koduyla çalıştırıldığında (app.R’nin sunucu kısmında aktif kod olmadan) düzen şöyle görünür - Bir sunucu yoksa hiçbir çizim oluşturulmayacağını unutmayın, ancak girişlerimiz düzgün çalışmaktadır!Bu örnek, widget’ların nasıl çalıştığını tartışmak için iyi bir fırsattır - widget’ın bir inputId, bir etiket ve widget türüne özgü bir dizi başka seçeneği kabul ettiğini unutmayın. Bu inputId son derece önemlidir - bunlar, kullanıcı arabiriminden sunucuya bilgi aktarmak için kullanılan kimliklerdir. Bu nedenle benzersiz olmaları gerekir. Daha büyük uygulamalar söz konusu olduğunda, inputIDlere mantıklı ve etkileşime girdikleri yapılara özgü bir ad vermek için çaba göstermelisiniz.Bu widget’ların birinin ne yaptığıyla ilgili tüm ayrıntılar için belgeleri dikkatlice okumalısınız. Widget’lar, widget türüne bağlı olarak belirli veri türlerini sunucuya iletir ve bunun tam olarak anlaşılması gerekir. Örneğin, selectInput() sunucuya bir karakter tipi iletir:• Buradaki ilk widget için Spring’seçersek, “Spring” karakter nesnesini sunucuya iletecektir.\n• Açılır menüden iki öğe seçersek, bunlar bir karakter vektörü olarak gelirler (örn. c(“Spring”, “Bolo”)).Diğer widget’lar, sunucuya farklı nesne türleri iletecektir! Örneğin:\n• numericInput(), sunucuya sayısal türde bir nesne iletir\n• checkboxInput(), sunucuya mantık nesnesi iletir (DOĞRU veya YANLIŞ)Burada yaş verileri için kullandığımız adlandırılmış vektörü de belirtmekte fayda var. Birçok pencere öğesi için, seçenekler olarak adlandırılmış bir vektörün kullanılması, vektörün adlarının seçenekler olarak görüntülenmesini sağlar, ancak sadece seçilen değeri vektörden sunucuya iletir. Yani burada birisi açılır menüden “15+” öğesini seçebilir ve kullanıcı arayüzü sunucuya “malaria_rdt_15” iletir - bu, ilgilendiğimiz sütunun adıdır!Uygulamanızla birçok eylem yapmak için kullanabileceğiniz çok sayıda widget vardır. Widget’lar ayrıca uygulamanıza dosya yüklemenize ve çıktıları indirmenize olanak tanır. Ayrıca, temel shiny’den daha fazla widget’erişmenizi sağlayan mükemmel shiny uzantılar da vardır - shinyWidgets paketi buna harika bir örnektir. Bazı örneklere bakmak için aşağıdaki bağlantılara bakabilirsiniz:temel shiny widget galerisishinyWidgets galerisi","code":"\nlibrary(shiny)\n\nui <- fluidPage(\n\n  titlePanel(\"Malaria facility visualisation app\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         # selector for district\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Select district\",\n              choices = c(\n                   \"All\",\n                   \"Spring\",\n                   \"Bolo\",\n                   \"Dingo\",\n                   \"Barnard\"\n              ),\n              selected = \"All\",\n              multiple = TRUE\n         ),\n         # selector for age group\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Select age group\",\n              choices = c(\n                   \"All ages\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ), \n              selected = \"All\",\n              multiple = FALSE\n         )\n\n    ),\n\n    mainPanel(\n      # epicurve goes here\n      plotOutput(\"malaria_epicurve\")\n    )\n    \n  )\n)"},{"path":"shiny-ile-gösterge-panelleri.html","id":"verinin-uygulamamıza-yüklenmesi","chapter":"43 Shiny ile Gösterge Panelleri","heading":"43.4 Verinin uygulamamıza yüklenmesi","text":"Uygulama geliştirmemizdeki bir sonraki adım, sunucuyu çalışır duruma getirmektir. Ancak bunu yapmak için uygulamamıza bazı veriler aktarmamız ve yapacağımız tüm hesaplamaları bulmamız gerekiyor. Shiny uygulamasının hatalarını ayıklamak kolay değildir, çünkü hataların nereden geldiği genellikle net değildir, bu nedenle sunucunun kendisini yapmaya başlamadan önce tüm veri işleme ve görselleştirme kodumuzu çalışır duruma getirmek idealdir.Kullanıcı girdisine göre değişen salgın eğrileri gösteren bir uygulama yapmak istediğimize göre, bunu normal bir R betiğinde çalıştırmak için hangi koda ihtiyacımız olacağını düşünmeliyiz. Şunlara ihtiyacımız olacak:\n1. Paketlerimizi yükleyin\n2. Verilerimizi yükleyin\n3. Verilerimizi dönüştürün\n4. Kullanıcı girdilerine dayalı olarak verilerimizi görselleştirmek için bir fonksiyon geliştirinBu liste oldukça basittir ve yapılması çok zor olmamalıdır. Artık bu sürecin hangi bölümlerinin yalnızca bir kez yapılması gerektiğini ve hangi bölümlerin kullanıcı girdilerine yanıt olarak çalıştırılması gerektiğini düşünmek önemlidir. Bunun nedeni, shiny uygulamalarının genellikle kullanımdan önce yalnızca bir kez çalıştırılan bazı kodları çalıştırmasıdır. Kodumuzun çoğu bu bölüme taşınabilirse, uygulamamızın performansına yardımcı olacaktır. Bu örnek için, sadece verilerimizi/paketlerimizi yüklememiz ve temel dönüşümleri bir kez yapmamız gerekiyor, böylece kodu sunucunun dışına yerleştirebiliriz. Bu, sunucuda ihtiyacımız olan tek kodun verilerimizi görselleştirecek kod olduğu anlamına gelir. Önce tüm bu bileşenleri bir komut dosyasında geliştirelim. Ancak verilerimizi bir fonksiyon ile görselleştirdiğimiz için, fonksiyonun kodunu sunucunun dışına da koyabiliriz, böylece uygulama çalıştığında fonksiyonumuz ortamda olur!Önce verilerimizi yükleyelim. Yeni bir proje ile çalıştığımız ve temizlemek istediğimiz için data adında yeni bir dizin oluşturabilir ve sıtma verilerimizi oraya ekleyebiliriz. Aşağıdaki kodu, uygulamamızın yapısını temizlediğimizde sileceğimiz bir test komut dosyasında çalıştırabiliriz.Tidy (düzenli) veri standartları kullanırsak bu verilerle çalışmak daha kolay olacaktır, bu nedenle yaş grubunun bir sütun olduğu ve vakaların başka bir sütun olduğu uzun bir veri formatına da pivotlamalıyız. Verilerin pivotlanması sayfasında öğrendiklerimizi kullanarak bunu kolayca yapabiliriz.Bu şeklide verilerimizi hazırlamayı bitirdik! Bu iş paketi, “R komut dosyasını test etme” için geliştirilecek şeyler listemizdeki 1, 2 ve 3 numaralı maddeleri kapsar. Son ve en zor görev, kullanıcı tanımlı parametrelere dayalı bir salgın eğrisi üretmek için bir fonksiyon oluşturmak olacaktır. Daha önce de belirtildiği gibi, shiny öğrenen herkesin, çalışma prensiplerini anlamak için önce fonksiyonel programlama (fonkisyonların yazılması) bölümünü incelemesi şiddetle tavsiye edilir!Fonksiyonumuzu tanımlarken, hangi parametreleri dahil etmek istediğimizi planlamak zor olabilir. Shiny ile fonksiyonel programlama için, ilgili parametrenin genellikle kendisiyle ilişkilendirilmiş bir widget’ı olacaktır, bu nedenle bunu planlamak genellikle oldukça kolaydır! Örneğin mevcut uygulamamızda, bölgeye göre filtreleme yapabilmek ve bunun için bir widget’ımız olmasını istiyoruz, bunun için bir bölge parametresini ekleyebiliriz. Tesise göre filtrelemek için herhangi bir uygulama işlevimiz şimdilik olmadığı için bu nedenle bunu bir parametre olarak eklememize gerek yoktur. Üç parametreli bir fonksiyon yazarak başlayalım:Çekirdek veri setiSeçim bölgesiTercih edilen yaş grubuNasıl çalıştığı nispeten basit olduğu için bu fonksiyon hakkında çok fazla ayrıntıya girmeyeceğiz. Bununla birlikte, edilmesi gereken bir nota, hata vereceği zamanlarda NULL elde ederek hataları ayıklamamızdır. Bunun nedeni, shiny’de sunucu bir çizim nesnesi yerine bir NULL nesnesi ürettiğinde, kullanıcı arayüzünde hiçbir şey gösterilmeyecek olmasıdır! Bu önemlidir, aksi takdirde hatalar genellikle uygulamanızın çalışmayı durdurmasına neden olur.Dikkat edilmesi gereken bir diğer nokta da, bölge girdisini değerlendirirken %% operatörünün kullanılmasıdır. Yukarıda bahsedildiği gibi bu operatör birden çok değere sahip bir karakter vektörü olarak kullanılabilir ,bu nedenle %% operatörünü kullanmak, == operatöründen daha esnektir.Fonksiyonumuzu test edelim!Fonksiyonumuz çalışırken, tüm bunların shiny uygulamamıza nasıl sığacağını anlamamız gerekiyor. Başlangıç kodu kavramından daha önce bahsetmiştik, ancak şimdi bunu uygulamamızın yapısına nasıl dahil edebileceğimize bakalım. Bunu yapabilmemizin iki yolu var!Bu kodu app.R dosyanıza komut dosyasının başına (kullanıcı arayüzünün üstüne) koyun veyaUygulamanızın global.R adlı dizininde yeni bir dosya oluşturun ve başlangıç kodunu bu dosyaya yerleştirin.Bu noktada, dosya yapınızı basit bir şekilde ayırmanıza izin verdiği için, özellikle daha büyük uygulamalarda, ikinci seçenekteki dosya yapısını kullanmanın genellikle daha kolay olduğunu belirtmekte fayda var. Şimdi bu global.R betiğini tamamen geliştirelim. Böyle görünebilir:Bright’ın harika bir özelliği, app.R, server.R, ui.R ve global.R adlı dosyaların ne için olduğunu anlamasıdır, bu nedenle herhangi bir kod aracılığıyla bunları birbirine bağlamaya gerek yoktur. Bu yüzden sadece global.R’deki bu kodu dizinde bulundurmak uygulamamızı başlatmadan önce çalışması için yeterlidir!Ayrıca, çizim işlevini kendi dosyasına taşımamızın uygulamamızın organizasyonunu iyileştireceğini de unutmamalıyız – bu eylem özellikle uygulamalar büyüdükçe yararlı olacaktır. Bunu yapmak için funcs adında başka bir dizin oluşturabilir ve bu işlevi plot_epicurve.R adlı bir dosyaya yerleştirebiliriz. Daha sonra bu işlevi global.R’de aşağıdaki komutla okuyabiliriz:Uygulama bir sunucuda yayınlandığında kaynak bulmayı etkileyeceğinden, shiny uygulamalarında zaman local argümanını ‘local= TRUE’ belirtmeniz gerektiğini unutmayın.","code":"\npacman::p_load(\"tidyverse\", \"lubridate\")\n\n# veriyi oku\nmalaria_data <- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\")) %>% \n  as_tibble()\n\nprint(malaria_data)## # A tibble: 3,038 × 10\n##    location_name data_date  submitted_date Province District `malaria_rdt_0-4` `malaria_rdt_5-14` malar…¹ malar…² newid\n##    <chr>         <date>     <date>         <chr>    <chr>                <int>              <int>   <int>   <int> <int>\n##  1 Facility 1    2020-08-11 2020-08-12     North    Spring                  11                 12      23      46     1\n##  2 Facility 2    2020-08-11 2020-08-12     North    Bolo                    11                 10       5      26     2\n##  3 Facility 3    2020-08-11 2020-08-12     North    Dingo                    8                  5       5      18     3\n##  4 Facility 4    2020-08-11 2020-08-12     North    Bolo                    16                 16      17      49     4\n##  5 Facility 5    2020-08-11 2020-08-12     North    Bolo                     9                  2       6      17     5\n##  6 Facility 6    2020-08-11 2020-08-12     North    Dingo                    3                  1       4       8     6\n##  7 Facility 6    2020-08-10 2020-08-12     North    Dingo                    4                  0       3       7     6\n##  8 Facility 5    2020-08-10 2020-08-12     North    Bolo                    15                 14      13      42     5\n##  9 Facility 5    2020-08-09 2020-08-12     North    Bolo                    11                 11      13      35     5\n## 10 Facility 5    2020-08-08 2020-08-12     North    Bolo                    19                 15      15      49     5\n## # … with 3,028 more rows, and abbreviated variable names ¹​malaria_rdt_15, ²​malaria_tot\nmalaria_data <- malaria_data %>%\n  select(-newid) %>%\n  pivot_longer(cols = starts_with(\"malaria_\"), names_to = \"age_group\", values_to = \"cases_reported\")\n\nprint(malaria_data)## # A tibble: 12,152 × 7\n##    location_name data_date  submitted_date Province District age_group        cases_reported\n##    <chr>         <date>     <date>         <chr>    <chr>    <chr>                     <int>\n##  1 Facility 1    2020-08-11 2020-08-12     North    Spring   malaria_rdt_0-4              11\n##  2 Facility 1    2020-08-11 2020-08-12     North    Spring   malaria_rdt_5-14             12\n##  3 Facility 1    2020-08-11 2020-08-12     North    Spring   malaria_rdt_15               23\n##  4 Facility 1    2020-08-11 2020-08-12     North    Spring   malaria_tot                  46\n##  5 Facility 2    2020-08-11 2020-08-12     North    Bolo     malaria_rdt_0-4              11\n##  6 Facility 2    2020-08-11 2020-08-12     North    Bolo     malaria_rdt_5-14             10\n##  7 Facility 2    2020-08-11 2020-08-12     North    Bolo     malaria_rdt_15                5\n##  8 Facility 2    2020-08-11 2020-08-12     North    Bolo     malaria_tot                  26\n##  9 Facility 3    2020-08-11 2020-08-12     North    Dingo    malaria_rdt_0-4               8\n## 10 Facility 3    2020-08-11 2020-08-12     North    Dingo    malaria_rdt_5-14              5\n## # … with 12,142 more rows\nplot_epicurve <- function(data, district = \"All\", agegroup = \"malaria_tot\") {\n  \n  if (!(\"All\" %in% district)) {\n    data <- data %>%\n      filter(District %in% district)\n    \n    plot_title_district <- stringr::str_glue(\"{paste0(district, collapse = ', ')} districts\")\n    \n  } else {\n    \n    plot_title_district <- \"all districts\"\n    \n  }\n  \n  # kalan veri yoksa, NULL getir\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  data <- data %>%\n    filter(age_group == agegroup)\n  \n  \n  # kalan veri yoksa, NULL getir\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  if (agegroup == \"malaria_tot\") {\n      agegroup_title <- \"All ages\"\n  } else {\n    agegroup_title <- stringr::str_glue(\"{str_remove(agegroup, 'malaria_rdt')} years\")\n  }\n  \n  \n  ggplot(data, aes(x = data_date, y = cases_reported)) +\n    geom_col(width = 1, fill = \"darkred\") +\n    theme_minimal() +\n    labs(\n      x = \"date\",\n      y = \"number of cases\",\n      title = stringr::str_glue(\"Malaria cases - {plot_title_district}\"),\n      subtitle = agegroup_title\n    )\n  \n  \n  \n}\nplot_epicurve(malaria_data, district = \"Bolo\", agegroup = \"malaria_rdt_0-4\")\n# global.R betiği\n\npacman::p_load(\"tidyverse\", \"lubridate\", \"shiny\")\n\n# veriyi oku\nmalaria_data <- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\")) %>% \n  as_tibble()\n\n# veriyi temizle ve uzun pivotla\nmalaria_data <- malaria_data %>%\n  select(-newid) %>%\n  pivot_longer(cols = starts_with(\"malaria_\"), names_to = \"age_group\", values_to = \"cases_reported\")\n\n\n# grafik fonksiyonunu tanımla\nplot_epicurve <- function(data, district = \"All\", agegroup = \"malaria_tot\") {\n  \n  # grafik başlığı oluştur\n  if (!(\"All\" %in% district)) {            \n    data <- data %>%\n      filter(District %in% district)\n    \n    plot_title_district <- stringr::str_glue(\"{paste0(district, collapse = ', ')} districts\")\n    \n  } else {\n    \n    plot_title_district <- \"all districts\"\n    \n  }\n  \n  # kalan veri yoksa, NULL sonucunu getir  \n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  # yaş grubuna filtrele\n  data <- data %>%\n    filter(age_group == agegroup)\n  \n  \n  # kalan veri yoksa, NULL sonucunu getir  \n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  if (agegroup == \"malaria_tot\") {\n      agegroup_title <- \"All ages\"\n  } else {\n    agegroup_title <- stringr::str_glue(\"{str_remove(agegroup, 'malaria_rdt')} years\")\n  }\n  \n  \n  ggplot(data, aes(x = data_date, y = cases_reported)) +\n    geom_col(width = 1, fill = \"darkred\") +\n    theme_minimal() +\n    labs(\n      x = \"date\",\n      y = \"number of cases\",\n      title = stringr::str_glue(\"Malaria cases - {plot_title_district}\"),\n      subtitle = agegroup_title\n    )\n  \n  \n  \n}\nsource(here(\"funcs\", \"plot_epicurve.R\"), local = TRUE)"},{"path":"shiny-ile-gösterge-panelleri.html","id":"bir-uygulama-sunucusu-geliştirme","chapter":"43 Shiny ile Gösterge Panelleri","heading":"43.5 Bir uygulama sunucusu geliştirme","text":"Artık kodumuzun çoğunu yazdığımıza göre, sadece sunucumuzu geliştirmemiz gerekiyor. Bu, uygulamamızın son parçasıdır ve muhtemelen anlaşılması en zor olanıdır. Sunucu büyük bir R işlevidir, ancak onu bir dizi daha küçük işlev veya uygulamanın gerçekleştirebileceği görevler olarak düşünmek yararlıdır. Bu işlevlerin doğrusal bir sırada yürütülmediğini anlamak önemlidir. Onlara verilen bir emir vardır ancak shiny’de başlangıç seviyesinde bu süreci tam olarak anlamak gerekli değildir. Çok temel düzeyde, bu görevler veya işlevler, geliştirici farklı davranacak şekilde ayarlamadıkça, sadece kullanıcı girdilerinde kendilerini etkileyen bir değişiklik olduğunda etkinleşir. Yine, bunların hepsi oldukça soyut kavramlardır. Ama önce üç temel shiny nesne türünü inceleyelim.Reaktif kaynaklar - bu, kullanıcı girdileri için başka bir terimdir. Shiny sunucusu, programladığımız widget’lar aracılığıyla UI’den (kullanıcı arayüzünden) gelen çıktılara erişebilir. Değerleri değiştirildiğinde, bu bilgi sunucuya iletilir.Reaktif kaynaklar - bu, kullanıcı girdileri için başka bir terimdir. Shiny sunucusu, programladığımız widget’lar aracılığıyla UI’den (kullanıcı arayüzünden) gelen çıktılara erişebilir. Değerleri değiştirildiğinde, bu bilgi sunucuya iletilir.Reaktif iletkenler - bunlar yalnızca shiny sunucusunun içinde bulunan nesnelerdir. Bunlara aslında basit uygulamalar için ihtiyacımız yoktur, yalnızca sunucu içinde görülebilen ve diğer işlemlerde kullanılabilen nesneler üretirler. Genellikle reaktif kaynaklara bağlıdırlar.Reaktif iletkenler - bunlar yalnızca shiny sunucusunun içinde bulunan nesnelerdir. Bunlara aslında basit uygulamalar için ihtiyacımız yoktur, yalnızca sunucu içinde görülebilen ve diğer işlemlerde kullanılabilen nesneler üretirler. Genellikle reaktif kaynaklara bağlıdırlar.Son noktalar - bunlar sunucudan kullanıcı arayüzüne iletilen çıktılardır. Örneğimizde, ürettiğimiz salgın eğrisi bu olacaktır.Son noktalar - bunlar sunucudan kullanıcı arayüzüne iletilen çıktılardır. Örneğimizde, ürettiğimiz salgın eğrisi bu olacaktır.Bunu akılda tutarak, sunucumuzu adım adım oluşturalım. Burada sadece referans olması için UI kodumuzu tekrar göstereceğiz:Bu kod kullanıcı arayüzünden elimize:\n• İki giriş ulaşır:\n• Bölge seçicisi(bir select_district giriş kimliğiyle)\n• Yaş grubu seçicisi (inputId’si select_agegroup olan)• Bir çıktı:\n• Salgın eğrisi (sıtma_epicurve çıkış kimliği ile)Daha önce de belirtildiği gibi, girdi ve çıktılarımıza atadığımız bu benzersiz isimler çok önemlidir. Benzersiz olmalıdırlar ve kullanıcı arayüzü ile sunucu arasında bilgi iletmek için kullanılırlar. Sunucumuzda girdilerimize ‘input\\(inputID' ve output sintaksı aracılığıyla erişiyoruz ve 'output\\)output_name’ sintaksı aracılığıyla kullanıcı arayüzüne iletiyoruz. Şimdi bir örneğe bakalım, çünkü bunu başka türlü anlaşılması güçtür.Bunun gibi basit bir uygulamanın sunucusu aslında oldukça basittir! Sunucunun üç parametreli bir fonksiyon olduğunu fark edeceksiniz - giriş, çıkış ve oturum - bunu anlamak bu basamakta o kadar önemli değildir , ancak bu kuruluma bağlı kalmak önemlidir! Sunucumuzda sadece bir görevimiz mevcuttur – bu da daha önce oluşturduğumuz fonksiyonumuza ve sunucudan gelen girdilere dayalı bir grafik oluşturmaktır. Giriş ve çıkış nesnelerinin adlarının, kullanıcı arabirimindekilere tam olarak nasıl karşılık geldiğine dikkat edin.Sunucunun kullanıcı girdilerine nasıl tepki verdiğinin temellerini anlamak için, girdiler değiştiğinde çıktının (altta yatan paket aracılığıyla) da değişeceğin ve değişimle bir grafik oluşturmak için bu fonksiyonu yeniden çalıştıracağını unutmamalısınız. Burada renderPlot() fonksiyonunu da kullandığımızı unutmayın – bu fonksiyon, nesneleri bir kullanıcı arabirimi çıktısına ileten sınıfa özgü fonkisyonlar ailesindendir. Benzer şekilde davranan birkaç fonksiyon vardır, ancak kullanılan fonksiyonun kullanıcı arayüzüne ilettiğiniz nesnenin sınıfıyla eşleştiğinden emin olmanız gerekir! Örneğin:renderText() - kullanıcı arayüzüne metin gönderirrenderDataTable - kullanıcı arayüzüne etkileşimli bir tablo gönderir.Bunların da kullanıcı arayüzünde kullanılan çıktı işleviyle eşleşmesi gerektiğini unutmayın - bu nedenle renderPlot(), plotOutput() ile eşleştirilir ve renderText(), textOutput() ile eşleştirilir.Sonunda çalışan bir uygulama yaptık! Bunu Rstudio’da komut dosyası penceresinin sağ üst kısmındaki Uygulamayı Çalıştır düğmesine basarak çalıştırabiliriz. Uygulamanızı, diğer kullanıcılar için uygulamanın nasıl görüneceğini daha doğru bir şekilde yansıtacak olan varsayılan tarayıcınızda (Rstudio yerine) çalıştırmayı seçebileceğinizi unutmayın.Uygulamanın R konsolunda “dinlediğini” fark etmek eğlencelidir! Reaktivite hakkında konuşun!","code":"\nui <- fluidPage(\n\n  titlePanel(\"Malaria facility visualisation app\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         # bölge için seçici\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Select district\",\n              choices = c(\n                   \"All\",\n                   \"Spring\",\n                   \"Bolo\",\n                   \"Dingo\",\n                   \"Barnard\"\n              ),\n              selected = \"All\",\n              multiple = TRUE\n         ),\n         # yaş grubu için seçici\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Select age group\",\n              choices = c(\n                   \"All ages\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ), \n              selected = \"All\",\n              multiple = FALSE\n         )\n\n    ),\n\n    mainPanel(\n      # salgın eğrisi burada bulunur\n      plotOutput(\"malaria_epicurve\")\n    )\n    \n  )\n)\nserver <- function(input, output, session) {\n  \n  output$malaria_epicurve <- renderPlot(\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  )\n  \n}"},{"path":"shiny-ile-gösterge-panelleri.html","id":"daha-fazla-işlevsellik-eklemek","chapter":"43 Shiny ile Gösterge Panelleri","heading":"43.6 Daha fazla işlevsellik eklemek","text":"Bu noktada nihayet çalışan bir uygulamamız var, ancak işlevsellik düzeyi düşüktür. Ayrıca, shine paketiyle yapabileceklerin henüz çok az kısımını gördük, bu yüzden öğrenecek daha çok şey var! Bazı ekstra özellikler ekleyerek mevcut uygulamamızı oluşturmaya devam edelim. Eklemenin uygun olacağı bazı seçenekler şunlar olabilir:Açıklayıcı metinlerGrafikler için bir indirme düğmesi - bu, kullanıcının uygulamada oluşturdukları görüntünün yüksek kaliteli bir sürümünü elde etmesini sağlarBelirli tesisler için bir seçiciBaşka bir gösterge paneli sayfası - bu, verilerimizin bir tablosunu gösterebilir.Bu şekilde eklenebilecek çok şey vardır, bu şekilde bir sürü farklı shiny özelliği hakkında bilgi edinebiliriz. Shiny hakkında öğrenilecek çok şey var (çok gelişmiş olabilir, ancak umarız ki kullanıcılar shiny’yi nasıl kullanacakları konusunda daha iyi bir fikre sahip olduklarında, harici öğrenme kaynaklarını kullanarak da daha rahat olabilirler).","code":""},{"path":"shiny-ile-gösterge-panelleri.html","id":"statik-metin-eklemek","chapter":"43 Shiny ile Gösterge Panelleri","heading":"Statik metin eklemek","text":"Önce shiny uygulamamıza statik metin eklemeyi tartışalım. İşin temellerini bildikten sonra, uygulamamıza metin eklemek son derece kolaydır. Shiny uygulamasında statik metin değişmediğinden (Değişmesini isterseniz, sunucudaki metin oluşturma fonkisyonlarını kullanabilirsiniz!), shiny’nin tüm statik metinleri genellikle uygulamanın kullanıcı arayüzüne eklenir. Bunu çok ayrıntılı olarak ele almayacağız, ancak R’ı HTML ve css ile arayüz olarak kullanarak; kullanıcı arayüzünüze (ve hatta özelleştirilmiş olanlara) bir dizi farklı öğe ekleyebilirsiniz.HTML ve css, kullanıcı arayüzü tasarımında açıkça yer alan dillerdir. Bunları çok iyi anlamamıza gerek yok, ancak HTML, UI’de nesneler oluşturur (metin kutusu veya tablo gibi) ve css genellikle bu nesnelerin stilini ve estetiğini değiştirmek için kullanılır. Shiny’nin çok sayıda HTML etiketine erişimi vardır – bunların arasında başlıklar, metin paragrafları, satır sonları, tablolar vb. gibi belirli bir şekilde davranan nesneler için bulunur. Bu örneklerden bazılarını şu şekilde kullanabiliriz:h1() - bu, ekteki metni otomatik olarak büyütecek ve yazı tipi yüzü, rengi vb. ile ilgili varsayılanları değiştirecek bir başlık etiketidir (uygulamanızın ana temasına bağlı olarak). h2() ile h6()’ya kadar daha küçük ve daha küçük alt başlıklara da erişebilirsiniz. Kullanım şuna benzer:\nh1(\"header - section 1\")\nh1() - bu, ekteki metni otomatik olarak büyütecek ve yazı tipi yüzü, rengi vb. ile ilgili varsayılanları değiştirecek bir başlık etiketidir (uygulamanızın ana temasına bağlı olarak). h2() ile h6()’ya kadar daha küçük ve daha küçük alt başlıklara da erişebilirsiniz. Kullanım şuna benzer:h1(\"header - section 1\")p() - bu, içine alınmış metni bir metin gövdesindeki metne benzer hale getiren bir paragraf etiketidir. Bu metin otomatik olarak sarılır ve nispeten küçük bir boyutta olur (örneğin alt bilgiler daha küçük olabilir.) Bunu bir word belgesinin metin gövdesi olarak düşünün. Kullanım şuna benzer:\np(\"Bu, uygulamamın işlevini açıkladığım daha büyük bir metindir\")\np() - bu, içine alınmış metni bir metin gövdesindeki metne benzer hale getiren bir paragraf etiketidir. Bu metin otomatik olarak sarılır ve nispeten küçük bir boyutta olur (örneğin alt bilgiler daha küçük olabilir.) Bunu bir word belgesinin metin gövdesi olarak düşünün. Kullanım şuna benzer:p(\"Bu, uygulamamın işlevini açıkladığım daha büyük bir metindir\")tags$b() ve tags$() - bunlar kalın etiketler tags\\(b() ve italik etiketler tags\\)() oluşturmak için kullanılır.tags$b() ve tags$() - bunlar kalın etiketler tags\\(b() ve italik etiketler tags\\)() oluşturmak için kullanılır.tags$ul(), tags$ol() ve tags$li() - bunlar, listelerin oluşturulmasında kullanılan etiketlerdir. Bunların tümü aşağıdaki sintaks içinde kullanılır ve kullanıcının sıralı bir liste (tags\\(ol(); yani numaralandırılmış) veya sırasız liste (tags\\)ul(), yani madde işareti noktaları) oluşturmasına izin verir. Tags$li(), kullanılan liste türünden bağımsız olarak listedeki öğeleri belirtmek için kullanılır. Örneğin.:tags$ul(), tags$ol() ve tags$li() - bunlar, listelerin oluşturulmasında kullanılan etiketlerdir. Bunların tümü aşağıdaki sintaks içinde kullanılır ve kullanıcının sıralı bir liste (tags\\(ol(); yani numaralandırılmış) veya sırasız liste (tags\\)ul(), yani madde işareti noktaları) oluşturmasına izin verir. Tags$li(), kullanılan liste türünden bağımsız olarak listedeki öğeleri belirtmek için kullanılır. Örneğin.:br() ve hr() - bu etiketler sırasıyla satır sonu ve yatay satır (satır sonu ile) oluşturur. Uygulamanızı ve metninizi bölümlerini ayırmak için bunları kullanın! Bu etiketlere herhangi bir öğe iletmeye gerek yoktur (parantezler boş kalabilir).br() ve hr() - bu etiketler sırasıyla satır sonu ve yatay satır (satır sonu ile) oluşturur. Uygulamanızı ve metninizi bölümlerini ayırmak için bunları kullanın! Bu etiketlere herhangi bir öğe iletmeye gerek yoktur (parantezler boş kalabilir).div() - bu etiket şeyi içerebilen ve herhangi bir adla adlandırılabilen genel bir etikettir. Kullanıcı arayüzü tasarımında ilerlediğinizde, bunları kullanıcı arayüzünüzü bölümlere ayırmak, belirli bölümlere belirli stiller vermek ve sunucu ile kullanıcı arabirimi öğeleri arasında etkileşimler oluşturmak için kullanabilirsiniz. Bunlara ayrıntılı olarak girmeyeceğiz, ancak bu etiketin farkında olmak önemlidir!div() - bu etiket şeyi içerebilen ve herhangi bir adla adlandırılabilen genel bir etikettir. Kullanıcı arayüzü tasarımında ilerlediğinizde, bunları kullanıcı arayüzünüzü bölümlere ayırmak, belirli bölümlere belirli stiller vermek ve sunucu ile kullanıcı arabirimi öğeleri arasında etkileşimler oluşturmak için kullanabilirsiniz. Bunlara ayrıntılı olarak girmeyeceğiz, ancak bu etiketin farkında olmak önemlidir!Bu nesnelerin birine, tags$... aracılığıyla veya bazıları için de yalnızca fonksiyon aracılığıyla erişilebileceğini unutmayın. Bunlar eş anlamlıdır, ancak daha açık olmayı ve yanlışlıkla fonksiyonların üzerine yazmamayı tercih ederseniz, tags$... stili etiketleri kullanmak yardımcı olabilir. Bu aynı zamanda mevcut etiketlerin kapsamlı bir listesi değildir. Tüm etiketlerin tam listesi burada shiny olarak mevcuttur ve daha da fazlası HTML’yi doğrudan kullanıcı arayüzünüze ekleyerek kullanılabilir!Kendinize güveniyorsanız, herhangi birindeki stil argümanı ile HTML etiketlerinize herhangi bir css stil öğesi de ekleyebilirsiniz. Bunun nasıl çalıştığına ayrıntılı olarak girmeyeceğiz, ancak bir kullanıcı arayüzündeki estetik değişiklikleri test etmek için, chrome’da (tarayıcıda çalıştırdığınız shiny uygulamanızın) HTML denetçi modunu kullanmak ve nesnelerin stilini kendiniz düzenleyebilirsiniz!Uygulamamıza biraz metin ekleyelim","code":"\ntags$ol(\n  \n  tags$li(\"Item 1\"),\n  \n  tags$li(\"Item 2\"),\n  \n  tags$li(\"Item 3\")\n  \n)\nui <- fluidPage(\n\n  titlePanel(\"Malaria facility visualisation app\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         h4(\"Options\"),\n         # selector for district\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Select district\",\n              choices = c(\n                   \"All\",\n                   \"Spring\",\n                   \"Bolo\",\n                   \"Dingo\",\n                   \"Barnard\"\n              ),\n              selected = \"All\",\n              multiple = TRUE\n         ),\n         # selector for age group\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Select age group\",\n              choices = c(\n                   \"All ages\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ), \n              selected = \"All\",\n              multiple = FALSE\n         ),\n    ),\n\n    mainPanel(\n      # salgın eğrisi burada bulunur\n      plotOutput(\"malaria_epicurve\"),\n      br(),\n      hr(),\n      p(\"Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:\"),\n    tags$ul(\n      tags$li(tags$b(\"location_name\"), \" - the facility that the data were collected at\"),\n      tags$li(tags$b(\"data_date\"), \" - the date the data were collected at\"),\n      tags$li(tags$b(\"submitted_daate\"), \" - the date the data were submitted at\"),\n      tags$li(tags$b(\"Province\"), \" - the province the data were collected at (all 'North' for this dataset)\"),\n      tags$li(tags$b(\"District\"), \" - the district the data were collected at\"),\n      tags$li(tags$b(\"age_group\"), \" - the age group the data were collected for (0-5, 5-14, 15+, and all ages)\"),\n      tags$li(tags$b(\"cases_reported\"), \" - the number of cases reported for the facility/age group on the given date\")\n    )\n    \n  )\n)\n)"},{"path":"shiny-ile-gösterge-panelleri.html","id":"bir-link-köprü-eklemek","chapter":"43 Shiny ile Gösterge Panelleri","heading":"Bir link (köprü) eklemek","text":"Bir web sitesine link eklemek için, bağlantıyla birlikte tags\\(() kullanın ve metni aşağıda gösterildiği gibi görüntüleyin. Bağımsız bir paragrafa için metni p() içine koyun. Bir cümlenin sadece birkaç kelimesini linke bağlamak için, cümleyi parçalara ayırın ve köprülü kısım için tag\\)() kullanın. Bağlantının yeni bir tarayıcı penceresinde açılmasını sağlamak için argüman olarak target = “_blank” ekleyin.","code":"\ntags$a(href = \"www.epiRhandbook.com\", \"Visit our website!\")"},{"path":"shiny-ile-gösterge-panelleri.html","id":"indirme-düğmesi-eklemek","chapter":"43 Shiny ile Gösterge Panelleri","heading":"İndirme düğmesi eklemek","text":"Üç özellikten ikincisine geçelim. İndirme düğmesini uygulamaya eklemek oldukça yaygındır ve yapılması oldukça kolaydır. Kullanıcı arayüzümüze başka bir widget eklememiz gerekiyor ve bunun için sunucumuza başka bir çıktı eklememiz gerekiyor. Bu örnekte reaktif iletkenleri de tanıtabiliriz!Önce kullanıcı arabirimimizi güncelleyelim - bu kolay çünkü shiny, downloadButton() adlı bir widget ile birlikte gelir - ona bir inputId ve bir etiket verelim.Burada ek olarak bir hr() etiketi eklediğimizi unutmayın - bu, kontrol widgetlarımızı indirme widgetlarımızdan ayıran yatay bir çizgi ekler. Bu, daha önce tartıştığımız HTML etiketlerinden bir diğeridir.Artık kullanıcı arayüzümüz hazır olduğuna göre, sunucu bileşenini eklememiz gerekiyor. İndirmeler, downloadHandler() fonksiyonuyla sunucuda yapılır. Grafiğimize benzer şekilde, indirme düğmesiyle aynı inputId’ye sahip bir çıktıya eklememiz gerekiyor. Bu fonkisyonun iki argümanı vardır - dosya adı ve içerik - bunların ikisi de işlevdir. Tahmin edebileceğiniz gibi, dosya adı indirilen dosyanın adını belirtmek için, içerik ise neyin indirileceğini belirtmek için kullanılır. İçerik, verileri yerel olarak kaydetmek için kullanacağınız bir fonkisyon içerir - bu nedenle, bir csv dosyası indiriyorsanız rio::export() fonksiyonunu kullanabilirsiniz. Bir grafik indirdiğimiz için ggplot2::ggsave() kullanacağız. Bunu nasıl programlayacağımıza bakalım (henüz sunucuya eklemeyeceğiz).İçerik fonksiyonunun zaman çıktı dosyası adının belirtildiği bir dosya argümanına ihtiyacı olduğunu unutmayın. Burada kodu tekrarladığımızı da fark edebilirsiniz - bu sunucuda bir kez indirme için ve bir kez de uygulamada görüntülenen grafik için olmak üzere plot_epicurve() fonksiyonumuzu iki kez kullanıyoruz. Bu, performansı büyük ölçüde etkilemeyecek olsa da, , kullanıcı bölge ve yaş grubunu belirten widgetları değiştirdiğinde ve grafiği indirmek istediğinde grafiği oluşturacak kodun çalıştırılması gerektiği anlamına gelir. Daha büyük uygulamalarda, bunun gibi optimal olmayan kararlar işleri daha da yavaşlatacaktır, bu nedenle uygulamamızı bu anlamda nasıl daha verimli hale getireceğimizi öğrenmek gerekir. Daha mantıklı olan, bölgeler/yaş grupları değiştiğinde epicurve kodunu çalıştırmanın bir yolu olması ve bunun renderPlot() ve downloadHandler() fonksiyonları tarafından kullanılmasına izin verilmesidir. Burada reaktif iletkenler devreye girer!Reaktif iletkenler, shiny sunucusunda reaktif bir şekilde oluşturulan, ancak çıktısı alınmayan nesnelerdir - yalnızca sunucunun diğer bölümleri tarafından kullanılabilirler. Birkaç farklı türde reaktif iletken vardır, ancak temel ikisini inceleyeceğiz.1.reactive() - bu en temel reaktif iletkendir - içinde kullanılan herhangi bir girdi değiştiğinde tepki verir (bu durumda bölge/yaş grubu widget’larımız)eventReactive()- bu rektif iletken, kullanıcının hangi girişlerin tekrar çalışmasına neden olduğunu belirleyebilmesi dışında, reaktif() ile aynı şekilde çalışır. Bu, reaktif iletkeninizin işlenmesi uzun zaman alıyorsa yararlıdır, ancak reaktif iletken daha sonra açıklanacaktır.İki örneğe bakalım:eventReactive() kurulumunu kullandığımızda, bu kod parçasının çalışmasına hangi girdilerin neden olduğunu belirleyebiliriz - bu şu anda bizim için pek kullanışlı değil, bu yüzden şimdilik bırakabiliriz. c() ile birden çok giriş ekleyebileceğinizi unutmayın.Bunu sunucu kodumuza nasıl entegre edebileceğimize bakalım:Hem indirme hem de grafik oluşturma işlevlerimizde tanımladığımız reaktif iletkenimizin çıktısını çağırdığımızı görebilirsiniz. Reaktiflerin çıktılarını fonksiyon gibi kullanmanız gerekir - bu nedenle sonlarına boş parantezler eklemelisiniz (yani, malaria_plot() doğrudur ve malaria_plot değil). Artık bu çözümü de eklediğimize göre, salgın eğrisi fonksiyonunu çalıştıran tüm kodlarımız tek bir yerde olduğundan uygulamamız daha düzenli (tidy), ve hızlıdır, değiştirilmesi de daha kolay.","code":"\nui <- fluidPage(\n\n  titlePanel(\"Malaria facility visualisation app\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         # selector for district\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Select district\",\n              choices = c(\n                   \"All\",\n                   \"Spring\",\n                   \"Bolo\",\n                   \"Dingo\",\n                   \"Barnard\"\n              ),\n              selected = \"All\",\n              multiple = FALSE\n         ),\n         # yaş grubu için seçici\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Select age group\",\n              choices = c(\n                   \"All ages\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ), \n              selected = \"All\",\n              multiple = FALSE\n         ),\n         # dikey hat\n         hr(),\n         downloadButton(\n           outputId = \"download_epicurve\",\n           label = \"Download plot\"\n         )\n\n    ),\n\n    mainPanel(\n      # salgon eğrisi buradadır\n      plotOutput(\"malaria_epicurve\"),\n      br(),\n      hr(),\n      p(\"Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:\"),\n      tags$ul(\n        tags$li(tags$b(\"location_name\"), \" - the facility that the data were collected at\"),\n        tags$li(tags$b(\"data_date\"), \" - the date the data were collected at\"),\n        tags$li(tags$b(\"submitted_daate\"), \" - the date the data were submitted at\"),\n        tags$li(tags$b(\"Province\"), \" - the province the data were collected at (all 'North' for this dataset)\"),\n        tags$li(tags$b(\"District\"), \" - the district the data were collected at\"),\n        tags$li(tags$b(\"age_group\"), \" - the age group the data were collected for (0-5, 5-14, 15+, and all ages)\"),\n        tags$li(tags$b(\"cases_reported\"), \" - the number of cases reported for the facility/age group on the given date\")\n      )\n      \n    )\n    \n  )\n)\nserver <- function(input, output, session) {\n  \n  output$malaria_epicurve <- renderPlot(\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  )\n  \n  output$download_epicurve <- downloadHandler(\n    filename = function() {\n      stringr::str_glue(\"malaria_epicurve_{input$select_district}.png\")\n    },\n    \n    content = function(file) {\n      ggsave(file, \n             plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup),\n             width = 8, height = 5, dpi = 300)\n    }\n    \n  )\n  \n}\nmalaria_plot_r <- reactive({\n  \n  plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  \n})\n\n\n# sadece bölge seçici değiştiğinde çalışır!\nmalaria_plot_er <- eventReactive(input$select_district, {\n  \n  plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  \n})\nserver <- function(input, output, session) {\n  \n  malaria_plot <- reactive({\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  })\n  \n  \n  \n  output$malaria_epicurve <- renderPlot(\n    malaria_plot()\n  )\n  \n  output$download_epicurve <- downloadHandler(\n    \n    filename = function() {\n      stringr::str_glue(\"malaria_epicurve_{input$select_district}.png\")\n    },\n    \n    content = function(file) {\n      ggsave(file, \n             malaria_plot(),\n             width = 8, height = 5, dpi = 300)\n    }\n    \n  )\n  \n}"},{"path":"shiny-ile-gösterge-panelleri.html","id":"tesis-seçici-eklemek","chapter":"43 Shiny ile Gösterge Panelleri","heading":"Tesis seçici eklemek","text":"Bir sonraki özelliğimize geçelim - belirli tesisler için bir seçici. Fonksiyonumuza kodumuzdan bir argüman olarak iletebileceğimiz başka bir parametre uygulayacağız. İlk önce bunu yapmaya odaklanalım. – Yeni parametre diğer parametrelerle aynı ilkelere göre çalışır. Fonksiyonumuzu güncelleyip test edelim.Haydi deneyelim:Verilerimizdeki tüm tesisler için hangi tesislerin hangi bölgelere karşılık geldiği çok net değildir - ve son kullanıcı da bu bilgiye erişemeyecektir. Bu, uygulamayı kullanmayı oldukça zor hale getirebilir. Bu nedenle, kullanıcı bölgeyi değiştirdikçe UI’deki tesis seçeneklerini dinamik olarak değiştirmeliyiz - biri diğerini filtrelemelidir! Seçeneklerde kullandığımız çok fazla değişken olduğundan, global.R dosyamızdaki kullanıcı arayüzü için bazı ayarlarımızı verilerimizden oluşturmak isteyebiliriz. Örneğin, verilerimizi okuduktan sonra bu kod parçasını global.R’ye ekleyebiliriz:Bölgelere bakalımBu yeni değişkenler, hem sunucu hem de kullanıcı arabirimi tarafından global olarak görünür olduklarından, herhangi bir sorun olmadan kullanıcı arabirimine geçirebiliriz! Arayüzümüzü güncelleyelim:Artık seçimlerimiz için değişkenleri kullanıcı arayüzünde kodlamak yerine nasıl ilettiğimize dikkat edin! Bu, kodumuzu da daha kompakt hale getirebilir! Son olarak, sunucuyu güncellememiz gerekecek. Yeni girdimizi dahil etmek için fonksiyonumuzu güncellemek kolay olacaktır (sadece yeni parametremize bir argüman olarak iletmemiz gerekiyor), ancak kullanıcı seçilen bölgeyi değiştirdiğinde kullanıcı arayüzünün dinamik olarak güncellenmesini istediğimizi hatırlamalıyız. Uygulama çalışırken widget’ların parametrelerini ve davranışını değiştirebileceğimizi burada anlamak önemlidir, ancak bunun sunucuda yapılması gerekir. Bunun nasıl yapılacağını öğrenmek için sunucuya çıktı almanın yeni bir yolunu anlamamız gerekiyor.Bunu gerçekleştiren fonksiyonlar, gözlemci fonksiyonlar olarak bilinir ve davranışları reaktif fonksiyonlara benzer. Yine de önemli bir farkları var:\n• Reaktif fonksiyonlar, çıktıları doğrudan etkilemez ve sunucudaki diğer konumlarda görülebilen nesneler üretir.\n• Gözlemci fonksiyonlar, sunucu çıktılarını etkileyebilir, ancak bunu diğer fonksiyonların fonksiyonlar yan etkileri yoluyla yapar. (Başka şeyler de yapabilirler, ancak pratikte bu onların ana işlevidir)Reaktif fonksiyonlara benzer şekilde, gözlemci fonksiyonların iki çeşidi vardır ve bunlar reaktif fonksiyonlarla aynı mantıkla sınıflandırılırlar:observe() - bu fonksiyon, kullanılan herhangi bir girdi değiştiğinde çalışırobserveEvent() - bu fonksiyon, kullanıcı tarafından belirlenen bir girdi değiştiğinde çalışırAyrıca, widget’ları güncelleyen shiny fonksiyonlarını da anlamamız gerekir. Bunların çalıştırılması oldukça basittir - önce sunucu fonkisyonundan oturum nesnesini alırlar (bunun şimdilik anlaşılması gerekmez), ardından değiştirilecek fonksiyonun inputId’sini alırlar. Ardından, selectInput() tarafından seçilmiş olan tüm parametrelerin yeni sürümleri iletilir - bunlar widget’ta otomatik olarak güncellenecektir.Bunu sunucumuzda nasıl kullanabileceğimize dair izole bir örneğe bakalım. Kullanıcı bölgeyi değiştirdiğinde, tesis gruplarımızı bölgeye göre filtrelemek ve seçenekleri yalnızca o bölgede mevcut olanları) yansıtacak (ve tüm tesisler için bir seçenek oluşturacak şekilde güncellemek istiyoruz.Ve bu kadar! Bunu sunucumuza ekleyebiliriz ve bu davranış şimdi işe yarayacaktır. Yeni sunucumuz şöyle görünmelidir:","code":"\nplot_epicurve <- function(data, district = \"All\", agegroup = \"malaria_tot\", facility = \"All\") {\n  \n  if (!(\"All\" %in% district)) {\n    data <- data %>%\n      filter(District %in% district)\n    \n    plot_title_district <- stringr::str_glue(\"{paste0(district, collapse = ', ')} districts\")\n    \n  } else {\n    \n    plot_title_district <- \"all districts\"\n    \n  }\n  \n  # kalan veri yoksa, NULL getir\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  data <- data %>%\n    filter(age_group == agegroup)\n  \n  \n  # kalan veri yoksa, NULL getir\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  if (agegroup == \"malaria_tot\") {\n      agegroup_title <- \"All ages\"\n  } else {\n    agegroup_title <- stringr::str_glue(\"{str_remove(agegroup, 'malaria_rdt')} years\")\n  }\n  \n    if (!(\"All\" %in% facility)) {\n    data <- data %>%\n      filter(location_name == facility)\n    \n    plot_title_facility <- facility\n    \n  } else {\n    \n    plot_title_facility <- \"all facilities\"\n    \n  }\n  \n  # kalan veri yoksa, NULL getir\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n\n  \n  \n  ggplot(data, aes(x = data_date, y = cases_reported)) +\n    geom_col(width = 1, fill = \"darkred\") +\n    theme_minimal() +\n    labs(\n      x = \"date\",\n      y = \"number of cases\",\n      title = stringr::str_glue(\"Malaria cases - {plot_title_district}; {plot_title_facility}\"),\n      subtitle = agegroup_title\n    )\n  \n  \n  \n}\nplot_epicurve(malaria_data, district = \"Spring\", agegroup = \"malaria_rdt_0-4\", facility = \"Facility 1\")\nall_districts <- c(\"All\", unique(malaria_data$District))\n\n# bölgeye göre konum adlarının veri çerçevesi\nfacility_list <- malaria_data %>%\n  group_by(location_name, District) %>%\n  summarise() %>% \n  ungroup()\nall_districts## [1] \"All\"     \"Spring\"  \"Bolo\"    \"Dingo\"   \"Barnard\"\nfacility_list## # A tibble: 65 × 2\n##    location_name District\n##    <chr>         <chr>   \n##  1 Facility 1    Spring  \n##  2 Facility 10   Bolo    \n##  3 Facility 11   Spring  \n##  4 Facility 12   Dingo   \n##  5 Facility 13   Bolo    \n##  6 Facility 14   Dingo   \n##  7 Facility 15   Barnard \n##  8 Facility 16   Barnard \n##  9 Facility 17   Barnard \n## 10 Facility 18   Bolo    \n## # … with 55 more rows\nui <- fluidPage(\n\n  titlePanel(\"Malaria facility visualisation app\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         # bölge için seçici\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Select district\",\n              choices = all_districts,\n              selected = \"All\",\n              multiple = FALSE\n         ),\n         # yaş grubu için seçici\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Select age group\",\n              choices = c(\n                   \"All ages\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ), \n              selected = \"All\",\n              multiple = FALSE\n         ),\n         # kurum için seçici\n         selectInput(\n           inputId = \"select_facility\",\n           label = \"Select Facility\",\n           choices = c(\"All\", facility_list$location_name),\n           selected = \"All\"\n         ),\n         \n         # dikey çizgi\n         hr(),\n         downloadButton(\n           outputId = \"download_epicurve\",\n           label = \"Download plot\"\n         )\n\n    ),\n\n    mainPanel(\n      # salgın eğrisi buradadır\n      plotOutput(\"malaria_epicurve\"),\n      br(),\n      hr(),\n      p(\"Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:\"),\n      tags$ul(\n        tags$li(tags$b(\"location_name\"), \" - the facility that the data were collected at\"),\n        tags$li(tags$b(\"data_date\"), \" - the date the data were collected at\"),\n        tags$li(tags$b(\"submitted_daate\"), \" - the date the data were submitted at\"),\n        tags$li(tags$b(\"Province\"), \" - the province the data were collected at (all 'North' for this dataset)\"),\n        tags$li(tags$b(\"District\"), \" - the district the data were collected at\"),\n        tags$li(tags$b(\"age_group\"), \" - the age group the data were collected for (0-5, 5-14, 15+, and all ages)\"),\n        tags$li(tags$b(\"cases_reported\"), \" - the number of cases reported for the facility/age group on the given date\")\n      )\n      \n    )\n    \n  )\n)\nobserve({\n  \n  if (input$select_district == \"All\") {\n    new_choices <- facility_list$location_name\n  } else {\n    new_choices <- facility_list %>%\n      filter(District == input$select_district) %>%\n      pull(location_name)\n  }\n  \n  new_choices <- c(\"All\", new_choices)\n  \n  updateSelectInput(session, inputId = \"select_facility\",\n                    choices = new_choices)\n  \n})\nserver <- function(input, output, session) {\n  \n  malaria_plot <- reactive({\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup, facility = input$select_facility)\n  })\n  \n  \n  \n  observe({\n    \n    if (input$select_district == \"All\") {\n      new_choices <- facility_list$location_name\n    } else {\n      new_choices <- facility_list %>%\n        filter(District == input$select_district) %>%\n        pull(location_name)\n    }\n    \n    new_choices <- c(\"All\", new_choices)\n    \n    updateSelectInput(session, inputId = \"select_facility\",\n                      choices = new_choices)\n    \n  })\n  \n  \n  output$malaria_epicurve <- renderPlot(\n    malaria_plot()\n  )\n  \n  output$download_epicurve <- downloadHandler(\n    \n    filename = function() {\n      stringr::str_glue(\"malaria_epicurve_{input$select_district}.png\")\n    },\n    \n    content = function(file) {\n      ggsave(file, \n             malaria_plot(),\n             width = 8, height = 5, dpi = 300)\n    }\n    \n  )\n  \n  \n  \n}"},{"path":"shiny-ile-gösterge-panelleri.html","id":"tabloya-yeni-bir-sekme-eklemek","chapter":"43 Shiny ile Gösterge Panelleri","heading":"Tabloya yeni bir sekme eklemek","text":"Şimdi uygulamamıza eklemek istediğimiz son bileşene geçeceğiz. Kullanıcı arayüzünü iki sekmeye ayırmak isteyeceğiz, bunlardan biri, kullanıcının salgın eğrisini oluşturdukları verileri görebileceği etkileşimli bir tabloya sahip olacak. Bunu yapmak için, sekmelerle ilgili shiny ile birlikte gelen paket dahili kullanıcı arabirimi öğelerini kullanabiliriz. Temel düzeyde, ana panelimizin çoğunu bu genel yapıya dahil edebiliriz:Bunu kullanıcı arayüzümüze uygulayalım. Ayrıca burada DT paketini kullanmak isteyeceğiz - bu, önceden var olan verilerden etkileşimli tablolar oluşturmak için harika bir pakettir. Bu örnekte DT::datatableOutput() fonksiyonunun kullanıldığını görebiliriz.Artık uygulamamız sekmeler halinde düzenlenmiştir! Sunucuda da gerekli düzenlemeleri yapalım. Veri setimizi oluşturmadan önce değiştirmemiz gerekmediğinden, sadece malaria_data veri setini DT::renderDT() aracılığıyla kullanıcı arayüzüne dönüştürüyoruz!","code":"\n# ... kullanıcı arayüzünden geri kalan\n\nmainPanel(\n  \n  tabsetPanel(\n    type = \"tabs\",\n    tabPanel(\n      \"Epidemic Curves\",\n      ...\n    ),\n    tabPanel(\n      \"Data\",\n      ...\n    )\n  )\n)\nui <- fluidPage(\n     \n     titlePanel(\"Malaria facility visualisation app\"),\n     \n     sidebarLayout(\n          \n          sidebarPanel(\n               # bölge için seçici\n               selectInput(\n                    inputId = \"select_district\",\n                    label = \"Select district\",\n                    choices = all_districts,\n                    selected = \"All\",\n                    multiple = FALSE\n               ),\n               # yaş grubu için seçici\n               selectInput(\n                    inputId = \"select_agegroup\",\n                    label = \"Select age group\",\n                    choices = c(\n                         \"All ages\" = \"malaria_tot\",\n                         \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                         \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                         \"15+ yrs\" = \"malaria_rdt_15\"\n                    ), \n                    selected = \"All\",\n                    multiple = FALSE\n               ),\n               # kurum için seçici\n               selectInput(\n                    inputId = \"select_facility\",\n                    label = \"Select Facility\",\n                    choices = c(\"All\", facility_list$location_name),\n                    selected = \"All\"\n               ),\n               \n               # dikey çizgi\n               hr(),\n               downloadButton(\n                    outputId = \"download_epicurve\",\n                    label = \"Download plot\"\n               )\n               \n          ),\n          \n          mainPanel(\n               tabsetPanel(\n                    type = \"tabs\",\n                    tabPanel(\n                         \"Epidemic Curves\",\n                         plotOutput(\"malaria_epicurve\")\n                    ),\n                    tabPanel(\n                         \"Data\",\n                         DT::dataTableOutput(\"raw_data\")\n                    )\n               ),\n               br(),\n               hr(),\n               p(\"Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:\"),\n               tags$ul(\n                    tags$li(tags$b(\"location_name\"), \" - the facility that the data were collected at\"),\n                    tags$li(tags$b(\"data_date\"), \" - the date the data were collected at\"),\n                    tags$li(tags$b(\"submitted_daate\"), \" - the date the data were submitted at\"),\n                    tags$li(tags$b(\"Province\"), \" - the province the data were collected at (all 'North' for this dataset)\"),\n                    tags$li(tags$b(\"District\"), \" - the district the data were collected at\"),\n                    tags$li(tags$b(\"age_group\"), \" - the age group the data were collected for (0-5, 5-14, 15+, and all ages)\"),\n                    tags$li(tags$b(\"cases_reported\"), \" - the number of cases reported for the facility/age group on the given date\")\n               )\n               \n               \n          )\n     )\n)\nserver <- function(input, output, session) {\n  \n  malaria_plot <- reactive({\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup, facility = input$select_facility)\n  })\n  \n  \n  \n  observe({\n    \n    if (input$select_district == \"All\") {\n      new_choices <- facility_list$location_name\n    } else {\n      new_choices <- facility_list %>%\n        filter(District == input$select_district) %>%\n        pull(location_name)\n    }\n    \n    new_choices <- c(\"All\", new_choices)\n    \n    updateSelectInput(session, inputId = \"select_facility\",\n                      choices = new_choices)\n    \n  })\n  \n  \n  output$malaria_epicurve <- renderPlot(\n    malaria_plot()\n  )\n  \n  output$download_epicurve <- downloadHandler(\n    \n    filename = function() {\n      stringr::str_glue(\"malaria_epicurve_{input$select_district}.png\")\n    },\n    \n    content = function(file) {\n      ggsave(file, \n             malaria_plot(),\n             width = 8, height = 5, dpi = 300)\n    }\n    \n  )\n  \n  \n  output$raw_data <- DT::renderDT(\n    malaria_data\n  )\n  \n  \n}"},{"path":"shiny-ile-gösterge-panelleri.html","id":"shiny-uygulamalarının-paylaşılması","chapter":"43 Shiny ile Gösterge Panelleri","heading":"43.7 Shiny Uygulamalarının Paylaşılması","text":"Artık uygulamanızı geliştirdiğinize göre, muhtemelen başkalarıyla paylaşmak istersiniz - bu, ne de olsa shiny’nin esas avantajıdır! Paylaşımı doğrudan kodu paylaşarak yapabiliriz veya bir sunucuda yayınlayabiliriz. Kodu paylaşırsak, başkaları ne yaptığınızı görebilir ve üzerine inşa edebilir, ancak bu, shiny’nin esas avantajlarından birini ortadan kaldıracaktır - son kullanıcıların bir R yükleme zorunluluğunu ortadan kaldırabilir. Bu nedenle, uygulamanızı R kullanmayan kullanıcılarla paylaşıyorsanız, sunucuda yayınlanan bir uygulamayı paylaşmak çok daha kolaydır.Kodu paylaşmayı tercih ederseniz, uygulamanın bir .zip dosyası oluşturabilir veya daha iyisi uygulamanızı github’da yayınlayabilir ve ortak çalışanlar ekleyebilirsiniz. Daha fazla bilgi için burada github ile ilgili bölüme başvurabilirsiniz.Ancak, uygulamayı çevrimiçi yayınlıyorsak, biraz daha çalışmamız gerekiyor. Sonuç olarak, başkalarının hızlı ve kolay bir şekilde erişebilmesi için uygulamanıza bir web URL’si aracılığıyla erişilebilmesini istiyoruz. Ne yazık ki, uygulamanızı bir sunucuda yayınlamak için, bir sunucuya erişiminiz olması gerekir! Bu söz konusu olduğunda bir dizi barındırma seçeneği vardır:• brightapps.io: Bu seçenekte shiny uygulamalarını yayınlamak için yapılandırma iş yükü düşüktür ve kısmen ücretsizdir, (ancak sınırlı lisanslara sahiptir) bu nedenle, shiny uygulamaları yayınlamak için en kolay yerdir.\n• RStudio Connect: Bu seçenek, shiny uygulamalarını yayınlamak dahil birçok işlemi gerçekleştirebilen bir R sunucusunun güçlü bir sürümüdür. Bununla birlikte, kullanımı daha zordur ve ilk kez kullananlar için daha az tavsiye edilir.Bu metnin amaçları doğrultusunda, ilk kez kullananlar için daha kolay olduğu için brightapps.io’yu kullanacağız. Başlamak için buradan ücretsiz bir hesap oluşturabilirsiniz - gerekirse sunucu lisansları için farklı fiyat seçenekleri de vardır. Ne kadar çok kullanıcıya sahip olmayı planlıyorsunuz, fiyat planınız o kadar pahalı olabilir, bu yüzden bunu göz önünde bulundurun. Küçük bir grup kişinin kullanması için bir uygulama oluşturmak istiyorsanız, ücretsiz bir lisans tamamen uygun olabilir, ancak halka açık bir uygulama daha fazla lisansa ihtiyaç duyabilir.Öncelikle uygulamamızın bir sunucuda yayınlanmaya uygun olduğundan emin olmalıyız. Uygulamanızda, R oturumunuzu yeniden başlatmalı ve herhangi bir ekstra kod çalıştırmadan çalıştığından emin olmalısınız. Bu önemlidir, çünkü paket yükleme gerektiren bir uygulama veya uygulama kodunuzda tanımlanmayan veri olması durumunda sunucuda çalışmayacaktır. Ayrıca, uygulamanızda herhangi bir açık dosya yoluna sahip olamayacağınızı unutmayın - bunlar sunucu ayarında geçersiz olacaktır - buradaki paketi kullanmak bu sorunu çok iyi çözer. Son olarak, kuruluşunuzun sunucuları gibi kullanıcı kimlik doğrulaması gerektiren bir kaynaktan veri okuyorsanız, bu genellikle bir sunucuda çalışmaz. Shiny sunucusunu beyaz listeye nasıl ekleyeceğinizi öğrenmek için bilgi işlem departmanınızla bağlantı kurmanız gerekecek.Hesabınızı aldıktan sonra, Hesaplar altındaki belirteçler (tokens) sayfasına gidebilirsiniz. Burada yeni bir belirteç eklemek isteyeceksiniz – bu belirteç, uygulamanızı dağıtmak için kullanılacaktır.\nBuradan, hesabınızın url’sinin uygulamanızın adını yansıtacağını unutmamalısınız - bu nedenle uygulamanızın adı my_app ise, url xxx.io/my_app/ olarak eklenecektir. Uygulamanızın adını akıllıca seçin! Artık hazır olduğunuza göre, dağıt’(deploy) tıklayın - başarılı olursa, bu uygulamanızı seçtiğiniz web url’sinde çalıştıracaktır!belgelerde uygulama yapma konusunda ek bir şey var mı?","code":""},{"path":"shiny-ile-gösterge-panelleri.html","id":"ileri-okuma","chapter":"43 Shiny ile Gösterge Panelleri","heading":"43.8 İleri okuma","text":"Şimdiye kadar, shiny’nin birçok yönünü ele aldık ancak tüm bilgiler göz önünde bulundurulursa shiny’yi ancak yüzeyel olarak gözden geçirdik. Bu kılavuz bir giriş niteliğinde olsa da, shiny’yi tam olarak anlamak için öğrenilecek daha çok şey var. Uygulamalar oluşturmaya başlamalı ve giderek daha fazla işlevsellik eklemelisiniz.","code":""},{"path":"shiny-ile-gösterge-panelleri.html","id":"önerilen-shiny-uzantıları","chapter":"43 Shiny ile Gösterge Panelleri","heading":"43.9 Önerilen shiny uzantıları","text":"Aşağıdakiler, shiny’den çok daha fazlasını elde etmenize yardımcı olabilecek yüksek kalitede shiny uzantıların bir seçimini temsil etmektedir. Bu uzantılar belirli bir sırada değildir:• brightWidgets - bu paket size uygulamanızda kullanabileceğiniz çok daha fazla widget sunar. Bu pakette mevcut widgetların bir seçimini görmek için shinyWidgets::shinyWidgetsGallery()’yi çalıştırın. buradaki örneklere bakabilirsiniz.• shinyjs – bu uzantı, kullanıcıya bir dizi javascript aracılığıyla shiny’ye büyük ölçüde genişletme yeteneği veren mükemmel bir pakettir. Bu paketin uygulamaları çok basitten son derece gelişmişe kadar değişir, ancak ilk önce kullanıcı arabirimini öğeleri gizleme/gösterme veya düğmeleri etkinleştirme/devre dışı bırakma gibi basit yollarla değiştirmek için kullanmak isteyebilirsiniz. Daha fazlasını buradan öğrenin:• shinydashboard - bu paket, shiny’de kullanılabilecek mevcut kullanıcı arayüzünü büyük ölçüde genişletir ve özellikle kullanıcının çeşitli karmaşık düzenlerle karmaşık bir panel oluşturmasına izin verir. Burada daha fazlasını görün:• shinydashboardPlus - shinydashboard çerçevesinden daha da fazla özellik elde edin! Burada daha fazlasını görün:• shinythemes - çok çeşitli önceden ayarlanmış şablonlarla shiny uygulamanız için varsayılan css temasını değiştirin! Burada daha fazlasını görün:Shiny uyumlu etkileşimli çıktılar oluşturmak için kullanılabilecek bir dizi paket de vardır.\n• DT, temel shiny’ye yarı entegredir, ancak etkileşimli tablolar oluşturmak için harika bir dizi fonksiyon sağlar.\n• plotly, kullanıcının uygulamada değiştirebileceği etkileşimli grafikler oluşturmaya yönelik bir pakettir. Ayrıca plotly::ggplotly() yoluyla grafiğinizi etkileşimli sürümlere dönüştürebilirsiniz! Alternatif olarak, dygraphs ve highcharter da mükemmeldir.shinyWidgets - package gives many many widgets can used app. Run shinyWidgets::shinyWidgetsGallery() see selection available widgets package. See examplesshinyWidgets - package gives many many widgets can used app. Run shinyWidgets::shinyWidgetsGallery() see selection available widgets package. See examplesshinyjs - bu uzantı, kullanıcıya bir dizi javascript aracılığıyla shiny’ye büyük ölçüde genişletme yeteneği veren mükemmel bir pakettir. Bu paketin uygulamaları çok basitten son derece gelişmişe kadar değişir, ancak ilk önce kullanıcı arabirimini öğeleri gizleme/gösterme veya düğmeleri etkinleştirme/devre dışı bırakma gibi basit yollarla değiştirmek için kullanmak isteyebilirsiniz. Daha fazlasını buradan öğrenin.shinyjs - bu uzantı, kullanıcıya bir dizi javascript aracılığıyla shiny’ye büyük ölçüde genişletme yeteneği veren mükemmel bir pakettir. Bu paketin uygulamaları çok basitten son derece gelişmişe kadar değişir, ancak ilk önce kullanıcı arabirimini öğeleri gizleme/gösterme veya düğmeleri etkinleştirme/devre dışı bırakma gibi basit yollarla değiştirmek için kullanmak isteyebilirsiniz. Daha fazlasını buradan öğrenin.shinydashboard - bu paket, shiny’de kullanılabilecek mevcut kullanıcı arayüzünü büyük ölçüde genişletir ve özellikle kullanıcının çeşitli karmaşık düzenlerle karmaşık bir panel oluşturmasına izin verir. Burada daha fazlasını görünshinydashboard - bu paket, shiny’de kullanılabilecek mevcut kullanıcı arayüzünü büyük ölçüde genişletir ve özellikle kullanıcının çeşitli karmaşık düzenlerle karmaşık bir panel oluşturmasına izin verir. Burada daha fazlasını görünshinydashboardPlus - shinydashboard çerçevesinden daha da fazla özellik elde edin! Burada daha fazlasını görün.shinydashboardPlus - shinydashboard çerçevesinden daha da fazla özellik elde edin! Burada daha fazlasını görün.shinythemes - çok çeşitli önceden ayarlanmış şablonlarla shiny uygulamanız için varsayılan css temasını değiştirin! Burada daha fazlasını görün.shinythemes - çok çeşitli önceden ayarlanmış şablonlarla shiny uygulamanız için varsayılan css temasını değiştirin! Burada daha fazlasını görün.Shiny uyumlu etkileşimli çıktılar oluşturmak için kullanılabilecek bir dizi paket de vardır.\n• DT, temel shiny’ye yarı entegredir, ancak etkileşimli tablolar oluşturmak için harika bir dizi fonksiyon sağlar.\n• plotly, kullanıcının uygulamada değiştirebileceği etkileşimli grafikler oluşturmaya yönelik bir pakettir. Ayrıca plotly::ggplotly() yoluyla grafiğinizi etkileşimli sürümlere dönüştürebilirsiniz! Alternatif olarak, dygraphs ve highcharter da mükemmeldir.","code":""},{"path":"yazma-fonksiyonları.html","id":"yazma-fonksiyonları","chapter":"44 Yazma fonksiyonları","heading":"44 Yazma fonksiyonları","text":"","code":""},{"path":"yazma-fonksiyonları.html","id":"hazırlık-36","chapter":"44 Yazma fonksiyonları","heading":"44.1 Hazırlık","text":"","code":""},{"path":"yazma-fonksiyonları.html","id":"paketleri-yüklemek-2","chapter":"44 Yazma fonksiyonları","heading":"Paketleri yüklemek","text":"Bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() vurgusu yapıyoruz. R tabanından library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakabilirsiniz.","code":""},{"path":"yazma-fonksiyonları.html","id":"verileri-içe-aktar-7","chapter":"44 Yazma fonksiyonları","heading":"Verileri içe aktar","text":"Simüle edilmiş bir Ebola salgınından vakaların veri setini içe aktarıyoruz. Adım adım izlenecek verileri indirmek istiyorsanız, [Kitap ve verileri indir] sayfasındaki talimatlara bakın. Veri kümesi, rio paketinden import() fonksiyonuyla kullanılarak içe aktarılır. Verileri içe aktarmanın çeşitli yolları için İçe ve dışa aktar hakkındaki sayfaya bakabilirsiniz.Ayrıca bu sayfanın son bölümünde 2013’ten itibaren H7N9 gribiyle ilgili bazı verileri kullanacağız.","code":""},{"path":"yazma-fonksiyonları.html","id":"fonksiyonlar-1","chapter":"44 Yazma fonksiyonları","heading":"44.2 Fonksiyonlar","text":"Fonksiyonlar, kodların daha kolay anlaşılmasını, bir şekilde daha kısa olmasını ve hataya daha az meyilli olmasını sağladıklarından (fonksiyonun kendisinde herhangi bir hata olmadığı göz önüne alındığında) programlamada faydalıdır.Bu el kitabında bu kadar ileri gittiyseniz, R’da işlem bir fonksiyon çağrısı olduğundan sonsuz fonksiyonlarla karşılaşmışsınız demektir. +, , , [, $, { …. Örneğin, “x + y”, “+”(x, y)” ile aynıdırR, fonksiyonlarla en fazla çalışma olanağı sunan ve kullanıcıya bunları kolayca yazabilmesi için yeterli araçları sağlayan dillerden biridir. Fonksiyonları programlama zincirinin en üstünde veya sonunda sabit olarak düşünmemeliyiz, R onları vektörlermiş gibi kullanma ve hatta başka fonksiyonlar, listeler vb. içinde kullanma imkanı sunar.Fonksiyonel programlama üzerine çok sayıda gelişmiş kaynak mevcuttur ve biz burada yalnızca kısa pratik örneklerle fonksiyonel programlamaya başlamanıza yardımcı olacak bir fikir vereceğiz. Daha sonra bu konuda daha fazla okumak için referanslardaki bağlantıları ziyaret etmeniz önerilir.","code":""},{"path":"yazma-fonksiyonları.html","id":"neden-bir-fonksiyon-kullanırsın","chapter":"44 Yazma fonksiyonları","heading":"44.3 Neden bir fonksiyon kullanırsın?","text":"Bu soruyu yanıtlamadan önce, bu el kitabının Yineleme, döngüler ve listeler sayfasındaki ilk R fonksiyonunuzu yazmak için ipuçlarına zaten sahip olduğunuzu belirtmek önemlidir. Aslında, “/else” ve döngülerin kullanımı, genellikle birden fazla koşula izin vererek kodumuzun uygulamasını genişletmeye veya görevleri tekrarlamak için kodları yinelemeye kolayca yardımcı olduklarından, çoğu fonksiyonumuzun temel bir parçasıdır.Farklı bir değişkene veya verilere uygulamak için aynı kod bloğunu birden çok kez mi tekrarlıyorum?Farklı bir değişkene veya verilere uygulamak için aynı kod bloğunu birden çok kez mi tekrarlıyorum?Ondan kurtulmak, genel kodumu önemli ölçüde kısaltır ve daha hızlı çalışmasını sağlar mı?Ondan kurtulmak, genel kodumu önemli ölçüde kısaltır ve daha hızlı çalışmasını sağlar mı?Yazdığım kodun tekrar kullanılması ancak kodun birçok yerinde farklı bir değerle kullanılması mümkün müdür?Yazdığım kodun tekrar kullanılması ancak kodun birçok yerinde farklı bir değerle kullanılması mümkün müdür?Önceki sorulardan birinin cevabı “EVET” ise, muhtemelen bir fonksiyon yazmanız gerekir.","code":""},{"path":"yazma-fonksiyonları.html","id":"r-fonksiyonları-nasıl-oluşturur","chapter":"44 Yazma fonksiyonları","heading":"44.4 R, fonksiyonları nasıl oluşturur?","text":"R’daki fonksiyonların üç ana bileşeni vardır:fonksiyonu nasıl çağırabileceğimizi kontrol eden değişkenlerin listesi olan formals()fonksiyonu nasıl çağırabileceğimizi kontrol eden değişkenlerin listesi olan formals()fonksiyonun içindeki kod olan body(), yani nasıl yazdığımıza bağlı olarak parantez içinde veya devamındafonksiyonun içindeki kod olan body(), yani nasıl yazdığımıza bağlı olarak parantez içinde veya devamındave,fonksiyonun değişkenlerini bulmaya yardımcı olacak ve fonksiyonun nasıl değer bulacağını belirleyen environment().Fonksiyonunuzu oluşturduktan sonra, ilişkili fonksiyonu çağırarak bu bileşenlerin birini doğrulayabilirsiniz.","code":""},{"path":"yazma-fonksiyonları.html","id":"temel-sözdizimi-ve-yapı","chapter":"44 Yazma fonksiyonları","heading":"44.5 Temel sözdizimi ve yapı","text":"Bir fonksiyonun adını okuduğumuz anda işinin kolayca anlaşılması için düzgün bir şekilde adlandırılması gerekir. Aslında bu, temel R mimarisinin çoğunda zaten böyledir. ‘mean()’, ‘print()’, ‘summary()’ gibi fonksiyonların çok basit adları vardır.Bir fonksiyonun adını okuduğumuz anda işinin kolayca anlaşılması için düzgün bir şekilde adlandırılması gerekir. Aslında bu, temel R mimarisinin çoğunda zaten böyledir. ‘mean()’, ‘print()’, ‘summary()’ gibi fonksiyonların çok basit adları vardır.Bir fonksiyon, üzerinde çalışılacak veriler ve diğer seçenekler arasında statik değerler olabilen diğer nesneler gibi bağımsız değişkenlere ihtiyaç duyacaktır.Bir fonksiyon, üzerinde çalışılacak veriler ve diğer seçenekler arasında statik değerler olabilen diğer nesneler gibi bağımsız değişkenlere ihtiyaç duyacaktır.Ve son olarak bir fonksiyon, temel görevine ve kendisine verilen değişkenlere dayalı olarak bir çıktı verecektir. Genellikle çıktıyı üretmek için yerleşik fonksiyonları print(), return()… olarak kullanırız. Çıktı, mantıksal bir değer, bir sayı, bir karakter, bir veri çerçevesi… kısacası herhangi bir R nesnesi olabilir.Ve son olarak bir fonksiyon, temel görevine ve kendisine verilen değişkenlere dayalı olarak bir çıktı verecektir. Genellikle çıktıyı üretmek için yerleşik fonksiyonları print(), return()… olarak kullanırız. Çıktı, mantıksal bir değer, bir sayı, bir karakter, bir veri çerçevesi… kısacası herhangi bir R nesnesi olabilir.Temel olarak bu, bir fonksiyonun bileşimidir:contain_covid19() olarak adlandırılacak ilk fonksiyonumuzu oluşturabiliriz.Daha sonra yeni oluşturulan fonksiyonumuzun bileşenlerini doğrulayabiliriz.Şimdi fonksiyonumuzu test edeceğiz. Yazılı fonksiyonumuzu çağırmak için, onu tüm R fonksiyonlarını kullandığınız gibi, yani fonksiyon adını yazıp gerekli değişkenleri ekleyerek kullanabilirsiniz.Önlem amaçlı olarak bir değişkenin adını tekrar yazabiliriz. Ancak bunları belirtmeden kod çalışmalıdır çünkü R bellekte değişkenin konumu vardır. Değişkenlerin değerlerini doğru sıraya koyduğun sürece, fonksiyonları çağırırken değişken isimlerini yazmayı atlayabilirsiniz.O zaman değerlerden biri \"hayır\" veya \"evet\" değil ise ne olduğuna bakalım.Tanınmayan bir değişken sağlarsak bir hata alırız:Error contain_covid19(barrier_gest = \"sometimes\", wear_mask = \"yes\",  :    \"contain_covid19\" fonksiyonu bulunamadıNOT: Bazı fonksiyonlar(çoğu zaman çok kısa ve anlaşılır) bir ada ihtiyaç duymayabilir ve hızlı görev yapmak için doğrudan bir kod satırında veya başka bir fonksiyonun içinde kullanılabilir. Bunlara anonim fonksiyonlar denir.Örneğin, aşağıdaki veri kümesinde yalnızca karakter değişkenlerini tutan ilk anonim fonksiyondur.Daha sonra, veri setimizin ikinci gözlemini seçen başka bir fonksiyon (örneğin, tarihe veya ziyarete göre sıralandıktan sonra hasta başına çok sayıda kayıt içeren boylamsal verilerimiz olduğunda alakalı olabilir). Bu durumda, dplyr dışına yazan uygun fonksiyon, tüm satır numaralarını içeren vektöre uygulanacak function (x) (x%%2 == 0) olacaktır.Aynı görev için olası bir temel R kodu şöyle olacaktır:UYARI: Fonksiyonları kullanmanın kodumuzda bize yardımcı olabileceği doğru olsa da, bazı fonksiyonları yazmak, iyice düşünülmemiş, yeterince yazılmamış ve sonuç olarak hatalar döndürüyorsa, o fonksiyonu düzeltmek zaman alıcı olabilir. Bu nedenle genellikle önce R kodunun yazılması, yapmak istediğimizi yaptığından emin olunması ve ardından yukarıda listelendiği gibi üç ana bileşeni ile bir fonksiyona dönüştürülmesi önerilir.","code":"\nfunction_name <- function(argument_1, argument_2, argument_3){\n  \n           function_task\n  \n           return(output)\n}\ncontain_covid19 <- function(barrier_gest, wear_mask, get_vaccine){\n  \n                            if(barrier_gest == \"yes\" & wear_mask == \"yes\" & get_vaccine == \"yes\" ) \n       \n                            return(\"success\")\n  \n  else(\"please make sure all are yes, this pandemic has to end!\")\n}\nformals(contain_covid19)## $barrier_gest\n## \n## \n## $wear_mask\n## \n## \n## $get_vaccine\nbody(contain_covid19)## {\n##     if (barrier_gest == \"yes\" & wear_mask == \"yes\" & get_vaccine == \n##         \"yes\") \n##         return(\"success\")\n##     else (\"please make sure all are yes, this pandemic has to end!\")\n## }\nenvironment(contain_covid19)## <environment: R_GlobalEnv>\ncontain_covid19(barrier_gest = \"yes\", wear_mask = \"yes\", get_vaccine = \"yes\")## [1] \"success\"\ncontain_covid19(\"yes\", \"yes\", \"yes\")## [1] \"success\"\ncontain_covid19(barrier_gest = \"yes\", wear_mask = \"yes\", get_vaccine = \"no\")## [1] \"please make sure all are yes, this pandemic has to end!\"\ncontain_covid19(barrier_gest = \"sometimes\", wear_mask = \"yes\", get_vaccine = \"no\")\nlinelist %>% \n  dplyr::slice_head(n=10) %>%  #R tabanı \"head\" fonksiyonuna eşdeğerdir ve bu, veri kümesinin ilk n gözlemini döndürür\n  select(function(x) is.character(x)) \nlinelist %>%   \n   slice_head(n=20) %>% \n   tibble::rownames_to_column() %>% # son seçimi net bir şekilde görmek için her bir gözlemin indekslerini satır isimleri olarak ekleyin\n   filter(row_number() %%2 == 0)\nlinelist_firstobs <- head(linelist, 20)\n\nlinelist_firstobs[base::Filter(function(x) (x%%2 == 0), seq(nrow(linelist_firstobs))),]"},{"path":"yazma-fonksiyonları.html","id":"örnekler-2","chapter":"44 Yazma fonksiyonları","heading":"44.6 Örnekler","text":"","code":""},{"path":"yazma-fonksiyonları.html","id":"birkaç-sütun-için-orantı-tablolarını-döndürmek","chapter":"44 Yazma fonksiyonları","heading":"Birkaç sütun için orantı tablolarını döndürmek","text":"Evet, zaten birçok pakette bilgileri çok kolay ve güzel bir şekilde özetlememizi sağlayan güzel fonksiyonlarımız var. Ama yine de yazma fonksiyonlarına alışmak için ilk adımlarımızda kendimizinkini yapmaya çalışacağız.Bu örnekte, basit bir fonksiyon yazmanın, aynı kodu defalarca kopyalayıp yapıştırmanızı nasıl önleyeceğini göstermek istiyoruz.İPUCU: Yukarıda gösterildiği gibi, genel programlama için yaptığınız fonksiyonlarınızı yorumlamanız çok önemlidir. Bir fonksiyonun amacının bir kodu okunmaya hazır, daha kısa ve daha verimli hale getirmek olduğunu unutmayın. O zaman sadece adını okuyarak fonksiyonun ne yaptığını anlayabilmeli ve yorumları okuyarak daha fazla ayrıntıya sahip olmalıyız.İkinci bir seçenek, işlemi bir kerede yapmak için bu fonksiyonu bir döngü aracılığıyla başka bir fonksiyonda kullanmaktır:Daha basit bir yol, aşağıda ifade edildiği gibi “loop” yerine R “apply” tabanını kullanmak olabilir:İPUCU:R genellikle işlevsel bir programlama dili olarak tanımlanır ve neredeyse zaman bir kod satırı çalıştırdığınızda bazı yerleşik fonksiyonları kullanırsınız. Yazma fonksiyonları konusunda daha rahat olmak için iyi bir alışkanlık, günlük olarak kullandığınız temel fonksiyonların nasıl oluşturulduğunu sık sık içsel olarak incelemektir. Bunu yapmanın kısayolu, fonksiyonun adını seçmek ve ardından Ctrl+F2 veya fn+F2 veya Cmd+F2 (bilgisayarınıza bağlı olarak) üzerine tıklamaktır.","code":"\nproptab_multiple <- function(my_data, var_to_tab){\n  \n  #tablolamayı yapmadan önce ilgilenilen her değişkenin adını yazdırın\n  print(var_to_tab)\n\n  with(my_data,\n       rbind( #aşağıdaki iki fonksiyonun sonuçlarını satıra bağla\n        #ilgilenilen değişkeni tablo haline getirin: sadece sayıları verir\n          table(my_data[[var_to_tab]], useNA = \"no\"),\n          #ilgilenilen her değişken için oranları hesaplayın ve değeri 2 ondalık basamağa yuvarlayın\n         round(prop.table(table(my_data[[var_to_tab]]))*100,2)\n         )\n       )\n}\n\n\nproptab_multiple(linelist, \"gender\")## [1] \"gender\"##            f       m\n## [1,] 2807.00 2803.00\n## [2,]   50.04   49.96\nproptab_multiple(linelist, \"age_cat\")## [1] \"age_cat\"##          0-4     5-9  10-14  15-19   20-29 30-49 50-69 70+\n## [1,] 1095.00 1095.00 941.00 743.00 1073.00   754 95.00 6.0\n## [2,]   18.87   18.87  16.22  12.81   18.49    13  1.64 0.1\nproptab_multiple(linelist, \"outcome\")## [1] \"outcome\"##        Death Recover\n## [1,] 2582.00 1983.00\n## [2,]   56.56   43.44\nfor(var_to_tab in c(\"gender\",\"age_cat\",  \"outcome\")){\n  \n  print(proptab_multiple(linelist, var_to_tab))\n  \n}## [1] \"gender\"\n##            f       m\n## [1,] 2807.00 2803.00\n## [2,]   50.04   49.96\n## [1] \"age_cat\"\n##          0-4     5-9  10-14  15-19   20-29 30-49 50-69 70+\n## [1,] 1095.00 1095.00 941.00 743.00 1073.00   754 95.00 6.0\n## [2,]   18.87   18.87  16.22  12.81   18.49    13  1.64 0.1\n## [1] \"outcome\"\n##        Death Recover\n## [1,] 2582.00 1983.00\n## [2,]   56.56   43.44"},{"path":"yazma-fonksiyonları.html","id":"purrr-kullanımı-yinelemeli-olarak-uygulanabilen-yazma-fonksiyonları","chapter":"44 Yazma fonksiyonları","heading":"44.7 purrr kullanımı: yinelemeli olarak uygulanabilen yazma fonksiyonları","text":"","code":""},{"path":"yazma-fonksiyonları.html","id":"bir-veri-kümesindeki-birden-çok-sütunun-sınıfını-değiştirin","chapter":"44 Yazma fonksiyonları","heading":"Bir veri kümesindeki birden çok sütunun sınıfını değiştirin","text":"Orijinal ‘satır listesi’ verilerindeki birçok karakter değişkeninin analiz ve çizim amaçları için “faktör” olarak değiştirilmesi gerektiğini varsayalım. Adımı birkaç kez tekrarlamak yerine, ilgili tüm değişkenlerin dönüşümünü tek bir kod satırında yapmak için sadece lapply() kullanabiliriz.UYARI: lapply() bir liste döndürür, bu nedenle kullanımı son adım olarak ek bir değişiklik gerektirebilir.Aynı adım, purrr paketindeki map_if() fonksiyonu kullanılarak da yapılabilir.","code":"\nlinelist_factor2 <- linelist %>%\n  purrr::map_if(is.character, as.factor)\n\n\nlinelist_factor2 %>%\n        glimpse()## List of 30\n##  $ case_id             : Factor w/ 5888 levels \"00031d\",\"00086d\",..: 2134 3022 396 4203 3084 4347 179 1241 5594 430 ...\n##  $ generation          : num [1:5888] 4 4 2 3 3 3 4 4 4 4 ...\n##  $ date_infection      : Date[1:5888], format: \"2014-05-08\" NA NA \"2014-05-04\" ...\n##  $ date_onset          : Date[1:5888], format: \"2014-05-13\" \"2014-05-13\" \"2014-05-16\" \"2014-05-18\" ...\n##  $ date_hospitalisation: Date[1:5888], format: \"2014-05-15\" \"2014-05-14\" \"2014-05-18\" \"2014-05-20\" ...\n##  $ date_outcome        : Date[1:5888], format: NA \"2014-05-18\" \"2014-05-30\" NA ...\n##  $ outcome             : Factor w/ 2 levels \"Death\",\"Recover\": NA 2 2 NA 2 2 2 1 2 1 ...\n##  $ gender              : Factor w/ 2 levels \"f\",\"m\": 2 1 2 1 2 1 1 1 2 1 ...\n##  $ age                 : num [1:5888] 2 3 56 18 3 16 16 0 61 27 ...\n##  $ age_unit            : Factor w/ 2 levels \"months\",\"years\": 2 2 2 2 2 2 2 2 2 2 ...\n##  $ age_years           : num [1:5888] 2 3 56 18 3 16 16 0 61 27 ...\n##  $ age_cat             : Factor w/ 8 levels \"0-4\",\"5-9\",\"10-14\",..: 1 1 7 4 1 4 4 1 7 5 ...\n##  $ age_cat5            : Factor w/ 18 levels \"0-4\",\"5-9\",\"10-14\",..: 1 1 12 4 1 4 4 1 13 6 ...\n##  $ hospital            : Factor w/ 6 levels \"Central Hospital\",..: 4 3 6 5 2 5 3 3 3 3 ...\n##  $ lon                 : num [1:5888] -13.2 -13.2 -13.2 -13.2 -13.2 ...\n##  $ lat                 : num [1:5888] 8.47 8.45 8.46 8.48 8.46 ...\n##  $ infector            : Factor w/ 2697 levels \"00031d\",\"002e6c\",..: 2594 NA NA 2635 180 1799 1407 195 NA NA ...\n##  $ source              : Factor w/ 2 levels \"funeral\",\"other\": 2 NA NA 2 2 2 2 2 NA NA ...\n##  $ wt_kg               : num [1:5888] 27 25 91 41 36 56 47 0 86 69 ...\n##  $ ht_cm               : num [1:5888] 48 59 238 135 71 116 87 11 226 174 ...\n##  $ ct_blood            : num [1:5888] 22 22 21 23 23 21 21 22 22 22 ...\n##  $ fever               : Factor w/ 2 levels \"no\",\"yes\": 1 NA NA 1 1 1 NA 1 1 1 ...\n##  $ chills              : Factor w/ 2 levels \"no\",\"yes\": 1 NA NA 1 1 1 NA 1 1 1 ...\n##  $ cough               : Factor w/ 2 levels \"no\",\"yes\": 2 NA NA 1 2 2 NA 2 2 2 ...\n##  $ aches               : Factor w/ 2 levels \"no\",\"yes\": 1 NA NA 1 1 1 NA 1 1 1 ...\n##  $ vomit               : Factor w/ 2 levels \"no\",\"yes\": 2 NA NA 1 2 2 NA 2 2 1 ...\n##  $ temp                : num [1:5888] 36.8 36.9 36.9 36.8 36.9 37.6 37.3 37 36.4 35.9 ...\n##  $ time_admission      : Factor w/ 1072 levels \"00:10\",\"00:29\",..: NA 308 746 415 514 589 609 297 409 387 ...\n##  $ bmi                 : num [1:5888] 117.2 71.8 16.1 22.5 71.4 ...\n##  $ days_onset_hosp     : num [1:5888] 2 1 2 2 1 1 2 1 1 2 ..."},{"path":"yazma-fonksiyonları.html","id":"değişkeninin-farklı-seviyeleri-için-yinelemeli-olarak-grafikler-üretin","chapter":"44 Yazma fonksiyonları","heading":"Değişkeninin farklı seviyeleri için yinelemeli olarak grafikler üretin","text":"eyalet için H7N9 salgını sırasında Çin’de hastaların sonucunun dağılımına bakmak için burada pasta grafiği üreteceğiz. biri için kodu tekrarlamak yerine sadece oluşturacağımız bir fonksiyonu uygulayacağız.","code":"\n#highchart kullanımı için kusursuz seçenekler\noptions(highcharter.theme =   highcharter::hc_theme_smpl(tooltip = list(valueDecimals = 2)))\n\n\n#\"chart_outcome_province\" adında, veri kümesini ve sonucun dağılımını çizeceği ilin adını değişken olarak alan bir fonksiyon oluşturun.\n\nchart_outcome_province <- function(data_used, prov){\n  \n  tab_prov <- data_used %>% \n    filter(province == prov,\n           !is.na(outcome))%>% \n    group_by(outcome) %>% \n    count() %>%\n    adorn_totals(where = \"row\") %>% \n    adorn_percentages(denominator = \"col\", )%>%\n    mutate(\n        perc_outcome= round(n*100,2))\n  \n  \n  tab_prov %>%\n    filter(outcome != \"Total\") %>% \n  highcharter::hchart(\n    \"pie\", hcaes(x = outcome, y = perc_outcome),\n    name = paste0(\"Distibution of the outcome in:\", prov)\n    )\n  \n}\n\nchart_outcome_province(flu_china, \"Shanghai\")\nchart_outcome_province(flu_china,\"Zhejiang\")\nchart_outcome_province(flu_china,\"Jiangsu\")"},{"path":"yazma-fonksiyonları.html","id":"bir-değişkenin-farklı-seviyeleri-için-yinelemeli-olarak-tablolar-üretin","chapter":"44 Yazma fonksiyonları","heading":"Bir değişkenin farklı seviyeleri için yinelemeli olarak tablolar üretin","text":"Burada bir tablo halinde özetlemek için üç gösterge oluşturacağız ve bu tabloyu il için üretmek istiyoruz. Göstergelerimiz, başlangıç ile hastaneye yatış arasındaki gecikme, iyileşme yüzdesi ve vakaların medyan yaşıdır.Indicateurs pour la province de: ShanghaiIndicateursEstimationMean delay onset-hosp4.0Percentage recovery46.7Median age cases67.0Indicateurs pour la province de: JiangsuIndicateursEstimationMean delay onset-hosp6.0Percentage recovery71.4Median age cases55.0","code":"\nindic_1 <- flu_china %>% \n  group_by(province) %>% \n  mutate(\n    date_hosp= strptime(date_of_hospitalisation, format = \"%m/%d/%Y\"),\n    date_ons= strptime(date_of_onset, format = \"%m/%d/%Y\"), \n    delay_onset_hosp= as.numeric(date_hosp - date_ons)/86400,\n    mean_delay_onset_hosp = round(mean(delay_onset_hosp, na.rm=TRUE ), 0)) %>%\n  select(province, mean_delay_onset_hosp)  %>% \n  distinct()\n     \n\nindic_2 <-  flu_china %>% \n            filter(!is.na(outcome)) %>% \n            group_by(province, outcome) %>% \n            count() %>%\n            pivot_wider(names_from = outcome, values_from = n) %>% \n    adorn_totals(where = \"col\") %>% \n    mutate(\n        perc_recovery= round((Recover/Total)*100,2))%>% \n  select(province, perc_recovery)\n    \n    \n    \nindic_3 <-  flu_china %>% \n            group_by(province) %>% \n            mutate(\n                    median_age_cases = median(as.numeric(age), na.rm = TRUE)\n            ) %>% \n  select(province, median_age_cases)  %>% \n  distinct()## Warning in median(as.numeric(age), na.rm = TRUE): NAs introduced by coercion\n#üç gösterge veri kümesine katılın\n\ntable_indic_all <- indic_1 %>% \n  dplyr::left_join(indic_2, by = \"province\") %>% \n        left_join(indic_3, by = \"province\")\n\n\n#göstergeleri esnek bir tabloda yazdırın\n\n\nprint_indic_prov <-  function(table_used, prov){\n  \n  #önce yazdırma kolaylığı için veri çerçevesini biraz dönüştürün\n  indic_prov <- table_used %>%\n    filter(province==prov) %>%\n    pivot_longer(names_to = \"Indicateurs\", cols = 2:4) %>% \n   mutate( indic_label = factor(Indicateurs,\n   levels= c(\"mean_delay_onset_hosp\",\"perc_recovery\",\"median_age_cases\"),\n   labels=c(\"Mean delay onset-hosp\",\"Percentage of recovery\", \"Median age of the cases\"))\n   ) %>% \n    ungroup(province) %>% \n    select(indic_label, value)\n  \n\n    tab_print <- flextable(indic_prov)  %>%\n    theme_vanilla() %>% \n    flextable::fontsize(part = \"body\", size = 10) \n    \n    \n     tab_print <- tab_print %>% \n                  autofit()   %>%\n                  set_header_labels( \n                indic_label= \"Indicateurs\", value= \"Estimation\") %>%\n    flextable::bg( bg = \"darkblue\", part = \"header\") %>%\n    flextable::bold(part = \"header\") %>%\n    flextable::color(color = \"white\", part = \"header\") %>% \n    add_header_lines(values = paste0(\"Indicateurs pour la province de: \", prov)) %>% \nbold(part = \"header\")\n \n tab_print <- set_formatter_type(tab_print,\n   fmt_double = \"%.2f\",\n   na_str = \"-\")\n\ntab_print \n    \n}\n\n\n\n\nprint_indic_prov(table_indic_all, \"Shanghai\")\nprint_indic_prov(table_indic_all, \"Jiangsu\")"},{"path":"yazma-fonksiyonları.html","id":"iyi-işleyen-fonksiyonlar-için-ipuçları-ve-en-iyi-uygulamalar","chapter":"44 Yazma fonksiyonları","heading":"44.8 İyi işleyen fonksiyonlar için ipuçları ve en iyi Uygulamalar","text":"Fonksiyonel programlama, kodu kolaylaştırmak içindir ve okunmasını kolaylaştırır. Aşağıdaki ipuçları, temiz bir koda ve okunması kolay bir koda sahip olmanıza yardımcı olacaktır.","code":""},{"path":"yazma-fonksiyonları.html","id":"adlandırma-ve-sözdizimi","chapter":"44 Yazma fonksiyonları","heading":"Adlandırma ve sözdizimi","text":"Ortamınızda zaten mevcut olan diğer fonksiyonlar tarafından kolayca alınmış olabilecek karakterleri kullanmaktan kaçınınOrtamınızda zaten mevcut olan diğer fonksiyonlar tarafından kolayca alınmış olabilecek karakterleri kullanmaktan kaçınınFonksiyon adının başka bir okuyucu için kısa ve anlaşılır olması önerilir.Fonksiyon adının başka bir okuyucu için kısa ve anlaşılır olması önerilir.Fonksiyon adı olarak fiiller, değişken adları için isimler kullanılması tercih edilir.Fonksiyon adı olarak fiiller, değişken adları için isimler kullanılması tercih edilir.","code":""},{"path":"yazma-fonksiyonları.html","id":"sütun-adları-ve-düzenli-değerlendirme","chapter":"44 Yazma fonksiyonları","heading":"Sütun adları ve düzenli değerlendirme","text":"Değişken olarak kodunuza sağlanan sütun adlarına nasıl başvuracağınızı öğrenmek istiyorsanız, bu tidyverse programlama kılavuzunu okuyabilirsiniz. Kapsanan konular arasında tidy evaluation ve embrace {{ }} “çift ayraç” kullanımı yer alır.Örneğin, hemen yukarıda bahsedilen sayfa eğitiminden hızlı bir iskelet şablon kodu:","code":"\nvar_summary <- function(data, var) {\n  data %>%\n    summarise(n = n(), min = min({{ var }}), max = max({{ var }}))\n}\nmtcars %>% \n  group_by(cyl) %>% \n  var_summary(mpg)"},{"path":"yazma-fonksiyonları.html","id":"test-ve-hata-işleme","chapter":"44 Yazma fonksiyonları","heading":"Test ve Hata işleme","text":"Bir fonksiyonun görevi ne kadar karmaşıksa, hata olasılığı da o kadar yüksek olur. Bu nedenle, bazen hatanın nereden geldiğini hızlı bir şekilde anlamaya ve düzeltmenin bir yolunu bulmaya yardımcı olmak için fonksiyona bazı doğrulamalar eklemek gerekir.eksik(değişken) kullanarak bir değişkenin eksikliğini kontrol etmek şiddetle tavsiye edilmektedir. Bu basit kontrol, “DOĞRU” veya “YANLIŞ” değerini döndürebilir.Daha fazla algılanabilir hata için stop() kullanın.Yerleşik fonksiyonların çoğunu çalıştırdığımızda gördüğümüz gibi, belirli koşullarda açılabilen mesajlar ve uyarılar vardır. Bunları yazılı fonksiyonlarımıza message() ve warning() fonksiyonlarını kullanarak entegre edebiliriz.Yerleşik fonksiyonların çoğunu çalıştırdığımızda gördüğümüz gibi, belirli koşullarda açılabilen mesajlar ve uyarılar vardır. Bunları yazılı fonksiyonlarımıza message() ve warning() fonksiyonlarını kullanarak entegre edebiliriz.Bir fonksiyonu değişken olarak alan ve onu güvenli bir şekilde yürüten safely() kullanarak da hataları halledebiliriz. Aslında, bir hatayla karşılaşırsa fonksiyon durmadan yürütülür. safely() çıktı olarak, sonuçlar ve “atladığı” hata olan iki nesne içeren bir liste döndürür.Bir fonksiyonu değişken olarak alan ve onu güvenli bir şekilde yürüten safely() kullanarak da hataları halledebiliriz. Aslında, bir hatayla karşılaşırsa fonksiyon durmadan yürütülür. safely() çıktı olarak, sonuçlar ve “atladığı” hata olan iki nesne içeren bir liste döndürür.Önce mean() fonksiyonunu fonksiyon olarak çalıştırıp sonra safely() ile çalıştırarak doğrulayabiliriz.Daha önce de belirtildiği gibi, kodlarımızı iyi yorumlamak, çalışmalarımızda dokümantasyona sahip olmak için zaten iyi bir yoldur.","code":"\ncontain_covid19_missing <- function(barrier_gest, wear_mask, get_vaccine){\n  \n  if (missing(barrier_gest)) (print(\"please provide arg1\"))\n  if (missing(wear_mask)) print(\"please provide arg2\")\n  if (missing(get_vaccine)) print(\"please provide arg3\")\n\n\n  if (!barrier_gest == \"yes\" | wear_mask ==\"yes\" | get_vaccine == \"yes\" ) \n       \n       return (\"you can do better\")\n  \n  else(\"please make sure all are yes, this pandemic has to end!\")\n}\n\n\ncontain_covid19_missing(get_vaccine = \"yes\")## [1] \"please provide arg1\"\n## [1] \"please provide arg2\"## Error in contain_covid19_missing(get_vaccine = \"yes\"): argument \"barrier_gest\" is missing, with no default\ncontain_covid19_stop <- function(barrier_gest, wear_mask, get_vaccine){\n  \n  if(!is.character(barrier_gest)) (stop(\"arg1 should be a character, please enter the value with `yes`, `no` or `sometimes\"))\n  \n  if (barrier_gest == \"yes\" & wear_mask ==\"yes\" & get_vaccine == \"yes\" ) \n       \n       return (\"success\")\n  \n  else(\"please make sure all are yes, this pandemic has to end!\")\n}\n\n\ncontain_covid19_stop(barrier_gest=1, wear_mask=\"yes\", get_vaccine = \"no\")## Error in contain_covid19_stop(barrier_gest = 1, wear_mask = \"yes\", get_vaccine = \"no\"): arg1 should be a character, please enter the value with `yes`, `no` or `sometimes\nmap(linelist, mean)## $case_id\n## [1] NA\n## \n## $generation\n## [1] 16.56165\n## \n## $date_infection\n## [1] NA\n## \n## $date_onset\n## [1] NA\n## \n## $date_hospitalisation\n## [1] \"2014-11-03\"\n## \n## $date_outcome\n## [1] NA\n## \n## $outcome\n## [1] NA\n## \n## $gender\n## [1] NA\n## \n## $age\n## [1] NA\n## \n## $age_unit\n## [1] NA\n## \n## $age_years\n## [1] NA\n## \n## $age_cat\n## [1] NA\n## \n## $age_cat5\n## [1] NA\n## \n## $hospital\n## [1] NA\n## \n## $lon\n## [1] -13.23381\n## \n## $lat\n## [1] 8.469638\n## \n## $infector\n## [1] NA\n## \n## $source\n## [1] NA\n## \n## $wt_kg\n## [1] 52.64487\n## \n## $ht_cm\n## [1] 124.9633\n## \n## $ct_blood\n## [1] 21.20686\n## \n## $fever\n## [1] NA\n## \n## $chills\n## [1] NA\n## \n## $cough\n## [1] NA\n## \n## $aches\n## [1] NA\n## \n## $vomit\n## [1] NA\n## \n## $temp\n## [1] NA\n## \n## $time_admission\n## [1] NA\n## \n## $bmi\n## [1] 46.89023\n## \n## $days_onset_hosp\n## [1] NA\nsafe_mean <- safely(mean)\nlinelist %>% \n  map(safe_mean)## $case_id\n## $case_id$result\n## [1] NA\n## \n## $case_id$error\n## NULL\n## \n## \n## $generation\n## $generation$result\n## [1] 16.56165\n## \n## $generation$error\n## NULL\n## \n## \n## $date_infection\n## $date_infection$result\n## [1] NA\n## \n## $date_infection$error\n## NULL\n## \n## \n## $date_onset\n## $date_onset$result\n## [1] NA\n## \n## $date_onset$error\n## NULL\n## \n## \n## $date_hospitalisation\n## $date_hospitalisation$result\n## [1] \"2014-11-03\"\n## \n## $date_hospitalisation$error\n## NULL\n## \n## \n## $date_outcome\n## $date_outcome$result\n## [1] NA\n## \n## $date_outcome$error\n## NULL\n## \n## \n## $outcome\n## $outcome$result\n## [1] NA\n## \n## $outcome$error\n## NULL\n## \n## \n## $gender\n## $gender$result\n## [1] NA\n## \n## $gender$error\n## NULL\n## \n## \n## $age\n## $age$result\n## [1] NA\n## \n## $age$error\n## NULL\n## \n## \n## $age_unit\n## $age_unit$result\n## [1] NA\n## \n## $age_unit$error\n## NULL\n## \n## \n## $age_years\n## $age_years$result\n## [1] NA\n## \n## $age_years$error\n## NULL\n## \n## \n## $age_cat\n## $age_cat$result\n## [1] NA\n## \n## $age_cat$error\n## NULL\n## \n## \n## $age_cat5\n## $age_cat5$result\n## [1] NA\n## \n## $age_cat5$error\n## NULL\n## \n## \n## $hospital\n## $hospital$result\n## [1] NA\n## \n## $hospital$error\n## NULL\n## \n## \n## $lon\n## $lon$result\n## [1] -13.23381\n## \n## $lon$error\n## NULL\n## \n## \n## $lat\n## $lat$result\n## [1] 8.469638\n## \n## $lat$error\n## NULL\n## \n## \n## $infector\n## $infector$result\n## [1] NA\n## \n## $infector$error\n## NULL\n## \n## \n## $source\n## $source$result\n## [1] NA\n## \n## $source$error\n## NULL\n## \n## \n## $wt_kg\n## $wt_kg$result\n## [1] 52.64487\n## \n## $wt_kg$error\n## NULL\n## \n## \n## $ht_cm\n## $ht_cm$result\n## [1] 124.9633\n## \n## $ht_cm$error\n## NULL\n## \n## \n## $ct_blood\n## $ct_blood$result\n## [1] 21.20686\n## \n## $ct_blood$error\n## NULL\n## \n## \n## $fever\n## $fever$result\n## [1] NA\n## \n## $fever$error\n## NULL\n## \n## \n## $chills\n## $chills$result\n## [1] NA\n## \n## $chills$error\n## NULL\n## \n## \n## $cough\n## $cough$result\n## [1] NA\n## \n## $cough$error\n## NULL\n## \n## \n## $aches\n## $aches$result\n## [1] NA\n## \n## $aches$error\n## NULL\n## \n## \n## $vomit\n## $vomit$result\n## [1] NA\n## \n## $vomit$error\n## NULL\n## \n## \n## $temp\n## $temp$result\n## [1] NA\n## \n## $temp$error\n## NULL\n## \n## \n## $time_admission\n## $time_admission$result\n## [1] NA\n## \n## $time_admission$error\n## NULL\n## \n## \n## $bmi\n## $bmi$result\n## [1] 46.89023\n## \n## $bmi$error\n## NULL\n## \n## \n## $days_onset_hosp\n## $days_onset_hosp$result\n## [1] NA\n## \n## $days_onset_hosp$error\n## NULL"},{"path":"yazma-fonksiyonları.html","id":"kaynaklar-35","chapter":"44 Yazma fonksiyonları","heading":"44.9 Kaynaklar","text":"Veri Bilimi için Rİleri R Programlama Pratik Kılavuzupurr Paket Pratik KılavuzuHadley Wickham’dan Video-ACM konuşması: Fonksiyonel programlamanın keyfi (map_dbl nasıl çalışır?)","code":""},{"path":"dizin-etkileşimleri.html","id":"dizin-etkileşimleri","chapter":"45 Dizin etkileşimleri","heading":"45 Dizin etkileşimleri","text":"Bu sayfada, dizinler (klasörler) oluşturduğunuz, etkileşimde bulunduğunuz, kaydettiğiniz ve içe aktardığınız genel senaryoları ele alıyoruz.","code":""},{"path":"dizin-etkileşimleri.html","id":"hazırlık-37","chapter":"45 Dizin etkileşimleri","heading":"45.1 Hazırlık","text":"","code":""},{"path":"dizin-etkileşimleri.html","id":"fs-paketi","chapter":"45 Dizin etkileşimleri","heading":"fs paketi","text":"fs paketi, dizin etkileşimlerini kolaylaştıran ve bazı R tabanı fonksiyonlarını geliştiren bir tidyverse paketidir. Aşağıdaki bölümlerde genellikle fs’den gelen fonksiyonları kullanacağız.","code":"\npacman::p_load(\n  fs,             # dosya/dizin etkileşimleri\n  rio,            # içe aktar/dışa aktar\n  here,           # göreceli dosya yolakları\n  tidyverse)      # veri yönetimi ve görselleştirme"},{"path":"dizin-etkileşimleri.html","id":"dizini-bir-dendrogram-ağacı-olarak-yazdır","chapter":"45 Dizin etkileşimleri","heading":"Dizini bir dendrogram ağacı olarak yazdır","text":"fs’den dir_tree() fonksiyonunu kullanın.Klasör dosya yolunu path = olarak sağlayın ve yalnızca bir seviyeyi mi (recurse = FALSE) yoksa tüm alt seviyelerdeki tüm dosyaları mı (recurse = TRUE) göstermek istediğinize karar verin. Aşağıda, R projesi için kısayol olarak () kullanıyoruz ve bu R el kitabı için kullanılan tüm verileri içeren alt klasör “verilerini” belirledik. “veri” ve alt klasörlerindeki (örneğin “önbellek”, “salgın modelleri”, “nüfus”, “shp” ve “hava durumu”) içindeki tüm dosyaları gösterecek şekilde ayarladık.","code":"\nfs::dir_tree(path = here(\"data\"), recurse = TRUE)## C:/Users/neale/Documents/Applied Epi/repos/epiRhandbook_tr/data\n## ├── cache\n## │   └── epidemic_models\n## │       ├── 2015-04-30\n## │       │   ├── estimated_reported_cases_samples.rds\n## │       │   ├── estimate_samples.rds\n## │       │   ├── latest_date.rds\n## │       │   ├── reported_cases.rds\n## │       │   ├── summarised_estimated_reported_cases.rds\n## │       │   ├── summarised_estimates.rds\n## │       │   └── summary.rds\n## │       ├── epinow_res.rds\n## │       ├── epinow_res_small.rds\n## │       ├── generation_time.rds\n## │       └── incubation_period.rds\n## ├── case_linelists\n## │   ├── cleaning_dict.csv\n## │   ├── fluH7N9_China_2013.csv\n## │   ├── linelist_cleaned.rds\n## │   ├── linelist_cleaned.xlsx\n## │   └── linelist_raw.xlsx\n## ├── example\n## │   ├── Central Hospital.csv\n## │   ├── district_weekly_count_data.xlsx\n## │   ├── fluH7N9_China_2013.csv\n## │   ├── hospital_linelists.xlsx\n## │   ├── linelists\n## │   │   ├── 20201007linelist.csv\n## │   │   ├── case_linelist20201006.csv\n## │   │   ├── case_linelist_2020-10-02.csv\n## │   │   ├── case_linelist_2020-10-03.csv\n## │   │   ├── case_linelist_2020-10-04.csv\n## │   │   ├── case_linelist_2020-10-05.csv\n## │   │   └── case_linelist_2020-10-08.xlsx\n## │   ├── Military Hospital.csv\n## │   ├── Missing.csv\n## │   ├── Other.csv\n## │   ├── Port Hospital.csv\n## │   └── St. Mark's Maternity Hospital (SMMH).csv\n## ├── flexdashboard\n## │   ├── outbreak_dashboard.html\n## │   ├── outbreak_dashboard.Rmd\n## │   ├── outbreak_dashboard_shiny.Rmd\n## │   ├── outbreak_dashboard_test.html\n## │   └── outbreak_dashboard_test.Rmd\n## ├── gis\n## │   ├── africa_countries.geo.json\n## │   ├── covid_incidence.csv\n## │   ├── covid_incidence_map.R\n## │   ├── linelist_cleaned_with_adm3.rds\n## │   ├── population\n## │   │   ├── sle_admpop_adm3_2020.csv\n## │   │   └── sle_population_statistics_sierraleone_2020.xlsx\n## │   └── shp\n## │       ├── README.txt\n## │       ├── sle_adm3.CPG\n## │       ├── sle_adm3.dbf\n## │       ├── sle_adm3.prj\n## │       ├── sle_adm3.sbn\n## │       ├── sle_adm3.sbx\n## │       ├── sle_adm3.shp\n## │       ├── sle_adm3.shp.xml\n## │       ├── sle_adm3.shx\n## │       ├── sle_hf.CPG\n## │       ├── sle_hf.dbf\n## │       ├── sle_hf.prj\n## │       ├── sle_hf.sbn\n## │       ├── sle_hf.sbx\n## │       ├── sle_hf.shp\n## │       └── sle_hf.shx\n## ├── godata\n## │   ├── cases_clean.rds\n## │   ├── contacts_clean.rds\n## │   ├── followups_clean.rds\n## │   └── relationships_clean.rds\n## ├── likert_data.csv\n## ├── linelist_cleaned.xlsx\n## ├── make_evd_dataset.R\n## ├── malaria_app\n## │   ├── app.R\n## │   ├── data\n## │   │   └── facility_count_data.rds\n## │   ├── funcs\n## │   │   └── plot_epicurve.R\n## │   ├── global.R\n## │   ├── malaria_app.Rproj\n## │   ├── server.R\n## │   └── ui.R\n## ├── malaria_facility_count_data.rds\n## ├── phylo\n## │   ├── sample_data_Shigella_tree.csv\n## │   ├── Shigella_subtree_2.nwk\n## │   ├── Shigella_subtree_2.txt\n## │   └── Shigella_tree.txt\n## ├── rmarkdown\n## │   ├── outbreak_report.docx\n## │   ├── outbreak_report.html\n## │   ├── outbreak_report.pdf\n## │   ├── outbreak_report.pptx\n## │   ├── outbreak_report.Rmd\n## │   ├── report_tabbed_example.html\n## │   └── report_tabbed_example.Rmd\n## ├── standardization\n## │   ├── country_demographics.csv\n## │   ├── country_demographics_2.csv\n## │   ├── deaths_countryA.csv\n## │   ├── deaths_countryB.csv\n## │   └── world_standard_population_by_sex.csv\n## ├── surveys\n## │   ├── population.xlsx\n## │   ├── survey_data.xlsx\n## │   └── survey_dict.xlsx\n## └── time_series\n##     ├── campylobacter_germany.xlsx\n##     └── weather\n##         ├── germany_weather2002.nc\n##         ├── germany_weather2003.nc\n##         ├── germany_weather2004.nc\n##         ├── germany_weather2005.nc\n##         ├── germany_weather2006.nc\n##         ├── germany_weather2007.nc\n##         ├── germany_weather2008.nc\n##         ├── germany_weather2009.nc\n##         ├── germany_weather2010.nc\n##         └── germany_weather2011.nc"},{"path":"dizin-etkileşimleri.html","id":"bir-dizindeki-dosyaları-listeleyin","chapter":"45 Dizin etkileşimleri","heading":"45.2 Bir dizindeki dosyaları listeleyin","text":"Bir dizindeki yalnızca dosya adlarını listelemek için R tabanından dir() kullanabilirsiniz. Örneğin, bu komut, içindeki “data” klasörünün “population” alt klasöründeki dosyaların adlarını listeler. Göreli dosya yolu, ‘()’ kullanılarak sağlanır (bunun hakkında daha fazla bilgiyi [İçe aktarma ve dışa aktarma] sayfasında okuyabilirsiniz).Dizin dosyalarının tam dosya yollarını listelemek için fs’den dir_ls() kullanabilirsiniz. Bir diğer R alternatifi “list.files()”dir.Bir dizindeki dosyayla ilgili tüm meta veri bilgilerini almak için (ör. yol, değişiklik tarihi vb.), fs’den dir_info() kullanabilirsiniz.Bu, örneğin dosyanın en son sürümünü içe aktarmak istediğinizde, dosyanın son değişiklik zamanını çıkarmak istiyorsanız özellikle yararlı olabilir. Bunun bir örneği için İçe ve dışa aktar sayfasına bakın.İşte döndürülen veri çerçevesi. Tüm sütunları görmek için sağa kaydırın.","code":"\n# dosya adları\ndir(here(\"data\", \"gis\", \"population\"))## [1] \"sle_admpop_adm3_2020.csv\"                        \"sle_population_statistics_sierraleone_2020.xlsx\"\n# dosya yolları\ndir_ls(here(\"data\", \"gis\", \"population\"))## C:/Users/neale/Documents/Applied Epi/repos/epiRhandbook_tr/data/gis/population/sle_admpop_adm3_2020.csv\n## C:/Users/neale/Documents/Applied Epi/repos/epiRhandbook_tr/data/gis/population/sle_population_statistics_sierraleone_2020.xlsx\n# dosya bilgisi\ndir_info(here(\"data\", \"gis\", \"population\"))"},{"path":"dizin-etkileşimleri.html","id":"dosya-bilgisi","chapter":"45 Dizin etkileşimleri","heading":"45.3 Dosya bilgisi","text":"Belirli bir dosya hakkında meta veri bilgilerini çıkarmak için, fs’den file_info() (veya R tabanından file.info()) kullanabilirsiniz.Burada sonucu dizine eklemek ve yalnızca “modification_time” değerini döndürmek için $ kullanıyoruz.","code":"\nfile_info(here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))\nfile_info(here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))$modification_time## [1] \"2022-11-20 16:20:50 CET\""},{"path":"dizin-etkileşimleri.html","id":"var-olup-olmadığını-kontrol-edin","chapter":"45 Dizin etkileşimleri","heading":"45.4 Var olup olmadığını kontrol edin","text":"","code":""},{"path":"dizin-etkileşimleri.html","id":"r-nesneleri","chapter":"45 Dizin etkileşimleri","heading":"R nesneleri","text":"Bir R nesnesinin * R içinde * olup olmadığını kontrol etmek için ‘exists()’ kullanabilirsiniz (nesne adını tırnak içinde sağlayın).Bazı R tabanı paketlerinin, sahne arkasında “data” gibi genel nesne adları kullandığını ve “inherit= YANLIŞ” belirtilmediği sürece DOĞRU olarak görüneceğini unutmayın. Bu, veri kümenizi “data” olarak adlandırmamanın bir nedenidir.Bir fonksiyon yazıyorsanız, bir değişken olup olmadığını kontrol etmek için ‘exists()’ yerine ‘missing()’ kullanmalısınız.","code":"\nexists(\"linelist\")## [1] TRUE\nexists(\"data\")## [1] TRUE\nexists(\"data\", inherit = FALSE)## [1] FALSE"},{"path":"dizin-etkileşimleri.html","id":"dizinler","chapter":"45 Dizin etkileşimleri","heading":"Dizinler","text":"Bir dizinin var olup olmadığını kontrol etmek için, fs’den is_dir() dizinine dosya yolunu (ve dosya adını) sağlayın. “TRUE” yazısının yazdırıldığını görmek için sağa kaydırın.Alternatif olarak file.exists() kullanılabilir.","code":"\nis_dir(here(\"data\"))## C:/Users/neale/Documents/Applied Epi/repos/epiRhandbook_tr/data \n##                                                            TRUE"},{"path":"dizin-etkileşimleri.html","id":"dosyalar","chapter":"45 Dizin etkileşimleri","heading":"Dosyalar","text":"Belirli bir dosyanın var olup olmadığını kontrol etmek için fs’den is_file() kullanın. “TRUE” yazısının yazdırıldığını görmek için sağa kaydırın.Alternatif olarak file.exists() kullanılabilir.","code":"\nis_file(here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))## C:/Users/neale/Documents/Applied Epi/repos/epiRhandbook_tr/data/case_linelists/linelist_cleaned.rds \n##                                                                                                TRUE"},{"path":"dizin-etkileşimleri.html","id":"oluşturmak","chapter":"45 Dizin etkileşimleri","heading":"45.5 Oluşturmak","text":"","code":""},{"path":"dizin-etkileşimleri.html","id":"dizinler-1","chapter":"45 Dizin etkileşimleri","heading":"Dizinler","text":"Yeni bir dizin (klasör) oluşturmak için fs’den dir_create() kullanabilirsiniz. Dizin zaten mevcutsa, üzerine yazılmaz ve hiçbir hata döndürülmez.Bir alternatif, dizin zaten mevcutsa bir hata gösterecek olan dir.create()dir. Buna karşılık, bu senaryoda dir_create() sessiz olacaktır.","code":"\ndir_create(here(\"data\", \"test\"))"},{"path":"dizin-etkileşimleri.html","id":"dosyalar-1","chapter":"45 Dizin etkileşimleri","heading":"Dosyalar","text":"fs’den file_create() ile (boş) bir dosya oluşturabilirsiniz. Dosya zaten mevcutsa, üzerine yazılmaz veya değiştirilmez.Alternatifi file.create(). Ancak dosya zaten mevcutsa, bu seçenek dosyayı kesecektir. file_create() kullanırsanız, dosya değişmeden kalacaktır.","code":"\nfile_create(here(\"data\", \"test.rds\"))"},{"path":"dizin-etkileşimleri.html","id":"yoksa-oluştur","chapter":"45 Dizin etkileşimleri","heading":"Yoksa oluştur","text":"YAPIM AŞAMASINDA…","code":""},{"path":"dizin-etkileşimleri.html","id":"silmek","chapter":"45 Dizin etkileşimleri","heading":"45.6 Silmek","text":"","code":""},{"path":"dizin-etkileşimleri.html","id":"r-nesneleri-1","chapter":"45 Dizin etkileşimleri","heading":"R nesneleri","text":"Bir R nesnesini kaldırmak için ‘rm()’ kullanın.","code":""},{"path":"dizin-etkileşimleri.html","id":"dizinler-2","chapter":"45 Dizin etkileşimleri","heading":"Dizinler","text":"fs’den dir_delete() kullanın.","code":""},{"path":"dizin-etkileşimleri.html","id":"dosyalar-2","chapter":"45 Dizin etkileşimleri","heading":"Dosyalar","text":"Dosyaları fs içinden file_delete() ile silebilirsiniz.","code":""},{"path":"dizin-etkileşimleri.html","id":"diğer-dosyaları-çalıştırma","chapter":"45 Dizin etkileşimleri","heading":"45.7 Diğer dosyaları çalıştırma","text":"","code":""},{"path":"dizin-etkileşimleri.html","id":"source","chapter":"45 Dizin etkileşimleri","heading":"source()","text":"Bir R betiğini başka bir R betiğinden çalıştırmak için source() komutunu kullanabilirsiniz (R tabanından).Bu, yukarıdaki R komut dosyasını görüntülemeye ve komut dosyasının sağ üst köşesindeki “Kaynak” düğmesine tıklamaya eşdeğerdir. Bu, betiği çalıştıracak, ancak özellikle istenmedikçe sessizce yapacak (R konsoluna çıktı yok). Soru-cevap modunda R konsolu aracılığıyla bir kullanıcıyla etkileşim kurmak için “source()” kullanma örnekleri için [Etkileşimli konsol] sayfasındaki sayfaya bakabilirsiniz.","code":"\nsource(here(\"scripts\", \"cleaning_scripts\", \"clean_testing_data.R\"))"},{"path":"dizin-etkileşimleri.html","id":"render","chapter":"45 Dizin etkileşimleri","heading":"render()","text":"“render()”, en sık R işaretleme komut dosyaları için kullanılan “source()”un bir varyasyonudur. R işaretleme dosyası olan input = ve ayrıca output_format = (tipik olarak “html_document”, “pdf_document”, “word_document”, ““) sağlamaktadır.Daha fazla ayrıntı için R Markdown ile Raporlar hakkındaki sayfaya bakabilirsiniz. Ayrıca “render()” belgelerine buradan veya “?render” girerek bakabilirsiniz.","code":""},{"path":"dizin-etkileşimleri.html","id":"dosyaları-dizinde-çalıştırın","chapter":"45 Dizin etkileşimleri","heading":"Dosyaları dizinde çalıştırın","text":"Bir loop oluşturabilir ve bunu ‘dir()’ ile tanımlanan bir dizindeki dosyayı ‘source()’ için kullanabilirsiniz.Yalnızca belirli komut dosyalarını çalıştırmak istiyorsanız, bunları şu şekilde adlarıyla tanımlayabilirsiniz:fs ve R tabanı fonksiyonlarının karşılaştırması","code":"\nfor(script in dir(here(\"scripts\"), pattern = \".R$\")) {   # R Project'in \"scripts\" klasöründeki her bir komut dosyası adı için (.R uzantılı)\n  source(here(\"scripts\", script))                        # dosyayı, komut dosyaları klasöründe bulunan eşleşen adla kaynaklayın\n}\nscripts_to_run <- c(\n     \"epicurves.R\",\n     \"demographic_tables.R\",\n     \"survival_curves.R\"\n)\n\nfor(script in scripts_to_run) {\n  source(here(\"scripts\", script))\n}"},{"path":"dizin-etkileşimleri.html","id":"dosyaları-dizine-aktarın","chapter":"45 Dizin etkileşimleri","heading":"Dosyaları dizine aktarın","text":"Tek tek dosyaları içe ve dışa aktarmak için [İçe ve dışa aktarma] hakkındaki sayfaya bakabilirsiniz.Ayrıca dosya meta verilerine bakarak veya dosya adındaki bir tarihe dayalı olarak en son dosyayı otomatik olarak içe aktarma yöntemleri için İçe ve dışa aktar sayfasına bakabilirsiniz.purrr paketinin aşağıdakileri gösterdiği bir örnek için Yineleme, döngüler ve listeler hakkındaki sayfaya bakabilirsiniz:Bir veri çerçevesini bölme ve birden çok CSV dosyası olarak kaydetmeBir veri çerçevesini bölme ve bir parçayı tek bir Excel çalışma kitabında ayrı bir sayfa olarak kaydetmeBirden fazla CSV dosyasını içe aktarma ve bunları tek bir veri çerçevesinde birleştirmeBirden çok sayfa içeren bir Excel çalışma kitabını içe aktarma ve bunları tek bir veri çerçevesinde birleştirme","code":""},{"path":"dizin-etkileşimleri.html","id":"r-tabanı-1","chapter":"45 Dizin etkileşimleri","heading":"45.8 R tabanı","text":"Belirtilen bir dizindeki dosyaları listelemekle aynı işlemi gerçekleştiren list.files() ve dir() fonksiyonlarına aşağıda bakın. “ignore.case =” veya aranacak belirli bir desen belirtebilirsiniz.Bir dosya şu anda “açık” ise, klasörünüzde “~$hospital_linelists.xlsx” gibi bir yaklaşık işareti olacak şekilde görüntülenir.","code":"\nlist.files(path = here(\"data\"))\n\nlist.files(path = here(\"data\"), pattern = \".csv\")\n# dir(path = here(\"data\"), pattern = \".csv\")\n\nlist.files(path = here(\"data\"), pattern = \"evd\", ignore.case = TRUE)"},{"path":"dizin-etkileşimleri.html","id":"kaynaklar-36","chapter":"45 Dizin etkileşimleri","heading":"45.9 Kaynaklar","text":"https://cran.r-project.org/web/packages/fs/vignettes/function-comparisons.html","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"46 Git ve Github ile sürüm kontrolü ve işbirliği","text":"Bu bölüm, Git’başkalarıyla işbirliği yapmak için kullanmaya genel bir bakış sunar. Daha kapsamlı öğreticiler, Kaynaklar bölümünün alt kısmında bulunabilir.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"git-nedir","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"46.1 Git nedir?","text":"Git, bir klasördeki değişiklikleri izlemeye izin veren bir sürüm kontrol yazılımıdır. Word, LibreOffice veya Google belgelerindeki “değişikliği izle” seçeneği gibi kullanılabilir. Sürüm kontrolü için en güçlü ve en çok kullanılan seçeneklerden biridir.Neden hiç duymadım? \nGeliştirici geçmişine sahip kişiler rutin olarak sürüm kontrol yazılımlarını (Git, Mercurial, Subversion veya diğerleri) kullanmayı öğrenirken, nicel disiplinlerden pek azımıza bu beceriler öğretilir. Sonuç olarak, çoğu epidemiyolog, çalışmaları sırasında bunu asla duymaz ve iş sırasında öğrenmek zorundadır.Bekle, Github’ı duydum, aynı mı?\nTam olarak değil, ancak bunları sıklıkla birlikte kullanıyorsunuz ve size nasıl yapılacağını göstereceğiz. Kısacası:\nGit, bir yazılım parçası olan sürüm kontrol sistemidir. Bilgisayarınızda yerel olarak veya bir klasörü ana bilgisayar web sitesi ile senkronize etmek için kullanabilirsiniz. Varsayılan olarak, komut satırında Git talimatlarını vermek için bir terminal kullanılır.Komut satırından kaçınmak ve aynı eylemleri gerçekleştirmek için bir Git istemcisi/arayüz kullanabilirsiniz (en azından basit, çok yaygın olanlar için).Klasörünüzü başkalarıyla işbirliği yapmak için bir ana web sitesinde depolamak istiyorsanız, Github, Gitlab, Bitbucket veya diğerlerinde bir hesap oluşturabilirsiniz.Böylece, dosyalarınızı hem yerel olarak bilgisayarınızda hem de bir Github sunucusunda uzaktan yönetmek için arka planda Git kullanan Github Desktop istemcisini/arayüzünü kullanabilirsiniz.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"neden-git-ve-github-kombinasyonunu-kullanmalısınız","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"46.2 Neden Git ve Github kombinasyonunu kullanmalısınız?","text":"Git kullanımı şunları kolaylaştırır:Herhangi bir önceki duruma kolayca geri dönebilmeniz için belgelenmiş sürümleri artımlı değişikliklerle arşivlemeParalel dallara sahip olmak, yani gözden geçirmeden sonra değişiklikleri entegre etmek için yapılandırılmış yollarla geliştirilen/“çalışan” sürümlerBu, başkalarıyla işbirliği yapmasanız bile bilgisayarınızda yerel olarak yapılabilir. Sen hiç:bir kod bölümünü sildiğiniz için pişmanlık duydunuz, ancak iki ay sonra gerçekten ihtiyacınız olduğunu fark ettiniz mi?bir kod bölümünü sildiğiniz için pişmanlık duydunuz, ancak iki ay sonra gerçekten ihtiyacınız olduğunu fark ettiniz mi?duraklatılmış bir projeye geri dönün ve modellerden birinde bu zor değişikliği yapıp yapmadığınızı hatırlamaya çalıştınız mı?duraklatılmış bir projeye geri dönün ve modellerden birinde bu zor değişikliği yapıp yapmadığınızı hatırlamaya çalıştınız mı?denemek için bir model_1.R dosyası ve başka bir model_1_test.R dosyası ve bir model_1_not_working.R dosyası mı vardı?denemek için bir model_1.R dosyası ve başka bir model_1_test.R dosyası ve bir model_1_not_working.R dosyası mı vardı?bir report.Rmd dosyası, bir report_full.Rmd dosyası, bir report_true_final.Rmd dosyası, bir report_final_20210304.Rmd dosyası, bir report_final_20210402.Rmd dosyası vardı ve arşivleme becerilerinize lanet mi okudunuz?bir report.Rmd dosyası, bir report_full.Rmd dosyası, bir report_true_final.Rmd dosyası, bir report_final_20210304.Rmd dosyası, bir report_final_20210402.Rmd dosyası vardı ve arşivleme becerilerinize lanet mi okudunuz?Git tüm bunlara yardımcı olacak ve sadece bunun için öğrenmeye değer.Ancak, işbirlikçi projeleri desteklemek için Github gibi bir çevrimiçi depo ile kullanıldığında daha da güçlü hale gelir. Bu şunları kolaylaştırır:İşbirliği: diğerleri değişiklikleri inceleyebilir, yorumlayabilir ve değişiklikleri kabul edebilir/reddetebilirİşbirliği: diğerleri değişiklikleri inceleyebilir, yorumlayabilir ve değişiklikleri kabul edebilir/reddetebilirKodunuzu, verilerinizi ve çıktılarınızı paylaşmak ve halktan (veya ekibinizle özel olarak) geri bildirim davet etmek ve şunlardan kaçınmak:Kodunuzu, verilerinizi ve çıktılarınızı paylaşmak ve halktan (veya ekibinizle özel olarak) geri bildirim davet etmek ve şunlardan kaçınmak:“Hata, son sürümü göndermeyi unuttum ve şimdi bu yeni dosya üzerinde iki günlük çalışmayı yeniden yapmanız gerekiyor”“Hata, son sürümü göndermeyi unuttum ve şimdi bu yeni dosya üzerinde iki günlük çalışmayı yeniden yapmanız gerekiyor”Mina, Henry ve Oumar aynı anda tek bir komut dosyası üzerinde çalıştı ve değişikliklerini manuel olarak birleştirmeleri gerekiyorMina, Henry ve Oumar aynı anda tek bir komut dosyası üzerinde çalıştı ve değişikliklerini manuel olarak birleştirmeleri gerekiyorDropbox ve Sharepoint üzerinde iki kişi aynı dosyayı değiştirmeye çalışıyor ve bu bir senkronizasyon hatası yaratıyor.Dropbox ve Sharepoint üzerinde iki kişi aynı dosyayı değiştirmeye çalışıyor ve bu bir senkronizasyon hatası yaratıyor.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"kulağa-karmaşık-geliyor-ben-programcı-değilim","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Kulağa karmaşık geliyor, ben programcı değilim","text":"Olabilir. Gelişmiş kullanım örnekleri oldukça korkutucu olabilir. Ancak, R’ye ve hatta Excel’e çok benzer şekilde, aracın avantajlarından yararlanmak için uzman olmanıza gerek yoktur. Az sayıda işlev ve kavram öğrenmek, değişikliklerinizi izlemenize, dosyalarınızı çevrimiçi bir havuzda senkronize etmenize ve çok kısa bir süre içinde iş arkadaşlarınızla işbirliği yapmanıza olanak tanır.Öğrenme eğrisi nedeniyle, acil durum bağlamı bu araçları öğrenmek için en iyi zaman olmayabilir. Ancak öğrenme adım adım gerçekleştirilebilir. Birkaç kavram edindikten sonra, iş akışınız oldukça verimli ve hızlı olabilir.Git aracılığıyla insanlarla işbirliği yapmanın bir zorunluluk olduğu bir proje üzerinde çalışmıyorsanız, ortak çalışmaya dalmadan önce onu solo olarak kullanmaktan emin olmak için iyi bir zamandır.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"kurmak","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"46.3 Kurmak","text":"","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"giti-yükleyin","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Git’i yükleyin","text":"Git, bilgisayarınızda değişiklikleri, dalları (sürümleri), birleştirmeleri ve geri dönmeyi izleyen perde arkasındaki motordur. Önce yapmanız gerekir\nhttps://git-scm.com/downloads adresinden Git’yükleyin.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"bir-arayüz-kurun-isteğe-bağlı-ancak-önerilir","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Bir arayüz kurun (isteğe bağlı ancak önerilir)","text":"Git’komut satırı terminaline yazılabilen kendi komut dili vardır. Bununla birlikte, birçok istemci/arayüz vardır ve geliştirici olmayanlar olarak, günlük kullanımınızda Git ile doğrudan etkileşime nadiren _ihtiyacınız olur ve arayüz genellikle dosya değişiklikleri veya dalları için güzel görselleştirme araçları sağlar.Yeni başlayanlardan daha karmaşık olanlara kadar tüm işletim sistemlerinde birçok seçenek mevcuttur. Yeni başlayanlar için iyi seçenekler arasında RStudio Git bölmesi ve\nGithub Desktop, ki bu bölümde durum nasıl olacak.Orta (daha güçlü, ancak daha karmaşık) seçenekler arasında Source Tree, Gitkracken, Smart Git ve diğerleri bulunur.Git istemcileri hakkında hızlı açıklama.: Arabirimlerin tümü Git’dahili olarak kullandığından, bunlardan birkaçını deneyebilir, belirli bir projede birinden diğerine geçebilir, konsolu arabiriminizin desteklemediği bir eylem için zamanında kullanabilir ve hatta üzerinde herhangi bir sayıda çevrimiçi eylem gerçekleştirebilirsiniz. Github.Aşağıda belirtildiği gibi, zaman zaman Git komutlarını RStudio terminal bölmesi (R Konsoluna bitişik bir sekme) veya Git Bash terminali gibi bir terminale yazmanız gerekebilir.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"github-hesabı","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Github hesabı","text":"github.com adresinde ücretsiz bir hesap için kaydolun.Bir uygulama ile iki faktörlü kimlik doğrulamayı ayarlamanız istenebilir.\nTelefonunuz. Github yardım belgelerinde daha fazlasını okuyun.Github Desktop kullanıyorsanız, kurulumdan sonra bu adımları izleyerek Gitub kimlik bilgilerinizi girebilirsiniz. .\nBunu bilmiyorsanız, daha sonra yapmaya çalıştığınızda kimlik bilgileri sorulacaktır.\nGithub’dan bir projeyi klonlayın.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"kelime-bilgisi-kavramlar-ve-temel-işlevler","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"46.4 Kelime bilgisi, kavramlar ve temel işlevler","text":"R öğrenirken olduğu gibi Git’anlamak için hatırlamanız gereken biraz kelime hazinesi vardır. İşte başlamanıza yardımcı olacak temel bilgiler/ etkileşimli öğretici. Sonraki bölümlerde, arayüzlerin nasıl kullanılacağını göstereceğiz, ancak zihinsel modelinizi oluşturmak için kelime dağarcığı ve kavramları aklınızda bulundurmak iyidir ve arayüzleri kullanırken bunlara ihtiyacınız olacaktır.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"depo","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Depo","text":"Git repo (“repo”), projeniz için tüm alt klasörleri ve dosyaları (veriler, kodlar, resimler vb.) ve bunların revizyon geçmişlerini içeren bir klasördür. Depodaki değişiklikleri onunla izlemeye başladığınızda Git, tüm izleme bilgilerini içeren gizli bir klasör oluşturacaktır. Tipik bir Git deposu, R Project klasörünüzdür (R projeleri hakkındaki el kitabı sayfasına bakın).Github, Github Desktop veya Rstudio’dan bir Git deposunun nasıl oluşturulacağını (initialize) sonraki bölümlerde göstereceğiz.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"taahhütler","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Taahhütler","text":"taahhüt, projenin belirli bir zamanda anlık görüntüsüdür. Projede bir değişiklik yaptığınızda, dosyalarınızda yapılan değişiklikleri (delta) izlemek için yeni bir taahhütte bulunacaksınız. Örneğin, bazı kod satırlarını düzenlemiş ve ilgili bir veri kümesini güncellemiş olabilirsiniz. Değişiklikleriniz kaydedildikten sonra, bu değişiklikleri tek bir “taahhüt” altında toplayabilirsiniz.\nişlemin benzersiz bir kimliği vardır (bir karma). Sürüm kontrolü amacıyla, taahhütlere dayalı olarak projenizi zamanında geri alabilirsiniz, bu nedenle onları nispeten küçük ve tutarlı tutmak en iyisidir. Ayrıca, “taahhüt mesajı” adı verilen değişikliklerin kısa bir açıklamasını da ekleyeceksiniz.Aşamalı değişiklikler? Değişiklikleri aşamaya geçirmek, bir sonraki işleme hazırlanmak için bunları hazırlama alanına eklemektir. Buradaki fikir, belirli bir taahhütte hangi değişikliklerin dahil edileceğine ince bir şekilde karar verebilmenizdir. Örneğin, bir komut dosyasında model belirtimi üzerinde çalıştıysanız ve daha sonra başka bir komut dosyasındaki bir şekil üzerinde çalıştıysanız, iki farklı kesinliğe sahip olmak mantıklı olacaktır (şekildeki değişiklikleri geri almak isteyip modeli).","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"şubeler","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Şubeler","text":"Dal, deponuzdaki bağımsız bir değişiklik satırını, proje dosyalarınızın paralel, alternatif bir sürümünü temsil eder.Dallar, değişiklikleri genellikle projenizin birincil/son/“canlı” versiyonu olan ana dalına dahil edilmeden önce test etmek için kullanışlıdır. Bir dal üzerinde denemeyi bitirdiğinizde, değişiklikleri birleştirerek ana dalınıza getirebilir veya değişiklikler o kadar başarılı olmazsa silebilirsiniz.: Şubeleri kullanmak için başka kişilerle işbirliği yapmanız veya uzak bir çevrimiçi veri havuzuna sahip olmanız gerekmez.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"yerel-ve-uzak-depolar","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Yerel ve uzak depolar","text":"Klonlamak, Git deposunun bir kopyasını başka bir yerde oluşturmaktır.Örneğin, Github’dan bilgisayarınızda yerel olarak bir çevrimiçi depoyu klonlayabilirsiniz veya yerel bir depoyla başlayabilir ve onu çevrimiçi olarak Github’kopyalayabilirsiniz.Bir havuzu klonladığınızda, proje dosyaları iki yerde bulunur:fiziksel bilgisayarınızdaki YEREL veri havuzu. Dosyalarda/kodda asıl değişiklikleri yaptığınız yer burasıdır.fiziksel bilgisayarınızdaki YEREL veri havuzu. Dosyalarda/kodda asıl değişiklikleri yaptığınız yer burasıdır.UZAK, çevrimiçi depo: Github deposundaki (veya başka herhangi bir web barındırıcısındaki) proje dosyalarınızın sürümleri.UZAK, çevrimiçi depo: Github deposundaki (veya başka herhangi bir web barındırıcısındaki) proje dosyalarınızın sürümleri.Bu depoları senkronize etmek için daha fazla fonksiyon kullanacağız. Gerçekten de, Sharepoint, Dropbox veya diğer senkronizasyon yazılımlarından farklı olarak Git, yerel deponuzu veya çevrimiçi olanı temel alarak veya tam tersi şekilde otomatik olarak güncellemez. Ne zaman ve nasıl senkronize edeceğinizi siz seçersiniz.git fetch uzak depodaki yeni değişiklikleri indirir ancak yerel deponuzu değiştirmez. Bunu uzak deponun durumunu kontrol etmek olarak düşünün.git fetch uzak depodaki yeni değişiklikleri indirir ancak yerel deponuzu değiştirmez. Bunu uzak deponun durumunu kontrol etmek olarak düşünün.git pull uzak depolardaki yeni değişiklikleri indirir ve yerel deponuzu günceller.git pull uzak depolardaki yeni değişiklikleri indirir ve yerel deponuzu günceller.Yerel olarak bir veya birkaç taahhütte bulunduğunuzda, taahhütleri uzak depoya git push edebilirsiniz. Bu, değişikliklerinizi Github’gönderir, böylece diğer insanlar isterlerse onları görebilir ve çekebilir.Yerel olarak bir veya birkaç taahhütte bulunduğunuzda, taahhütleri uzak depoya git push edebilirsiniz. Bu, değişikliklerinizi Github’gönderir, böylece diğer insanlar isterlerse onları görebilir ve çekebilir.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"başlayın-yeni-bir-depo-oluşturun","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"46.5 Başlayın: yeni bir depo oluşturun","text":"Yeni depolar oluşturmanın birçok yolu vardır. Bunu konsoldan, Github’dan bir arayüzden yapabilirsiniz.Kurulum için iki genel yaklaşım şunlardır:Mevcut veya yeni bir Github deposundan yeni bir R Projesi oluşturun (yeni başlayanlar için tercih edilir) veyaMevcut bir R projesi için bir Github deposu oluşturun","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"başlangıç-dosyaları","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Başlangıç dosyaları","text":"Yeni bir havuz oluşturduğunuzda, isteğe bağlı olarak aşağıdaki dosyaların tümünü oluşturabilir veya daha sonraki bir aşamada havuzunuza ekleyebilirsiniz. Genellikle havuzun “kök” klasöründe yaşarlar.README dosyası, projenizin neden var olduğunu ve onu kullanmak için başka neleri bilmeleri gerektiğini anlamak için birinin okuyabileceği bir dosyadır. İlk başta boş olacak, ancak daha sonra tamamlamanız gerekir.README dosyası, projenizin neden var olduğunu ve onu kullanmak için başka neleri bilmeleri gerektiğini anlamak için birinin okuyabileceği bir dosyadır. İlk başta boş olacak, ancak daha sonra tamamlamanız gerekir.Bir .gitignore dosyası, satırın Git’yok sayması gereken (değişiklikleri izlememesi) klasörleri veya dosyaları içerdiği bir metin dosyasıdır. Bununla ilgili daha fazla bilgi edinin ve örneklere bakınburadan.Bir .gitignore dosyası, satırın Git’yok sayması gereken (değişiklikleri izlememesi) klasörleri veya dosyaları içerdiği bir metin dosyasıdır. Bununla ilgili daha fazla bilgi edinin ve örneklere bakınburadan.Çalışmanız için bir lisans seçebilirsiniz, böylece diğer insanlar çalışmanızı hangi koşullar altında kullanabileceklerini veya çoğaltabileceklerini bilsinler. Daha fazla bilgi için bkz. [Creative Commons lisansları] https://creativecommons.org/licenses/).Çalışmanız için bir lisans seçebilirsiniz, böylece diğer insanlar çalışmanızı hangi koşullar altında kullanabileceklerini veya çoğaltabileceklerini bilsinler. Daha fazla bilgi için bkz. [Creative Commons lisansları] https://creativecommons.org/licenses/).","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"githubda-yeni-bir-depo-oluşturun","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Github’da yeni bir depo oluşturun","text":"Yeni bir depo oluşturmak için Github’da oturum açın ve yeni bir depo oluşturmak için yeşil düğmeyi arayın. Artık boş olan bu depo bilgisayarınıza yerel olarak klonlanabilir (bir sonraki bölüme bakın).Deponuzun genel (internetteki herkes tarafından görülebilir) veya özel (yalnızca izne sahip olanlar tarafından görülebilir) olmasını seçmelisiniz. Verileriniz hassassa, bunun önemli etkileri vardır. Deponuz özelse, kodunuzu bulutta otomatik olarak çalıştırmak için Github actions kullanıyorsanız, örneğin gelişmiş özel durumlarda bazı kotalarla karşılaşırsınız.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"github-deposundan-klonlama","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Github deposundan klonlama","text":"Bilgisayarınızda yeni bir yerel R projesi oluşturmak için mevcut bir Github deposunu klonlayabilirsiniz.Github deposu, zaten var olan ve içerik içeren bir depo olabilir veya az önce oluşturduğunuz boş bir depo olabilir. Bu ikinci durumda, esasen Github deposunu ve yerel R projesini aynı anda yaratıyorsunuz (yukarıdaki talimatlara bakın).: Bir Github deposunda katkıda bulunma hakkınız yoksa, önce depoyu profilinize fork yapmak ve ardından diğer işlemlere geçmek mümkündür. Çatallanma bu bölümün sonunda açıklanmıştır, ancak önce diğer bölümleri okumanızı öneririz.Adım 1: Github’da depoya gidin, yeşil “Kod” düğmesine tıklayın ve HTTPS klon URL’sini kopyalayın (aşağıdaki resme bakın)Bir sonraki adım herhangi bir arayüzde gerçekleştirilebilir. Rstudio ve Github masaüstü ile örneklendireceğiz.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"rstudioda","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Rstudio’da","text":"RStudio’da Dosya > Yeni Proje >Sürüm Kontrolü > Git’e tıklayarak yeni bir R projesi başlatın.“Depo URL’si” istendiğinde, HTTPS URL’sini Github'dan yapıştırınR projesine kısa, bilgilendirici bir ad verinYeni R Projesinin yerel olarak nereye kaydedileceğini seçin“Yeni oturumda aç” seçeneğini işaretleyin ve “Proje oluştur” u tıklayınArtık Github deposunun bir klonu olan yeni, yerel bir RStudio projesindesiniz. Bu yerel proje ve Github deposu artık\nbağlantılı.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"github-desktopta","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Github Desktop’ta","text":"Dosya > Bir depoyu klonla üzerine tıklayınDosya > Bir depoyu klonla üzerine tıklayınURL sekmesini seçinURL sekmesini seçinGithub’dan HTTPS URL’sini ilk kutuya yapıştırınGithub’dan HTTPS URL’sini ilk kutuya yapıştırınYerel deponuzun olmasını istediğiniz klasörü seçinYerel deponuzun olmasını istediğiniz klasörü seçin“KLON” u tıklayın“KLON” u tıklayın","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"mevcut-r-projesinden-yeni-github-deposu","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Mevcut R projesinden yeni Github deposu","text":"Alternatif bir kurulum senaryosu, içeriği olan mevcut bir R projeniz olması ve bunun için bir Github deposu oluşturmak istemenizdir.Proje için yeni, boş bir Github deposu oluşturun (yukarıdaki talimatlara bakın)Bu depoyu yerel olarak klonlayın (yukarıdaki HTTPS talimatlarına bakın)Önceden var olan R projenizdeki tüm içeriği (kodlar, veriler, vb.) bu yeni boş, yerel depoya kopyalayın (örn. kopyala ve yapıştır kullanın).Yeni projenizi RStudio’da açın ve Git bölmesine gidin. Yeni dosyalar, artık Git tarafından izlenen dosya değişiklikleri olarak kaydedilmelidir. Bu nedenle, bu değişiklikleri bir taahhüt olarak paketleyebilir ve Github’gönderebilirsiniz. Bir kez basıldığında, Github’daki depo tüm dosyaları yansıtacaktır.Bu işlemle ilgili ayrıntılar için aşağıdaki Github iş akışı bölümüne bakın.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"şimdi-nasıl-görünüyor","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Şimdi nasıl görünüyor?","text":"","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"rstudioda-1","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"RStudio’da","text":"Bir Github deposunu yeni bir R projesine klonladığınızda, artık RStudio’da bir “Git” sekmesi görürsünüz. Bu sekme, R Ortamınız ile aynı RStudio bölmesinde görünür:Lütfen yukarıdaki resimde daire içine alınmış butonlara dikkat edin, çünkü bunlar\ndaha sonra atıfta bulunuldu (soldan sağa):Kaydedilen dosya değişikliklerini yerel şubede kabul etme düğmesi (bu, yeni bir pencere açar)Çekmek için mavi ok (dalın uzak/Github sürümünde yapılan değişikliklerle şubenin yerel sürümünüzü güncelleyin)Push için yeşil ok (dalın yerel sürümünüz için tüm taahhütleri/değişiklikleri o dalın uzak/Github sürümüne gönderin)RStudio’daki Git sekmesiSağda taban olarak gösterilen yerel şubeyi kullanarak YENİ bir şube oluşturma düğmesi. Neredeyse zaman ana daldan ayrılmak istersiniz (ana dalı güncellemek için ilk kez çektikten sonra)Şu anda çalıştığınız şubeKodda veya diğer dosyalarda yaptığınız değişiklikler aşağıda görünecektir","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"github-masaüstünde","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Github Masaüstünde","text":"Github Desktop, tüm depolarınızı yönetmenize izin veren bağımsız bir uygulamadır. Açtığınızda, arayüz üzerinde çalışmak istediğiniz depoyu seçmenize ve ardından oradan temel Git eylemlerini gerçekleştirmenize olanak tanır.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"git-github-iş-akışı","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"46.6 Git + Github iş akışı","text":"","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"sürece-genel-bakış","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Sürece genel bakış","text":"Kurulumu tamamladığınızda (yukarıda açıklanmıştır), yerel bir R projesine bağlı (klonlanmış) bir Github deposuna sahip olacaksınız. main dalı (varsayılan olarak oluşturulur), tüm dosyaların sözde “canlı” versiyonudur. Değişiklik yapmak istediğinizde, ana daldan yeni bir dal oluşturmak (“Kopya Oluştur” gibi) iyi bir uygulamadır. Dal oluşturmak kolay ve hızlı olduğu için bu Git’teki tipik bir iş akışıdır.Tipik bir iş akışı aşağıdaki gibidir:Yerel deponuzun güncel olduğundan emin olun, değilse güncelleyinYerel deponuzun güncel olduğundan emin olun, değilse güncelleyinDaha önce çalıştığınız şubeye gidin veya bazı şeyleri denemek için yeni bir şube oluşturun.Daha önce çalıştığınız şubeye gidin veya bazı şeyleri denemek için yeni bir şube oluşturun.Bilgisayarınızda yerel olarak dosyalar üzerinde çalışın, bu şubeye bir veya birkaç taahhütte bulununBilgisayarınızda yerel olarak dosyalar üzerinde çalışın, bu şubeye bir veya birkaç taahhütte bulununŞubenin uzak sürümünü değişikliklerinizle güncelleyin (push)Şubenin uzak sürümünü değişikliklerinizle güncelleyin (push)Şubenizden memnun kaldığınızda, değişiklikleri aktarmak için çalışan şubenin çevrimiçi sürümünü çevrimiçi “ana” şubeye birleştirebilirsiniz.Şubenizden memnun kaldığınızda, değişiklikleri aktarmak için çalışan şubenin çevrimiçi sürümünü çevrimiçi “ana” şubeye birleştirebilirsiniz.Diğer ekip üyeleri de aynı şeyi kendi şubeleriyle yapıyor olabilir veya belki de sizin çalışma şubenize taahhütlere katkıda bulunuyor olabilir.Yukarıdaki süreci aşağıda daha ayrıntılı olarak adım adım inceliyoruz. İşte geliştirdiğimiz bir şema - iki yönlü bir tablo biçiminde olduğundan epidemiyologların anlamasına yardımcı olmalıdır.İşte başka bir şema.: Yakın zamana kadar “master” dal terimi kullanılıyordu, ancak şimdi “main” dal olarak anılıyor.Görüntü source","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"yeni-bir-dal-oluştur","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"46.7 Yeni bir dal oluştur","text":"Üzerinde çalışmak için bir dal seçtiğinizde Git, çalışma dizininizi bu dalda en son bulunduğunuz zamanki gibi sıfırlar.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"rstudio-git-bölmesinde","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Rstudio Git bölmesinde","text":"“Ana” dalda olduğunuzdan emin olun ve ardından yeni bir dal oluşturmak için mor simgeye tıklayın (yukarıdaki resme bakın).Şubenize tek kelimelik açıklayıcı bir ad vermeniz istenecektir (gerekirse alt çizgi kullanabilirsiniz).Yerel olarak hala aynı R projesinde olduğunuzu ancak artık “ana” dal üzerinde çalışmadığınızı göreceksiniz.Yeni şube oluşturulduktan sonra Github web sitesinde şube olarak da görünecektir.“Geçmiş” e tıkladıktan sonra Rstudio’daki Git Bölmesi’ndeki dalları görselleştirebilirsiniz.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"masaüstünde-github","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Masaüstünde Github","text":"İşlem çok benzer, dalınıza bir isim vermeniz isteniyor. Ardından, yeni şubenin uzak depoda da görünmesini sağlamak için “Dalınızı Github’da yayınla” denilmelidir.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"konsol-kullanırken","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Konsol Kullanırken","text":"Perde arkasında gerçekte olan şey, “git dalı” ile yeni bir şube oluşturmanız ve ardından “git checkout” ile dala gitmenizdir (Örneğin Git’e sonraki taahhütlerinizin orada gerçekleşeceğini söyleyin).\nGit deponuzdan:Konsolu kullanma hakkında daha fazla bilgi için sondaki Git komutlarına bakınız.","code":"git branch my-new-branch  # Yeni bir dal oluşturun\ngit checkout my-new-branch # Oluşturulan dala gidin\ngit checkout -b my-new-branch # İkisi aynı anda (Kısayol)"},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"değişiklikleri-uygula-commit-changes","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"46.8 Değişiklikleri Uygula (Commit Changes)","text":"Artık kodu düzenleyebilir, yeni dosyalar ekleyebilir, veri kümelerini güncelleyebilirsiniz.Değişikliklerinizin biri ilgili dosya kaydedildikten sonra izlenir. Değiştirilen dosyalar RStudio Git sekmesinde, Github Desktop’ta veya terminalde ‘git status’ komutu kullanılarak görünecektir (aşağıya bakın).Önemli değişiklikler yaptığınızda (örneğin, bir kod bölümü ekleme veya güncelleme), bu değişiklikleri duraklatın ve kabul edin. Bir taahhüdü, ortak bir amaçla ilgili değişikliklerin bir “topluluğu” olarak düşünün. Üzerinde değişiklik yaptıktan sonra bir dosyayı zaman revize etmeye devam edebilirsiniz.Uygulamayla ilgili tavsiye: genel olarak, bir sorun ortaya çıktığında kolayca geri alınabilecek küçük uygulamalar yapmak, ortak bir amaç ile ilgili değişiklikleri birlikte yapmak daha iyidir. Bunu başarmak için sık sık uygulamalarda bulunmanız gerektiğini göreceksiniz. Başlangıçta, muhtemelen sık sık uygulamada bulunmayı unutacaksınız, ancak daha sonra alışkanlık halini almaktadır.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"rstudioda-2","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Rstudio’da","text":"Aşağıdaki örnek, son işlemden bu yana, “collaboration.Rmd” R Markdown komut dosyasının değiştiğini ve birkaç PNG görüntüsünün eklendiğini göstermektedir.Dosya adlarının yanındaki sarı, mavi, yeşil ve kırmızı karelerin neyi temsil ettiğini merak ediyor olabilirsiniz. İşte RStudio kolay kullanım sayfasından anlamlarını açıklayan bir anlık görüntü. Değişikliklerin sarı “?” ile işaretlendiğine, halen görüntülenebilir, işlenebilir ve gönderilebilir(push) olduğuna dikkat edin.Sol üstteki kutuda bir dosya adına tıklayınSol üstteki kutuda bir dosya adına tıklayınBu dosyada yaptığınız değişiklikleri gözden geçirin (aşağıda yeşil veya kırmızı renkle vurgulanmıştır)Bu dosyada yaptığınız değişiklikleri gözden geçirin (aşağıda yeşil veya kırmızı renkle vurgulanmıştır)Gönderirken bu değişiklikleri içerecek olan dosyayı “stage” yapın. Bunu dosya adının yanındaki kutuyu işaretleyerek yapabilirsiniz. Alternatif olarak, birden fazla dosya adını vurgulayabilir ve ardından “Stage(Aşama)” yı tıklayabilir.Gönderirken bu değişiklikleri içerecek olan dosyayı “stage” yapın. Bunu dosya adının yanındaki kutuyu işaretleyerek yapabilirsiniz. Alternatif olarak, birden fazla dosya adını vurgulayabilir ve ardından “Stage(Aşama)” yı tıklayabilir.Kısa ama açıklayıcı bir Commit mesajı yazın (gereklidir)Kısa ama açıklayıcı bir Commit mesajı yazın (gereklidir)“Commit” düğmesine basın. Başarıyı gösteren bir açılır kutu veya bir hata mesajı görünecektir.“Commit” düğmesine basın. Başarıyı gösteren bir açılır kutu veya bir hata mesajı görünecektir.Artık istediğiniz kadar değişiklikte bulunabilir ve commit edebilirsiniz.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"masaüstünde-github-1","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Masaüstünde Github","text":"Solda değiştirilen dosyaların listesini görebilirsiniz. Eğer\nbir metin dosyası seçerseniz, yapılan değişikliklerin bir özetini görürsünüz.\nsağ bölmede (görünüm .docs veya .xlsx gibi daha karmaşık dosyalarda çalışmaz).Değişiklikleri düzenlemek için dosya adlarının yanındaki küçük kutuyu işaretlemeniz yeterlidir. Ne zaman bu uygulamaları eklemek istediğiniz dosyaları seçerseniz commit edebilirsiniz. Bir isim verip, isteğe bağlı olarak bir açıklama yazmanın ardından commit edilebilir.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"konsolda","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Konsolda","text":"Sahne arkasında kullanılan iki fonksiyon, seçme/sahneleme için “git add” fonksiyonudur.\ndosyalar ve ‘git commit’ commit etmek içindir.","code":"git status # değişiklikleri izle \n\ngit add new_pages/collaboration.Rmd  # commit edilecek dosyaları seçin (= değişiklikleri yapın)\n\ngit commit -m \"Describe commit from Github Desktop\" # değişiklikleri bir mesajla commit et\n\ngit log  # geçmiş commitlerle ilgili bilgileri görüntüle"},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"önceki-bir-commiti-değiştirin","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Önceki bir commit’i değiştirin","text":"Bazı değişiklikler yaparsanız, çalışmaya devam ederseniz ve geçmiş commit’e “ait” olması gereken değişiklikler yaptığınızı fark ederseniz ne olur (sizce). Korkmayın! Bu değişiklikleri önceki gönderinize ekleyebilirsiniz.Rstudio’da, COMMIT düğmesiyle aynı satırda bir “Önceki commit’değiştir” kutusu olduğu için oldukça açıktır.Belirsiz bir nedenle, işlevsellik Github Desktop’ta olduğu gibi uygulanmamıştır, ancak (kavramsal olarak garip ama kolay) bir yol vardır. Henüz değişikliklerinizi commit etmiş ancak push etmediyseniz, COMMIT düğmesinin hemen altında bir “GERİ AL” düğmesi görünür. Üzerine tıklayın geri alacaktır (ancak aşamalı dosyalarınızı ve commit mesajınızı saklayın). Değişikliklerinizi kaydedin, gerekirse commit’e yeni dosyalar ekleyin ve tekrar commit edin.Konsolda:: Zaten herkese açık olan ve ortak çalışanlarınızla paylaşılan commitleri değiştirmeden önce düşünün.","code":"git add [YOUR FILES] # Yeni değişikliklerinizi aşamalandırın\n\ngit commit --amend  # Önceki commit'i değiştir\n\ngit commit --amend -m \"An updated commit message\"  # Önceki commitlerini değiştirin VE mesajını güncelleyin"},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"değişiklikleri-githuba-kadar-çekin-ve-iletin","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"46.9 Değişiklikleri Github’a kadar çekin ve iletin","text":"“Önce PULL (çekin), sonra PUSH(iletin)”Projeniz üzerinde çalışmaya başlamadan önce fetch(getirmek) ve pull(çekmek), yerel bilgisayarınızdaki dalın sürümünü uzak/Github sürümünde yapılan değişikliklerle güncellemek iyi bir uygulamadır.sık sık ÇEKİN. tereddüt etmeyin. İtmeden önce daima çekin. Değişiklikleriniz yapıldığında ve commit edildiğinde ve projenizin durumundan memnun olduğunuzda, gönderilerinizi dalınızın uzak/Github sürümüne iletebilirsiniz.Depo üzerinde çalışırken tekrarlayın.: Commit edilen ancak gönderilmeyen (yani hala yerel olan) değişiklikleri geri almak, uzak depoya gönderilen (ve belki de zaten başka biri tarafından çekilmiş) değişiklikleri geri almaktan çok daha kolaydır, bu nedenle üzerinde çalıştığınız görevde değişiklik yapmayı bitirdiğinizde commit etmek daha iyidir.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"rstudioda-3","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Rstudio’da","text":"PULL - İlk olarak, “Çek” simgesine (aşağı ok) tıklayın.PUSH - Yeşil “Çek” simgesine (yukarı ok) tıklayın. Github kullanıcı adınızı ve şifrenizi girmeniz istenebilir. İlk sorulduğunda, Terminal’e Git komut satırını girmeniz gerekebilir:git config –global user.email “[siz@example.com (mailto:siz@example.com){.email}” (Github e-posta adresiniz) vegit config –global user.name “Github kullanıcı adınız”Bu komutların nasıl girileceği hakkında daha fazla bilgi edinmek için aşağıdaki Git komutları bölümüne bakın.İPUCU: Parolanızı çok sık mı istedi? Havuza bağlanmak için bu [eğiticinin (https://happygitwithr.com/credential-caching.html#credential-caching) 10. ve 11. bölümlerine bakın.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"github-desktopta-1","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Github Desktop’ta","text":"Uzak depoda yeni commitler olup olmadığını kontrol etmek için “Fetch Origin” düğmesine tıklayın.Git, uzak depoda yeni taahhütler bulursa, düğme bir “Çek” düğmesine dönüşür. İtme ve çekme için aynı düğme kullanıldığından, daha önce çekmediyseniz değişikliklerinizi itemezsiniz.Tüm commitleri (sizin ve diğerleri) görmek için “Geçmiş” sekmesine (“Değişiklikler” sekmesinin yanında) gidebilirsiniz. Bu, işbirlikçilerinizin yaptıkları hakkında bilgi edinmenin güzel bir yoludur. Commit mesajını, varsa açıklamasını okuyabilir ve diff bölmesini kullanarak iki dosyanın kodunu karşılaştırabilirsiniz.Tüm uzaktan değişiklikler çekildikten ve en az bir yerel değişiklik yapıldıktan sonra, aynı düğmeye tıklayarak basabilirsiniz.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"konsol","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Konsol","text":"Şaşırtıcı olmayan bir şekilde, komutlar getir(fetch), çek(pull) ve ittir(push) şeklindedir.","code":"git fetch  # uzak dizinde yeni commitler var mı?\ngit pull   # Uzak commitleri yerel dalınıza getirin\ngit push   # Bu dalın yerel commitlerini uzak dala aktarın"},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"çekmek-istiyorum-ama-yerel-işim-var","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Çekmek istiyorum ama yerel işim var","text":"Bu bazen olabilir: yerel deponuzda bazı değişiklikler yaptınız, ancak uzak depo sizin çekmediğinizi commit etti.Git, değişikliklerinizin üzerine yazabileceği için çekmeyi reddedecek. Değişikliklerinizi korumak için [Happy Git R (https://happygitwithr.com/pull-tricky.html) bölümünde iyi açıklanan birkaç strateji vardır.\n- değişikliklerinizi gerçekleştirin, uzaktan değişiklikleri alın, bunları çekin, gerekirse çakışmaları çözün (aşağıdaki bölüme bakın) ve şeyi çevrimiçine gönderin\n- Değişikliklerinizi ‘saklayın’, bu tür onları bir kenara depolar, çeker, geri yükler ve ardından commit eder, herhangi bir çakışmayı çözer ve iter.Uzak değişikliklerle ilgili dosyalar ve yerel değişikliklerinizle ilgili dosyalar çakışmıyorsa Git, çakışmaları otomatik olarak çözebilir.Github Desktop’ta bu, düğmelerle yapılabilir. Saklamak için Branch>Tüm değişiklikleri sakla seçeneğine gidin.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"dalını-ana-gövde-ile-birleştir","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"46.10 Dalını Ana Gövde ile birleştir","text":"Değişiklik yapmayı bitirdiyseniz, bu değişiklikleri ana dalda birleştirme işlemine başlayabilirsiniz. Durumunuza bağlı olarak bu hızlı olabilir veya ekip arkadaşlarınızı içeren kasıtlı inceleme ve onay adımlarını atmış olabilirsiniz.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"yerel-olarak-github-desktopta","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Yerel olarak Github Desktop’ta","text":"Github Desktop kullanarak dalları yerel olarak birleştirebilirsiniz. İlk olarak, commitlerin alıcısı olacak dallara, yani güncellemek istediğiniz dala gidin. Ardından Dal> Geçerli gövdeye birleştir menüsüne gidin ve tıklayın. Bir kutu, içe aktarmak istediğiniz dalı seçmenize olanak tanır.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"konsolda-1","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Konsolda","text":"İlk önce değişikliklerin alıcısı olacak dala geri dönün.\nBu genellikle master şeklindedir, ancak başka bir dal da olabilir. Sonra master içine çalışma dalınızı birleştirin.Bu sayfa daha gelişmiş bir dallanma örneği gösterir ve perde arkasında neler olduğunu biraz açıklar .","code":"git checkout master  # Master'a (veya taşımak istediğiniz dala) geri dönün\ngit merge this_fancy_new_branch"},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"githubda-çekme-istekleri-gönderme","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Github’da: çekme istekleri gönderme","text":"İki dalı yerel olarak veya kimseye haber vermeden birleştirmek tamamen mümkün olmakla birlikte, bir birleşme ana gövdeye entegre edilmeden önce birkaç kişi tarafından tartışılabilir veya araştırılabilir. Sürece yardımcı olmak için Github, birleştirme ile ilgili bazı tartışma özellikleri sunar: çekme isteği.Bir çekme isteği (bir “PR”), bir dalı diğeriyle birleştirme isteğidir (başka bir deyişle, çalışan dalınızın “ana” dala çekilmesine yönelik bir istek).Bir çekme isteği, genellikle birden çok commit içerir. Bir çekme isteği, genellikle kabul edilmeden ve dal birleştirilmeden önce bir konuşma ve inceleme sürecini başlatır. Örneğin, [dplyr’s github] (https://github.com/tidyverse/dplyr/pulls) üzerinden çekme isteği tartışmalarını okuyabilirsiniz.Doğrudan web sitesinden (aşağıda gösterildiği gibi) veya Github Desktop’tan bir çekme isteği (PR) gönderebilirsiniz.Github deposuna gidin (çevrimiçi)“Çekme İstekleri” sekmesini görüntüleyin ve “Yeni çekme isteği” düğmesini tıklayınDalınızı ana gövde ile birleştirmek için açılır menüden seçinAyrıntılı bir Çekme Talebi yorumu yazın ve “Çekme Talebi Oluştur” u tıklayın.Aşağıdaki resimde, “ormanlar” dalı “ana” ile birleştirilmek üzere seçilmiştir:Şimdi çekme isteğini görebilmelisiniz (aşağıdaki örnek resim):Dal birleştirilirse “ana” dalın nasıl değişeceğini görmek için “Dosyalar değişti” sekmesini inceleyin.Sağ tarafta, Github ID’lerini etiketleyerek ekibinizin üyelerinden inceleme talep edebilirsiniz. İsterseniz, ana ile birleştirmek için havuz ayarlarını bir onay incelemesi gerektirecek şekilde ayarlayabilirsiniz.Çekme talebi onaylandıktan sonra,\n“Birleştirme çekme isteği” aktif hale gelecektir. Buna tıklayın.Tamamlandıktan sonra dalınızı aşağıda açıklandığı gibi silin.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"çakışmaları-çözme","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Çakışmaları çözme","text":"İki kişi aynı satırları aynı anda değiştirdiğinde, birleştirme çatışması ortaya çıkar. Aslında Git, hangi sürümün tutulacağına karar vermeyi reddeder, ancak çatışmanın nerede olduğunu bulmanıza yardımcı olur. PANİK YAPMA. Çoğu zaman, çözmek oldukça basittir.Örneğin, Github’da:Birleştirme bir çakışma yarattıktan sonra, dosyayı favori düzenleyicinizde açın.\nÇatışma bir dizi karakterle belirtilecektir:<<<<<<< HEAD ve ======= arasındaki metin yerel deponuzdan gelir ve ======= ile arasındaki metin >>>>>>> diğer daldan (orijin, master veya seçtiğiniz herhangi bir dal olabilir).Kodun hangi sürümünü tercih ettiğinize karar vermeniz (veya uygunsa iki taraftaki değişiklikler de dahil olmak üzere üçüncü bir tane yazmanız), gerisini silmeniz ve Git’eklediği tüm işaretleri kaldırmanız gerekir (<<<<< << HEAD, =======,>>>>>>> Origin/master/your_branch_name).Ardından, dosyayı kaydedin, düzenleyin ve commit edin: bu, birleştirilmiş sürümü “resmi” yapan committir. Daha sonra itmeyi unutmayın.Siz ve işbirlikçileriniz ne kadar sık ​​​​çekip iterseniz, çatışmalar o kadar küçük olur.: Konsolla kendinizi rahat hissediyorsanız, daha fazla gelişmiş\nbirleştirme seçenekleri (ör. boşlukları yok sayma, ortak çalışana öncelik verme vb.).","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"dalınızı-silin","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Dalınızı silin","text":"Bir dal ana dalla birleştirildiğinde ve artık gerekli olmadığında, onu silebilirsiniz.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"github-rstudio","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"46.10.0.1 Github + Rstudio","text":"Github’daki depoya gidin ve tüm dalları görüntülemek için düğmeye tıklayın (dalları seçmek için açılır menünün yanında). Şimdi dalınızı bulun ve yanındaki çöp kutusu simgesine tıklayın. Dal silmeyle ilgili daha fazla ayrıntıyı buradan okuyun -deponuzdaki-dallar#dal silme).Dalı bilgisayarınızdan yerel olarak da sildiğinizden emin olun. Bu otomatik olarak olmayacak.RStudio’dan Ana gövdede olduğunuzdan emin olun.RStudio “Terminal”de (R konsolunun bitişiğindeki sekme) Git komutlarını yazmaya geçin ve şunu yazın: git branch -d branch_name, burada “branch_name” silinecek dalınızın adıdırGit sekmenizi yenileyin, dal gitmiş olmalı","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"github-masaüstünde-1","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"46.10.0.2 Github Masaüstünde","text":"Silmek istediğiniz dalı kontrol edin ve menüye gidin\nDal> Sil.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"çatallama","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Çatallama","text":"Bir projeye katkıda bulunmak istiyorsanız, ancak bunu yapma hakkına sahip değilseniz veya sadece kişisel kullanımınız için değiştirmek istiyorsanız, bir projeyi çatallayabilirsiniz. Çatallamanın kısa bir açıklaması burada bulunabilir.Github’da “Çatal” düğmesine tıklayın:Bu, orijinal depoyu klonlayacaktır, ancak kendi profilinizde. Şimdi, Github’da deponun iki sürümü var: değiştiremeyeceğiniz orijinal sürüm ve profilinizdeki klonlanmış sürüm.Ardından, önceki bölümlerde açıklanan yöntemlerden herhangi birini kullanarak çevrimiçi depo sürümünüzü yerel olarak bilgisayarınızda klonlamaya devam edebilirsiniz. Ardından, yeni bir dal oluşturabilir, değişiklik yapabilir, commit edebilir ve bunları uzak deponuza gönderebilirsiniz.Sonuçtan memnun kaldığınızda, orijinal deponun sahipleri/koruyucuları ile konuşmaya başlamak için Github veya Github Desktop’tan bir Çekme Talebi oluşturabilirsiniz.Ya resmi depodan bazı yeni commitlere ihtiyacınız olursa?Birinin, klonlanmış sürümünüze dahil etmek istediğiniz resmi depoda kritik bir değişiklik yaptığını hayal edin. Fork’unuzu resmi depo ile senkronize etmek mümkündür. Terminalin kullanılmasını içerir, ancak çok karmaşık değildir. Çoğunlukla şunu hatırlamanız gerekir:\n- upstream = değiştiremeyeceğiniz resmi depo\n- origin = Github profilinizdeki depo sürümünüz[Bu öğreticiyi (https://docs.github.com/en/github/collaborating--issues--pull-requests/syncing--fork) okuyabilir veya aşağıdakileri takip edebilirsiniz:İlk önce Git terminalinizi yazın (deponuzun içine):Yukarı akış deposunu henüz yapılandırmadıysanız, Origin ile başlayan iki satır görmelisiniz. “fetch” ve “push”un işaret ettiği uzak depoyu gösterirler. Unutmayın, Origin, Github’daki deponun kendi sürümünüz için geleneksel takma addır. Örneğin:Şimdi yeni bir uzak depo ekleyin:Burada adres, bir depoyu klonladığınızda Github’un ürettiği adrestir (klonlama ile ilgili bölüme bakın). Şimdi dört uzak işaretçiniz olacak:Artık kurulum tamamlandığında, değişiklikleri orijinal (upstream) deposundan almak istediğinizde, güncellemek istediğiniz dala(checkout) gitmeniz ve şunu yazmanız yeterlidir:Çakışmalar varsa, bunları Çakışmaları çözme bölümünde açıklandığı gibi çözmeniz gerekecektir.Özet: çatallama klonlanıyor, ancak Github sunucu tarafında.\nEylemlerin geri kalanı, tipik işbirliği iş akışı eylemleridir.\n(klonlama, itme, çekme, commit etme, birleştirme, çekme isteklerini gönderme…).: forking bir Git komutu değildir bir kavram olsa da, [Bitbucket] https://www.atlassian.com/git/tutorials/comparing-workflows/forking-workflow gibi diğer Web ana bilgisayarlarında da bulunur).","code":"git remote -vgit remote add upstream https://github.com/appliedepi/epirhandbook_eng.gitgit fetch upstream # Uzak depodan yeni commitleri alın\ngit checkout the_branch_you_want_to_update\ngit merge upstream/the_branch_you_want_to_update  # Yukarı akış dalını kendi dalınızla birleştirin.\ngit push # Uzak deponun kendi sürümünüzü güncelleyin"},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"öğrendiklerimiz","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"46.11 Öğrendiklerimiz","text":"Şunları nasıl yapacağınızı öğrendiniz:Git’klasörlerinizdeki değişiklikleri takip edecek şekilde ayarlayın,yerel deponuzu uzak bir çevrimiçi depoya bağlayın,değişiklikleri commit edin,yerel ve uzak depolarınızı senkronize edin.Bütün bunlar sizi harekete geçirmeli ve epidemiyologlar olarak ihtiyaçlarınızın çoğu için yeterli olmalıdır. Genellikle geliştiriciler kadar gelişmiş kullanıma sahip değiliz.Ancak, daha ileri gitmek isterseniz (veya buna ihtiyaç duyarsanız) Git’commit geçmişlerini basitleştirmek, bir veya birkaç işlemi geri almak, kesin bir işlem yapmak vb. için daha fazla güç sunduğunu bilin. Bazıları tam bir sihirbazlık gibi gelebilir, ancak şimdi temellere sahipseniz, üzerine inşa etmek daha kolaydır.Rstudio ve Github Desktop’taki Git bölmesi, çalışma alanımızda yeni başlayanlar / günlük kullanım için iyi olsa da, bazı orta / gelişmiş Git işlevleri için bir arayüz sunmadıklarını unutmayın. Bazı daha eksiksiz arayüzler, işaretle ve tıkla (genellikle daha karmaşık bir düzen pahasına) ile daha fazlasını yapmanıza olanak tanır.Deponuzu izlemek için herhangi bir noktada herhangi bir aracı kullanabildiğiniz için, bazen denemek veya ara sıra daha az yaygın karmaşık görevleri gerçekleştirmek için bir arabirimi çok kolay bir şekilde kurabileceğinizi ve geri kalan zaman için basitleştirilmiş bir arabirimi tercih edebileceğinizi unutmayın ( örneğin çoğu zaman Github Desktop’ı kullanmak ve bazı özel görevler için SourceTree veya Gitbash’geçmek).","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"git","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"46.12 Git komutları","text":"","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"önerilen-öğrenim","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Önerilen öğrenim","text":"Etkileşimli bir eğiticide Git komutlarını öğrenmek için bu web sitesine bakabilirsiniz.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"komutların-girileceği-yer","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Komutların girileceği yer","text":"Git kabuğuna komutlar girersiniz.Seçenek 1 RStudio’da yeni bir Terminal açabilirsiniz. Bu sekmenin yanında R Konsolu. İçine herhangi bir metin yazamıyorsanız, “Terminal”altındaki açılır menüye tıklayın ve “Yeni terminal”seçin. Komutları, dolar işareti “$” önündeki yanıp sönen boşluğa yazın.Seçenek 2 Git sekmesinde (RStudio Ortamı yakınında) mavi “dişliler” simgesine tıklayarak bir kabuk (komut girmek için bir terminal) de açabilirsiniz. Açılır menüden “Kabuk” öğesini seçin. “$” dolar işaretinden sonra komutları yazabileceğiniz yeni bir pencere açılacaktır.Seçenek 3 Aynı tür terminali açacak olan “Git Bash burada”yı açmak için sağ tıklayın veya uygulama listenizden Git Bash’açın [Git Bash hakkında daha fazla başlangıç seviyesi bilgisi (https://happygitwithr.com/shell.html), nasıl bulunur ve ihtiyacınız olacak bazı bash komutları.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"örnek-komutlar","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"Örnek komutlar","text":"Aşağıda birkaç yaygın git komutu sunuyoruz. Bunları kullandığınızda, eylemi değiştireceğinden, hangi dalın aktif olduğunu (check-) aklınızda bulundurun!Aşağıdaki komutlarda,  bir dal adını temsil eder , belirli bir commitin karma kimliğini temsil eder.  bir sayıyı temsil eder. < veya > sembollerini yazmayın.","code":""},{"path":"git-ve-github-ile-sürüm-kontrolü-ve-işbirliği.html","id":"kaynaklar-37","chapter":"46 Git ve Github ile sürüm kontrolü ve işbirliği","heading":"46.13 Kaynaklar","text":"Bu sayfanın çoğu, Jenny Bryan’ın bu “Happy Git R” web sitesi çalışmasından faydalanılarak hazırlanmıştır. Bu web sitesinin yaygın Git sorunlarını gidermenize yardımcı olan bölümü ve R ile ilgili hatalara çok yardımcı çözümleri mevcuttur.Github.com belgeleri ve başlangıç ​​kılavuzu.RStudio ile Git hakkında ipuçları içeren RStudio “IDE” yardım sayfası.https://ohi-science.org/news/github-coming-back--timeYeni başlayanlar için Git komutlarıÖğrenmek için bir etkileşimli öğreticihttps://www.freecodecamp.org/news/-introduction--git--absolute-beginners-86fa1d32ff71/: Kendi bilgisayarınızdaki bir klasördeki değişiklikleri izlemek için mutlak temel bilgileri öğrenmek için iyi.Dalları anlamak için güzel şemalar: https://speakerdeck.com/alicebartlett/git--humans>Hem temel hem de ileri düzey konuları kapsayan eğitimlerhttps://tutorialzine.com/2016/06/learn-git--30-dakikahttps://dzone.com/articles/git-tutorial-commands--operations--git https://swcarpentry.github.io/git-novice/ (kısa kurs <https://rsjakob .gitbooks.io/git/content/chapter1.html>Pro Git kitabı resmi bir referans olarak kabul edilir. Bazı bölümler iyi olsa da, genellikle biraz teknik. Git’biraz kullandıktan ve ne olduğunu ve nasıl daha ileri gidileceğini biraz daha kesin olarak öğrenmek istediğinizde muhtemelen iyi bir kaynaktır.","code":""},{"path":"yaygın-hatalar.html","id":"yaygın-hatalar","chapter":"47 Yaygın hatalar","heading":"47 Yaygın hatalar","text":"Bu sayfa, sık karşılaşılan hataların bir listesini içerir ve bunları gidermek için çözümler önerir.","code":""},{"path":"yaygın-hatalar.html","id":"hata-mesajlarını-yorumlama","chapter":"47 Yaygın hatalar","heading":"47.1 Hata mesajlarını yorumlama","text":"R hataları bazen şifreli olabilir, bu nedenle Google sizin arkadaşınızdır. Hata mesajını “R” ile arayın ve StackExchange.com, stackoverflow.com, community.rstudio.com twitter (#rstats) ve programcılar tarafından soru ve cevapları dosyalamak için kullanılan diğer forumlar içindeki son gönderileri arayın. Benzer sorunları çözen son gönderileri bulmaya çalışın.Çok fazla arama yaptıktan sonra sorununuza bir yanıt bulamıyorsanız, tekrarlanabilir bir örnek (“reprex”) oluşturmayı ve soruyu kendiniz göndermeyi düşünün. Tekrarlanabilir bir örneğin nasıl oluşturulacağı ve forumlara nasıl gönderileceğiyle ilgili ipuçları için Yardım alma hakkındaki sayfaya bakabilirsiniz.","code":""},{"path":"yaygın-hatalar.html","id":"yaygın-hatalar-1","chapter":"47 Yaygın hatalar","heading":"47.2 Yaygın hatalar","text":"Aşağıda, bazı yaygın hataları ve olası açıklamaları/çözümleri listeliyoruz. Bunlardan bazıları, Stack Overflow’ta R hata mesajları hakkında en yaygın forum gönderilerini analiz eden Noam Ross’tan ödünç alınmıştır (analiz için buraya bakın /stack-overflow-common-r-errors.md))","code":""},{"path":"yaygın-hatalar.html","id":"yazım-hataları","chapter":"47 Yaygın hatalar","heading":"Yazım hataları","text":"“Beklenmeyen simge” görürseniz, eksik virgül olup olmadığını kontrol edin","code":"Error: unexpected symbol in:\n\"  geom_histogram(stat = \"identity\")+\n  tidyquant::geom_ma(n=7, size = 2, color = \"red\" lty\""},{"path":"yaygın-hatalar.html","id":"paket-hataları","chapter":"47 Yaygın hatalar","heading":"Paket hataları","text":"Bu muhtemelen fonksiyon adını yanlış yazdığınız veya bir paketi yüklemeyi unuttuğunuz anlamına gelir.‘dplyr::select()’ kullandığınızı düşünüyorsunuz, ancak ‘select()’ fonksiyonu ‘MASS::select()’, ‘dplyr::’ belirten veya dplyr için paketinizi yeniden sipariş eden tarafından maskelenmiştir.Diğer yaygın maskeleme hataları şunlardan kaynaklanır: “plyr::summarise()” ve “stats::filter()”. Çatışmalı paketi kullanmayı düşünün.Bir “00LOCK” dosyasını kaldırmanız gerektiğini söyleyen bir hata alırsanız, bilgisayar dizininizdeki “R” kitaplığınıza gidin (örn. R/win-library/) ve “00LOCK” adlı bir klasör arayın. Bunu manuel olarak silin ve paketi yeniden yüklemeyi deneyin. Daha önceki bir yükleme işlemi muhtemelen kesintiye uğramıştır ve bu duruma yol açmıştır.","code":"could not find function \"x\"...Error in select(data, var) : unused argument (var)Error in install.packages : ERROR: failed to lock directory ‘C:\\Users\\Name\\Documents\\R\\win-library\\4.0’ for modifying\nTry removing ‘C:\\Users\\Name\\Documents\\R\\win-library\\4.0/00LOCK’"},{"path":"yaygın-hatalar.html","id":"nesne-hataları","chapter":"47 Yaygın hatalar","heading":"Nesne hataları","text":"Dışa veya içe aktarmaya çalıştığınızda böyle bir hata görürseniz: Dosyanın ve dosya yolunun yazımını kontrol edin ve yol eğik çizgi içeriyorsa bunların ileri / olduğundan ve geriye doğru değil \\ olduğundan emin olun. Ayrıca doğru dosya uzantısını (ör. .csv, .xlsx) kullandığınızdan emin olun.Bu, başvurduğunuz bir nesnenin mevcut olmadığı anlamına gelir. Belki yukarıdaki kod düzgün çalışmamıştır?Bu, orada olmayan bir şeye (bir vektörün veya bir listenin öğesi) erişmeye çalıştığınız anlamına gelir.","code":"No such file or directory:object 'x' not found Error in 'x': subscript out of bounds"},{"path":"yaygın-hatalar.html","id":"fonksiyon-sözdizimi-hataları","chapter":"47 Yaygın hatalar","heading":"Fonksiyon sözdizimi hataları","text":"Sütunun adını ilk değişken olarak sağlamanızı beklediği yerde “recode()” veya “replace_na()” gibi bir fonksiyon sağlıyorsanız, yukarıdaki bu hata (“değişken .x eksik, varsayılan yok”) “mutate()”de yaygındır. Bunu unutmak kolaydır.","code":"# mutate(x = recode(x, OLD= NEW) içindeki x değişkenini yeniden belirtmek için kodu tekrarlayın\nError: Problem with `mutate()` input `hospital`.\nx argument \".x\" is missing, with no default\ni Input `hospital` is `recode(...)`."},{"path":"yaygın-hatalar.html","id":"mantık-hataları","chapter":"47 Yaygın hatalar","heading":"Mantık hataları","text":"Bu, muhtemelen DOĞRU veya YANLIŞ olmayan bir şeye bir “” ifadesinin uygulandığı anlamına gelir.","code":"Error in if"},{"path":"yaygın-hatalar.html","id":"faktör-hataları","chapter":"47 Yaygın hatalar","heading":"Faktör hataları","text":"Geçersiz faktör seviyeleri hakkında bu hatayı görüyorsanız, muhtemelen bir sınıf Faktör sütununuz (önceden tanımlanmış seviyeleri içeren) var ve ona yeni bir değer eklemeye çalışıyorsunuz. Yeni bir değer eklemeden önce onu Karakter sınıfına dönüştürün.","code":"#Bir faktöre bir değer (\"Eksik\") eklemeye çalışın (bir faktör üzerinde çalışan replace_na ile)\n'age_cat' girişi 'mutate()' ile ilgili sorun olur.\ni invalid factor level, NA generated\ni Input `age_cat` is `replace_na(age_cat, \"Missing\")`.invalid factor level, NA generated"},{"path":"yaygın-hatalar.html","id":"çizim-hataları","chapter":"47 Yaygın hatalar","heading":"Çizim hataları","text":"Error: Insufficient values manual scale. 3 needed 2 provided.\nggplot() scale_fill_manual() değerleri = c(“turuncu”, “mor”) … faktör düzeyi sayısı için yetersiz … NA’nın artık bir faktör düzeyi olup olmadığını düşünün…Muhtemelen silmeniz gereken bir ggplot komutunun sonunda fazladan bir “+” işaretiniz vardır.","code":"Can't add x object"},{"path":"yaygın-hatalar.html","id":"r-markdown-hataları","chapter":"47 Yaygın hatalar","heading":"R Markdown hataları","text":"Hata mesajı şöyle bir şey içeriyorsa Error options[[sprintf(\"fig.%s\", )]], bir parçanın üstündeki knitr seçeneklerinizin doğru şekilde kullanıldığını kontrol edin. .width = veya .height = ve fig.width= ve fig.height=.","code":""},{"path":"yaygın-hatalar.html","id":"çeşitli-konular","chapter":"47 Yaygın hatalar","heading":"Çeşitli Konular","text":"Tünellenmiş dplyr fiillerini yeniden düzenlediğinizi ve ortadaki bir tüneli değiştirmediğinizi veya yeniden düzenledikten sonra tüneli sondan çıkarmadığınızı düşünün.","code":""},{"path":"yaygın-hatalar.html","id":"kaynaklar-38","chapter":"47 Yaygın hatalar","heading":"47.3 Kaynaklar","text":"Bu bölüm, [yeni başlayanların karşılaştığı yaygın R programlama hatalarını] listeleyen başka bir blog gönderisidir(https://www.r-bloggers.com/2016/06/common-r-programming-errors-faced--beginners/)","code":""},{"path":"yardım-alma.html","id":"yardım-alma","chapter":"48 Yardım alma","heading":"48 Yardım alma","text":"Bu sayfa, bir Github sorunu göndererek veya çevrimiçi bir foruma tekrarlanabilir bir örnek (“reprex”) göndererek nasıl yardım alınacağını anlatmaktadır.","code":""},{"path":"yardım-alma.html","id":"github-sorunları","chapter":"48 Yardım alma","heading":"48.1 Github sorunları","text":"Birçok R paketi ve projesinin kodu Github.com web sitesinde barındırılmaktadır. Bir “Sorun” göndererek bu web sitesi aracılığıyla yazarlarla doğrudan iletişim kurabilirsiniz.Çalışmanızı Github’da nasıl saklayacağınızla ilgili daha fazla bilgiyi [İşbirliği ve Github] sayfasından okuyabilirsiniz.Github’da proje bir depo içinde bulunur. depoda kod, veri, çıktılar, yardım belgeleri vb. bulunur. Ayrıca “Sorunlar” adı verilen yazarlarla iletişim kurmak için bir araç da vardır.incidence2 paketi (salgın eğrileri oluşturmak için kullanılır) için Github sayfasının altına bakın. Sarı renkle vurgulanmış “Sorunlar” sekmesini görebilirsiniz. 5 tane açık konu olduğunu görebilirsiniz.Sorunlar sekmesinde, açık sorunları görebilirsiniz. Sorununuzun henüz ele alınmadığından emin olmak için bunları gözden geçirin. Sağdaki yeşil butona tıklayarak yeni bir konu açabilirsiniz. Bunu yapmak için bir Github hesabına ihtiyacınız olacak.Sorununuzla ilgili olarak, minimal, tekrarlanabilir bir örnek sağlamak için aşağıdaki talimatları izleyin. Ve lütfen nazik olun! R paketleri ve projeleri geliştiren çoğu kişi boş zamanlarında bunu yapıyor (bu el kitabı gibi!).Kendi Github deponuzdaki sorunları ele almayla ilgili daha gelişmiş materyalleri okumak için Github Sorunlarla ilgili belgelere bakabilirsiniz.","code":""},{"path":"yardım-alma.html","id":"tekrarlanabilir-örnek","chapter":"48 Yardım alma","heading":"48.2 Tekrarlanabilir örnek","text":"Tekrarlanabilir bir örnek (“reprex”) sağlamak, bir forumda veya Github sayısında gönderi yayınlarken yardım almanın anahtarıdır. İnsanlar sana yardım etmek istiyor ama onlara kendi bilgisayarlarında çalışabilecekleri bir örnek vermelisin. Bu örnekte:Karşılaştığınız sorunu gösterinMinimal olun, yalnızca sorununuzu yeniden oluşturmak için gereken verileri ve kodu gönderinTüm nesneler (ör. veri), paket çağrıları (ör. ‘library()’ veya ‘p_load()’) dahil edilecek şekilde tekrarlanabilir olsunAyrıca, reprex ile herhangi bir hassas veri göndermediğinizden emin olun! Örnek veri çerçeveleri oluşturabilir veya R’da yerleşik veri çerçevelerinden birini kullanabilirsiniz (bu veri kümelerinin bir listesini açmak için data() komutunu girin).","code":""},{"path":"yardım-alma.html","id":"reprex-paketi","chapter":"48 Yardım alma","heading":"reprex paketi","text":"reprex paketi, tekrarlanabilir bir örnek oluşturmanıza yardımcı olur:reprex, tidyverse ile kurulur, bu nedenle iki paketi de yüklemelisinizPaketleri ve verileri yüklemekten başlayarak adım adım sorununuzu oluşturan bir R betiği başlatın.Tüm kodu panonuza kopyalayın ve aşağıdaki komutu çalıştırın:RStudio Görüntüleyici bölmesinde bir HTML çıktısının göründüğünü göreceksiniz. Tüm kodunuzu ve tüm uyarıları, hataları veya çizim çıktılarını içerecektir. Bu çıktı aynı zamanda panonuza da kopyalanır, böylece doğrudan bir Github sorununa veya bir forum gönderisine gönderebilirsiniz.‘session_info = TRUE’ olarak ayarlarsanız, R paket sürümlerinize ‘sessioninfo::session_info()’ çıktısı dahil edilecektir.wd = için bir çalışma dizini sağlayabilirsiniz.Değişkenler ve olası varyasyonlar hakkında daha fazla bilgiyi documentation adresinden veya ?reprex girerek okuyabilirsiniz.Yukarıdaki örnekte, ‘ggplot()’ komutu, ‘date_format =’ değişkeni doğru olmadığı için çalışmadı - ‘date_labels =’ olmalı idi.","code":"\n# tidyverse kurun/yükleyin (reprex içerir)\npacman::p_load(tidyverse)\n# paketleri yükleyin\npacman::p_load(\n     tidyverse,  # veri yönetimi ve görselleştirme\n     outbreaks)  # salgın veri kümelerinin örneği\n\n# grip salgını vaka satır listesi\noutbreak_raw <- outbreaks::fluH7N9_china_2013  # salgın paketinden veri kümesini al\n\n# veri kümesini temizle\noutbreak <- outbreak_raw %>% \n     mutate(across(contains(\"date\"), as.Date))\n\n# salgın grafiğini çiz\n\nggplot(data = outbreak)+\n     geom_histogram(\n          mapping = aes(x = date_of_onset),\n          binwidth = 7\n     )+\n  scale_x_date(\n    date_format = \"%d %m\"\n  )\nreprex::reprex()"},{"path":"yardım-alma.html","id":"minimum-veri","chapter":"48 Yardım alma","heading":"Minimum veri","text":"Yardımcıların verilerinizi kullanabilmesi gerekir - ideal olarak verileri kodla oluşturabilmeleri gerekir.Minimum bir veri kümesi oluşturmak için, anonimleştirmeyi ve gözlemlerin yalnızca bir alt kümesini kullanmayı düşünün.YAPIM AŞAMASINDA… - minimal veri kümesi oluşturmak için ‘dput()’ fonksiyonunu da kullanabilirsiniz.","code":""},{"path":"yardım-alma.html","id":"bir-foruma-gönderme","chapter":"48 Yardım alma","heading":"48.3 Bir foruma gönderme","text":"Bol bol forum yazıları okuyun. Hangi gönderilerin iyi yazıldığını ve hangilerinin yazılmadığını anlayın.İlk olarak, soruyu sorup sormamaya karar verin. Sorunuzun daha önce sorulup sorulmadığını görmek için çeşitli arama terimlerini deneyerek forum web sitesini iyice incelediniz mi?İlk olarak, soruyu sorup sormamaya karar verin. Sorunuzun daha önce sorulup sorulmadığını görmek için çeşitli arama terimlerini deneyerek forum web sitesini iyice incelediniz mi?Sorunuza bilgilendirici bir başlık verin (“Yardım! Bu çalışmıyor” değil).Sorunuza bilgilendirici bir başlık verin (“Yardım! Bu çalışmıyor” değil).Sorunuzu yazın:Sorunuzu yazın:Durumunuzu ve probleminizi tanıtınBenzer sorunların gönderilerine bağlantı verin ve sorunuzu nasıl yanıtlamadıklarını açıklayınÇalışmanızın bağlamını bilmeyen birine yardımcı olmak için ilgili bilgileri ekleyinR oturum bilgilerinizle minimum tekrarlanabilir bir örnek verinDoğru yazım, dil bilgisi, noktalama işaretleri kullanın ve sorunuzu daha kolay okunabilmesi için paragraflara ayırınHerhangi bir açıklama talebine yanıt vermek için sorunuzu yayınladıktan sonra izleyin. Nazik ve kibar olun - yanıtlayan kişiler genellikle size yardım etmek için zamanlarını gönüllü olarak harcarlar. Takip eden bir sorunuz varsa, bunun ayrı bir soru olması gerekip gerekmediğini düşünün.Herhangi bir açıklama talebine yanıt vermek için sorunuzu yayınladıktan sonra izleyin. Nazik ve kibar olun - yanıtlayan kişiler genellikle size yardım etmek için zamanlarını gönüllü olarak harcarlar. Takip eden bir sorunuz varsa, bunun ayrı bir soru olması gerekip gerekmediğini düşünün.eğer isteği karşılayan bir yanıt alırsanız, soruyu yanıtlandı olarak işaretlemeyi unutmayın. Bu durum, başkalarının çözümü daha sonra hızlı bulmasına yardımcı olur.eğer isteği karşılayan bir yanıt alırsanız, soruyu yanıtlandı olarak işaretlemeyi unutmayın. Bu durum, başkalarının çözümü daha sonra hızlı bulmasına yardımcı olur.İyi bir soru nasıl sorulur hakkında Stackoverflow davranış kuralları hakkındaki bu yayınları okuyun.","code":""},{"path":"yardım-alma.html","id":"kaynaklar-39","chapter":"48 Yardım alma","heading":"48.4 Kaynaklar","text":"Nasıl [yardım alacağınız] hakkında Tidyverse sayfası!(https://www.tidyverse.org/help/#:~:text=%20you%20want%20to%20make,%20load%20the%20reprex%20package.&text=Enter%20reprex()%20in%20the,preview%20of%20your%20rendered%20reprex.)Minimum bir veri kümesi üretmeye ilişkin ipuçlarıdput fonksiyonu için belgeler","code":""},{"path":"ağ-sürücülerinde-r.html","id":"ağ-sürücülerinde-r","chapter":"49 Ağ sürücülerinde R","heading":"49 Ağ sürücülerinde R","text":"","code":""},{"path":"ağ-sürücülerinde-r.html","id":"genel-bakış-9","chapter":"49 Ağ sürücülerinde R","heading":"49.1 Genel Bakış","text":"R’ı ağda veya “şirket” ortak sürücülerinde kullanmak ek zorluklar ortaya çıkarabilir. Bu sayfa, bu sorunlar üzerinde çalışırken edindiğimiz deneyimlerden sorunları gidermeye yönelik yaklaşımları, yaygın hataları ve önerileri içerir. Bölüm ayrıca R Markdown’ı da içeren özellikle hassas durumlar için ipuçları içerir.Ağ Sürücülerinde R Kullanımı: Kapsamlı ilkelerBilgisayarınız için yönetici erişimi almalısınız. RStudio’yu özellikle yönetici olarak çalışacak şekilde kurun.Mümkün olduğunda paketleri harfli bir sürücüdeki (örneğin “C:”) bir kitaplığa kaydedin. Mümkün olduğunca az yolu “\\\" ile başlayan bir paket kitaplığı kullanın.rmarkdown paketi bir “\\\" paket kitaplığında olmamalıdır, çünkü bu durumda TinyTex veya Pandoc’bağlanamaz.","code":""},{"path":"ağ-sürücülerinde-r.html","id":"yönetici-olarak-rstudio","chapter":"49 Ağ sürücülerinde R","heading":"49.2 Yönetici olarak RStudio","text":"RStudio’yu açmak için RStudio simgesine tıkladığınızda, bunu sağ tıklatarak yapın. Makinenize bağlı olarak, “Yönetici Olarak Çalıştır” seçeneğini görebilirsiniz. Aksi takdirde, Özellikler’seçmek için bir seçenek görebilirsiniz (daha sonra “Uyumluluk” seçeneğinin olduğu bir pencere görünmelidir ve “Yönetici Olarak Çalıştır” onay kutusunu seçebilirsiniz).","code":""},{"path":"ağ-sürücülerinde-r.html","id":"faydalı-komutlar","chapter":"49 Ağ sürücülerinde R","heading":"49.3 Faydalı komutlar","text":"Aşağıda, ağ sürücülerinde R kullanarak sorunları gidermeye yarayan bazı yararlı komutlar verilmiştir.Yolları R’ın kullandığı paket kitaplıklarına döndürebilirsiniz. Bunlar, R’ın paketleri kurmak/yüklemek/aramak için kullandığı sırayla listelenecektir. Bu nedenle, R’ın farklı bir varsayılan kitaplık kullanmasını istiyorsanız, bu yolların sırasını değiştirebilirsiniz (aşağıya bakın).R tarafından kullanılan paket kitaplıklarının sırasını değiştirmek isteyebilirsiniz. Örneğin, R “\\\" ile başlayan ve büyük bir harfle başlayan bir kitaplık konumu alıyorsa, örn.”D:“. .libPaths() sırasını aşağıdaki kod ile ayarlayabilirsiniz.Pandoc’bağlanan R Markdown ile ilgili sorunlar yaşıyorsanız, RStudio’nun Pandoc kurulumunuzun nerede olduğunu düşündüğünü öğrenmek için bu kodla başlayın.Bir paketin hangi kütüphaneden yüklendiğini görmek istiyorsanız aşağıdaki kodu deneyin:","code":"\n# kitaplığı bul\n.libPaths()                   # R'ın yüklediği/aradığı sırayla listelenmiş kitaplık yollarınız.\n                              # Not: tüm kitaplıklar listelenecektir, ancak bazılarına (örneğin C :) yüklemek için\n                              # RStudio'yu yönetici olarak çalıştırmanız gerekebilir \n                              # (paket kitaplığı açılır menüsü yükleyin)\n# Kitaplıkların sırasını değiştir\n# bu, R'ın bir paket bulma önceliğini etkileyebilir. Örneğin. C: kitaplığınızın önce listelenmesini isteyebilirsiniz\nmyPaths <- .libPaths() # yolakları al\nmyPaths <- c(myPaths[2], myPaths[1]) # değiştir\n.libPaths(myPaths) # yeniden ata\n# Pandoc'u bul\nSys.getenv(\"RSTUDIO_PANDOC\")  # RStudio'nun Pandoc kurulumunuzun nerede olduğunu düşündüğünü bulun\n# bir paket bulun\n# paketin ilk konumunu verir (kütüphanelerinizin sırasını not edin)\nfind.package(\"rmarkdown\", lib.loc = NULL, quiet = FALSE, verbose = getOption(\"verbose\")) "},{"path":"ağ-sürücülerinde-r.html","id":"sık-karşılaşılan-hataları-giderme","chapter":"49 Ağ sürücülerinde R","heading":"49.4 Sık karşılaşılan hataları giderme","text":"“rmarkdown’da…tex derlenemedi”TinyTex kurulumunu kontrol edin veya TinyTex’C: konumuna kurun. TinyTex’nasıl kurulacağını öğrenmek için [R temelleri] sayfasına bakabilirsiniz.İnternet rutinleri yüklenemiyorÖrneğin, Error tools::startDynamicHelp() : internet rutinleri yüklenemiyorAraçlar/Global Seçenekler aracılığıyla RStudio’dan 32 bit sürümü seçmeyi deneyin.\n: Menüde 32 bit sürüm görünmüyorsa, RStudio v1.2’yi kullanmadığınızdan emin olun.\n: Menüde 32 bit sürüm görünmüyorsa, RStudio v1.2’yi kullanmadığınızdan emin olun.Alternatif olarak, R’ı kaldırıp farklı bir bit sürümüyle yeniden yüklemeyi deneyin (64 yerine 32)C: kitaplık paketleri manuel olarak yüklemeye çalıştığımda bir seçenek olarak görünmüyorRStudio’yu yönetici olarak çalıştırın, bu seçenek görünecektir.RStudio’yu zaman yönetici olarak çalışacak şekilde ayarlamak için Rstudio simgesine sağ tıklayınAşağıdaki resim, bir paketin kurulacağı kitaplığı manuel olarak nasıl seçebileceğinizi gösterir. Bu pencere, Paketler RStudio bölmesini açtığınızda ve “Yükle” yi tıkladığınızda görünür.Pandoc 1 hatasıAğ sürücülerinde R Markdowns komut dosyalarını örerken “pandoc hatası 1” alıyorsanız:Birden fazla kitaplık konumundan önce harfli sürücüye sahip olanı listeleyin (yukarıdaki kodlara bakın)Yukarıdaki çözüm, yerel sürücüde örerken ancak ağ bağlantılı bir internet bağlantısındayken işe yaradı.Burada daha fazla ipucu bulabilirsiniz: https://ciser.cornell.edu/rmarkdown-knit--html-word-pdf/Pandoc Hatası 83Hata şuna benzer: find file...rmarkdown...lua.... Bu, bu dosyayı bulamadığı anlamına gelir.https://stackoverflow.com/questions/58830927/rmarkdown-unable--locate-lua-filter--knitting--word ’e bakınOlasılıklar:Rmarkdown paketi kurulu değilRmarkdown paketi bulunamadıBir yönetici hakları sorunu.R’ın rmarkdown paket dosyasını bulamaması mümkündür, bu nedenle rmarkdown paketinin hangi kütüphanede olduğunu kontrol edin (yukarıdaki koda bakın). Paket, erişilemeyen (örneğin, “\\\" ile başlayan) bir kitaplığa kuruluysa, onu manuel olarak C:’ye veya başka bir adlandırılmış sürücü kitaplığına taşımayı düşünün. rmarkdown paketinin TinyTex kurulumuna bağlanabilmesi gerektiğini, bu nedenle bir ağ sürücüsündeki bir kitaplıkta yaşayamayacağını unutmayın.Pandoc Hatası 61Örneğin: Error: pandoc document conversion failed error 61 fetch...RStudio’yu yönetici olarak çalıştırmayı deneyin (simgeye sağ tıklayın, yönetici olarak çalıştır’ı seçin, yukarıdaki talimatlara bakın)Ayrıca ulaşılamayan belirli paketin C: kitaplığına taşınıp taşınamayacağına da bakın.LaTex hatası (aşağıya bakın)Şuna benzer bir hata: ! Package pdftex.def Error: File 'cict_qm2_2020-06-29_files/figure-latex/unnamed-chunk-5-1.png' found: using draft setting. Error: LaTeX failed compile file_name.tex.Hata ayıklama ipuçları için https://yihui.org/tinytex/r/#debugging adresine bakın.Daha fazla bilgi için file_name.log’bakın.Pandoc Hatası 127Bu bir RAM (boşluk) sorunu olabilir. R oturumunuzu yeniden başlatın ve tekrar deneyin.Ağ sürücülerini eşlemeBir ağ sürücüsünü eşlemek riskli olabilir. Bunu denemeden önce bilgi işlem departmanınıza danışın.Bu [forum tartışmasından] ödünç alınmış bir yorumdur: (https://stackoverflow.com/questions/48161177/r-markdown-openbinaryfile---exist---file--directory/55616529?noredirect=1#comment97966859_55616529):“Eşlenmiş bir ağ sürücüsü aracılığıyla” bir dosya nasıl açılır?Öncelikle, erişmeye çalıştığınız ağ konumunu bilmeniz gerekir.Ardından, Windows dosya yöneticisinde, sağdaki bölmede “Bu PC”ye sağ tıklamanız ve “Bir ağ sürücüsünü eşle”yi seçmeniz gerekecektir.Ağ konumunu daha önce harfli bir sürücü olarak tanımlamak için diyalogu gözden geçirin.Artık açtığınız dosyaya ulaşmanın iki yolu var. Sürücü harfi yolunu kullanmak işe yaramalıdır.install.packages() dosyasında hataBir “kilit” dizininden bahseden bir hata alırsanız, örneğin: Error install.packages : ERROR: failed lock directory...\nPaket kitaplığınıza baktığınızda adı “00LOCK” ile başlayan bir klasör göreceksiniz. Aşağıdakileri deneyin:“00LOCK” klasör dizinini paket kitaplığınızdan manuel olarak silin. Paketi yeniden yüklemeyi deneyin.Ayrıca pacman::p_unlock() komutunu da deneyebilirsiniz (bu komutu proje açıldığında çalışması için Rprofile’e de koyabilirsiniz.). Ardından paketi yeniden yüklemeyi deneyin. Birkaç deneme gerektirebilir.RStudio’yu Yönetici modunda çalıştırmayı deneyin ve paketleri tek tek yüklemeyi deneyin.Diğerleri başarısız olursa, paketi başka bir kitaplığa veya klasöre (örn. Temp) kurun ve ardından paketin klasörünü istenen kitaplığa manuel olarak kopyalayın.","code":"\n# tinytex'i kontrol edin/yükleyin, C: konumuna\ntinytex::install_tinytex()\ntinytex:::is_tinytex() #  DOĞRU döndürmelidir (üç kolonu da not alın)"},{"path":"veri-tablosu.html","id":"veri-tablosu","chapter":"50 Veri tablosu","heading":"50 Veri tablosu","text":"El kitabı, verileri temizleme ve gruplama yöntemi olarak dplyr “verb” fonksiyonlarına ve magrittr tünel operatörü %>% üzerine odaklanır, ancak data.table paketi kullanabileceğiniz bir alternatif mevcuttur.","code":""},{"path":"veri-tablosu.html","id":"veri-tablolarına-giriş","chapter":"50 Veri tablosu","heading":"50.1 Veri tablolarına giriş","text":"Bir veri tablosu, karmaşık gruplama işlemlerinin gerçekleştirilmesine izin veren bir veri çerçevesi gibi 2 boyutlu bir veri yapısıdır. data.table sözdizimi, satırlar, sütunlar ve gruplar üzerinde işlemler gerçekleştirilebilecek şekilde yapılandırılmıştır.Yapı DT[, j, ] şeklindedir ve 3 parça ile ayrılmıştır; , j ve değişkenleri. değişkeni gerekli satırların alt kümelenmesine, j değişkeni sütunlar üzerinde işlem yapmanıza ve değişkeni sütunlar üzerinde gruplara göre işlem yapmanıza olanak tanır.Bu sayfa aşağıdaki konuları ele alacaktır:Verileri içe aktarma ve fread() ve fwrite() kullanımıi değişkenini kullanarak satırları seçme ve filtreleme%like%, %chin%, %% yardımcı fonksiyonlarını kullanmaj değişkenini kullanarak sütunları seçme ve hesaplamaby değişkenini kullanan gruplara göre hesaplama:= kullanarak veri tablolarına veri ekleme ve güncelleme","code":""},{"path":"veri-tablosu.html","id":"paketleri-yükleyin-ve-verileri-içe-aktarın","chapter":"50 Veri tablosu","heading":"50.2 Paketleri yükleyin ve verileri içe aktarın","text":"","code":""},{"path":"veri-tablosu.html","id":"paketleri-yükleyin-8","chapter":"50 Veri tablosu","heading":"Paketleri yükleyin","text":"pacman’den p_load() fonksiyonunu kullanarak, bu analiz için gerekli paketleri yükleriz (ve gerekirse kurarız).","code":"\npacman::p_load(\n  rio,        # verileri içe aktarmak için\n  data.table, # verileri gruplamak ve temizlemek için\n  tidyverse,  # bu bölümde tünelleme (%>%) fonksiyonunun kullanılmasına izin verir\n  here \n  ) "},{"path":"veri-tablosu.html","id":"verileri-içe-aktar-8","chapter":"50 Veri tablosu","heading":"Verileri içe aktar","text":"Bu sayfa, el kitabında atıfta bulunulan vaka satır listesini kullanarak data.table’ın bazı temel fonksiyonlarını keşfedecektir.Simüle edilmiş bir Ebola salgınından vakaların veri setini içe aktarıyoruz. Adım adım izlenecek verileri indirmek istiyorsanız, [Kitap ve verileri indir] sayfasındaki talimatlara bakın. Veri kümesi, rio paketinden import() fonksiyonu kullanılarak içe aktarılır. Verileri içe aktarmanın çeşitli yolları için İçe ve dışa aktar hakkındaki sayfaya bakın. Buradan veri çerçevesini bir veri tablosuna dönüştürmek için data.table() kullanıyoruz.‘fread()’ fonksiyonu, .csv dosyaları gibi normal sınırlandırılmış dosyaları doğrudan bir veri tablosu biçimine içe aktarmak için kullanılır. Data.tables’ı düzenli sınırlandırılmış dosyalar olarak yazmak için kullanılan bu işlev ve muadili ‘fwrite()’, büyük veritabanları için çok hızlı ve hesaplama açısından verimli seçeneklerdir.“linelist”ilk 20 satırı:Veri çerçeveleri için kullanılan ‘dim()’ gibi R Tabanı komutları, veri tabloları için de kullanılabilir.","code":"\nlinelist <- rio::import(here(\"data\", \"linelist_cleaned.xlsx\")) %>% data.table()\ndim(linelist) #veri tablosundaki satır ve sütun sayısını verir## [1] 5888   30"},{"path":"veri-tablosu.html","id":"i-değişkeni-satırları-seçme-ve-filtreleme","chapter":"50 Veri tablosu","heading":"50.3 i değişkeni: satırları seçme ve filtreleme","text":"DT[, j, ] yapısını hatırlayarak, satır numaralarını veya mantıksal ifadeleri kullanarak satırları filtreleyebiliriz. değişkeni ilk; bu nedenle, DT[] veya DT[,] sözdizimi kullanılabilir.İlk örnek veri tablosunun ilk 5 satırını alır, ikinci örnek alt küme vakaları 18 yaş ve üzeridir ve üçüncü örnek alt kümeler 18 yaş veya üzeri ancak Merkez Hastanede teşhis edilmemiş vakaları içerir:bağımsız değişkeninde .N kullanılması, veri tablosundaki toplam satır sayısını temsil eder. Bu, satır numaralarını alt kümelemek için kullanılabilir:","code":"\nlinelist[1:5] #1.ila 5. satır arasını getirir\nlinelist[age >= 18] #alt küme vakaları 18 yaşa eşit veya daha büyük\nlinelist[age >= 18 & hospital != \"Central Hospital\"] #18 yaşına eşit veya daha büyük ancak Merkez Hastanede teşhis edilmemiş alt kümeler\nlinelist[.N] #son satırı getirir\nlinelist[15:.N] #15. satırdan son satıra kadar getirir"},{"path":"veri-tablosu.html","id":"filtreleme-için-yardımcı-fonksiyonları-kullanma","chapter":"50 Veri tablosu","heading":"Filtreleme için yardımcı fonksiyonları kullanma","text":"Veri tablosu, alt küme satırlarını kolaylaştıran yardımcı fonksiyonları kullanır. ‘%like%’ bir sütundaki kalıbı eşleştirmek için kullanılır, ‘%chin%’ belirli bir karakteri eşleştirmek için kullanılır ve ‘%%’ önceden belirlenmiş bir aralıktaki sayısal sütunları eşleştirmek için kullanılır.Aşağıdaki örneklerde:\n* hastane değişkeninin “Hastane” içerdiği satırları filtreleyin\n* sonucun “İyileşme” veya “Ölüm” olduğu satırları filtreleyin\n* 40-60 yaş aralığındaki satırları filtreleyin","code":"\nlinelist[hospital %like% \"Hospital\"] #hastane değişkeninin \"Hastane\" içerdiği satırları filtreleyin\nlinelist[outcome %chin% c(\"Recover\", \"Death\")] #sonucun \"İyileşme\" veya \"Ölüm\" olduğu satırları filtreleyin\nlinelist[age %between% c(40, 60)] #40-60 yaş aralığındaki satırları filtreleyin\n\n#%between% 2 uzunlukta bir vektör almalıdır, oysa %chin% >= 1 uzunlukta vektörler alabilir"},{"path":"veri-tablosu.html","id":"j-değişkeni-sütunları-seçme-ve-hesaplama","chapter":"50 Veri tablosu","heading":"50.4 j değişkeni: sütunları seçme ve hesaplama","text":"DT[, j, ] yapısını kullanarak sayıları veya isimleri kullanarak sütunları seçebiliriz. j değişkeni ikinci sıradadır; bu nedenle DT[, j] sözdizimi kullanılır. j değişkenindeki hesaplamaları kolaylaştırmak için, ‘list()’ ya da ‘.()’ kullanılarak sütun sarılır.","code":""},{"path":"veri-tablosu.html","id":"sütunları-seçme","chapter":"50 Veri tablosu","heading":"Sütunları seçme","text":"İlk örnek, veri tablosunun birinci, üçüncü ve beşinci sütunlarını alır; ikinci örnek, boy, ağırlık ve cinsiyet sütunları dışındaki tüm sütunları seçer. Üçüncü örnek, case_id ve outcome sütunlarını seçmek için .() sarmasını kullanır.","code":"\nlinelist[ , c(1,3,5)]\nlinelist[ , -c(\"gender\", \"age\", \"wt_kg\", \"ht_cm\")]\nlinelist[ , list(case_id, outcome)] #linelist[ , .(case_id, outcome)] aynı şekilde çalışır"},{"path":"veri-tablosu.html","id":"sütunlarda-hesaplama","chapter":"50 Veri tablosu","heading":"Sütunlarda hesaplama","text":"ve j değikenlerini birleştirerek, satırları filtrelemek ve sütunlarda hesaplama yapmak mümkündür. j değişkeninde .N kullanılması ayrıca veri tablosundaki toplam satır sayısını temsil eder ve satır filtrelemeden sonra satır sayısını döndürmek için yararlı olabilir.Aşağıdaki örneklerde:\n* Hastanede 7 günden fazla kalan vaka sayısını sayın\n* Askeri hastanede ölen vakaların yaş ortalamasını hesaplayın\n* Merkez hastanede iyileşen vakaların standart sapma, ortanca, yaş ortalamasını hesaplayınj değişkeninde .() sarma kullanmanın hesaplamayı kolaylaştırdığını, bir veri tablosu döndürdüğünü ve sütun adlandırmasına izin verdiğini unutmayın.","code":"\nlinelist[days_onset_hosp > 7 , .N]## [1] 189\nlinelist[hospital %like% \"Military\" & outcome %chin% \"Death\", .(mean(age, na.rm = T))] #na.rm = T siler N/A değerleri##         V1\n## 1: 15.9084\nlinelist[hospital == \"Central Hospital\" & outcome == \"Recover\", \n                 .(mean_age = mean(age, na.rm = T),\n                   median_age = median(age, na.rm = T),\n                   sd_age = sd(age, na.rm = T))] #bu sözdizimi yardımcı fonksiyonları kullanmaz ancak aynı şekilde çalışır##    mean_age median_age   sd_age\n## 1: 16.85185         14 12.93857"},{"path":"veri-tablosu.html","id":"değişkene-göre-gruplara-göre-hesaplama","chapter":"50 Veri tablosu","heading":"50.5 Değişkene göre: gruplara göre hesaplama","text":"değişkeni, DT[, j, ] yapısındaki üçüncü değişkendir. değişkeni hem bir karakter vektörünü hem de ‘list()’ veya ‘.()’ sözdizimini kabul eder. değişkeninde .() sözdizimini kullanmak, anında sütun yeniden adlandırılmasına izin verir.Aşağıdaki örneklerde:\n* vaka sayısını hastaneye göre gruplandırın\n* 18 yaş ve üzeri vakalarda cinsiyete göre vakaların ortalama boy ve kilolarını, iyileşip ölmediklerini hesaplayın\n* 7 günü aşan başvurularda, vaka sayısını yattığı aya ve yattığı hastaneye göre sayısını hesaplayınData.table ayrıca zincirleme ifadelere aşağıdaki gibi izin verir:Bu örneklerde, veri tablosundaki bir satırın yeni bir duruma eşit olduğu varsayımını izliyoruz ve bu nedenle veri tablosundaki satır sayısını temsil etmek için .N’yi kullanabiliriz. Benzersiz durumların sayısını temsil eden başka bir yararlı fonksiyon, belirli bir girdideki benzersiz değerlerin sayısını döndüren “uniqueN()” dir. Aşağıda gösterilmektedir:Cinsiyet sütunundaki benzersiz değerler m, f ve N/olduğundan cevap 3’tür. Belirli bir girdideki tüm benzersiz değerleri döndüren temel R fonksiyonu “unique()” ile karşılaştırın:Belirli bir aydaki benzersiz vakaların sayısını bulmak için aşağıdakileri yazarız:","code":"\nlinelist[, .N, .(hospital)] #hastaneye göre vaka sayıları##                                hospital    N\n## 1:                                Other  885\n## 2:                              Missing 1469\n## 3: St. Mark's Maternity Hospital (SMMH)  422\n## 4:                        Port Hospital 1762\n## 5:                    Military Hospital  896\n## 6:                     Central Hospital  454\nlinelist[age > 18, .(mean_wt = mean(wt_kg, na.rm = T),\n                             mean_ht = mean(ht_cm, na.rm = T)), .(gender, outcome)] #NAs, verilerin eksik olduğu kategorileri temsil eder##    gender outcome  mean_wt  mean_ht\n## 1:      m Recover 71.90227 178.1977\n## 2:      f   Death 63.27273 159.9448\n## 3:      m   Death 71.61770 175.4726\n## 4:      f    <NA> 64.49375 162.7875\n## 5:      m    <NA> 72.65505 176.9686\n## 6:      f Recover 62.86498 159.2996\n## 7:   <NA> Recover 67.21429 175.2143\n## 8:   <NA>   Death 69.16667 170.7917\n## 9:   <NA>    <NA> 70.25000 175.5000\nlinelist[days_onset_hosp > 7, .N, .(month = month(date_hospitalisation), hospital)]##     month                             hospital  N\n##  1:     5                    Military Hospital  3\n##  2:     6                        Port Hospital  4\n##  3:     7                        Port Hospital  8\n##  4:     8 St. Mark's Maternity Hospital (SMMH)  5\n##  5:     8                    Military Hospital  9\n##  6:     8                                Other 10\n##  7:     8                        Port Hospital 10\n##  8:     9                        Port Hospital 28\n##  9:     9                              Missing 27\n## 10:     9                     Central Hospital 10\n## 11:     9 St. Mark's Maternity Hospital (SMMH)  6\n## 12:    10                              Missing  2\n## 13:    10                    Military Hospital  3\n## 14:     3                        Port Hospital  1\n## 15:     4                    Military Hospital  1\n## 16:     5                                Other  2\n## 17:     5                     Central Hospital  1\n## 18:     5                              Missing  1\n## 19:     6                              Missing  7\n## 20:     6 St. Mark's Maternity Hospital (SMMH)  2\n## 21:     6                    Military Hospital  1\n## 22:     7                    Military Hospital  3\n## 23:     7                                Other  1\n## 24:     7                              Missing  2\n## 25:     7 St. Mark's Maternity Hospital (SMMH)  1\n## 26:     8                     Central Hospital  2\n## 27:     8                              Missing  6\n## 28:     9                                Other  9\n## 29:     9                    Military Hospital 11\n## 30:    10                        Port Hospital  3\n## 31:    10                                Other  4\n## 32:    10 St. Mark's Maternity Hospital (SMMH)  1\n## 33:    10                     Central Hospital  1\n## 34:    11                              Missing  2\n## 35:    11                        Port Hospital  1\n## 36:    12                        Port Hospital  1\n##     month                             hospital  N\nlinelist[, .N, .(hospital)][order(-N)][1:3] #1. tüm vakaları hastaneye göre seçer, 2. vakaları azalan sırayla sıralar, 3. en büyük vaka yüküne sahip 3 hastaneyi alt kümeler##             hospital    N\n## 1:     Port Hospital 1762\n## 2:           Missing 1469\n## 3: Military Hospital  896\nlinelist[, .(uniqueN(gender))] #hatırlayın .() j değişkeninde bir veri tablosu döndürür##    V1\n## 1:  3\nlinelist[, .(unique(gender))]##      V1\n## 1:    m\n## 2:    f\n## 3: <NA>\nlinelist[, .(uniqueN(case_id)), .(month = month(date_hospitalisation))]##     month   V1\n##  1:     5   62\n##  2:     6  100\n##  3:     7  198\n##  4:     8  509\n##  5:     9 1170\n##  6:    10 1228\n##  7:    11  813\n##  8:    12  576\n##  9:     1  434\n## 10:     2  310\n## 11:     3  290\n## 12:     4  198"},{"path":"veri-tablosu.html","id":"veri-tablolarına-ekleme-ve-güncelleme","chapter":"50 Veri tablosu","heading":"50.6 Veri tablolarına ekleme ve güncelleme","text":":= operatörü, bir veri tablosuna veri eklemek veya bu tabloya veri güncellemek için kullanılır. Veri tablonuza sütun eklemek aşağıdaki şekillerde yapılabilir:Daha karmaşık toplamalar bu giriş bölümünün kapsamı dışındadır, ancak buradaki fikir, verileri gruplama ve temizleme için dplyr’e popüler ve uygulanabilir bir alternatif sağlamaktır. data.table paketi, düzgün ve okunabilir koda izin veren harika bir pakettir.","code":"\nlinelist[, adult := age >= 18] #bir sütun ekler\nlinelist[, c(\"child\", \"wt_lbs\") := .(age < 18, wt_kg*2.204)] #birden çok sütun eklemek için c(\"\") ve list() veya .() sözdizimi gerekir\nlinelist[, `:=` (bmi_in_range = (bmi > 16 & bmi < 40),\n                         no_infector_source_data = is.na(infector) | is.na(source))] #bu yöntem :='yi fonksiyonel operatör olarak `:=` kullanır\nlinelist[, adult := NULL] #sütunu siler"},{"path":"veri-tablosu.html","id":"kaynaklar-40","chapter":"50 Veri tablosu","heading":"50.7 Kaynaklar","text":"https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.htmlhttps://github.com/Rdatatable/data.tablehttps://s3.amazonaws.com/assets.datacamp.com/img/blog/data+table+cheat+sheet.pdfhttps://www.machinelearningplus.com/data-manipulation/datatable--r-complete-guide/https://www.datacamp.com/community/tutorials/data-table-r-tutorialGruplandırılmış veriler üzerinde herhangi bir özet fonksiyonu gerçekleştirebilirsiniz; Daha fazla bilgi için buradaki pratik belgeye bakın:\nhttps://s3.amazonaws.com/assets.datacamp.com/blog_assets/datatable_Cheat_Sheet_R.pdf","code":""}]
